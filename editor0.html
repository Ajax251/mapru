<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ГеоРедактор</title>
    <link rel="stylesheet" href="webfonts/all.min.css">
    <link rel="icon" href="https://img.icons8.com/?size=100&id=HskCGIilF9IM&format=png&color=000000" type="image/png">
    <script src="webfonts/jszip.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>

    <style>
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            margin: 0;
            background-color: #f0f0f0;
            overflow: hidden;
        }

        #objectAnalysisContainer {
            position: fixed;
            left: 20%;
            top: 0;
            width: 80%;
            height: 100vh;
            background: white;
            z-index: 999;
        }

        #objectAnalysisCanvas {
            width: 100%;
            height: 100%;
            cursor: grab;
        }
         #objectAnalysisCanvas.drawing-mode {
             cursor: crosshair;
         }
         #objectAnalysisCanvas.editing-point-mode {
             cursor: move;
         }
         #objectAnalysisCanvas.geometry-edit-mode-add {
            cursor: cell;
         }
         #objectAnalysisCanvas.geometry-edit-mode-hover-point {
            cursor: pointer;
         }


        #infoPanel {
            position: fixed;
            top: 0;
            left: 0;
            width: 20%;
            height: 100vh;
            background-color: #f8f8f8;
            border-right: 1px solid #ddd;
            overflow-y: auto;
            z-index: 1000;
            padding: 20px;
            user-select: none;
            box-shadow: 2px 0 10px rgba(0,0,0,0.1);
        }

        .action-button {
            position: absolute;
            right: 20px;
            background-color: #4a69bd;
            color: white;
            border: none;
            padding: 10px;
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            width: 50px;
            height: 50px;
            font-size: 18px;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }
        .action-button:hover {
            transform: scale(1.1);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.3);
        }
         .action-button:active {
             transform: scale(0.95);
         }
         .action-button.active {
              box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
              transform: scale(0.98);
         }

        #addObjectBtn {
            bottom: 20px;
            background-color: #4a69bd;
        }
        #addObjectBtn:hover { background-color: #354f9e; }

        #drawObjectBtn {
             bottom: 80px;
             background-color: #f39c12;
         }
         #drawObjectBtn:hover { background-color: #e67e22; }
         #drawObjectBtn.active { background-color: #d35400; }

         #finishDrawingBtn {
             bottom: 80px;
             background-color: #2ecc71;
             display: none;
         }
         #finishDrawingBtn:hover { background-color: #27ae60; }

        #togglePointsBtn {
             bottom: 140px;
             background-color: #e74c3c;
         }
        #togglePointsBtn:hover { background-color: #c0392b; }

        #rulerBtn {
            bottom: 200px;
            background-color: #3498db;
        }
        #rulerBtn:hover { background-color: #2980b9; }
        #rulerBtn.active { background-color: #27ae60; }


               #toggleGeometryEditBtn {
            bottom: 260px;
            background-color: #9b59b6;
        }
        #toggleGeometryEditBtn:hover {
            background-color: #8e44ad; 
        }
        #toggleGeometryEditBtn.active {
            background-color: #e74c3c; 
        }
        #toggleGeometryEditBtn.active:hover {
            background-color: #c0392b; 
        }


        #undoGeometryChangeBtn {
            bottom: 320px;
            background-color: #e67e22;
            display: none;
        }
        #undoGeometryChangeBtn:hover { background-color: #d35400; }
        #undoGeometryChangeBtn:disabled {
            background-color: #bdc3c7;
            cursor: not-allowed;
            transform: scale(1);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }


        #measurementPanel {
            position: absolute;
            bottom: 80px;
            left: 20px;
            background-color: rgba(255, 255, 255, 0.9);
            padding: 10px 15px;
            border-radius: 5px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
            font-size: 14px;
            max-width: 300px;
            display: none;
            z-index: 1100;
        }
        #measurementPanel.active { display: block; animation: fadeIn 0.3s; }
        .measurement-title { font-weight: bold; margin-bottom: 8px; color: #2c3e50; display: flex; align-items: center; }
        .measurement-title i { margin-right: 5px; color: #3498db; }
        .measurement-coordinates { margin-bottom: 8px; padding-left: 10px; border-left: 3px solid #3498db; font-family: monospace; }
        .measurement-distance { font-weight: bold; color: #e74c3c; font-size: 16px; text-align: center; margin-top: 8px; padding: 5px; background-color: rgba(231, 76, 60, 0.1); border-radius: 3px; }
        #resetMeasurementBtn { background-color: #3498db; color: white; border: none; padding: 5px 10px; border-radius: 3px; margin-top: 8px; cursor: pointer; width: 100%; transition: background-color 0.3s; }
        #resetMeasurementBtn:hover { background-color: #2980b9; }

               #gridInfoPanel {
            position: absolute;
            bottom: 20px;
            left: calc(20% + 20px);
            background-color: rgba(255, 255, 255, 0.85);
            padding: 8px 12px;
            border-radius: 5px;
            font-size: 12px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            z-index: 1000;
            display: flex;
            align-items: center;
            pointer-events: none;
            transition: opacity 0.3s;
            opacity: 0.8;
            color: royalblue;
        }
        #gridInfoPanel i { margin-right: 5px; color: royalblue; }
        #gridInfoPanel:hover { opacity: 1; }

        #cursorInfoPanel {
            position: absolute;
            bottom: 20px;
            left: calc(20% + 150px);
            background-color: rgba(255, 255, 255, 0.85);
            padding: 8px 12px;
            border-radius: 5px;
            font-size: 12px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            z-index: 1000;
            display: flex;
            align-items: center;
            pointer-events: none;
            transition: opacity 0.3s;
            opacity: 0.8;
            color: royalblue;
        }
        #cursorInfoPanel i { margin-right: 5px; color: royalblue; }
        #cursorInfoPanel:hover { opacity: 1; }


        #selectedObjectInfo h3 {
            text-align: center;
            font-size: 1.2em;
            margin-bottom: 10px;
            color: #336699;
            border-bottom: 2px solid #336699;
            padding-bottom: 5px;
            font-weight: bold;
            cursor: pointer;
        }
         #selectedObjectInfo h3:hover {
             color: #4a69bd;
         }
        #selectedObjectInfo .info-item {
            display: flex;
            justify-content: space-between;
            padding: 6px 0;
            border-bottom: 1px solid #eee;
        }
        #selectedObjectInfo .info-item span:first-child {
            font-weight: bold;
            color: #555;
            margin-right: 10px;
        }
        #selectedObjectInfo .info-item span:last-child {
            color: #333;
            text-align: right;
        }
        #selectedObjectInfo .info-item span.copyable {
             cursor: pointer;
             transition: color 0.2s;
        }
         #selectedObjectInfo .info-item span.copyable:hover {
              color: #4a69bd;
         }
         .flash {
            animation: flash 0.5s;
        }
        @keyframes flash {
            0%, 100% { background-color: inherit; }
            50% { background-color: #90EE90; }
        }


        #coordsDialog {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 400px;
            background-color: white;
            border-radius: 10px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            z-index: 2000;
            padding: 20px;
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        @keyframes fadeInDialog { from { opacity: 0; transform: translate(-50%, -50%) scale(0.95); } to { opacity: 1; transform: translate(-50%, -50%) scale(1); } }
        #coordsDialog.show {
             opacity: 1;
             animation: fadeInDialog 0.3s ease-out forwards;
        }
        #coordsDialog h3 { margin: 0 0 15px; font-size: 18px; color: #333; }
        #coordsInput {
            width: 100%;
            height: 150px;
            padding: 8px;
            border: 1px solid #ccc;
            border-radius: 4px;
            box-sizing: border-box;
            resize: vertical;
            font-size: 14px;
            margin-bottom: 15px;
            transition: border-color 0.3s;
        }
        #coordsInput:focus { border-color: #4a69bd; box-shadow: 0 0 5px rgba(74, 105, 189, 0.5); outline: none; }
        .dialog-buttons { display: flex; justify-content: space-between; gap: 10px; }
        #importCoordsBtn, #importFromFileBtn, #closeDialogBtn {
            background-color: #4a69bd;
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s;
            flex: 1;
            font-size: 14px;
            position: relative;
            overflow: hidden;
        }
        #importCoordsBtn:hover, #importFromFileBtn:hover {
            background-color: #354f9e;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }
        #importCoordsBtn:active, #importFromFileBtn:active, #closeDialogBtn:active {
            transform: translateY(1px);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        #closeDialogBtn { background-color: #dc3545; }
        #closeDialogBtn:hover { background-color: #c82333; transform: translateY(-2px); box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2); }

        #dialogOverlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0);
            z-index: 1999;
            backdrop-filter: blur(0px);
            opacity: 0;
            transition: opacity 0.3s ease, background-color 0.3s ease, backdrop-filter 0.3s ease;
        }
        #dialogOverlay.show {
             opacity: 1;
             background-color: rgba(0, 0, 0, 0.5);
             backdrop-filter: blur(2px);
        }


        #tooltip {
            position: absolute;
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 12px;
            pointer-events: none;
            z-index: 1001;
            display: none;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
            font-weight: bold;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
        }

        .notification {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 15px 20px;
            border-radius: 5px;
            color: white;
            font-size: 14px;
            z-index: 9999;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            transform: translateX(120%);
            transition: transform 0.3s ease;
            max-width: 300px;
            border: 1px solid rgba(0, 0, 0, 0.1);
            text-shadow: 0 0 2px rgba(0, 0, 0, 0.5);
        }
        .notification.info { background-color: #3498db; }
        .notification.success { background-color: #4CAF50; }
        .notification.error { background-color: #F44336; }
        .notification.warning { background-color: #FF9800; }
        .notification.show { transform: translateX(0); }
        .notification i { margin-right: 10px; }

        #loaderContainer {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background-color: rgba(173, 216, 230, 0.9);
            display: none; justify-content: center; align-items: center;
            z-index: 10000; backdrop-filter: blur(3px); flex-direction: column;
        }
        .spinner-container { width: 80px; height: 80px; position: relative; }
        .spinner-ring { position: absolute; width: 100%; height: 100%; border-radius: 50%; border: 6px solid transparent; border-top-color: #3498db; animation: spin 1.2s cubic-bezier(0.5, 0, 0.5, 1) infinite; box-sizing: border-box; }
        .spinner-ring:before, .spinner-ring:after { content: ''; position: absolute; border-radius: 50%; border: 6px solid transparent; box-sizing: border-box; }
        .spinner-ring:before { top: -6px; left: -6px; right: -6px; bottom: -6px; border-top-color: #2980b9; animation: spin 2s cubic-bezier(0.5, 0, 0.5, 1) infinite; }
        .spinner-ring:after { top: 6px; left: 6px; right: 6px; bottom: 6px; border-top-color: #6ab7e2; animation: spin 0.8s cubic-bezier(0.5, 0, 0.5, 1) infinite; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        .loading-text { color: #2c3e50; font-size: 18px; font-weight: bold; margin-top: 30px; letter-spacing: 1px; text-shadow: 0 1px 2px rgba(255, 255, 255, 0.5); animation: pulse 1.5s ease infinite; text-align: center; line-height: 1.5; min-height: 50px; }
        @keyframes pulse { 0%, 100% { opacity: 0.7; } 50% { opacity: 1; } }

        .coordinates-table {
            width: 100%; border-collapse: collapse; margin-top: 15px;
            animation: fadeInCoords 0.3s ease;
        }
        @keyframes fadeInCoords {
            from { opacity: 0; transform: translateY(-10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .coordinates-table th, .coordinates-table td { border: 1px solid #ddd; padding: 8px; text-align: center; }
        .coordinates-table th { background-color: #f2f2f2; }
        .coordinate-row { cursor: pointer; transition: background-color 0.3s; }
        .coordinate-row:hover { background-color: #f0f8ff; }
        .coordinate-row.selected-coordinate { background-color: #ffebee !important; border-left: 3px solid #f44336; font-weight: bold; }
        .coordinate-row .copyable { cursor: pointer; }

        .panel-button {
            margin-top: 10px; width: 100%; padding: 10px; color: white;
            border: none; border-radius: 5px; cursor: pointer; transition: all 0.3s;
            display: flex; align-items: center; justify-content: center;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
        .panel-button:hover { transform: translateY(-2px); box-shadow: 0 4px 8px rgba(0,0,0,0.3); }
        .panel-button:active { transform: translateY(1px); box-shadow: 0 1px 2px rgba(0,0,0,0.2); }
        .panel-button i { margin-right: 8px; }

        #showCoordinatesBtn { background-color: #4a69bd; margin-bottom: 10px; }
        #showCoordinatesBtn:hover { background-color: #354f9e; }

        #copyAllCoordinatesBtn {
            background-color: #1abc9c;
            margin-bottom: 10px;
        }
        #copyAllCoordinatesBtn:hover {
            background-color: #16a085;
        }

        #centerObjectBtn { background-color: #2ecc71; margin-bottom: 10px; }
        #centerObjectBtn:hover { background-color: #27ae60; }
        #renameObjectBtn { background-color: #f39c12; margin-bottom: 10px; }
        #renameObjectBtn:hover { background-color: #e67e22; }
        #deleteObjectBtn { background-color: #e74c3c; }
        #deleteObjectBtn:hover { background-color: #c0392b; }


        .panel-section {
            padding-bottom: 15px;
            margin-bottom: 15px;
            border-bottom: 1px solid #ddd;
        }
        .panel-section:last-child { border-bottom: none; margin-bottom: 0; }
        .section-title {
            background-color: #4a69bd; color: white; padding: 8px 12px;
            border-radius: 4px; margin-top: 15px; margin-bottom: 10px;
            font-weight: bold; position: relative; overflow: hidden;
            font-size: 0.9em;
        }
        .section-title i { margin-right: 8px; }

        #intersectionList {
            list-style: none; padding: 0; margin-top: 10px;
        }
        #intersectionList li {
            padding: 8px 12px; border: 1px solid #ddd; margin-bottom: 5px;
            border-radius: 4px; background-color: #fff; cursor: pointer;
            transition: all 0.2s; position: relative; overflow: hidden;
            font-size: 0.9em;
        }
        #intersectionList li:hover {
            background-color: #f0f0f0; transform: translateX(5px);
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        #intersectionList li:before {
            content: ''; position: absolute; left: 0; top: 0; height: 100%;
            width: 3px; background-color: #4a69bd; transform: scaleY(0);
            transition: transform 0.2s;
        }
        #intersectionList li:hover:before { transform: scaleY(1); }
         #intersectionList li.full-containment { border-left: 3px solid #27ae60; background-color: #e8f8f5; }
         #intersectionList li.contained-by { border-left: 3px solid #af7ac5; background-color: #f4ecf7; }
         #intersectionList li.partial-overlap { border-left: 3px solid #f39c12; background-color: #fef9e7; }
         #intersectionList li .overlap-details { font-size: 0.8em; color: #666; margin-top: 3px; display: block; }

        #objectListContainer { max-height: 250px; overflow-y: auto; }
        #objectList li {
             padding: 5px 8px; margin-bottom: 3px; border-radius: 3px;
             cursor: pointer; display: flex; align-items: center;
             border: 1px solid transparent; transition: background-color 0.2s, border-color 0.2s;
             font-size: 0.9em;
        }
         #objectList li:hover { background-color: #f0f0f0; }
         #objectList li.selected { background-color: #e0f2f7; border-color: #b3e5fc; font-weight: bold; }
         #objectList li .color-indicator {
             display: inline-block; width: 12px; height: 12px; border-radius: 3px;
             margin-right: 8px; flex-shrink: 0; border: 1px solid #ccc;
         }
         #objectList li .name-span {
             flex-grow: 1; overflow: hidden; white-space: nowrap; text-overflow: ellipsis;
         }


        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-10px); }
            to { opacity: 1; transform: translateY(0); }
        }


        #namePromptOverlay {
            display: none;
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background-color: rgba(0, 0, 0, 0.4);
            z-index: 2999;
            backdrop-filter: blur(1.5px);
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        #namePromptOverlay.show {
            opacity: 1;
            display: block;
        }

        #namePromptDialog {
            display: none;
            position: fixed;
            top: 40%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0.95);
            width: 350px;
            background-color: white;
            border-radius: 10px;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.25);
            z-index: 3000;
            padding: 25px;
            opacity: 0;
            transition: opacity 0.3s ease, transform 0.3s ease;
            box-sizing: border-box;
        }

        #namePromptDialog.show {
            opacity: 1;
            transform: translate(-50%, -50%) scale(1);
            display: block;
        }

        #namePromptDialog h3 {
            margin: 0 0 20px;
            font-size: 1.2em;
            color: #333;
            text-align: center;
            font-weight: 600;
        }

        #namePromptInput {
            width: 100%;
            padding: 12px 10px;
            border: 1px solid #ccc;
            border-radius: 5px;
            box-sizing: border-box;
            font-size: 1em;
            margin-bottom: 20px;
            transition: border-color 0.3s, box-shadow 0.3s;
        }
        #namePromptInput:focus {
            border-color: #4a69bd;
            box-shadow: 0 0 0 3px rgba(74, 105, 189, 0.2);
            outline: none;
        }
        #namePromptDialog .dialog-buttons {
            justify-content: space-between;
        }

        #namePromptSaveBtn, #namePromptCancelBtn {
            background-color: #4a69bd;
            color: white; border: none; padding: 10px 15px; border-radius: 5px;
            cursor: pointer; transition: all 0.3s; flex-basis: 48%;
            font-size: 0.95em; display: flex; align-items: center; justify-content: center; gap: 5px;
        }
        #namePromptSaveBtn:hover { background-color: #354f9e; transform: translateY(-1px); }
        #namePromptSaveBtn:active { transform: translateY(0px); }

        #namePromptCancelBtn {
            background-color: #6c757d;
        }
        #namePromptCancelBtn:hover { background-color: #5a6268; transform: translateY(-1px); }
        #namePromptCancelBtn:active { transform: translateY(0px); }

         #viewInfoPanel {
            position: absolute;
            bottom: 20px;
            left: calc(20% + 420px);
            background-color: rgba(255, 255, 255, 0.85);
            padding: 8px 12px;
            border-radius: 5px;
            font-size: 12px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            z-index: 1000;
            display: flex;
            align-items: center;
            pointer-events: none;
            transition: opacity 0.3s;
            opacity: 0.8;
            color: #27ae60;
            white-space: nowrap;
        }
        #viewInfoPanel i {
             margin-right: 5px;
             color: #27ae60;
         }
        #viewInfoPanel:hover {
             opacity: 1;
         }
         
           @media (max-width: 768px) {
            /* Перемещаем кнопки действий в правый верхний угол на мобильных */
            .action-button {
                /* Обнуляем bottom, чтобы top сработал */
                bottom: auto !important; /* Используем !important для переопределения инлайновых стилей, если они есть, или высокой специфичности */
            }

            #addObjectBtn {
                top: 20px;
            }
            #drawObjectBtn, #finishDrawingBtn { /* finishDrawingBtn делит место с drawObjectBtn */
                top: 80px;
            }
            #togglePointsBtn {
                top: 140px;
            }
            #rulerBtn {
                top: 200px;
            }
            #toggleGeometryEditBtn {
                top: 260px;
            }
            #undoGeometryChangeBtn {
                top: 320px;
            }

            /* Если информационные панели снизу мешают кнопкам, их тоже можно сдвинуть */
            /* Например, если они накладываются */
            /*
            #gridInfoPanel, #cursorInfoPanel, #viewInfoPanel {
                bottom: auto;
                top: 20px;
            }
            #gridInfoPanel { left: 20px; }
            #cursorInfoPanel { left: 150px; }
            #viewInfoPanel { left: 280px; }
            */
        }

    </style>
</head>
<body>

<div id="infoPanel">
    <div class="panel-section">
        <h4>Информация об объекте</h4>
        <div id="selectedObjectInfo">
            <p style="color: #777; font-style: italic; text-align: center;">Выберите объект на схеме (двойной клик) или добавьте новый.</p>
        </div>
        <div id="coordinatesTableContainer"></div>
    </div>

    <div class="panel-section">
        <div class="section-title" style="display: none;" id="intersectionsTitle">
            <i class="fas fa-vector-square"></i> Пересечения и Наложения
        </div>
        <div id="intersectionsContainer">
            <ul id="intersectionList"></ul>
        </div>
    </div>

    <div class="panel-section">
        <div class="section-title">
            <i class="fas fa-list"></i> Список объектов (<span id="objectCount">0</span>)
        </div>
        <div id="objectListContainer">
            <ul id="objectList"></ul>
        </div>
    </div>
</div>

<div id="objectAnalysisContainer">
    <canvas id="objectAnalysisCanvas"></canvas>
    <button id="addObjectBtn" class="action-button" title="Добавить объект из координат">
        <i class="fas fa-plus"></i>
    </button>
    <button id="drawObjectBtn" class="action-button" title="Нарисовать объект">
        <i class="fas fa-pencil-alt"></i>
    </button>
    <button id="finishDrawingBtn" class="action-button" title="Завершить создание объекта">
        <i class="fas fa-check"></i>
    </button>
    <button id="togglePointsBtn" class="action-button" title="Показать/скрыть точки">
        <i class="fas fa-map-marker-alt"></i>
    </button>
    <button id="rulerBtn" class="action-button" title="Измерить расстояние">
        <i class="fas fa-ruler"></i>
    </button>
    <button id="toggleGeometryEditBtn" class="action-button" title="Редактировать геометрию">
        <i class="fas fa-edit"></i>
    </button>
    <button id="undoGeometryChangeBtn" class="action-button" title="Отменить изменение геометрии">
        <i class="fas fa-undo"></i>
    </button>


    <div id="measurementPanel">
        <div class="measurement-title"><i class="fas fa-ruler"></i> Измерение</div>
        <div class="measurement-coordinates" id="measurementCoordinates">...</div>
        <div class="measurement-distance" id="measurementDistance">Расстояние: -</div>
        <button id="resetMeasurementBtn">Сбросить</button>
    </div>

    <div id="gridInfoPanel">
        <i class="fas fa-th"></i>
        <span id="gridStepText"></span>
    </div>
    <div id="cursorInfoPanel">
        <i class="fas fa-mouse-pointer"></i>
        <span id="cursorCoordinates">X: 0.00, Y: 0.00</span>
    </div>
      <div id="viewInfoPanel">
        <i class="fas fa-ruler-horizontal"></i>
        <span id="viewInfoText">Обзор: -</span>
    </div>
</div>

<div id="tooltip"></div>

<div id="dialogOverlay"></div>
<div id="coordsDialog">
    <h3>Добавить объект</h3>
    <textarea id="coordsInput" placeholder="Вставьте координаты (X Y или Y X на каждой строке, разделенные пробелом/табуляцией) ИЛИ список кадастровых номеров (каждый на новой строке)."></textarea>
    <div class="dialog-buttons">
        <button id="importCoordsBtn">
            <i class="fas fa-cloud-download-alt"></i> Загрузить и Добавить
        </button>
        <button id="importFromFileBtn" title="Импорт координат из TXT/CSV файла (X Y или Y X)">
            <i class="fas fa-file-upload"></i> Файл (X Y)
        </button>
        <button id="closeDialogBtn">
            <i class="fas fa-times"></i> Закрыть
        </button>
    </div>
</div>

<div id="loaderContainer">
  <div class="spinner-container">
    <div class="spinner-ring"></div>
  </div>
  <div class="loading-text">Загрузка...</div>
</div>


<div id="namePromptOverlay"></div>
<div id="namePromptDialog">
    <h3 id="namePromptTitle">Имя объекта</h3>
    <input type="text" id="namePromptInput" placeholder="Введите имя...">
    <div class="dialog-buttons">
        <button id="namePromptSaveBtn">
            <i class="fas fa-check"></i> Сохранить
        </button>
        <button id="namePromptCancelBtn">
            <i class="fas fa-times"></i> Отмена
        </button>
    </div>
</div>

<script>

     let userObjects = [];
    let selectedObjectIndex = -1;
    let nextObjectId = 1;
    const objectColors = [ '#FF6347', '#4682B4', '#32CD32', '#FFD700', '#6A5ACD', '#FF4500', '#1E90FF', '#ADFF2F', '#DAA520', '#8A2BE2', '#DC143C', '#00CED1', '#9ACD32', '#FF8C00', '#9932CC' ];
    let nextColorIndex = 0;

    let scale = 1;
    let offsetX = 0;
    let offsetY = 0;
    let minX = undefined, minY = undefined, maxX = undefined, maxY = undefined;

    let isDragging = false;
    let startX, startY;
    let lastOffsetX = 0, lastOffsetY = 0;
    let selectedCoordinate = null;
    let showPoints = true;

    let rulerMode = false;
    let rulerPoints = [];
    let isDrawingMode = false;
    let isDrawingActive = false;
    let currentDrawingPoints = [];
    let currentMousePos = { x: 0, y: 0 };

    let isGeometryEditMode = false;
    let editingObjectIndex = -1;
    let isMovingPoint = false;
    let movedPointInfo = null;
    let snappedToPointVisual = null;
    let geometryHistory = [];
    const MAX_GEOMETRY_HISTORY = 10;

    const SNAP_RADIUS_SCREEN = 10;
    const ADD_POINT_THRESHOLD_SCREEN = 7;
    const GRAB_POINT_RADIUS_SCREEN = 7;
    window.lastPointMoveEndTime = 0;

    const SUPABASE_URL = 'https://krbqraivfbowmzvucjxz.supabase.co';
    const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImtyYnFyYWl2ZmJvd216dnVjanh6Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDU1MDA0MTAsImV4cCI6MjA2MTA3NjQxMH0.Aun2UJDEW_75_Di-2hIcap42gqyZAu2XY9xiZpmShPc';
    const BUCKET_NAME = 'gkn';
    let supabase = null;
    const sevenDigitsRegions = ['24', '50', '63', '66', '77', '78', '91'];


    const canvas = document.getElementById('objectAnalysisCanvas');
    const ctx = canvas.getContext('2d');
    const tooltip = document.getElementById('tooltip');
    const selectedObjectInfoDiv = document.getElementById('selectedObjectInfo');
    const coordinatesTableContainer = document.getElementById('coordinatesTableContainer');
    const intersectionsTitle = document.getElementById('intersectionsTitle');
    const intersectionList = document.getElementById('intersectionList');
    const objectListUL = document.getElementById('objectList');
    const objectCountSpan = document.getElementById('objectCount');
    const coordsDialog = document.getElementById('coordsDialog');
    const dialogOverlay = document.getElementById('dialogOverlay');
    const coordsInput = document.getElementById('coordsInput');
    const gridInfoText = document.getElementById('gridStepText');
    const cursorCoordinates = document.getElementById('cursorCoordinates');
    const measurementPanel = document.getElementById('measurementPanel');
    const measurementCoordinates = document.getElementById('measurementCoordinates');
    const measurementDistance = document.getElementById('measurementDistance');
    const loaderContainer = document.getElementById('loaderContainer');
    const loaderTextElement = loaderContainer.querySelector('.loading-text');
    const drawObjectBtn = document.getElementById('drawObjectBtn');
    const finishDrawingBtn = document.getElementById('finishDrawingBtn');
    const namePromptDialog = document.getElementById('namePromptDialog');
    const namePromptOverlay = document.getElementById('namePromptOverlay');
    const namePromptTitle = document.getElementById('namePromptTitle');
    const namePromptInput = document.getElementById('namePromptInput');
    const viewInfoText = document.getElementById('viewInfoText');
    const toggleGeometryEditBtn = document.getElementById('toggleGeometryEditBtn');
    const undoGeometryChangeBtn = document.getElementById('undoGeometryChangeBtn');
    const rulerBtn = document.getElementById('rulerBtn');
    
    const nextObjectIdPlaceholder = "%%NEXT_OBJECT_ID_PLACEHOLDER%%"; // Для временных имен


    function roundCoord(value) {
        if (!isFinite(value)) return value;
        return parseFloat(value.toFixed(2));
    }

    function updateObjectMetrics(obj) {
        if (!obj || !obj.contours || obj.contours.length === 0) {
            obj.area = 0;
            obj.perimeter = 0;
            return;
        }
        // Ensure all points in contours are rounded and contours are closed if polygon
        obj.contours.forEach((contour, cIdx) => {
            if (contour) {
                for(let i=0; i < contour.length; i++) {
                    if(contour[i]) {
                        contour[i].x = roundCoord(contour[i].x);
                        contour[i].y = roundCoord(contour[i].y);
                    }
                }
                // Auto-close polygon contours if not already closed
                if (obj.type === 'polygon' && contour.length >= 3) {
                    const firstPt = contour[0];
                    const lastPt = contour[contour.length - 1];
                    const PRECISION_THRESHOLD = 0.001;
                    if (!(Math.abs(firstPt.x - lastPt.x) < PRECISION_THRESHOLD && Math.abs(firstPt.y - lastPt.y) < PRECISION_THRESHOLD)) {
                        contour.push({ x: firstPt.x, y: firstPt.y });
                    }
                }
            }
        });

        const isPolygon = obj.type === 'polygon';
        // For simplicity, calculate area/perimeter based on the first contour.
        // Proper multi-contour area would subtract inner holes.
        obj.area = isPolygon && obj.contours[0] ? calculatePolygonArea(obj.contours[0]) : 0;
        obj.perimeter = obj.contours[0] ? calculatePolygonPerimeter(obj.contours[0], isPolygon) : 0;

        // If multi-contour, sum perimeters (approximation for non-nested)
        if (obj.contours.length > 1) {
            obj.perimeter = 0;
            obj.contours.forEach(c => {
                obj.perimeter += calculatePolygonPerimeter(c, isPolygon);
            });
            obj.perimeter = roundCoord(obj.perimeter);
        }
    }


    function deepCloneContours(contours) {
        if (!contours) return [];
        return contours.map(contour => {
            if (!contour) return null;
            return contour.map(p => (p ? { ...p } : null));
        });
    }

    function saveGeometryStateForUndo(objIndex) {
        if (objIndex < 0 || objIndex >= userObjects.length || !userObjects[objIndex]) return;
        const obj = userObjects[objIndex];
        geometryHistory.push(deepCloneContours(obj.contours));
        if (geometryHistory.length > MAX_GEOMETRY_HISTORY) {
            geometryHistory.shift();
        }
        updateUndoButtonState();
    }

    function undoLastGeometryChange() {
        if (!isGeometryEditMode || editingObjectIndex === -1 || geometryHistory.length === 0) return;
        const obj = userObjects[editingObjectIndex];
        if (!obj) return;

        const previousContours = geometryHistory.pop();
        if (previousContours) {
            obj.contours = previousContours;
            updateObjectMetrics(obj);
            displayObjectInfo(editingObjectIndex);
            redraw(true);
            saveState();
            showNotification("Действие отменено", "info", "undo");
        }
        updateUndoButtonState();
    }

    function updateUndoButtonState() {
        if (isGeometryEditMode && editingObjectIndex !== -1) {
            undoGeometryChangeBtn.style.display = 'flex';
            undoGeometryChangeBtn.disabled = geometryHistory.length === 0;
        } else {
            undoGeometryChangeBtn.style.display = 'none';
            undoGeometryChangeBtn.disabled = true;
        }
    }



    function loadState() {
        try {
            const savedStateJSON = localStorage.getItem('geoAnalyzerState');
            if (savedStateJSON) {
                const state = JSON.parse(savedStateJSON);
                // Фильтруем null/undefined объекты, которые могли сохраниться из-за ошибки
                userObjects = (state.userObjects || []).filter(o => o && o.id && o.contours);
                nextObjectId = state.nextObjectId || 1;
                nextColorIndex = state.nextColorIndex || 0;
                showPoints = state.showPoints === undefined ? true : state.showPoints;

                if (state.view && state.view.minX !== undefined && isFinite(state.view.scale)) {
                    scale = state.view.scale;
                    offsetX = state.view.offsetX;
                    offsetY = state.view.offsetY;
                    minX = state.view.minX;
                    minY = state.view.minY;
                    maxX = state.view.maxX;
                    maxY = state.view.maxY;
                    if (!hasValidView()) {
                        console.warn("Загруженное состояние вида невалидно, сброс.");
                        calculateBounds(); // Рассчитать границы на основе загруженных объектов
                        resetView();     // Затем сбросить вид
                    }
                } else {
                    calculateBounds();
                    resetView();
                }
                console.log("Состояние загружено из localStorage.");
            } else {
                userObjects = []; // Инициализация, если состояния нет
                nextObjectId = 1;
                nextColorIndex = 0;
                showPoints = true;
                calculateBounds();
                resetView();
                console.log("Сохраненное состояние не найдено, начинаем с чистого листа.");
            }
        } catch (e) {
            console.error("Ошибка загрузки состояния:", e);
            userObjects = []; // Сброс при ошибке
            nextObjectId = 1;
            nextColorIndex = 0;
            showPoints = true;
            calculateBounds();
            resetView();
            showNotification("Ошибка загрузки сохраненного состояния. Начинаем с чистого листа.", "warning", "hdd");
        }
        // Обновление метрик объектов после загрузки
        userObjects.forEach(obj => updateObjectMetrics(obj));
    }

 async function initializeApp() { // Сделана асинхронной
        try {
            if (window.supabase && typeof window.supabase.createClient === 'function') {
                supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
                console.log("Supabase client initialized.");
            } else {
                throw new Error("Supabase client library not loaded.");
            }
        } catch (error) {
            console.error("Supabase initialization error:", error);
            showNotification("Ошибка инициализации базы данных. Загрузка по КН не будет работать.", "error", "database");
        }
        canvas.width = canvas.offsetWidth;
        canvas.height = canvas.offsetHeight;

        loadState(); // 1. Загрузка сохраненного состояния

        // 2. Проверка буфера обмена. Если успешно и пользователь согласен, userObjects будут очищены и заполнены заново.
        const clipboardImported = await checkClipboardForObjects();

        // 3. Обновление UI и состояния
        // Если из буфера не было импорта, то userObjects остаются те, что из loadState.
        // Если был импорт, userObjects уже обновлены.
        updateObjectList();
        setupEventListeners();

        if (userObjects.length > 0 && (!hasValidView() || clipboardImported)) {
             calculateBounds();
             resetView();
        } else if (userObjects.length === 0) {
            calculateBounds();
            resetView();
        }

        redraw(false);
        updateViewInfo();
        updateToggleButtonStates();
        updateUndoButtonState();
    }

    const cMinXGlob = () => (minX === undefined || !isFinite(minX)) ? 0 : minX;
    const cMinYGlob = () => (minY === undefined || !isFinite(minY)) ? 0 : minY;

    function calculateBounds() {
        const canvasWidth = canvas.width || 100;
        const canvasHeight = canvas.height || 100;

        if (userObjects.length === 0) {
             minX = 0; minY = 0; maxX = canvasWidth; maxY = canvasHeight;
             return;
         }

         let currentMinX = Infinity, currentMinY = Infinity, currentMaxX = -Infinity, currentMaxY = -Infinity;
         let hasValidPoints = false;
         userObjects.forEach(obj => {
             if (!obj || !obj.contours) return;
             obj.contours.forEach(contour => {
                 if (!contour) return;
                 contour.forEach(p => {
                     if (p && isFinite(p.x) && isFinite(p.y)) {
                         currentMinX = Math.min(currentMinX, p.x); currentMinY = Math.min(currentMinY, p.y);
                         currentMaxX = Math.max(currentMaxX, p.x); currentMaxY = Math.max(currentMaxY, p.y);
                         hasValidPoints = true;
                     }
                 });
             });
         });

         if (hasValidPoints && isFinite(currentMinX)) {
            minX = currentMinX; minY = currentMinY; maxX = currentMaxX; maxY = currentMaxY;
         } else {
              minX = 0; minY = 0; maxX = canvasWidth; maxY = canvasHeight;
         }
    }
    
function processSingleObjectBlock(blockLines, defaultNameBase = "Объект") {
        if (blockLines.length === 0) return null;

        let objectName;
        let coordinateLinesStartIdx = 0;

        const firstLine = blockLines[0].trim();

        // 1. Проверяем, является ли первая строка валидным кадастровым номером
        if (isValidCadastralNumberFormat(firstLine)) {
            objectName = firstLine;
            coordinateLinesStartIdx = 1;
        } else {
            // 2. Если не КН, проверяем, похожа ли она на координаты
            // Более строгая проверка: X<разделитель>Y, где X и Y - числа с возможной дробной частью
            // Разделитель - пробел или таб. Должно быть ДВА числа.
            const coordParts = firstLine.replace(/,/g, '.').split(/[\s\t]+/);
            let firstLineIsCoords = false;
            if (coordParts.length >= 2) {
                const xCand = parseFloat(coordParts[0]);
                const yCand = parseFloat(coordParts[1]);
                if (isFinite(xCand) && isFinite(yCand)) {
                    firstLineIsCoords = true;
                } else if (coordParts.length > 2) { // Попробовать вторую и третью, если первая пара не числа
                    const xCand2 = parseFloat(coordParts[1]);
                    const yCand2 = parseFloat(coordParts[2]);
                     if (isFinite(xCand2) && isFinite(yCand2)) {
                        firstLineIsCoords = true;
                    }
                }
            }


            if (firstLineIsCoords) {
                // Первая строка - это координаты, генерируем имя
                objectName = `${defaultNameBase} #${nextObjectIdPlaceholder}`;
                coordinateLinesStartIdx = 0; // Все строки из blockLines - потенциальные координаты
            } else {
                // Первая строка не КН и не явные координаты - считаем ее произвольным именем
                objectName = firstLine;
                coordinateLinesStartIdx = 1;
            }
        }

        if (coordinateLinesStartIdx >= blockLines.length && objectName !== `${defaultNameBase} #${nextObjectIdPlaceholder}` && !isValidCadastralNumberFormat(objectName) ) {
             // Если было произвольное имя (не КН и не автоген), но не было координат
             console.warn(`Объект с именем "${objectName}" не имел координатных строк.`);
             return null;
        }
         // Если это был КН и нет координатных строк, это нормально - КН может быть без координат в данном тексте
         // и должен быть добавлен как объект, координаты для него могут быть загружены позже, если это единичный КН из буфера.
         // Но если это КН как часть большого блока, и мы не нашли для него координат в ЭТОМ блоке,
         // то сам processSingleObjectBlock вернет contours.length === 0, и он не будет добавлен.


        const contours = [];
        let currentContour = [];

        for (let i = coordinateLinesStartIdx; i < blockLines.length; i++) {
            const line = blockLines[i];
            if (line === "") {
                if (currentContour.length > 0) {
                    contours.push(currentContour);
                    currentContour = [];
                }
            } else {
                const parts = line.replace(/,/g, '.').split(/[\s\t]+/);
                if (parts.length >= 2) {
                    let x = parseFloat(parts[0]);
                    let y = parseFloat(parts[1]);
                    if (!isFinite(x) || !isFinite(y)) {
                        x = parseFloat(parts[1]);
                        y = parseFloat(parts[0]);
                    }
                    if (isFinite(x) && isFinite(y)) {
                        currentContour.push({ x: roundCoord(x), y: roundCoord(y) });
                    }
                }
            }
        }
        if (currentContour.length > 0) {
            contours.push(currentContour);
        }

        // Важно: если это был КН (objectName = firstLine и isValidCadastralNumberFormat(objectName)),
        // и для него не нашлось координат В ЭТОМ БЛОКЕ (contours.length == 0),
        // то мы все равно должны вернуть объект с именем КН и пустыми контурами.
        // Это позволит функции checkClipboardForObjects решить, что делать дальше
        // (например, если это единственный КН, то загрузить из Supabase).
        // Если же это был КН как часть мульти-блока, и дальше нет координат - то он не добавится в addedObjectsBatch.

        if (contours.length > 0 && contours.some(c => c.length > 0)) {
            return { name: objectName, contours: contours.filter(c => c.length > 0) };
        } else if (isValidCadastralNumberFormat(objectName) && coordinateLinesStartIdx === 1) {
            // Если это был КН и после него не было координатных строк ВООБЩЕ
            // (т.е. blockLines состоял только из КН или КН + пустые строки)
            // Возвращаем его с пустыми контурами, чтобы checkClipboardForObjects мог его обработать как одиночный КН
            return { name: objectName, contours: [] };
        }


        return null;
    }
    
    
     function processObjectBlock(objectLines, parsedObjectsArray) {
        if (objectLines.length < 2) return; // Нужно имя и хотя бы одна координата

        const objectName = objectLines[0];
        const coordinateLines = objectLines.slice(1);

        const contours = [];
        let currentContour = [];

        for (const coordLine of coordinateLines) {
            // coordLine уже очищена от пробелов по краям из внешнего цикла
            // Пустая строка ВНУТРИ блока объекта означает новый контур
            if (coordLine === "") {
                if (currentContour.length > 0) {
                    contours.push(currentContour);
                    currentContour = [];
                }
            } else {
                const parts = coordLine.replace(/,/g, '.').split(/[\s\t]+/);
                if (parts.length >= 2) {
                    let x = parseFloat(parts[0]);
                    let y = parseFloat(parts[1]);
                    if (!isFinite(x) || !isFinite(y)) { // Попробовать поменять местами
                        x = parseFloat(parts[1]);
                        y = parseFloat(parts[0]);
                    }
                    if (isFinite(x) && isFinite(y)) {
                        currentContour.push({ x: roundCoord(x), y: roundCoord(y) });
                    }
                }
            }
        }
        if (currentContour.length > 0) { // Добавить последний контур
            contours.push(currentContour);
        }

        if (contours.length > 0 && contours.some(c => c.length > 0)) {
            parsedObjectsArray.push({ name: objectName, contours: contours.filter(c => c.length > 0) });
        }
    }

 function parseObjectsFromClipboardText(text) {
        const parsedObjectData = [];
        // Сначала разбиваем весь текст на блоки, где каждый блок - это потенциальный объект.
        // Разделитель между объектами - две или более последовательные пустые строки.
        // Используем регулярное выражение для разделения по двум и более переводам строки.
        // trim() в начале убирает лишние пробелы и пустые строки в начале/конце всего текста.
        const objectBlocksAsStrings = text.trim().split(/\n\s*\n\s*\n*/); // Две или более пустые строки

        for (const blockStr of objectBlocksAsStrings) {
            if (blockStr.trim() === "") continue; // Пропускаем полностью пустые блоки

            // Теперь каждую строку внутри блока объекта тримим и разбиваем
            const blockLines = blockStr.split('\n').map(line => line.trim()).filter(line => line !== "" || blockStr.split('\n').map(l => l.trim()).indexOf(line.trim()) !== blockStr.split('\n').map(l => l.trim()).lastIndexOf(line.trim()) );
            // Фильтр (line => line !== "" || ...) нужен, чтобы сохранить одну пустую строку, если она разделяет контуры,
            // но удалить множественные пустые строки внутри одного блока объекта, которые не являются разделителями контуров.
            // Проще: разбиваем блок на строки, потом передаем в processSingleObjectBlock, который сам обработает пустые строки как разделители контуров.

            const linesForSingleObject = blockStr.split('\n').map(l => l.trim());


            const obj = processSingleObjectBlock(linesForSingleObject);
            if (obj) {
                // Проверка, если имя объекта - это валидный КН, и у него нет координат,
                // то это может быть случай, когда КН был частью блока с координатами.
                // Такой КН не должен обрабатываться как отдельный объект, если он не единственный в буфере.
                if (isValidCadastralNumberFormat(obj.name) && obj.contours.length === 0) {
                     // Пропускаем, если это КН без координат, который мог быть "заголовком"
                     console.log(`Пропущен КН "${obj.name}" без координат как потенциальный заголовок.`);
                } else {
                    parsedObjectData.push(obj);
                }
            }
        }
        return parsedObjectData;
    }

async function checkClipboardForObjects() {
        try {
            const text = await navigator.clipboard.readText();
            if (!text || text.trim().length === 0) return false;

            const trimmedText = text.trim();
            const lines = trimmedText.split('\n');

            // 1. Проверка на одиночный кадастровый номер
            if (lines.length === 1 && isValidCadastralNumberFormat(trimmedText)) {
                // REMOVED: const userConfirmation = window.confirm(`В буфере обмена обнаружен кадастровый номер: ${trimmedText}. Загрузить его из базы данных? (Это очистит текущие объекты)`);
                // REMOVED: if (userConfirmation) {
                showLoader(true, `Загрузка ${trimmedText}...`);
                userObjects = []; nextObjectId = 1; nextColorIndex = 0; selectedObjectIndex = -1; editingObjectIndex = -1; geometryHistory = [];
                console.log("Состояние очищено перед импортом КН из буфера обмена.");

                await handleImportFromCadNumbers([trimmedText]);
                showLoader(false);
                return true;
                // REMOVED: }
                // REMOVED: return false;
            }

            // 2. Проверка на многострочные данные
            const looksLikeCoordinateData = /\d/.test(trimmedText) && /[ \t,.]/.test(trimmedText);

            if (looksLikeCoordinateData) {
                // REMOVED: const userConfirmation = window.confirm("В буфере обмена обнаружены данные, похожие на координаты объектов. Хотите импортировать их? (Это очистит текущие объекты)");
                // REMOVED: if (!userConfirmation) {
                // REMOVED:     console.log("Пользователь отклонил импорт из буфера обмена.");
                // REMOVED:     return false;
                // REMOVED: }

                showLoader(true, "Импорт из буфера обмена...");
                userObjects = []; nextObjectId = 1; nextColorIndex = 0; selectedObjectIndex = -1; editingObjectIndex = -1; geometryHistory = [];
                console.log("Состояние очищено перед импортом объектов из буфера обмена.");

                const parsedClipboardObjects = parseObjectsFromClipboardText(trimmedText);
                let tempNextObjectIdForNaming = 1;

                if (parsedClipboardObjects.length > 0) {
                    let addedObjectsBatch = [];
                    for (const objData of parsedClipboardObjects) {
                        if (isValidCadastralNumberFormat(objData.name) && objData.contours.length === 0 && parsedClipboardObjects.length > 1) {
                            console.log(`Пропущен КН "${objData.name}" без координат, так как он не единственный в буфере и является заголовком.`);
                            continue;
                        }

                        let finalName = objData.name;
                        if (finalName === `Объект #${nextObjectIdPlaceholder}`) {
                            finalName = `Объект #${tempNextObjectIdForNaming++}`;
                        }

                        let objectType = 'point';
                         if (objData.contours && objData.contours.length > 0) {
                            const firstPrimaryContour = objData.contours.find(c => c && c.length > 0);
                            if (firstPrimaryContour) {
                                if (firstPrimaryContour.length >= 3) {
                                    const firstPt = firstPrimaryContour[0];
                                    const lastPt = firstPrimaryContour[firstPrimaryContour.length - 1];
                                    const PRECISION_THRESHOLD = 0.001;
                                    if (Math.abs(firstPt.x - lastPt.x) < PRECISION_THRESHOLD && Math.abs(firstPt.y - lastPt.y) < PRECISION_THRESHOLD) {
                                        objectType = 'polygon';
                                    } else {
                                        objectType = 'line';
                                    }
                                } else if (firstPrimaryContour.length === 2) {
                                    objectType = 'line';
                                }
                            }
                        }

                        if (objData.contours.length > 0 || isValidCadastralNumberFormat(finalName)) {
                            const newObj = addObjectInternal(objData.contours, finalName, objectType, true);
                            if (newObj) {
                                addedObjectsBatch.push(newObj);
                            }
                        } else if (objData.name !== `Объект #${nextObjectIdPlaceholder}`) {
                            console.warn(`Объект "${finalName}" не был добавлен, так как не имеет валидных контуров.`);
                        }
                    }
                    if (addedObjectsBatch.length > 0) {
                        finalizeBatchAdd(addedObjectsBatch);
                        showNotification(`Импортировано ${addedObjectsBatch.length} объектов из буфера обмена.`, "success", "clipboard-check");
                    } else {
                        showNotification("Не удалось импортировать объекты из буфера обмена. Проверьте формат или убедитесь, что есть валидные координаты.", "warning", "exclamation-triangle");
                    }
                } else {
                     showNotification("Не найдено валидных объектов для импорта в буфере обмена.", "info", "clipboard");
                }
                showLoader(false);
                return parsedClipboardObjects.length > 0;
            }
        } catch (err) {
             if (err.name === 'NotAllowedError' || (err.message && err.message.toLowerCase().includes('permission denied'))) {
                 console.warn('Чтение из буфера обмена не удалось (разрешения/фокус).', err.name);
            } else if (err.name === 'TypeError' && (err.message && err.message.toLowerCase().includes('readtext'))) {
                console.warn('API буфера обмена navigator.clipboard недоступно.');
            } else {
                console.error('Ошибка чтения/парсинга буфера обмена:', err);
            }
            showLoader(false);
        }
        return false;
    }
  


    
    function updateViewInfo() {
        if (!viewInfoText || !hasValidView() || !canvas || canvas.width <= 0 || scale <= 1e-9) {
            if(viewInfoText) viewInfoText.textContent = `Обзор: -`;
            return;
        }
        const visibleWidthMeters = canvas.width / scale;
        let displayText;
        if (!isFinite(visibleWidthMeters)) {
             displayText = `Высота: -`;
        } else if (visibleWidthMeters >= 1000) {
            displayText = `Высота: ${(visibleWidthMeters / 1000).toFixed(2)} км`;
        } else {
            displayText = `Высота: ${visibleWidthMeters.toFixed(1)} м`;
        }
        viewInfoText.textContent = displayText;
    }
    function resetView() {
        calculateBounds();
        const canvasWidth = canvas.width || 100;
        const canvasHeight = canvas.height || 100;

        if (minX === undefined || !isFinite(minX) || maxX === undefined || !isFinite(maxX) ||
            minY === undefined || !isFinite(minY) || maxY === undefined || !isFinite(maxY))
        {
             scale = 1; offsetX = 0; offsetY = 0;
             minX = 0; minY = 0; maxX = canvasWidth; maxY = canvasHeight;
        } else {
            const dataWidth = Math.max(1e-6, maxX - minX);
            const dataHeight = Math.max(1e-6, maxY - minY);
            const scaleX = canvasWidth / dataWidth * 0.9;
            const scaleY = canvasHeight / dataHeight * 0.9;
            scale = Math.max(1e-9, Math.min(Math.min(scaleX, scaleY), 10000));
            if (!isFinite(scale) || scale <= 0) scale = 1;

            const centerX = minX + dataWidth / 2;
            const centerY = minY + dataHeight / 2;
            offsetX = canvasWidth / 2 - (centerY - cMinYGlob()) * scale;
            offsetY = canvasHeight / 2 - (centerX - cMinXGlob()) * scale;
        }

        if (!isFinite(scale) || scale <= 0) scale = 1;
        if (!isFinite(offsetX)) offsetX = 0;
        if (!isFinite(offsetY)) offsetY = 0;

        if (!hasValidView()) {
             scale = 1; offsetX = 0; offsetY = 0;
             minX = 0; minY = 0; maxX = canvasWidth; maxY = canvasHeight;
        }
         updateViewInfo();
    }
    function hasValidView() {
        return isFinite(scale) && scale > 1e-9 &&
               isFinite(offsetX) && isFinite(offsetY) &&
               minX !== undefined && minY !== undefined && maxX !== undefined && maxY !== undefined &&
               isFinite(minX) && isFinite(minY) && isFinite(maxX) && isFinite(maxY);
    }

     function updateToggleButtonStates() {
         document.getElementById('togglePointsBtn').style.backgroundColor = showPoints ? '#e74c3c' : '#7f8c8d';
         rulerBtn.classList.toggle('active', rulerMode);
         drawObjectBtn.classList.toggle('active', isDrawingMode);
         finishDrawingBtn.style.display = isDrawingActive ? 'flex' : 'none';
         toggleGeometryEditBtn.classList.toggle('active', isGeometryEditMode);
         updateUndoButtonState();

         canvas.classList.toggle('drawing-mode', isDrawingMode && isDrawingActive);
         canvas.classList.toggle('editing-point-mode', isMovingPoint);
     }

    function setupEventListeners() {
        canvas.addEventListener('mousedown', handleMouseDown);
        canvas.addEventListener('mousemove', handleMouseMove);
        canvas.addEventListener('mouseup', handleMouseUp);
        canvas.addEventListener('wheel', handleWheel, { passive: false });
        canvas.addEventListener('click', handleClick);
        canvas.addEventListener('dblclick', handleDoubleClick);
        canvas.addEventListener('mouseout', handleMouseOut);
        canvas.addEventListener('contextmenu', handleContextMenu);

        document.getElementById('addObjectBtn').addEventListener('click', openCoordsDialog);
        document.getElementById('togglePointsBtn').addEventListener('click', togglePointsVisibility);
        document.getElementById('rulerBtn').addEventListener('click', () => toggleMode('ruler'));
        document.getElementById('resetMeasurementBtn').addEventListener('click', resetMeasurement);
        drawObjectBtn.addEventListener('click', () => toggleMode('draw'));
        finishDrawingBtn.addEventListener('click', finishDrawingAsLineOrPoint);
        toggleGeometryEditBtn.addEventListener('click', () => toggleMode('geometryEdit'));
        undoGeometryChangeBtn.addEventListener('click', undoLastGeometryChange);

        document.getElementById('importCoordsBtn').addEventListener('click', handleUniversalImport);
        document.getElementById('importFromFileBtn').addEventListener('click', handleImportFromFile);
        document.getElementById('closeDialogBtn').addEventListener('click', closeCoordsDialog);
        dialogOverlay.addEventListener('click', closeCoordsDialog);
        coordsDialog.addEventListener('click', (e) => e.stopPropagation());

        window.addEventListener('resize', () => {
             canvas.width = canvas.offsetWidth;
             canvas.height = canvas.offsetHeight;
             calculateBounds();
             redraw(true);
        });
        document.addEventListener('keydown', (e) => {
            if (isGeometryEditMode && e.key === 'Escape') {
                deactivateGeometryEditMode();
            }
        });
    }

    function activateGeometryEditMode() {
        if (selectedObjectIndex === -1) {
            showNotification("Сначала выберите объект для редактирования.", "warning", "hand-pointer");
            return false;
        }
        isGeometryEditMode = true;
        editingObjectIndex = selectedObjectIndex;
        geometryHistory = [];
        saveGeometryStateForUndo(editingObjectIndex);

        if (rulerMode) { rulerMode = false; measurementPanel.classList.remove('active'); rulerPoints = []; }
        if (isDrawingMode) { isDrawingMode = false; isDrawingActive = false; currentDrawingPoints = []; }

        showNotification(`Режим редактирования для "${userObjects[editingObjectIndex].name || 'Объект ' + userObjects[editingObjectIndex].id}". Клик на сегмент - добавить. ПКМ на точку - удалить.`, "info", "edit");
        redraw(true);
        return true;
    }

    function deactivateGeometryEditMode(showNotif = true) {
        if (!isGeometryEditMode) return;
        isGeometryEditMode = false;
        editingObjectIndex = -1;
        isMovingPoint = false;
        movedPointInfo = null;
        snappedToPointVisual = null;
        geometryHistory = [];

        if (showNotif) showNotification("Режим редактирования геометрии выключен.", "info", "edit");
        if (!rulerMode && !isDrawingMode) canvas.style.cursor = 'grab';
        redraw(true);
    }


    function toggleMode(modeToToggle) {
        if (modeToToggle !== 'ruler' && rulerMode) {
            rulerMode = false; measurementPanel.classList.remove('active'); rulerPoints = [];
        }
        if (modeToToggle !== 'draw' && isDrawingMode) {
            isDrawingMode = false; isDrawingActive = false; currentDrawingPoints = [];
        }
        if (modeToToggle !== 'geometryEdit' && isGeometryEditMode) {
            deactivateGeometryEditMode(false);
        }

        if (modeToToggle === 'ruler') {
            rulerMode = !rulerMode;
            if (rulerMode) {
                resetMeasurement(); measurementPanel.classList.add('active');
                showNotification('Режим измерения включен.', 'info', 'ruler');
                canvas.style.cursor = 'crosshair';
            } else {
                showNotification('Режим измерения выключен.', 'info', 'ruler');
            }
        } else if (modeToToggle === 'draw') {
            isDrawingMode = !isDrawingMode;
            if (isDrawingMode) activateDrawingMode();
            else cancelDrawing();
        } else if (modeToToggle === 'geometryEdit') {
            if (isGeometryEditMode) {
                deactivateGeometryEditMode();
            } else {
                activateGeometryEditMode();
            }
        }

        if (!rulerMode && !isDrawingMode && !isGeometryEditMode && !isMovingPoint) {
            canvas.style.cursor = 'grab';
        }
        updateToggleButtonStates();
        redraw(true);
    }


     function saveState() {
        try {
            const maxObjectsToSave = 50;
            const validObjects = userObjects.filter(o => o);
            const objectsToSave = validObjects.slice(-maxObjectsToSave);
            const state = {
                userObjects: objectsToSave, nextObjectId, nextColorIndex,
                view: hasValidView() ? { scale, offsetX, offsetY, minX, minY, maxX, maxY } : null,
                showPoints
            };
            localStorage.setItem('geoAnalyzerState', JSON.stringify(state));
        } catch (e) {
             if (e.name === 'QuotaExceededError') {
                  localStorage.removeItem('geoAnalyzerState');
                   showNotification("Хранилище переполнено. Старые данные удалены.", "warning", "hdd");
             } else { console.error("Ошибка сохранения состояния:", e); showNotification("Ошибка сохранения состояния.", "error", "save"); }
        }
    }

    // `contoursData` is expected to be an array of contours (array of arrays of points)
    function addObjectInternal(contoursData, name, objectType, isMultiPart = false) {
         if (!contoursData || contoursData.length === 0 || contoursData.every(c => !c || c.length === 0)) {
             if (!isMultiPart) showNotification("Не удалось добавить объект: нет контуров или они пусты.", "error", "exclamation-circle");
             return null;
         }

         const processedContours = contoursData.map(contour => {
             if (!contour || contour.length === 0) return null;
             const roundedContour = contour.map(p => ({ x: roundCoord(p.x), y: roundCoord(p.y) }));
             const validPoints = roundedContour.filter(p => p && isFinite(p.x) && isFinite(p.y));
             if (validPoints.length === 0) return null;

             // Auto-close polygon contours
             if (objectType === 'polygon' && validPoints.length >= 3) {
                const firstPt = validPoints[0];
                const lastPt = validPoints[validPoints.length - 1];
                const PRECISION_THRESHOLD = 0.001;
                if (!(Math.abs(firstPt.x - lastPt.x) < PRECISION_THRESHOLD && Math.abs(firstPt.y - lastPt.y) < PRECISION_THRESHOLD)) {
                    validPoints.push({ x: firstPt.x, y: firstPt.y });
                }
            }
            return validPoints;
         }).filter(c => c !== null && c.length > 0); // Remove null or empty contours

         if (processedContours.length === 0) {
            if (!isMultiPart) showNotification("Не удалось добавить объект: нет валидных координат в контурах.", "error", "exclamation-circle");
            return null;
         }

         let finalObjectType = objectType;
         // Determine object type based on the first valid contour if not explicitly point/line with too few points
         const firstValidContour = processedContours[0];
         if (firstValidContour.length < 3 && objectType === 'polygon') {
             finalObjectType = firstValidContour.length === 2 ? 'line' : 'point';
         } else if (firstValidContour.length < 2 && objectType === 'line') {
             finalObjectType = 'point';
         }
         // If after processing, an object intended as line/polygon only has one point in its primary contour, make it a point.
         if ((finalObjectType === 'line' || finalObjectType === 'polygon') && firstValidContour.length === 1) {
            finalObjectType = 'point';
         }


         const newId = nextObjectId++;
         const newColor = objectColors[nextColorIndex % objectColors.length]; nextColorIndex++;

         const newObject = {
             id: newId,
             name,
             type: finalObjectType,
             contours: processedContours, // Store all valid, processed contours
             color: newColor,
             area: 0,
             perimeter: 0
         };
         updateObjectMetrics(newObject); // This will also handle closing polygon contours within it

         userObjects.push(newObject);
         const newIndex = userObjects.length - 1;

         if (!isMultiPart) {
             updateObjectList();
             selectedObjectIndex = newIndex;
             calculateBounds();
             displayObjectInfo(selectedObjectIndex);
             setTimeout(() => { centerOnObject(newIndex, true); }, 50);
             saveState();
             redraw(true);
         }
         return newObject;
    }

    function deleteObject(index) {
        if (index < 0 || index >= userObjects.length || !userObjects[index]) return;
        const obj = userObjects[index];
        const objectName = obj.name || `Объект ${obj.id}`;
        if (window.confirm(`Вы уверены, что хотите удалить "${objectName}"?`)) {
             if(isGeometryEditMode && editingObjectIndex === index) {
                deactivateGeometryEditMode(false);
            }
            userObjects.splice(index, 1);
            const wasSelected = (selectedObjectIndex === index);

            if (wasSelected) { selectedObjectIndex = -1; displayObjectInfo(-1); }
            else if (selectedObjectIndex > index) { selectedObjectIndex--; }

            if(editingObjectIndex > index) editingObjectIndex--;
            else if (editingObjectIndex === index) editingObjectIndex = -1;


            showNotification(`"${objectName}" удален`, "info", "trash-alt");
            updateObjectList();
            calculateBounds();
            if (!hasValidView()) {
                resetView();
                redraw(false);
            } else {
                 redraw(true);
            }
            saveState();
        }
    }
    async function renameObject(index, newName) {
         if (index < 0 || index >= userObjects.length || !userObjects[index] || !newName || !newName.trim()) {
              showNotification("Имя объекта не может быть пустым.", "warning", "exclamation-triangle"); return;
         }
         const finalName = newName.trim(); userObjects[index].name = finalName;
         displayObjectInfo(index); updateObjectList(); redraw(true);
         showNotification(`Объект переименован в "${finalName}"`, "success", "pencil-alt"); saveState();
    }

    function openCoordsDialog() {
        if (isDrawingMode || isMovingPoint || isGeometryEditMode) {
            showNotification("Завершите текущее действие перед импортом.", "warning", "pause-circle"); return;
        }
        coordsInput.value = ''; coordsDialog.style.display = 'block'; dialogOverlay.style.display = 'block';
        requestAnimationFrame(() => { dialogOverlay.classList.add('show'); coordsDialog.classList.add('show'); coordsInput.focus(); });
    }
    function closeCoordsDialog() {
        dialogOverlay.classList.remove('show'); coordsDialog.classList.remove('show');
        setTimeout(() => { coordsDialog.style.display = 'none'; dialogOverlay.style.display = 'none'; }, 300);
    }
    async function promptAndAddObjectInternal(contoursData, objectType, defaultName) {
        const name = await showNamePrompt(`Имя нового объекта (${defaultName}):`, defaultName || `Объект ${nextObjectId}`);
        if (name !== null) {
            // Ensure contoursData is an array of contours
            const contoursArray = Array.isArray(contoursData[0]) ? contoursData : [contoursData];
            return addObjectInternal(contoursArray, name, objectType, true);
        } else {
            showNotification(`Добавление "${defaultName || 'объекта'}" отменено.`, 'warning', 'times-circle');
            return null;
        }
    }

    async function handleUniversalImport() {
        const inputText = coordsInput.value.trim();
        if (!inputText) {
            showNotification("Поле ввода пустое.", "warning", "exclamation-triangle");
            return;
        }

        const lines = inputText.split('\n').map(line => line.trim()).filter(line => line);
        const isFirstLineCadNumber = lines.length > 0 && isValidCadastralNumberFormat(lines[0]);

        if (isFirstLineCadNumber) {
            const areAllCadNumbers = lines.every(line => isValidCadastralNumberFormat(line));
            if (areAllCadNumbers) {
                await handleImportFromCadNumbers(lines);
            } else {
                showNotification("Обнаружен кадастровый номер, но не все строки в списке являются корректными кадастровыми номерами. Проверьте ввод.", "error", "list-ol");
            }
        } else {
            await handleImportFromTextareaCoordinates(inputText);
        }
    }


    async function handleImportFromTextareaCoordinates(text) {
         const parsedContours = parseCoordinatesFromText(text); // Returns array of contours
         if (parsedContours && parsedContours.length > 0) {
            closeCoordsDialog();
            let addedObjects = [];
            for (let i = 0; i < parsedContours.length; i++) {
                const contour = parsedContours[i];
                if (contour && contour.length > 0) {
                     const isClosed = contour.length >= 3 &&
                                   Math.abs(contour[0].x - contour[contour.length - 1].x) < 0.001 &&
                                   Math.abs(contour[0].y - contour[contour.length - 1].y) < 0.001;
                    let objectType = isClosed ? 'polygon' : (contour.length >= 2 ? 'line' : 'point');
                    // For text input, we treat each block as a separate object, so pass [contour]
                    const newObj = await promptAndAddObjectInternal([contour], objectType, `Участок  ${nextObjectId -1}`); // -1 because nextObjectId was already incremented
                    if(newObj) addedObjects.push(newObj);
                }
            }
            if(addedObjects.length > 0) {
                finalizeBatchAdd(addedObjects);
            }

         } else { showNotification("Не удалось распознать валидные координаты X Y.", "error", "exclamation-circle"); }
    }


    async function handleImportFromFile() {
         const fileInput = document.createElement('input'); fileInput.type = 'file'; fileInput.accept = '.txt,.csv';
         fileInput.onchange = async (e) => {
             const file = e.target.files[0]; if (!file) return;
             const baseName = file.name.split('.').slice(0, -1).join('.') || `Файл ${nextObjectId}`;
             const reader = new FileReader();
             reader.onload = async (event) => {
                 const content = event.target.result;
                 const parsedContours = parseCoordinatesFromText(content);
                  if (parsedContours && parsedContours.length > 0) {
                      closeCoordsDialog();
                      let addedObjects = [];
                      for (let i = 0; i < parsedContours.length; i++) {
                          const contour = parsedContours[i];
                           if (contour && contour.length > 0) {
                               const isClosed = contour.length >= 3 &&
                                   Math.abs(contour[0].x - contour[contour.length - 1].x) < 0.001 &&
                                   Math.abs(contour[0].y - contour[contour.length - 1].y) < 0.001;
                               let objectType = isClosed ? 'polygon' : (contour.length >= 2 ? 'line' : 'point');
                               const newObj = await promptAndAddObjectInternal([contour], objectType, `${baseName}${parsedContours.length > 1 ? '_'+(i+1) : ''}`);
                               if(newObj) addedObjects.push(newObj);
                           }
                      }
                      if(addedObjects.length > 0) {
                          finalizeBatchAdd(addedObjects);
                      }
                  } else { showNotification('Не удалось найти валидные координаты в файле.', 'error', 'exclamation-circle'); }
             };
             reader.onerror = () => { showNotification('Ошибка чтения файла.', 'error', 'exclamation-circle'); };
             reader.readAsText(file);
         };
         fileInput.click();
    }

    function parseCoordinatesFromText(text) {
        const lines = text.split('\n');
        const contours = [];
        let currentContour = [];
        lines.forEach(line => {
            line = line.trim().replace(/,/g, '.');
            if (line === '') { // Пустая строка разделяет контуры
                if (currentContour.length > 0) {
                    contours.push(currentContour);
                    currentContour = [];
                }
            } else {
                const parts = line.split(/[\s\t]+/);
                if (parts.length >= 2) {
                    let x = parseFloat(parts[0]);
                    let y = parseFloat(parts[1]);
                     if (!isFinite(x) || !isFinite(y)) { // Try swapping if first parse failed
                         x = parseFloat(parts[1]);
                         y = parseFloat(parts[0]);
                     }
                    if (isFinite(x) && isFinite(y)) {
                        currentContour.push({ x: roundCoord(x), y: roundCoord(y) });
                    }
                }
            }
        });
        if (currentContour.length > 0) { // Добавляем последний контур, если он не пустой
            contours.push(currentContour);
        }
        return contours.filter(c => c.length > 0); // Возвращаем только непустые контуры
    }

    function showNamePrompt(title, initialValue = '') {
        return new Promise((resolve) => {
            namePromptTitle.textContent = title; namePromptInput.value = initialValue;
            namePromptDialog.classList.add('show'); namePromptOverlay.classList.add('show');
            namePromptInput.focus(); namePromptInput.select();
            let resolved = false;
            const cleanupAndResolve = (value) => { if (resolved) return; resolved = true; namePromptSaveBtn.onclick = null; namePromptCancelBtn.onclick = null; namePromptOverlay.onclick = null; namePromptInput.onkeydown = null; namePromptDialog.classList.remove('show'); namePromptOverlay.classList.remove('show'); resolve(value); };
            const handleSave = () => { const name = namePromptInput.value.trim(); if (name) cleanupAndResolve(name); else { showNotification("Имя не может быть пустым.", "warning"); namePromptInput.focus(); } };
            const handleCancel = () => cleanupAndResolve(null);
            const handleKeydown = (e) => { if (e.key === 'Enter') { e.preventDefault(); handleSave(); } else if (e.key === 'Escape') handleCancel(); };
            namePromptSaveBtn.onclick = handleSave; namePromptCancelBtn.onclick = handleCancel; namePromptOverlay.onclick = handleCancel; namePromptInput.onkeydown = handleKeydown;
        });
    }
    function calculatePolygonArea(polygon) {
        let area = 0; const n = polygon.length; if (n < 3) return 0;
        for (let i = 0; i < n; i++) {
            const p1 = polygon[i]; const p2 = polygon[(i + 1) % n];
            if (!p1 || !p2 || !isFinite(p1.x) || !isFinite(p1.y) || !isFinite(p2.x) || !isFinite(p2.y)) return 0;
            area += (p1.x * p2.y - p2.x * p1.y);
        }
        return roundCoord(Math.abs(area / 2.0));
    }
    function calculatePolygonPerimeter(polygon, isClosed = true) {
        let length = 0; const n = polygon.length; if (n < 1) return 0; if (n === 1) return 0;
        for (let i = 0; i < n - 1; i++) {
            const p1 = polygon[i]; const p2 = polygon[i + 1];
            if (!p1 || !p2 || !isFinite(p1.x) || !isFinite(p1.y) || !isFinite(p2.x) || !isFinite(p2.y)) return NaN;
            const dist = calculateDistance(p1,p2); if (isNaN(dist)) return NaN; length += dist;
        }
        if (isClosed && n >= 3) {
            const p1 = polygon[n - 1]; const p2 = polygon[0];
            // Ensure points are valid before calculating distance.
            if (!p1 || !p2 || !isFinite(p1.x) || !isFinite(p1.y) || !isFinite(p2.x) || !isFinite(p2.y)) return NaN;
             // Check if first and last points are indeed the same for a closed polygon before adding last segment.
            const PRECISION_THRESHOLD = 0.001;
            if (Math.abs(p1.x - p2.x) > PRECISION_THRESHOLD || Math.abs(p1.y - p2.y) > PRECISION_THRESHOLD) {
                // This case implies the polygon was not properly closed by having the last point identical to the first.
                // The updateObjectMetrics function should handle closing it.
                // For perimeter calculation, we should calculate distance if they are meant to be connected.
                 const dist = calculateDistance(p1, p2); if (isNaN(dist)) return NaN; length += dist;
            }
        }
        return roundCoord(length);
    }
   function checkIntersection(poly1, poly2) {
    if (!poly1 || poly1.length < 3 || !poly2 || poly2.length < 3) return { intersects: false, contains: false, containedBy: false, sharedVertices: 0 };
    let min1x=Infinity,min1y=Infinity,max1x=-Infinity,max1y=-Infinity,v1=false;
    let min2x=Infinity,min2y=Infinity,max2x=-Infinity,max2y=-Infinity,v2=false;
    poly1.forEach(p => { if(p&&isFinite(p.x)&&isFinite(p.y)){min1x=Math.min(min1x,p.x);min1y=Math.min(min1y,p.y);max1x=Math.max(max1x,p.x);max1y=Math.max(max1y,p.y);v1=true;} });
    poly2.forEach(p => { if(p&&isFinite(p.x)&&isFinite(p.y)){min2x=Math.min(min2x,p.x);min2y=Math.min(min2y,p.y);max2x=Math.max(max2x,p.x);max2y=Math.max(max2y,p.y);v2=true;} });
    if(!v1||!v2) return { intersects: false, contains: false, containedBy: false, sharedVertices: 0 };
    const sharedVertices = countSharedVertices(poly1, poly2);
    if(max1x < min2x || max2x < min1x || max1y < min2y || max2y < min1y) {
        return { intersects: sharedVertices > 0, contains: false, containedBy: false, sharedVertices };
    }
    let intersects=false;
    for(const p1 of poly1){if(p1&&isFinite(p1.x)&&isFinite(p1.y)&&isPointInPolygon(p1,poly2)){intersects=true;break;}}
    if(!intersects){for(const p2 of poly2){if(p2&&isFinite(p2.x)&&isFinite(p2.y)&&isPointInPolygon(p2,poly1)){intersects=true;break;}}}
    let contains=false, containedBy=false;
    if(intersects || !(max1x < min2x || max2x < min1x || max1y < min2y || max2y < min1y)) {
        contains = poly2.every(p => (p && isFinite(p.x) && isFinite(p.y)) ? isPointInPolygon(p, poly1) : true);
        containedBy = poly1.every(p => (p && isFinite(p.x) && isFinite(p.y)) ? isPointInPolygon(p, poly2) : true);
    }
    if(contains && containedBy){ contains = false; containedBy = false; intersects = true; }
    if(containedBy || contains) { intersects = true; }
    return { intersects, contains, containedBy, sharedVertices };
}
    function isPointInPolygon(point, polygon) {
        if (!polygon || polygon.length < 3 || !point || !isFinite(point.x) || !isFinite(point.y)) return false;
        let inside = false;
        const ptX = point.x;
        const ptY = point.y;
        for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
            const pi = polygon[i], pj = polygon[j];
            if (!pi || !pj || !isFinite(pi.x) || !isFinite(pi.y) || !isFinite(pj.x) || !isFinite(pj.y)) continue;
            const xi = pi.x, yi = pi.y;
            const xj = pj.x, yj = pj.y;
            if ((xi === ptX && yi === ptY) || (xj === ptX && yj === ptY)) return true;
            const onHorizontal = (Math.abs(yi - ptY) < 1e-9 && Math.abs(yj - ptY) < 1e-9) && (ptX >= Math.min(xi, xj) - 1e-9 && ptX <= Math.max(xi, xj) + 1e-9);
            const onVertical = (Math.abs(xi - ptX) < 1e-9 && Math.abs(xj - ptX) < 1e-9) && (ptY >= Math.min(yi, yj) - 1e-9 && ptY <= Math.max(yi, yj) + 1e-9);
            if (onHorizontal || onVertical) return true;
            const intersect = ((yi > ptY) !== (yj > ptY)) && (ptX < (xj - xi) * (ptY - yi) / (yj - yi) + xi);
            if (intersect) inside = !inside;
        }
        return inside;
    }
    function getContourCentroid(contour) {
        if (!contour || contour.length === 0) return { x: NaN, y: NaN };
        let sumX = 0, sumY = 0; let validPoints = 0;
        contour.forEach(p => { if (p && isFinite(p.x) && isFinite(p.y)) { sumX += p.x; sumY += p.y; validPoints++; } });
        if (validPoints === 0) return { x: NaN, y: NaN };
        return { x: roundCoord(sumX / validPoints), y: roundCoord(sumY / validPoints) };
    }
    const transformCoord = (dataX, dataY) => {
        const cH = canvas.height || 0;
        const cX = offsetX + (dataY - cMinYGlob()) * scale;
        const cY = cH - (offsetY + (dataX - cMinXGlob()) * scale);
        return [cX, cY];
    };
    const inverseTransformCoord = (canvasX, canvasY) => {
        const cH = canvas.height || 0;
        if (Math.abs(scale) < 1e-9) return { x: NaN, y: NaN };
        const dX_raw = cMinXGlob() + (cH - canvasY - offsetY) / scale;
        const dY_raw = cMinYGlob() + (canvasX - offsetX) / scale;
        return { x: roundCoord(dX_raw), y: roundCoord(dY_raw) };
    };

    function redraw(preserveTransform = false) {
        if (canvas.width !== canvas.offsetWidth || canvas.height !== canvas.offsetHeight) {
            canvas.width = canvas.offsetWidth; canvas.height = canvas.offsetHeight;
            if (!preserveTransform) { calculateBounds(); if (!hasValidView()) resetView(); }
        }
        ctx.setTransform(1, 0, 0, 1, 0, 0); ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = 'white'; ctx.fillRect(0, 0, canvas.width, canvas.height);
        if (userObjects.length === 0 && !rulerMode && !isDrawingActive && !isGeometryEditMode) {
             ctx.fillStyle = "#777"; ctx.font = "16px Arial"; ctx.textAlign = "center";
             ctx.fillText("Добавьте объекты (+), нарисуйте (✎), редактируйте () или измерьте (📏)", canvas.width / 2, canvas.height / 2);
        }
        if (!preserveTransform) calculateBounds();
        if (!hasValidView()) { ctx.fillStyle = "red"; ctx.font = "bold 18px Arial"; ctx.textAlign = "center"; ctx.fillText("Ошибка отображения: Невалидное состояние вида.", canvas.width / 2, canvas.height / 2); return; }

        const gridStep = determineGridStep();
        drawGrid(ctx, gridStep);
        drawObjects(ctx);
        drawActiveDrawingPreview(ctx);
        drawRuler(ctx);
        drawSelectedCoordinateMarker(ctx);
        drawSnapHighlight(ctx);

        updateGridInfo(gridStep);
        updateViewInfo();
    }

    function getPointState(pointToCheck, currentObjectIndex) {
        let isInsideOtherPolygon = false;
        let isCoincidentWithOther = false;
        if (!pointToCheck || !isFinite(pointToCheck.x) || !isFinite(pointToCheck.y)) {
            return { isCoincident: false, isInsideOther: false };
        }
        userObjects.forEach((otherObj, otherIndex) => {
            if (currentObjectIndex === otherIndex || !otherObj || !otherObj.contours) return;
            if (!isCoincidentWithOther) {
                for (const otherContour of otherObj.contours) {
                    if (!otherContour) continue;
                    for (const otherPoint of otherContour) {
                        if (otherPoint && isFinite(otherPoint.x) && isFinite(otherPoint.y)) {
                            if (pointToCheck.x === otherPoint.x && pointToCheck.y === otherPoint.y) {
                                isCoincidentWithOther = true; break;
                            }
                        }
                    }
                    if (isCoincidentWithOther) break;
                }
            }
            if (!isInsideOtherPolygon && otherObj.type === 'polygon' && otherObj.contours[0] && otherObj.contours[0].length >= 3) {
                let pointIsPartOfOtherPolygonBoundary = false;
                if (otherObj.contours[0]) {
                    for(const boundaryPoint of otherObj.contours[0]) {
                         if (boundaryPoint && isFinite(boundaryPoint.x) && isFinite(boundaryPoint.y)) {
                             if (pointToCheck.x === boundaryPoint.x && pointToCheck.y === boundaryPoint.y) {
                                pointIsPartOfOtherPolygonBoundary = true; break;
                             }
                         }
                    }
                }
                if (!pointIsPartOfOtherPolygonBoundary && isPointInPolygon(pointToCheck, otherObj.contours[0])) {
                    isInsideOtherPolygon = true;
                }
            }
        });
        return { isCoincident: isCoincidentWithOther, isInsideOther: isInsideOtherPolygon };
    }

    function drawObjects(ctx) {
        userObjects.forEach((obj, index) => {
            if (!obj || !obj.contours) return;
            const isSelected = (index === selectedObjectIndex);
            const isBeingEdited = (isGeometryEditMode && index === editingObjectIndex);

            ctx.strokeStyle = obj.color || '#000000';
            ctx.lineWidth = (isSelected || isBeingEdited) ? 2.5 : 1.5;
            const fillColor = (obj.type === 'polygon') ? hexToRgba(obj.color || '#000000', (isSelected || isBeingEdited) ? 0.3 : 0.15) : 'transparent';
            ctx.fillStyle = fillColor;

            obj.contours.forEach((contour, cIdx) => {
                if (!contour || contour.length === 0) return;
                ctx.beginPath();
                let firstPoint = true;
                contour.forEach((point) => {
                    if (!point || !isFinite(point.x) || !isFinite(point.y)) return;
                    const [canvasX, canvasY] = transformCoord(point.x, point.y);
                    if (!isFinite(canvasX) || !isFinite(canvasY)) return;
                    if (firstPoint) { ctx.moveTo(canvasX, canvasY); firstPoint = false; }
                    else { ctx.lineTo(canvasX, canvasY); }
                });
                if (firstPoint) return;

                const objectType = obj.type; // Use stored type

                switch (objectType) {
                    case 'polygon':
                        // Path is already built, it will be closed if points were added correctly.
                        // The `updateObjectMetrics` should ensure first and last points are same for polygons.
                        ctx.closePath(); // This is important for fill and stroke of polygon
                        ctx.fill();
                        ctx.stroke();
                        break;
                    case 'line': ctx.stroke(); break;
                    case 'point': default:
                        if (contour[0] && isFinite(contour[0].x) && isFinite(contour[0].y)){
                            const [cx,cy]=transformCoord(contour[0].x, contour[0].y);
                            if(isFinite(cx) && isFinite(cy)){
                                ctx.save(); ctx.setTransform(1,0,0,1,0,0);
                                ctx.fillStyle=obj.color||'#000000';
                                ctx.beginPath(); ctx.arc(cx,cy,(isSelected || isBeingEdited)?5:3.5,0,Math.PI*2); ctx.closePath(); ctx.fill();
                                ctx.strokeStyle='white'; ctx.lineWidth=1; ctx.stroke();
                                ctx.restore();
                            }
                        }
                        break;
                }

                if (showPoints && contour.length > 0 && objectType !== 'point') {
                    contour.forEach((point, pIdx) => {
                        if (!point || !isFinite(point.x) || !isFinite(point.y)) return;
                        const [px, py] = transformCoord(point.x, point.y);
                        if (!isFinite(px) || !isFinite(py)) return;

                        const pointState = getPointState(point, index);
                        ctx.save(); ctx.setTransform(1, 0, 0, 1, 0, 0);
                        ctx.lineWidth = 1;
                        const isCurrentMovingPoint = isMovingPoint && movedPointInfo?.objectIndex === index && movedPointInfo?.contourIndex === cIdx && movedPointInfo?.pointIndex === pIdx;
                        const highlightRadius = (isSelected || isBeingEdited || isCurrentMovingPoint ? 4 : 3) + 2.5;

                        if (pointState.isCoincident && !isCurrentMovingPoint) {
                            ctx.strokeStyle = 'rgba(0, 200, 0, 0.9)';
                            ctx.beginPath(); ctx.arc(px, py, highlightRadius, 0, Math.PI * 2); ctx.stroke();
                        } else if (pointState.isInsideOther && !isCurrentMovingPoint) {
                            ctx.strokeStyle = 'rgba(255, 0, 0, 0.8)';
                            ctx.beginPath(); ctx.arc(px, py, highlightRadius, 0, Math.PI * 2); ctx.stroke();
                        }
                        ctx.restore();

                        ctx.save(); ctx.setTransform(1, 0, 0, 1, 0, 0);
                        let pointFill = isSelected || isBeingEdited ? hexToRgba(obj.color, 0.9) : hexToRgba(obj.color, 0.7);
                        let pointRadius = isSelected || isBeingEdited ? 4 : 3;
                        if(isCurrentMovingPoint){
                            pointFill = 'yellow'; pointRadius = 5;
                        }

                        ctx.fillStyle = pointFill;
                        ctx.beginPath(); ctx.arc(px, py, pointRadius, 0, Math.PI * 2); ctx.closePath(); ctx.fill();
                        ctx.strokeStyle = 'white'; ctx.lineWidth = 0.5; ctx.stroke();
                        ctx.restore();
                    });
                }
            });

            if (scale > 0.005 && obj.contours.length > 0 && obj.contours[0] && obj.contours[0].length > 0) {
                const firstContour = obj.contours[0];
                if (firstContour.every(p => p && isFinite(p.x) && isFinite(p.y))) {
                    const labelPos = getContourCentroid(firstContour);
                    if (labelPos && isFinite(labelPos.x) && isFinite(labelPos.y)) {
                        const [labelX, labelY] = transformCoord(labelPos.x, labelPos.y);
                        if (isFinite(labelX) && isFinite(labelY)) {
                            ctx.save(); ctx.setTransform(1, 0, 0, 1, 0, 0);
                            ctx.font = "bold 11px Arial";
                            ctx.fillStyle = obj.color || '#000000';
                            ctx.strokeStyle = 'white'; ctx.lineWidth = 2.5;
                            ctx.textAlign = "center"; ctx.textBaseline = "bottom";
                            ctx.strokeText(obj.name || `Объект ${obj.id}`, labelX, labelY - 5);
                            ctx.fillText(obj.name || `Объект ${obj.id}`, labelX, labelY - 5);
                            ctx.restore();
                        }
                    }
                }
            }
        });
    }
    function drawActiveDrawingPreview(ctx) {
        if (!isDrawingActive || currentDrawingPoints.length === 0) return;
        ctx.save(); ctx.setTransform(1, 0, 0, 1, 0, 0);
        ctx.strokeStyle = '#f39c12'; ctx.fillStyle = 'rgba(243, 156, 18, 0.7)';
        ctx.lineWidth = 1.5; ctx.globalAlpha = 0.8;
        ctx.beginPath();
        let firstDrawPoint = true;
        currentDrawingPoints.forEach((point) => {
            if (!point || !isFinite(point.x) || !isFinite(point.y)) return;
            const [cx, cy] = transformCoord(point.x, point.y);
            if (!isFinite(cx) || !isFinite(cy)) return;
            if (firstDrawPoint) { ctx.moveTo(cx, cy); firstDrawPoint = false; }
            else { ctx.lineTo(cx, cy); }
        });
        if (!firstDrawPoint) ctx.stroke();

        currentDrawingPoints.forEach((point) => {
            if (!point || !isFinite(point.x) || !isFinite(point.y)) return;
            const [cx, cy] = transformCoord(point.x, point.y);
            if (!isFinite(cx) || !isFinite(cy)) return;
            ctx.save();
            ctx.fillStyle = 'rgba(243, 156, 18, 0.7)'; ctx.strokeStyle = 'white'; ctx.lineWidth = 1;
            ctx.beginPath(); ctx.arc(cx, cy, 4, 0, Math.PI * 2); ctx.fill(); ctx.stroke();
            ctx.restore();
        });

        if (!firstDrawPoint && currentMousePos && isFinite(currentMousePos.x) && isFinite(currentMousePos.y)) {
            const lastPoint = currentDrawingPoints[currentDrawingPoints.length - 1];
            if (lastPoint && isFinite(lastPoint.x) && isFinite(lastPoint.y)) {
                const [lastX, lastY] = transformCoord(lastPoint.x, lastPoint.y);
                const [cursorCanvasX, cursorCanvasY] = transformCoord(currentMousePos.x, currentMousePos.y);
                if (isFinite(lastX) && isFinite(lastY) && isFinite(cursorCanvasX) && isFinite(cursorCanvasY)) {
                    ctx.beginPath(); ctx.moveTo(lastX, lastY); ctx.lineTo(cursorCanvasX, cursorCanvasY);
                    ctx.setLineDash([4, 4]); ctx.strokeStyle = '#f39c12'; ctx.lineWidth = 1; ctx.stroke();
                    ctx.setLineDash([]);
                }
            }
        }
        ctx.restore();
    }
    function drawRuler(ctx) {
      if (!rulerMode || rulerPoints.length === 0) return;
      ctx.save(); ctx.setTransform(1, 0, 0, 1, 0, 0);
      ctx.strokeStyle = '#e74c3c'; ctx.fillStyle = '#e74c3c';
      ctx.lineWidth = 2; ctx.font = 'bold 12px Arial';
      const p1 = rulerPoints[0];
      if (p1 && isFinite(p1.x) && isFinite(p1.y)) {
        const [p1x, p1y] = transformCoord(p1.x, p1.y);
        if (isFinite(p1x) && isFinite(p1y)) {
          ctx.beginPath(); ctx.arc(p1x, p1y, 5, 0, Math.PI * 2); ctx.fill();
          if (rulerPoints.length === 2) {
            const p2 = rulerPoints[1];
            if (p2 && isFinite(p2.x) && isFinite(p2.y)) {
              const [p2x, p2y] = transformCoord(p2.x, p2.y);
              if (isFinite(p2x) && isFinite(p2y)) {
                ctx.beginPath(); ctx.arc(p2x, p2y, 5, 0, Math.PI * 2); ctx.fill();
                ctx.beginPath(); ctx.moveTo(p1x, p1y); ctx.lineTo(p2x, p2y); ctx.stroke();
                const distance = calculateDistance(p1, p2);
                if (isFinite(distance)) {
                  const midX = (p1x + p2x) / 2; const midY = (p1y + p2y) / 2;
                  const labelText = distance.toFixed(2) + ' м';
                  const textWidth = ctx.measureText(labelText).width;
                  ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                  ctx.fillRect(midX - textWidth / 2 - 4, midY - 8, textWidth + 8, 16);
                  ctx.fillStyle = '#e74c3c'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                  ctx.fillText(labelText, midX, midY);
                }
              }
            }
          }
        }
      }
      ctx.restore();
    }
    function drawSelectedCoordinateMarker(ctx) {
        if (!selectedCoordinate || !isFinite(selectedCoordinate.x) || !isFinite(selectedCoordinate.y)) return;
        const [selX, selY] = transformCoord(selectedCoordinate.x, selectedCoordinate.y);
        if (!isFinite(selX) || !isFinite(selY)) return;
        ctx.save(); ctx.setTransform(1, 0, 0, 1, 0, 0);
        ctx.fillStyle = 'rgba(255, 0, 0, 0.8)'; ctx.strokeStyle = 'white'; ctx.lineWidth = 2;
        ctx.beginPath(); ctx.arc(selX, selY, 6, 0, Math.PI * 2); ctx.fill(); ctx.stroke();
        ctx.restore();
    }
    function drawSnapHighlight(ctx) {
        if (!isMovingPoint || !snappedToPointVisual) return;
        const [snapX, snapY] = transformCoord(snappedToPointVisual.x, snappedToPointVisual.y);
        if (!isFinite(snapX) || !isFinite(snapY)) return;

        ctx.save();
        ctx.setTransform(1, 0, 0, 1, 0, 0);
        ctx.strokeStyle = 'rgba(0, 255, 0, 0.9)';
        ctx.lineWidth = 1.5;
        ctx.beginPath();
        ctx.arc(snapX, snapY, GRAB_POINT_RADIUS_SCREEN + 2, 0, Math.PI * 2);
        ctx.stroke();
        const crossSize = GRAB_POINT_RADIUS_SCREEN + 4;
        ctx.beginPath();
        ctx.moveTo(snapX - crossSize, snapY); ctx.lineTo(snapX + crossSize, snapY);
        ctx.moveTo(snapX, snapY - crossSize); ctx.lineTo(snapX, snapY + crossSize);
        ctx.stroke();
        ctx.restore();
    }
    function determineGridStep() {
        const possibleSteps = [0.01, 0.05, 0.1, 0.5, 1, 5, 10, 50, 100, 200, 500, 1000, 5000, 10000, 50000];
        const targetPixelSize = 40;
        let bestStep = 100;
        if (!hasValidView() || scale <= 0) return bestStep;
        for (const step of possibleSteps) {
            const pixelSize = step * scale;
            if (pixelSize >= targetPixelSize) { bestStep = step; break; }
            bestStep = step;
        }
        if (bestStep * scale < 10 && possibleSteps.indexOf(bestStep) < possibleSteps.length - 1) {
            bestStep = possibleSteps[possibleSteps.indexOf(bestStep) + 1];
        }
        return bestStep;
    }
    function updateGridInfo(gridStep) {
        let stepText;
        if (!isFinite(gridStep) || gridStep <= 0) stepText = '-';
        else if (gridStep < 0.1) stepText = `${(gridStep * 100).toFixed(0)} см`;
        else if (gridStep < 1) stepText = `${gridStep.toFixed(1)} м`;
        else if (gridStep >= 1000) stepText = `${(gridStep / 1000).toFixed(1)} км`;
        else stepText = `${gridStep.toFixed(0)} м`;
        gridInfoText.textContent = ` ${stepText}`;
    }
    function drawGrid(ctx, gridStep) {
        if (!hasValidView() || !isFinite(gridStep) || gridStep <= 0) return;
        ctx.save(); ctx.setTransform(1, 0, 0, 1, 0, 0);
        ctx.strokeStyle = 'rgba(200, 200, 200, 0.6)'; ctx.lineWidth = 0.5;
        ctx.beginPath();
        const cW = canvas.width, cH = canvas.height, tol = 10;
        const tl = inverseTransformCoord(0, 0); const br = inverseTransformCoord(cW, cH);
        if (!isFinite(tl.x) || !isFinite(tl.y) || !isFinite(br.x) || !isFinite(br.y)) { ctx.restore(); return; }
        const minDX = Math.min(tl.x, br.x), maxDX = Math.max(tl.x, br.x);
        const minDY = Math.min(tl.y, br.y), maxDY = Math.max(tl.y, br.y);
        const startDX = Math.floor(minDX / gridStep) * gridStep;
        const endDX = Math.ceil(maxDX / gridStep) * gridStep;
        const startDY = Math.floor(minDY / gridStep) * gridStep;
        const endDY = Math.ceil(maxDY / gridStep) * gridStep;
        for (let dX = startDX; dX <= endDX; dX += gridStep) {
            const [, lCY] = transformCoord(dX, 0);
            if (isFinite(lCY) && lCY >= -tol && lCY <= cH + tol) { ctx.moveTo(0, lCY); ctx.lineTo(cW, lCY); }
        }
        for (let dY = startDY; dY <= endDY; dY += gridStep) {
            const [lCX, ] = transformCoord(0, dY);
            if (isFinite(lCX) && lCX >= -tol && lCX <= cW + tol) { ctx.moveTo(lCX, 0); ctx.lineTo(lCX, cH); }
        }
        ctx.stroke(); ctx.restore();
    }
    function countSharedVertices(poly1, poly2) {
        if (!poly1 || !poly2 || poly1.length === 0 || poly2.length === 0) return 0;
        let sharedCount = 0;
        const uniquePoly2Points = []; const addedCoords = new Set();
        for (const p2 of poly2) {
            if (!p2 || !isFinite(p2.x) || !isFinite(p2.y)) continue;
            const coordKey = `${p2.x}_${p2.y}`;
            if (!addedCoords.has(coordKey)) { uniquePoly2Points.push(p2); addedCoords.add(coordKey); }
        }
        for (const p1 of poly1) {
            if (!p1 || !isFinite(p1.x) || !isFinite(p1.y)) continue;
            for (const p2 of uniquePoly2Points) {
                if (p1.x === p2.x && p1.y === p2.y) {
                    sharedCount++; break;
                }
            }
        }
        return sharedCount;
    }
    function updateCursorInfo(x, y) {
        if (!isFinite(x) || !isFinite(y)) { cursorCoordinates.textContent = `X: -, Y: -`; }
        else { cursorCoordinates.textContent = `X: ${x.toFixed(2)}, Y: ${y.toFixed(2)}`; }
    }

    function handleMouseDown(e) {
        const rect = canvas.getBoundingClientRect();
        const canvasMouseX = e.clientX - rect.left;
        const canvasMouseY = e.clientY - rect.top;
        const clickDataPoint = inverseTransformCoord(canvasMouseX, canvasMouseY);

        if (isDrawingMode && isDrawingActive) return;
        if (rulerMode) return;

        if (isGeometryEditMode && editingObjectIndex !== -1) {
            const obj = userObjects[editingObjectIndex];
            if (!obj || !obj.contours) { deactivateGeometryEditMode(); return; }

            const grabRadiusDataSq = (GRAB_POINT_RADIUS_SCREEN / scale) ** 2;
            let foundPointToEdit = false;

            for (let cIdx = 0; cIdx < obj.contours.length; cIdx++) {
                const contour = obj.contours[cIdx];
                if (!contour) continue;
                for (let pIdx = 0; pIdx < contour.length; pIdx++) {
                    const point = contour[pIdx];
                    if (!point || !isFinite(point.x) || !isFinite(point.y)) continue;
                    const distSq = (clickDataPoint.x - point.x)**2 + (clickDataPoint.y - point.y)**2;
                    if (distSq < grabRadiusDataSq) {
                        isMovingPoint = true;
                        movedPointInfo = {
                            objectIndex: editingObjectIndex, contourIndex: cIdx, pointIndex: pIdx,
                            originalX: point.x, originalY: point.y
                        };
                        saveGeometryStateForUndo(editingObjectIndex);
                        canvas.classList.add('editing-point-mode');
                        isDragging = false;
                        foundPointToEdit = true;
                        redraw(true);
                        break;
                    }
                }
                if (foundPointToEdit) break;
            }
            if (foundPointToEdit) return;
            return;
        }

        isDragging = true;
        startX = e.clientX; startY = e.clientY;
        lastOffsetX = offsetX; lastOffsetY = offsetY;
        canvas.style.cursor = 'grabbing';
    }


    function handleMouseMove(e) {
        const r = canvas.getBoundingClientRect();
        const cX = e.clientX - r.left; const cY = e.clientY - r.top;

        if (!hasValidView()) {
            updateCursorInfo(NaN, NaN); canvas.style.cursor = 'not-allowed'; tooltip.style.display = 'none';
            return;
        }
        const dP = inverseTransformCoord(cX, cY);
        updateCursorInfo(dP.x, dP.y);
        currentMousePos = { x: dP.x, y: dP.y };

        if (isMovingPoint && movedPointInfo) {
            let targetPoint = { x: currentMousePos.x, y: currentMousePos.y };
            snappedToPointVisual = null;
            const snapRadiusDataSq = (SNAP_RADIUS_SCREEN / scale) ** 2;
            let bestSnapDistSq = snapRadiusDataSq;

            for (const snapObj of userObjects) {
                if (!snapObj.contours) continue;
                for (const snapContour of snapObj.contours) {
                    if (!snapContour) continue;
                    for (let i = 0; i < snapContour.length; i++) {
                        const snapCandidatePt = snapContour[i];
                        if (snapObj === userObjects[movedPointInfo.objectIndex] &&
                            snapContour === userObjects[movedPointInfo.objectIndex].contours[movedPointInfo.contourIndex] &&
                            i === movedPointInfo.pointIndex) {
                            continue;
                        }
                        const distSq = (currentMousePos.x - snapCandidatePt.x)**2 + (currentMousePos.y - snapCandidatePt.y)**2;
                        if (distSq < bestSnapDistSq) {
                            bestSnapDistSq = distSq;
                            targetPoint = { x: snapCandidatePt.x, y: snapCandidatePt.y };
                            snappedToPointVisual = { ...targetPoint };
                        }
                    }
                }
            }

            const objToUpdate = userObjects[movedPointInfo.objectIndex];
            const pointToUpdate = objToUpdate.contours[movedPointInfo.contourIndex][movedPointInfo.pointIndex];
            pointToUpdate.x = targetPoint.x;
            pointToUpdate.y = targetPoint.y;

            updateObjectMetrics(objToUpdate);
            if (movedPointInfo.objectIndex === selectedObjectIndex) {
                displayObjectInfo(selectedObjectIndex);
            }
            redraw(true);

        } else if (isDragging) {
             offsetX = lastOffsetX + (e.clientX - startX);
             offsetY = lastOffsetY - (e.clientY - startY);
            redraw(true);
            tooltip.style.display = 'none';
        } else {
            let hObjArea = false;
            let hPointInfo = null;
            let hSegment = false;

            const hoverPointRadiusDataSq = (GRAB_POINT_RADIUS_SCREEN / scale)**2;
            let minPtDistSq = hoverPointRadiusDataSq;

            if (!rulerMode && !isDrawingActive && !isGeometryEditMode && isFinite(dP.x) && isFinite(dP.y)) {
                for (let i = userObjects.length - 1; i >= 0; i--) {
                    const o = userObjects[i];
                    if (o?.type === 'polygon' && o.contours?.[0] && isPointInPolygon(dP, o.contours[0])) {
                        hObjArea = true; break;
                    }
                }
            }
            if (showPoints && isFinite(dP.x) && isFinite(dP.y)) {
                 for (let i = userObjects.length - 1; i >= 0; i--) {
                     const o = userObjects[i];
                     if (!o?.contours || o.type === 'point') continue;
                     if (isGeometryEditMode && editingObjectIndex !== -1 && i !== editingObjectIndex) continue;

                     for (let cIdx = 0; cIdx < o.contours.length; cIdx++) {
                         const c = o.contours[cIdx]; if (!c) continue;
                         for (let pIdx = 0; pIdx < c.length; pIdx++) {
                             const p = c[pIdx];
                             if (p && isFinite(p.x) && isFinite(p.y)) {
                                 const dx = p.x - dP.x; const dy = p.y - dP.y;
                                 const distanceSq = dx * dx + dy * dy;
                                 if (distanceSq < minPtDistSq) {
                                     minPtDistSq = distanceSq;
                                     hPointInfo = { point: p, objectIndex: i, contourIndex: cIdx, pointInContourIndex: pIdx };
                                 }
                             }
                         }
                     }
                 }
            }
            if (isGeometryEditMode && editingObjectIndex !== -1 && !hPointInfo) {
                const obj = userObjects[editingObjectIndex];
                if (obj && obj.contours) {
                    const addPointThresholdDataSq = (ADD_POINT_THRESHOLD_SCREEN / scale)**2;
                    obj.contours.forEach(contour => {
                        if (!contour || contour.length < (obj.type === 'line' ? 1 : 2)) return;
                        const numSegments = obj.type === 'polygon' ? contour.length : contour.length - 1;
                         if (numSegments < 1 && obj.type !== 'point') return;

                        for (let sIdx = 0; sIdx < numSegments; sIdx++) {
                            const p1 = contour[sIdx];
                            const p2 = contour[(sIdx + 1) % (obj.type === 'polygon' ? contour.length : Infinity)];
                             if (!p2 && obj.type === 'line' && sIdx === contour.length -1) continue;
                            const closestPtOnSeg = getClosestPointOnSegment(dP, p1, p2);
                            const distSq = (dP.x - closestPtOnSeg.x)**2 + (dP.y - closestPtOnSeg.y)**2;
                            if (distSq < addPointThresholdDataSq) {
                                hSegment = true; break;
                            }
                        }
                        if (hSegment) return;
                    });
                }
            }

            if (hPointInfo) {
                 const hPt = hPointInfo.point; let tooltipText = ''; let sequentialIndex = -1;
                 if (selectedObjectIndex !== -1 && hPointInfo.objectIndex === selectedObjectIndex) {
                     const selObj = userObjects[selectedObjectIndex];
                     if (selObj && selObj.contours) {
                         let counter = 1; let found = false;
                         for (let cIdx = 0; cIdx < selObj.contours.length; cIdx++) {
                             const contour = selObj.contours[cIdx]; if (!contour) continue;
                             for (let pIdx = 0; pIdx < contour.length; pIdx++) {
                                 const pt = contour[pIdx]; if (!pt || !isFinite(pt.x) || !isFinite(pt.y)) continue;
                                 if (cIdx === hPointInfo.contourIndex && pIdx === hPointInfo.pointInContourIndex) {
                                     sequentialIndex = counter; found = true; break;
                                 }
                                 counter++;
                             }
                             if (found) break;
                         }
                     }
                 }
                 tooltipText = sequentialIndex !== -1 ? `№: ${sequentialIndex}\nX: ${hPt.x.toFixed(2)}\nY: ${hPt.y.toFixed(2)}` : `X: ${hPt.x.toFixed(2)}\nY: ${hPt.y.toFixed(2)}`;
                 if(isGeometryEditMode && hPointInfo.objectIndex === editingObjectIndex && hPointInfo.point){
                     tooltipText += "\n(ПКМ для удаления)";
                 }
                 const pointState = getPointState(hPt, hPointInfo.objectIndex);
                 let tooltipColor = 'rgba(52, 152, 219, 0.85)';
                 if (pointState.isCoincident) tooltipColor = 'rgba(46, 204, 113, 0.85)';
                 else if (pointState.isInsideOther) tooltipColor = 'rgba(231, 76, 60, 0.85)';
                 tooltip.style.backgroundColor = tooltipColor; tooltip.style.color = 'white';
                 tooltip.style.display = 'block'; tooltip.textContent = tooltipText;
                 tooltip.style.left = `${e.clientX + 10}px`; tooltip.style.top = `${e.clientY + 10}px`;
                 tooltip.style.whiteSpace = 'pre';
            } else {
                 tooltip.style.display = 'none';
            }

            canvas.classList.remove('geometry-edit-mode-hover-point', 'geometry-edit-mode-add');

            if (isDrawingActive) canvas.style.cursor = 'crosshair';
            else if (rulerMode) canvas.style.cursor = 'crosshair';
            else if (isGeometryEditMode && editingObjectIndex !== -1) {
                if (hPointInfo && hPointInfo.objectIndex === editingObjectIndex) {
                    canvas.classList.add('geometry-edit-mode-hover-point');
                    canvas.style.cursor = '';
                } else if (hSegment) {
                    canvas.classList.add('geometry-edit-mode-add');
                    canvas.style.cursor = '';
                }
                else canvas.style.cursor = 'default';
            }
            else if (hPointInfo || hObjArea) canvas.style.cursor = 'pointer';
            else canvas.style.cursor = 'grab';

            if (isDrawingActive || isGeometryEditMode) redraw(true);
        }
    }


    function handleMouseOut() {
        if (isDragging) {
            isDragging = false;
            if (!isDrawingMode && !isMovingPoint && !rulerMode && !isGeometryEditMode) canvas.style.cursor = 'grab';
            saveState();
        }
        tooltip.style.display = 'none';
        if (isDrawingActive && currentDrawingPoints.length > 0) {
            currentMousePos = currentDrawingPoints[currentDrawingPoints.length-1] || {x:NaN, y:NaN};
            redraw(true);
        }
        updateCursorInfo(NaN, NaN);
    }

    function handleMouseUp(e) {
        const wasMovingPoint = isMovingPoint;

        if (isMovingPoint) {
            isMovingPoint = false;
            snappedToPointVisual = null;
            canvas.classList.remove('editing-point-mode');
            updateObjectMetrics(userObjects[movedPointInfo.objectIndex]);
            if (movedPointInfo.objectIndex === selectedObjectIndex) {
                 displayObjectInfo(selectedObjectIndex);
            }
            movedPointInfo = null;
            saveState();
            redraw(true);
            window.lastPointMoveEndTime = Date.now();
        } else if (isDragging) {
            isDragging = false;
            saveState();
        }

        if (!rulerMode && !isDrawingMode && !isGeometryEditMode && !isMovingPoint) {
            canvas.style.cursor = 'grab';
        }
    }

    function handleWheel(e) {
        if ((isDrawingMode && isDrawingActive) || isMovingPoint) {
            e.preventDefault(); return;
        }
        e.preventDefault();
        if (!hasValidView()) { calculateBounds(); resetView(); if (!hasValidView()) return; }

        const zoomFactor = 1.1;
        const zoomDir = e.deltaY < 0 ? zoomFactor : 1 / zoomFactor;

        const rect = canvas.getBoundingClientRect();
        const mouseCX = e.clientX - rect.left; const mouseCY = e.clientY - rect.top;
        const dataMouseBefore = inverseTransformCoord(mouseCX, mouseCY);
        if (!isFinite(dataMouseBefore.x) || !isFinite(dataMouseBefore.y)) return;

        const newScale = scale * zoomDir;
        const minScale = 1e-9, maxScale = 10000;
        if (newScale < minScale || newScale > maxScale) return;
        scale = newScale;

        offsetX = mouseCX - (dataMouseBefore.y - cMinYGlob()) * scale;
        offsetY = canvas.height - mouseCY - (dataMouseBefore.x - cMinXGlob()) * scale;

        if (!hasValidView()) resetView();
        redraw(true); updateViewInfo(); saveState();
    }

    function getClosestPointOnSegment(p, a, b) {
        const abx = b.x - a.x;
        const aby = b.y - a.y;
        const apx = p.x - a.x;
        const apy = p.y - a.y;

        const ab_ab = abx * abx + aby * aby;
        if (ab_ab === 0) return { x: a.x, y: a.y };

        let t = (apx * abx + apy * aby) / ab_ab;
        t = Math.max(0, Math.min(1, t));

        return {
            x: roundCoord(a.x + t * abx),
            y: roundCoord(a.y + t * aby)
        };
    }


    function handleClick(e) {
        if (e.button !== 0) return;

        const timeSinceLastPointMoveEnd = Date.now() - (window.lastPointMoveEndTime || 0);
        if (timeSinceLastPointMoveEnd < 50) {
            return;
        }

        if (e.detail > 1) return;
        if (!hasValidView()) return;


        const r = canvas.getBoundingClientRect();
        const cX = e.clientX - r.left; const cY = e.clientY - r.top;
        const dP = inverseTransformCoord(cX, cY);
        if (!isFinite(dP.x) || !isFinite(dP.y)) return;

        if (isDrawingMode && isDrawingActive) {
            currentDrawingPoints.push({ x: dP.x, y: dP.y });
            redraw(true);
        } else if (rulerMode) {
            if (rulerPoints.length < 2) {
                rulerPoints.push({ x: dP.x, y: dP.y });
                updateMeasurementPanel(); redraw(true);
                if (rulerPoints.length === 2) {
                    const dist = calculateDistance(rulerPoints[0], rulerPoints[1]);
                    if (isFinite(dist)) showNotification(`Расстояние: ${dist.toFixed(2)} м`, "success", "ruler");
                    else showNotification(`Не удалось измерить`, "error");
                }
            }
        } else if (isGeometryEditMode && editingObjectIndex !== -1 && !e.altKey) {
            const obj = userObjects[editingObjectIndex];
            if (!obj || !obj.contours) return;

            let bestMatch = { distSq: Infinity, contourIndex: -1, segmentIndex: -1, newPoint: null };
            const clickThresholdDataSq = (ADD_POINT_THRESHOLD_SCREEN / scale)**2;

            obj.contours.forEach((contour, cIdx) => {
                if (!contour || contour.length < (obj.type === 'line' ? 1 : 2) ) return;
                const numSegments = obj.type === 'polygon' ? contour.length : contour.length -1;
                 if (numSegments < 1 && obj.type !== 'point') return;

                for (let sIdx = 0; sIdx < numSegments; sIdx++) {
                    const p1 = contour[sIdx];
                    const p2 = contour[(sIdx + 1) % (obj.type === 'polygon' ? contour.length : Infinity)];
                    if (!p2 && obj.type==='line' && sIdx === contour.length -1) continue;

                    const closestPtOnSeg = getClosestPointOnSegment(dP, p1, p2);
                    const distSq = (dP.x - closestPtOnSeg.x)**2 + (dP.y - closestPtOnSeg.y)**2;

                    if (distSq < bestMatch.distSq && distSq < clickThresholdDataSq) {
                        bestMatch = {
                            distSq, contourIndex: cIdx, segmentIndex: sIdx,
                            newPoint: closestPtOnSeg
                        };
                    }
                }
            });

            if (bestMatch.newPoint) {
                saveGeometryStateForUndo(editingObjectIndex);
                const contourToModify = userObjects[editingObjectIndex].contours[bestMatch.contourIndex];
                contourToModify.splice(bestMatch.segmentIndex + 1, 0, bestMatch.newPoint);
                updateObjectMetrics(userObjects[editingObjectIndex]);
                displayObjectInfo(editingObjectIndex);
                showNotification("Точка добавлена на сегмент.", "success", "plus-circle");
                redraw(true); saveState();
                return;
            }
        }
    }

    function handleContextMenu(e) {
        e.preventDefault();
        if (!isGeometryEditMode || editingObjectIndex === -1) return;

        const r = canvas.getBoundingClientRect();
        const cX = e.clientX - r.left; const cY = e.clientY - r.top;
        const clickDataPoint = inverseTransformCoord(cX, cY);

        const obj = userObjects[editingObjectIndex];
        if (!obj || !obj.contours) return;

        const grabRadiusDataSq = (GRAB_POINT_RADIUS_SCREEN / scale) ** 2;
        let pointToDeleteInfo = null;

        for (let cIdx = 0; cIdx < obj.contours.length; cIdx++) {
            const contour = obj.contours[cIdx];
            if (!contour) continue;
            const minPoints = obj.type === 'polygon' ? 3 : (obj.type === 'line' ? 2 : Infinity);

            for (let pIdx = 0; pIdx < contour.length; pIdx++) {
                const point = contour[pIdx];
                if (!point || !isFinite(point.x) || !isFinite(point.y)) continue;
                const distSq = (clickDataPoint.x - point.x)**2 + (clickDataPoint.y - point.y)**2;
                if (distSq < grabRadiusDataSq) {
                    if (contour.length > minPoints) {
                        pointToDeleteInfo = { contourIndex: cIdx, pointIndex: pIdx, object: obj };
                    } else {
                        showNotification(`Нельзя удалить вершину: у ${obj.type === 'polygon' ? 'полигона' : 'линии'} должно быть минимум ${minPoints} вершин${obj.type === 'polygon' ? 'ы' : ''}.`, "warning", "ban");
                        return;
                    }
                    break;
                }
            }
            if (pointToDeleteInfo) break;
        }

        if (pointToDeleteInfo) {
            if (window.confirm("Удалить выбранную вершину?")) {
                saveGeometryStateForUndo(editingObjectIndex);
                const contourToModify = pointToDeleteInfo.object.contours[pointToDeleteInfo.contourIndex];
                contourToModify.splice(pointToDeleteInfo.pointIndex, 1);
                updateObjectMetrics(pointToDeleteInfo.object);
                displayObjectInfo(editingObjectIndex);
                showNotification("Вершина удалена.", "info", "trash-alt");
                redraw(true);
                saveState();
            }
        }
    }


    function handleDoubleClick(e) {
        e.preventDefault();
        if (!hasValidView()) return;
        const r = canvas.getBoundingClientRect();
        const cX = e.clientX - r.left; const cY = e.clientY - r.top;
        const dP = inverseTransformCoord(cX, cY);
        if (!isFinite(dP.x) || !isFinite(dP.y)) return;

        if (isDrawingMode && isDrawingActive) {
            finishDrawingAsPolygon();
        } else if (!rulerMode && !isMovingPoint && !isGeometryEditMode) {
            selectObjectByPoint(dP);
        }
    }

    function selectObjectByPoint(dataClickPoint) {
        let clickedIdx = -1; let minArea = Infinity;
        userObjects.forEach((obj, index) => {
            if (!obj || !obj.contours) return;
            let containsPoint = false;
            for (const contour of obj.contours) {
                if (obj.type === 'polygon' && contour && contour.length >= 3 && isPointInPolygon(dataClickPoint, contour)) {
                    containsPoint = true; break;
                }
            }
            if (containsPoint) {
                const area = (obj.area !== undefined && isFinite(obj.area)) ? obj.area : Infinity;
                if (area < minArea) { minArea = area; clickedIdx = index; }
            }
        });
        if (clickedIdx !== -1) {
            if (isGeometryEditMode && editingObjectIndex !== clickedIdx) {
                deactivateGeometryEditMode(false);
            }
            selectedObjectIndex = clickedIdx;
            displayObjectInfo(selectedObjectIndex); updateObjectListSelection();
        } else {
            if (!isGeometryEditMode) {
                selectedObjectIndex = -1;
                displayObjectInfo(-1); updateObjectListSelection();
            }
        }
        selectedCoordinate = null;
        redraw(true);
    }
    function centerOnObject(index, adjustZoom = false) {
        if (index < 0 || index >= userObjects.length || !userObjects[index]) return;
        const obj = userObjects[index];
        if (!obj.contours || obj.contours.length === 0 || !obj.contours[0] || obj.contours[0].length === 0) {
            showNotification("Невозможно центрировать: нет валидных координат.", "warning", "exclamation-triangle"); return;
        };
        let oMinX = Infinity, oMinY = Infinity, oMaxX = -Infinity, oMaxY = -Infinity, hasPts = false;
        obj.contours.forEach(c => {
            if (!c) return;
            c.forEach(p => {
                if (p && isFinite(p.x) && isFinite(p.y)) {
                    oMinX = Math.min(oMinX, p.x); oMinY = Math.min(oMinY, p.y);
                    oMaxX = Math.max(oMaxX, p.x); oMaxY = Math.max(oMaxY, p.y);
                    hasPts = true;
                }
            });
        });
        if (!hasPts) {
            showNotification("Невозможно центрировать: координаты объекта невалидны.", "error", "exclamation-circle"); return;
        }
        const oW = Math.max(1e-6, oMaxX - oMinX); const oH = Math.max(1e-6, oMaxY - oMinY);
        const oCX = oMinX + oW / 2; const oCY = oMinY + oH / 2;
        const cW = canvas.width || 100; const cH = canvas.height || 100;
        calculateBounds();
        if (adjustZoom) {
            const sX = cW / oW * 0.8; const sY = cH / oH * 0.8;
            let nS = Math.min(sX, sY);
            nS = Math.max(1e-9, Math.min(nS, 10000));
            if (!isFinite(nS) || nS <= 0) nS = scale; scale = nS;
        }
        offsetX = cW / 2 - (roundCoord(oCY) - cMinYGlob()) * scale;
        offsetY = cH / 2 - (roundCoord(oCX) - cMinXGlob()) * scale;
        if (!hasValidView()) resetView();
        updateViewInfo(); redraw(true); saveState();
        if (!adjustZoom) showNotification(`Центрировано на "${obj.name || `Объект ${obj.id}`}"`, "info", "crosshairs");
    }
    function addInfoItem(label, value, isCopyable = false, objectIndex = -1) {
        let displayValue = 'Н/Д';
        if (value !== undefined && value !== null) {
            if (typeof value === 'number' && isFinite(value)) {
                displayValue = value.toFixed(2);
            } else if (typeof value === 'string') {
                displayValue = value;
            } else if (typeof value === 'number') {
                 displayValue = 'Не число';
            }
        }
        const itemDiv = document.createElement('div'); itemDiv.className = 'info-item';
        const labelSpan = document.createElement('span'); labelSpan.textContent = label;
        const valueSpan = document.createElement('span'); valueSpan.textContent = displayValue;
        if (label === 'Цвет' && value !== 'Н/Д' && objectIndex !== -1) {
            valueSpan.classList.add('color-picker-trigger'); valueSpan.title = 'Кликните для выбора цвета';
            valueSpan.style.cursor = 'pointer'; valueSpan.style.fontWeight = 'bold';
            const colorSwatch = document.createElement('span');
            colorSwatch.style.display = 'inline-block'; colorSwatch.style.width = '12px'; colorSwatch.style.height = '12px';
            colorSwatch.style.backgroundColor = value; colorSwatch.style.border = '1px solid #ccc';
            colorSwatch.style.marginRight = '5px'; colorSwatch.style.verticalAlign = 'middle';
            valueSpan.prepend(colorSwatch);
        } else if (isCopyable && displayValue !== 'Н/Д' && displayValue !== 'Не число') {
            valueSpan.classList.add('copyable'); valueSpan.title = 'Двойной клик для копирования';
            valueSpan.ondblclick = (e) => {
                e.stopPropagation(); copyToClipboard(value.toString());
                valueSpan.classList.add('flash'); setTimeout(() => valueSpan.classList.remove('flash'), 500);
            };
        }
        itemDiv.appendChild(labelSpan); itemDiv.appendChild(valueSpan);
        selectedObjectInfoDiv.appendChild(itemDiv); return itemDiv;
    }
    function displayObjectInfo(index) {
        selectedObjectIndex = index;
        if (isGeometryEditMode && editingObjectIndex !== selectedObjectIndex) {
            deactivateGeometryEditMode(false);
        }

        selectedObjectInfoDiv.innerHTML = ''; coordinatesTableContainer.innerHTML = '';
        intersectionList.innerHTML = ''; intersectionsTitle.style.display = 'none';

        if (index < 0 || index >= userObjects.length || !userObjects[index]) {
            selectedObjectInfoDiv.innerHTML = '<p style="color: #777; font-style: italic; text-align: center;">Объект не выбран.</p>';
            updateObjectListSelection(); return;
        }
        const obj = userObjects[index];
        const nameContainer = document.createElement('div'); nameContainer.style.marginBottom = '10px';
        const nameLabel = document.createElement('h3'); nameLabel.textContent = obj.name || `Объект ${obj.id}`;
        nameLabel.title = "Кликните для переименования"; nameLabel.onclick = () => handleRenameRequest(index);
        nameContainer.appendChild(nameLabel); selectedObjectInfoDiv.appendChild(nameContainer);

        const pointCount = (obj.contours || []).reduce((sum, c) => sum + (c ? c.length : 0), 0);
        let typeDisplay = 'Н/Д';
        if (obj.type === 'polygon') typeDisplay = 'Полигон';
        else if (obj.type === 'line') typeDisplay = 'Линия';
        else if (obj.type === 'point') typeDisplay = 'Точка';

        addInfoItem('ID', obj.id); addInfoItem('Тип', typeDisplay);
        addInfoItem('Цвет', obj.color || 'Н/Д', false, index);
        addInfoItem(obj.type === 'line' ? 'Длина (м)' : 'Периметр (м)', obj.perimeter);
        addInfoItem('Площадь (кв. м)', obj.type === 'polygon' && obj.area > 1e-9 ? obj.area : 0);
        addInfoItem('Контуры', (obj.contours || []).length); addInfoItem('Точки', pointCount);

        const colorValueSpan = selectedObjectInfoDiv.querySelector('.color-picker-trigger');
        if (colorValueSpan) {
             colorValueSpan.onclick = (e) => {
                 e.stopPropagation();
                 if (index < 0 || index >= userObjects.length || !userObjects[index]) return;
                 const currentColor = userObjects[index].color || '#000000';
                 const colorInput = document.createElement('input');
                 colorInput.type = 'color'; colorInput.value = currentColor;
                 colorInput.style.position = 'absolute'; colorInput.style.left = '-9999px'; colorInput.style.top = '-9999px';
                 colorInput.onchange = (event) => {
                     const newColor = event.target.value; userObjects[index].color = newColor;
                     colorValueSpan.textContent = newColor;
                     const colorSwatch = colorValueSpan.querySelector('span');
                     if (colorSwatch) colorSwatch.style.backgroundColor = newColor;
                     else {
                           const newSwatch = document.createElement('span');
                           newSwatch.style.display = 'inline-block'; newSwatch.style.width = '12px'; newSwatch.style.height = '12px';
                           newSwatch.style.backgroundColor = newColor; newSwatch.style.border = '1px solid #ccc';
                           newSwatch.style.marginRight = '5px'; newSwatch.style.verticalAlign = 'middle';
                           colorValueSpan.prepend(newSwatch);
                     }
                     updateObjectListColorIndicator(index, newColor); redraw(true); saveState();
                     showNotification(`Цвет объекта "${obj.name || obj.id}" изменен на ${newColor}`, 'success', 'palette');
                     document.body.removeChild(colorInput);
                 };
                 document.body.appendChild(colorInput); colorInput.click();
                 colorInput.onblur = () => { setTimeout(() => { if (colorInput.parentNode === document.body) document.body.removeChild(colorInput); }, 100); };
            };
        }
        const btnContainer = document.createElement('div'); btnContainer.style.marginTop = '15px';
        const showCoordsBtn = document.createElement('button'); showCoordsBtn.id = 'showCoordinatesBtn'; showCoordsBtn.className = 'panel-button'; showCoordsBtn.innerHTML = '<i class="fas fa-list-ol"></i> Координаты'; showCoordsBtn.onclick = () => toggleCoordinatesTable(index); btnContainer.appendChild(showCoordsBtn);
        const copyAllCoordsBtn = document.createElement('button'); copyAllCoordsBtn.id = 'copyAllCoordinatesBtn'; copyAllCoordsBtn.className = 'panel-button'; copyAllCoordsBtn.innerHTML = '<i class="fas fa-copy"></i> Копировать'; copyAllCoordsBtn.title = 'Скопировать все координаты объекта (X\tY)'; copyAllCoordsBtn.onclick = () => handleCopyAllCoordinates(index); btnContainer.appendChild(copyAllCoordsBtn);
        const centerBtn = document.createElement('button'); centerBtn.id = 'centerObjectBtn'; centerBtn.className = 'panel-button'; centerBtn.innerHTML = '<i class="fas fa-crosshairs"></i> Центрировать'; centerBtn.onclick = () => centerOnObject(index, false); btnContainer.appendChild(centerBtn);
        const renameBtn = document.createElement('button'); renameBtn.id = 'renameObjectBtn'; renameBtn.className = 'panel-button'; renameBtn.innerHTML = '<i class="fas fa-pencil-alt"></i> Переименовать'; renameBtn.onclick = () => handleRenameRequest(index); btnContainer.appendChild(renameBtn);
        const deleteBtn = document.createElement('button'); deleteBtn.id = 'deleteObjectBtn'; deleteBtn.className = 'panel-button'; deleteBtn.innerHTML = '<i class="fas fa-trash-alt"></i> Удалить'; deleteBtn.onclick = () => deleteObject(index); btnContainer.appendChild(deleteBtn);
        selectedObjectInfoDiv.appendChild(btnContainer);

        calculateAndDisplayIntersections(index); updateObjectListSelection();
    }
    function handleCopyAllCoordinates(objectIndex) {
        if (objectIndex < 0 || objectIndex >= userObjects.length || !userObjects[objectIndex]) {
            showNotification("Объект не выбран или невалиден.", "error", "exclamation-circle"); return;
        }
        const obj = userObjects[objectIndex];
        if (!obj.contours || obj.contours.length === 0) {
            showNotification("У объекта нет координат для копирования.", "warning", "exclamation-triangle"); return;
        }
        let allCoordsString = "";
        obj.contours.forEach((contour, cIdx) => {
            if (!contour) return;
            contour.forEach(point => {
                if (point && isFinite(point.x) && isFinite(point.y)) {
                    allCoordsString += `${point.x.toFixed(2)}\t${point.y.toFixed(2)}\n`;
                }
            });
            if (obj.contours.length > 1 && cIdx < obj.contours.length - 1 && contour.length > 0) {
                 allCoordsString += "\n"; // Add blank line between contours for multi-contour objects
            }
        });
        if (allCoordsString.trim() === "") {
            showNotification("Нет валидных координат для копирования.", "warning", "exclamation-triangle"); return;
        }
        copyToClipboard(allCoordsString.trim());
    }
    function toggleCoordinatesTable(index) {
        if (index < 0 || index >= userObjects.length || !userObjects[index]) return;
        const obj = userObjects[index];
        const btn = document.getElementById('showCoordinatesBtn');
        const isVisible = coordinatesTableContainer.querySelector('.coordinates-table') !== null;

        if (isVisible) {
            coordinatesTableContainer.innerHTML = '';
            if (btn) btn.innerHTML = '<i class="fas fa-list-ol"></i> Координаты';
            selectedCoordinate = null;
            redraw(true);
        } else {
            let selectedPointsForTable = [];
            let pointCounter = 1;

          (obj.contours || []).forEach((contour, contourIndex) => {
                if (!contour || contour.length === 0) return;

                let isClosingPointIdenticalToFirstForThisContour = false; // ADDED: Tracks if the current contour is closed by a duplicate point

                if (obj.contours.length > 1) { // Add contour header for multi-contour objects
                    selectedPointsForTable.push({isHeader: true, text: `Контур ${contourIndex + 1}`});
                }

                contour.forEach((point, pIdx) => {
                    if (point && isFinite(point.x) && isFinite(point.y)) {
                        let displayPointNumber;
                        let isThisSpecificPointADuplicateCloser = false; // MODIFIED: Renamed from isClosingPointIdenticalToFirst for clarity

                        if (obj.type === 'polygon' &&
                            pIdx === contour.length - 1 && // This condition ensures we only check the last point
                            contour.length > 1) {

                            const firstPt = contour[0];
                            const PRECISION_THRESHOLD = 0.001;
                            if (Math.abs(point.x - firstPt.x) < PRECISION_THRESHOLD &&
                                Math.abs(point.y - firstPt.y) < PRECISION_THRESHOLD) {
                                displayPointNumber = 1;
                                isThisSpecificPointADuplicateCloser = true;
                                isClosingPointIdenticalToFirstForThisContour = true; // MODIFIED: Set the contour-level flag
                            } else {
                                displayPointNumber = pointCounter;
                            }
                        } else {
                            displayPointNumber = pointCounter;
                        }

                        selectedPointsForTable.push({
                            contour: contourIndex + 1,
                            point: displayPointNumber,
                            x: point.x,
                            y: point.y,
                            isClosingDuplicate: isThisSpecificPointADuplicateCloser // MODIFIED: Use the point-specific flag
                        });

                        if (!isThisSpecificPointADuplicateCloser) { // MODIFIED: Use the point-specific flag
                            pointCounter++;
                        }
                    }
                });
                 // MODIFIED: Use the contour-level flag here
                 if (obj.type !== 'polygon' || contour.length === 0 || !isClosingPointIdenticalToFirstForThisContour) { 
                     pointCounter = 1; // Reset counter for each contour if not handling single sequence for multi-contour
                 }
            });

            displayCoordinatesTable(selectedPointsForTable);
            if (btn) btn.innerHTML = '<i class="fas fa-times"></i> Скрыть Координаты';
        }
    }
    function displayCoordinatesTable(points) {
        if (!points || points.length === 0) {
            coordinatesTableContainer.innerHTML = '<p style="color: #777; font-style: italic; text-align: center; margin-top: 10px;">Нет координат.</p>';
            return;
        }
        let tableHtml = `<table class="coordinates-table"><thead><tr><th>№ п/п</th><th>X</th><th>Y</th></tr></thead><tbody>`;
        points.forEach(point => {
            if (point.isHeader) {
                tableHtml += `<tr><th colspan="3" style="background-color: #e9ecef; text-align: center;">${point.text}</th></tr>`;
            } else {
                const rowClass = point.isClosingDuplicate ? 'coordinate-row closing-duplicate' : 'coordinate-row';
                tableHtml += `<tr class="${rowClass}" data-x="${point.x}" data-y="${point.y}"><td>${point.point}</td><td class="copyable">${point.x.toFixed(2)}</td><td class="copyable">${point.y.toFixed(2)}</td></tr>`;
            }
        });
        tableHtml += `</tbody></table>`;
        coordinatesTableContainer.innerHTML = tableHtml;
        coordinatesTableContainer.querySelectorAll('.coordinate-row:not(.closing-duplicate):not([data-is-header="true"])').forEach(row => { // Exclude headers and closing duplicates from full interactivity if needed
            row.querySelectorAll('.copyable').forEach(cell => {
                cell.ondblclick = function(e) {
                    e.stopPropagation();
                    copyToClipboard(this.textContent);
                    this.closest('tr')?.classList.add('flash');
                    setTimeout(() => this.closest('tr')?.classList.remove('flash'), 500);
                };
            });
            row.onclick = function() {
                document.querySelectorAll('.coordinate-row.selected-coordinate').forEach(r => r.classList.remove('selected-coordinate'));
                this.classList.add('selected-coordinate');
                const x = parseFloat(this.dataset.x);
                const y = parseFloat(this.dataset.y);
                if (isFinite(x) && isFinite(y)) {
                    selectedCoordinate = { x, y };
                    highlightPointOnMap(x, y);
                } else {
                    selectedCoordinate = null;
                }
            };
        });
    }
    function highlightPointOnMap(x, y) {
        if (!hasValidView() || !isFinite(x) || !isFinite(y)) return;
        let pulseSize = 8; let pulseOpacity = 1; let animationFrameId = null;
        const pulse = () => {
            redraw(true); if (pulseOpacity <= 0 || !hasValidView()) { window.currentPulseAnimation = null; redraw(true); return; }
            const [cx, cy] = transformCoord(x, y); if (!isFinite(cx) || !isFinite(cy)) { window.currentPulseAnimation = null; return; }
            ctx.save(); ctx.setTransform(1, 0, 0, 1, 0, 0);
            ctx.strokeStyle = `rgba(255, 0, 0, ${pulseOpacity})`; ctx.lineWidth = 2.5;
            ctx.beginPath(); ctx.arc(cx, cy, pulseSize, 0, Math.PI * 2); ctx.stroke();
            ctx.fillStyle = 'rgba(255, 0, 0, 0.8)'; ctx.strokeStyle = 'white'; ctx.lineWidth = 1;
            ctx.beginPath(); ctx.arc(cx, cy, 5, 0, Math.PI * 2); ctx.fill(); ctx.stroke();
            ctx.restore();
            pulseSize += 1.5; pulseOpacity -= 0.06;
            if (pulseOpacity > 0) animationFrameId = requestAnimationFrame(pulse);
            else { window.currentPulseAnimation = null; redraw(true); }
        };
        if (window.currentPulseAnimation) cancelAnimationFrame(window.currentPulseAnimation);
        window.currentPulseAnimation = requestAnimationFrame(pulse);
    }
    function calculateAndDisplayIntersections(selectedIndex) {
        intersectionList.innerHTML = '';
        if (selectedIndex < 0 || selectedIndex >= userObjects.length || !userObjects[selectedIndex]) {
            intersectionsTitle.style.display = 'none'; return;
        }
        const selectedObj = userObjects[selectedIndex];
        if (!selectedObj.contours || selectedObj.contours.length === 0 || selectedObj.type !== 'polygon') {
            intersectionList.innerHTML = '<li style="color: #777; font-style: italic;">Проверка пересечений доступна только для полигонов.</li>';
            intersectionsTitle.style.display = 'block'; return;
        }
        let hasRelations = false; const selPolygon = selectedObj.contours[0];
        if (!selPolygon || selPolygon.length < 3 || !selPolygon.every(p => p && isFinite(p.x) && isFinite(p.y))) {
            intersectionList.innerHTML = '<li style="color: #777; font-style: italic;">Выбранный объект не является валидным полигоном.</li>';
            intersectionsTitle.style.display = 'block'; return;
        }
        userObjects.forEach((otherObj, otherIndex) => {
            if (selectedIndex === otherIndex || !otherObj || !otherObj.contours || otherObj.contours.length === 0 || otherObj.type !== 'polygon') return;
            const otherPolygon = otherObj.contours[0];
            if (!otherPolygon || otherPolygon.length < 3 || !otherPolygon.every(p => p && isFinite(p.x) && isFinite(p.y))) return;
            const result = checkIntersection(selPolygon, otherPolygon);
            let message = ""; let liClass = ''; let relationFound = false;
            const otherName = otherObj.name || `Объект ${otherObj.id}`;
            if (result.contains) { message = `Полностью содержит <strong>${otherName}</strong>`; liClass = 'full-containment'; relationFound = true; }
            else if (result.containedBy) { message = `Полностью содержится в <strong>${otherName}</strong>`; liClass = 'contained-by'; relationFound = true; }
            else if (result.intersects) {
                let pointsPoly1InPoly2 = 0; selPolygon.forEach(p => { if (p && isFinite(p.x) && isFinite(p.y) && isPointInPolygon(p, otherPolygon)) pointsPoly1InPoly2++; });
                let pointsPoly2InPoly1 = 0; otherPolygon.forEach(p => { if (p && isFinite(p.x) && isFinite(p.y) && isPointInPolygon(p, selPolygon)) pointsPoly2InPoly1++; });
                if (pointsPoly1InPoly2 > result.sharedVertices || pointsPoly2InPoly1 > result.sharedVertices) {
                    message = `Имеет наложение на <strong>${otherName}</strong>`;
                    if (result.sharedVertices > 0) { const pw = result.sharedVertices === 1 ? 'точку' : (result.sharedVertices <= 4 ? 'ки' : 'ек'); message += ` (имеет ${result.sharedVertices} общих точ${pw})`; }
                    liClass = 'partial-overlap'; if (result.sharedVertices > 0) liClass += ' shared-vertices';
                } else {
                    if (result.sharedVertices > 0) { const pw = result.sharedVertices === 1 ? 'точку' : (result.sharedVertices <= 4 ? 'ки' : 'ек'); message = `Имеет общую границу с <strong>${otherName}</strong> (${result.sharedVertices} точ${pw})`; liClass = 'boundary-touch';}
                    else { message = `Имеет наложение на <strong>${otherName}</strong>`; liClass = 'partial-overlap';}
                }
                relationFound = true;
            } else if (result.sharedVertices > 0) { const pw = result.sharedVertices === 1 ? 'точку' : (result.sharedVertices <= 4 ? 'ки' : 'ек'); message = `Имеет общую границу с <strong>${otherName}</strong> (${result.sharedVertices} точ${pw})`; liClass = 'boundary-touch'; relationFound = true;}
            if (relationFound) { hasRelations = true; const li = document.createElement('li'); li.innerHTML = message; li.className = liClass; li.title = `Кликните для выбора объекта ${otherName}`; li.onclick = () => { displayObjectInfo(otherIndex); }; intersectionList.appendChild(li); }
        });
        intersectionsTitle.style.display = 'block';
        if (!hasRelations) intersectionList.innerHTML = '<li style="color: #777; font-style: italic;">Пересечений, наложений или общих границ не найдено.</li>';
    }
    function updateObjectList() {
        objectListUL.innerHTML = ''; const validObjects = userObjects.filter(o => o); objectCountSpan.textContent = validObjects.length;
        if (validObjects.length === 0) { objectListUL.innerHTML = '<li style="color: #777; font-style: italic; padding: 5px 0;">Нет объектов</li>'; return; }
        const sortedObjects = [...validObjects].sort((a, b) => (a.id || 0) - (b.id || 0));
        sortedObjects.forEach((obj) => {
            const originalIndex = userObjects.findIndex(o => o && o.id === obj.id); if (originalIndex === -1) return;
            const li = document.createElement('li'); li.dataset.originalIndex = originalIndex;
            const colorIndicator = document.createElement('span'); colorIndicator.className = 'color-indicator'; colorIndicator.style.backgroundColor = obj.color || '#ccc';
            const nameSpan = document.createElement('span'); nameSpan.className = 'name-span';
            const objName = obj.name || `Объект ${obj.id}`; nameSpan.textContent = objName; nameSpan.title = objName;
            li.appendChild(colorIndicator); li.appendChild(nameSpan);
            if (originalIndex === selectedObjectIndex) li.classList.add('selected');

            li.onclick = () => {
                const idx = parseInt(li.dataset.originalIndex);
                if (!isNaN(idx) && selectedObjectIndex !== idx) {
                    if (isDrawingMode && isDrawingActive) cancelDrawing();
                    if (isGeometryEditMode) deactivateGeometryEditMode(false);
                    displayObjectInfo(idx);
                    redraw(true);
                } else if (!isNaN(idx) && selectedObjectIndex === idx) {
                    if (isGeometryEditMode && editingObjectIndex !== idx) {
                        deactivateGeometryEditMode(false);
                        activateGeometryEditMode();
                    }
                }
            };
            objectListUL.appendChild(li);
        });
        updateObjectListSelection();
    }
    function updateObjectListSelection() {
        const items = objectListUL.querySelectorAll('li'); items.forEach(li => { if (!li.dataset.originalIndex) return; const idx = parseInt(li.dataset.originalIndex); if (isNaN(idx)) return; if (idx === selectedObjectIndex) { li.classList.add('selected'); requestAnimationFrame(() => { try { li.scrollIntoView({ behavior: 'smooth', block: 'nearest' }); } catch(e) { li.scrollIntoView(false); } }); } else { li.classList.remove('selected'); } });
    }
    function updateObjectListColorIndicator(objectIndex, newColor) {
        if (!objectListUL) return; const items = objectListUL.querySelectorAll('li'); items.forEach(li => { if (li.dataset.originalIndex === String(objectIndex)) { const colorIndicator = li.querySelector('.color-indicator'); if (colorIndicator) colorIndicator.style.backgroundColor = newColor || '#ccc'; } });
    }
    function showNotification(message, type = 'info', icon = 'info-circle') {
        const n = document.createElement('div'); n.className = `notification ${type}`; n.innerHTML = `<i class="fas fa-${icon}"></i> ${message}`; document.body.appendChild(n); requestAnimationFrame(() => { n.classList.add('show'); setTimeout(() => { n.classList.remove('show'); setTimeout(() => n.remove(), 500); }, 3000); });
    }
    function copyToClipboard(text) {
        if (text === undefined || text === null) text = ''; navigator.clipboard.writeText(text.toString()).then(() => { const sT = text.toString().substring(0, 30); showNotification(`Скопировано: "${sT}${text.toString().length > 30 ? '...' : ''}"`, 'success', 'check-circle'); }).catch(err => { showNotification('Ошибка копирования в буфер', 'error', 'exclamation-circle'); });
    }
    function hexToRgba(hex, alpha) {
        if (typeof alpha !== 'number' || !isFinite(alpha)) alpha = 1.0; alpha = Math.max(0, Math.min(1, alpha)); if (!hex || typeof hex !== 'string') hex = '#000000'; hex = hex.replace('#', ''); if (hex.length === 3) hex = hex[0]+hex[0]+hex[1]+hex[1]+hex[2]+hex[2]; if (hex.length !== 6) hex = '000000'; const r = parseInt(hex.substring(0, 2), 16); const g = parseInt(hex.substring(2, 4), 16); const b = parseInt(hex.substring(4, 6), 16); if (isNaN(r) || isNaN(g) || isNaN(b)) return `rgba(0, 0, 0, ${alpha})`; return `rgba(${r}, ${g}, ${b}, ${alpha})`;
    }
    function resetMeasurement() { rulerPoints = []; updateMeasurementPanel(); redraw(true); }
    function updateMeasurementPanel() { if (!rulerMode) return; let coordText = 'Точка 1: -<br>Точка 2: -'; let distText = 'Расстояние: -'; if (rulerPoints.length >= 1) { const p1 = rulerPoints[0]; const p1x = (p1 && isFinite(p1.x)) ? p1.x.toFixed(2) : '-'; const p1y = (p1 && isFinite(p1.y)) ? p1.y.toFixed(2) : '-'; coordText = `Точка 1: X=${p1x}, Y=${p1y}<br>Точка 2: Выберите...`; } if (rulerPoints.length === 2) { const p1 = rulerPoints[0]; const p2 = rulerPoints[1]; if (p1 && p2 && isFinite(p1.x) && isFinite(p1.y) && isFinite(p2.x) && isFinite(p2.y)) { const dist = calculateDistance(p1, p2); coordText = `Точка 1: X=${p1.x.toFixed(2)}, Y=${p1.y.toFixed(2)}<br>Точка 2: X=${p2.x.toFixed(2)}, Y=${p2.y.toFixed(2)}`; distText = `Расстояние: ${isFinite(dist) ? dist.toFixed(2) + ' м' : '-'}`; } else { coordText = `Точка 1: ${isFinite(p1?.x) ? p1.x.toFixed(2) : '-'}, Y=${isFinite(p1?.y) ? p1.y.toFixed(2) : '-'}<br>Точка 2: Ошибка`; distText = 'Расстояние: -'; } } measurementCoordinates.innerHTML = coordText; measurementDistance.textContent = distText; }
    function calculateDistance(p1, p2) { if (!p1 || !p2 || !isFinite(p1.x) || !isFinite(p1.y) || !isFinite(p2.x) || !isFinite(p2.y)) return NaN; const dx = p2.x - p1.x; const dy = p2.y - p1.y; return Math.sqrt(dx * dx + dy * dy); }
    function togglePointsVisibility() { showPoints = !showPoints; redraw(true); showNotification(showPoints ? 'Точки включены' : 'Точки отключены', 'info', showPoints ? 'eye' : 'eye-slash'); updateToggleButtonStates(); saveState(); }

    function activateDrawingMode() { isDrawingMode = true; isDrawingActive = true; currentDrawingPoints = []; showNotification('Режим рисования. Клик: точка. Двойной клик: полигон. ✓: линия/точка.', 'info', 'pencil-alt'); selectedObjectIndex = -1; displayObjectInfo(-1); updateObjectListSelection(); redraw(true); }
    function cancelDrawing() { if (isDrawingActive) { showNotification('Рисование отменено.', 'info', 'times-circle'); } finalizeDrawingState(); }

    function finalizeDrawingState() {
        isDrawingMode = false;
        isDrawingActive = false;
        currentDrawingPoints = [];
        redraw(true);
        if (!rulerMode && !isGeometryEditMode && !isMovingPoint) canvas.style.cursor = 'grab';
        updateToggleButtonStates(); // <--- ДОБАВЛЕНА ЭТА СТРОКА
    }
    
    async function finishDrawingAsPolygon() {
         if (!isDrawingActive) return;
         const validPointsRaw = currentDrawingPoints.filter(p => p && isFinite(p.x) && isFinite(p.y));
         if (validPointsRaw.length < 3) {
             showNotification("Нужно минимум 3 точки для полигона.", "warning", "exclamation-triangle");
             return;
         }
         let finalPolygonPoints = [...validPointsRaw];
         const firstPoint = finalPolygonPoints[0];
         const lastPoint = finalPolygonPoints[finalPolygonPoints.length - 1];
         const PRECISION_THRESHOLD = 0.001;
         const isAlreadyClosed = Math.abs(firstPoint.x - lastPoint.x) < PRECISION_THRESHOLD &&
                                 Math.abs(firstPoint.y - lastPoint.y) < PRECISION_THRESHOLD;
         if (!isAlreadyClosed) {
             finalPolygonPoints.push({ x: firstPoint.x, y: firstPoint.y });
         }
         if (finalPolygonPoints.length < 3) {
            showNotification("Недостаточно уникальных точек для полигона после замыкания.", "warning", "exclamation-triangle");
            return;
         }
         showLoader(false);
         const name = await showNamePrompt("Имя нового полигона:", `Нарисованный ${nextObjectId}`);
         if (name !== null) {
            const newObj = addObjectInternal([finalPolygonPoints], name, 'polygon', true); // Pass as array of contours
            if (newObj) {
                 finalizeBatchAdd([newObj]);
            }
         } else {
            showNotification('Создание полигона отменено.', 'warning', 'times-circle');
         }
         finalizeDrawingState();
    }
    async function finishDrawingAsLineOrPoint() {
        if (!isDrawingActive) return;
        const validPoints = currentDrawingPoints.filter(p => p && isFinite(p.x) && isFinite(p.y));
        if (validPoints.length < 1) { showNotification("Нет точек для создания объекта.", "warning", "exclamation-triangle"); cancelDrawing(); return; }
        const objectType = validPoints.length >= 2 ? 'line' : 'point';
        const typeDesc = objectType === 'line' ? 'линии' : 'точки';
        showLoader(false);
        const name = await showNamePrompt(`Имя новой ${typeDesc}:`, `Нарисованный ${nextObjectId}`);
        if (name !== null) {
            const newObj = addObjectInternal([validPoints], name, objectType, true); // Pass as array of contours
             if (newObj) {
                 finalizeBatchAdd([newObj]);
            }
        } else {
            showNotification(`Создание ${typeDesc} отменено.`, 'warning', 'times-circle');
        }
        finalizeDrawingState();
    }
    async function handleRenameRequest(index) {
        if (index < 0 || index >= userObjects.length || !userObjects[index]) return;
        const currentName = userObjects[index].name || `Объект ${userObjects[index].id}`;
        const newName = await showNamePrompt(`Переименовать объект:`, currentName);
        if (newName !== null) await renameObject(index, newName);
    }

    // --- Supabase specific functions ---
    function isValidCadastralNumberFormat(text) {
        if (!text) return false;
        const pattern = new RegExp(`^\\d{2}:\\d{2}:\\d{6,7}:\\d+$`);
        return pattern.test(text);
    }

    function getElementValueFromNode(element, tagName) {
        if (!element) return '';
        const parts = tagName.split('>');
        let currentElement = element;
        for (let part of parts) {
            currentElement = currentElement.querySelector(part);
            if (!currentElement) return '';
        }
        return currentElement.textContent.trim();
    }

    function extractCoordinatesFromXMLNode(landRecordNode) {
        const allContoursData = []; // Will hold arrays of points, one for each contour
        const contoursLocationNode = landRecordNode.querySelector("contours_location");

        const processSpatialElements = (spatialElementParentNode) => {
            if (!spatialElementParentNode) return;
            // XML structure might have <spatial_element> directly or wrapped in <spatials_elements>
            let spatialElementNodes = spatialElementParentNode.querySelectorAll(":scope > spatial_element");
            if (spatialElementNodes.length === 0 && spatialElementParentNode.querySelector("spatials_elements")) {
                 spatialElementNodes = spatialElementParentNode.querySelectorAll(":scope > spatials_elements > spatial_element");
            }


            spatialElementNodes.forEach(spatialElementNode => {
                const ordinatesNode = spatialElementNode.querySelector("ordinates");
                if (ordinatesNode) {
                    const currentContourPoints = [];
                    const ordinateNodes = ordinatesNode.querySelectorAll("ordinate");
                    ordinateNodes.forEach(ordNode => {
                        const xVal = getElementValueFromNode(ordNode, "x");
                        const yVal = getElementValueFromNode(ordNode, "y");
                        if (xVal && yVal) {
                            const x = parseFloat(xVal); const y = parseFloat(yVal);
                            if (!isNaN(x) && !isNaN(y)) currentContourPoints.push({ x: roundCoord(x), y: roundCoord(y) });
                        }
                    });
                    if (currentContourPoints.length > 0) {
                         // Auto-close this specific contour if it's a polygon part
                        if (currentContourPoints.length >= 3) { // Assuming it's part of a polygon
                            const firstPt = currentContourPoints[0];
                            const lastPt = currentContourPoints[currentContourPoints.length - 1];
                            const PRECISION_THRESHOLD = 0.001;
                             if (!(Math.abs(firstPt.x - lastPt.x) < PRECISION_THRESHOLD && Math.abs(firstPt.y - lastPt.y) < PRECISION_THRESHOLD)) {
                                currentContourPoints.push({ x: firstPt.x, y: firstPt.y });
                            }
                        }
                        allContoursData.push(currentContourPoints);
                    }
                }
            });
        };

        if (contoursLocationNode) {
            const contourNodes = contoursLocationNode.querySelectorAll("contours > contour");
            if (contourNodes.length > 0) { // This is the typical multi-contour or single wrapped contour structure
                contourNodes.forEach(contourNode => {
                    // A <contour> node usually contains one <entity_spatial> which then has <spatials_elements>
                    let elementsParent = contourNode.querySelector("entity_spatial"); // Common parent
                    if (elementsParent) processSpatialElements(elementsParent);
                    else processSpatialElements(contourNode); // Fallback to process <contour> directly if no <entity_spatial>
                });
            } else { // Fallback for simpler structures or if <contours> tag is missing but <contours_location> is present
                processSpatialElements(contoursLocationNode);
            }
        }

        // Fallback if contours_location is not present or empty, try top-level spatial_data
        if (allContoursData.length === 0) {
            const spatialDataNode = landRecordNode.querySelector("spatial_data");
            if (spatialDataNode) {
                processSpatialElements(spatialDataNode);
            }
        }
        return allContoursData; // Returns array of arrays of points
    }


    async function fetchParcelCoordinatesFromSupabase(cadNumber) {
        if (!supabase) {
            showNotification("Клиент Supabase не инициализирован.", "error", "database");
            console.error("Supabase client not initialized for fetchParcelCoordinatesFromSupabase");
            return null;
        }
       console.log(`[Supabase] Запрос для КН: ${cadNumber}`);
        const parts = cadNumber.split(':');
        if (parts.length < 3) {
            const errorMsg = `Неверный формат КН для извлечения квартала: ${cadNumber}`;
            showNotification(errorMsg, "error", "hashtag");
            console.error(`[Supabase] ${errorMsg}`);
            return null;
        }
        const quarterNumber = parts.slice(0, 3).join(':');
        const supabaseQuarterPrefix = quarterNumber.replace(/:/g, '_');
        console.log(`[Supabase] Поиск файлов для квартала: ${supabaseQuarterPrefix}`);

        try {
            const { data: fileList, error: listError } = await supabase.storage
                .from(BUCKET_NAME)
                .list(null, { limit: 200, offset: 0, search: supabaseQuarterPrefix });

            if (listError) {
                console.error(`[Supabase] Ошибка получения списка файлов для ${supabaseQuarterPrefix}:`, listError);
                throw new Error(`Ошибка получения списка файлов: ${listError.message}`);
            }
            if (!fileList || fileList.length === 0) {
                console.warn(`[Supabase] КПТ для квартала ${quarterNumber} не найдены.`);
                throw new Error(`КПТ для квартала ${quarterNumber} не найдены.`);
            }
             console.log(`[Supabase] Найдено файлов для квартала ${quarterNumber}: ${fileList.length}`);

            const matchingFiles = fileList.filter(file => file.name.startsWith(supabaseQuarterPrefix) && file.name.toLowerCase().endsWith('.zip'));
            if (matchingFiles.length === 0) {
                console.warn(`[Supabase] ZIP-архивы КПТ для ${quarterNumber} не найдены среди ${fileList.length} файлов.`);
                throw new Error(`ZIP-архивы КПТ для ${quarterNumber} не найдены.`);
            }

            const dateRegex = /(\d{4}-\d{2}-\d{2})/;
            const latestFile = matchingFiles
                .map(file => ({ name: file.name, date: (file.name.match(dateRegex) ? new Date(file.name.match(dateRegex)[1]) : new Date(0)) }))
                .sort((a, b) => b.date - a.date)[0];

            if (!latestFile) {
                console.error("[Supabase] Не удалось определить последний файл КПТ.");
                throw new Error("Не удалось определить последний файл КПТ.");
            }
            console.log(`[Supabase] Выбран файл КПТ: ${latestFile.name}`);

            const { data: blob, error: downloadError } = await supabase.storage
                .from(BUCKET_NAME)
                .download(latestFile.name);

            if (downloadError) {
                console.error(`[Supabase] Ошибка загрузки ${latestFile.name}:`, downloadError);
                throw new Error(`Ошибка загрузки ${latestFile.name}: ${downloadError.message}`);
            }
            if (!blob) {
                 console.error("[Supabase] Пустой файл КПТ от Supabase.");
                throw new Error("Пустой файл КПТ от Supabase.");
            }
            console.log(`[Supabase] Файл ${latestFile.name} загружен, размер: ${blob.size} байт.`);

            const zip = await JSZip.loadAsync(blob);
            console.log("[Supabase] ZIP архив успешно загружен JSZip.");
            let xmlFileEntry = null;
            for (const fileNameInZip in zip.files) {
                if (fileNameInZip.toLowerCase().endsWith('.xml') && !zip.files[fileNameInZip].dir) {
                    xmlFileEntry = zip.files[fileNameInZip];
                    console.log(`[Supabase] Найден XML файл в архиве: ${fileNameInZip}`);
                    break;
                }
            }
            if (!xmlFileEntry) {
                console.error("[Supabase] XML-файл не найден в архиве КПТ.");
                throw new Error("XML-файл не найден в архиве КПТ.");
            }

            const xmlContent = await xmlFileEntry.async('string');
            console.log(`[Supabase] XML контент извлечен, длина: ${xmlContent.length}`);
            const parser = new DOMParser();
            const xmlDoc = parser.parseFromString(xmlContent, "text/xml");
            const landRecords = xmlDoc.querySelectorAll('land_record');
            console.log(`[Supabase] Найдено ${landRecords.length} land_record в XML.`);
            let foundLandRecord = null;
            landRecords.forEach(record => {
                const cnElem = record.querySelector('object > common_data > cad_number');
                if (cnElem && cnElem.textContent.trim() === cadNumber) {
                    foundLandRecord = record;
                }
            });

            if (!foundLandRecord) {
                console.warn(`[Supabase] Участок ${cadNumber} не найден в XML ${latestFile.name}.`);
                throw new Error(`Участок ${cadNumber} не найден в XML ${latestFile.name}.`);
            }
            console.log(`[Supabase] Участок ${cadNumber} найден в XML.`);
            const extractedContours = extractCoordinatesFromXMLNode(foundLandRecord); // Returns array of contours
            console.log(`[Supabase] Извлечено контуров для ${cadNumber}: ${extractedContours.length}`);
            extractedContours.forEach((c,i) => console.log(`  Контур ${i+1}: ${c.length} точек`));
            return extractedContours; // Return array of contours

        } catch (error) {
            console.error(`[Supabase] Общая ошибка для КН ${cadNumber}:`, error);
            showNotification(`Ошибка для ${cadNumber}: ${error.message}`, "error", "times-circle");
            return null;
        }
    }

    function showLoader(show, text = "Загрузка...") {
        if (show) {
            loaderTextElement.textContent = text;
            loaderContainer.style.display = 'flex';
        } else {
            loaderContainer.style.display = 'none';
        }
    }

    async function handleImportFromCadNumbers(cadNumbers) {
        if (!supabase) {
            showNotification("Supabase не инициализирован. Невозможно загрузить по КН.", "error", "database");
            return;
        }
        closeCoordsDialog();

        let addedObjects = [];
        let errors = 0;
        let currentProcessed = 0;
        const totalCadNumbers = cadNumbers.length;

        showLoader(true, `Подготовка к загрузке ${totalCadNumbers} участков...`);

        for (let i = 0; i < totalCadNumbers; i++) {
            const cn = cadNumbers[i];
            currentProcessed++;
            console.log(`[BatchImport] Начинаем обработку ${cn} (${currentProcessed}/${totalCadNumbers})`);
            showLoader(true, `Загрузка ${currentProcessed}/${totalCadNumbers}: ${cn}`);

            const contoursData = await fetchParcelCoordinatesFromSupabase(cn); // Expects array of contours

            showLoader(false);

            if (contoursData && contoursData.length > 0) {
                console.log(`[BatchImport] Контуры для ${cn} получены. Добавление объекта...`);
                // addObjectInternal ожидает массив контуров
                const newObj = addObjectInternal(contoursData, cn, "polygon", true);
                if (newObj) {
                    addedObjects.push(newObj);
                    console.log(`[BatchImport] Объект ${cn} добавлен.`);
                } else {
                    errors++;
                    console.warn(`[BatchImport] Не удалось создать объект для ${cn} после получения координат.`);
                }
            } else {
                errors++;
                console.warn(`[BatchImport] Не удалось получить координаты или контуры для ${cn}.`);
            }
            if (currentProcessed < totalCadNumbers) {
                 showLoader(true, `Подготовка к загрузке следующего участка...`);
            }
        }

        showLoader(false);

        if (addedObjects.length > 0) {
            finalizeBatchAdd(addedObjects);
            showNotification(`Загружено ${addedObjects.length} участков. ${errors > 0 ? errors + ' с ошибками.' : ''}`, "success", "check-circle");
        } else {
            showNotification(`Не удалось загрузить участки. Ошибок: ${errors}.`, "error", "exclamation-triangle");
        }
    }

    function finalizeBatchAdd(addedObjectsArray) {
        if (addedObjectsArray.length === 0) return;
        updateObjectList();
        selectedObjectIndex = userObjects.indexOf(addedObjectsArray[addedObjectsArray.length - 1]);
        calculateBounds();
        displayObjectInfo(selectedObjectIndex);
        setTimeout(() => {
            if (selectedObjectIndex !== -1) centerOnObject(selectedObjectIndex, true);
            else resetView();
        }, 100);
        saveState();
        redraw(true);
    }


    document.addEventListener('DOMContentLoaded', initializeApp);

</script>
</body>
</html>