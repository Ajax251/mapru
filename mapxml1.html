<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Пакетная обработка XML-планов (Universal)</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <style>
        :root {
            --primary-color: #2563eb;
            --primary-hover: #1d4ed8;
            --bg-color: #f3f4f6;
            --card-bg: #ffffff;
            --text-main: #1f2937;
            --text-secondary: #6b7280;
            --border-color: #e5e7eb;
            --success: #059669;
            --error: #dc2626;
            --warning: #d97706;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-main);
            margin: 0;
            padding: 20px;
            line-height: 1.5;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
        }

        .wrapper {
            width: 100%;
            max-width: 1200px;
            display: grid;
            grid-template-columns: 1fr 350px;
            gap: 20px;
            align-items: start;
        }

        .card {
            background: var(--card-bg);
            border-radius: 12px;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            padding: 24px;
            display: flex;
            flex-direction: column;
        }

        .header-card {
            grid-column: 1 / -1;
            text-align: center;
            padding: 30px;
            margin-bottom: 20px;
        }

        h1 {
            margin: 0 0 10px 0;
            color: var(--text-main);
            font-size: 1.5rem;
        }

        .description {
            color: var(--text-secondary);
            font-size: 0.95rem;
            max-width: 800px;
            margin: 0 auto;
        }

        .upload-section {
            border: 2px dashed var(--border-color);
            border-radius: 8px;
            padding: 30px;
            text-align: center;
            transition: border-color 0.2s;
            margin-bottom: 20px;
        }

        .upload-section:hover {
            border-color: var(--primary-color);
        }

        input[type="file"] {
            display: none;
        }

        .custom-file-upload {
            display: inline-block;
            padding: 12px 24px;
            cursor: pointer;
            background-color: var(--primary-color);
            color: white;
            border-radius: 6px;
            font-weight: 500;
            transition: background-color 0.2s;
        }

        .custom-file-upload:hover {
            background-color: var(--primary-hover);
        }

        .settings-section {
            background-color: #f8fafc;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 15px 20px;
            margin-bottom: 20px;
        }

        .settings-title {
            font-weight: 600;
            font-size: 0.9rem;
            margin-bottom: 10px;
            display: block;
        }

        .checkbox-group {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
        }

        .checkbox-label {
            display: flex;
            align-items: center;
            cursor: pointer;
            font-size: 0.9rem;
            user-select: none;
        }

        .checkbox-label input {
            display: inline-block;
            width: auto;
            margin-right: 8px;
            accent-color: var(--primary-color);
        }

        #log {
            flex-grow: 1;
            height: 400px;
            border: 1px solid var(--border-color);
            background: #f9fafb;
            border-radius: 6px;
            padding: 12px;
            font-family: "Menlo", "Monaco", "Consolas", monospace;
            font-size: 0.85rem;
            overflow-y: auto;
            white-space: pre-wrap;
        }

        .log-item {
            margin-bottom: 4px;
            border-bottom: 1px solid #f3f4f6;
            padding-bottom: 2px;
        }

        .success { color: var(--success); }
        .error { color: var(--error); font-weight: 600; }
        .info { color: var(--primary-color); }
        .warn { color: var(--warning); }

        .error-list {
            list-style: none;
            padding: 0;
            margin: 0;
        }

        .error-item {
            background-color: #fef2f2;
            border: 1px solid #fee2e2;
            color: #991b1b;
            padding: 10px;
            margin-bottom: 8px;
            border-radius: 6px;
            font-size: 0.85rem;
            word-break: break-all;
        }

        .error-header {
            color: #b91c1c;
            font-size: 1.1rem;
            margin-top: 0;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 2px solid #fee2e2;
        }
    </style>
</head>
<body>

<div class="card header-card">
    <h1>Автоматизация формирования архивов XML</h1>
    <div class="description">
        <p>
            Программа анализирует содержимое ZIP-архивов MapPlanTerritory.
            Поддерживаются участки типов: <strong>SpecifyParcel</strong> (уточняемые), <strong>NewParcel</strong> (образуемые), <strong>ExistParcel</strong> (существующие).
            Алгоритм находит первые два участка с <strong>ненулевым</strong> кадастровым кварталом и сравнивает их.
        </p>
    </div>
</div>

<div class="wrapper">
    <div class="card">
        <div class="settings-section">
            <span class="settings-title">Настройки имени файла:</span>
            <div class="checkbox-group">
                <label class="checkbox-label">
                    <input type="checkbox" id="chkCadastralDate">
                    Добавить дату кадастровых работ (ExplanatoryNote)
                </label>
                <label class="checkbox-label">
                    <input type="checkbox" id="chkFileDate">
                    Добавить дату изменения файла XML
                </label>
            </div>
        </div>

        <div class="upload-section">
            <label class="custom-file-upload">
                <input type="file" id="dirInput" webkitdirectory directory multiple>
                Выбрать папку с архивами
            </label>
            <div style="margin-top: 10px; color: var(--text-secondary); font-size: 0.9rem;">
                Выберите директорию с файлами .zip
            </div>
        </div>
        
        <div style="font-weight: 600; margin-bottom: 10px;">Журнал операций:</div>
        <div id="log">Ожидание действий пользователя...</div>
    </div>

    <div class="card">
        <h3 class="error-header">Список ошибок</h3>
        <ul id="errorList" class="error-list">
        </ul>
    </div>
</div>

<script>
    const dirInput = document.getElementById('dirInput');
    const logDiv = document.getElementById('log');
    const errorList = document.getElementById('errorList');
    const chkCadastralDate = document.getElementById('chkCadastralDate');
    const chkFileDate = document.getElementById('chkFileDate');

    function log(message, type = 'normal') {
        const div = document.createElement('div');
        div.className = 'log-item ' + type;
        div.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
        logDiv.appendChild(div);
        logDiv.scrollTop = logDiv.scrollHeight;
    }

    function addErrorToList(fileName, block1, block2) {
        const li = document.createElement('li');
        li.className = 'error-item';
        li.innerHTML = `<strong>${fileName}</strong><br>Несовпадение: ${block1} ≠ ${block2}`;
        errorList.appendChild(li);
    }

    function formatDate(dateObj) {
        const year = dateObj.getFullYear();
        const month = String(dateObj.getMonth() + 1).padStart(2, '0');
        const day = String(dateObj.getDate()).padStart(2, '0');
        return `${year}-${month}-${day}`;
    }

    function isZeroBlock(block) {
        return !block || block === "0" || block.endsWith(":000000");
    }

    function getCadastralBlock(parcelNode) {
        try {
            const node = parcelNode.querySelector("CadastralBlock");
            return node ? node.textContent.trim() : null;
        } catch (e) {
            return null;
        }
    }

    function saveFile(blob, fileName) {
        const link = document.createElement('a');
        link.href = URL.createObjectURL(blob);
        link.download = fileName;
        document.body.appendChild(link);
        link.click();
        setTimeout(() => document.body.removeChild(link), 100);
    }

    dirInput.addEventListener('change', async function(e) {
        logDiv.innerHTML = ''; 
        errorList.innerHTML = '';
        
        const files = Array.from(e.target.files);
        
        if (files.length === 0) {
            log("Директория пуста или файлы не выбраны.", "warn");
            return;
        }

        log(`Инициализация. Найдено объектов: ${files.length}`, "info");

        const fileMap = new Map();
        files.forEach(f => fileMap.set(f.name, f));

        const zipFiles = files.filter(f => f.name.toLowerCase().endsWith('.zip') && !f.name.toLowerCase().endsWith('.zip.sig'));

        if (zipFiles.length === 0) {
            log("Файлы .zip не обнаружены.", "warn");
            return;
        }

        for (const zipFile of zipFiles) {
            try {
                await processZipFile(zipFile, fileMap);
            } catch (err) {
                log(`Ошибка обработки ${zipFile.name}: ${err.message}`, "error");
            }
        }
        
        log("Пакетная обработка завершена.", "info");
    });

    async function processZipFile(file, fileMap) {
        let loadedZip;
        try {
            loadedZip = await JSZip.loadAsync(file);
        } catch (e) {
            log(`Некорректный архив: ${file.name}`, "error");
            return;
        }

        let xmlFileName = null;
        let xmlFileDate = null;

        loadedZip.forEach(function (relativePath, zipEntry) {
            if (relativePath.toLowerCase().endsWith('.xml')) {
                xmlFileName = relativePath;
                xmlFileDate = zipEntry.date;
            }
        });

        if (!xmlFileName) {
            log(`XML не найден в архиве: ${file.name}`, "warn");
            return;
        }

        const xmlContent = await loadedZip.file(xmlFileName).async("string");
        const parser = new DOMParser();
        const xmlDoc = parser.parseFromString(xmlContent, "text/xml");

        // ИЗМЕНЕНИЕ: Ищем сразу SpecifyParcel, NewParcel и ExistParcel
        const parcelNodes = xmlDoc.querySelectorAll("SpecifyParcel, NewParcel, ExistParcel");
        
        let validBlocks = [];

        for (let i = 0; i < parcelNodes.length; i++) {
            const block = getCadastralBlock(parcelNodes[i]);
            
            if (!isZeroBlock(block)) {
                validBlocks.push(block);
            }

            if (validBlocks.length === 2) {
                break;
            }
        }

        if (validBlocks.length < 2) {
            log(`Пропуск ${file.name}: Недостаточно участков с корректным кварталом (Найдено: ${validBlocks.length}).`, "warn");
            return;
        }

        const block1 = validBlocks[0];
        const block2 = validBlocks[1];

        if (block1 === block2) {
            let newFileNameBase = block1.replace(/:/g, '_');

            if (chkCadastralDate.checked) {
                const noteNode = xmlDoc.querySelector("ExplanatoryNote");
                const dateCadastral = noteNode ? noteNode.getAttribute("DateCadastral") : null;
                if (dateCadastral) {
                    newFileNameBase += ` ${dateCadastral}`;
                }
            }

            if (chkFileDate.checked && xmlFileDate) {
                newFileNameBase += ` от ${formatDate(xmlFileDate)}`;
            }

            const newZipName = newFileNameBase + ".zip";

            const outZip = new JSZip();
            outZip.file(file.name, file);

            const sigName = file.name + ".sig";
            if (fileMap.has(sigName)) {
                outZip.file(sigName, fileMap.get(sigName));
            }

            log(`Обработан: ${file.name} -> ${newZipName}`, "success");

            const content = await outZip.generateAsync({
                type: "blob", 
                compression: "STORE" 
            });
            
            saveFile(content, newZipName);

        } else {
            log(`Ошибка валидации ${file.name}: ${block1} ≠ ${block2}`, "error");
            addErrorToList(file.name, block1, block2);
        }
    }
</script>

</body>
</html>