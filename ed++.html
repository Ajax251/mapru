<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ГеоРедактор</title>
    <link rel="stylesheet" href="webfonts/all.min.css">
    <link rel="icon" href="img/ed.png" type="image/png">
    <script src="webfonts/jszip.min.js"></script>
    <style>
        * {
            box-sizing: border-box;
            transition: none !important;
            animation: none !important;
        }

        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            margin: 0;
            background-color: #f0f0f0;
            overflow: hidden;
            touch-action: manipulation;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
        }

        #objectAnalysisContainer {
            position: fixed;
            left: 20%;
            top: 0;
            width: 80%;
            height: 100vh;
            height: 100dvh;
            background: white;
            z-index: 999;
        }

        #objectAnalysisCanvas {
            width: 100%;
            height: 100%;
            cursor: grab;
            touch-action: none;
        }

        #objectAnalysisCanvas.drawing-mode { cursor: crosshair; }
        #objectAnalysisCanvas.editing-point-mode { cursor: move; }
        #objectAnalysisCanvas.geometry-edit-mode-add { cursor: cell; }
        #objectAnalysisCanvas.geometry-edit-mode-hover-point { cursor: pointer; }

        #infoPanel {
            position: fixed;
            top: 0;
            left: 0;
            width: 20%;
            height: 100vh;
            height: 100dvh;
            background-color: #f8f8f8;
            border-right: 1px solid #ddd;
            overflow-y: auto;
            overflow-x: hidden;
            z-index: 1000;
            padding: 20px;
            user-select: none;
            box-shadow: 2px 0 10px rgba(0,0,0,0.1);
            -webkit-overflow-scrolling: touch;
        }

        .action-button {
            position: absolute;
            right: 20px;
            background-color: #4a69bd;
            color: white;
            border: none;
            padding: 10px;
            border-radius: 50%;
            cursor: pointer;
            width: 50px;
            height: 50px;
            font-size: 18px;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
            -webkit-tap-highlight-color: transparent;
        }

        .action-button:hover { transform: scale(1.1); box-shadow: 0 6px 12px rgba(0,0,0,0.3); }
        .action-button:active { transform: scale(0.95); }
        .action-button.active { box-shadow: inset 0 2px 4px rgba(0,0,0,0.3); transform: scale(0.98); }

        #addObjectBtn { bottom: 20px; background-color: #4a69bd; }
        #addObjectBtn:hover { background-color: #354f9e; }
        #drawObjectBtn { bottom: 80px; background-color: #f39c12; }
        #drawObjectBtn:hover { background-color: #e67e22; }
        #drawObjectBtn.active { background-color: #d35400; }
        #finishDrawingBtn { bottom: 80px; background-color: #2ecc71; display: none; }
        #finishDrawingBtn:hover { background-color: #27ae60; }
        #togglePointsBtn { bottom: 140px; background-color: #e74c3c; }
        #togglePointsBtn:hover { background-color: #c0392b; }
        #rulerBtn { bottom: 200px; background-color: #3498db; }
        #rulerBtn:hover { background-color: #2980b9; }
        #rulerBtn.active { background-color: #27ae60; }
        #toggleGeometryEditBtn { bottom: 260px; background-color: #9b59b6; }
        #toggleGeometryEditBtn:hover { background-color: #8e44ad; }
        #toggleGeometryEditBtn.active { background-color: #e74c3c; }
        #toggleGeometryEditBtn.active:hover { background-color: #c0392b; }
        #undoGeometryChangeBtn { bottom: 320px; background-color: #e67e22; display: none; }
        #undoGeometryChangeBtn:hover { background-color: #d35400; }
        #undoGeometryChangeBtn:disabled { background-color: #bdc3c7; cursor: not-allowed; transform: scale(1); }
        #cutObjectBtn { bottom: 380px; background-color: #16a085; }
        #cutObjectBtn:hover { background-color: #138d75; }
        #cutObjectBtn.active { background-color: #e74c3c; box-shadow: inset 0 2px 4px rgba(0,0,0,0.5); }
        #unionObjectBtn { bottom: 440px; background-color: #16a085; display: none; }
        #unionObjectBtn:hover { background-color: #1abc9c; }
        #unionObjectBtn.active { background-color: #e74c3c; box-shadow: inset 0 2px 4px rgba(0,0,0,0.5); }
        #intersectPointsBtn { bottom: 500px; background-color: #8e44ad; display: none; }
        #intersectPointsBtn:hover { background-color: #732d91; }
        #intersectPointsBtn.active { background-color: #e74c3c; box-shadow: inset 0 2px 4px rgba(0,0,0,0.5); }

        #measurementPanel {
            position: absolute;
            bottom: 80px;
            left: 20px;
            background-color: rgba(255,255,255,0.9);
            padding: 10px 15px;
            border-radius: 5px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
            font-size: 14px;
            max-width: 300px;
            display: none;
            z-index: 1100;
        }

        #measurementPanel.active { display: block; }
        .measurement-title { font-weight: bold; margin-bottom: 8px; color: #2c3e50; display: flex; align-items: center; }
        .measurement-title i { margin-right: 5px; color: #3498db; }
        .measurement-coordinates { margin-bottom: 8px; padding-left: 10px; border-left: 3px solid #3498db; font-family: monospace; }
        .measurement-distance { font-weight: bold; color: #e74c3c; font-size: 16px; text-align: center; margin-top: 8px; padding: 5px; background-color: rgba(231,76,60,0.1); border-radius: 3px; }
        #resetMeasurementBtn { background-color: #3498db; color: white; border: none; padding: 5px 10px; border-radius: 3px; margin-top: 8px; cursor: pointer; width: 100%; }
        #resetMeasurementBtn:hover { background-color: #2980b9; }

        #gridInfoPanel, #cursorInfoPanel, #viewInfoPanel {
            position: absolute;
            bottom: 20px;
            background-color: rgba(255,255,255,0.85);
            padding: 8px 12px;
            border-radius: 5px;
            font-size: 12px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            z-index: 1000;
            display: flex;
            align-items: center;
            pointer-events: none;
            opacity: 0.8;
            color: royalblue;
        }

        #gridInfoPanel { left: calc(20% + 20px); }
        #gridInfoPanel:hover, #cursorInfoPanel:hover, #viewInfoPanel:hover { opacity: 1; }
        #gridInfoPanel i, #cursorInfoPanel i { margin-right: 5px; color: royalblue; }
        #cursorInfoPanel { left: calc(20% + 150px); }
        #viewInfoPanel { left: calc(20% + 420px); color: #27ae60; white-space: nowrap; }
        #viewInfoPanel i { margin-right: 5px; color: #27ae60; }

        #selectedObjectInfo h3 {
            text-align: center;
            font-size: 1.2em;
            margin-bottom: 10px;
            color: #336699;
            border-bottom: 2px solid #336699;
            padding-bottom: 5px;
            font-weight: bold;
            cursor: pointer;
        }

        #selectedObjectInfo h3:hover { color: #4a69bd; }
        #selectedObjectInfo .info-item { display: flex; justify-content: space-between; padding: 6px 0; border-bottom: 1px solid #eee; }
        #selectedObjectInfo .info-item span:first-child { font-weight: bold; color: #555; margin-right: 10px; }
        #selectedObjectInfo .info-item span:last-child { color: #333; text-align: right; }
        #selectedObjectInfo .info-item span.copyable { cursor: pointer; }
        #selectedObjectInfo .info-item span.copyable:hover { color: #4a69bd; }
        .flash { background-color: #90EE90; }

        #coordsDialog {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 400px;
            background-color: white;
            border-radius: 10px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
            z-index: 2000;
            padding: 20px;
            opacity: 1;
            max-height: 90vh;
            overflow-y: auto;
        }

        #coordsDialog.show { display: block; opacity: 1; }
        #coordsDialog h3 { margin: 0 0 15px; font-size: 18px; color: #333; }

        #coordsInput {
            width: 100%;
            height: 150px;
            padding: 8px;
            border: 1px solid #ccc;
            border-radius: 4px;
            box-sizing: border-box;
            resize: vertical;
            font-size: 14px;
            margin-bottom: 15px;
        }

        #coordsInput:focus { border-color: #4a69bd; box-shadow: 0 0 5px rgba(74,105,189,0.5); outline: none; }

        .dialog-buttons { display: flex; justify-content: space-between; gap: 10px; flex-wrap: wrap; }

        #importCoordsBtn, #importFromFileBtn, #closeDialogBtn, #findCoordsBtn {
            background-color: #4a69bd;
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 5px;
            cursor: pointer;
            flex: 1;
            font-size: 14px;
            position: relative;
            overflow: hidden;
            min-width: 100px;
        }

        #importCoordsBtn:hover, #importFromFileBtn:hover, #findCoordsBtn:hover { background-color: #354f9e; transform: translateY(-2px); }
        #importCoordsBtn:active, #importFromFileBtn:active, #closeDialogBtn:active, #findCoordsBtn:active { transform: translateY(1px); }
        #closeDialogBtn { background-color: #dc3545; }
        #closeDialogBtn:hover { background-color: #c82333; }
        #findCoordsBtn { background-color: #8e44ad; }

        #dialogOverlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.5);
            z-index: 1999;
        }

        #dialogOverlay.show { display: block; opacity: 1; }

        #tooltip {
            position: absolute;
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 12px;
            pointer-events: none;
            z-index: 1001;
            display: none;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
            font-weight: bold;
            background-color: rgba(0,0,0,0.7);
            color: white;
        }

        .notification {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 15px 20px;
            border-radius: 5px;
            color: white;
            font-size: 14px;
            z-index: 9999;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
            display: none;
            max-width: 300px;
            border: 1px solid rgba(0,0,0,0.1);
            text-shadow: 0 0 2px rgba(0,0,0,0.5);
        }

        .notification.show { display: block; }
        .notification.info { background-color: #3498db; }
        .notification.success { background-color: #4CAF50; }
        .notification.error { background-color: #F44336; }
        .notification.warning { background-color: #FF9800; }
        .notification i { margin-right: 10px; }

        #loaderContainer {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(173,216,230,0.9);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 10000;
            flex-direction: column;
        }

        .spinner-container { width: 80px; height: 80px; position: relative; }

        .spinner-ring {
            position: absolute;
            width: 100%;
            height: 100%;
            border-radius: 50%;
            border: 6px solid transparent;
            border-top-color: #3498db;
            animation: spin 1.2s cubic-bezier(0.5,0,0.5,1) infinite !important;
            box-sizing: border-box;
        }

        .spinner-ring:before, .spinner-ring:after {
            content: '';
            position: absolute;
            border-radius: 50%;
            border: 6px solid transparent;
            box-sizing: border-box;
        }

        .spinner-ring:before {
            top: -6px; left: -6px; right: -6px; bottom: -6px;
            border-top-color: #2980b9;
            animation: spin 2s cubic-bezier(0.5,0,0.5,1) infinite !important;
        }

        .spinner-ring:after {
            top: 6px; left: 6px; right: 6px; bottom: 6px;
            border-top-color: #6ab7e2;
            animation: spin 0.8s cubic-bezier(0.5,0,0.5,1) infinite !important;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .loading-text {
            color: #2c3e50;
            font-size: 18px;
            font-weight: bold;
            margin-top: 30px;
            letter-spacing: 1px;
            text-align: center;
            line-height: 1.5;
            min-height: 50px;
        }

        .coordinates-table { width: 100%; border-collapse: collapse; margin-top: 15px; }
        .coordinates-table th, .coordinates-table td { border: 1px solid #ddd; padding: 8px; text-align: center; }
        .coordinates-table th { background-color: #f2f2f2; }
        .coordinate-row { cursor: pointer; }
        .coordinate-row:hover { background-color: #f0f8ff; }
        .coordinate-row.selected-coordinate { background-color: #ffebee !important; border-left: 3px solid #f44336; font-weight: bold; }

        .panel-button {
            margin-top: 10px;
            width: 100%;
            padding: 10px;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            -webkit-tap-highlight-color: transparent;
        }

        .panel-button:hover { transform: translateY(-2px); box-shadow: 0 4px 8px rgba(0,0,0,0.3); }
        .panel-button:active { transform: translateY(1px); }
        .panel-button i { margin-right: 8px; }

        #showCoordinatesBtn { background-color: #4a69bd; margin-bottom: 10px; }
        #showCoordinatesBtn:hover { background-color: #354f9e; }
        #copyAllCoordinatesBtn { background-color: #1abc9c; margin-bottom: 10px; }
        #copyAllCoordinatesBtn:hover { background-color: #16a085; }
        #centerObjectBtn { background-color: #2ecc71; margin-bottom: 10px; }
        #centerObjectBtn:hover { background-color: #27ae60; }
        #renameObjectBtn { background-color: #f39c12; margin-bottom: 10px; }
        #renameObjectBtn:hover { background-color: #e67e22; }
        #deleteObjectBtn { background-color: #e74c3c; }
        #deleteObjectBtn:hover { background-color: #c0392b; }
        #openSchemaBtn { background-color: #9b59b6; margin-bottom: 10px; }
        #openSchemaBtn:hover { background-color: #8e44ad; }

        .panel-section { padding-bottom: 15px; margin-bottom: 15px; border-bottom: 1px solid #ddd; }
        .panel-section:last-child { border-bottom: none; margin-bottom: 0; }

        .section-title {
            background-color: #4a69bd;
            color: white;
            padding: 8px 12px;
            border-radius: 4px;
            margin-top: 15px;
            margin-bottom: 10px;
            font-weight: bold;
            position: relative;
            overflow: hidden;
            font-size: 0.9em;
        }

        .section-title i { margin-right: 8px; }
        .section-title-action { position: absolute; right: 12px; top: 50%; transform: translateY(-50%); cursor: pointer; opacity: 0.8; }
        .section-title-action:hover { color: #ffdddd; opacity: 1; }

        #intersectionList { list-style: none; padding: 0; margin-top: 10px; }

        #intersectionList li {
            padding: 8px 12px;
            border: 1px solid #ddd;
            margin-bottom: 5px;
            border-radius: 4px;
            background-color: #fff;
            cursor: pointer;
            position: relative;
            overflow: hidden;
            font-size: 0.9em;
        }

        #intersectionList li:hover { background-color: #f0f0f0; transform: translateX(5px); box-shadow: 0 2px 5px rgba(0,0,0,0.1); }
        #intersectionList li.full-containment { border-left: 3px solid #27ae60; background-color: #e8f8f5; }
        #intersectionList li.contained-by { border-left: 3px solid #af7ac5; background-color: #f4ecf7; }
        #intersectionList li.partial-overlap { border-left: 3px solid #f39c12; background-color: #fef9e7; }

        #objectListContainer { max-height: 250px; overflow-y: auto; -webkit-overflow-scrolling: touch; }

        #objectList li {
            padding: 5px 8px;
            margin-bottom: 3px;
            border-radius: 3px;
            cursor: pointer;
            display: flex;
            align-items: center;
            border: 1px solid transparent;
            font-size: 0.9em;
        }

        #objectList li:hover { background-color: #f0f0f0; }
        #objectList li.selected { background-color: #e0f2f7; border-color: #b3e5fc; font-weight: bold; }
        #objectList li .color-indicator { display: inline-block; width: 12px; height: 12px; border-radius: 3px; margin-right: 8px; flex-shrink: 0; border: 1px solid #ccc; }
        #objectList li .name-span { flex-grow: 1; overflow: hidden; white-space: nowrap; text-overflow: ellipsis; }

        #namePromptOverlay {
            display: none;
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background-color: rgba(0,0,0,0.4);
            z-index: 2999;
        }

        #namePromptOverlay.show { display: block; opacity: 1; }

        #namePromptDialog {
            display: none;
            position: fixed;
            top: 40%; left: 50%;
            transform: translate(-50%, -50%);
            width: 350px;
            background-color: white;
            border-radius: 10px;
            box-shadow: 0 5px 20px rgba(0,0,0,0.25);
            z-index: 3000;
            padding: 25px;
            box-sizing: border-box;
        }

        #namePromptDialog.show { display: block; opacity: 1; }
        #namePromptDialog h3 { margin: 0 0 20px; font-size: 1.2em; color: #333; text-align: center; font-weight: 600; }

        #namePromptInput {
            width: 100%;
            padding: 12px 10px;
            border: 1px solid #ccc;
            border-radius: 5px;
            box-sizing: border-box;
            font-size: 1em;
            margin-bottom: 20px;
        }

        #namePromptInput:focus { border-color: #4a69bd; outline: none; }

        #namePromptSaveBtn, #namePromptCancelBtn {
            background-color: #4a69bd;
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 5px;
            cursor: pointer;
            flex-basis: 48%;
            font-size: 0.95em;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 5px;
        }

        #namePromptSaveBtn:hover { background-color: #354f9e; }
        #namePromptCancelBtn { background-color: #6c757d; }
        #namePromptCancelBtn:hover { background-color: #5a6268; }
        #toggleLabelsDialogBtn.active { background-color: #138496 !important; border: 2px solid #0c5460; }

        #objectAnalysisContainer.editing-mode { box-shadow: inset 0 0 0 6px rgba(231,76,60,0.85); }

        #editModeBadge {
            display: none;
            position: absolute;
            top: 15px; left: 50%;
            transform: translateX(-50%);
            background-color: #e74c3c;
            color: white;
            padding: 8px 25px;
            border-radius: 30px;
            font-weight: bold;
            font-size: 14px;
            text-transform: uppercase;
            letter-spacing: 1px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
            z-index: 1000;
            pointer-events: auto;
            cursor: pointer;
        }

        #editModeBadge:hover { background-color: #c0392b; transform: translateX(-50%) scale(1.05); }
        #editModeBadge:active { transform: translateX(-50%) scale(0.95); }
        #editModeBadge i { margin-right: 8px; }

        #globalEditModeBorder {
            display: none;
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            box-shadow: inset 0 0 0 4px #e74c3c;
            z-index: 100000;
            pointer-events: none;
        }

        #globalEditModeBorder.active { display: block; }

        .visibility-toggle {
            margin-left: 10px;
            cursor: pointer;
            color: #777;
            padding: 5px;
            display: flex;
            align-items: center;
        }

        .visibility-toggle:hover { color: #333; transform: scale(1.1); }
        .visibility-toggle i { pointer-events: none; }

        #customConfirmOverlay {
            display: none;
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background-color: rgba(0,0,0,0.5);
            z-index: 4000;
        }

        #customConfirmOverlay.show { display: block; opacity: 1; }

        #customConfirmDialog {
            display: none;
            position: fixed;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            width: 400px;
            background-color: white;
            border-radius: 12px;
            box-shadow: 0 10px 25px rgba(0,0,0,0.2);
            z-index: 4001;
            padding: 30px;
            box-sizing: border-box;
            text-align: center;
        }

        #customConfirmDialog.show { display: block; opacity: 1; }
        #customConfirmTitle { margin: 0 0 15px; font-size: 1.3em; color: #222; font-weight: bold; }
        #customConfirmMessage { color: #555; margin-bottom: 25px; font-size: 1em; line-height: 1.5; }

        #customConfirmYesBtn {
            background-color: #2ecc71;
            color: white;
            border: none;
            padding: 10px 30px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 1em;
            min-width: 100px;
            font-weight: bold;
        }

        #customConfirmYesBtn:hover { background-color: #27ae60; }

        #customConfirmNoBtn {
            background-color: #e74c3c;
            color: white;
            border: none;
            padding: 10px 30px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 1em;
            min-width: 100px;
            font-weight: bold;
        }

        #customConfirmNoBtn:hover { background-color: #c0392b; }

        #quarterLoadOptionsDialog, #intersectionOptionsDialog {
            display: none;
            position: fixed;
            top: 40%; left: 50%;
            transform: translate(-50%, -50%);
            width: 400px;
            background-color: white;
            border-radius: 10px;
            box-shadow: 0 5px 20px rgba(0,0,0,0.25);
            z-index: 3000;
            padding: 25px;
            box-sizing: border-box;
            text-align: center;
        }

        #quarterLoadOptionsTitle, #intersectionOptionsDialog h3 { margin: 0 0 20px; font-size: 1.2em; color: #333; font-weight: 600; }
        #quarterLoadOptionsButtons { display: flex; flex-direction: column; gap: 10px; }

        #mobileMenuToggle {
            display: none;
            position: fixed;
            top: 10px; left: 10px;
            width: 44px; height: 44px;
            background-color: #4a69bd;
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 20px;
            z-index: 1100;
            cursor: pointer;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
            align-items: center;
            justify-content: center;
            -webkit-tap-highlight-color: transparent;
        }

        #mobileMenuToggle.active { background-color: #e74c3c; }

        @media (max-width: 1024px) {
            #infoPanel { width: 30%; }
            #objectAnalysisContainer { left: 30%; width: 70%; }
            #gridInfoPanel { left: calc(30% + 10px); }
            #cursorInfoPanel { left: calc(30% + 130px); }
            #viewInfoPanel { left: calc(30% + 350px); }
            .action-button { width: 44px; height: 44px; font-size: 16px; right: 15px; }
        }

        @media (max-width: 768px) {
            #mobileMenuToggle { display: flex; }
            #infoPanel { width: 85%; max-width: 320px; left: -100%; z-index: 1050; padding: 15px; padding-top: 60px; }
            #infoPanel.open { left: 0; }
            #objectAnalysisContainer { left: 0; width: 100%; }
            .action-button { width: 44px; height: 44px; font-size: 16px; right: 12px; }
            #addObjectBtn { bottom: 20px; }
            #drawObjectBtn, #finishDrawingBtn { bottom: 74px; }
            #togglePointsBtn { bottom: 128px; }
            #rulerBtn { bottom: 182px; }
            #toggleGeometryEditBtn { bottom: 236px; }
            #undoGeometryChangeBtn { bottom: 290px; }
            #cutObjectBtn { bottom: 344px; }
            #unionObjectBtn { bottom: 398px; }
            #intersectPointsBtn { bottom: 452px; }
            #gridInfoPanel, #cursorInfoPanel, #viewInfoPanel { bottom: 10px; font-size: 10px; padding: 5px 8px; }
            #gridInfoPanel { left: 10px; }
            #cursorInfoPanel { left: 120px; }
            #viewInfoPanel { display: none; }
            #measurementPanel { left: 10px; right: 70px; bottom: 70px; max-width: none; font-size: 12px; }
            #coordsDialog { width: 95%; max-width: 400px; padding: 15px; }
            #coordsDialog h3 { font-size: 16px; margin-bottom: 10px; }
            #coordsInput { height: 100px; font-size: 13px; }
            .dialog-buttons { gap: 8px; }
            #importCoordsBtn, #importFromFileBtn, #closeDialogBtn, #findCoordsBtn { flex: 1 1 45%; padding: 10px 8px; font-size: 12px; }
            #coordsDialog > div:first-of-type { flex-wrap: wrap; }
            #coordsDialog > div:first-of-type .panel-button { flex: 1 1 100%; font-size: 12px; padding: 8px; }
            #namePromptDialog, #customConfirmDialog { width: 90%; max-width: 350px; padding: 20px; }
            #quarterLoadOptionsDialog, #intersectionOptionsDialog { width: 90%; max-width: 380px; padding: 20px; }
            #editModeBadge { font-size: 11px; padding: 6px 15px; top: 10px; }
            .notification { top: 10px; right: 10px; left: 10px; max-width: none; font-size: 13px; padding: 12px 15px; }
            .panel-button { padding: 10px; font-size: 13px; }
            .section-title { font-size: 0.85em; padding: 6px 10px; }
            #objectListContainer { max-height: 200px; }
            .coordinates-table th, .coordinates-table td { padding: 6px; font-size: 12px; }
            #tooltip { display: none !important; }
        }

        @media (max-width: 480px) {
            #infoPanel { width: 100%; max-width: none; }
            .action-button { width: 40px; height: 40px; font-size: 14px; right: 8px; }
            #addObjectBtn { bottom: 15px; }
            #drawObjectBtn, #finishDrawingBtn { bottom: 65px; }
            #togglePointsBtn { bottom: 115px; }
            #rulerBtn { bottom: 165px; }
            #toggleGeometryEditBtn { bottom: 215px; }
            #undoGeometryChangeBtn { bottom: 265px; }
            #cutObjectBtn { bottom: 315px; }
            #unionObjectBtn { bottom: 365px; }
            #intersectPointsBtn { bottom: 415px; }
            #gridInfoPanel { display: none; }
            #cursorInfoPanel { left: 10px; font-size: 11px; }
            #coordsDialog { padding: 12px; }
            #coordsInput { height: 80px; }
            #importCoordsBtn, #importFromFileBtn, #closeDialogBtn, #findCoordsBtn { flex: 1 1 100%; }
            #namePromptDialog h3, #customConfirmTitle { font-size: 1.1em; }
            #customConfirmMessage { font-size: 0.9em; }
            #customConfirmYesBtn, #customConfirmNoBtn { padding: 8px 20px; font-size: 0.9em; }
            .loading-text { font-size: 14px; padding: 0 20px; }
            .spinner-container { width: 60px; height: 60px; }
        }

        @media (max-height: 600px) and (max-width: 768px) {
            .action-button { width: 36px; height: 36px; font-size: 13px; }
            #addObjectBtn { bottom: 10px; }
            #drawObjectBtn, #finishDrawingBtn { bottom: 52px; }
            #togglePointsBtn { bottom: 94px; }
            #rulerBtn { bottom: 136px; }
            #toggleGeometryEditBtn { bottom: 178px; }
            #undoGeometryChangeBtn { bottom: 220px; }
            #cutObjectBtn { bottom: 262px; }
            #unionObjectBtn { bottom: 304px; }
            #intersectPointsBtn { bottom: 346px; }
        }

        @media (hover: none) and (pointer: coarse) {
            .action-button:hover { transform: none; box-shadow: 0 4px 8px rgba(0,0,0,0.2); }
            .panel-button:hover { transform: none; }
            #objectList li:hover { background-color: transparent; }
            #intersectionList li:hover { transform: none; box-shadow: none; }
            .action-button:active { transform: scale(0.9); }
            .panel-button:active { transform: scale(0.98); }
        }
    </style>
</head>
<body>

<button id="mobileMenuToggle" aria-label="Меню">
    <i class="fas fa-bars"></i>
</button>

<div id="infoPanel">
    <div class="panel-section">
        <h4>Информация об объекте</h4>
        <div id="selectedObjectInfo">
            <p style="color: #777; font-style: italic; text-align: center;">Выберите объект на схеме (двойной клик) или добавьте новый.</p>
        </div>
        <div id="coordinatesTableContainer"></div>
    </div>
    <div class="panel-section">
        <div class="section-title" style="display: none;" id="intersectionsTitle">
            <i class="fas fa-vector-square"></i> Пересечения и Наложения
        </div>
        <div id="intersectionsContainer">
            <ul id="intersectionList"></ul>
        </div>
    </div>
    <div class="panel-section">
        <div class="section-title">
            <i class="fas fa-list"></i> Список объектов (<span id="objectCount">0</span>)
            <span id="hideAllObjectsBtn" class="section-title-action" title="Скрыть все объекты" style="right: 100px;">
                <i class="fas fa-eye-slash"></i>
            </span>
            <span id="showAllObjectsBtn" class="section-title-action" title="Показать все" style="right: 40px;">
                <i class="fas fa-expand"></i>
            </span>
            <span id="showAdjacentPointsBtn" class="section-title-action" title="Показать точки смежных (1м)" style="right: 70px;">
                <i class="fas fa-dot-circle"></i>
            </span>
            <span id="deleteAllObjectsBtn" class="section-title-action" title="Удалить все объекты">
                <i class="fas fa-eraser"></i>
            </span>
        </div>
        <div id="objectListContainer">
            <ul id="objectList"></ul>
        </div>
    </div>
</div>

<div id="objectAnalysisContainer">
    <canvas id="objectAnalysisCanvas"></canvas>
    <button id="addObjectBtn" class="action-button" title="Добавить объект из координат"><i class="fas fa-plus"></i></button>
    <button id="drawObjectBtn" class="action-button" title="Нарисовать объект"><i class="fas fa-pencil-alt"></i></button>
    <button id="finishDrawingBtn" class="action-button" title="Завершить создание объекта"><i class="fas fa-check"></i></button>
    <button id="togglePointsBtn" class="action-button" title="Показать/скрыть точки"><i class="fas fa-map-marker-alt"></i></button>
    <button id="rulerBtn" class="action-button" title="Измерить расстояние"><i class="fas fa-ruler"></i></button>
    <button id="toggleGeometryEditBtn" class="action-button" title="Редактировать геометрию"><i class="fas fa-edit"></i></button>
    <button id="undoGeometryChangeBtn" class="action-button" title="Отменить изменение геометрии"><i class="fas fa-undo"></i></button>
    <button id="cutObjectBtn" class="action-button" title="Рассечение объекта" style="display: none;"><i class="fas fa-cut"></i></button>
    <button id="unionObjectBtn" class="action-button" title="Объединение объектов" style="display: none;"><i class="fas fa-object-group"></i></button>
    <button id="intersectPointsBtn" class="action-button" title="Создать точки пересечения" style="display: none;"><i class="fas fa-project-diagram"></i></button>
    <div id="editModeBadge" title="Нажмите, чтобы выйти из режима редактирования"><i class="fas fa-pencil-alt"></i> Режим редактирования</div>
    <div id="measurementPanel">
        <div class="measurement-title"><i class="fas fa-ruler"></i> Измерение</div>
        <div class="measurement-coordinates" id="measurementCoordinates">...</div>
        <div class="measurement-distance" id="measurementDistance">Расстояние: -</div>
        <button id="resetMeasurementBtn">Сбросить</button>
    </div>
    <div id="gridInfoPanel"><i class="fas fa-th"></i><span id="gridStepText"></span></div>
    <div id="cursorInfoPanel"><i class="fas fa-mouse-pointer"></i><span id="cursorCoordinates">X: 0.00, Y: 0.00</span></div>
    <div id="viewInfoPanel"><i class="fas fa-ruler-horizontal"></i><span id="viewInfoText">Обзор: -</span></div>
</div>

<div id="tooltip"></div>
<div id="dialogOverlay"></div>

<div id="coordsDialog">
    <h3>Добавить объект</h3>
    <div style="display: flex; gap: 10px; margin-bottom: 15px; padding-bottom: 15px; border-bottom: 1px solid #eee; flex-wrap: wrap;">
        <button id="saveProjectBtn" class="panel-button" style="margin: 0; background-color: #27ae60; flex: 1 1 45%;"><i class="fas fa-file-export"></i> Сохранить проект</button>
        <button id="openProjectBtn" class="panel-button" style="margin: 0; background-color: #e67e22; flex: 1 1 45%;"><i class="fas fa-folder-open"></i> Открыть проект</button>
        <button id="toggleLabelsDialogBtn" class="panel-button" style="margin: 0; background-color: #17a2b8; flex: 1 1 100%;"><i class="fas fa-tag"></i> Подписи координат</button>
        <input type="file" id="projectFileInput" accept=".geoed" style="display: none;">
    </div>
    <div style="margin-bottom: 15px; text-align: left;">
        <label for="importModeSelect" style="text-align: left; margin-bottom: 5px; font-size: 14px;">Режим загрузки для кадастровых номеров:</label>
        <select id="importModeSelect" style="width: 100%; padding: 8px; border-radius: 4px; border: 1px solid #ccc;"></select>
    </div>
    <div style="margin-bottom: 10px; display: flex; align-items: center; gap: 10px; background: #f9f9f9; padding: 8px; border-radius: 4px; flex-wrap: wrap;">
        <input type="checkbox" id="useFixedColor" style="cursor: pointer;">
        <label for="useFixedColor" style="cursor: pointer; user-select: none;">Использовать фиксированный цвет:</label>
        <input type="color" id="importColorInput" value="#FF0000" style="cursor: pointer; height: 25px; border: none; background: none;">
    </div>
    <textarea id="coordsInput" placeholder="Варианты ввода:
1. Координаты (X Y или X tab Y)
2. Кадастровые номера или номера кварталов
3. Кадастровый номер (1-я строка) и координаты"></textarea>
    <div class="dialog-buttons">
        <button id="importCoordsBtn"><i class="fas fa-cloud-download-alt"></i> Загрузить</button>
        <button id="importFromFileBtn" title="Импорт из TXT/CSV"><i class="fas fa-file-upload"></i> Файл</button>
        <button id="findCoordsBtn" title="Найти координаты"><i class="fas fa-crosshairs"></i> Найти</button>
        <button id="closeDialogBtn"><i class="fas fa-times"></i> Закрыть</button>
    </div>
</div>

<div id="loaderContainer">
    <div class="spinner-container"><div class="spinner-ring"></div></div>
    <div class="loading-text">Загрузка...</div>
    <button id="cancelLoadBtn" style="margin-top: 20px; padding: 8px 20px; background: #e74c3c; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 14px; display: none;"><i class="fas fa-times"></i> Отменить</button>
</div>

<div id="namePromptOverlay"></div>
<div id="namePromptDialog">
    <h3 id="namePromptTitle">Имя объекта</h3>
    <input type="text" id="namePromptInput" placeholder="Введите имя...">
    <div class="dialog-buttons">
        <button id="namePromptSaveBtn"><i class="fas fa-check"></i> Сохранить</button>
        <button id="namePromptCancelBtn"><i class="fas fa-times"></i> Отмена</button>
    </div>
</div>

<div id="quarterLoadOptionsDialog">
    <h3 id="quarterLoadOptionsTitle">Режим загрузки квартала</h3>
    <div id="quarterLoadOptionsButtons">
        <button data-load-type="all" class="panel-button" style="background-color: #3498db; margin: 0;"><i class="fas fa-layer-group"></i> Загрузить все объекты</button>
        <button data-load-type="zu" class="panel-button" style="background-color: #2ecc71; margin: 0;"><i class="fas fa-map-marked-alt"></i> Только Земельные Участки</button>
        <button data-load-type="oks" class="panel-button" style="background-color: #e67e22; margin: 0;"><i class="fas fa-building"></i> Только Здания</button>
        <button data-load-type="construction" class="panel-button" style="background-color: #f1c40f; margin: 0;"><i class="fas fa-industry"></i> Только Сооружения</button>
        <button data-load-type="adjacent" class="panel-button" style="background-color: #9b59b6; margin: 0;"><i class="fas fa-vector-square"></i> Только смежные объекты</button>
    </div>
    <button id="quarterLoadOptionsCancelBtn" class="panel-button" style="background-color: #6c757d; margin-top: 20px;"><i class="fas fa-times"></i> Отмена</button>
</div>

<div id="intersectionOptionsDialog">
    <h3>Пересечение найдено</h3>
    <p id="intersectionCountText">Найдено точек: 0</p>
    <div style="display: flex; flex-direction: column; gap: 10px;">
        <button onclick="applyIntersectionChoice('create_only')" class="panel-button" style="background-color: #3498db; margin: 0;"><i class="fas fa-map-marker-alt"></i> 1. Создать только точки</button>
        <button onclick="applyIntersectionChoice('modify_both')" class="panel-button" style="background-color: #8e44ad; margin: 0;"><i class="fas fa-vector-square"></i> 2. Создать точки в обоих</button>
        <button onclick="applyIntersectionChoice('modify_first')" class="panel-button" style="background-color: #e67e22; margin: 0;"><i class="fas fa-draw-polygon"></i> 3. Только в объекте №1</button>
        <button onclick="applyIntersectionChoice('modify_second')" class="panel-button" style="background-color: #2ecc71; margin: 0;"><i class="fas fa-draw-polygon"></i> 4. Только в объекте №2</button>
    </div>
    <button onclick="closeIntersectionDialog()" class="panel-button" style="background-color: #6c757d; margin-top: 20px;"><i class="fas fa-times"></i> Отмена</button>
</div>

<div id="customConfirmOverlay"></div>
<div id="customConfirmDialog">
    <h3 id="customConfirmTitle">Подтвердите действие</h3>
    <p id="customConfirmMessage">Текст сообщения...</p>
    <div class="dialog-buttons" style="justify-content: center; gap: 15px;">
        <button id="customConfirmYesBtn">Да</button>
        <button id="customConfirmNoBtn">Нет</button>
    </div>
</div>

<div id="globalEditModeBorder"></div>

<script src="webfonts/proj4.js"></script>
<script src="sk.js"></script>


<script>

let userObjects = [];
let selectedObjectIndex = -1;
let nextObjectId = 1;
const objectColors = ['#FF6347','#4682B4','#32CD32','#FFD700','#6A5ACD','#FF4500','#1E90FF','#ADFF2F','#DAA520','#8A2BE2','#DC143C','#00CED1','#9ACD32','#FF8C00','#9932CC'];
let nextColorIndex = 0;

let scale = 1;
let offsetX = 0;
let offsetY = 0;
let minX = undefined, minY = undefined, maxX = undefined, maxY = undefined;

let isDragging = false;
let startX, startY;
let lastOffsetX = 0, lastOffsetY = 0;
let selectedCoordinate = null;
let showPoints = true;

let rulerMode = false;
let rulerPoints = [];
let isDrawingMode = false;
let isDrawingActive = false;
let currentDrawingPoints = [];
let currentMousePos = { x: 0, y: 0 };
let currentHoveredPoint = null;

let isGeometryEditMode = false;
let editingObjectIndex = -1;
let isMovingPoint = false;
let movedPointInfo = null;
let snappedToPointVisual = null;
let geometryHistory = [];

let isNspdLoadCancelled = false;
let isCutToolActive = false;
let cutTargetIndex = -1;
let isUnionToolActive = false;
let unionTargetIndex = -1;
let isIntersectToolActive = false;
let intersectTargetIndex = -1;
let pendingIntersectionData = null;
let showLabels = false;
let adjacentPointsMode = false;
let adjacentObjectIndices = new Set();

const MAX_GEOMETRY_HISTORY = 10;
const SNAP_RADIUS_SCREEN = 10;
const ADD_POINT_THRESHOLD_SCREEN = 7;
const GRAB_POINT_RADIUS_SCREEN = 7;
window.lastPointMoveEndTime = 0;

const STORAGE_API_URL = 'https://mapruapp.ru/storage';
const BUCKET_NAME = 'kpt';
const sevenDigitsRegions = ['24','50','63','66','77','78','91'];
const nextObjectIdPlaceholder = "%%NEXT_OBJECT_ID_PLACEHOLDER%%";

const canvas = document.getElementById('objectAnalysisCanvas');
const ctx = canvas.getContext('2d');
const tooltip = document.getElementById('tooltip');
const selectedObjectInfoDiv = document.getElementById('selectedObjectInfo');
const coordinatesTableContainer = document.getElementById('coordinatesTableContainer');
const intersectionsTitle = document.getElementById('intersectionsTitle');
const intersectionList = document.getElementById('intersectionList');
const objectListUL = document.getElementById('objectList');
const objectCountSpan = document.getElementById('objectCount');
const coordsDialog = document.getElementById('coordsDialog');
const dialogOverlay = document.getElementById('dialogOverlay');
const coordsInput = document.getElementById('coordsInput');
const gridInfoText = document.getElementById('gridStepText');
const cursorCoordinates = document.getElementById('cursorCoordinates');
const measurementPanel = document.getElementById('measurementPanel');
const measurementCoordinates = document.getElementById('measurementCoordinates');
const measurementDistance = document.getElementById('measurementDistance');
const loaderContainer = document.getElementById('loaderContainer');
const loaderTextElement = loaderContainer.querySelector('.loading-text');
const drawObjectBtn = document.getElementById('drawObjectBtn');
const finishDrawingBtn = document.getElementById('finishDrawingBtn');
const namePromptDialog = document.getElementById('namePromptDialog');
const namePromptOverlay = document.getElementById('namePromptOverlay');
const namePromptTitle = document.getElementById('namePromptTitle');
const namePromptInput = document.getElementById('namePromptInput');
const viewInfoText = document.getElementById('viewInfoText');
const toggleGeometryEditBtn = document.getElementById('toggleGeometryEditBtn');
const undoGeometryChangeBtn = document.getElementById('undoGeometryChangeBtn');
const rulerBtn = document.getElementById('rulerBtn');

let touchState = {
    lastTap: 0,
    lastTouchEnd: 0,
    isPinching: false,
    initialPinchDistance: 0,
    initialScale: 1,
    pinchCenterX: 0,
    pinchCenterY: 0,
    touchStartX: 0,
    touchStartY: 0,
    isTouchDragging: false
};

(function() {
    var mobileMenuToggle = document.getElementById('mobileMenuToggle');
    var infoPanel = document.getElementById('infoPanel');

    function isMobile() {
        return window.innerWidth <= 768;
    }

    function closePanel() {
        if (isMobile()) {
            infoPanel.classList.remove('open');
            mobileMenuToggle.classList.remove('active');
            mobileMenuToggle.querySelector('i').className = 'fas fa-bars';
        }
    }

    function togglePanel() {
        if (isMobile()) {
            var isOpen = infoPanel.classList.toggle('open');
            mobileMenuToggle.classList.toggle('active', isOpen);
            mobileMenuToggle.querySelector('i').className = isOpen ? 'fas fa-times' : 'fas fa-bars';
        }
    }

    mobileMenuToggle.addEventListener('click', function(e) {
        e.stopPropagation();
        togglePanel();
    });

    document.getElementById('objectAnalysisContainer').addEventListener('click', function() {
        closePanel();
    });

    document.getElementById('objectAnalysisCanvas').addEventListener('touchstart', function() {
        closePanel();
    }, { passive: true });

    var objectList = document.getElementById('objectList');
    objectList.addEventListener('click', function(e) {
        var li = e.target.closest('li');
        if (li && isMobile()) {
            setTimeout(closePanel, 300);
        }
    });

    window.addEventListener('resize', function() {
        if (!isMobile()) {
            infoPanel.classList.remove('open');
            mobileMenuToggle.classList.remove('active');
            mobileMenuToggle.querySelector('i').className = 'fas fa-bars';
        }
    });

    var dialogs = ['coordsDialog','namePromptDialog','quarterLoadOptionsDialog','intersectionOptionsDialog','customConfirmDialog'];
    dialogs.forEach(function(dialogId) {
        var dialog = document.getElementById(dialogId);
        if (dialog) {
            var closeButtons = dialog.querySelectorAll('[id*="Close"], [id*="Cancel"], [id*="close"], [id*="cancel"]');
            closeButtons.forEach(function(btn) {
                btn.addEventListener('click', function() {
                    closePanel();
                });
            });
        }
    });

    document.addEventListener('gesturestart', function(e) {
        e.preventDefault();
    });

    if (window.visualViewport) {
        window.visualViewport.addEventListener('resize', function() {
            if (document.activeElement.tagName === 'INPUT' || document.activeElement.tagName === 'TEXTAREA') {
                setTimeout(function() {
                    document.activeElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
                }, 100);
            }
        });
    }
})();

function roundCoord(value) {
    if (!isFinite(value)) return value;
    return parseFloat(value.toFixed(2));
}

function showCustomConfirm(title, message) {
    return new Promise((resolve) => {
        const overlay = document.getElementById('customConfirmOverlay');
        const dialog = document.getElementById('customConfirmDialog');
        const titleEl = document.getElementById('customConfirmTitle');
        const msgEl = document.getElementById('customConfirmMessage');
        const yesBtn = document.getElementById('customConfirmYesBtn');
        const noBtn = document.getElementById('customConfirmNoBtn');

        titleEl.textContent = title;
        msgEl.textContent = message;
        overlay.classList.add('show');
        dialog.classList.add('show');
        dialog.style.display = 'block';

        const close = (result) => {
            dialog.classList.remove('show');
            overlay.classList.remove('show');
            dialog.style.display = 'none';
            yesBtn.onclick = null;
            noBtn.onclick = null;
            resolve(result);
        };

        yesBtn.onclick = () => close(true);
        noBtn.onclick = () => close(false);
        overlay.onclick = () => close(false);
    });
}

function updateObjectMetrics(obj) {
    if (!obj || !obj.contours || obj.contours.length === 0) {
        obj.area = 0;
        obj.perimeter = 0;
        return;
    }

    obj.contours.forEach((contour) => {
        if (contour) {
            for (let i = 0; i < contour.length; i++) {
                if (contour[i]) {
                    contour[i].x = roundCoord(contour[i].x);
                    contour[i].y = roundCoord(contour[i].y);
                }
            }

            if (obj.type === 'polygon' && obj.subType !== 'construction_record' && contour.length >= 3) {
                const firstPt = contour[0];
                const lastPt = contour[contour.length - 1];
                const PRECISION_THRESHOLD = 0.001;
                if (!(Math.abs(firstPt.x - lastPt.x) < PRECISION_THRESHOLD && Math.abs(firstPt.y - lastPt.y) < PRECISION_THRESHOLD)) {
                    contour.push({ x: firstPt.x, y: firstPt.y });
                }
            }
        }
    });

    if (obj.type === 'polygon' && obj.subType !== 'construction_record') {
        const polygonStats = obj.contours.map(c => ({
            contour: c,
            area: calculatePolygonArea(c)
        }));

        let totalArea = 0;
        for (let i = 0; i < polygonStats.length; i++) {
            let nestingLevel = 0;
            const currentPoly = polygonStats[i];
            if (currentPoly.area < 1e-9) continue;

            for (let j = 0; j < polygonStats.length; j++) {
                if (i === j) continue;
                const otherPoly = polygonStats[j];
                if (otherPoly.area > currentPoly.area) {
                    if (isPointInPolygon(currentPoly.contour[0], otherPoly.contour)) {
                        nestingLevel++;
                    }
                }
            }

            if (nestingLevel % 2 === 0) {
                totalArea += currentPoly.area;
            } else {
                totalArea -= currentPoly.area;
            }
        }
        obj.area = roundCoord(Math.abs(totalArea));
    } else {
        obj.area = 0;
    }

    let totalPerimeter = 0;
    const isConsideredPolygonForCalc = obj.type === 'polygon' && obj.subType !== 'construction_record';
    obj.contours.forEach(c => {
        totalPerimeter += calculatePolygonPerimeter(c, isConsideredPolygonForCalc);
    });
    obj.perimeter = roundCoord(totalPerimeter);
}

function deepCloneContours(contours) {
    if (!contours) return [];
    return contours.map(contour => {
        if (!contour) return null;
        return contour.map(p => (p ? { ...p } : null));
    });
}

function saveGeometryStateForUndo(objIndex) {
    if (objIndex < 0 || objIndex >= userObjects.length || !userObjects[objIndex]) return;
    const obj = userObjects[objIndex];
    geometryHistory.push(deepCloneContours(obj.contours));
    if (geometryHistory.length > MAX_GEOMETRY_HISTORY) {
        geometryHistory.shift();
    }
    updateUndoButtonState();
}

function undoLastGeometryChange() {
    if (!isGeometryEditMode || editingObjectIndex === -1 || geometryHistory.length === 0) return;
    const obj = userObjects[editingObjectIndex];
    if (!obj) return;

    const previousContours = geometryHistory.pop();
    if (previousContours) {
        obj.contours = previousContours;
        updateObjectMetrics(obj);
        displayObjectInfo(editingObjectIndex);
        redraw(true);
        saveState();
        showNotification("Действие отменено", "info", "undo");
    }
    updateUndoButtonState();
}

function updateUndoButtonState() {
    const undoBtn = document.getElementById('undoGeometryChangeBtn');
    const cutBtn = document.getElementById('cutObjectBtn');
    const unionBtn = document.getElementById('unionObjectBtn');
    const intBtn = document.getElementById('intersectPointsBtn');

    if (isGeometryEditMode) {
        cutBtn.style.display = 'flex';
        unionBtn.style.display = 'flex';
        intBtn.style.display = 'flex';

        if (editingObjectIndex !== -1) {
            undoBtn.style.display = 'flex';
            undoBtn.disabled = geometryHistory.length === 0;
        } else {
            undoBtn.style.display = 'none';
        }

        if (editingObjectIndex === -1) {
            if (isCutToolActive) toggleCutTool();
            if (isUnionToolActive) toggleUnionTool();
            if (isIntersectToolActive) toggleIntersectTool();
        }
    } else {
        undoBtn.style.display = 'none';
        undoBtn.disabled = true;
        cutBtn.style.display = 'none';
        cutBtn.classList.remove('active');
        isCutToolActive = false;
        cutTargetIndex = -1;
        unionBtn.style.display = 'none';
        unionBtn.classList.remove('active');
        isUnionToolActive = false;
        unionTargetIndex = -1;
        intBtn.style.display = 'none';
        intBtn.classList.remove('active');
        isIntersectToolActive = false;
        intersectTargetIndex = -1;
    }
}

function toggleCutTool() {
    if (!isGeometryEditMode) return;
    isCutToolActive = !isCutToolActive;
    const btn = document.getElementById('cutObjectBtn');
    if (isCutToolActive) {
        btn.classList.add('active');
        cutTargetIndex = -1;
        showNotification("Инструмент «Ножницы»: Двойной клик по РАССЕКАЕМОМУ объекту.", "info", "cut");
        canvas.style.cursor = 'crosshair';
    } else {
        btn.classList.remove('active');
        cutTargetIndex = -1;
        showNotification("Инструмент «Ножницы» выключен.", "info", "times");
        canvas.style.cursor = 'default';
    }
    redraw(true);
}

function loadState() {
    try {
        const savedStateJSON = localStorage.getItem('geoAnalyzerState');
        if (savedStateJSON) {
            const state = JSON.parse(savedStateJSON);
            userObjects = (state.userObjects || []).filter(o => o && o.id && o.contours);
            nextObjectId = state.nextObjectId || 1;
            nextColorIndex = state.nextColorIndex || 0;
            showPoints = state.showPoints === undefined ? true : state.showPoints;

            if (state.view && state.view.minX !== undefined && isFinite(state.view.scale)) {
                scale = state.view.scale;
                offsetX = state.view.offsetX;
                offsetY = state.view.offsetY;
                minX = state.view.minX;
                minY = state.view.minY;
                maxX = state.view.maxX;
                maxY = state.view.maxY;
                if (!hasValidView()) {
                    calculateBounds();
                    resetView();
                }
            } else {
                calculateBounds();
                resetView();
            }
        } else {
            userObjects = [];
            nextObjectId = 1;
            nextColorIndex = 0;
            showPoints = true;
            calculateBounds();
            resetView();
        }
    } catch (e) {
        userObjects = [];
        nextObjectId = 1;
        nextColorIndex = 0;
        showPoints = true;
        calculateBounds();
        resetView();
        showNotification("Ошибка загрузки сохраненного состояния.", "warning", "hdd");
    }
    userObjects.forEach(obj => updateObjectMetrics(obj));
}

async function initializeApp() {
    canvas.width = canvas.offsetWidth;
    canvas.height = canvas.offsetHeight;
    setupEventListeners();
    loadState();
    populateImportModeSelect();

    const clipboardImported = await checkClipboardForObjects();

    updateObjectList();

    if (userObjects.length > 0 && (!hasValidView() || clipboardImported)) {
        calculateBounds();
        resetView();
    } else if (userObjects.length === 0) {
        calculateBounds();
        resetView();
    }

    redraw(false);
    updateViewInfo();
    updateToggleButtonStates();
    updateUndoButtonState();
}

const cMinXGlob = () => (minX === undefined || !isFinite(minX)) ? 0 : minX;
const cMinYGlob = () => (minY === undefined || !isFinite(minY)) ? 0 : minY;

function calculateBounds() {
    const canvasWidth = canvas.width || 100;
    const canvasHeight = canvas.height || 100;

    if (userObjects.length === 0) {
        minX = 0; minY = 0; maxX = canvasWidth; maxY = canvasHeight;
        return;
    }

    let currentMinX = Infinity, currentMinY = Infinity, currentMaxX = -Infinity, currentMaxY = -Infinity;
    let hasValidPoints = false;
    userObjects.forEach(obj => {
        if (!obj || !obj.contours) return;
        obj.contours.forEach(contour => {
            if (!contour) return;
            contour.forEach(p => {
                if (p && isFinite(p.x) && isFinite(p.y)) {
                    currentMinX = Math.min(currentMinX, p.x);
                    currentMinY = Math.min(currentMinY, p.y);
                    currentMaxX = Math.max(currentMaxX, p.x);
                    currentMaxY = Math.max(currentMaxY, p.y);
                    hasValidPoints = true;
                }
            });
        });
    });

    if (hasValidPoints && isFinite(currentMinX)) {
        minX = currentMinX; minY = currentMinY; maxX = currentMaxX; maxY = currentMaxY;
    } else {
        minX = 0; minY = 0; maxX = canvasWidth; maxY = canvasHeight;
    }
}

function isCoordinateLine(line) {
    if (!line) return false;
    const parts = line.replace(/,/g, '.').trim().split(/[\s\t]+/);
    if (parts.length < 2) return false;
    const x = parseFloat(parts[0]);
    const y = parseFloat(parts[1]);
    return isFinite(x) && isFinite(y);
}

function parseTextToObjects(text, defaultColor = null) {
    if (!text || !text.trim()) return [];

    const lines = text.trim().split('\n').map(l => l.trim());
    if (lines.length === 0) return [];

    const groupsMap = new Map();
    let currentName = null;
    let isExplicitName = false;

    lines.forEach(line => {
        if (!line) {
            if (currentName !== null && groupsMap.has(currentName)) {
                groupsMap.get(currentName).lines.push('');
            }
            return;
        }

        if (isCoordinateLine(line)) {
            if (currentName === null) {
                currentName = "unnamed_group";
                isExplicitName = false;
            }

            if (!groupsMap.has(currentName)) {
                groupsMap.set(currentName, { displayName: isExplicitName ? currentName : null, lines: [] });
            }
            groupsMap.get(currentName).lines.push(line);
        } else {
            const newName = line;
            currentName = newName;
            isExplicitName = true;

            if (!groupsMap.has(newName)) {
                groupsMap.set(newName, { displayName: newName, lines: [] });
            } else {
                const group = groupsMap.get(newName);
                if (group.lines.length > 0) {
                    group.lines.push('');
                }
            }
        }
    });

    const resultObjects = [];

    groupsMap.forEach((groupData, keyName) => {
        const coordinatesText = groupData.lines.join('\n');
        const rawContours = parseCoordinatesFromText(coordinatesText);

        if (rawContours.length === 0) return;

        if (groupData.displayName) {
            const mainContour = rawContours[0];
            let objectType = 'point';

            if (mainContour.length >= 3) {
                const first = mainContour[0];
                const last = mainContour[mainContour.length - 1];
                if (Math.abs(first.x - last.x) < 0.001 && Math.abs(first.y - last.y) < 0.001) {
                    objectType = 'polygon';
                } else {
                    objectType = 'line';
                }
            } else if (mainContour.length === 2) {
                objectType = 'line';
            }

            resultObjects.push({
                contours: rawContours,
                name: groupData.displayName,
                type: objectType,
                color: defaultColor
            });
        } else {
            const consolidated = consolidateContoursIntoObjects(rawContours);

            consolidated.forEach((objectContours, index) => {
                const mainContour = objectContours[0];
                let objectType = 'point';

                if (mainContour.length >= 3) {
                    const first = mainContour[0];
                    const last = mainContour[mainContour.length - 1];
                    if (Math.abs(first.x - last.x) < 0.001 && Math.abs(first.y - last.y) < 0.001) {
                        objectType = 'polygon';
                    } else {
                        objectType = 'line';
                    }
                } else if (mainContour.length === 2) {
                    objectType = 'line';
                }

                const nameSuffix = consolidated.length > 1 ? ` (${index + 1})` : '';
                const name = `Объект ${nextObjectIdPlaceholder}${nameSuffix}`;

                resultObjects.push({
                    contours: objectContours,
                    name: name,
                    type: objectType,
                    color: defaultColor
                });
            });
        }
    });

    return resultObjects;
}

async function checkClipboardForObjects() {
    try {
        const text = await navigator.clipboard.readText();
        if (!text || text.trim().length === 0) return false;

        const trimmedText = text.trim();
        const lines = trimmedText.split('\n').map(l => l.trim()).filter(l => l);

        if (lines.length === 1 && isValidCadastralNumberFormat(lines[0])) {
            showLoader(true, `Загрузка ${lines[0]}...`);
            userObjects = []; nextObjectId = 1; nextColorIndex = 0; selectedObjectIndex = -1; editingObjectIndex = -1; geometryHistory = [];
            await handleImportFromCadNumbers([lines[0]]);
            showLoader(false);
            return true;
        }

        const objectsToAdd = parseTextToObjects(trimmedText);

        if (objectsToAdd.length > 0) {
            showLoader(true, "Импорт из буфера обмена...");
            userObjects = []; nextObjectId = 1; nextColorIndex = 0; selectedObjectIndex = -1; editingObjectIndex = -1; geometryHistory = [];

            let addedBatch = [];
            objectsToAdd.forEach(objData => {
                const realName = objData.name.replace(nextObjectIdPlaceholder, nextObjectId);
                const newObj = addObjectInternal(objData.contours, realName, objData.type, true);
                if (newObj) addedBatch.push(newObj);
            });

            if (addedBatch.length > 0) {
                finalizeBatchAdd(addedBatch);
                showNotification(`Импортировано ${addedBatch.length} объектов из буфера.`, "success", "clipboard-check");
                showLoader(false);
                return true;
            }
        }
    } catch (err) {}
    showLoader(false);
    return false;
}

function updateViewInfo() {
    if (!viewInfoText || !hasValidView() || !canvas || canvas.width <= 0 || scale <= 1e-9) {
        if (viewInfoText) viewInfoText.textContent = `Обзор: -`;
        return;
    }
    const visibleWidthMeters = canvas.width / scale;
    let displayText;
    if (!isFinite(visibleWidthMeters)) {
        displayText = `Высота: -`;
    } else if (visibleWidthMeters >= 1000) {
        displayText = `Высота: ${(visibleWidthMeters / 1000).toFixed(2)} км`;
    } else {
        displayText = `Высота: ${visibleWidthMeters.toFixed(1)} м`;
    }
    viewInfoText.textContent = displayText;
}

function resetView() {
    calculateBounds();
    const canvasWidth = canvas.width || 100;
    const canvasHeight = canvas.height || 100;

    if (minX === undefined || !isFinite(minX) || maxX === undefined || !isFinite(maxX) ||
        minY === undefined || !isFinite(minY) || maxY === undefined || !isFinite(maxY)) {
        scale = 1; offsetX = 0; offsetY = 0;
        minX = 0; minY = 0; maxX = canvasWidth; maxY = canvasHeight;
    } else {
        const dataWidth = Math.max(1e-6, maxX - minX);
        const dataHeight = Math.max(1e-6, maxY - minY);
        const scaleX = canvasWidth / dataWidth * 0.9;
        const scaleY = canvasHeight / dataHeight * 0.9;
        scale = Math.max(1e-9, Math.min(Math.min(scaleX, scaleY), 10000));
        if (!isFinite(scale) || scale <= 0) scale = 1;

        const centerX = minX + dataWidth / 2;
        const centerY = minY + dataHeight / 2;
        offsetX = canvasWidth / 2 - (centerY - cMinYGlob()) * scale;
        offsetY = canvasHeight / 2 - (centerX - cMinXGlob()) * scale;
    }

    if (!isFinite(scale) || scale <= 0) scale = 1;
    if (!isFinite(offsetX)) offsetX = 0;
    if (!isFinite(offsetY)) offsetY = 0;

    if (!hasValidView()) {
        scale = 1; offsetX = 0; offsetY = 0;
        minX = 0; minY = 0; maxX = canvasWidth; maxY = canvasHeight;
    }
    updateViewInfo();
}

function hasValidView() {
    return isFinite(scale) && scale > 1e-9 &&
        isFinite(offsetX) && isFinite(offsetY) &&
        minX !== undefined && minY !== undefined && maxX !== undefined && maxY !== undefined &&
        isFinite(minX) && isFinite(minY) && isFinite(maxX) && isFinite(maxY);
}

function updateToggleButtonStates() {
    const pointsBtn = document.getElementById('togglePointsBtn');
    if (pointsBtn) {
        pointsBtn.style.backgroundColor = showPoints ? '#e74c3c' : '#7f8c8d';
    }

    const adjBtn = document.getElementById('showAdjacentPointsBtn');
    if (adjBtn) {
        if (adjacentPointsMode) {
            adjBtn.style.color = '#e74c3c';
            adjBtn.style.transform = 'translateY(-50%) scale(1.2)';
        } else {
            adjBtn.style.color = '';
            adjBtn.style.transform = '';
        }
    }

    const rulerBtn = document.getElementById('rulerBtn');
    if (rulerBtn) {
        rulerBtn.classList.toggle('active', rulerMode);
    }

    const drawBtn = document.getElementById('drawObjectBtn');
    if (drawBtn) {
        drawBtn.classList.toggle('active', isDrawingMode);
    }

    const finishDrawBtn = document.getElementById('finishDrawingBtn');
    if (finishDrawBtn) {
        finishDrawBtn.style.display = isDrawingActive ? 'flex' : 'none';
    }

    const geomEditBtn = document.getElementById('toggleGeometryEditBtn');
    if (geomEditBtn) {
        geomEditBtn.classList.toggle('active', isGeometryEditMode);
    }

    updateUndoButtonState();

    canvas.classList.toggle('drawing-mode', isDrawingMode && isDrawingActive);
    canvas.classList.toggle('editing-point-mode', isMovingPoint);

    const labelsDlgBtn = document.getElementById('toggleLabelsDialogBtn');
    if (labelsDlgBtn) {
        if (showLabels) {
            labelsDlgBtn.classList.add('active');
            labelsDlgBtn.innerHTML = '<i class="fas fa-check-square"></i> Подписи вкл.';
        } else {
            labelsDlgBtn.classList.remove('active');
            labelsDlgBtn.innerHTML = '<i class="fas fa-tag"></i> Подписи коорд.';
        }
    }
}

function setupEventListeners() {
    canvas.addEventListener('mousedown', handleMouseDown);
    canvas.addEventListener('mousemove', handleMouseMove);
    canvas.addEventListener('mouseup', handleMouseUp);
    canvas.addEventListener('wheel', handleWheel, { passive: false });
    canvas.addEventListener('click', handleClick);
    canvas.addEventListener('dblclick', handleDoubleClick);
    canvas.addEventListener('mouseout', handleMouseOut);
    canvas.addEventListener('contextmenu', handleContextMenu);

    canvas.addEventListener('touchstart', handleTouchStart, { passive: false });
    canvas.addEventListener('touchmove', handleTouchMove, { passive: false });
    canvas.addEventListener('touchend', handleTouchEnd, { passive: false });
    canvas.addEventListener('touchcancel', handleTouchEnd, { passive: false });

    const toggleLabelsDialogBtn = document.getElementById('toggleLabelsDialogBtn');
    if (toggleLabelsDialogBtn) {
        toggleLabelsDialogBtn.addEventListener('click', toggleLabelsVisibility);
    }

    document.getElementById('saveProjectBtn').addEventListener('click', saveProjectToJson);
    document.getElementById('openProjectBtn').addEventListener('click', () => {
        document.getElementById('projectFileInput').click();
    });
    document.getElementById('projectFileInput').addEventListener('change', loadProjectFromJson);
    document.getElementById('findCoordsBtn').addEventListener('click', handleFindCoordinates);
    document.getElementById('addObjectBtn').addEventListener('click', openCoordsDialog);
    document.getElementById('togglePointsBtn').addEventListener('click', togglePointsVisibility);
    document.getElementById('hideAllObjectsBtn').addEventListener('click', hideAllObjects);
    document.getElementById('rulerBtn').addEventListener('click', () => toggleMode('ruler'));
    document.getElementById('resetMeasurementBtn').addEventListener('click', resetMeasurement);
    drawObjectBtn.addEventListener('click', () => toggleMode('draw'));
    document.getElementById('cutObjectBtn').addEventListener('click', toggleCutTool);
    document.getElementById('unionObjectBtn').addEventListener('click', toggleUnionTool);
    document.getElementById('intersectPointsBtn').addEventListener('click', toggleIntersectTool);
    finishDrawingBtn.addEventListener('click', finishDrawingAsLineOrPoint);
    toggleGeometryEditBtn.addEventListener('click', () => toggleMode('geometryEdit'));
    undoGeometryChangeBtn.addEventListener('click', undoLastGeometryChange);
    document.getElementById('importCoordsBtn').addEventListener('click', handleUniversalImport);
    document.getElementById('importFromFileBtn').addEventListener('click', handleImportFromFile);
    document.getElementById('closeDialogBtn').addEventListener('click', closeCoordsDialog);
    dialogOverlay.addEventListener('click', closeCoordsDialog);
    coordsDialog.addEventListener('click', (e) => e.stopPropagation());

    window.addEventListener('resize', () => {
        canvas.width = canvas.offsetWidth;
        canvas.height = canvas.offsetHeight;
        calculateBounds();
        redraw(true);
    });

    document.addEventListener('keydown', (e) => {
        if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') {
            return;
        }

        if (e.key === 'F6') {
            e.preventDefault();
            let targetX, targetY;

            if (currentHoveredPoint) {
                targetX = currentHoveredPoint.x;
                targetY = currentHoveredPoint.y;
            } else if (currentMousePos && isFinite(currentMousePos.x) && isFinite(currentMousePos.y)) {
                targetX = currentMousePos.x;
                targetY = currentMousePos.y;
            }

            if (isFinite(targetX) && isFinite(targetY)) {
                const textToCopy = `${targetX.toFixed(2)}\t${targetY.toFixed(2)}`;
                copyToClipboard(textToCopy);
            }
            return;
        }

        const panStep = 50;
        const zoomStep = 1.2;
        let handled = false;

        if (e.key === 'ArrowLeft') { offsetX += panStep; handled = true; }
        else if (e.key === 'ArrowRight') { offsetX -= panStep; handled = true; }
        else if (e.key === 'ArrowUp') { offsetY -= panStep; handled = true; }
        else if (e.key === 'ArrowDown') { offsetY += panStep; handled = true; }
        else if (e.key === '+' || e.key === '=') {
            const cX = canvas.width / 2;
            const cY = canvas.height / 2;
            const dataPoint = inverseTransformCoord(cX, cY);

            if (isFinite(dataPoint.x) && isFinite(dataPoint.y)) {
                let newScale = scale * zoomStep;
                newScale = Math.max(1e-9, Math.min(newScale, 10000));
                scale = newScale;
                offsetX = cX - (dataPoint.y - cMinYGlob()) * scale;
                offsetY = canvas.height - cY - (dataPoint.x - cMinXGlob()) * scale;
                updateViewInfo();
                handled = true;
            }
        } else if (e.key === '-' || e.key === '_') {
            const cX = canvas.width / 2;
            const cY = canvas.height / 2;
            const dataPoint = inverseTransformCoord(cX, cY);

            if (isFinite(dataPoint.x) && isFinite(dataPoint.y)) {
                let newScale = scale / zoomStep;
                newScale = Math.max(1e-9, Math.min(newScale, 10000));
                scale = newScale;
                offsetX = cX - (dataPoint.y - cMinYGlob()) * scale;
                offsetY = canvas.height - cY - (dataPoint.x - cMinXGlob()) * scale;
                updateViewInfo();
                handled = true;
            }
        }

        if (handled) {
            e.preventDefault();
            redraw(true);
            return;
        }

        if (e.key === 'Escape') {
            if (loaderContainer.style.display === 'flex') {
                isNspdLoadCancelled = true;
                showLoader(false);
                showNotification("Загрузка отменена пользователем.", "warning", "hand-paper");
                return;
            }
            if (isGeometryEditMode) { deactivateGeometryEditMode(); }
            if (isDrawingMode) { cancelDrawing(); }
            if (rulerMode) { toggleMode('ruler'); }
        }
    });

    document.getElementById('cancelLoadBtn').addEventListener('click', () => {
        isNspdLoadCancelled = true;
        showNotification("Отмена загрузки...", "warning");
        document.getElementById('cancelLoadBtn').style.display = 'none';
        loaderTextElement.textContent = "Остановка...";
    });

    document.getElementById('deleteAllObjectsBtn').addEventListener('click', deleteAllObjects);
    document.getElementById('showAdjacentPointsBtn').addEventListener('click', toggleAdjacentPointsMode);
    document.getElementById('showAllObjectsBtn').addEventListener('click', () => {
        if (userObjects.length > 0) {
            resetView();
            redraw(true);
        } else {
            showNotification("Нет объектов для отображения.", "info");
        }
    });
    document.getElementById('importModeSelect').addEventListener('change', (e) => {
        localStorage.setItem('selectedImportMode', e.target.value);
    });
}

function handleTouchStart(e) {
    if (e.touches.length === 2) {
        e.preventDefault();
        touchState.isPinching = true;
        const touch1 = e.touches[0];
        const touch2 = e.touches[1];
        touchState.initialPinchDistance = Math.hypot(
            touch2.clientX - touch1.clientX,
            touch2.clientY - touch1.clientY
        );
        touchState.initialScale = scale;
        const rect = canvas.getBoundingClientRect();
        touchState.pinchCenterX = ((touch1.clientX + touch2.clientX) / 2) - rect.left;
        touchState.pinchCenterY = ((touch1.clientY + touch2.clientY) / 2) - rect.top;
        return;
    }

    if (e.touches.length === 1) {
        const touch = e.touches[0];
        const rect = canvas.getBoundingClientRect();
        touchState.touchStartX = touch.clientX;
        touchState.touchStartY = touch.clientY;
        touchState.isTouchDragging = false;

        const canvasX = touch.clientX - rect.left;
        const canvasY = touch.clientY - rect.top;
        const dataPoint = inverseTransformCoord(canvasX, canvasY);

        if (isDrawingMode && isDrawingActive) {
            return;
        }

        if (rulerMode) {
            return;
        }

        if (isGeometryEditMode && editingObjectIndex !== -1) {
            const obj = userObjects[editingObjectIndex];
            if (obj && obj.contours) {
                const grabRadiusDataSq = (GRAB_POINT_RADIUS_SCREEN / scale) ** 2;
                for (let cIdx = 0; cIdx < obj.contours.length; cIdx++) {
                    const contour = obj.contours[cIdx];
                    if (!contour) continue;
                    for (let pIdx = 0; pIdx < contour.length; pIdx++) {
                        const point = contour[pIdx];
                        if (!point || !isFinite(point.x) || !isFinite(point.y)) continue;
                        const distSq = (dataPoint.x - point.x) ** 2 + (dataPoint.y - point.y) ** 2;
                        if (distSq < grabRadiusDataSq) {
                            e.preventDefault();
                            isMovingPoint = true;
                            movedPointInfo = {
                                objectIndex: editingObjectIndex,
                                contourIndex: cIdx,
                                pointIndex: pIdx,
                                originalX: point.x,
                                originalY: point.y
                            };
                            const editingObj = userObjects[editingObjectIndex];
                            if (editingObj && editingObj.type === 'polygon') {
                                movedPointInfo.originalArea = editingObj.area;
                            }
                            saveGeometryStateForUndo(editingObjectIndex);
                            canvas.classList.add('editing-point-mode');
                            redraw(true);
                            return;
                        }
                    }
                }
            }
        }

        lastOffsetX = offsetX;
        lastOffsetY = offsetY;
        startX = touch.clientX;
        startY = touch.clientY;
    }
}

function handleTouchMove(e) {
    if (touchState.isPinching && e.touches.length === 2) {
        e.preventDefault();
        const touch1 = e.touches[0];
        const touch2 = e.touches[1];
        const currentDistance = Math.hypot(
            touch2.clientX - touch1.clientX,
            touch2.clientY - touch1.clientY
        );

        const pinchRatio = currentDistance / touchState.initialPinchDistance;
        let newScale = touchState.initialScale * pinchRatio;
        newScale = Math.max(1e-9, Math.min(newScale, 10000));

        const dataPointAtCenter = inverseTransformCoord(touchState.pinchCenterX, touchState.pinchCenterY);

        if (isFinite(dataPointAtCenter.x) && isFinite(dataPointAtCenter.y)) {
            scale = newScale;
            offsetX = touchState.pinchCenterX - (dataPointAtCenter.y - cMinYGlob()) * scale;
            offsetY = canvas.height - touchState.pinchCenterY - (dataPointAtCenter.x - cMinXGlob()) * scale;
            updateViewInfo();
            redraw(true);
        }
        return;
    }

    if (e.touches.length === 1) {
        const touch = e.touches[0];
        const rect = canvas.getBoundingClientRect();
        const canvasX = touch.clientX - rect.left;
        const canvasY = touch.clientY - rect.top;

        const dx = touch.clientX - touchState.touchStartX;
        const dy = touch.clientY - touchState.touchStartY;

        if (Math.abs(dx) > 10 || Math.abs(dy) > 10) {
            touchState.isTouchDragging = true;
        }

        if (isMovingPoint && movedPointInfo) {
            e.preventDefault();
            const dP = inverseTransformCoord(canvasX, canvasY);
            let targetPoint = { x: dP.x, y: dP.y };

            const snapRadiusDataSq = (SNAP_RADIUS_SCREEN / scale) ** 2;
            let bestSnapDistSq = snapRadiusDataSq;
            let foundSnap = false;

            for (const snapObj of userObjects) {
                if (!snapObj.contours) continue;
                for (const snapContour of snapObj.contours) {
                    if (!snapContour) continue;
                    for (let i = 0; i < snapContour.length; i++) {
                        const snapCandidatePt = snapContour[i];
                        if (isMovingPoint && movedPointInfo &&
                            snapObj === userObjects[movedPointInfo.objectIndex] &&
                            snapContour === userObjects[movedPointInfo.objectIndex].contours[movedPointInfo.contourIndex] &&
                            i === movedPointInfo.pointIndex) {
                            continue;
                        }
                        const distSq = (dP.x - snapCandidatePt.x) ** 2 + (dP.y - snapCandidatePt.y) ** 2;
                        if (distSq < bestSnapDistSq) {
                            bestSnapDistSq = distSq;
                            targetPoint = { x: snapCandidatePt.x, y: snapCandidatePt.y };
                            snappedToPointVisual = { ...targetPoint };
                            foundSnap = true;
                        }
                    }
                }
            }

            if (!foundSnap) {
                snappedToPointVisual = null;
            }

            const objToUpdate = userObjects[movedPointInfo.objectIndex];
            const contourToUpdate = objToUpdate.contours[movedPointInfo.contourIndex];
            const pointToUpdate = contourToUpdate[movedPointInfo.pointIndex];

            pointToUpdate.x = targetPoint.x;
            pointToUpdate.y = targetPoint.y;

            if (objToUpdate.type === 'polygon' && contourToUpdate.length > 1) {
                const lastIndex = contourToUpdate.length - 1;
                if (movedPointInfo.pointIndex === 0) {
                    const lastPoint = contourToUpdate[lastIndex];
                    if (lastPoint) { lastPoint.x = targetPoint.x; lastPoint.y = targetPoint.y; }
                } else if (movedPointInfo.pointIndex === lastIndex) {
                    const firstPoint = contourToUpdate[0];
                    if (firstPoint) { firstPoint.x = targetPoint.x; firstPoint.y = targetPoint.y; }
                }
            }

            updateObjectMetrics(objToUpdate);
            redraw(true);
            return;
        }

        if (touchState.isTouchDragging && !isDrawingActive && !rulerMode) {
            e.preventDefault();
            offsetX = lastOffsetX + (touch.clientX - startX);
            offsetY = lastOffsetY - (touch.clientY - startY);
            redraw(true);
        }
    }
}

function handleTouchEnd(e) {
    if (touchState.isPinching) {
        touchState.isPinching = false;
        if (e.touches.length === 0) {
            saveState();
        }
        return;
    }

    if (isMovingPoint) {
        isMovingPoint = false;
        snappedToPointVisual = null;
        canvas.classList.remove('editing-point-mode');
        updateObjectMetrics(userObjects[movedPointInfo.objectIndex]);
        if (movedPointInfo.objectIndex === selectedObjectIndex) {
            displayObjectInfo(selectedObjectIndex);
        }
        movedPointInfo = null;
        saveState();
        redraw(true);
        window.lastPointMoveEndTime = Date.now();
        return;
    }

    const now = Date.now();
    const DOUBLE_TAP_DELAY = 300;
    const TAP_THRESHOLD = 15;

    if (e.changedTouches.length === 1 && !touchState.isTouchDragging) {
        const touch = e.changedTouches[0];
        const rect = canvas.getBoundingClientRect();
        const canvasX = touch.clientX - rect.left;
        const canvasY = touch.clientY - rect.top;
        const dataPoint = inverseTransformCoord(canvasX, canvasY);

        if (now - touchState.lastTap < DOUBLE_TAP_DELAY) {
            touchState.lastTap = 0;
            if (isDrawingMode && isDrawingActive) {
                finishDrawingAsPolygon();
            } else if (isCutToolActive && isGeometryEditMode) {
                handleCutSelection(dataPoint);
            } else if (isUnionToolActive && isGeometryEditMode) {
                handleUnionSelection(dataPoint);
            } else if (isIntersectToolActive && isGeometryEditMode) {
                handleIntersectSelection(dataPoint);
            } else if (!rulerMode && !isMovingPoint && !isGeometryEditMode) {
                selectObjectByPoint(dataPoint);
            }
        } else {
            touchState.lastTap = now;

            setTimeout(() => {
                if (now === touchState.lastTap) {
                    if (isDrawingMode && isDrawingActive) {
                        const pointToAdd = snappedToPointVisual
                            ? { x: snappedToPointVisual.x, y: snappedToPointVisual.y }
                            : { x: dataPoint.x, y: dataPoint.y };
                        currentDrawingPoints.push(pointToAdd);
                        redraw(true);
                    } else if (rulerMode) {
                        if (rulerPoints.length < 2) {
                            const pointToAdd = snappedToPointVisual
                                ? { x: snappedToPointVisual.x, y: snappedToPointVisual.y }
                                : { x: dataPoint.x, y: dataPoint.y };
                            rulerPoints.push(pointToAdd);
                            updateMeasurementPanel();
                            redraw(true);
                            if (rulerPoints.length === 2) {
                                const dist = calculateDistance(rulerPoints[0], rulerPoints[1]);
                                if (isFinite(dist)) showNotification(`Расстояние: ${dist.toFixed(2)} м`, "success", "ruler");
                            }
                        }
                    } else if (isGeometryEditMode && editingObjectIndex !== -1) {
                        handleGeometryEditTap(dataPoint);
                    }
                }
            }, DOUBLE_TAP_DELAY + 50);
        }
    }

    if (touchState.isTouchDragging) {
        saveState();
    }

    touchState.isTouchDragging = false;
    touchState.lastTouchEnd = now;
}

function handleGeometryEditTap(dataPoint) {
    const obj = userObjects[editingObjectIndex];
    if (!obj || !obj.contours) return;

    let bestMatch = { distSq: Infinity, contourIndex: -1, segmentIndex: -1, newPoint: null };
    const clickThresholdDataSq = (ADD_POINT_THRESHOLD_SCREEN / scale) ** 2;

    obj.contours.forEach((contour, cIdx) => {
        if (!contour || contour.length < (obj.type === 'line' ? 1 : 2)) return;
        const numSegments = obj.type === 'polygon' ? contour.length : contour.length - 1;
        if (numSegments < 1 && obj.type !== 'point') return;

        for (let sIdx = 0; sIdx < numSegments; sIdx++) {
            const p1 = contour[sIdx];
            const p2 = contour[(sIdx + 1) % (obj.type === 'polygon' ? contour.length : Infinity)];
            if (!p2 && obj.type === 'line' && sIdx === contour.length - 1) continue;

            const closestPtOnSeg = getClosestPointOnSegment(dataPoint, p1, p2);
            const distSq = (dataPoint.x - closestPtOnSeg.x) ** 2 + (dataPoint.y - closestPtOnSeg.y) ** 2;

            if (distSq < bestMatch.distSq && distSq < clickThresholdDataSq) {
                bestMatch = { distSq, contourIndex: cIdx, segmentIndex: sIdx, newPoint: closestPtOnSeg };
            }
        }
    });

    if (bestMatch.newPoint) {
        saveGeometryStateForUndo(editingObjectIndex);
        const contourToModify = userObjects[editingObjectIndex].contours[bestMatch.contourIndex];
        contourToModify.splice(bestMatch.segmentIndex + 1, 0, bestMatch.newPoint);
        updateObjectMetrics(userObjects[editingObjectIndex]);
        displayObjectInfo(editingObjectIndex);
        showNotification("Точка добавлена на сегмент.", "success", "plus-circle");
        redraw(true);
        saveState();
    }
}

function activateGeometryEditMode() {
    if (selectedObjectIndex === -1) {
        showNotification("Сначала выберите объект для редактирования.", "warning", "hand-pointer");
        return false;
    }
    isGeometryEditMode = true;
    editingObjectIndex = selectedObjectIndex;
    geometryHistory = [];
    saveGeometryStateForUndo(editingObjectIndex);

    if (rulerMode) { rulerMode = false; measurementPanel.classList.remove('active'); rulerPoints = []; }
    if (isDrawingMode) { isDrawingMode = false; isDrawingActive = false; currentDrawingPoints = []; }

    showNotification(`Режим редактирования для "${userObjects[editingObjectIndex].name || 'Объект ' + userObjects[editingObjectIndex].id}".`, "info", "edit");

    const borderEl = document.getElementById('globalEditModeBorder');
    const badge = document.getElementById('editModeBadge');

    if (borderEl) borderEl.classList.add('active');
    if (badge) badge.style.display = 'block';

    redraw(true);
    return true;
}

function deactivateGeometryEditMode(showNotif = true) {
    if (!isGeometryEditMode) return;

    isGeometryEditMode = false;
    editingObjectIndex = -1;
    isMovingPoint = false;
    movedPointInfo = null;
    snappedToPointVisual = null;
    geometryHistory = [];

    if (showNotif) showNotification("Режим редактирования геометрии выключен.", "info", "edit");

    if (!rulerMode && !isDrawingMode) canvas.style.cursor = 'grab';

    const borderEl = document.getElementById('globalEditModeBorder');
    const badge = document.getElementById('editModeBadge');

    if (borderEl) borderEl.classList.remove('active');
    if (badge) badge.style.display = 'none';

    updateToggleButtonStates();
    redraw(true);
}

document.getElementById('editModeBadge').addEventListener('click', function() {
    deactivateGeometryEditMode();
});

function toggleMode(modeToToggle) {
    if (modeToToggle !== 'ruler' && rulerMode) {
        rulerMode = false; measurementPanel.classList.remove('active'); rulerPoints = [];
    }
    if (modeToToggle !== 'draw' && isDrawingMode) {
        isDrawingMode = false; isDrawingActive = false; currentDrawingPoints = [];
    }
    if (modeToToggle !== 'geometryEdit' && isGeometryEditMode) {
        deactivateGeometryEditMode(false);
    }

    if (modeToToggle === 'ruler') {
        rulerMode = !rulerMode;
        if (rulerMode) {
            resetMeasurement(); measurementPanel.classList.add('active');
            showNotification('Режим измерения включен.', 'info', 'ruler');
            canvas.style.cursor = 'crosshair';
        } else {
            measurementPanel.classList.remove('active');
            rulerPoints = [];
            showNotification('Режим измерения выключен.', 'info', 'ruler');
        }
    } else if (modeToToggle === 'draw') {
        isDrawingMode = !isDrawingMode;
        if (isDrawingMode) activateDrawingMode();
        else cancelDrawing();
    } else if (modeToToggle === 'geometryEdit') {
        if (isGeometryEditMode) {
            deactivateGeometryEditMode();
        } else {
            activateGeometryEditMode();
        }
    }

    if (!rulerMode && !isDrawingMode && !isGeometryEditMode && !isMovingPoint) {
        canvas.style.cursor = 'grab';
    }
    updateToggleButtonStates();
    redraw(true);
}

function saveState() {
    try {
        const maxObjectsToSave = 50;
        const validObjects = userObjects.filter(o => o);
        const objectsToSave = validObjects.slice(-maxObjectsToSave);
        const state = {
            userObjects: objectsToSave,
            nextObjectId,
            nextColorIndex,
            view: hasValidView() ? { scale, offsetX, offsetY, minX, minY, maxX, maxY } : null,
            showPoints
        };
        localStorage.setItem('geoAnalyzerState', JSON.stringify(state));
    } catch (e) {
        if (e.name === 'QuotaExceededError') {
            localStorage.removeItem('geoAnalyzerState');
            showNotification("Хранилище переполнено. Старые данные удалены.", "warning", "hdd");
        }
    }
}

function addObjectInternal(contoursData, name, objectType, isMultiPart = false, subType = null, specificColor = null) {
    if (!contoursData || contoursData.length === 0 || contoursData.every(c => !c || c.length === 0)) {
        if (!isMultiPart) showNotification("Не удалось добавить объект: нет контуров.", "error", "exclamation-circle");
        return null;
    }

    const processedContours = contoursData.map(contour => {
        if (!contour || contour.length === 0) return null;
        const roundedContour = contour.map(p => ({ x: roundCoord(p.x), y: roundCoord(p.y) }));
        const validPoints = roundedContour.filter(p => p && isFinite(p.x) && isFinite(p.y));
        if (validPoints.length === 0) return null;
        return validPoints;
    }).filter(c => c !== null && c.length > 0);

    if (processedContours.length === 0) {
        if (!isMultiPart) showNotification("Не удалось добавить объект: нет валидных координат.", "error", "exclamation-circle");
        return null;
    }

    let finalObjectType = objectType;
    const firstValidContour = processedContours[0];
    if (firstValidContour.length < 3 && objectType === 'polygon') {
        finalObjectType = firstValidContour.length === 2 ? 'line' : 'point';
    } else if (firstValidContour.length < 2 && objectType === 'line') {
        finalObjectType = 'point';
    }
    if ((finalObjectType === 'line' || finalObjectType === 'polygon') && firstValidContour.length === 1) {
        finalObjectType = 'point';
    }

    const newId = nextObjectId++;
    let newColor;
    if (specificColor) {
        newColor = specificColor;
    } else {
        newColor = objectColors[nextColorIndex % objectColors.length];
        nextColorIndex++;
    }

    const newObject = {
        id: newId,
        name,
        type: finalObjectType,
        subType: subType,
        contours: processedContours,
        color: newColor,
        area: 0,
        perimeter: 0,
        visible: true
    };

    updateObjectMetrics(newObject);
    userObjects.push(newObject);
    const newIndex = userObjects.length - 1;

    if (!isMultiPart) {
        updateObjectList();
        selectedObjectIndex = newIndex;
        calculateBounds();
        displayObjectInfo(selectedObjectIndex);
        setTimeout(() => { centerOnObject(newIndex, true); }, 50);
        checkTotalPointsAndHide();
        saveState();
        redraw(true);
    }
    return newObject;
}

async function deleteObject(index) {
    if (index < 0 || index >= userObjects.length || !userObjects[index]) return;
    const obj = userObjects[index];
    const objectName = obj.name || `Объект ${obj.id}`;

    const confirmed = await showCustomConfirm("Удаление объекта", `Вы уверены, что хотите удалить "${objectName}"?`);

    if (confirmed) {
        if (isGeometryEditMode && editingObjectIndex === index) {
            deactivateGeometryEditMode(false);
        }
        userObjects.splice(index, 1);
        const wasSelected = (selectedObjectIndex === index);

        if (wasSelected) { selectedObjectIndex = -1; displayObjectInfo(-1); }
        else if (selectedObjectIndex > index) { selectedObjectIndex--; }

        if (editingObjectIndex > index) editingObjectIndex--;
        else if (editingObjectIndex === index) editingObjectIndex = -1;

        showNotification(`"${objectName}" удален`, "info", "trash-alt");
        updateObjectList();
        calculateBounds();
        if (!hasValidView()) {
            resetView();
            redraw(false);
        } else {
            redraw(true);
        }
        saveState();
    }
}

async function renameObject(index, newName) {
    if (index < 0 || index >= userObjects.length || !userObjects[index] || !newName || !newName.trim()) {
        showNotification("Имя объекта не может быть пустым.", "warning", "exclamation-triangle");
        return;
    }
    const finalName = newName.trim();
    userObjects[index].name = finalName;
    displayObjectInfo(index);
    updateObjectList();
    redraw(true);
    showNotification(`Объект переименован в "${finalName}"`, "success", "pencil-alt");
    saveState();
}

function openCoordsDialog() {
    if (isDrawingMode || isMovingPoint || isGeometryEditMode) {
        showNotification("Завершите текущее действие перед импортом.", "warning", "pause-circle");
        return;
    }
    coordsInput.value = '';
    coordsDialog.style.display = 'block';
    dialogOverlay.style.display = 'block';
    dialogOverlay.classList.add('show');
    coordsDialog.classList.add('show');
    coordsInput.focus();
}

function closeCoordsDialog() {
    dialogOverlay.classList.remove('show');
    coordsDialog.classList.remove('show');
    coordsDialog.style.display = 'none';
    dialogOverlay.style.display = 'none';
}

async function promptAndAddObjectInternal(contoursData, objectType, defaultName) {
    const name = await showNamePrompt(`Имя нового объекта (${defaultName}):`, defaultName || `Объект ${nextObjectId}`);
    if (name !== null) {
        const contoursArray = Array.isArray(contoursData[0]) ? contoursData : [contoursData];
        return addObjectInternal(contoursArray, name, objectType, true);
    } else {
        showNotification(`Добавление "${defaultName || 'объекта'}" отменено.`, 'warning', 'times-circle');
        return null;
    }
}

function populateImportModeSelect() {
    const select = document.getElementById('importModeSelect');
    if (!select) return;

    select.innerHTML = '<option value="xml">Из архива КПТ (XML файл)</option>';
    if (typeof COORDINATE_SYSTEMS !== 'undefined') {
        const mskSystems = COORDINATE_SYSTEMS.filter(sys => sys.value.startsWith('EPSG:') && sys.value !== 'EPSG:4326' && sys.value !== 'EPSG:3857');
        mskSystems.forEach(sys => {
            const option = document.createElement('option');
            option.value = sys.value;
            option.textContent = `EPSG3857 -> ${sys.text}`;
            select.appendChild(option);
        });
    }

    const savedMode = localStorage.getItem('selectedImportMode');
    if (savedMode) {
        if (select.querySelector(`option[value="${savedMode}"]`)) {
            select.value = savedMode;
        }
    }
}

async function handleImportFromNspdAndConvertToMsk(cadNumbers, destScId) {
    closeCoordsDialog();
    if (cadNumbers.length > 100) {
        showNotification("Превышен лимит в 100 кадастровых номеров.", "error");
        return;
    }

    const destSystem = COORDINATE_SYSTEMS.find(s => s.value === destScId);
    if (!destSystem || !destSystem.def) {
        showNotification(`Не найдено определение для целевой СК: ${destScId}`, "error");
        return;
    }

    proj4.defs(destSystem.value, destSystem.def);
    if (typeof proj4.defs['EPSG:3857'] === 'undefined') {
        proj4.defs("EPSG:3857", COORDINATE_SYSTEMS.find(s => s.value === "EPSG:3857").def);
    }
    if (typeof proj4.defs['EPSG:4326'] === 'undefined') {
        proj4.defs("EPSG:4326", COORDINATE_SYSTEMS.find(s => s.value === "EPSG:4326").def);
    }

    let addedObjects = [];
    let errors = 0;
    isNspdLoadCancelled = false;
    showLoader(true, `Подготовка к загрузке ${cadNumbers.length} участков...`);

    for (let i = 0; i < cadNumbers.length; i++) {
        if (isNspdLoadCancelled) break;

        const kn = cadNumbers[i];
        showLoader(true, `Загрузка ${i + 1}/${cadNumbers.length}: ${kn}`);

        try {
            const feature = await fetchCadastralData(kn);
            if (!feature.geometry || !feature.geometry.coordinates) {
                throw new Error('У объекта нет координат в ЕГРН.');
            }

            const categoryId = feature.properties.category;
            let subType = null;
            if (categoryId === 36368) subType = 'land_record';
            else if (categoryId === 36369) subType = 'build_record';
            else if (categoryId === 36383) subType = 'construction_record';

            const geometryType = feature.geometry.type;
            const polygonsData = geometryType === 'MultiPolygon' ? feature.geometry.coordinates : [feature.geometry.coordinates];

            const objectMskContours = [];
            polygonsData.forEach(polygonRings => {
                polygonRings.forEach(ring => {
                    const mskPoints = ring.map(coord_3857 => {
                        const wgs84 = proj4('EPSG:3857', 'EPSG:4326', coord_3857);
                        const msk = proj4('EPSG:4326', destSystem.value, wgs84);
                        const finalX = msk[1] + (destSystem.offsetX || 0);
                        const finalY = msk[0] + (destSystem.offsetY || 0);
                        return { x: roundCoord(finalX), y: roundCoord(finalY) };
                    });
                    objectMskContours.push(mskPoints);
                });
            });

            if (objectMskContours.length > 0) {
                const newObj = addObjectInternal(objectMskContours, kn, "polygon", true, subType);
                if (newObj) addedObjects.push(newObj);
            } else {
                throw new Error('Не удалось извлечь контуры.');
            }
        } catch (error) {
            showNotification(`Ошибка для ${kn}: ${error.message}`, "error");
            errors++;
        }

        if (i < cadNumbers.length - 1) {
            await new Promise(resolve => setTimeout(resolve, 500));
        }
    }

    showLoader(false);
    if (addedObjects.length > 0) {
        finalizeBatchAdd(addedObjects);
        showNotification(`Загружено ${addedObjects.length} участков. ${errors > 0 ? errors + ' с ошибками.' : ''}`, "success", "check-circle");
    } else if (errors > 0 && !isNspdLoadCancelled) {
        showNotification(`Не удалось загрузить участки. Ошибок: ${errors}.`, "error", "exclamation-triangle");
    }
}

function isQuarterFormat(text) {
    if (!text) return false;
    const quarterRegex = /^\d{2}:\d{2}:(\d{6}|\d{7})$/;
    return quarterRegex.test(text.trim());
}

function showQuarterLoadOptionsDialog(quarterNumber) {
    const dialog = document.getElementById('quarterLoadOptionsDialog');
    const overlay = document.getElementById('dialogOverlay');
    const title = document.getElementById('quarterLoadOptionsTitle');
    const adjacentBtn = dialog.querySelector('button[data-load-type="adjacent"]');

    title.textContent = `Загрузка квартала ${quarterNumber}`;

    if (userObjects.length === 0) {
        adjacentBtn.disabled = true;
        adjacentBtn.style.opacity = '0.5';
        adjacentBtn.title = 'Эта опция доступна, когда на карте уже есть объекты';
    } else {
        adjacentBtn.disabled = false;
        adjacentBtn.style.opacity = '1';
        adjacentBtn.title = '';
    }

    const newButtons = document.getElementById('quarterLoadOptionsButtons').cloneNode(true);
    document.getElementById('quarterLoadOptionsButtons').parentNode.replaceChild(newButtons, document.getElementById('quarterLoadOptionsButtons'));

    newButtons.querySelectorAll('button').forEach(button => {
        button.onclick = () => processQuarterLoad(quarterNumber, button.dataset.loadType);
    });

    document.getElementById('quarterLoadOptionsCancelBtn').onclick = closeQuarterLoadOptionsDialog;
    overlay.onclick = closeQuarterLoadOptionsDialog;
    dialog.style.display = 'block';
    overlay.classList.add('show');
}

function closeQuarterLoadOptionsDialog() {
    document.getElementById('quarterLoadOptionsDialog').style.display = 'none';
    document.getElementById('dialogOverlay').classList.remove('show');
}

function getObjectBoundingBox(obj) {
    let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
    if (!obj.contours) return null;
    obj.contours.forEach(c => {
        if (!c) return;
        c.forEach(p => {
            if (p && isFinite(p.x) && isFinite(p.y)) {
                minX = Math.min(minX, p.x);
                minY = Math.min(minY, p.y);
                maxX = Math.max(maxX, p.x);
                maxY = Math.max(maxY, p.y);
            }
        });
    });
    if (minX === Infinity) return null;
    return { minX, minY, maxX, maxY };
}

function calculateAdjacentIndices(targetIndex) {
    const indices = new Set();
    if (targetIndex < 0 || targetIndex >= userObjects.length) return indices;

    indices.add(targetIndex);
    const targetObj = userObjects[targetIndex];
    const targetBBox = getObjectBoundingBox(targetObj);
    if (!targetBBox) return indices;

    const buffer = 1.5;
    const expandedTargetBBox = {
        minX: targetBBox.minX - buffer,
        minY: targetBBox.minY - buffer,
        maxX: targetBBox.maxX + buffer,
        maxY: targetBBox.maxY + buffer
    };

    const thresholdSq = 1.0 * 1.0;
    const segsTarget = getAllSegments(targetObj);

    userObjects.forEach((otherObj, idx) => {
        if (idx === targetIndex) return;
        if (!otherObj.contours) return;

        const otherBBox = getObjectBoundingBox(otherObj);
        if (!otherBBox) return;

        if (otherBBox.maxX < expandedTargetBBox.minX || otherBBox.minX > expandedTargetBBox.maxX ||
            otherBBox.maxY < expandedTargetBBox.minY || otherBBox.minY > expandedTargetBBox.maxY) {
            return;
        }

        let isAdjacent = false;
        const segsOther = getAllSegments(otherObj);

        for (const s1 of segsTarget) {
            for (const s2 of segsOther) {
                if (getSegmentIntersection(s1.p1, s1.p2, s2.p1, s2.p2)) {
                    isAdjacent = true;
                    break;
                }
            }
            if (isAdjacent) break;
        }

        if (!isAdjacent) {
            for (const contour of otherObj.contours) {
                if (!contour) continue;
                for (const pt of contour) {
                    for (const seg of segsTarget) {
                        const distSq = pointLineDistSq(pt.x, pt.y, seg.p1.x, seg.p1.y, seg.p2.x, seg.p2.y);
                        if (distSq <= thresholdSq) {
                            isAdjacent = true;
                            break;
                        }
                    }
                    if (isAdjacent) break;
                }
                if (isAdjacent) break;
            }
        }

        if (!isAdjacent) {
            for (const contour of targetObj.contours) {
                if (!contour) continue;
                for (const pt of contour) {
                    for (const seg of segsOther) {
                        const distSq = pointLineDistSq(pt.x, pt.y, seg.p1.x, seg.p1.y, seg.p2.x, seg.p2.y);
                        if (distSq <= thresholdSq) {
                            isAdjacent = true;
                            break;
                        }
                    }
                    if (isAdjacent) break;
                }
                if (isAdjacent) break;
            }
        }

        if (isAdjacent) {
            indices.add(idx);
        }
    });

    return indices;
}

function toggleAdjacentPointsMode() {
    if (adjacentPointsMode) {
        adjacentPointsMode = false;
        adjacentObjectIndices.clear();
        showNotification("Режим смежных точек выключен.", "info");
    } else {
        if (selectedObjectIndex === -1) {
            showNotification("Выберите объект для отображения смежных точек.", "warning", "hand-pointer");
            return;
        }

        showLoader(true, "Поиск смежных объектов (1м)...");

        setTimeout(() => {
            adjacentObjectIndices = calculateAdjacentIndices(selectedObjectIndex);
            adjacentPointsMode = true;
            showPoints = false;
            showLoader(false);
            showNotification(`Показаны точки для ${adjacentObjectIndices.size} объектов.`, "success", "dot-circle");
            updateToggleButtonStates();
            redraw(true);
        }, 50);
        return;
    }

    updateToggleButtonStates();
    redraw(true);
}

async function handleUniversalImport() {
    const inputText = coordsInput.value.trim();
    if (!inputText) {
        showNotification("Поле ввода пустое.", "warning", "exclamation-triangle");
        return;
    }

    const useFixedColor = document.getElementById('useFixedColor').checked;
    const fixedColor = useFixedColor ? document.getElementById('importColorInput').value : null;

    const lines = inputText.split('\n').map(line => line.trim()).filter(line => line);

    const firstIsKn = isValidCadastralNumberFormat(lines[0]);
    const secondIsKn = lines.length > 1 && isValidCadastralNumberFormat(lines[1]);
    const isKnList = firstIsKn && (lines.length === 1 || secondIsKn);

    const isSingleQuarter = lines.length === 1 && isQuarterFormat(lines[0]);

    if (isSingleQuarter) {
        closeCoordsDialog();
        showQuarterLoadOptionsDialog(lines[0]);
        return;
    }

    if (isKnList) {
        const importMode = document.getElementById('importModeSelect').value;
        if (importMode === 'xml') {
            await handleImportFromCadNumbers(lines);
        } else {
            if (lines.length > 20) {
                const confirmed = await showCustomConfirm("Большой список", `В списке ${lines.length} объектов. Это может занять время. Продолжить?`);
                if (!confirmed) return;
            }
            await handleImportFromNspdAndConvertToMsk(lines, importMode);
        }
        return;
    }

    const objectsToAdd = parseTextToObjects(inputText, fixedColor);

    if (objectsToAdd.length > 0) {
        closeCoordsDialog();
        let addedBatch = [];

        objectsToAdd.forEach(objData => {
            const realName = objData.name.replace(nextObjectIdPlaceholder, nextObjectId);
            const newObj = addObjectInternal(objData.contours, realName, objData.type, true, null, objData.color);
            if (newObj) addedBatch.push(newObj);
        });

        if (addedBatch.length > 0) {
            finalizeBatchAdd(addedBatch);
            showNotification(`Добавлено ${addedBatch.length} объектов.`, "success");
        }
    } else {
        showNotification("Не удалось распознать данные.", "error");
    }
}

async function processQuarterLoad(quarterNumber, filterType) {
    closeQuarterLoadOptionsDialog();
    const importMode = document.getElementById('importModeSelect').value;

    if (importMode === 'xml') {
        showLoader(true, `Загрузка данных КПТ для квартала ${quarterNumber}...`);
        try {
            const xmlContent = await fetchKptXmlContent(quarterNumber);
            if (!xmlContent) {
                showLoader(false);
                return;
            }

            showLoader(true, `Обработка XML, фильтр: ${filterType}...`);
            await new Promise(resolve => setTimeout(resolve, 50));

            const objectsToAdd = extractObjectsFromXml(xmlContent, filterType);

            if (objectsToAdd.length === 0) {
                showNotification(`В файле КПТ для квартала ${quarterNumber} не найдено объектов.`, "info");
                showLoader(false);
                return;
            }

            let addedObjectsBatch = [];
            objectsToAdd.forEach(objData => {
                const isPolygon = objData.contours.some(c => c.length >= 3);
                const objectType = isPolygon ? 'polygon' : (objData.contours.some(c => c.length >= 2) ? 'line' : 'point');
                const newObj = addObjectInternal(objData.contours, objData.name, objectType, true);
                if (newObj) addedObjectsBatch.push(newObj);
            });

            if (addedObjectsBatch.length > 0) {
                finalizeBatchAdd(addedObjectsBatch);
                showNotification(`Загружено ${addedObjectsBatch.length} объектов из файла КПТ.`, "success");
            }
        } catch (error) {
            showNotification(`Ошибка загрузки из КПТ: ${error.message}`, "error");
        } finally {
            showLoader(false);
        }
    } else {
        if (filterType === 'adjacent') {
            showNotification(`Загрузка смежных объектов не поддерживается.`, "warning");
            return;
        }
        await handleImportQuarterFromNspdAndConvertToMsk(quarterNumber, filterType, importMode);
    }
}

async function handleImportQuarterFromNspdAndConvertToMsk(quarterNumber, filterType, destScId) {
    isNspdLoadCancelled = false;
    showLoader(true, `Загрузка данных для квартала ${quarterNumber}...`);

    try {
        const destSystem = COORDINATE_SYSTEMS.find(s => s.value === destScId);
        if (!destSystem || !destSystem.def) {
            throw new Error(`Не найдено определение для целевой СК: ${destScId}`);
        }
        proj4.defs(destSystem.value, destSystem.def);
        if (typeof proj4.defs['EPSG:3857'] === 'undefined') {
            proj4.defs("EPSG:3857", COORDINATE_SYSTEMS.find(s => s.value === "EPSG:3857").def);
        }
        if (typeof proj4.defs['EPSG:4326'] === 'undefined') {
            proj4.defs("EPSG:4326", COORDINATE_SYSTEMS.find(s => s.value === "EPSG:4326").def);
        }

        showLoader(true, `Запрос геометрии квартала ${quarterNumber}...`);
        if (isNspdLoadCancelled) return;

        const quarterGeomUrl = `https://nspd.gov.ru/api/geoportal/v2/search/geoportal?thematicSearchId=2&query=${quarterNumber}`;
        const quarterGeomData = await fetchNspd(quarterGeomUrl);
        const quarterFeature = quarterGeomData?.data?.features?.[0];
        if (!quarterFeature || !quarterFeature.geometry) {
            throw new Error(`Не найдена геометрия для квартала ${quarterNumber}`);
        }

        const categories = [];
        if (filterType === 'zu' || filterType === 'all') categories.push({ "id": 36368, "name": "land_record" });
        if (filterType === 'oks' || filterType === 'all') categories.push({ "id": 36369, "name": "build_record" });
        if (filterType === 'construction' || filterType === 'all') categories.push({ "id": 36383, "name": "construction_record" });

        if (categories.length === 0) {
            throw new Error(`Неизвестный тип фильтра: ${filterType}`);
        }

        showLoader(true, `Загрузка объектов (${filterType}) в квартале...`);
        if (isNspdLoadCancelled) return;

        const requestBody = {
            "geom": { "type": "FeatureCollection", "features": [{ "type": "Feature", "geometry": quarterFeature.geometry, "properties": {} }] },
            "categories": categories.map(c => ({ "id": c.id }))
        };
        const intersectsUrl = 'https://nspd.gov.ru/api/geoportal/v1/intersects?typeIntersect=fullObject';

        const intersectsResponse = await fetch(intersectsUrl, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json', 'Referer': 'https://nspd.gov.ru/' },
            body: JSON.stringify(requestBody)
        });
        if (!intersectsResponse.ok) throw new Error(`Ошибка при запросе объектов: ${intersectsResponse.statusText}`);
        const objectsData = await intersectsResponse.json();

        const featuresToConvert = objectsData.features || [];
        if (featuresToConvert.length === 0) {
            showNotification(`В квартале не найдено объектов типа '${filterType}'`, "info");
            return;
        }

        showLoader(true, `Конвертация ${featuresToConvert.length} объектов...`);
        let addedObjectsBatch = [];
        let errors = 0;

        for (const feature of featuresToConvert) {
            if (isNspdLoadCancelled) break;

            try {
                const cadNumber = feature.properties.descr || feature.properties.options?.cad_num || `Объект без КН`;
                if (!feature.geometry || !feature.geometry.coordinates) continue;

                const categoryId = feature.properties.category;
                const categoryInfo = categories.find(c => c.id === categoryId);
                const subType = categoryInfo ? categoryInfo.name : null;

                const geometryType = feature.geometry.type;
                const coordinatesArray = feature.geometry.coordinates;

                let rings = [];
                if (geometryType === "Polygon") {
                    rings = coordinatesArray;
                } else if (geometryType === "MultiPolygon") {
                    rings = coordinatesArray.flat(1);
                } else {
                    continue;
                }

                const objectMskContours = [];
                rings.forEach(ring => {
                    if (!ring || ring.length === 0) return;
                    const mskPoints = ring.map(coord_3857 => {
                        const wgs84 = proj4('EPSG:3857', 'EPSG:4326', coord_3857);
                        const msk = proj4('EPSG:4326', destSystem.value, wgs84);
                        const finalX = msk[1] + (destSystem.offsetX || 0);
                        const finalY = msk[0] + (destSystem.offsetY || 0);
                        return { x: roundCoord(finalX), y: roundCoord(finalY) };
                    });
                    if (mskPoints.length > 0) objectMskContours.push(mskPoints);
                });

                if (objectMskContours.length > 0) {
                    const newObj = addObjectInternal(objectMskContours, cadNumber, "polygon", true, subType);
                    if (newObj) addedObjectsBatch.push(newObj);
                } else {
                    errors++;
                }
            } catch (convertError) {
                errors++;
            }
        }

        if (addedObjectsBatch.length > 0) {
            finalizeBatchAdd(addedObjectsBatch);
            showNotification(`Загружено ${addedObjectsBatch.length} объектов ${errors > 0 ? errors + ' с ошибками.' : ''}`, "success");
        } else if (errors > 0 && !isNspdLoadCancelled) {
            showNotification(`Не удалось загрузить объекты. Ошибок: ${errors}.`, "error");
        }
    } catch (error) {
        if (!isNspdLoadCancelled) {
            showNotification(`Ошибка загрузки: ${error.message}`, "error");
        }
    } finally {
        if (!isNspdLoadCancelled) {
            showLoader(false);
        }
    }
}

async function handleFindCoordinates() {
    const inputText = coordsInput.value.trim();
    if (!inputText) {
        showNotification("Поле ввода пустое.", "warning", "exclamation-triangle");
        return;
    }

    const parsedContours = parseCoordinatesFromText(inputText);

    if (parsedContours && parsedContours.length > 0) {
        closeCoordsDialog();

        const allPoints = [];
        parsedContours.forEach(contour => {
            contour.forEach(p => allPoints.push(p));
        });

        if (allPoints.length === 0) return;

        showLoader(true, `Создание ${allPoints.length} точек...`);

        const addedBatch = [];
        let counter = 1;

        await new Promise(resolve => setTimeout(resolve, 50));

        allPoints.forEach(pt => {
            const singlePointContour = [[{ x: pt.x, y: pt.y }]];
            const name = `Тчк ${counter++}`;
            const newObj = addObjectInternal(singlePointContour, name, 'point', true, 'crosshair');
            if (newObj) addedBatch.push(newObj);
        });

        if (addedBatch.length > 0) {
            finalizeBatchAdd(addedBatch);
            showNotification(`Добавлено ${addedBatch.length} точек поиска.`, "success", "crosshairs");
        }

        showLoader(false);
    } else {
        showNotification("Не удалось распознать координаты.", "error");
    }
}

function extractObjectsFromXml(xmlContent, filterType) {
    const parser = new DOMParser();
    const xmlDoc = parser.parseFromString(xmlContent, "text/xml");
    const extracted = [];
    const TOLERANCE_DIGITS = 2;

    if (filterType === 'adjacent') {
        if (userObjects.length === 0) {
            showNotification("Для загрузки смежных объектов на карте должен быть хотя бы один объект.", "warning");
            return [];
        }

        const existingPoints = new Set();
        userObjects.forEach(obj => {
            if (!obj.contours) return;
            obj.contours.forEach(contour => {
                if (!contour) return;
                contour.forEach(p => {
                    if (p && isFinite(p.x) && isFinite(p.y)) {
                        existingPoints.add(`${p.x.toFixed(TOLERANCE_DIGITS)}_${p.y.toFixed(TOLERANCE_DIGITS)}`);
                    }
                });
            });
        });

        if (existingPoints.size === 0) return [];

        const allRecordsFromXml = xmlDoc.querySelectorAll('land_record, build_records build_record, construction_records construction_record');

        allRecordsFromXml.forEach(record => {
            const cadNumber = getElementValueFromNode(record, 'object > common_data > cad_number');
            if (!cadNumber) return;

            const contours = extractCoordinatesFromXMLNode(record);
            if (contours.length === 0) return;

            let isAdjacent = false;

            for (const newContour of contours) {
                if (!newContour) continue;
                for (const newPoint of newContour) {
                    const pointKey = `${newPoint.x.toFixed(TOLERANCE_DIGITS)}_${newPoint.y.toFixed(TOLERANCE_DIGITS)}`;
                    if (existingPoints.has(pointKey)) {
                        isAdjacent = true;
                        break;
                    }
                }
                if (isAdjacent) break;
            }

            if (isAdjacent) {
                extracted.push({ name: cadNumber, contours: contours });
            }
        });

        return extracted;
    } else {
        const processRecords = (records, objectCategory) => {
            if (filterType !== 'all' && filterType !== objectCategory) return;
            records.forEach(record => {
                const cadNumber = getElementValueFromNode(record, 'object > common_data > cad_number');
                if (!cadNumber) return;
                const contours = extractCoordinatesFromXMLNode(record);
                if (contours.length > 0) {
                    extracted.push({ name: cadNumber, contours: contours });
                }
            });
        };

        processRecords(xmlDoc.querySelectorAll('land_record'), 'zu');
        processRecords(xmlDoc.querySelectorAll('build_records build_record'), 'oks');
        processRecords(xmlDoc.querySelectorAll('construction_records construction_record'), 'construction');

        return extracted;
    }
}

async function fetchKptXmlContent(quarterNumber) {
    const serverQuarterPrefix = quarterNumber.replace(/:/g, '_');
    try {
        const responseList = await fetch(`${STORAGE_API_URL}/${BUCKET_NAME}?search=${serverQuarterPrefix}`);
        if (!responseList.ok) throw new Error(`Ошибка сети: ${responseList.statusText}`);

        const fileList = await responseList.json();
        if (!fileList || fileList.length === 0) throw new Error(`КПТ для квартала ${quarterNumber} не найдены.`);

        const matchingFiles = fileList.filter(f => f.name.startsWith(serverQuarterPrefix) && f.name.toLowerCase().endsWith('.zip'));
        if (matchingFiles.length === 0) throw new Error(`Архивы КПТ для квартала ${quarterNumber} не найдены.`);

        const latestFile = matchingFiles.sort((a, b) => b.name.localeCompare(a.name))[0];

        const responseDownload = await fetch(`${STORAGE_API_URL}/${BUCKET_NAME}/${latestFile.name}`);
        if (!responseDownload.ok) throw new Error(`Ошибка загрузки файла: ${responseDownload.statusText}`);

        const blob = await responseDownload.blob();
        const zip = await JSZip.loadAsync(blob);

        let xmlFileEntry = null;
        for (const fileNameInZip in zip.files) {
            if (fileNameInZip.toLowerCase().endsWith('.xml') && !zip.files[fileNameInZip].dir) {
                xmlFileEntry = zip.files[fileNameInZip];
                break;
            }
        }
        if (!xmlFileEntry) throw new Error("XML-файл не найден в архиве.");

        return await xmlFileEntry.async('string');
    } catch (error) {
        throw new Error(error.message);
    }
}

function consolidateContoursIntoObjects(contours) {
    let items = contours.map(c => ({
        contour: c,
        area: calculatePolygonArea(c),
        holes: []
    }));

    items.sort((a, b) => b.area - a.area);

    const roots = [];

    items.forEach(item => {
        let bestParent = null;

        for (const r of roots) {
            if (isPointInPolygon(item.contour[0], r.contour)) {
                if (!bestParent || r.area < bestParent.area) {
                    bestParent = r;
                }
            }
        }

        if (bestParent) {
            bestParent.holes.push(item.contour);
        } else {
            roots.push(item);
        }
    });

    return roots.map(r => [r.contour, ...r.holes]);
}

async function handleImportFromTextareaCoordinates(text, color = null) {
    const parsedContours = parseCoordinatesFromText(text);
    if (parsedContours && parsedContours.length > 0) {
        closeCoordsDialog();

        const groupedContours = consolidateContoursIntoObjects(parsedContours);

        let addedObjects = [];
        for (let i = 0; i < groupedContours.length; i++) {
            const objectContours = groupedContours[i];

            if (objectContours && objectContours.length > 0) {
                const mainContour = objectContours[0];
                const isClosed = mainContour.length >= 3 &&
                    Math.abs(mainContour[0].x - mainContour[mainContour.length - 1].x) < 0.001 &&
                    Math.abs(mainContour[0].y - mainContour[mainContour.length - 1].y) < 0.001;

                let objectType = isClosed ? 'polygon' : (mainContour.length >= 2 ? 'line' : 'point');

                const nameBase = groupedContours.length > 1 ? `Участок ${nextObjectId} (${i + 1})` : `Участок ${nextObjectId}`;

                const newObj = addObjectInternal(objectContours, nameBase, objectType, true, null, color);
                if (newObj) addedObjects.push(newObj);
            }
        }

        if (addedObjects.length > 0) {
            finalizeBatchAdd(addedObjects);
        }
    } else {
        showNotification("Не удалось распознать валидные координаты X Y.", "error", "exclamation-circle");
    }
}

async function handleImportFromFile() {
    const useFixedColor = document.getElementById('useFixedColor').checked;
    const fixedColor = useFixedColor ? document.getElementById('importColorInput').value : null;

    const fileInput = document.createElement('input');
    fileInput.type = 'file';
    fileInput.accept = '.txt,.csv';
    fileInput.onchange = async (e) => {
        const file = e.target.files[0];
        if (!file) return;
        const baseName = file.name.split('.').slice(0, -1).join('.') || `Файл ${nextObjectId}`;
        const reader = new FileReader();
        reader.onload = async (event) => {
            const content = event.target.result;
            const parsedContours = parseCoordinatesFromText(content);
            if (parsedContours && parsedContours.length > 0) {
                closeCoordsDialog();
                let addedObjects = [];
                for (let i = 0; i < parsedContours.length; i++) {
                    const contour = parsedContours[i];
                    if (contour && contour.length > 0) {
                        const isClosed = contour.length >= 3 &&
                            Math.abs(contour[0].x - contour[contour.length - 1].x) < 0.001 &&
                            Math.abs(contour[0].y - contour[contour.length - 1].y) < 0.001;
                        let objectType = isClosed ? 'polygon' : (contour.length >= 2 ? 'line' : 'point');

                        const autoName = `${baseName}${parsedContours.length > 1 ? '_' + (i + 1) : ''}`;

                        const newObj = addObjectInternal([contour], autoName, objectType, true, null, fixedColor);

                        if (newObj) addedObjects.push(newObj);
                    }
                }
                if (addedObjects.length > 0) {
                    finalizeBatchAdd(addedObjects);
                }
            } else {
                showNotification('Не удалось найти валидные координаты в файле.', 'error', 'exclamation-circle');
            }
        };
        reader.onerror = () => {
            showNotification('Ошибка чтения файла.', 'error', 'exclamation-circle');
        };
        reader.readAsText(file);
    };
    fileInput.click();
}

function parseCoordinatesFromText(text) {
    const lines = text.split('\n');
    const contours = [];
    let currentContour = [];
    lines.forEach(line => {
        line = line.trim().replace(/,/g, '.');
        if (line === '') {
            if (currentContour.length > 0) {
                contours.push(currentContour);
                currentContour = [];
            }
        } else {
            const parts = line.split(/[\s\t]+/);
            if (parts.length >= 2) {
                let x = parseFloat(parts[0]);
                let y = parseFloat(parts[1]);
                if (!isFinite(x) || !isFinite(y)) {
                    x = parseFloat(parts[1]);
                    y = parseFloat(parts[0]);
                }
                if (isFinite(x) && isFinite(y)) {
                    currentContour.push({ x: roundCoord(x), y: roundCoord(y) });
                }
            }
        }
    });
    if (currentContour.length > 0) {
        contours.push(currentContour);
    }
    return contours.filter(c => c.length > 0);
}

function showNamePrompt(title, initialValue = '') {
    return new Promise((resolve) => {
        namePromptTitle.textContent = title;
        namePromptInput.value = initialValue;
        namePromptDialog.classList.add('show');
        namePromptOverlay.classList.add('show');
        namePromptInput.focus();
        namePromptInput.select();
        let resolved = false;
        const cleanupAndResolve = (value) => {
            if (resolved) return;
            resolved = true;
            namePromptSaveBtn.onclick = null;
            namePromptCancelBtn.onclick = null;
            namePromptOverlay.onclick = null;
            namePromptInput.onkeydown = null;
            namePromptDialog.classList.remove('show');
            namePromptOverlay.classList.remove('show');
            resolve(value);
        };
        const handleSave = () => {
            const name = namePromptInput.value.trim();
            if (name) cleanupAndResolve(name);
            else {
                showNotification("Имя не может быть пустым.", "warning");
                namePromptInput.focus();
            }
        };
        const handleCancel = () => cleanupAndResolve(null);
        const handleKeydown = (e) => {
            if (e.key === 'Enter') {
                e.preventDefault();
                handleSave();
            } else if (e.key === 'Escape') handleCancel();
        };
        namePromptSaveBtn.onclick = handleSave;
        namePromptCancelBtn.onclick = handleCancel;
        namePromptOverlay.onclick = handleCancel;
        namePromptInput.onkeydown = handleKeydown;
    });
}

function calculatePolygonArea(polygon) {
    let area = 0;
    const n = polygon.length;
    if (n < 3) return 0;
    for (let i = 0; i < n; i++) {
        const p1 = polygon[i];
        const p2 = polygon[(i + 1) % n];
        if (!p1 || !p2 || !isFinite(p1.x) || !isFinite(p1.y) || !isFinite(p2.x) || !isFinite(p2.y)) return 0;
        area += (p1.x * p2.y - p2.x * p1.y);
    }
    return area / 2;
}

function calculatePolygonPerimeter(polygon, isClosed = true) {
    let length = 0;
    const n = polygon.length;
    if (n < 1) return 0;
    if (n === 1) return 0;
    for (let i = 0; i < n - 1; i++) {
        const p1 = polygon[i];
        const p2 = polygon[i + 1];
        if (!p1 || !p2 || !isFinite(p1.x) || !isFinite(p1.y) || !isFinite(p2.x) || !isFinite(p2.y)) return NaN;
        const dist = calculateDistance(p1, p2);
        if (isNaN(dist)) return NaN;
        length += dist;
    }
    if (isClosed && n >= 3) {
        const p1 = polygon[n - 1];
        const p2 = polygon[0];
        if (!p1 || !p2 || !isFinite(p1.x) || !isFinite(p1.y) || !isFinite(p2.x) || !isFinite(p2.y)) return NaN;
        const PRECISION_THRESHOLD = 0.001;
        if (Math.abs(p1.x - p2.x) > PRECISION_THRESHOLD || Math.abs(p1.y - p2.y) > PRECISION_THRESHOLD) {
            const dist = calculateDistance(p1, p2);
            if (isNaN(dist)) return NaN;
            length += dist;
        }
    }
    return roundCoord(length);
}

function checkIntersection(poly1, poly2) {
    if (!poly1 || poly1.length < 3 || !poly2 || poly2.length < 3) return { intersects: false, contains: false, containedBy: false, sharedVertices: 0 };
    let min1x = Infinity, min1y = Infinity, max1x = -Infinity, max1y = -Infinity, v1 = false;
    let min2x = Infinity, min2y = Infinity, max2x = -Infinity, max2y = -Infinity, v2 = false;
    poly1.forEach(p => { if (p && isFinite(p.x) && isFinite(p.y)) { min1x = Math.min(min1x, p.x); min1y = Math.min(min1y, p.y); max1x = Math.max(max1x, p.x); max1y = Math.max(max1y, p.y); v1 = true; } });
    poly2.forEach(p => { if (p && isFinite(p.x) && isFinite(p.y)) { min2x = Math.min(min2x, p.x); min2y = Math.min(min2y, p.y); max2x = Math.max(max2x, p.x); max2y = Math.max(max2y, p.y); v2 = true; } });
    if (!v1 || !v2) return { intersects: false, contains: false, containedBy: false, sharedVertices: 0 };
    const sharedVertices = countSharedVertices(poly1, poly2);
    if (max1x < min2x || max2x < min1x || max1y < min2y || max2y < min1y) {
        return { intersects: sharedVertices > 0, contains: false, containedBy: false, sharedVertices };
    }
    let intersects = false;
    for (const p1 of poly1) { if (p1 && isFinite(p1.x) && isFinite(p1.y) && isPointInPolygon(p1, poly2)) { intersects = true; break; } }
    if (!intersects) { for (const p2 of poly2) { if (p2 && isFinite(p2.x) && isFinite(p2.y) && isPointInPolygon(p2, poly1)) { intersects = true; break; } } }
    let contains = false, containedBy = false;
    if (intersects || !(max1x < min2x || max2x < min1x || max1y < min2y || max2y < min1y)) {
        contains = poly2.every(p => (p && isFinite(p.x) && isFinite(p.y)) ? isPointInPolygon(p, poly1) : true);
        containedBy = poly1.every(p => (p && isFinite(p.x) && isFinite(p.y)) ? isPointInPolygon(p, poly2) : true);
    }
    if (contains && containedBy) { contains = false; containedBy = false; intersects = true; }
    if (containedBy || contains) { intersects = true; }
    return { intersects, contains, containedBy, sharedVertices };
}

function isPointInPolygon(point, polygon) {
    if (!polygon || polygon.length < 3 || !point || !isFinite(point.x) || !isFinite(point.y)) return false;
    let inside = false;
    const ptX = point.x;
    const ptY = point.y;
    for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
        const pi = polygon[i], pj = polygon[j];
        if (!pi || !pj || !isFinite(pi.x) || !isFinite(pi.y) || !isFinite(pj.x) || !isFinite(pj.y)) continue;
        const xi = pi.x, yi = pi.y;
        const xj = pj.x, yj = pj.y;
        if ((xi === ptX && yi === ptY) || (xj === ptX && yj === ptY)) return true;
        const onHorizontal = (Math.abs(yi - ptY) < 1e-9 && Math.abs(yj - ptY) < 1e-9) && (ptX >= Math.min(xi, xj) - 1e-9 && ptX <= Math.max(xi, xj) + 1e-9);
        const onVertical = (Math.abs(xi - ptX) < 1e-9 && Math.abs(xj - ptX) < 1e-9) && (ptY >= Math.min(yi, yj) - 1e-9 && ptY <= Math.max(yi, yj) + 1e-9);
        if (onHorizontal || onVertical) return true;
        const intersect = ((yi > ptY) !== (yj > ptY)) && (ptX < (xj - xi) * (ptY - yi) / (yj - yi) + xi);
        if (intersect) inside = !inside;
    }
    return inside;
}

function getContourCentroid(contour) {
    if (!contour || contour.length === 0) return { x: NaN, y: NaN };
    let sumX = 0, sumY = 0;
    let validPoints = 0;
    contour.forEach(p => { if (p && isFinite(p.x) && isFinite(p.y)) { sumX += p.x; sumY += p.y; validPoints++; } });
    if (validPoints === 0) return { x: NaN, y: NaN };
    return { x: roundCoord(sumX / validPoints), y: roundCoord(sumY / validPoints) };
}

const transformCoord = (dataX, dataY) => {
    const cH = canvas.height || 0;
    const cX = offsetX + (dataY - cMinYGlob()) * scale;
    const cY = cH - (offsetY + (dataX - cMinXGlob()) * scale);
    return [cX, cY];
};

const inverseTransformCoord = (canvasX, canvasY) => {
    const cH = canvas.height || 0;
    if (Math.abs(scale) < 1e-9) return { x: NaN, y: NaN };
    const dX_raw = cMinXGlob() + (cH - canvasY - offsetY) / scale;
    const dY_raw = cMinYGlob() + (canvasX - offsetX) / scale;
    return { x: roundCoord(dX_raw), y: roundCoord(dY_raw) };
};

function redraw(preserveTransform = false) {
    if (canvas.width !== canvas.offsetWidth || canvas.height !== canvas.offsetHeight) {
        canvas.width = canvas.offsetWidth;
        canvas.height = canvas.offsetHeight;
        if (!preserveTransform) {
            calculateBounds();
            if (!hasValidView()) resetView();
        }
    }
    ctx.setTransform(1, 0, 0, 1, 0, 0);
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.fillStyle = 'white';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    if (userObjects.length === 0 && !rulerMode && !isDrawingActive && !isGeometryEditMode) {
        ctx.fillStyle = "#777";
        ctx.font = "16px Arial";
        ctx.textAlign = "center";
        ctx.fillText("Добавьте объекты (+), нарисуйте (✎) или измерьте (📏)", canvas.width / 2, canvas.height / 2);
    }
    if (!preserveTransform) calculateBounds();
    if (!hasValidView()) {
        ctx.fillStyle = "red";
        ctx.font = "bold 18px Arial";
        ctx.textAlign = "center";
        ctx.fillText("Ошибка отображения", canvas.width / 2, canvas.height / 2);
        return;
    }

    const gridStep = determineGridStep();
    drawGrid(ctx, gridStep);
    drawObjects(ctx);
    drawActiveDrawingPreview(ctx);
    drawRuler(ctx);
    drawSelectedCoordinateMarker(ctx);
    drawSnapHighlight(ctx);

    if (showLabels) {
        drawCoordinateLabels(ctx);
    }

    updateGridInfo(gridStep);
    updateViewInfo();
}






