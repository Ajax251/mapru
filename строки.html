


<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cтроки</title>
<link rel="icon" href="https://img.icons8.com/?size=100&id=zWCWezaAmqit&format=png&color=000000" type="image/png">

 
<style>
:root { --bg-color: #ffffff; --text-color: #000000; --element-bg: #f0f0f0; --element-shadow: #d9d9d9; --element-highlight: #ffffff; --border-color: #c0c0c0; --placeholder-color: #000000; /* Добавлено для placeholder */ }
body, html { height: 100%; margin: 0; padding: 0; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; background: var(--bg-color); color: var(--text-color); transition: all 0.3s ease; }
.container { display: flex; flex-direction: column; height: 100%; padding: 20px; box-sizing: border-box; }
.text-fields { display: flex; flex: 1; margin-bottom: 20px; min-height: 300px; }
.text-field-container { position: relative; flex: 1; margin-right: 10px; display: flex; }
.text-field-container:last-child { margin-right: 0; }
textarea { flex: 1; width: 100%; resize: none; border: 1px solid var(--border-color); background: var(--element-bg); box-shadow: 3px 3px 6px var(--element-shadow), -3px -3px 6px var(--element-highlight); border-radius: 10px; padding: 15px; font-size: 16px; transition: all 0.3s ease; color: var(--text-color); }
textarea::placeholder { color: var(--placeholder-color); /* Добавлено для placeholder */ }
textarea:focus, select:focus, input[type="text"]:focus { outline: none; border-color: #4CAF50; box-shadow: 0 0 0 2px rgba(76, 175, 80, 0.2), inset 2px 2px 5px var(--element-shadow), inset -2px -2px 5px var(--element-highlight); }
#workPanel { background: var(--element-bg); border-radius: 15px; padding: 20px; box-shadow: 5px 5px 10px var(--element-shadow), -5px -5px 10px var(--element-highlight); border: 1px solid var(--border-color); }
.control-row { display: flex; align-items: center; justify-content: space-between; margin-bottom: 10px; }
select, input[type="text"], button { border: 1px solid var(--border-color); background: var(--element-bg); box-shadow: 3px 3px 6px var(--element-shadow), -3px -3px 6px var(--element-highlight); border-radius: 10px; padding: 12px 15px; font-size: 16px; transition: all 0.3s ease; color: var(--text-color); }
select::placeholder { color: var(--placeholder-color); /* Добавлено для placeholder */ }
input[type="text"]::placeholder { color: var(--placeholder-color); /* Добавлено для placeholder */ }
select { flex-grow: 1; margin-right: 10px; appearance: none; background-image: url("data:image/svg+xml; charset=US-ASCII,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%22292.4%22%20height%3D%22292.4%22%3E%3Cpath%20fill%3D%22%23007CB2%22%20d%3D%22M287%2069.4a17.6%2017.6%200%200%200-13-5.4H18.4c-5%200-9.3%201.8-12.9%205.4A17.6%2017.6%200%200%200%200%2082.2c0%205%201.8%209.3%205.4%2012.9l128%20127.9c3.6%203.6%207.8%205.4%2012.8%205.4s9.2-1.8%2012.8-5.4L287%2095c3.5-3.5%205.4-7.8%205.4-12.8%200-5-1.9-9.2-5.5-12.8z%22%2F%3E%3C%2Fsvg%3E"); background-repeat: no-repeat; background-position: right 10px top 50%; background-size: 12px auto; }
button { background: linear-gradient(145deg, var(--element-bg), var(--element-shadow)); color: var(--text-color); cursor: pointer; transition: all 0.3s ease; display: flex; align-items: center; justify-content: center; min-width: 120px; }
button:hover { background: linear-gradient(145deg, var(--element-shadow), var(--element-bg)); transform: translateY(-2px); box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1); }
button:active { transform: translateY(1px); box-shadow: inset 2px 2px 5px var(--element-shadow), inset -2px -2px 5px var(--element-highlight); }
.edit-row { display: flex; align-items: center; margin-top: 10px; margin-bottom: 10px; width: 100%; gap: 10px; /* добавляем отступ между полями */ }
.edit-row > div { flex: 1; width: 100%; /* добавлено */ }
.edit-row input[type="text"] { width: 99%; /* растягиваем на всю ширину родителя */ min-width: 0; /* позволяет сжиматься внутри flex-контейнера */ box-sizing: border-box; /* включаем padding в расчет ширины */ height: 42px; /* высота как у select */ }
.edit-row input[type="text"] { flex: 1; min-width: 0; }
.edit-row input[type="text"]:first-child { margin-right: 10px; }
.checkbox-wrapper { display: flex; align-items: center; white-space: nowrap; }
.checkbox-wrapper input[type="checkbox"] { appearance: none; width: 20px; height: 20px; background: var(--element-bg); border: 1px solid var(--border-color); border-radius: 5px; box-shadow: inset 2px 2px 5px var(--element-shadow), inset -2px -2px 5px var(--element-highlight); cursor: pointer; margin-right: 10px; position: relative; }
.checkbox-wrapper input[type="checkbox"]:checked::before { content: '\2714'; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: #4CAF50; font-size: 14px; }
#colorPicker { cursor: pointer; border: none; padding: 0; width: 30px; height: 30px; border-radius: 50%; }
.copy-icon { position: absolute; bottom: 10px; right: 10px; width: 32px; height: 32px; cursor: pointer; opacity: 0.6; transition: opacity 0.3s ease; }
.copy-icon:hover { opacity: 1; }
.control-row button { flex: 0 1 auto; }
@media (max-width: 768px) { .control-row { flex-direction: column; align-items: stretch; }
.control-row > * { margin-bottom: 10px; }
.control-row button, .checkbox-wrapper, #colorPicker { width: 100%; }
.checkbox-wrapper { justify-content: center; }
#colorPicker { margin: 0 auto; }
.edit-row { flex-direction: column; }
.edit-row input[type="text"] { width: 100%; margin-bottom: 10px; }
.edit-row input[type="text"]:first-child { margin-right: 0; }
}
#status-bar { position: fixed; bottom: 0; left: 0; right: 0; background-color: #f0f0f0; padding: 5px 10px; font-size: 12px; border-top: 1px solid #ccc; display: flex; justify-content: space-between; }
#translateDialog { display: none; position: fixed; z-index: 1000; left: 50%; top: 50%; transform: translate(-50%, -50%); background-color: var(--bg-color); padding: 20px; border-radius: 10px; box-shadow: 0 0 10px rgba(0,0,0,0.3); width: 300px; }
#translateDialog select { width: 100%; /* Растягиваем combobox на всю ширину диалога */ margin: 10px 0; }
</style>

</head>
<body>
    <div class="container">
        <div class="text-fields">
            <div class="text-field-container">
                <textarea id="field1" placeholder="Вставьте текст сюда"></textarea>
                <img src="https://img.icons8.com/?size=100&id=DDryiUPQjQ9L&format=png&color=000000" alt="Copy" class="copy-icon" onclick="copyText('field1')">
            </div>
            <div class="text-field-container">
                <textarea id="field2" placeholder="Результат обработки появится здесь"></textarea>
                <img src="https://img.icons8.com/?size=100&id=DDryiUPQjQ9L&format=png&color=000000" alt="Copy" class="copy-icon" onclick="copyText('field2')">
            </div>
        </div>
        <div id="workPanel">
            <div class="control-row">
               <select id="operation">
    <option value="compareLists">Сравнить списки</option>
       <option value="translate">Перевести</option>
    <option value="extractBetween">Выбрать текст между (текст1 и текст2) и оставить только эти строки</option>
    <option value="addEmptyLines">Добавить строку между строками</option>
    <option value="replace">Заменить текст</option>
    <option value="replaceWithNewline">Заменить текст на перенос строк</option>
    <option value="replaceAndNewline">Заменить текст и перенести строку</option>
    <option value="replaceNewlineWithText">Заменить перенос строк на текст</option>
    <option value="replaceWithTab">Заменить текст на знак табуляции</option>
<option value="replaceTabWithText">Заменить знак табуляции на текст</option>
<option value="replaceTabWithNewline">Заменить знак табуляции на перенос строки</option>
    <option value="replaceAndKeep">Заменить текст и оставить только строки с замененным текстом</option>
    <option value="replaceLastChar">Заменить последний символ в строке</option>
    <option value="replaceSpacesWithNewline">Заменить пробел(ы) на знак переноса строки</option>
<option value="replaceSpacesWithTab">Заменить пробел(ы) на знак табуляции</option>
<option value="replaceSpacesWithText">Заменить пробел(ы) на текст</option>

    <option value="replaceAndCreateCSV">Заменить текст по списку замен и сформировать CSV</option>
    <option value="toUpperCase">Изменить регистр на "ВЕРХНИЙ"</option>
    <option value="toLowerCase">Изменить регистр на "нижний"</option>
    <option value="toTitleCase">Изменить регистр на "Верхний и Нижний"</option>
    <option value="extractColumns">Колонки: Извлечь указанные колонки</option>
    <option value="splitIntoColumns">Колонки: Разделить на две колонки</option>
    <option value="splitByDelimiter">Колонки: Разделить список с несколькими разделителями</option>
        <option value="multiSelect">Множественный выбор</option>
    <option value="findDuplicates">Найти дубли</option>
    <option value="removeLinesDuplicatesInLine">Найти строки с дублями в строке</option>
      <option value="removeLinesWithSpecificLength">Найти или удалить строки с указанным количеством символов</option>
    <option value="findUniqueWordsNoNumbers">Найти уникальные слова</option>
    <option value="findUniqueWords">Найти уникальные слова и числа</option>
    <option value="keepLinesAfter">Оставить строки с текстом после...</option>
    <option value="keepLinesBefore">Оставить строки с текстом до...</option>
    <option value="keepLinesBetween">Оставить строки с текстом между..</option>
<option value="keepAndTrimLinesBetween">Оставить строки с текстом между... (и оставить только данный текст) </option>
<option value="swapColumns">Поменять местами колонки</option>
    <option value="reverse">Поменять направление строк</option>
    <option value="compareLineByLine">Построчное сравнение</option>
         <option value="groupLinesByKeyWord">Сгруппировать строки по ключевому слову</option>
    <option value="joinColumnsToCSV">Соединить колонки в CSV</option>
    <option value="joinByContent">Соединить по содержимому</option>
    <option value="sort">Сортировать</option>
    <option value="sortByTextBetween">Сортировать по тексту между..</option>
    <option value="compareListsContains">Сравнение строк с условием "содержит текст из строки"</option>
    <option value="sum">Сумма</option>
        <option value="transpose">Транспонировать</option>
        <option value="removeDuplicates">Удалить дублирующие строки</option>
    <option value="removeEmptyLines">Удалить пустые строки (в том числе содержащие только пробел)</option>
        <option value="trim">Удалить пробелы слева и справа</option>
        <option value="removeLinesWithSpecificLength">Удалить строки с указанным количеством символов</option>
        <option value="removeLinesContainingText">Удалить строки, содержащие текст</option>
        <option value="removeTextBeforeAfter">Удалить текст до/после...</option>
        <option value="removeTextBeforeAfterKeep">Удалить текст до/после...(и оставить текст из до и после)</option>
             <option value="removeText">Удалить текст</option>
             <option value="removeDigitsAndText">Удалить цифры и текст</option>
    <option value="filterLines">Фильтр</option>
    <option value="multiFilter">Мультифильтр</option>
    <option value="mergeFiles">Файлы: объединить текстовые файлы</option>

    </select>
            </div>
           <div class="edit-row">
    <div>
        <input type="text" id="edit1" placeholder="Найти">
    </div>
    <div>
        <input type="text" id="edit2" placeholder="Заменить на">
    </div>
</div>

     <div class="control-row">
    <button onclick="processText()">
        <img src="https://img.icons8.com/material-outlined/24/000000/play--v1.png" alt="Execute" class="icon">
        Выполнить
    </button>
    <div class="checkbox-wrapper">
        <input type="checkbox" id="caseSensitive">
        <label for="caseSensitive">Учитывать регистр</label>
    </div>
    <input type="color" id="colorPicker" onchange="changeThemeColor(this.value)">
</div>
        </div>
    <div id="status-bar"></div>
    </div>

   <div id="translateDialog">
    <h3>Перевести текст</h3>
    <div>
        <input type="radio" id="field1Radio" name="sourceField" value="field1" checked>
        <label for="field1Radio">Список 1</label>
        <input type="radio" id="field2Radio" name="sourceField" value="field2">
        <label for="field2Radio">Список 2</label>
    </div>
    <select id="fromLang">
        <option value="en" selected>Английский</option>
        <option value="es">Испанский</option>
        <option value="de">Немецкий</option>
        <option value="ru">Русский</option>
        <option value="tt">Татарский</option>
        <option value="tr">Турецкий</option>
        <option value="fr">Французский</option>
    </select>
    <select id="toLang">
       <option value="en">Английский</option>
        <option value="es">Испанский</option>
        <option value="de">Немецкий</option>
        <option value="ru" selected>Русский</option>
        <option value="tt">Татарский</option>
        <option value="tr">Турецкий</option>
        <option value="fr">Французский</option>
    </select>
    <button id="translateBtn">Перевести</button>
</div>

  <script>
    function escapeRegExp(string) {
        if (string === undefined || string === null) {
            return '';
        }
        return string.replace(/[-\/\\^$*+?.()|[$${}]/g, '\\$&');
    }

  function showTranslateDialog() {
        const dialog = document.getElementById('translateDialog');
        dialog.style.display = 'block';

  
        function closeDialog(e) {
            if (e.target === dialog) {
                dialog.style.display = 'none';
                document.removeEventListener('click', closeDialog);
            }
        }

   
        setTimeout(() => {
            document.addEventListener('click', closeDialog);
        }, 0);
    }

        function translate() {
            const sourceField = document.querySelector('input[name="sourceField"]:checked').value;
            const fromLang = document.getElementById('fromLang').value;
            const toLang = document.getElementById('toLang').value;
            const text = document.getElementById(sourceField).value;

            const url = `https://translate.google.com/?sl=${fromLang}&tl=${toLang}&text=${encodeURIComponent(text)}`;
            window.open(url, '_blank');

            document.getElementById('translateDialog').style.display = 'none';
        }
        
        
        function swapColumns(text, delimiter, requiredPrefix) {
    if (!delimiter) {
        return text;
    }

    const lines = text.split('\n');
    const swappedLines = lines.map(line => {
        if (!line.trim()) return '';

        const parts = line.split(delimiter);
        if (parts.length !== 2) return line; // Пропускаем строки без разделителя

        const [col1, col2] = parts.map(part => part.trim());

        // Если указан обязательный реквизит
        if (requiredPrefix) {
            // Если первая колонка должна содержать определенный префикс
            if (col1.includes(requiredPrefix)) {
                return `${col1}${delimiter}${col2}`;
            }
            if (col2.includes(requiredPrefix)) {
                return `${col2}${delimiter}${col1}`;
            }
            return line; // Если префикс не найден, оставляем строку без изменений
        }

        // Если префикс не указан, просто меняем колонки местами
        return `${col2}${delimiter}${col1}`;
    });

    return swappedLines.filter(line => line).join('\n');
}


        
function removeLinesWithSpecificLength(text, length1, length2) {
  
    
    // Определяем активную длину и режим
    const activeLength = length2 || length1; // приоритет length2
    const isKeepMode = Boolean(length2);
    
  

    const lengthSet = new Set(activeLength.split(' ').map(Number));
  
    
    const filteredLines = text.split('\n')
        .filter(line => {
            const lineLength = line.trim().length;
            const shouldKeep = isKeepMode ? lengthSet.has(lineLength) : !lengthSet.has(lineLength);
        
            return shouldKeep;
        });

 
    
    return filteredLines.join('\n');
}

function removeLinesDuplicatesInLine(text, separator1 = '', separator2 = '') {
    // Проверка, что хотя бы один разделитель указан
    if (!separator1 && !separator2) {
        alert('Пожалуйста, укажите разделитель в одном из полей.');
        return '';
    }

    // Проверка на одинаковые разделители
    if (separator1 && separator2 && separator1 === separator2) {
        alert('Ошибка: разделители в обоих полях не могут быть. Пожалуйста, используйте разделитель в одном из полей.');
        return '';
    }

    const lines = text.split('\n').filter(line => line.trim());
    
    return lines.filter(line => {
        // Используем первый непустой разделитель
        const separator = separator1 || separator2;
        const parts = line.split(separator).map(part => part.trim());
        const hasDuplicates = parts.length !== new Set(parts).size;
        
        // Логика фильтрации
        if (separator2) {
            // Если указан второй разделитель, ищем строки с дублями
            return hasDuplicates;
        } 
        
        // Если второй разделитель не указан, удаляем строки с дублями
        return !hasDuplicates;
    }).join('\n');
}


    function compareLists() {
        const caseSensitive = document.getElementById('caseSensitive').checked;
        const list1 = document.getElementById('field1').value.split('\n').map(item => item.trim()).filter(Boolean);
        const list2 = document.getElementById('field2').value.split('\n').map(item => item.trim()).filter(Boolean);

        const compareFunction = caseSensitive
            ? (a, b) => a === b
            : (a, b) => a.toLowerCase() === b.toLowerCase();

        const set1 = new Set(caseSensitive ? list1 : list1.map(item => item.toLowerCase()));
        const set2 = new Set(caseSensitive ? list2 : list2.map(item => item.toLowerCase()));

        const inBothFromFirst = list1.filter(item => Array.from(set2).some(setItem => compareFunction(item, setItem)));
        const inBothFromSecond = list2.filter(item => Array.from(set1).some(setItem => compareFunction(item, setItem)));
        const onlyInFirst = list1.filter(item => !Array.from(set2).some(setItem => compareFunction(item, setItem)));
        const onlyInSecond = list2.filter(item => !Array.from(set1).some(setItem => compareFunction(item, setItem)));

        const options = [
            { text: "Есть в первом списке и есть во втором", result: inBothFromFirst },
            { text: "Есть в первом списке и нет во втором", result: onlyInFirst },
            { text: "Есть во втором списке и есть в первом", result: inBothFromSecond },
            { text: "Есть во втором списке и нет в первом", result: onlyInSecond }
        ];

        const dialog = document.createElement('div');
        dialog.style.position = 'fixed';
        dialog.style.left = '50%';
        dialog.style.top = '50%';
        dialog.style.transform = 'translate(-50%, -50%)';
        dialog.style.backgroundColor = 'white';
        dialog.style.padding = '20px';
        dialog.style.border = '1px solid black';
        dialog.style.zIndex = '1000';

        options.forEach((option) => {
            const button = document.createElement('button');
            button.textContent = option.text;
            button.onclick = function(e) {
                e.stopPropagation();
                const result = option.result.join('\n');

                const blob = new Blob([result], {type: "text/plain;charset=utf-8"});
                const link = document.createElement("a");
                link.href = URL.createObjectURL(blob);
                link.download = `${option.text}.txt`;
                link.click();

                document.body.removeChild(dialog);
            };
            dialog.appendChild(button);
            dialog.appendChild(document.createElement('br'));
        });

        dialog.onclick = function(e) {
            if (e.target === dialog) {
                document.body.removeChild(dialog);
            }
        };

        document.body.appendChild(dialog);
    }

function updateStatistics() {
    const field1 = document.getElementById('field1');
    const field2 = document.getElementById('field2');
    const statusBar = document.getElementById('status-bar');

    const stats1 = getFieldStats(field1);
    const stats2 = getFieldStats(field2);

    const cursorPos1 = getCursorPosition(field1);
    const cursorPos2 = getCursorPosition(field2);

    statusBar.innerHTML = `
        <span>Список 1: Строка ${cursorPos1.line} из  ${stats1.lines}, Символ ${cursorPos1.col}/${cursorPos1.total} из ${stats1.chars}</span>
        <span>Список 2: Строка ${cursorPos2.line} из ${stats2.lines}, Символ ${cursorPos2.col}/${cursorPos2.total} из ${stats2.chars}</span>
    `;
}

function getCursorPosition(field) {
    const text = field.value;
    const cursorPos = field.selectionStart;
    const lines = text.substring(0, cursorPos).split('\n');
    const line = lines.length;
    const col = lines[lines.length - 1].length;
    const total = cursorPos;
    return { line, col, total };
}


function removeLinesContainingText(text, searchText1, searchText2, caseSensitive) {
    const flags = caseSensitive ? 'u' : 'ui';
    const regex1 = new RegExp(escapeRegExp(searchText1), flags);
    const regex2 = searchText2 ? new RegExp(escapeRegExp(searchText2), flags) : null;

    return text.split('\n')
        .filter(line => !regex1.test(line) && (!regex2 || !regex2.test(line)))
        .join('\n');
}

function keepLinesBetween(text, start, end, caseSensitive) {

    const flags = caseSensitive ? 'u' : 'ui';
    const startRegex = new RegExp(escapeRegExp(start), flags);
    const endRegex = new RegExp(escapeRegExp(end), flags);

    const lines = text.split('\n');
    let result = [];

    for (const line of lines) {
        const startMatch = line.match(startRegex);
        const endMatch = line.match(endRegex);

        if (startMatch && endMatch) {
            const startIndex = startMatch.index + startMatch[0].length;
            const endIndex = endMatch.index;

      
            if (startIndex < endIndex) {
                const textBetween = line.substring(startIndex, endIndex).trim();

                if (textBetween.length > 0) {
                    result.push(line);
                }
            }
        }
    }

    return result.join('\n');
}


function keepAndTrimLinesBetween(text, start, end, caseSensitive) {
    if (!start || !end) {
        console.log("Один из паттернов не указан. Возвращаем исходный текст.");
        return text;
    }

    const flags = caseSensitive ? '' : 'i';
    const startRegex = new RegExp(escapeRegExp(start), flags);

    console.log("Начальный паттерн (startRegex):", startRegex);
    console.log("Конечный паттерн (end):", end);

    const lines = text.split('\n');
    let result = [];

    console.log("Обрабатываем строки:", lines);

    lines.forEach((line, index) => {
        console.log(`\nОбработка строки ${index + 1}: "${line}"`);

        // Ищем startMatch
        const startMatch = startRegex.exec(line);

        console.log("Результат поиска startMatch:", startMatch);

        if (startMatch) {
            // Получаем подстроку после startMatch
            const substringAfterStart = line.substring(startMatch.index + startMatch[0].length);
            console.log("Подстрока после startMatch:", substringAfterStart);

            // Ищем end в подстроке после startMatch
            const endIndexInSubstring = substringAfterStart.indexOf(end);
            console.log("Результат поиска end в подстроке:", endIndexInSubstring);

            if (endIndexInSubstring !== -1) {
                console.log("startMatch находится перед end.");

                // Вычисляем позицию end в исходной строке
                const endIndex = startMatch.index + startMatch[0].length + endIndexInSubstring;

                // Извлекаем текст между паттернами и удаляем пробелы
                const textBetween = line.substring(startMatch.index + startMatch[0].length, endIndex).trim();
                console.log("Текст между паттернами:", textBetween);

                if (textBetween.length > 0) {
                    result.push(textBetween);
                    console.log("Добавлен текст в результат:", textBetween);
                } else {
                    console.log("Текст между паттернами пуст. Пропускаем.");
                }
            } else {
                console.log("end не найден после startMatch. Пропускаем строку.");
            }
        } else {
            console.log("startMatch не найден. Пропускаем строку.");
        }
    });

    console.log("Итоговый результат:", result.join('\n'));
    return result.join('\n');
}


function filterLines(text, filter1, filter2, caseSensitive) {
    const flags = caseSensitive ? '' : 'i';
    const regex1 = new RegExp(escapeRegExp(filter1), flags);
    const regex2 = filter2 ? new RegExp(escapeRegExp(filter2), flags) : null;
    return text.split('\n')
        .filter(line => regex1.test(line) && (!regex2 || regex2.test(line)))
        .join('\n');
}

function splitByDelimiter(text, delimiter, position) {
    if (!delimiter) {
        return {
            firstPart: text,
            secondPart: ''
        };
    }

    // Преобразуем position в число, по умолчанию 1
    const pos = parseInt(position) || 1;
    
    const lines = text.split('\n');
    const firstParts = [];
    const secondParts = [];

    lines.forEach(line => {
        if (line.trim()) { // Обрабатываем только непустые строки
            // Находим все позиции разделителя в строке
            let indices = [];
            let index = -1;
            while ((index = line.indexOf(delimiter, index + 1)) !== -1) {
                indices.push(index);
            }

            // Если указанная позиция больше, чем количество разделителей
            if (pos > indices.length) {
                firstParts.push(line);
            } else {
                // Разделяем строку по указанной позиции разделителя
                const splitIndex = indices[pos - 1];
                firstParts.push(line.substring(0, splitIndex));
                secondParts.push(line.substring(splitIndex + delimiter.length));
            }
        }
    });

    return {
        firstPart: firstParts.join('\n'),
        secondPart: secondParts.join('\n')
    };
}

function extractColumns(text, delimiter, columns) {
    if (!delimiter) {
        delimiter = '\t'; // По умолчанию используем табуляцию
    }

    const columnIndices = columns.split(' ').map(Number);
    const lines = text.split('\n');
    const result = [];

    lines.forEach(line => {
        const parts = line.split(delimiter);
        const selectedParts = columnIndices.map(index => parts[index - 1] || '').join(delimiter);
        result.push(selectedParts);
    });

    return result.join('\n');
}

function sortByTextBetween(text, start, end, caseSensitive) {

    const regex = new RegExp(`${escapeRegExp(start)}(.*?)${escapeRegExp(end)}`, 'g');

    const lines = text.split('\n');
    const extractedTexts = lines.map(line => {
        const match = line.match(regex);
        return match ? { line, text: match[0].slice(start.length, -end.length).trim() } : null;
    }).filter(item => item !== null);

    if (extractedTexts.length === 0) {
        return text;
    }

    extractedTexts.sort((a, b) => {
        const comparison = caseSensitive
            ? a.text.localeCompare(b.text)
            : a.text.toLowerCase().localeCompare(b.text.toLowerCase());

        return comparison;
    });

    const result = extractedTexts.map(item => item.line).join('\n');

    return result;
}

function getFieldStats(field) {
    const text = field.value;
    const chars = text.length;
    const lines = text.split('\n').length;
    return { chars, lines };
}

    function processText() {
        const text1 = document.getElementById('field1').value;
    const text2 = document.getElementById('field2').value;

         const text = document.getElementById('field1').value;
        const edit1 = document.getElementById('edit1').value;
        const edit2 = document.getElementById('edit2').value;
        const caseSensitive = document.getElementById('caseSensitive').checked;
        const operation = document.getElementById('operation').value;
        let result = '';

         if (operation === 'translate') {
            showTranslateDialog();
            return;
        }

        switch(operation) {
            case 'replace':
                if (caseSensitive) {
                    result = text.split(edit1).join(edit2);
                } else {
                    const regex = new RegExp(escapeRegExp(edit1), 'gi');
                    result = text.replace(regex, edit2);
                }
                break;
                
                case 'removeTextBeforeAfter':
    result = removeTextBeforeAfter(text, edit1, edit2, caseSensitive);
    break;
    
     case 'extractColumns':
            result = extractColumns(text, edit1, edit2);
            break;
    
    case 'mergeFiles':
    mergeFiles();
    return;
    
    
    case 'swapColumns':
    const swapDelimiter = edit1 || '';
    const requiredPrefix = edit2 || '';
    result = swapColumns(text, swapDelimiter, requiredPrefix);
    break;
    
     case 'groupLinesByKeyWord':
            result = groupLinesByKeyWord(text, edit1, edit2);
            break;
            
            
        
case 'replaceLastChar':
    const searchChar = edit1.trim();
    const replaceChar = edit2 || ''; // Если edit2 пустое, заменяем на пустую строку
    
    result = text.split('\n').map(line => {
        if (!line.trim()) return line; // Пропускаем пустые строки
        
        if (!searchChar) {
            // Если edit1 пустое, заменяем последний символ на текст из edit2
            return line.slice(0, -1) + replaceChar;
        } else {
            // Если edit1 указан, проверяем, является ли последний символ искомым
            if (line.endsWith(searchChar)) {
                return line.slice(0, -searchChar.length) + replaceChar;
            }
            return line; // Если последний символ не совпадает, оставляем строку без изменений
        }
    }).join('\n');
    break;
    
    
case 'removeLinesDuplicatesInLine':
    // Получаем значения напрямую из элементов ввода
    const dupSeparator1 = document.getElementById('edit1').value || '';
    const dupSeparator2 = document.getElementById('edit2').value || '';
    
 
    
    result = removeLinesDuplicatesInLine(text, dupSeparator1, dupSeparator2);
    break;
    
    
    case 'multiSelect':
    multiSelect();
    return;
    
    case 'splitByDelimiter':
    const delimiter = edit1 || '';
    const position = edit2 || '1';
    const parts = splitByDelimiter(text, delimiter, position);
    document.getElementById('field1').value = parts.firstPart;
    document.getElementById('field2').value = parts.secondPart;
    updateStatistics();
    return;
    
    
      case 'removeDigitsAndText':
    // Начинаем с исходного текста
    result = text1;

    // Удаляем цифры
    result = result.replace(/[0-9]/g, '');

    // Обрабатываем текст из edit1 (если есть)
    if (edit1) {
        const textToRemove1 = edit1.includes(' ') ? edit1 : escapeRegExp(edit1);
        if (caseSensitive) {
            result = result.replace(new RegExp(textToRemove1, 'g'), '');
        } else {
            result = result.replace(new RegExp(textToRemove1, 'gi'), '');
        }
    }

    // Обрабатываем текст из edit2 (если есть)
    if (edit2) {
        // Разбиваем текст на слова, если есть пробелы
        const words = edit2.split(' ');
        for (const word of words) {
            if (word.trim()) { // Проверяем, что слово не пустое
                const escapedWord = escapeRegExp(word);
                if (caseSensitive) {
                    result = result.replace(new RegExp(escapedWord, 'g'), '');
                } else {
                    result = result.replace(new RegExp(escapedWord, 'gi'), '');
                }
            }
        }
    }
    break;

case 'removeText':
    // Начинаем с исходного текста
    result = text1;

    // Обрабатываем текст из edit1 (если есть)
    if (edit1) {
        const textToRemove1 = edit1.includes(' ') ? edit1 : escapeRegExp(edit1);
        if (caseSensitive) {
            result = result.replace(new RegExp(textToRemove1, 'g'), '');
        } else {
            result = result.replace(new RegExp(textToRemove1, 'gi'), '');
        }
    }

    // Обрабатываем текст из edit2 (если есть)
    if (edit2) {
        // Разбиваем текст на слова, если есть пробелы
        const words = edit2.split(' ');
        for (const word of words) {
            if (word.trim()) { // Проверяем, что слово не пустое
                const escapedWord = escapeRegExp(word);
                if (caseSensitive) {
                    result = result.replace(new RegExp(escapedWord, 'g'), '');
                } else {
                    result = result.replace(new RegExp(escapedWord, 'gi'), '');
                }
            }
        }
    }
    break;
            
    
case 'removeLinesWithSpecificLength':
    const length1 = document.getElementById('edit1').value.trim();
    const length2 = document.getElementById('edit2').value.trim();
   

    // Если оба поля пустые
    if (!length1 && !length2) {
        alert('Ошибка: Необходимо заполнить одно из полей.');
        return;
    }

    // Если оба поля заполнены
    if (length1 && length2) {
        alert('Ошибка: Нельзя вводить данные одновременно в оба поля.');
        return;
    }

    result = removeLinesWithSpecificLength(text1, length1, length2);
    break;

    case 'joinColumnsToCSV':
    const column1 = text1.split('\n');
    const column2 = text2.split('\n');
    const separator = edit1 || ';';
    const additionalText = edit2 || '';

    // Определяем максимальную длину колонок
    const maxLength = Math.max(column1.length, column2.length);

    // Создаем массив строк CSV с CRLF окончаниями строк
    const csvLines = [];
    for (let i = 0; i < maxLength; i++) {
        const col1Value = column1[i] || '';
        const col2Value = column2[i] || '';
        csvLines.push(`${col1Value}${separator}${col2Value}${additionalText}`);
    }

    // Создаем содержимое CSV файла с CRLF
    const csvContent = csvLines.join('\r\n');

    // Создаем и скачиваем CSV файл
    const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
    const link = document.createElement("a");
    if (link.download !== undefined) {
        const url = URL.createObjectURL(blob);
        link.setAttribute("href", url);
        link.setAttribute("download", "combined_columns.csv");
        link.style.visibility = 'hidden';
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
    }
    return; // Добавьте эту строку
    break;
    
    case 'replaceTabWithNewline':
    result = text.replace(/\t/g, '\n');
    break;
    
    case 'findDuplicates':
    result = findDuplicates(text, caseSensitive);
    break;
    
    case 'replaceSpacesWithNewline':
  
    result = text.replace(/\s+/g, '\n');
    break;
    
         case 'removeLinesContainingText':
            result = removeLinesContainingText(text1, edit1, edit2, caseSensitive);
            break;
            
            
case 'addEmptyLines':
    const lineCount = document.getElementById('edit1').value;
    const lineText = document.getElementById('edit2').value;
    result = addEmptyLinesBetween(text, lineCount, lineText);
    break;

case 'replaceSpacesWithTab':
    // Используем регулярное выражение, которое захватывает только пробелы, 
    // не затрагивая символы переноса строки
    result = text.replace(/ +/g, '\t');
    break;

case 'replaceSpacesWithText':
    // Получаем текст для замены из поля edit1
    const replacementText = edit1 || ','; // Changed from edit1.value

    
    // Используем регулярное выражение для замены одного или нескольких пробелов
    result = text.replace(/\s+/g, replacementText);
    

    break;
    
    
case 'splitIntoColumns':
    const separatorText = document.getElementById('edit1').value; 
    if (!separatorText) {
        document.getElementById('field2').value = "Укажите разделитель";
        return;
    }
    const splitResult = splitTextIntoColumns(text, separatorText);
    document.getElementById('field1').value = splitResult.firstColumn;
    document.getElementById('field2').value = splitResult.secondColumn;
    updateStatistics(); // обновляем статистику после изменения полей
    return;

case 'compareListsContains':
    const list1 = text1.split('\n').map(item => item.trim()).filter(Boolean);
    const list2 = text2.split('\n').map(item => item.trim()).filter(Boolean);

    // Поиск строк из list1, которых нет в list2
    const notFoundInList2 = list1.filter(item1 => {
        return !list2.some(item2 => {
            if (caseSensitive) {
                return item2.includes(item1);
            } else {
                return item2.toLowerCase().includes(item1.toLowerCase());
            }
        });
    });

    // Поиск строк из list2, которых нет в list1
    const notFoundInList1 = list2.filter(item2 => {
        return !list1.some(item1 => {
            if (caseSensitive) {
                return item1.includes(item2);
            } else {
                return item1.toLowerCase().includes(item2.toLowerCase());
            }
        });
    });

    const resultContent = "Ненайденные строки из Списка1 в Списке2:\n" +
                          notFoundInList2.join('\n') +
                          "\n\nНенайденные строки из Списка2 в Списке1:\n" +
                          notFoundInList1.join('\n');

    // Создание и скачивание текстового файла
    const compareListBlob = new Blob([resultContent], {type: "text/plain;charset=utf-8"});
    const compareListLink = document.createElement("a");
    compareListLink.href = URL.createObjectURL(compareListBlob);
    compareListLink.download = "comparison_result.txt";
    compareListLink.click();

    // Не очищаем field2
    return;

    case 'multiFilter':
    result = multiFilter(text, edit1, edit2, caseSensitive);
    break;

                case 'keepLinesBetween':
    result = keepLinesBetween(text, edit1, edit2, caseSensitive);
    break;
    
    
    
case 'keepAndTrimLinesBetween':
    result = keepAndTrimLinesBetween(text, edit1, edit2, caseSensitive);
    break;
case 'filterLines':
    result = filterLines(text, edit1, edit2, caseSensitive);
    break;
case 'sortByTextBetween':
    result = sortByTextBetween(text, edit1, edit2, caseSensitive);
    break;
    
    
    

    case 'replaceAndCreateCSV':
    replaceAndCreateCSV(text1, text2, edit1.value || ';');

    return;

            case 'replaceWithTab':
    if (caseSensitive) {
        result = text.split(edit1).join('\t');
    } else {
        const regex = new RegExp(escapeRegExp(edit1), 'gi');
        result = text.replace(regex, '\t');
    }
    break;
case 'replaceTabWithText':
    result = text.replace(/\t/g, edit1);
    break;

         case 'findUniqueWords':
            result = findUniqueWords(text1, caseSensitive);
            break;
        case 'findUniqueWordsNoNumbers':
            result = findUniqueWordsNoNumbers(text1, caseSensitive);
            break;

             case 'reverse':
                result = text.split('\n').reverse().join('\n');
                break;
            case 'compareLists':
                compareLists();
                return;
            case 'transpose':
                const rows = text.split('\n').map(row => row.split('\t'));
                result = rows[0].map((_, colIndex) => rows.map(row => row[colIndex]).join('\t')).join('\n');
                break;
case 'sum':
    const numbers = text.split('\n')
        .flatMap(line => {
            // Заменяем запятые на точки для десятичных чисел
            line = line.replace(/,/g, '.');

            // Разбиваем строку по двум или более пробелам или по нецифровым символам
            const parts = line.split(/(?:\s{2,}|[^0-9.\s])+/);

            return parts.map(part => {
                // Убираем одиночные пробелы и обрабатываем число
                const cleanedPart = part.replace(/\s/g, '');
                // Проверяем, является ли строка корректным числом
                if (/^-?\d+(\.\d+)?$/.test(cleanedPart)) {
                    return parseFloat(cleanedPart);
                }
                return null;
            });
        })
        .filter(num => num !== null);  // Удаляем все нечисловые значения

    if (numbers.length > 0) {
        const sum = numbers.reduce((acc, num) => acc + num, 0);
        const average = sum / numbers.length;
        const count = numbers.length; // Количество записей

        result = numbers.map(num => num.toFixed(2)).join('\n')
               + '\n\nсумма:\n' + sum.toFixed(2)
               + '\n\nсреднее значение (из ' + count + '):\n' + average.toFixed(2);
    } else {
        result = "Не найдено корректных числовых значений";
    }
    break;
                   case 'removeDuplicates':
            const lines = text.split('\n');
            const uniqueLines = new Set();
            result = lines.filter(line => {
                const trimmedLine = line.trim();
                if (caseSensitive) {
                    if (!uniqueLines.has(trimmedLine)) {
                        uniqueLines.add(trimmedLine);
                        return true;
                    }
                } else {
                    const lowerCaseLine = trimmedLine.toLowerCase();
                    if (!uniqueLines.has(lowerCaseLine)) {
                        uniqueLines.add(lowerCaseLine);
                        return true;
                    }
                }
                return false;
            }).join('\n');
            break;
            
            case 'joinByContent':
    result = joinByContent(text);
    break;

    case 'compareLineByLine':
            const lines1 = text1.split('\n');
            const lines2 = text2.split('\n');
            const maxLines = Math.max(lines1.length, lines2.length);

            for (let i = 0; i < maxLines; i++) {
                const line1 = lines1[i] || '';
                const line2 = lines2[i] || '';

                if (caseSensitive ? line1 === line2 : line1.toLowerCase() === line2.toLowerCase()) {
                    result += `${line1} * Совпадает\n`;
                } else {
                    result += `${line1} * Различается: ${line2}\n`;
                }
            }
            break;

            case 'toUpperCase':
                result = text.toUpperCase();
                break;
            case 'toLowerCase':
                result = text.toLowerCase();
                break;
 case 'toTitleCase':
    result = text.split('\n').map(line =>
        line.replace(/[^\s;]+/g, word =>
            word.charAt(0).toUpperCase() + word.slice(1).toLowerCase()
        )
    ).join('\n');
    break;
            case 'replaceWithNewline':
                if (caseSensitive) {
                    result = text.split(edit1).join('\n');
                } else {
                    const regex = new RegExp(escapeRegExp(edit1), 'gi');
                    result = text.replace(regex, '\n');
                }
                break;
                
                 case 'removeTextBeforeAfterKeep':
    result = removeTextBeforeAfterKeep(text, edit1, edit2, caseSensitive);
    break;
    
    
            case 'replaceAndNewline':
                if (caseSensitive) {
                    result = text.split(edit1).join(edit2 + '\n');
                } else {
                    const regex = new RegExp(escapeRegExp(edit1), 'gi');
                    result = text.replace(regex, edit2 + '\n');
                }
                break;
            case 'extractBetween':
                const flags = caseSensitive ? 'gs' : 'gis';
                const regex = new RegExp(`${escapeRegExp(edit1)}(.*?)${escapeRegExp(edit2)}`, flags);
                result = [...text.matchAll(regex)].map(match => match[1].trim()).join('\n');
                break;
            case 'sort':
                result = text.split('\n').sort((a, b) => {
                    if (caseSensitive) {
                        return a.localeCompare(b);
                    } else {
                        return a.toLowerCase().localeCompare(b.toLowerCase());
                    }
                }).join('\n');
                break;
            case 'removeEmptyLines':
                result = text.split('\n').filter(line => line.trim() !== '').join('\n');
                break;
  case 'trim':
    const separator1 = document.getElementById('edit1').value; 
    const separator2 = document.getElementById('edit2').value; 
    result = trimWithSeparators(text, separator1, separator2);
    break;
            case 'keepLinesAfter':
                result = text.split('\n')
                    .map(line => {
                        const index = caseSensitive ? line.indexOf(edit1) : line.toLowerCase().indexOf(edit1.toLowerCase());
                        return index !== -1 ? line.slice(index + edit1.length) : '';
                    })
                    .filter(line => line.trim() !== '')
                    .join('\n');
                break;
            case 'keepLinesBefore':
                result = text.split('\n')
                    .map(line => {
                        const index = caseSensitive ? line.indexOf(edit1) : line.toLowerCase().indexOf(edit1.toLowerCase());
                        return index !== -1 ? line.slice(0, index) : line;
                    })
                    .filter(line => line.trim() !== '')
                    .join('\n');
                break;
            case 'replaceAndKeep':

                if (caseSensitive) {
                    result = lines.filter(line => line.includes(edit1)).map(line => line.replace(new RegExp(escapeRegExp(edit1), 'g'), edit2)).join('\n');
                } else {
                    result = lines.filter(line => line.toLowerCase().includes(edit1.toLowerCase())).map(line => line.replace(new RegExp(escapeRegExp(edit1), 'gi'), edit2)).join('\n');
                }
                break;
            case 'replaceNewlineWithText':
                result = text.replace(/\n/g, edit1);
                break;
        }

        document.getElementById('field2').value = result;
         updateStatistics();
    }

function findUniqueWordsNoNumbers(text, caseSensitive) {

    const words = text.split(/[^a-zA-Zа-яА-ЯёЁ]+/).filter(word => word.length > 0);

    const uniqueWords = new Set();

    words.forEach(word => {
        uniqueWords.add(caseSensitive ? word : word.toLowerCase());
    });

    const sortedUniqueWords = Array.from(uniqueWords).sort((a, b) =>
        a.localeCompare(b, ['ru', 'en'], {sensitivity: caseSensitive ? 'case' : 'base'})
    );

    return sortedUniqueWords.join('\n');
}


function multiSelect() {
    const sourceText = document.getElementById('field1').value;
    const searchTexts = document.getElementById('field2').value.split('\n').filter(line => line.trim() !== '');
    const sourceLines = sourceText.split('\n');
    let selectedLines = [];

    searchTexts.forEach(searchText => {
        const matchingLines = sourceLines.filter(line => line.includes(searchText));
        selectedLines = selectedLines.concat(matchingLines);
    });

    const uniqueSelectedLines = Array.from(new Set(selectedLines)); // Удалить дубликаты, если они есть

    // Создание текстового файла с выбранными строками
    const blob = new Blob([uniqueSelectedLines.join('\n')], { type: 'text/plain;charset=utf-8;' });
    const link = document.createElement("a");
    link.href = URL.createObjectURL(blob);
    link.download = "selected_lines.txt";
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
}


function findUniqueWords(text, caseSensitive) {

    const words = text.split(/[^a-zA-Zа-яА-ЯёЁ0-9]+/).filter(word => word.length > 0);

    const uniqueWords = new Set();

    words.forEach(word => {
        uniqueWords.add(caseSensitive ? word : word.toLowerCase());
    });

    const sortedUniqueWords = Array.from(uniqueWords).sort((a, b) =>
        a.localeCompare(b, ['ru', 'en'], {sensitivity: caseSensitive ? 'case' : 'base'})
    );

    return sortedUniqueWords.join('\n');
}

function trimWithSeparators(text, separator1, separator2) {
    // Если нет разделителей, просто удаляем пробелы по краям строк
    if (!separator1 && !separator2) {
        return text.split('\n')
            .map(line => line.trim())
            .filter(line => line.length > 0)
            .join('\n');
    }

    // Обработка строк с разделителями
    return text.split('\n')
        .map(line => {
            // Сначала удаляем пробелы по краям строки
            line = line.trim();

            // Обрабатываем первый разделитель
            if (separator1) {
                const parts = line.split(separator1);
                const trimmedParts = parts.map(part => part.trim());
                line = trimmedParts.join(separator1);
            }

            // Обрабатываем второй разделитель
            if (separator2) {
                const parts = line.split(separator2);
                const trimmedParts = parts.map(part => part.trim());
                line = trimmedParts.join(separator2);
            }

            return line;
        })
        .filter(line => line.length > 0)
        .join('\n');
}

function addEmptyLinesBetween(text, count, content) {
   
    
    // Получаем количество строк для добавления (по умолчанию 1)
    const numberOfLines = parseInt(count) || 1;

    
    // Получаем содержимое для добавления (по умолчанию пустая строка)
    const lineContent = content || '';
 
    
    // Разбиваем текст на строки, удаляя пустые в конце
    const textLines = text.split('\n').filter(line => line.trim() !== '');
  
    
    // Обрабатываем каждую строку
    const result = textLines.flatMap((line, index) => {
  
        
        // Для последней строки не добавляем дополнительные строки
        if (index === textLines.length - 1) {
         
            return [line];
        }
        
        // Создаем массив дополнительных строк
        const additionalLines = Array(numberOfLines).fill(lineContent);
  
        
        // Возвращаем строку вместе с дополнительными строками
        const resultLines = [line, ...additionalLines];
    
        return resultLines;
    }).join('\n');

 
    return result;
}


function splitTextIntoColumns(text, separatorText) {
    // Если разделитель не указан, используем табуляцию
    const separator = separatorText || '\t';
    
    if (!text) {
        return {
            firstColumn: "",
            secondColumn: ""
        };
    }
    
    const splitResults = text.split('\n').map(line => {
        const splitIndex = line.indexOf(separator);
        if (splitIndex === -1) return { before: line, after: '' };
        return {
            before: line.substring(0, splitIndex).trim(),
            after: line.substring(splitIndex + separator.length).trim()
        };
    });
    
    return {
        firstColumn: splitResults.map(r => r.before).join('\n'),
        secondColumn: splitResults.map(r => r.after).join('\n')
    };
}



function updatePlaceholders() {
    const operation = document.getElementById('operation').value;
    const field1 = document.getElementById('field1');
    const field2 = document.getElementById('field2');
    const edit1 = document.getElementById('edit1');
    const edit2 = document.getElementById('edit2');
    const edit1Container = edit1.parentElement;
    const edit2Container = edit2.parentElement;

    edit1Container.style.display = 'none';
    edit2Container.style.display = 'none';

    [edit1, edit2].forEach(el => {
        el.classList.remove('required');
        el.value = '';
    });

    const activateField = (field, placeholder, required = false) => {
        field.disabled = false;
        field.placeholder = placeholder;
        if (required) {
            field.classList.add('required');
        }
        if (field === edit1 || field === edit2) {
            field.parentElement.style.display = 'block';
        }
    };

    activateField(field1, "Исходный текст", true);

    switch(operation) {
        case 'replaceWithTab':
            activateField(edit1, "Заменить этот текст", true);
            activateField(field2, "Результат: Заменяет указанный текст на знак табуляции");
            break;

        case 'replaceWithNewline':
            activateField(edit1, "Заменить этот текст", true);
            activateField(field2, "Результат: Заменяет указанный текст на перенос строки");
            break;

        case 'removeDigitsAndText':
            activateField(field1, "Исходный текст", true);
            activateField(edit1, "Удалить этот текст целиком (с учетом пробелов)");
            activateField(edit2, "Удалить каждое слово отдельно (слова разделены пробелом)");
            activateField(field2, "Результат: Будут удалены все цифры и указанный текст");
            edit1Container.style.display = 'block';
            edit2Container.style.display = 'block';
            break;

        case 'removeText':
            activateField(field1, "Исходный текст", true);
            activateField(edit1, "Удалить этот текст целиком (с учетом пробелов)");
            activateField(edit2, "Удалить каждое слово отдельно (слова разделены пробелом)");
            activateField(field2, "Результат: Будет удален указанный текст");
            edit1Container.style.display = 'block';
            edit2Container.style.display = 'block';
            break;
            
    case 'mergeFiles':
            activateField(edit1, "Текст для добавления между файлами (по умолчанию пусто)");
            activateField(edit2, "Число повторений или текст для добавления (по умолчанию пусто)");
            activateField(field1, "Содержимое всех файлов будет добавлено сюда");
            activateField(field2, "Содержимое всех файлов будет добавлено сюда с текстом между файлами");
            break;

        case 'groupLinesByKeyWord':
            activateField(field1, "Исходный текст со строками для группировки", true);
            activateField(edit1, "Ключевое слово для поиска заголовков", true);
            activateField(edit2, "Разделитель (по умолчанию табуляция)");
            activateField(field2, "Результат будет сформирован следующим образом:\n\n" +
                "1) Программа ищет строки, содержащие указанное ключевое слово - эти строки становятся заголовками\n" +
                "2) Каждая строка, следующая за заголовком (до следующего заголовка), будет начинаться с текста заголовка\n\n" +
                "Пример:\n" +
                "Если в тексте есть строки:\n" +
                "Район А\n" +
                "город 1\n" +
                "город 2\n" +
                "Район Б\n" +
                "город 3\n\n" +
                "То при поиске по слову 'Район' получим:\n" +
                "Район А[разделитель]\n" +
                "Район А[разделитель]город 1\n" +
                "Район А[разделитель]город 2\n" +
                "Район Б[разделитель]\n" +
                "Район Б[разделитель]город 3");
            break;

        case 'findDuplicates':
            activateField(field1, "Исходный текст", true);
            activateField(field2, "Результат: Список дублей и количество повторений");
            break;

        case 'addEmptyLines':
            activateField(field1, "Исходный текст", true);
            activateField(edit1, "Количество строк (по умолчанию 1)");
            activateField(edit2, "Текст для добавления (по умолчанию пустая строка)");
            activateField(field2, "Результат: Добавляет пустые строки между строками");
            break;

        case 'swapColumns':
            activateField(field1, "Исходный текст с двумя колонками", true);
            activateField(edit1, "Разделитель между колонками", true);
            activateField(edit2, "Обязательный реквизит для первой колонки (необязательно)");
            activateField(field2, "Результат: Меняет местами колонки");
            break;

        case 'splitByDelimiter':
            activateField(field1, "Исходный текст со строками для разделения", true);
            activateField(edit1, "Разделитель", true);
            activateField(edit2, "Номер разделителя (по умолчанию 1)");
            activateField(field2, "Результат: Разделяет строки по указанному разделителю");
            break;

        case 'removeLinesContainingText':
            activateField(field1, "Исходный текст", true);
            activateField(edit1, "Текст для удаления строк", true);
            activateField(edit2, "Дополнительный текст для удаления строк");
            activateField(field2, "Результат: Удаляет строки, содержащие указанный текст");
            break;

        case 'removeLinesWithSpecificLength':
            activateField(field1, "Исходный текст", true);
            activateField(edit1, "Удалить строки с указанным количеством символов (через пробел)");
            activateField(edit2, "Оставить строки с указанным количеством символов");
            activateField(field2, "Результат: Удаляет строки с указанным количеством символов");
            edit1Container.style.display = 'block';
            edit2Container.style.display = 'block';
            break;
            
              case 'extractColumns':
            activateField(edit1, "Разделитель между колонками (по умолчанию табуляция)", true);
            activateField(edit2, "Номера колонок для извлечения (разделенные пробелом)", true);
            activateField(field2, "Результат: Извлеченные колонки");
            break;

        case 'multiSelect':
            activateField(field1, "Исходный текст", true);
            activateField(field2, "В исходном тексте будут выбраны строки, содержащие текст из строк данного списка");
            break;
            
          
case 'replaceLastChar':
    activateField(field1, "Исходный текст", true);
    activateField(edit1, "Последний символ для замены (если пусто - любой)");
    activateField(edit2, "Заменить на этот текст");
    activateField(field2, "Результат: Заменяет последний символ в каждой строке");
    break;

        case 'removeLinesDuplicatesInLine':
            activateField(field1, "Исходный текст", true);
            activateField(edit1, "Укажите разделитель для поиска строк без дублей");
            activateField(edit2, "Укажите разделитель для поиска строк с дублями");
            activateField(field2, "Результат: Поиск строк с дублями");
            break;

        case 'splitIntoColumns':
            activateField(field1, "Исходный текст с разделителем", true);
            activateField(edit1, "Разделитель (по умолчанию - знак табуляции)", true);
            edit1.value = '\t'; // устанавливаем табуляцию по умолчанию
            edit2Container.style.display = 'none';
            activateField(field2, "Результат: Разделяет текст на две колонки; по умолчанию в тексте применяется разделитель - знак табуляции, или укажите другой)");
            break;

        case 'replaceTabWithNewline':
            activateField(field1, "Исходный текст", true);
            activateField(field2, "Результат: Заменяет знаки табуляции на перенос строки");
            break;

        case 'replaceTabWithText':
            activateField(edit1, "Заменить на этот текст", true);
            activateField(field2, "Результат: Заменяет знаки табуляции на указанный текст");
            break;

        case 'compareListsContains':
            activateField(field1, "Первый список для сравнения", true);
            activateField(field2, "Второй список для сравнения");
            edit1Container.style.display = 'none';
            edit2Container.style.display = 'none';
            break;

        case 'replaceAndCreateCSV':
            activateField(field1, "Исходный текст", true);
            activateField(field2, "Список для замены на символ разделителя в CSV (; или выберите другой)");
            activateField(edit1, "Разделитель CSV");
            edit1.value = ';';
            break;

        case 'multiFilter':
            activateField(edit1, "Фильтр 1", true);
            activateField(edit2, "Фильтр 2");
            activateField(field2, "1) В Фильтр1 вводятся фильтры, разделенные пробелами, осуществляется поиск текста, в котором фильтры располагаются в любом порядке;\n2) В Фильтр2 вводятся фильтры, разделенные пробелами, осуществляется поиск текста, где фильтры располагаются в том же порядке, в котором они указаны");
            break;

        case 'removeTextBeforeAfter':
            activateField(edit1, "Удалить до...", true);
            activateField(edit2, "Удалить после...", true);
            activateField(field2, "Результат: Удаляет текст до и после указанных паттернов");
            break;

        case 'removeTextBeforeAfterKeep':
            activateField(edit1, "Удалить до... (сохранить)", true);
            activateField(edit2, "Удалить после... (сохранить)");
            activateField(field2, "Результат: Удаляет текст до и после указанных паттернов, сохраняя сами паттерны");
            break;

        case 'joinByContent':
            activateField(field1, "Введите текст с двумя колонками (разделитель табуляция или ;)", true);
            activateField(field2, "Результат: Строки соединятся по условию: (Текст в колонке 1) содержится в (Тексте в колонке 2)");
            break;

        case 'replaceSpacesWithNewline':
            activateField(field1, "Исходный текст", true);
            activateField(field2, "Результат: Заменяет пробелы на перенос строки");
            break;

        case 'replaceSpacesWithTab':
            activateField(field1, "Исходный текст", true);
            activateField(field2, "Результат: Заменяет пробелы на знак табуляции");
            break;

        case 'replaceSpacesWithText':
            activateField(field1, "Исходный текст", true);
            activateField(edit1, "Текст для замены пробелов", true);
            activateField(field2, "Результат: Заменяет пробелы на указанный текст");
            break;

        case 'keepLinesBetween':
        case 'keepAndTrimLinesBetween':
        case 'sortByTextBetween':
            activateField(edit1, "Начало", true);
            activateField(edit2, "Конец", true);
            activateField(field2, "Результат: Сортирует по тексту между указанными текстами (и оставляет данные строки)");
            break;

        case 'filterLines':
            activateField(edit1, "Фильтр 1", true);
            activateField(edit2, "Фильтр 2 (необязательно)");
            activateField(field2, "Результат: Фильтрует строки по указанным критериям");
            break;

        case 'joinColumnsToCSV':
            activateField(field1, "Первая колонка", true);
            activateField(field2, "Вторая колонка");
            activateField(edit1, "Разделитель CSV");
            activateField(edit2, "Дополнительный текст (необязательно)");
            edit1.value = ';';
            break;

        case 'trim':
            activateField(field2, "Результат: Удаляет пробелы слева и справа от текста в строке,\nа также слева и справа от разделителей, если они указаны");
            activateField(edit1, "Разделитель 1 (необязательно)");
            activateField(edit2, "Разделитель 2 (необязательно)");
            break;

        case 'translate':
            activateField(field1, "Текст для перевода 1", true);
            activateField(field2, "Текст для перевода 2");
            break;

        case 'findUniqueWords':
            activateField(field1, "Исходный текст", true);
            activateField(field2, "Уникальные слова и числа");
            break;

        case 'findUniqueWordsNoNumbers':
            activateField(field1, "Исходный текст", true);
            activateField(field2, "Уникальные слова");
            break;

        case 'replace':
        case 'replaceAndKeep':
            activateField(edit1, "Найти", true);
            activateField(edit2, "Заменить на");
            activateField(field2, "Результат: Заменяет указанный текст");
            break;

        case 'keepLinesAfter':
            activateField(edit1, "После этого текста", true);
            activateField(field2, "Результат: Оставляет строки после указанного текста");
            break;

        case 'keepLinesBefore':
            activateField(edit1, "До этого текста", true);
            activateField(field2, "Результат: Оставляет строки до указанного текста");
            break;

        case 'replaceNewlineWithText':
            activateField(edit1, "Заменить на этот текст", true);
            activateField(field2, "Результат: Заменяет переносы строк на указанный текст");
            break;

        case 'replaceAndNewline':
            activateField(edit1, "Заменить этот текст", true);
            activateField(edit2, "На этот текст", true);
            activateField(field2, "Результат: Заменяет указанный текст и добавляет перенос строки");
            break;

        case 'extractBetween':
            activateField(edit1, "Текст1", true);
            activateField(edit2, "Текст2", true);
            activateField(field2, "Результат: Извлекает текст между указанными текстами");
            break;

        case 'compareLineByLine':
            activateField(field2, "Второй текст для сравнения");
            break;

        case 'compareLists':
            activateField(field2, "Второй список для сравнения");
            break;

        case 'removeDuplicates':
            activateField(field2, "Текст без дубликатов");
            break;

        default:
            activateField(field2, "Результат");
    }

    checkExecuteButton();
}



function checkExecuteButton() {
    const operation = document.getElementById('operation').value;
    const field1 = document.getElementById('field1');
    const edit1 = document.getElementById('edit1');
    const edit2 = document.getElementById('edit2');
    const executeButton = document.querySelector('button');

    let requiredFields = [];

    switch (operation) {
        case 'mergeFiles':
            // Для операции "Объединить текстовые файлы" не требуем заполнения field1 и field2
            requiredFields = [];
            break;

        case 'replace':
        case 'replaceWithNewline':
        case 'replaceAndNewline':
        case 'extractBetween':
        case 'keepLinesAfter':
        case 'keepLinesBefore':
        case 'replaceAndKeep':
        case 'removeLinesWithSpecificLength':
            // Проверяем, заполнено ли хотя бы одно из полей edit1 или edit2
            if (edit1.value.trim() || edit2.value.trim()) {
                requiredFields = [field1]; // Только field1 обязательное
            } else {
                requiredFields = [field1, { value: '' }]; // Добавляем фиктивное поле, чтобы кнопка была неактивной
            }
            break;

        default:
            requiredFields = [field1]; // По умолчанию требуем заполнения field1
    }

    // Проверяем, заполнены ли все обязательные поля
    const allFieldsFilled = requiredFields.every(field => field.value.trim() !== '');
    executeButton.disabled = !allFieldsFilled;
}

    
function removeTextBeforeAfter(text, before, after, caseSensitive) {
    const flags = caseSensitive ? 'g' : 'gi';
    const beforeRegex = new RegExp(`^.*?${escapeRegExp(before)}`, flags);
    const afterRegex = after ? new RegExp(`${escapeRegExp(after)}.*$`, flags) : null;

    return text.split('\n')
        .map(line => {
            // Удаляем текст до указанного паттерна
            let result = line.replace(beforeRegex, '');
            
            // Если указан паттерн "после", удаляем текст после него
            if (after && after.trim()) {
                result = result.replace(afterRegex, '');
            }
            
            return result.trim();
        })
        .filter(line => line.length > 0) // Удаляем пустые строки
        .join('\n');
}

function joinByContent(text) {
    // Разделяем входной текст на строки
    const lines = text.trim().split('\n');
    const result = [];
    
    // Проходим по каждой строке как по первой колонке
    for (const line1 of lines) {
        const columns1 = line1.split(/[\t;]/);
        if (columns1.length < 2) continue;
        
        const word1 = columns1[0].trim();
        const normalized1 = word1.normalize('NFD').replace(/[\u0300-\u036f]/g, '').toLowerCase();
        
        // Проходим по каждой строке как по второй колонке
        for (const line2 of lines) {
            const columns2 = line2.split(/[\t;]/);
            if (columns2.length < 2) continue;
            
            const text2 = columns2[1].trim();
            const normalized2 = text2.normalize('NFD').replace(/[\u0300-\u036f]/g, '').toLowerCase();
            
            // Если находим совпадение
            if (normalized2.includes(normalized1)) {
                result.push(`${word1}\t${text2}`);
                break; // Прерываем внутренний цикл после первого найденного совпадения
            }
        }
    }
    
    return result.join('\n');
}

function changeThemeColor(color) {
    const r = parseInt(color.substr(1,2), 16);
    const g = parseInt(color.substr(3,2), 16);
    const b = parseInt(color.substr(5,2), 16);
    const yiq = ((r*299)+(g*587)+(b*114))/1000;
    const textColor = (yiq >= 128) ? 'black' : 'white';

    // Проверка на белый или близкий к белому цвет фона
    const isWhiteBackground = (r > 240 && g > 240 && b > 240);
    const placeholderColor = isWhiteBackground ? '#898989' : textColor;

    document.documentElement.style.setProperty('--bg-color', color);
    document.documentElement.style.setProperty('--text-color', textColor);
    document.documentElement.style.setProperty('--element-bg', adjustColor(color, 20));
    document.documentElement.style.setProperty('--element-shadow', adjustColor(color, -20));
    document.documentElement.style.setProperty('--element-highlight', adjustColor(color, 40));
    document.documentElement.style.setProperty('--placeholder-color', placeholderColor); // Добавлено для placeholder

    updateExecuteIcon(textColor);

    saveThemeColor(color);

    document.getElementById('colorPicker').value = color;
}


    function saveThemeColor(color) {
        localStorage.setItem('themeColor', color);
    }

    function loadThemeColor() {
        return localStorage.getItem('themeColor') || '#ffffff';
    }

    function saveOperationToLocalStorage(operation) {
    localStorage.setItem('selectedOperation', operation);
}


function groupLinesByKeyWord(text, keyWord, delimiter) {
    if (!keyWord) {
        return text;
    }

    const lines = text.split('\n').filter(line => line.trim());
    const customDelimiter = delimiter || '\t';
    let currentHeader = '';
    const result = [];
    
    lines.forEach(line => {
        if (line.includes(keyWord)) {
            currentHeader = line.trim();
            result.push(currentHeader + customDelimiter);
        } else if (currentHeader && line.trim()) {
            result.push(currentHeader + customDelimiter + line.trim());
        } else if (line.trim()) {
            result.push(line.trim());
        }
    });

    return result.join('\n');
}

function downloadTextFile(content, filename = 'output.txt') {
    const blob = new Blob([content], { type: 'text/plain' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    a.click();
    URL.revokeObjectURL(url);
}


function mergeFiles() {
    const edit1 = document.getElementById('edit1').value;
    const edit2 = document.getElementById('edit2').value;
    const field1 = document.getElementById('field1');
    const field2 = document.getElementById('field2');

    // Создаем input для выбора файлов
    const fileInput = document.createElement('input');
    fileInput.type = 'file';
    fileInput.multiple = true;
    fileInput.accept = '*'; // Фильтр для всех файлов

    fileInput.onchange = async function (event) {
        const files = event.target.files;
        let contentField1 = '';
        let contentField2 = '';

        for (let i = 0; i < files.length; i++) {
            const file = files[i];
            const reader = new FileReader();

            // Обрабатываем файл
            await new Promise((resolve) => {
                reader.onload = function (e) {
                    const arrayBuffer = e.target.result;
                    const uint8Array = new Uint8Array(arrayBuffer);

                    // Декодируем как UTF-8
                    let decodedContent = decodeContent(uint8Array, 'utf-8');
                    let encoding = 'UTF-8';

                    // Если есть недопустимые символы, пробуем Windows-1251 (ANSI)
                    if (containsInvalidCharacters(decodedContent)) {
                        decodedContent = decodeContent(uint8Array, 'windows-1251');
                        encoding = 'Windows-1251';
                    }

                    // Добавляем содержимое файла в field1
                    contentField1 += decodedContent + '\n';

                    // Добавляем содержимое файла в field2 с учетом текста из edit1 и edit2
                    contentField2 += decodedContent;

                    // Добавляем текст из edit1 и edit2 между файлами
                    if (i < files.length - 1) {
                        if (edit1) {
                            contentField2 += '\n' + edit1;
                        }
                        if (edit2) {
                            if (!isNaN(edit2)) {
                                // Если edit2 - число, добавляем edit1 указанное количество раз
                                const repeatCount = parseInt(edit2);
                                for (let j = 0; j < repeatCount; j++) {
                                    contentField2 += '\n' + edit1;
                                }
                            } else {
                                // Если edit2 - текст, добавляем его
                                contentField2 += '\n' + edit2;
                            }
                        }
                        contentField2 += '\n';
                    }

                    resolve();
                };

                // Читаем файл как ArrayBuffer
                reader.readAsArrayBuffer(file);
            });
        }

        // Все файлы обработаны, обновляем поля
        field1.value = contentField1.trim();
        field2.value = contentField2.trim();
        updateStatistics();

        // Скачиваем содержимое field2 в текстовый файл
        downloadTextFile(contentField2.trim(), 'output.txt');
    };

    // Запускаем выбор файлов
    fileInput.click();
}


function decodeContent(uint8Array, encoding) {
    try {
        const decoder = new TextDecoder(encoding);
        return decoder.decode(uint8Array);
    } catch (error) {
        console.error('Ошибка декодирования:', error);
        return 'Ошибка при чтении файла';
    }
}

function containsInvalidCharacters(text) {
    const invalidChars = /[\uFFFD]/gu; // Символы замены ( )
    return invalidChars.test(text);
}


function removeTextBeforeAfterKeep(text, before, after, caseSensitive) {
    const flags = caseSensitive ? 'g' : 'gi';
    const beforeRegex = new RegExp(`^.*?(${escapeRegExp(before)})`, flags);
    const afterRegex = after ? new RegExp(`(${escapeRegExp(after)}).*$`, flags) : null;

    return text.split('\n')
        .map(line => {
            let result = line;
            
            // Находим совпадение для текста "до"
            const beforeMatch = line.match(beforeRegex);
            const beforeText = beforeMatch ? beforeMatch[1] : '';
            
            // Находим совпадение для текста "после"
            const afterMatch = after ? line.match(afterRegex) : null;
            const afterText = afterMatch ? afterMatch[1] : '';
            
            // Удаляем текст до указанного паттерна, сохраняя сам паттерн
            result = result.replace(beforeRegex, '$1');
            
            // Если указан паттерн "после", удаляем текст после него, сохраняя сам паттерн
            if (after && after.trim()) {
                result = result.replace(afterRegex, '$1');
            }
            
            return result.trim();
        })
        .filter(line => line.length > 0) // Удаляем пустые строки
        .join('\n');
}

function replaceAndCreateCSV(sourceText, replacementList, separator) {
    const lines = replacementList.split('\n');
    let csvContent = sourceText;

    lines.forEach(line => {
        if (line) {
            // Экранируем специальные символы регулярных выражений
            const escapedLine = line.replace(/[-\/\\^$*+?.()|[$${}]/g, '\\$&');
            // Используем глобальный флаг 'g' для замены всех вхождений
            const regex = new RegExp(escapedLine, 'g');
            csvContent = csvContent.replace(regex, separator);
        }
    });

    // Создаем и скачиваем CSV файл
    const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
    const link = document.createElement("a");
    if (link.download !== undefined) {
        const url = URL.createObjectURL(blob);
        link.setAttribute("href", url);
        link.setAttribute("download", "replaced_content.csv");
        link.style.visibility = 'hidden';
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
    }

    showNotification('CSV файл с заменами создан и скачан');
}

function findDuplicates(text, caseSensitive) {
    const lines = text.split('\n');
    const countMap = new Map();
    
    // Подсчитываем количество каждой строки
    lines.forEach(line => {
        const trimmedLine = line.trim();
        if (trimmedLine) {
            const key = caseSensitive ? trimmedLine : trimmedLine.toLowerCase();
            countMap.set(key, {
                originalText: trimmedLine,
                count: (countMap.get(key)?.count || 0) + 1
            });
        }
    });

    // Формируем список дублей (строк, которые встречаются более одного раза)
    const duplicates = Array.from(countMap.entries())
        .filter(([_, data]) => data.count > 1)
        .map(([_, data]) => data.originalText)
        .sort();

    // Формируем список дублей с количеством
    const duplicatesWithCount = Array.from(countMap.entries())
        .filter(([_, data]) => data.count > 1)
        .map(([_, data]) => `${data.originalText}(${data.count})`)
        .sort();

    // Объединяем результаты с тремя пустыми строками между списками
    return duplicates.join('\n') + '\n\n\n\n' + duplicatesWithCount.join('\n');
}

function loadOperationFromLocalStorage() {
    return localStorage.getItem('selectedOperation');
}

    function copyText(fieldId) {
        const textarea = document.getElementById(fieldId);
        textarea.select();
        document.execCommand('copy');

        const icon = textarea.nextElementSibling;
        icon.classList.add('flash');
        setTimeout(() => {
            icon.classList.remove('flash');
        }, 300);
    }

    function adjustColor(color, amount) {
        return '#' + color.replace(/^#/, '').replace(/../g, color => ('0'+Math.min(255, Math.max(0, parseInt(color, 16) + amount)).toString(16)).substr(-2));
    }

    function updateExecuteIcon(textColor) {
        const executeIcon = document.querySelector('button .icon');
        executeIcon.src = `https://img.icons8.com/material-outlined/24/${textColor === 'white' ? 'ffffff' : '000000'}/play--v1.png`;
    }

function multiFilter(text, filter1, filter2, caseSensitive) {
    const flags = caseSensitive ? '' : 'i';
    const filter1Array = filter1.split(/\s+/);
    const filter2Array = filter2 ? filter2.split(/\s+/) : [];

    return text.split('\n')
        .filter(line => {
            let currentIndex = 0;

            // Проверяем соответствие фильтру 1
            for (const f1 of filter1Array) {
                if (!new RegExp(escapeRegExp(f1), flags).test(line)) {
                    return false;
                }
            }

            // Проверяем соответствие фильтру 2
            if (filter2Array.length > 0) {
                for (const f2 of filter2Array) {
                    const nextIndex = line.indexOf(f2, currentIndex);
                    if (nextIndex === -1) {
                        return false;
                    }
                    currentIndex = nextIndex;
                }
            }

            return true;
        })
        .join('\n');
}


function saveWordWrapState(state) {
    localStorage.setItem('wordWrapState', state);
}

function loadWordWrapState() {
    return localStorage.getItem('wordWrapState') || 'pre-wrap';
}



function initializeApp() {
    const operationSelect = document.getElementById('operation');
    const allInputs = document.querySelectorAll('textarea, input[type="text"]');

    const savedOperation = loadOperationFromLocalStorage();
    if (savedOperation && operationSelect) {
        operationSelect.value = savedOperation;
    }

    if (operationSelect) {
        operationSelect.addEventListener('change', () => {
            const selectedOperation = operationSelect.value;
            saveOperationToLocalStorage(selectedOperation);
            updatePlaceholders();
            checkExecuteButton();
        });
        updatePlaceholders();
    } else {
        console.error('Operation select element not found');
    }

    allInputs.forEach(input => {
        input.addEventListener('input', checkExecuteButton);
    });

    const savedColor = loadThemeColor();
    changeThemeColor(savedColor);
    updatePlaceholders();
}

function initializeWordWrapState() {
    const savedState = loadWordWrapState();
    const field1 = document.getElementById('field1');
    const field2 = document.getElementById('field2');

    field1.style.whiteSpace = savedState;
    field2.style.whiteSpace = savedState;
}

window.addEventListener('load', initializeWordWrapState);


document.getElementById('caseSensitive').addEventListener('dblclick', function() {
    const field1 = document.getElementById('field1');
    const field2 = document.getElementById('field2');

    // Переключаем перенос слов
    const newState = field1.style.whiteSpace === 'pre-wrap' ? 'nowrap' : 'pre-wrap';
    field1.style.whiteSpace = newState;
    field2.style.whiteSpace = newState;

    // Сохраняем состояние в localStorage
    saveWordWrapState(newState);
});



document.getElementById('status-bar').addEventListener('dblclick', function() {
    const field1 = document.getElementById('field1');
    const field2 = document.getElementById('field2');

    // Сохраняем текущее содержимое поля field1
    const temp = field1.value;

    // Меняем местами содержимое полей
    field1.value = field2.value;
    field2.value = temp;

    // Обновляем статистику для обоих полей, если функция updateStatistics определена
    if (typeof updateStatistics === "function") {
        updateStatistics();
    }
});

document.getElementById('field1').addEventListener('input', updateStatistics);
document.getElementById('field1').addEventListener('keyup', updateStatistics);
document.getElementById('field1').addEventListener('click', updateStatistics);

document.getElementById('field2').addEventListener('input', updateStatistics);
document.getElementById('field2').addEventListener('keyup', updateStatistics);
document.getElementById('field2').addEventListener('click', updateStatistics);


 document.getElementById('translateBtn').addEventListener('click', translate);

document.getElementById('field1').addEventListener('input', updateStatistics);
document.getElementById('field2').addEventListener('input', updateStatistics);
    window.addEventListener('load', initializeApp);
    window.addEventListener('load', updateStatistics);
    
    
    
    
</script>
</body>
</html>


