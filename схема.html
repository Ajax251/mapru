<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Схема по координатам</title>
    <link href="webfonts/all.min.css" rel="stylesheet">
    <link rel="stylesheet" href="webfonts/all.min.css">
<link rel="icon" href="img/xy.png" type="image/png">
<script src="webfonts/proj4.js"></script>

<script src="webfonts/jszip.min.js"></script>
<script src="webfonts/xlsx.full.min.js"></script>
   <style>
    :root {
        --primary-color: #3498db;
        --secondary-color: #2ecc71;
        --background-color: #f0f3f6;
        --text-color: #333;
        --border-radius: 8px;
        --box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
    }

    body {
        font-family: 'Arial', sans-serif;
        background-color: var(--background-color);
        color: var(--text-color);
        line-height: 1.6;
        margin: 0;
        padding: 20px;
        display: flex;
        flex-direction: column;
        min-height: 100vh;
    }

    #content {
        max-width: 800px;
        margin: 0 auto;
        background-color: #fff;
        border-radius: var(--border-radius);
        box-shadow: var(--box-shadow);
        padding: 30px;
        flex-grow: 1;
    }

    h1 {
        color: var(--primary-color);
        text-align: center;
        margin-bottom: 30px;
    }

    #coordsInput {
        width: 100%;
        height: 150px;
        border: 2px solid var(--primary-color);
        border-radius: var(--border-radius);
        padding: 10px;
        font-size: 14px;
        resize: vertical;
        transition: border-color 0.3s ease;
    }

    #coordsInput:focus {
        outline: none;
        border-color: var(--secondary-color);
    }

  .button-container {
    display: flex;
    gap: 15px;
    margin-top: 20px;
    justify-content: center;
}

.custom-button {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 10px;
    padding: 15px 25px;
    border: none;
    border-radius: 8px;
    cursor: pointer;
    font-size: 16px;
    color: white;
    transition: all 0.3s ease;
    box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
}

.custom-button:hover {
    transform: translateY(-2px);
    box-shadow: 0 6px 10px rgba(0, 0, 0, 0.2);
}

.custom-button:active {
    transform: translateY(0);
    box-shadow: 0 3px 6px rgba(0, 0, 0, 0.15);
}

.custom-button i {
    font-size: 18px;
    transition: transform 0.3s ease;
}

.custom-button:hover i {
    transform: scale(1.2);
}

.dxf-button {
    background: linear-gradient(145deg, #4285F4, #357ABD);
}

.mif-button {
    background: linear-gradient(145deg, #FF4444, #CC0000);
}

.csv-button {
    background: linear-gradient(145deg, #4CAF50, #45a049);
}

/* Add ripple effect */
.custom-button {
    position: relative;
    overflow: hidden;
}

.custom-button::after {
    content: '';
    position: absolute;
    top: 50%;
    left: 50%;
    width: 300%;
    height: 300%;
    background: rgba(255, 255, 255, 0.4);
    transform: translate(-50%, -50%) scale(0);
    border-radius: 50%;
    opacity: 0;
    pointer-events: none;
}

.custom-button:active::after {
    animation: ripple 0.6s ease;
}

@keyframes ripple {
    0% {
        transform: translate(-50%, -50%) scale(0);
        opacity: 1;
    }
    100% {
        transform: translate(-50%, -50%) scale(1);
        opacity: 0;
    }
}

/* Mobile responsiveness */
@media (max-width: 768px) {
    .button-container {
        flex-direction: column;
    }
    
    .custom-button {
        width: 100%;
    }
}

    #canvas {
        max-width: 100%;
        height: auto;
        margin: 30px auto;
        display: block;
        border: 2px solid var(--primary-color);
        border-radius: var(--border-radius);
    }

    #log, #distanceLog {
        background-color: #fff;
        border: 1px solid #ddd;
        border-radius: var(--border-radius);
        padding: 15px;
        margin-top: 20px;
    }

    .comboBoxContainer {
        display: flex;
        justify-content: center;
        gap: 20px;
        margin-top: 20px;
    }

    select {
        padding: 8px;
        border: 1px solid var(--primary-color);
        border-radius: var(--border-radius);
        font-size: 14px;
    }

    #notification {
        position: fixed;
        bottom: 20px;
        right: 20px;
        background-color: var(--secondary-color);
        color: #fff;
        padding: 10px 20px;
        border-radius: var(--border-radius);
        box-shadow: var(--box-shadow);
        display: none;
    }

    
    .import-button {
    display: inline-flex; /* Используем inline-flex вместо flex */
    align-items: center;
    justify-content: center;
    gap: 10px;
    padding: 10px 20px; /* Уменьшим padding для компактности */
    border: none;
    border-radius: 8px;
    cursor: pointer;
    font-size: 14px; /* Уменьшим размер шрифта */
    color: white;
    transition: all 0.3s ease;
    box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
    background: linear-gradient(145deg, #9b59b6, #8e44ad); /* Фиолетовый градиент */
    position: fixed; /* Используем fixed для фиксации в правом верхнем углу */
    top: 20px;
    right: 20px;
    z-index: 1000; /* Убедимся, что кнопка поверх других элементов */
    width: auto; /* Убедимся, что ширина определяется содержимым */
    white-space: nowrap; /* Запрещаем перенос текста */
}

.import-button:hover {
    transform: translateY(-2px);
    box-shadow: 0 6px 10px rgba(0, 0, 0, 0.2);
}

.import-button:active {
    transform: translateY(0);
    box-shadow: 0 3px 6px rgba(0, 0, 0, 0.15);
}

.import-button i {
    font-size: 16px; /* Уменьшим размер иконки */
    transition: transform 0.3s ease;
}

.import-button:hover i {
    transform: scale(1.2);
}

/* Эффект ripple */
.import-button::after {
    content: '';
    position: absolute;
    top: 50%;
    left: 50%;
    width: 300%;
    height: 300%;
    background: rgba(255, 255, 255, 0.4);
    transform: translate(-50%, -50%) scale(0);
    border-radius: 50%;
    opacity: 0;
    pointer-events: none;
}

.import-button:active::after {
    animation: ripple 0.6s ease;
}

@keyframes ripple {
    0% {
        transform: translate(-50%, -50%) scale(0);
        opacity: 1;
    }
    100% {
        transform: translate(-50%, -50%) scale(1);
        opacity: 0;
    }
}


    .dropdown-content {
        display: none;
        position: absolute;
        background-color: #f9f9f9;
        min-width: 160px;
        box-shadow: var(--box-shadow);
        z-index: 1;
        border-radius: var(--border-radius);
    }

    .dropdown-content a {
        color: var(--text-color);
        padding: 12px 16px;
        text-decoration: none;
        display: block;
    }

    .dropdown-content a:hover {
        background-color: #f1f1f1;
    }

    .show {
        display: block;
    }

    #bottomContainer {
        margin-top: auto;
    }
    
     #coordsInput {
      
           text-align: center; 
    }

    #pointsList textarea {
        width: 100%;
        border: 2px solid var(--primary-color);
        border-radius: var(--border-radius);
        padding: 10px;
        font-size: 14px;
        resize: vertical;
    }

    .btn-copy, .btn-add-to-list {
        background-color: var(--secondary-color);
        color: white;
        border: none;
        border-radius: var(--border-radius);
        cursor: pointer;
        transition: background-color 0.3s;
        padding: 5px 10px;
        font-size: 14px;
    }

    .btn-copy:hover, .btn-add-to-list:hover {
        background-color: #27ae60;
    }
    
.clickable-area, .clickable-perimeter {
    cursor: pointer;
}


.scheme-button {
    position: fixed;
    bottom: 20px;
    left: 20px;
    background-color: #3498db;
    color: white;
    padding: 10px 20px;
    border-radius: 5px;
    cursor: pointer;
    z-index: 1000;
    display: flex;
    align-items: center;
    gap: 8px; /* отступ между иконкой и текстом */
    transition: background-color 0.3s ease;
}

.scheme-button:hover {
    background-color: #2980b9;
}

.scheme-button i {
    font-size: 16px;
}

.scheme-menu {
    display: none;
    position: fixed;
    bottom: 70px;
    left: 20px; 
    background-color: white;
    border: 1px solid #ccc;
    border-radius: 5px;
    padding: 10px;
    z-index: 1000;
}

    .scheme-menu div {
        cursor: pointer;
        padding: 5px;
    }

    .scheme-menu div:hover {
        background-color: #f0f0f0;
    }

    .width-dialog {
        display: none;
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background-color: white;
        border: 1px solid #ccc;
        border-radius: 5px;
        padding: 20px;
        z-index: 1001;
    }

    .width-dialog input {
        width: 100%;
        margin-bottom: 10px;
    }

    .width-dialog button {
        margin-right: 10px;
    }
    
    #calculateDistances {
    cursor: pointer;
    padding: 5px;
}

#calculateDistances:hover {
    background-color: #f0f0f0;
}





.canvas-container {
    position: relative;
    display: inline-block;
    margin: 30px auto;
    width: 100%;
    max-width: 800px;
}

.eye-button {
    position: absolute;
    left: 20px;
    bottom: -50px; /* Размещаем под canvas */
    width: 40px;
    height: 40px;
    background: rgba(52, 152, 219, 0.8);
    border: 2px solid white;
    border-radius: 50%;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    box-shadow: 0 2px 5px rgba(0,0,0,0.2);
}

.eye-button::before {
    content: '';
    width: 20px;
    height: 20px;
    background: white;
    border-radius: 50%;
}

.eye-button.no-labels::after {
    content: '';
    position: absolute;
    width: 100%;
    height: 2px;
    background: red;
    transform: rotate(0deg);
}

.eye-button.no-points::after {
    content: '';
    position: absolute;
    width: 100%;
    height: 2px;
    background: red;
    transform: rotate(45deg);
}

.eye-button.only-drawing::after {
    content: '';
    position: absolute;
    width: 100%;
    height: 2px;
    background: red;
    transform: rotate(90deg);
}


.eye-button.no-distances::after {
    content: '';
    position: absolute;
    width: 100%;
    height: 2px;
    background: red;
    transform: rotate(135deg);
}

/* Медиа-запрос для мобильных устройств */


#canvas {
    width: 100%;
    height: auto;
    border: 2px solid var(--primary-color);
    border-radius: var(--border-radius);
    cursor: grab;
    touch-action: none;
}

#canvas:active {
    cursor: grabbing;
}


#addToDrawing {
    cursor: pointer;
    padding: 5px;
}

#addToDrawing:hover {
    background-color: #f0f0f0;
}

.json-button {
    background: linear-gradient(145deg, #f39c12, #e67e22); /* Оранжевый градиент */
}

/* Стили для модального окна обрезки (для Схемы по координатам) */
#crop-image-modal-scheme {
    display: none; /* Скрыто по умолчанию */
    /* ... (остальные стили из предыдущего ответа, если они подходят) ... */
}

.crop-modal-content-wrapper-scheme {
    background-color:white;
    padding:20px;
    border-radius:10px;
    box-shadow:0 0 15px rgba(0,0,0,0.5);
    max-width:95vw;
    max-height:95vh;
    overflow:auto;
    text-align:center;
    border: 3px solid lime; 
}

#crop-image-container-scheme {
    position:relative;
    display:inline-block;
    border:1px dashed #ccc;
    user-select:none;
    touch-action:none;
    max-width:100%;
    max-height:calc(85vh - 120px);
    overflow:hidden;
    cursor:crosshair;
}
#crop-image-preview-scheme {
    display:block;
    max-width:100%;
    max-height:100%;
    user-select:none;
    -webkit-user-drag:none;
}
#crop-selection-rectangle-scheme {
    position:absolute;
    border:2px solid rgba(0,123,255,0.7);
    background-color:rgba(0,123,255,0.1);
    display:none;
    pointer-events:none;
}
.crop-modal-buttons-scheme button {
    padding:10px 20px;
    color:white;
    border:none;
    border-radius:5px;
    cursor:pointer;
    margin-right:10px;
}
/* Кнопка "Обрезать" */
#crop-image-button-confirm-scheme {
    background-color: #4CBB17 !important; /* Зелёный */
    color: white;
    border: none;
    border-radius: 5px;
    cursor: pointer;
    padding: 10px 20px;
    font-size: 0.9rem;
    transition: transform 0.2s ease; /* Только анимация масштабирования */
}

/* Кнопка "Отмена" */
#crop-image-button-cancel-scheme {
    background-color: #FF2C2C !important; /* Красный */
    color: white;
    border: none;
    border-radius: 5px;
    cursor: pointer;
    padding: 10px 20px;
    font-size: 0.9rem;
    transition: transform 0.2s ease; /* Только анимация масштабирования */
}

#crop-image-button-confirm-scheme,
#crop-image-button-cancel-scheme {
    transition: transform 0.2s ease;
}

#crop-image-button-confirm-scheme:hover {
    transform: scale(1.05);
}

#crop-image-button-cancel-scheme:hover {
    transform: scale(1.05);
}

.json-button {
    background: linear-gradient(145deg, #f39c12, #e67e22); /* Оранжевый градиент */
}

.xml-button {
    background: linear-gradient(145deg, #8e44ad, #9b59b6); /* Фиолетовый градиент */
}


.editor-button {
    background: linear-gradient(145deg, #ff7f50, #ff6347); /* Coral/Tomato gradient */
}

.eye-button.points-distances-only::after {
    content: '';
    position: absolute;
    width: 100%;
    height: 2px;
    background: red;
    transform: rotate(180deg);
}

</style>
    </head>
<body>
<button class="import-button" onclick="importFile()">
    <i class="fas fa-file-import"></i>
    <span></span>
</button>


    <div class="dropdown-content" id="importDropdown">
        <a href="#" onclick="importXML()">
            <i class="fas fa-file-code"></i>
            XML
        </a>
        <a href="#" onclick="importDXF()">
            <i class="fas fa-drafting-compass"></i>
            DXF
        </a>
        <a href="#" onclick="importMIF()">
            <i class="fas fa-map-marked-alt"></i>
            MIF
        </a>
        <a href="#" onclick="importCSV()">
            <i class="fas fa-file-excel"></i>
            CSV
        </a>
    </div>
</div>

<div id="content">
    <h1>Схема по координатам</h1>
<textarea id="coordsInput" rows="10" cols="30" placeholder="Введите координаты в формате XY или вставьте изображение" oninput="handleInput()"></textarea>
<div class="button-container">
    <button class="custom-button dxf-button" onclick="generateAndDownloadDXF()">
        <i class="fas fa-drafting-compass"></i>
        <span>DXF</span>
    </button>
    <button class="custom-button mif-button" onclick="generateAndDownloadMIF()">
        <i class="fas fa-map"></i>
        <span>MIF</span>
    </button>
    <button class="custom-button csv-button" onclick="generateAndDownloadCSV()">
        <i class="fas fa-file-excel"></i>
        <span>CSV</span>
    </button>
    <button class="custom-button json-button" onclick="generateAndDownloadJSON()">
        <i class="fas fa-file-code"></i>
        <span>JSON</span>
    </button>
    <button class="custom-button xml-button" onclick="generateAndDownloadXML()">
        <i class="fas fa-code"></i>
        <span></span>
    </button>
    <button class="custom-button map-button" onclick="copyCoordinatesAndOpenMap()">
         <i class="fas fa-globe"></i>
        <span></span>
    </button>
    
    <button class="custom-button editor-button" onclick="openEditor()">
    <i class="fas fa-edit"></i>
    <span></span>
</button>

</div>

<div class="canvas-container">
    <canvas id="canvas" width="600" height="600"></canvas>
    <div id="eyeButton" class="eye-button"></div>
</div>

    <div id="log"></div>
    <div id="bottomContainer">
        <div id="comboBoxContainer" class="comboBoxContainer"></div>
        <div id="distanceLog"></div>
        <div id="pointsList"></div>
    </div>
</div>

<div id="notification"></div>

<div id="schemeButton" class="scheme-button">
    <i class="fas fa-ruler"></i>
    <span></span>
</div>

<div id="schemeMenu" class="scheme-menu">
    <div id="calculateDistances" onclick="checkDistances(); return false;">Расстояние между точками</div>    
    <div id="expandLinearObject">Расширить линейный объект</div>
    <div id="addToDrawing">Добавить из файла</div>
    <div id="openDXFButton">DXF</div>
    <div id="generateTXT" onclick="generateTXTFile()">TXT</div> <!-- Новый пункт -->
</div>


<div id="widthDialog" class="width-dialog">
    <h3>Укажите ширину в метрах:</h3>
    <input type="number" id="widthInput" min="0" step="0.01">
    <button id="applyWidth">Применить</button>
    <button id="cancelWidth">Отмена</button>
</div>

<div id="aiLoader" style="display: none; position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%); background-color: #ffc107; color: #333; padding: 10px 20px; border-radius: var(--border-radius); box-shadow: var(--box-shadow); z-index: 1001; align-items: center; gap: 10px;">
    <i class="fas fa-spinner fa-spin"></i>
    <span>Распознавание координат из изображения...</span>
</div>
    
    
    <!-- CROP MODAL HTML (для Схемы по координатам) -->
<div id="crop-image-modal-scheme" style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; background-color:rgba(0,0,0,0.7); z-index:10001; justify-content:center; align-items:center; flex-direction: column;">
    <div class="crop-modal-content-wrapper-scheme" style="background-color:white; padding:20px; border-radius:10px; box-shadow:0 0 15px rgba(0,0,0,0.5); max-width:95vw; max-height:95vh; overflow:auto; text-align:center;">
        <h3 style="margin-top:0;">Обрезать изображение</h3>
        <p style="font-size:0.9em; color:#555;">Нажмите и перетащите на изображении, чтобы выбрать область.</p>
        <div id="crop-image-container-scheme" style="position:relative; display:inline-block; border:1px dashed #ccc; user-select:none; touch-action:none; max-width:100%; max-height:calc(85vh - 120px); overflow:hidden; cursor:crosshair;">
            <img id="crop-image-preview-scheme" src="#" alt="Preview" style="display:block; max-width:100%; max-height:100%; user-select:none; -webkit-user-drag:none;" />
            <div id="crop-selection-rectangle-scheme" style="position:absolute; border:2px solid rgba(0,123,255,0.7); background-color:rgba(0,123,255,0.1); display:none; pointer-events:none;"></div>
        </div>
            <div class="crop-modal-buttons-scheme" style="margin-top:15px; display: flex; justify-content: center; gap: 15px;">
  <!-- Кнопка "Обрезать" -->
<button id="crop-image-button-confirm-scheme"
        style="padding:10px 20px; background-color:#4CBB17; color:white; border:none; border-radius:8px; cursor:pointer; display: flex; align-items: center; justify-content: center; gap: 5px; font-size: 0.9rem; transition: transform 0.2s ease;">
    <i class="fas fa-check" style="font-size: 1rem;"></i>Применить
</button>

<!-- Кнопка "Отмена" -->
<button id="crop-image-button-cancel-scheme"
        style="padding:10px 20px; background-color:#FF2C2C; color:white; border:none; border-radius:8px; cursor:pointer; display: flex; align-items: center; justify-content: center; gap: 5px; font-size: 0.9rem; transition: transform 0.2s ease;">
    <i class="fas fa-times" style="font-size: 1rem;"></i>Выбрать все
</button>
</div>
    </div>
</div>
<!-- END CROP MODAL HTML -->
    
    <script>
    
 
let zoomLevel = 1;
let panX = 0;
let panY = 0;
let isDragging = false;
let lastX = 0;
let lastY = 0;

let showLabels = true;
let showPoints = true;
let eyeState = 0; 

let showRulers = true;

let showDistances = true;

let cropSelectionScheme = { startX: 0, startY: 0, endX: 0, endY: 0, isDrawing: false };
let imageNaturalSizeScheme = { width: 0, height: 0 };
let imageDisplaySizeScheme = { width: 0, height: 0 };
let cropModalResolveScheme = null;

const VERCEL_PROXY_BASE_URL = "https://ver-olive-delta.vercel.app";



async function getCoordinatesFromImageAI(base64ImageData) {
    const aiLoader = document.getElementById('aiLoader');
    if (aiLoader) {
        aiLoader.querySelector('span').textContent = 'Распознавание координат из изображения...';
        aiLoader.style.display = 'flex';
    }

    const prompt = `Extract all numerical coordinates from this image.
Present them as two columns separated by a tab character (\\t).
The first coordinate in a pair (X) must always be less than the second coordinate (Y). If the original X > Y, swap them.
Each coordinate pair (X\\tY) should be on a new line.

Important: Regarding the number of digits before the decimal point:
1. Typically, one coordinate in a pair has 6 digits before the decimal point (e.g., "123456.78") and the other has 7 digits (e.g., "1234567.89").
2. If you identify a pair where one coordinate has 7 digits before the decimal point (like Y in "123.45\\t1234567.89"), and the other coordinate (X) has significantly fewer than 6 digits (e.g., only 3 digits as in "123.45"), please carefully re-examine the image. Look for any potentially obscured or missed leading digits in the shorter coordinate. Your goal is to extract a 6-digit number for X if it is visually supported by the image context. The aim is to accurately represent what is present or very strongly implied.

Do not include any headers, descriptions, comments, markdown formatting (e.g., \`\`\`), or any characters other than the coordinates themselves and the delimiters (tab and newline).
Numbers should have no more than two decimal places. Round mathematically.
If there are no coordinates in the image or you cannot recognize them, return an empty response. If for some reason you must write an explanatory message, it MUST be in Russian (for example: "Координаты на изображении не найдены"). Do not respond in English.
Example of correct output:
123456.78\\t1234567.89
654321.00\\t7654321.00
100000.10\\t2000000.20`;

    const requestUrl = `${VERCEL_PROXY_BASE_URL}/v1beta/models/gemini-2.5-flash-lite-preview-06-17:generateContent`;

    try {
        const response = await fetch(requestUrl, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
                contents: [{
                    role: "user",
                    parts: [
                        { text: prompt },
                        { inlineData: { mimeType: "image/jpeg", data: base64ImageData } }
                    ]
                }]
            })
        });

        const data = await response.json();

        if (!response.ok) {
            const errorDetail = data?.error?.message || `Статус ${response.status}`;
            console.error("Vercel Proxy Error (Image):", data);
            throw new Error(`Ошибка AI прокси: ${errorDetail}`);
        }

        if (data.candidates?.[0]?.content?.parts?.[0]?.text) {
            return data.candidates[0].content.parts[0].text;
        } else if (data.candidates?.[0]?.finishReason === 'SAFETY') {
            throw new Error("Ответ заблокирован моделью по соображениям безопасности.");
        } else {
            console.warn("Vercel Proxy response structure not as expected (Image):", data);
            return "";
        }
    } catch (error) {
        console.error("Error calling Vercel Proxy API (Image):", error);
        throw error;
    } finally {
        if (aiLoader) aiLoader.style.display = 'none';
    }
}

async function getCoordinatesFromTextAI(textData) {
    const aiLoader = document.getElementById('aiLoader');
    if (aiLoader) {
        aiLoader.querySelector('span').textContent = 'Распознавание координат из текста...';
        aiLoader.style.display = 'flex';
    }

    const prompt = `Extract all numerical X and Y coordinates from the provided text.
The input text might be a JSON-like structure where coordinate data is organized into "contours". Each contour is an array of point objects (e.g., \`[ { "x": XVAL, "y": YVAL, ... }, ... ]\`). Sometimes these contour arrays are nested within a larger "contours" key, like \`"contours": [ [ {point1}, {point2} ], [ {point3}, {point4} ] ] \`.
Your task is to process these points sequentially as they appear in the input:
1.  For each point object, extract the "x" and "y" values.
2.  Ensure that the first coordinate (X) is always numerically less than the second coordinate (Y). If you find a pair where X > Y, swap them. Example: if input is {"x": 2222222.22, "y": 111111.11}, the pair to format is 111111.11 and 2222222.22.
3.  Format the extracted coordinates as two columns separated by a tab character (\`\\t\`): \`X_value\\tY_value\`.
4.  Each formatted coordinate pair should be on a new line.
5.  Numbers should have no more than two decimal places (round mathematically).
6.  **Crucially: Preserve all points as they appear in each contour. If a contour's first and last point objects are identical (based on their "x" and "y" values, indicating a closed loop), you MUST output both the first occurrence and the last occurrence of this point for that contour.**

Do not include any headers, explanations, comments, or markdown formatting (like \`\`\`) in your response. Only output the formatted coordinates.
If you cannot find any coordinates in the text, you must return an empty response. If for some reason you must write an explanatory message, it MUST be in Russian (for example: "Координаты в тексте не найдены"). Do not use English for explanations like "The provided text does not contain...".
The following is the text to process:
---
${textData}
---
`;
    
    const requestUrl = `${VERCEL_PROXY_BASE_URL}/v1beta/models/gemini-2.5-flash-lite-preview-06-17:generateContent`;

    try {
        const response = await fetch(requestUrl, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
                contents: [{
                    role: "user",
                    parts: [{ text: prompt }]
                }]
            })
        });

        const data = await response.json();

        if (!response.ok) {
            const errorDetail = data?.error?.message || `Статус ${response.status}`;
            console.error("Vercel Proxy Error (Text):", data);
            throw new Error(`Ошибка AI прокси: ${errorDetail}`);
        }

        if (data.candidates?.[0]?.content?.parts?.[0]?.text) {
            const rawContent = data.candidates[0].content.parts[0].text.trim();
            // Проверяем, не является ли ответ сообщением об ошибке на русском
            if (rawContent.includes("Координаты") && rawContent.includes("не найдены")) {
                console.warn("AI returned a 'not found' message in Russian:", rawContent);
                return ""; // Возвращаем пустую строку, чтобы не обрабатывать это как координаты
            }
            console.log("Raw AI response (Text):", rawContent);
            const processedContent = addContourSeparators(rawContent);
            console.log("Processed content (Text, after addContourSeparators):", processedContent);
            return processedContent;
        } else if (data.candidates?.[0]?.finishReason === 'SAFETY') {
            throw new Error("Ответ заблокирован моделью по соображениям безопасности.");
        } else {
            console.warn("Vercel Proxy response structure not as expected (Text):", data);
            return "";
        }
    } catch (error) {
        console.error("Error calling Vercel Proxy API (Text):", error);
        throw error;
    } finally {
        if (aiLoader) aiLoader.style.display = 'none';
    }
}

// Define MSK projections (copied from your example)
if (typeof proj4 !== 'undefined') {
    proj4.defs("EPSG:3857", "+proj=merc +a=6378137 +b=6378137 +lat_ts=0.0 +lon_0=0.0 +x_0=0.0 +y_0=0 +k=1.0 +units=m +nadgrids=@null +wktext +no_defs");
    proj4.defs("EPSG:4326", "+proj=longlat +datum=WGS84 +no_defs");
    proj4.defs("MSK16_ZONE2",
        "+proj=tmerc +lat_0=0 +lon_0=52.033333333333 +k=1 +x_0=2300000 +y_0=-5709414.70 +ellps=krass +towgs84=23.57,-140.95,-79.8,0,-0.35,-0.79,-0.22 +units=m +no_defs +axis=enu"
    );
    proj4.defs("MSK16_ZONE1",
        "+proj=tmerc +lat_0=0 +lon_0=49.033333333333 +k=1 +x_0=1300000 +y_0=-5709414.70 +ellps=krass +towgs84=23.57,-140.95,-79.8,0,-0.35,-0.79,-0.22 +units=m +no_defs +axis=enu"
    );
} else {
    console.warn("Proj4 library is not defined. XML quarter determination might fail.");
}


function parseMskCoordinatesForQuarter(text) {
    if (!text || typeof text !== 'string') return [];
    // Split by one or more empty lines to get groups/contours
    const groups = text.split(/\n\s*\n+/).map(group => group.trim()).filter(group => group !== '');
    
    return groups.map(group => {
        const lines = group.split('\n').map(line => line.trim()).filter(line => line !== '');
        return lines.map(line => {
            // Regex to match two numbers, potentially with decimals, separated by whitespace or tab
            // Handles numbers with comma or period as decimal separator
            const match = line.match(/^\s*([+-]?\d+([.,]\d+)?)\s+([+-]?\d+([.,]\d+)?)\s*$/);
            if (!match) return null;

            const val1Str = match[1].replace(',', '.');
            const val2Str = match[3].replace(',', '.');

            const val1 = parseFloat(val1Str);
            const val2 = parseFloat(val2Str);

            if (!isFinite(val1) || !isFinite(val2)) return null;
            return [val1, val2]; // Keep original order for now
        }).filter(coord => coord !== null);
    }).filter(group => group.length > 0);
}


function convertMSKToWGS84(mskCoords, mskZoneName) {
    if (typeof proj4 === 'undefined') {
        console.error("Proj4 is not defined. Cannot convert coordinates.");
        return null;
    }
    const [x, y] = mskCoords;
    // These specific corrections were in your example
    const correctedX = x + 14.745;
    const correctedY = y - 14.038;
    try {
        let wgs84 = proj4(mskZoneName, "EPSG:4326", [correctedX, correctedY]);
        // These specific corrections were in your example
        wgs84[0] -= 0.00000152; // Longitude adjustment
        wgs84[1] += 0.00000118; // Latitude adjustment
        return [wgs84[1], wgs84[0]]; // Return as [latitude, longitude]
    } catch (e) {
        console.error(`Error converting MSK to WGS84 using proj4 for zone ${mskZoneName}:`, e);
        showNotification(`Ошибка конвертации MSK в WGS84: ${e.message}`);
        return null;
    }
}

function convertWGS84toEPSG3857(latitude, longitude) {
    if (typeof proj4 === 'undefined') {
        console.error("Proj4 is not defined. Cannot convert coordinates.");
        return null;
    }
    try {
        const epsg3857Coords = proj4("EPSG:4326", "EPSG:3857", [longitude, latitude]);
        return { x: epsg3857Coords[0], y: epsg3857Coords[1] };
    } catch (e) {
        console.error("Error converting WGS84 to EPSG:3857 using proj4:", e);
        showNotification(`Ошибка конвертации WGS84 в EPSG:3857: ${e.message}`);
        return null;
    }
}

function calculateCentroidWGS84(coordsArrayWGS84) {
    if (!coordsArrayWGS84 || coordsArrayWGS84.length === 0) return null;
    let sumLat = 0;
    let sumLon = 0;
    coordsArrayWGS84.forEach(coord => {
        if (coord && typeof coord[0] === 'number' && typeof coord[1] === 'number') {
            sumLat += coord[0]; // latitude
            sumLon += coord[1]; // longitude
        }
    });
    return [sumLat / coordsArrayWGS84.length, sumLon / coordsArrayWGS84.length];
}

async function queryNSPDForQuarter(originalLatitudeWGS, originalLongitudeWGS) {
    const MAX_RETRIES = 10; // Увеличено до 10 попыток
    const RETRY_DELAY_MS = 200; // Пауза в 200 мс
    const OFFSET_DEGREES = 0.0001; // Примерный эквивалент 10-11 метров для широты/долготы

    for (let attempt = 0; attempt < MAX_RETRIES; attempt++) {
        if (attempt > 0) {
            // Пауза перед повторной попыткой
            await new Promise(resolve => setTimeout(resolve, RETRY_DELAY_MS));
        }

        let currentLat = originalLatitudeWGS;
        let currentLon = originalLongitudeWGS;

        if (attempt > 0) {
            // Применяем случайное смещение для повторных попыток
            const latOffset = (Math.random() * 2 - 1) * OFFSET_DEGREES;
            const lonOffset = (Math.random() * 2 - 1) * OFFSET_DEGREES;
            currentLat += latOffset;
            currentLon += lonOffset;
            console.log(`NSPD Попытка ${attempt + 1}/${MAX_RETRIES}: Смещенные координаты lat=${currentLat.toFixed(6)}, lon=${currentLon.toFixed(6)}`);
        }

        const centerPointEPSG3857 = convertWGS84toEPSG3857(currentLat, currentLon);
        if (!centerPointEPSG3857) {
            console.warn(`NSPD Попытка ${attempt + 1}: Не удалось конвертировать смещенные WGS84 в EPSG:3857.`);
            if (attempt === MAX_RETRIES - 1) {
                return null;
            }
            continue;
        }

        const centerX = centerPointEPSG3857.x;
        const centerY = centerPointEPSG3857.y;
        const halfSize = 10.0;
        const minX = centerX - halfSize;
        const minY = centerY - halfSize;
        const maxX = centerX + halfSize;
        const maxY = centerY + halfSize;
        const bbox = `${minX},${minY},${maxX},${maxY}`;

        const queryI = 256, queryJ = 256, queryWidth = 512, queryHeight = 512, featureCount = 10;
        const layerIdsToTry = ["36048"];
        
        for (const layerId of layerIdsToTry) {
            const url = `https://nspd.gov.ru/api/aeggis/v4/${layerId}/wms?REQUEST=GetFeatureInfo&QUERY_LAYERS=${layerId}&SERVICE=WMS&VERSION=1.3.0&FORMAT=image%2Fpng%2F&STYLES=&TRANSPARENT=true&LAYERS=${layerId}&RANDOM=${Math.random()}&INFO_FORMAT=application%2Fjson&FEATURE_COUNT=${featureCount}&I=${queryI}&J=${queryJ}&WIDTH=${queryWidth}&HEIGHT=${queryHeight}&CRS=EPSG%3A3857&BBOX=${bbox}`;
            
            try {
                console.log(`Querying NSPD Layer ${layerId} (Попытка ${attempt + 1}/${MAX_RETRIES}) with BBOX: ${bbox} for coords: lat=${currentLat.toFixed(6)}, lon=${currentLon.toFixed(6)}`);
                const response = await fetch(url);
                if (!response.ok) {
                    const errorText = await response.text();
                    console.error(`NSPD GetFeatureInfo Error ${response.status} for layer ${layerId} (Попытка ${attempt + 1}). URL: ${url}. BBOX: ${bbox}. Response: ${errorText}`);
                    continue;
                }
                const data = await response.json();
                console.log(`NSPD GetFeatureInfo Response (layer ${layerId}, Попытка ${attempt + 1}):`, data);
                if (data && data.features && data.features.length > 0 && data.features[0].properties && data.features[0].properties.descr) {
                    const fullCadastralNumber = data.features[0].properties.descr;
                    const cnParts = fullCadastralNumber.split(':');
                    if (cnParts.length >= 3) {
                        console.log(`NSPD Успех на попытке ${attempt + 1} со слоем ${layerId}.`);
                        return cnParts.slice(0, 3).join(':'); 
                    } else {
                        console.warn("NSPD вернул кадастровый номер в неожиданном формате:", fullCadastralNumber);
                    }
                }
            } catch (error) {
                console.error(`Ошибка при запросе NSPD GetFeatureInfo для слоя ${layerId} (Попытка ${attempt + 1}):`, error, `BBOX: ${bbox}`);
            }
        }
        
        if (attempt < MAX_RETRIES - 1) {
            console.log(`NSPD Попытка ${attempt + 1} не удалась для всех слоев. Повторяем...`);
        }
    }

    console.warn("Квартал не найден после всех попыток  для исходного центроида:", originalLatitudeWGS, originalLongitudeWGS);
    return null; 
}


async function generateAndDownloadXML() {
    const coordsInputElement = document.getElementById('coordsInput');
    const inputText = coordsInputElement.value.trim();

    if (!inputText) {
        showNotification('Нет координат для определения квартала.');
        return;
    }
    
    if (typeof proj4 === 'undefined') {
        showNotification('Библиотека Proj4.js не загружена. Определение квартала невозможно.');
        console.error("Proj4 is not available.");
        return;
    }

    const aiLoader = document.getElementById('aiLoader');
    if (aiLoader) {
        aiLoader.querySelector('span').textContent = 'Определение кадастрового квартала...';
        aiLoader.style.display = 'flex';
    }

    const parsedGroups = parseMskCoordinatesForQuarter(inputText);

    if (parsedGroups.length === 0 || parsedGroups[0].length === 0) {
        showNotification("Не удалось распознать координаты МСК-16 из ввода.");
        if (aiLoader) aiLoader.style.display = 'none';
        return;
    }

    const firstGroupMSK = parsedGroups[0];
    let mskZoneToUse;
    let allWGS84CoordsInFirstGroup = [];

    const sampleMskPair = firstGroupMSK[0];
    const val1_sample = sampleMskPair[0];
    const val2_sample = sampleMskPair[1];

    if (val1_sample >= 2000000 && val1_sample < 3000000) { 
        mskZoneToUse = "MSK16_ZONE2";
    } else if (val1_sample >= 1000000 && val1_sample < 2000000) { 
        mskZoneToUse = "MSK16_ZONE1";
    } else if (val2_sample >= 2000000 && val2_sample < 3000000) { 
        mskZoneToUse = "MSK16_ZONE2";
    } else if (val2_sample >= 1000000 && val2_sample < 2000000) { 
        mskZoneToUse = "MSK16_ZONE1";
    } else {
        showNotification("Не удалось определить зону МСК-16. X должен быть 1xxxxxx или 2xxxxxx.");
        if (aiLoader) aiLoader.style.display = 'none';
        return;
    }
    console.log(`Determined MSK Zone for XML: ${mskZoneToUse}`);

    for (const mskPair of firstGroupMSK) {
        let currentMskX, currentMskY;
        if (mskZoneToUse === "MSK16_ZONE2") {
            currentMskX = (mskPair[0] >= 2000000 && mskPair[0] < 3000000) ? mskPair[0] : mskPair[1];
            currentMskY = (mskPair[0] >= 2000000 && mskPair[0] < 3000000) ? mskPair[1] : mskPair[0];
        } else { 
            currentMskX = (mskPair[0] >= 1000000 && mskPair[0] < 2000000) ? mskPair[0] : mskPair[1];
            currentMskY = (mskPair[0] >= 1000000 && mskPair[0] < 2000000) ? mskPair[1] : mskPair[0];
        }
        const wgs84Point = convertMSKToWGS84([currentMskX, currentMskY], mskZoneToUse);
        if (wgs84Point) {
            allWGS84CoordsInFirstGroup.push(wgs84Point);
        } else {
            if (aiLoader) aiLoader.style.display = 'none';
            return; 
        }
    }
    
    if (allWGS84CoordsInFirstGroup.length === 0) {
        showNotification("Ошибка конвертации координат МСК в WGS84.");
        if (aiLoader) aiLoader.style.display = 'none';
        return;
    }

    const centroidWGS84 = calculateCentroidWGS84(allWGS84CoordsInFirstGroup);
    if (!centroidWGS84) {
        showNotification("Не удалось рассчитать центроид для определения квартала.");
        if (aiLoader) aiLoader.style.display = 'none';
        return;
    }

    const quarterNumber = await queryNSPDForQuarter(centroidWGS84[0], centroidWGS84[1]);

    if (aiLoader) aiLoader.style.display = 'none';

    if (quarterNumber) {
        const textToCopy = `${quarterNumber}\n${inputText}`;
        try {
            await navigator.clipboard.writeText(textToCopy);
            showNotification(`Квартал ${quarterNumber} и координаты скопированы.`);
            window.open('схема_xml.html', '_blank');
        } catch (err) {
            console.error('Ошибка копирования в буфер обмена:', err);
            showNotification('Ошибка копирования. Квартал: ' + quarterNumber);
        }
    } else {
        // Измененное сообщение
        showNotification('Не удалось определить кадастровый квартал. Попробуйте другие координаты или проверьте их корректность.');
    }
}


        function getRandomColor() {
            const letters = '01234156789ABCDEF';
            let color = '#';
            for (let i = 0; i < 6; i++) {
                color += letters[Math.floor(Math.random() * 16)];
            }
            return color;
        }

        function setRandomButtonColors() {
            const buttons = document.querySelectorAll('button');
            buttons.forEach(button => {
                const randomColor = getRandomColor();
                button.style.backgroundColor = randomColor;
                button.style.color = getContrastYIQ(randomColor);
            });
        }

        function getContrastYIQ(hexcolor) {
            hexcolor = hexcolor.replace('#', '');
            const r = parseInt(hexcolor.substr(0, 2), 16);
            const g = parseInt(hexcolor.substr(2, 2), 16);
            const b = parseInt(hexcolor.substr(4, 4), 16);
            const yiq = ((r * 299) + (g * 587) + (b * 114)) / 1000;
            return (yiq >= 128) ? 'black' : 'white';
        }

        function addIconsToButtons() {
            const buttons = document.querySelectorAll('button');
            buttons.forEach(button => {
                const icon = document.createElement('i');
                icon.className = 'icon';
    
                button.insertBefore(icon, button.firstChild);
            });
        }
        
        function showCropModalScheme(imageFile) {
    return new Promise((resolve) => {
        cropModalResolveScheme = resolve;
        const modal = document.getElementById('crop-image-modal-scheme');
        const imgPreview = document.getElementById('crop-image-preview-scheme');
        const cropContainer = document.getElementById('crop-image-container-scheme');
        const selectionRectDiv = document.getElementById('crop-selection-rectangle-scheme');
        const confirmButton = document.getElementById('crop-image-button-confirm-scheme');
        const cancelButton = document.getElementById('crop-image-button-cancel-scheme');

        selectionRectDiv.style.display = 'none';
        cropSelectionScheme.isDrawing = false;

        const reader = new FileReader();
        reader.onload = function(e) {
            imgPreview.src = e.target.result;
            modal.style.display = 'flex';

            imgPreview.onload = () => {
                imageNaturalSizeScheme.width = imgPreview.naturalWidth;
                imageNaturalSizeScheme.height = imgPreview.naturalHeight;

                const modalContentWrapper = modal.querySelector('.crop-modal-content-wrapper-scheme');
                const containerPadding = 40;
                const buttonsAndTextHeight = 120;

                imgPreview.style.maxWidth = `calc(${modalContentWrapper.clientWidth - containerPadding}px - 2px)`;
                imgPreview.style.maxHeight = `calc(${modalContentWrapper.clientHeight - containerPadding - buttonsAndTextHeight}px - 2px)`;

                requestAnimationFrame(() => {
                    imageDisplaySizeScheme.width = imgPreview.offsetWidth;
                    imageDisplaySizeScheme.height = imgPreview.offsetHeight;
                });
            };
        };
        reader.readAsDataURL(imageFile);

        function updateSelectionRectScheme() {
            const x = Math.min(cropSelectionScheme.startX, cropSelectionScheme.endX);
            const y = Math.min(cropSelectionScheme.startY, cropSelectionScheme.endY);
            const width = Math.abs(cropSelectionScheme.endX - cropSelectionScheme.startX);
            const height = Math.abs(cropSelectionScheme.endY - cropSelectionScheme.startY);
            selectionRectDiv.style.left = `${x}px`;
            selectionRectDiv.style.top = `${y}px`;
            selectionRectDiv.style.width = `${width}px`;
            selectionRectDiv.style.height = `${height}px`;
        }

        function getMousePosScheme(event) {
            const rect = cropContainer.getBoundingClientRect();
            let x = event.clientX - rect.left;
            let y = event.clientY - rect.top;
            x = Math.max(0, Math.min(x, imageDisplaySizeScheme.width));
            y = Math.max(0, Math.min(y, imageDisplaySizeScheme.height));
            return { x, y };
        }

        const onMouseDownScheme = (e) => {
            e.preventDefault();
            if (e.button !== 0 && e.type === 'mousedown') return;
            cropSelectionScheme.isDrawing = true;
            const pos = getMousePosScheme(e.touches ? e.touches[0] : e);
            cropSelectionScheme.startX = pos.x;
            cropSelectionScheme.startY = pos.y;
            cropSelectionScheme.endX = pos.x;
            cropSelectionScheme.endY = pos.y;
            selectionRectDiv.style.width = '0px';
            selectionRectDiv.style.height = '0px';
            selectionRectDiv.style.left = `${pos.x}px`;
            selectionRectDiv.style.top = `${pos.y}px`;
            selectionRectDiv.style.display = 'block';
            cropContainer.addEventListener('mousemove', onMouseMoveScheme);
            cropContainer.addEventListener('touchmove', onMouseMoveScheme, { passive: false });
            window.addEventListener('mouseup', onMouseUpScheme);
            window.addEventListener('touchend', onMouseUpScheme);
        };

        const onMouseMoveScheme = (e) => {
            if (!cropSelectionScheme.isDrawing) return;
            e.preventDefault();
            const pos = getMousePosScheme(e.touches ? e.touches[0] : e);
            cropSelectionScheme.endX = pos.x;
            cropSelectionScheme.endY = pos.y;
            updateSelectionRectScheme();
        };

        const onMouseUpScheme = () => {
            if (!cropSelectionScheme.isDrawing) return;
            cropSelectionScheme.isDrawing = false;
            cropContainer.removeEventListener('mousemove', onMouseMoveScheme);
            cropContainer.removeEventListener('touchmove', onMouseMoveScheme);
            window.removeEventListener('mouseup', onMouseUpScheme);
            window.removeEventListener('touchend', onMouseUpScheme);
            const width = Math.abs(cropSelectionScheme.endX - cropSelectionScheme.startX);
            const height = Math.abs(cropSelectionScheme.endY - cropSelectionScheme.startY);
            if (width < 5 || height < 5) {
                selectionRectDiv.style.display = 'none';
            }
        };

        cropContainer.addEventListener('mousedown', onMouseDownScheme);
        cropContainer.addEventListener('touchstart', onMouseDownScheme, { passive: false });

        const handleConfirmScheme = () => {
            const selWidth = Math.abs(cropSelectionScheme.endX - cropSelectionScheme.startX);
            const selHeight = Math.abs(cropSelectionScheme.endY - cropSelectionScheme.startY);
            if (selWidth < 5 || selHeight < 5 || selectionRectDiv.style.display === 'none') {
                fileToBase64(imageFile).then(base64 => cropModalResolveScheme({
                    cropped: false, data: base64.split(',')[1]
                }));
                cleanupModalScheme();
                return;
            }
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            const scaleX = imageNaturalSizeScheme.width / imageDisplaySizeScheme.width;
            const scaleY = imageNaturalSizeScheme.height / imageDisplaySizeScheme.height;
            const sX = Math.min(cropSelectionScheme.startX, cropSelectionScheme.endX) * scaleX;
            const sY = Math.min(cropSelectionScheme.startY, cropSelectionScheme.endY) * scaleY;
            const sWidth = selWidth * scaleX;
            const sHeight = selHeight * scaleY;
            canvas.width = sWidth;
            canvas.height = sHeight;
            ctx.drawImage(imgPreview, sX, sY, sWidth, sHeight, 0, 0, sWidth, sHeight);
            const croppedImageDataUrl = canvas.toDataURL(imageFile.type);
            cropModalResolveScheme({ cropped: true, data: croppedImageDataUrl.split(',')[1] });
            cleanupModalScheme();
        };

        const handleCancelScheme = () => {
            fileToBase64(imageFile).then(base64 => cropModalResolveScheme({
                cropped: false, data: base64.split(',')[1]
            }));
            cleanupModalScheme();
        };

        confirmButton.removeEventListener('click', handleConfirmScheme);
        confirmButton.addEventListener('click', handleConfirmScheme);
        cancelButton.removeEventListener('click', handleCancelScheme);
        cancelButton.addEventListener('click', handleCancelScheme);

        function cleanupModalScheme() {
            modal.style.display = 'none';
            imgPreview.src = '#';
            imgPreview.onload = null;
            cropContainer.removeEventListener('mousedown', onMouseDownScheme);
            cropContainer.removeEventListener('touchstart', onMouseDownScheme);
            // ... (удаление остальных обработчиков, как в вашем предыдущем коде, но с суффиксом Scheme)
            cropContainer.removeEventListener('mousemove', onMouseMoveScheme);
            cropContainer.removeEventListener('touchmove', onMouseMoveScheme);
            window.removeEventListener('mouseup', onMouseUpScheme);
            window.removeEventListener('touchend', onMouseUpScheme);
            confirmButton.onclick = null;
            cancelButton.onclick = null;
            cropModalResolveScheme = null;
        }
    });
}

        
        
        
        async function checkClipboardOnLoad() {
    try {
        // Пытаемся прочитать текст из буфера обмена
        // Важно: Это может потребовать разрешения пользователя или не сработать
        // в некоторых браузерах/контекстах без явного действия пользователя.
        let clipboardText = await navigator.clipboard.readText(); // Changed to let

        if (!clipboardText) {
            console.log("Буфер обмена пуст.");
            return;
        }

        // START OF CHANGE
        // Заменяем все запятые на точки в тексте из буфера обмена
        clipboardText = clipboardText.replace(/,/g, '.');
        // END OF CHANGE

        const lines = clipboardText.trim().split('\n');
        if (lines.length === 0) {
            console.log("Содержимое буфера обмена не содержит строк после очистки.");
            return;
        }

        const firstLine = lines[0].trim();

        // Регулярное выражение для поиска двух чисел (возможно, с десятичной точкой),
        // разделенных одним или несколькими пробелами или табуляцией.
        // Учитывает возможные пробелы в начале/конце строки.
        const coordRegex = /^\s*(\d+(?:\.\d+)?)\s+(\d+(?:\.\d+)?)\s*$/; // Already handles periods
        const match = firstLine.match(coordRegex);

        if (match) {
            // Извлекаем числа и проверяем, похожи ли они на координаты
            const num1 = parseFloat(match[1]); // No need to replace comma here anymore
            const num2 = parseFloat(match[2]); // No need to replace comma here anymore

            // Используем порог, аналогичный логике handleInput
            // (числа должны быть достаточно большими)
            const isLikelyCoords = !isNaN(num1) && !isNaN(num2) &&
                                   Math.abs(num1) >= 10000 && Math.abs(num2) >= 10000;

            if (isLikelyCoords) {
                console.log("Содержимое буфера обмена похоже на координаты, выполняется вставка.");
                const coordsInput = document.getElementById('coordsInput');

                // Вставляем только если поле ввода пустое, чтобы не перезаписать введенные вручную данные
                if (coordsInput.value.trim() === '') {
                     coordsInput.value = clipboardText; // clipboardText now has periods instead of commas
                     handleInput(true); // Обрабатываем вставленное содержимое
                     showNotification('Координаты вставлены из буфера обмена');
                } else {
                     console.log("Поле ввода не пустое, вставка из буфера обмена пропущена.");
                }
            } else {
                console.log("Первая строка совпала с шаблоном чисел, но числа не похожи на типовые координаты:", num1, num2);
            }
        } else {
            console.log("Первая строка буфера обмена не соответствует шаблону координат:", firstLine);
        }

    } catch (err) {
        console.error('Не удалось прочитать содержимое буфера обмена: ', err);
        // Можно уведомить пользователя, но лучше не назойливо, если проблема в разрешениях
        // showNotification('Не удалось прочитать буфер обмена. Возможно, требуется разрешение.');
    }
}


        document.addEventListener('DOMContentLoaded', () => {
             initializeZoom();
               initializeTouchZoom();
            setRandomButtonColors();
            addIconsToButtons();
             initializeEyeButton();
             
              const expandMenuItem = document.getElementById('expandLinearObject');
    const widthDialogElement = document.getElementById('widthDialog');
    const widthDialogInput = document.getElementById('widthInput'); // Get the input element
    const schemeMenu = document.getElementById('schemeMenu');

    if (expandMenuItem && widthDialogElement && widthDialogInput && schemeMenu) {
        expandMenuItem.addEventListener('click', () => {
            // Set the default value BEFORE showing the dialog
            widthDialogInput.value = "0.05"; // <<< ADD THIS LINE

            widthDialogElement.style.display = 'block';
            schemeMenu.style.display = 'none'; // Hide menu if needed
        });
    }
    
             
              const openDXFButton = document.getElementById('openDXFButton');
    if (openDXFButton) {
        openDXFButton.addEventListener('click', function() {
            window.open('DXF.html', '_blank');
        });
    }
             
               // Добавляем обработчик для пункта меню "Добавить на чертеж"
    const addToDrawingElement = document.getElementById('addToDrawing');
    if (addToDrawingElement) {
        addToDrawingElement.addEventListener('click', () => {
            importFile(true);
            document.getElementById('schemeMenu').style.display = 'none';
        });
    }

    


document.getElementById('canvas').addEventListener('dblclick', () => {
    const input = document.getElementById('coordsInput').value.trim();
    const contours = input.split('\n\n').filter(contour => contour.trim() !== '');

    if (contours.length === 0) {
        showNotification('Нет данных для отображения в новом окне.');
        return;
    }

    // 1. Сериализуем данные о контурах в строку JSON перед созданием окна
    const contoursJSON = JSON.stringify(contours);

    const newWindow = window.open('', '_blank');
    newWindow.document.write('<html><head><title>Чертеж</title></head><body style="margin: 0; padding: 0; background-color: white;"><canvas id="newCanvas" width="800" height="800" style="display: block;"></canvas><script>');

    // 2. Пишем саму функцию отрисовки (здесь исправлен split и проверка на замкнутость)
    newWindow.document.write('function drawContoursOnCanvas(contours) {');
    newWindow.document.write('const canvas = document.getElementById("newCanvas"); const ctx = canvas.getContext("2d");');
    newWindow.document.write('ctx.fillStyle = "white";');
    newWindow.document.write('ctx.fillRect(0, 0, canvas.width, canvas.height);');
    newWindow.document.write('ctx.strokeStyle = "black";');
    newWindow.document.write('ctx.fillStyle = "black";');
    newWindow.document.write('if (contours.length === 0) return;');
    // Используем более надежный split для пробелов или табов
    newWindow.document.write('let allPoints = contours.flatMap(contour => contour.split("\\n").map(coord => coord.split(/\\s+|\\t/).map(c => parseFloat(String(c).replace(",", ".")))));');
    newWindow.document.write('const minX = Math.min(...allPoints.map(p => p[0])); const minY = Math.min(...allPoints.map(p => p[1])); const maxX = Math.max(...allPoints.map(p => p[0])); const maxY = Math.max(...allPoints.map(p => p[1]));');
    newWindow.document.write('const scaleX = canvas.width / (maxY - minY); const scaleY = canvas.height / (maxX - minX); const scale = Math.min(scaleX, scaleY) * 0.9;');
    newWindow.document.write('const offsetX = (canvas.width - (maxY - minY) * scale) / 2; const offsetY = (canvas.height - (maxX - minX) * scale) / 2;');
    newWindow.document.write('contours.forEach((contour, contourIndex) => {');
    // Используем более надежный split
    newWindow.document.write('  const points = contour.split("\\n").map(coord => coord.split(/\\s+|\\t/).map(c => parseFloat(String(c).replace(",", "."))));');
    // Используем более надежную проверку на замкнутость с погрешностью
    newWindow.document.write('  const isClosed = points.length > 2 && Math.abs(points[0][0] - points[points.length - 1][0]) < 0.01 && Math.abs(points[0][1] - points[points.length - 1][1]) < 0.01;');
    newWindow.document.write('  ctx.beginPath();');
    newWindow.document.write('  points.forEach(([x, y], index) => { const canvasX = offsetX + (y - minY) * scale; const canvasY = canvas.height - (offsetY + (x - minX) * scale); if (index === 0) { ctx.moveTo(canvasX, canvasY); } else { ctx.lineTo(canvasX, canvasY); } });');
    newWindow.document.write('  if (isClosed) { ctx.closePath(); }');
    newWindow.document.write('  ctx.stroke();');
    newWindow.document.write('  ctx.fillStyle = "red";');
    newWindow.document.write('  points.forEach(([x, y], index) => { const canvasX = offsetX + (y - minY) * scale; const canvasY = canvas.height - (offsetY + (x - minX) * scale); ctx.beginPath(); ctx.arc(canvasX, canvasY, 3, 0, 2 * Math.PI); ctx.fill(); ctx.fillStyle = "black"; ctx.fillText(`${contourIndex + 1}.${index + 1}`, canvasX + 5, canvasY - 5); ctx.fillStyle = "red"; });');
    newWindow.document.write('  if (points.length < 30) { ctx.font = "12px Arial"; ctx.fillStyle = "black"; points.forEach(([x1, y1], index) => { if (index < points.length - 1 || isClosed) { const [x2, y2] = points[(index + 1) % points.length]; const distance = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2)); if (distance > 0.01) { const canvasX1 = offsetX + (y1 - minY) * scale; const canvasY1 = canvas.height - (offsetY + (x1 - minX) * scale); const canvasX2 = offsetX + (y2 - minY) * scale; const canvasY2 = canvas.height - (offsetY + (x2 - minX) * scale); const midX = (canvasX1 + canvasX2) / 2; const midY = (canvasY1 + canvasY2) / 2; ctx.fillText(`${distance.toFixed(2)} м`, midX, midY); } } }); }');
    newWindow.document.write('});}'); // Завершаем функцию forEach и drawContoursOnCanvas

    // 3. САМОЕ ГЛАВНОЕ: Вызываем созданную функцию, передавая в неё данные
    newWindow.document.write(`drawContoursOnCanvas(${contoursJSON});`);

    newWindow.document.write('<\/script></body></html>');
    newWindow.document.close();
});
  checkClipboardOnLoad(); 
  
  
     const coordsInputEl = document.getElementById('coordsInput');
if (coordsInputEl) {
    coordsInputEl.addEventListener('paste', async function(event) {
        const items = (event.clipboardData || window.clipboardData).items;
        let imageFile = null;
        const aiLoader = document.getElementById('aiLoader');

        for (let i = 0; i < items.length; i++) {
            if (items[i].type.indexOf("image") !== -1) {
                imageFile = items[i].getAsFile();
                break;
            }
        }

        if (imageFile) {
            event.preventDefault();
            if (aiLoader) aiLoader.style.display = 'flex';

            const tempImg = new Image();
            const objectURL = URL.createObjectURL(imageFile);
            let imageDataToSendToAI;

            tempImg.onload = async () => {
                URL.revokeObjectURL(objectURL);
                const width = tempImg.width;
                const height = tempImg.height;

                if (width > 800 || height > 800) {
                    try {
                        const cropResult = await showCropModalScheme(imageFile); // Используем новую функцию
                        imageDataToSendToAI = cropResult.data;
                        if (cropResult.cropped) {
                           // showNotification('Изображение обрезано для распознавания.');
                        }
                    } catch (cropError) {
                        console.error("Ошибка во время обрезки:", cropError);
                        showNotification('Ошибка при обрезке, используется оригинальное изображение.');
                        imageDataToSendToAI = (await fileToBase64(imageFile)).split(',')[1];
                    }
                } else {
                    imageDataToSendToAI = (await fileToBase64(imageFile)).split(',')[1];
                }

                try {
                    const extractedCoordsText = await getCoordinatesFromImageAI(imageDataToSendToAI);
                    if (extractedCoordsText && extractedCoordsText.trim() !== "") {
                        const cleanedCoords = cleanAndFormatAICoordinates(extractedCoordsText);
                        this.value = cleanedCoords;
                        handleInput(true);
                        showNotification('Координаты извлечены из изображения!');
                    } else {
                        showNotification('Не удалось извлечь координаты из изображения');
                    }
                } catch (error) {
                    console.error('Ошибка при обработке изображения AI:', error);
                    showNotification('Ошибка AI: ' + error.message);
                } finally {
                    if (aiLoader) aiLoader.style.display = 'none';
                }
            };
            tempImg.onerror = () => {
                URL.revokeObjectURL(objectURL);
                showNotification('Не удалось загрузить изображение для проверки размеров.');
                if (aiLoader) aiLoader.style.display = 'none';
            };
            tempImg.src = objectURL;

        } else { // Если вставлен текст
            event.preventDefault();
            let pastedText = (event.clipboardData || window.clipboardData).getData('text');
            const modifiedText = pastedText.replace(/,/g, '.'); // Замена запятых на точки
            const start = this.selectionStart;
            const end = this.selectionEnd;
            const currentText = this.value;
            this.value = currentText.substring(0, start) + modifiedText + currentText.substring(end);
            this.selectionStart = this.selectionEnd = start + modifiedText.length;
            handleInput(true, false); // Call with showNotifications=true, isAIRetry=false
        }
    });
}
        
});

function cleanAndFormatAICoordinates(aiText) {
        if (!aiText || aiText.trim() === "") {
            return "";
        }

        const lines = aiText.trim().split('\n');
        const formattedCoords = [];

        for (const line of lines) {
            const parts = line.trim().split(/\s+/); // Разделение по пробелам или табуляции
            if (parts.length === 2) {
                let x = parseFloat(parts[0].replace(',', '.'));
                let y = parseFloat(parts[1].replace(',', '.'));

                if (!isNaN(x) && !isNaN(y)) {
                    // Убедимся, что x < y
                    if (x > y) {
                        [x, y] = [y, x];
                    }
                    // Форматируем до 2 знаков после запятой
                    formattedCoords.push(`${x.toFixed(2)}\t${y.toFixed(2)}`);
                }
            }
        }
        return formattedCoords.join('\n');
    }



function initializeEyeButton() {
    const eyeButton = document.getElementById('eyeButton');
    
    eyeButton.addEventListener('click', () => {
        eyeState = (eyeState + 1) % 6; // Изменяем на 6 состояний
        
        switch(eyeState) {
            case 0: // Показать все
                showLabels = true;
                showPoints = true;
                showRulers = true;
                showDistances = true;
                eyeButton.className = 'eye-button';
                break;
            case 1: // Без надписей (только номера)
                showLabels = false;
                showPoints = true;
                showRulers = true;
                showDistances = true;
                eyeButton.className = 'eye-button no-labels';
                break;
            case 2: // Без точек
                showLabels = true;
                showPoints = false;
                showRulers = true;
                showDistances = true;
                eyeButton.className = 'eye-button no-points';
                break;
            case 3: // Только номера точек и контур (без расстояний)
                showLabels = true;
                showPoints = true;
                showRulers = true;
                showDistances = false;
                eyeButton.className = 'eye-button no-distances';
                break;
            case 4: // Только чертеж
                showLabels = false;
                showPoints = false;
                showRulers = false;
                showDistances = false;
                eyeButton.className = 'eye-button only-drawing';
                break;
            case 5: // Только точки, чертеж и расстояния (БЕЗ номеров)
                showLabels = false;    // Скрывает номера точек
                showPoints = true;     // Показывает красные точки
                showRulers = true;    // Скрывает линейки
                showDistances = true;  // Показывает расстояния
                eyeButton.className = 'eye-button points-distances-only';
                break;
        }

        // Перерисовываем canvas
        drawContour(savedContours);
    });
}


function openEditor() {
    const coordsInput = document.getElementById('coordsInput');
    const coordinatesText = coordsInput.value;

    if (!coordinatesText.trim()) {
        showNotification('Нет координат для копирования в редактор.');
        return;
    }

    navigator.clipboard.writeText(coordinatesText).then(() => {
        showNotification('Координаты скопированы. Открываю редактор...');
        window.open('editor.html', '_blank');
    }).catch(err => {
        console.error('Не удалось скопировать координаты: ', err);
        showNotification('Ошибка при копировании координат для редактора.');
    });
}

function generateDXF(coords) {
    let dxfContent = `0\nSECTION\n2\nHEADER\n0\nENDSEC\n`;
    dxfContent += `0\nSECTION\n2\nTABLES\n0\nENDSEC\n`;
    dxfContent += `0\nSECTION\n2\nBLOCKS\n0\nENDSEC\n`;
    dxfContent += `0\nSECTION\n2\nENTITIES\n`;

    let contours = [[]];
    let currentContourIndex = 0;

    coords.forEach(coord => {
        if (coord.trim() === '') {
            if (contours[currentContourIndex].length > 0) {
                currentContourIndex++;
                contours.push([]);
            }
        } else {
            contours[currentContourIndex].push(coord.split('\t').map(Number));
        }
    });

    // Удаляем пустые контуры
    contours = contours.filter(contour => contour.length > 0);

    contours.forEach((contour, index) => {
        const isClosed = contour[0][0] === contour[contour.length - 1][0] && contour[0][1] === contour[contour.length - 1][1];

        dxfContent += `0\nLWPOLYLINE\n8\n0\n66\n1\n70\n${isClosed ? 1 : 0}\n`;
        dxfContent += `90\n${contour.length}\n`;

        contour.forEach(([x, y]) => {
            dxfContent += `10\n${y}\n20\n${x}\n`;
        });

        dxfContent += `0\nSEQEND\n`;
    });

    dxfContent += `0\nENDSEC\n0\nEOF\n`;
    return dxfContent;
}

function copyCoordinatesAndOpenMap() {
    const input = document.getElementById('coordsInput').value.trim();
    if (!input) {
        showNotification('Нет координат для копирования');
        return;
    }

    // Убираем .filter(), чтобы сохранить пустые строки
    const coords = input.split('\n');  // Изменение здесь!

    if (coords.length === 0) {
        showNotification('Не удалось извлечь координаты');
        return;
    }

    // Преобразуем координаты в формат, подходящий для карты
    const formattedCoords = coords.map(coord => {
        const [x, y] = coord.split(/\s+/).map(Number);
        // Если x или y не являются числами (из-за пустой строки),
        // вернем пустую строку.  Это сохранит разделители контуров.
        if (isNaN(x) || isNaN(y)) {
          return '';  // Пустая строка вместо координат
        }
        return `${y}\t${x}`;
    }).join('\n');

    navigator.clipboard.writeText(formattedCoords).then(() => {
        showNotification('Координаты скопированы в буфер обмена');
        window.open('map.html', '_blank');
    }).catch(err => {
        console.error('Не удалось скопировать координаты: ', err);
        showNotification('Ошибка при копировании координат');
    });
}

function generateMIF(coords) {
    let mifContent = `Version 300\nCharset "WindowsCyrillic"\nDelimiter ","\nCoordSys NonEarth Units "m" Bounds (0, 0) (10000000, 10000000)\nColumns 2\n  X Decimal(15, 2)\n  Y Decimal(15, 2)\nData\n\n`;

    let contours = [[]];
    let currentContourIndex = 0;

    coords.forEach(coord => {
        if (coord.trim() === '') {
            if (contours[currentContourIndex].length > 0) {
                currentContourIndex++;
                contours.push([]);
            }
        } else {
            contours[currentContourIndex].push(coord.split('\t').map(Number));
        }
    });

    // Удаляем пустые контуры
    contours = contours.filter(contour => contour.length > 0);

    if (contours.length === 1) {
        // Один контур
        mifContent += `Region 1\n${contours[0].length}\n`;
        contours[0].forEach(([x, y]) => {
            mifContent += `${y} ${x}\n`;
        });
    } else {
        // Множество контуров
        mifContent += `Region ${contours.length}\n`;
        contours.forEach(contour => {
            mifContent += `${contour.length}\n`;
            contour.forEach(([x, y]) => {
                mifContent += `${y} ${x}\n`;
            });
        });
    }

    return mifContent;
}

function generateCSV(coords) {
    let csvContent = "Контур;Префикс номера;Номер;Старый X;Старый Y;Новый X;Новый Y;Метод определения;Формула;Радиус;Погрешность;Описание закрепления\n";
    csvContent += ";;;;;;;;;;;\n";

    let contourNumber = 1;
    let pointNumber = 1;
    let contour = [];

    coords.forEach((coord, index) => {
        if (coord.trim() === '') {
            // Завершаем текущий контур
            if (contour.length > 0) {
                csvContent += processContour(contour, contourNumber, pointNumber);
                contourNumber++;
                pointNumber = 1;
                contour = [];
                csvContent += ";;;;;;;;;;;\n"; // Пустая строка между контурами
            }
        } else {
            const [x, y] = coord.split(/\s+|\t/).map(Number);
            if (!isNaN(x) && !isNaN(y)) {
                contour.push([x, y]);
            } else {
                console.warn('Некорректные координаты:', coord);
            }
        }
    });

    // Обрабатываем последний контур, если он есть
    if (contour.length > 0) {
        csvContent += processContour(contour, contourNumber, pointNumber);
    }

    return csvContent;
}



function initializeZoom() {
    const canvas = document.getElementById('canvas');

    // Обработка колесика мыши для масштабирования
      canvas.addEventListener('wheel', function(e) {
        e.preventDefault();
        const rect = canvas.getBoundingClientRect();
        const mouseX = e.clientX - rect.left;
        const mouseY = e.clientY - rect.top;

        // Определяем направление прокрутки
        const delta = Math.sign(e.deltaY);
        const zoomFactor = delta > 0 ? 0.9 : 1.1;

        // Обновляем уровень масштабирования
        const oldZoom = zoomLevel;
        zoomLevel *= zoomFactor;
        zoomLevel = Math.min(Math.max(zoomLevel, 0.1), 10); // Ограничиваем масштаб

        // Корректируем позицию панорамирования для зума в точку мыши
        panX += (mouseX / oldZoom - mouseX / zoomLevel);
        panY += (mouseY / oldZoom - mouseY / zoomLevel);

        // Перерисовываем canvas
         drawContour(savedContours); // Перерисовываем с savedContours
    });
    
     // Обработка перетаскивания
    canvas.addEventListener('mousedown', function(e) {
        isDragging = true;
        lastX = e.clientX;
        lastY = e.clientY;
        canvas.style.cursor = 'grabbing';
    });

    canvas.addEventListener('mousemove', function(e) {
        if (isDragging) {
            const dx = e.clientX - lastX;
            const dy = e.clientY - lastY;
            
            panX += dx / zoomLevel;
            panY += dy / zoomLevel;

            lastX = e.clientX;
            lastY = e.clientY;

            drawContour(savedContours); // Перерисовываем с savedContours
        }
    });

    canvas.addEventListener('mouseup', function() {
        isDragging = false;
        canvas.style.cursor = 'grab';
    });

    canvas.addEventListener('mouseleave', function() {
        isDragging = false;
        canvas.style.cursor = 'grab';
    });
}

// Функции для кнопок масштабирования
// Функция для плавного масштабирования
function smoothZoom(targetZoom, duration = 300) {
    const startZoom = zoomLevel;
    const startTime = Date.now();
    
    function update() {
        const currentTime = Date.now();
        const elapsed = currentTime - startTime;
        const progress = Math.min(elapsed / duration, 1);
        
        // Функция плавности
        const easeOutCubic = progress => (1 - Math.pow(1 - progress, 3));
        
        zoomLevel = startZoom + (targetZoom - startZoom) * easeOutCubic(progress);
        drawContour(getCurrentCoordinates());
        
        if (progress < 1) {
            requestAnimationFrame(update);
        }
    }
    
    update();
}


function resetZoom() {
    smoothZoom(1, 300); // Сброс к исходному масштабу
    panX = 0;
    panY = 0;
    drawContour(getCurrentCoordinates());
}

// Добавьте обработку тачскрина для мобильных устройств
function initializeTouchZoom() {
    const canvas = document.getElementById('canvas');
    let initialDistance = 0;
    let initialZoom = 1;
    
    canvas.addEventListener('touchstart', function(e) {
        if (e.touches.length === 2) {
            initialDistance = Math.hypot(
                e.touches[0].clientX - e.touches[1].clientX,
                e.touches[0].clientY - e.touches[1].clientY
            );
            initialZoom = zoomLevel;
        }
    });

    canvas.addEventListener('touchmove', function(e) {
        if (e.touches.length === 2) {
            e.preventDefault();
            const currentDistance = Math.hypot(
                e.touches[0].clientX - e.touches[1].clientX,
                e.touches[0].clientY - e.touches[1].clientY
            );
            
            const scale = currentDistance / initialDistance;
            zoomLevel = Math.min(Math.max(initialZoom * scale, 0.1), 10);
            drawContour(savedContours);
        }
    });
}


// Обновленные функции зума
function zoomIn() {
    const targetZoom = Math.min(zoomLevel * 1.2, 10);
    smoothZoom(targetZoom);
}

function zoomOut() {
    const targetZoom = Math.max(zoomLevel * 0.8, 0.1);
    smoothZoom(targetZoom);
}


let savedContours = []; // Добавляем переменную для сохранения контуров

async function handleInput(showNotifications = false, isAIRetry = false) {
    const inputElement = document.getElementById('coordsInput');
    let inputText = inputElement.value;
    console.log("--- Starting handleInput ---");
    console.log("handleInput: isAIRetry =", isAIRetry);

    if (inputText.trim() === '') {
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        canvas.style.display = 'none';
        document.getElementById('log').innerHTML = '';
        document.getElementById('comboBoxContainer').innerHTML = '';
        savedContours = [];
        console.log("handleInput: Input is empty, clearing.");
        console.log("--- Ending handleInput ---");
        return;
    }

    let coordinates = [];
    let extractionMethod = "None";
    let localParsingSucceeded = false;

    if (!isAIRetry) { // Локальный парсинг только если это не повторный вызов после AI
        console.log("handleInput: Trying extractCoordinatesEntitySpatial...");
        coordinates = extractCoordinatesEntitySpatial(inputText);
        if (coordinates.length > 0) {
            extractionMethod = "EntitySpatial";
        } else {
            console.log("handleInput: Trying extractCoordinatesNewContour...");
            coordinates = extractCoordinatesNewContour(inputText);
            if (coordinates.length > 0) {
                extractionMethod = "NewContour";
            } else {
                console.log("handleInput: Trying searchInTabs...");
                coordinates = searchInTabs(inputText);
                if (coordinates.length > 0) {
                    extractionMethod = "SearchInTabs";
                } else {
                    console.log("handleInput: Trying standard split (X Y format)...");
                    coordinates = inputText.split('\n').map(line => {
                        line = line.trim();
                        if (line === '') return '';
                        const parts = line.split(/\s+|\t/);
                        if (parts.length >= 2) {
                            const xStr = parts[0].replace(',', '.');
                            const yStr = parts[1].replace(',', '.');
                            const x = parseFloat(xStr);
                            const y = parseFloat(yStr);
                            if (!isNaN(x) && !isNaN(y) && Math.abs(x) >= 10000 && Math.abs(y) >= 10000) {
                                return `${x.toFixed(2)}\t${y.toFixed(2)}`;
                            }
                        }
                        return null;
                    }).filter(coord => coord !== null);

                    if (coordinates.length > 0) {
                        extractionMethod = "StandardSplit";
                    } else {
                        console.log("handleInput: Trying importGeo...");
                        coordinates = importGeo(inputText);
                        if (coordinates.length > 0) {
                            extractionMethod = "ImportGeo";
                        } else {
                            console.log("handleInput: Trying extractCoordinatesFromTextWithDescription...");
                            coordinates = extractCoordinatesFromTextWithDescription(inputText);
                            if (coordinates.length > 0) {
                                extractionMethod = "TextWithDescription";
                            } else {
                                console.log("handleInput: Trying extractCoordinatesFromSpelementUnit...");
                                coordinates = extractCoordinatesFromSpelementUnit(inputText);
                                if (coordinates.length > 0) {
                                    extractionMethod = "SpelementUnit";
                                } else {
                                    console.log("handleInput: Trying extractSingleNumberPerLine...");
                                    coordinates = extractSingleNumberPerLine(inputText);
                                    if (coordinates.length > 0) {
                                        extractionMethod = "SingleNumberPerLine";
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        
        localParsingSucceeded = coordinates.some(c => typeof c === 'string' && c.trim() !== '');
    }


    if (localParsingSucceeded) {
        console.log(`handleInput: Coordinates found using local method: ${extractionMethod}. Total items (coords + separators): ${coordinates.length}`);
        let cleanedCoordinates = [];
        let lastWasEmpty = true;
        for (const coord of coordinates) {
            const isEmpty = typeof coord === 'string' && coord.trim() === '';
            if (!isEmpty) {
                cleanedCoordinates.push(coord);
                lastWasEmpty = false;
            } else if (!lastWasEmpty) {
                cleanedCoordinates.push('');
                lastWasEmpty = true;
            }
        }
        if (cleanedCoordinates.length > 0 && typeof cleanedCoordinates[cleanedCoordinates.length - 1] === 'string' && cleanedCoordinates[cleanedCoordinates.length - 1].trim() === '') {
            cleanedCoordinates.pop();
        }
        
        // *** MODIFICATION START ***
        // Update the input field with only the cleaned coordinates
        inputElement.value = cleanedCoordinates.join('\n');
        // *** MODIFICATION END ***

        savedContours = [];
        let currentContour = [];
        cleanedCoordinates.forEach(coord => {
            if (typeof coord === 'string' && coord.trim() === '') {
                if (currentContour.length > 0) {
                    savedContours.push(currentContour);
                    currentContour = [];
                }
            } else {
                if (typeof coord === 'string') {
                    currentContour.push(coord);
                } else {
                    console.warn("handleInput (local): Encountered non-string coordinate:", coord);
                }
            }
        });
        if (currentContour.length > 0) {
            savedContours.push(currentContour);
        }
        console.log("handleInput: Populated savedContours from local parsing:", savedContours);
        drawContour(savedContours);
        if (showNotifications) {
            showNotification('Координаты обработаны локально');
        }
    } else if (inputText.trim() !== '' && !isAIRetry) { // AI вызывается только если локальный парсинг не удался и это не AI-retry
        console.log("handleInput: No local coordinates found. Attempting AI extraction for text.");
        try {
            const aiMultiContourText = await getCoordinatesFromTextAI(inputText);

            if (aiMultiContourText && aiMultiContourText.trim() !== "") {
                console.log("handleInput: AI extracted text. Processing for multiple contours directly.");
                
                inputElement.value = aiMultiContourText; // Обновляем поле ввода текстом от AI

                const contourBlocksText = aiMultiContourText.split(/\n\s*\n/);
                const newSavedContours = [];

                for (const blockText of contourBlocksText) {
                    const trimmedBlock = blockText.trim();
                    if (trimmedBlock.length === 0) continue;

                    const pointsInCurrentContour = [];
                    const linesInBlock = trimmedBlock.split('\n');

                    for (const line of linesInBlock) {
                        const trimmedLine = line.trim();
                        if (trimmedLine === '') continue;

                        const parts = trimmedLine.split('\t');
                        if (parts.length === 2) {
                            pointsInCurrentContour.push(trimmedLine);
                        } else {
                            console.warn("handleInput (AI): Line in AI-processed block does not have 2 parts after tab split:", trimmedLine);
                        }
                    }
                    if (pointsInCurrentContour.length > 0) {
                        newSavedContours.push(pointsInCurrentContour);
                    }
                }

                if (newSavedContours.length > 0) {
                    savedContours = newSavedContours;
                    showNotification('Координаты извлечены из текста с помощью ИИ!');
                    console.log("handleInput: Populated savedContours from AI processing:", savedContours);
                    drawContour(savedContours);
                    console.log("--- Ending handleInput after AI success (direct processing) ---");
                    return; 
                } else {
                    showNotification('ИИ вернул текст, но не удалось извлечь валидные контуры.');
                    console.log("handleInput (AI): AI returned text, but no valid contours extracted from blocks.");
                }
            } else {
                showNotification('Не удалось извлечь координаты из текста с помощью ИИ.');
                console.log("handleInput (AI): AI did not return useful coordinate text.");
            }
        } catch (error) {
            console.error('Ошибка при обработке текста AI:', error);
            showNotification('Ошибка ИИ (текст): ' + error.message);
        }
    }


    const finalHasDrawableCoords = savedContours.some(contour => contour.length > 0);

    if (!finalHasDrawableCoords) {
        console.log("handleInput: No valid coordinates found after all attempts.");
        if (inputText.trim() === '') {
            const canvas = document.getElementById('canvas');
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            canvas.style.display = 'none';
            document.getElementById('log').innerHTML = '';
            document.getElementById('comboBoxContainer').innerHTML = '';
            savedContours = [];
            console.log("handleInput: Input is empty, cleared canvas/logs.");
        } else {
             if (showNotifications && !isAIRetry) { 
                 showNotification('Не удалось распознать координаты из текста');
             }
             console.log("handleInput: Input has text but no drawable coords found. Keeping previous drawing if any.");
        }
    }
    console.log("--- Ending handleInput ---");
}



function drawContour(coords) {
    
    // Проверка на наличие данных для отрисовки
    if (!coords || coords.length === 0 || coords.every(obj => obj.length === 0)) {
        console.warn('Нет данных для отрисовки.');
         const canvas = document.getElementById('canvas');
         const ctx = canvas.getContext('2d');
         ctx.clearRect(0, 0, canvas.width, canvas.height);
         canvas.style.display = 'none';
         document.getElementById('log').innerHTML = '';
         document.getElementById('comboBoxContainer').innerHTML = '';
        return;
    }
    
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // Сохраняем текущее состояние контекста
    ctx.save();

    // Применяем трансформации для масштабирования и панорамирования
    ctx.translate(canvas.width / 2, canvas.height / 2);
    ctx.scale(zoomLevel, zoomLevel);
    ctx.translate(-canvas.width / 2 + panX, -canvas.height / 2 + panY);

    // Подготавливаем точки для отрисовки
    let allPoints = coords.flat().map(coord => coord.split('\t').map(Number));


    const minX = Math.min(...allPoints.map(p => p[0]));
    const minY = Math.min(...allPoints.map(p => p[1]));
    const maxX = Math.max(...allPoints.map(p => p[0]));
    const maxY = Math.max(...allPoints.map(p => p[1]));

    const padding = 60;
    const scaleX = (canvas.width - padding * 2) / (maxY - minY);
    const scaleY = (canvas.height - padding * 2) / (maxX - minX);
    const scale = Math.min(scaleX, scaleY) * 0.9;

    const offsetX = padding + (canvas.width - padding * 2 - (maxY - minY) * scale) / 2;
    const offsetY = padding + (canvas.height - padding * 2 - (maxX - minX) * scale) / 2;

    const pointRadius = 3 / zoomLevel;
    const fontSize = 12 / zoomLevel;
    const textOffset = 5 / zoomLevel;


    if (showRulers) {
        drawRulers(ctx, minX, minY, maxX, maxY, offsetX, offsetY, scale, canvas.width, canvas.height);
    }

    const isPointVisible = (x, y) => {
        return x >= 0 && x <= canvas.width && y >= 0 && y <= canvas.height;
    };

    coords.forEach((points, objectIndex) => {
        ctx.beginPath();
        ctx.strokeStyle = getRandomColor();

        const isClosedContour = isContourClosed(points);

        let firstCanvasX, firstCanvasY;

        points.forEach((coord, index) => {
            const [x, y] = coord.split('\t').map(Number);
            const canvasX = offsetX + (y - minY) * scale;
            const canvasY = canvas.height - (offsetY + (x - minX) * scale);

            if (index === 0) {
                ctx.moveTo(canvasX, canvasY);
                firstCanvasX = canvasX;
                firstCanvasY = canvasY;
            } else {
                ctx.lineTo(canvasX, canvasY);
            }
        });

        if (isClosedContour) {
            ctx.closePath();
        }
        ctx.stroke();

        // Отрисовка точек (если включено)
        if (showPoints) {
            ctx.fillStyle = 'red';
            points.forEach((coord, index) => {
                const [x, y] = coord.split('\t').map(Number);
                const canvasX = offsetX + (y - minY) * scale;
                const canvasY = canvas.height - (offsetY + (x - minX) * scale);

                if (isPointVisible(canvasX, canvasY)) {
                     ctx.beginPath();
                    ctx.arc(canvasX, canvasY, pointRadius, 0, 2 * Math.PI);
                    ctx.fill();
               }
            });
        }

        // Отрисовка надписей (номеров точек) (если включено)
        if (showLabels) {
            ctx.font = `${fontSize}px Arial`;
            ctx.fillStyle = 'red';
            // Номера точек
            points.forEach((coord, index) => {
                const [x, y] = coord.split('\t').map(Number);
                const canvasX = offsetX + (y - minY) * scale;
                const canvasY = canvas.height - (offsetY + (x - minX) * scale);
                if (isPointVisible(canvasX, canvasY)) {
                    if (isClosedContour && index === points.length - 1) {
                        ctx.fillText(`${objectIndex + 1}.1`, canvasX + textOffset, canvasY - textOffset);
                    } else {
                        ctx.fillText(`${objectIndex + 1}.${index + 1}`, canvasX + textOffset, canvasY - textOffset);
                     }
                }
            });
        }
        
        // Отрисовка расстояний между точками (если включено)
        if (showDistances && points.length < 30) {
            ctx.font = `${fontSize}px Arial`;
            ctx.fillStyle = 'black';
            for (let i = 0; i < points.length - 1; i++) {
                const [x1, y1] = points[i].split('\t').map(Number);
                const [x2, y2] = points[i + 1].split('\t').map(Number);
                const canvasX1 = offsetX + (y1 - minY) * scale;
                const canvasY1 = canvas.height - (offsetY + (x1 - minX) * scale);
                const canvasX2 = offsetX + (y2 - minY) * scale;
                const canvasY2 = canvas.height - (offsetY + (x2 - minX) * scale);

                const midX = (canvasX1 + canvasX2) / 2;
                const midY = (canvasY1 + canvasY2) / 2;

               if (isPointVisible(midX, midY)) {
                   const distance = Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);
                   if (distance > 0.01) {
                      ctx.fillText(`${distance.toFixed(2)} м`, midX, midY);
                  }
              }
            }

            if (isClosedContour) {
                const [x1, y1] = points[points.length - 1].split('\t').map(Number);
                const [x2, y2] = points[0].split('\t').map(Number);
                const canvasX1 = offsetX + (y1 - minY) * scale;
                const canvasY1 = canvas.height - (offsetY + (x1 - minX) * scale);
                const canvasX2 = offsetX + (y2 - minY) * scale;
                const canvasY2 = canvas.height - (offsetY + (x2 - minX) * scale);

                const midX = (canvasX1 + canvasX2) / 2;
                const midY = (canvasY1 + canvasY2) / 2;
               
                if (isPointVisible(midX, midY)) {
                     const distance = Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);
                    if (distance > 0.01) {
                       ctx.fillText(`${distance.toFixed(2)} м`, midX, midY);
                   }
                }
            }
        }
    });

    // Восстанавливаем состояние контекста
    ctx.restore();

    canvas.style.display = 'block';
    displayLog(coords);
    createComboBoxes(coords);
}

function isContourClosed(contour) {
    // Need at least 3 points for a polygon, and first must match last
    if (!contour || contour.length < 3) return false;
    const firstPointStr = contour[0];
    const lastPointStr = contour[contour.length - 1];

    // Parse coordinates to compare numerically, handling potential floating point issues
    try {
        const [x1, y1] = firstPointStr.split('\t').map(Number);
        const [x2, y2] = lastPointStr.split('\t').map(Number);

        // Use a small tolerance for floating point comparison (e.g., 1 mm)
        const tolerance = 0.001;
        return Math.abs(x1 - x2) < tolerance && Math.abs(y1 - y2) < tolerance;
    } catch (e) {
        console.error("Error parsing points in isContourClosed:", firstPointStr, lastPointStr, e);
        return false; // Treat parse errors as not closed
    }
}



function initializeZoom() {
    const canvas = document.getElementById('canvas');

    // Обработка колесика мыши для масштабирования
      canvas.addEventListener('wheel', function(e) {
        e.preventDefault();
        const rect = canvas.getBoundingClientRect();
        const mouseX = e.clientX - rect.left;
        const mouseY = e.clientY - rect.top;

        // Определяем направление прокрутки
        const delta = Math.sign(e.deltaY);
        const zoomFactor = delta > 0 ? 0.9 : 1.1;

        // Обновляем уровень масштабирования
        const oldZoom = zoomLevel;
        zoomLevel *= zoomFactor;
        zoomLevel = Math.min(Math.max(zoomLevel, 0.1), 10); // Ограничиваем масштаб

        // Корректируем позицию панорамирования для зума в точку мыши
        panX += (mouseX / oldZoom - mouseX / zoomLevel);
        panY += (mouseY / oldZoom - mouseY / zoomLevel);

        // Перерисовываем canvas
         drawContour(savedContours); // Перерисовываем с savedContours
    });
    
     // Обработка перетаскивания
    canvas.addEventListener('mousedown', function(e) {
        isDragging = true;
        lastX = e.clientX;
        lastY = e.clientY;
        canvas.style.cursor = 'grabbing';
    });

    canvas.addEventListener('mousemove', function(e) {
        if (isDragging) {
            const dx = e.clientX - lastX;
            const dy = e.clientY - lastY;
            
            panX += dx / zoomLevel;
            panY += dy / zoomLevel;

            lastX = e.clientX;
            lastY = e.clientY;

            drawContour(savedContours); // Перерисовываем с savedContours
        }
    });

    canvas.addEventListener('mouseup', function() {
        isDragging = false;
        canvas.style.cursor = 'grab';
    });

    canvas.addEventListener('mouseleave', function() {
        isDragging = false;
        canvas.style.cursor = 'grab';
    });
}

// Добавьте обработку тачскрина для мобильных устройств
function initializeTouchZoom() {
    const canvas = document.getElementById('canvas');
    let initialDistance = 0;
    let initialZoom = 1;
    
    canvas.addEventListener('touchstart', function(e) {
        if (e.touches.length === 2) {
            initialDistance = Math.hypot(
                e.touches[0].clientX - e.touches[1].clientX,
                e.touches[0].clientY - e.touches[1].clientY
            );
            initialZoom = zoomLevel;
        }
    });

    canvas.addEventListener('touchmove', function(e) {
        if (e.touches.length === 2) {
            e.preventDefault();
            const currentDistance = Math.hypot(
                e.touches[0].clientX - e.touches[1].clientX,
                e.touches[0].clientY - e.touches[1].clientY
            );
            
            const scale = currentDistance / initialDistance;
            zoomLevel = Math.min(Math.max(initialZoom * scale, 0.1), 10);
            drawContour(savedContours);
        }
    });
}

function getCurrentCoordinates() {
    // This function is now deprecated as we use savedContours
    // However, it's still used by copyCoordinatesAndOpenMap
    const input = document.getElementById('coordsInput').value;
    return input.split('\n'); // Return raw lines including empty ones
}




function drawRulers(ctx, minX, minY, maxX, maxY, offsetX, offsetY, scale, canvasWidth, canvasHeight) {
    ctx.strokeStyle = 'royalblue';
    ctx.fillStyle = 'royalblue';
    ctx.font = '12px Arial';
    ctx.textAlign = 'center';

    const steps = [1, 2, 5, 10, 20, 50, 100, 200, 500, 1000, 2000, 5000, 10000];

    function getOptimalStep(range) {
        return steps.find(step => range / step <= 5) || steps[steps.length - 1];
    }

    const bottomY = canvasHeight - 20;
    ctx.beginPath();
    ctx.moveTo(offsetX, bottomY);
    ctx.lineTo(canvasWidth - offsetX, bottomY);
    ctx.stroke();

    const horizontalRange = maxY - minY;
    const horizontalStep = getOptimalStep(horizontalRange);
    for (let i = 0; i <= Math.floor(horizontalRange / horizontalStep); i++) {
        const y = minY + i * horizontalStep;
        const canvasX = offsetX + (y - minY) * scale;
        ctx.beginPath();
        ctx.moveTo(canvasX, bottomY);
        ctx.lineTo(canvasX, bottomY + 5);
        ctx.stroke();
        ctx.fillText(`${(i * horizontalStep).toFixed(0)} м`, canvasX, bottomY + 15);
    }

    const rightX = canvasWidth - 20;
    ctx.beginPath();
    ctx.moveTo(rightX, offsetY);
    ctx.lineTo(rightX, canvasHeight - offsetY - 30);
    ctx.stroke();

    ctx.textAlign = 'right';
    const verticalRange = maxX - minX;
    const verticalStep = getOptimalStep(verticalRange);
    for (let i = 0; i <= Math.floor(verticalRange / verticalStep); i++) {
        const x = minX + i * verticalStep;
        const canvasY = canvasHeight - (offsetY + (x - minX) * scale);
        ctx.beginPath();
        ctx.moveTo(rightX, canvasY);
        ctx.lineTo(rightX + 5, canvasY);
        ctx.stroke();
        ctx.fillText(`${(i * verticalStep).toFixed(0)} м`, rightX - 5, canvasY + 4);
    }
}

function calculateArea(points) {
    let area = 0;
    const n = points.length;
    // Ensure it's treated as closed for calculation, even if last point isn't explicitly repeated in input sometimes
    for (let i = 0; i < n; i++) {
        try {
            const [x1, y1] = points[i].split('\t').map(Number);
            // Use modulo operator to wrap around for the last point connecting to the first
            const [x2, y2] = points[(i + 1) % n].split('\t').map(Number);
            area += x1 * y2 - y1 * x2;
        } catch (e) {
            console.error("Error parsing points in calculateArea:", points[i], points[(i + 1) % n], e);
            return 0; // Return 0 on error
        }
    }
    return Math.abs(area) / 2;
}

function calculatePerimeter(points) {
    let perimeter = 0;
    const n = points.length;
    // Check if the shape is closed based on coordinate match
    const closedByCoords = isContourClosed(points);
    // Determine the number of segments to calculate
    
     if (n < 2) return 0; // No perimeter for single point or empty array

    // Simpler approach: Sum distances between p[i] and p[i+1] for i from 0 to n-2.
    // If closed, add distance between p[n-1] and p[0].

    perimeter = 0;
    for (let i = 0; i < n - 1; i++) { // Sum segments p[i] to p[i+1]
        try {
            const [x1, y1] = points[i].split('\t').map(Number);
            const [x2, y2] = points[i + 1].split('\t').map(Number);
            perimeter += Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);
        } catch (e) {
             console.error("Error parsing points in calculatePerimeter (segment):", points[i], points[i+1], e);
             return NaN; // Return NaN on error
        }
    }
    
    // If the contour is closed and has more than 2 points, add the segment from the last point back to the first.
    // Note: isContourClosed checks if the *last coordinate value* matches the *first coordinate value*.
    // If the input explicitly repeats the first point at the end, the loop above already calculated the segment from n-2 to n-1.
    // We only need to add the closing segment if the last point in the array is *not* the same as the first point in the array structure.
    // However, the `isContourClosed` function checks if the *values* match.
    // Let's rely on `isContourClosed`. If it's closed, the last point is logically the same as the first.
    // The loop from 0 to n-2 calculates distances for segments (0,1), (1,2), ..., (n-2, n-1).
    // If closed, we need the segment (n-1, 0).
    if (closedByCoords) {
         try {
             const [x1, y1] = points[n - 1].split('\t').map(Number);
             const [x2, y2] = points[0].split('\t').map(Number);
             perimeter += Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);
         } catch (e) {
             console.error("Error parsing points in calculatePerimeter (closing segment):", points[n - 1], points[0], e);
             return NaN;
         }
    }


    return perimeter;
}
        

function generateAndDownloadMIF() {
    const input = document.getElementById('coordsInput').value;
    const coords = input.split('\n');
    const mifContent = generateMIF(coords);
    const blob = new Blob([mifContent], { type: 'text/plain' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'output.mif';
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
}

function generateAndDownloadDXF() {
    const input = document.getElementById('coordsInput').value;
    const coords = input.split('\n');
    const dxfContent = generateDXF(coords);
    const blob = new Blob([dxfContent], { type: 'application/dxf' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'output.dxf';
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
}

function generateAndDownloadCSV() {
    const input = document.getElementById('coordsInput').value;
    const coords = input.split('\n');
    const csvContent = generateCSV(coords);
    
    // Добавляем BOM для правильного распознавания UTF-8
    const bom = '\uFEFF';
    const csvWithBom = bom + csvContent;
    
    const blob = new Blob([csvWithBom], { type: 'text/csv;charset=utf-8;' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'технокад.csv';
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
}




function extractCoordinatesEntitySpatial(text) {
    const coordinates = [];
    const contours = text.split('</entity_spatial>');

    contours.forEach((contour, index) => {
        const regex = /<x>(\d+(?:\.\d+)?)<\/x>\s*<y>(\d+(?:\.\d+)?)<\/y>/g;
        let matches;
        let currentContour = [];

        while ((matches = regex.exec(contour)) !== null) {
            const x = parseFloat(matches[1]).toFixed(2);
            const y = parseFloat(matches[2]).toFixed(2);
            currentContour.push(`${x}\t${y}`);
        }

        if (currentContour.length > 0) {
            if (coordinates.length > 0) coordinates.push('');
            coordinates.push(...currentContour);
        }
    });

    return coordinates;
}

function extractCoordinatesNewContour(text) {
    const coordinates = [];
    const contours = text.split('</NewContour>');

    contours.forEach((contour, index) => {
        const regex = /X="(\d+(?:\.\d+)?)"[^>]+Y="(\d+(?:\.\d+))"/g;
        let matches;
        let currentContour = [];

        while ((matches = regex.exec(contour)) !== null) {
            const x = parseFloat(matches[1]).toFixed(2);
            const y = parseFloat(matches[2]).toFixed(2);
            currentContour.push(`${x}\t${y}`);
        }

        if (currentContour.length > 0) {
            if (coordinates.length > 0) coordinates.push('');
            coordinates.push(...currentContour);
        }
    });

    return coordinates;
}

function extractCoordinatesPlainText(text) {
    const contours = text.split('\n\n');
    return contours.flatMap((contour, index) => {
        const coords = contour.trim().split('\n').map(line => {
            const [x, y] = line.trim().split(/\s+|\t/);
            return `${parseFloat(x).toFixed(2)}\t${parseFloat(y).toFixed(2)}`;
        });
        return index > 0 ? ['', ...coords] : coords;
    });
}

function searchInTabs(text) {
    console.log("=== Starting searchInTabs ===");
    const coordinates = [];
    const lines = text.split('\n');
    let currentContour = [];
    let previousLineHadCoords = false;

    for (let i = 0; i < lines.length; i++) {
        const line = lines[i].trim();
        if (!line) {
             // If current line is empty and the previous one had coordinates,
             // it signifies the end of a contour.
            if (previousLineHadCoords && currentContour.length > 0) {
                coordinates.push(...currentContour);
                coordinates.push(''); // Add contour separator
                currentContour = [];
            }
            previousLineHadCoords = false; // Reset flag for empty line
            continue; // Skip empty lines
        }

        // Разбиваем строку на части по табуляции или пробелам
        const parts = line.split(/[\t\s]+/);
        
        // Ищем числа с 5+ цифрами среди частей
        let possibleNumbers = parts.map(part => {
            const num = parseFloat(part.replace(',', '.'));
            return !isNaN(num) && Math.abs(num) >= 10000 ? num : null;
        }).filter(num => num !== null);

        if (possibleNumbers.length >= 2) {
            currentContour.push(`${possibleNumbers[0].toFixed(2)}\t${possibleNumbers[1].toFixed(2)}`);
            previousLineHadCoords = true;
        } else {
             // If current line has text but no coordinates, and previous had coords,
             // it also signifies the end of a contour (text as description).
            if (previousLineHadCoords && currentContour.length > 0) {
                coordinates.push(...currentContour);
                coordinates.push(''); // Add contour separator
                currentContour = [];
            }
            previousLineHadCoords = false; // Reset flag as this line didn't have coords
        }
    }

    // Добавляем последний контур, если он не был добавлен
    if (currentContour.length > 0) {
        coordinates.push(...currentContour);
    }

    // Удаляем пустую строку в конце, если она есть
    while (coordinates.length > 0 && coordinates[coordinates.length - 1] === '') {
        coordinates.pop();
    }

    console.log("=== Ending searchInTabs ===");
    return coordinates;
}

function importGeo(text) {
    const lines = text.split('\n');
    const coordinates = [];
    const separators = /[,;\t]/;  // разделители: запятая, точка с запятой, табуляция
    
    let currentContour = [];
    let previousLineHadCoords = false;
    
    for (let line of lines) {
        line = line.trim();
        if (!line) {
             if (previousLineHadCoords && currentContour.length > 0) {
                coordinates.push(...currentContour, '');
                currentContour = [];
            }
            previousLineHadCoords = false;
            continue;
        }
        
        // Разбиваем строку по разделителям
        const parts = line.split(separators);
        
        // Ищем два числа больше 10000
        let foundCoords = [];
        for (let part of parts) {
            const num = parseFloat(part.replace(',', '.'));
            if (!isNaN(num) && Math.abs(num) >= 10000) {
                foundCoords.push(num);
                if (foundCoords.length === 2) break;
            }
        }
        
        // Если нашли две координаты
        if (foundCoords.length === 2) {
            // Сортируем координаты (X всегда меньше Y)
            const [x, y] = foundCoords[0] < foundCoords[1] ? 
                [foundCoords[0], foundCoords[1]] : 
                [foundCoords[1], foundCoords[0]];
            currentContour.push(`${x.toFixed(2)}\t${y.toFixed(2)}`);
            previousLineHadCoords = true;
        } else {
             if (previousLineHadCoords && currentContour.length > 0) {
                coordinates.push(...currentContour, '');
                currentContour = [];
            }
            previousLineHadCoords = false;
        }
    }
    
    // Добавляем последний контур, если есть
    if (currentContour.length > 0) {
        coordinates.push(...currentContour);
    }

     while (coordinates.length > 0 && coordinates[coordinates.length - 1] === '') {
        coordinates.pop();
    }
    
    return coordinates;
}

 function extractCoordinatesFromTextWithDescription(text) {
    const lines = text.split('\n');
    const coordinates = [];
    let currentContour = [];
    let previousLineHadCoords = false;
    const numberRegex = /[-+]?[0-9]*[.,]?[0-9]+/g;

    for (let line of lines) {
        line = line.trim();
        if (!line) {
          if (previousLineHadCoords && currentContour.length > 0) {
            coordinates.push(...currentContour);
            coordinates.push('');
            currentContour = [];
          }
          previousLineHadCoords = false;
          continue;
        }

         const numbers = line.match(numberRegex);
       const potentialCoords = numbers ? numbers.map(n => parseFloat(n.replace(',', '.')))
                                                 .filter(n => Math.abs(n) >= 10000)
                                        : [];
       if (potentialCoords.length >= 2) {
          const [x, y] = potentialCoords[0] < potentialCoords[1]
            ? [potentialCoords[0], potentialCoords[1]]
            : [potentialCoords[1], potentialCoords[0]];
           currentContour.push(`${x.toFixed(2)}\t${y.toFixed(2)}`);
           previousLineHadCoords = true;
        } else {
            if (previousLineHadCoords && currentContour.length > 0) {
                coordinates.push(...currentContour);
                coordinates.push(''); // Добавляем разделитель контуров
                currentContour = [];
            }
          previousLineHadCoords = false;
        }
    }

  if (currentContour.length > 0) {
       coordinates.push(...currentContour);
  }


     if (coordinates.length > 0 && coordinates[coordinates.length - 1] === '') {
        coordinates.pop();
    }
      return coordinates;
}



     function addToList() {
   const startComboBox = document.getElementById('start-point');
    const endComboBox = document.getElementById('end-point');
    const pointsList = document.getElementById('pointsList');

    if (!pointsList.querySelector('textarea')) {
        const textarea = document.createElement('textarea');
        textarea.rows = 5;
        textarea.style.width = '100%';
        textarea.readOnly = true;
        textarea.style.textAlign = 'center'; // Добавлено центрирование текста
        textarea.style.border = '2px solid #007bff';
        textarea.style.borderRadius = '10px';
        textarea.style.padding = '10px';
        textarea.style.boxShadow = '0 4px 8px rgba(0, 0, 0, 0.1)';
        textarea.style.transition = 'border-color 0.3s ease';
        textarea.style.boxSizing = 'border-box';
        textarea.style.resize = 'vertical';
        pointsList.appendChild(textarea);
    }

    const textarea = pointsList.querySelector('textarea');

    let newLine = '';
    if (startComboBox.value === '' || endComboBox.value === '' || startComboBox.value === endComboBox.value) {
        // Если точки не выбраны или выбрана одна и та же точка
        // Find the first area or perimeter element in the log
        const logElement = document.getElementById('log');
        const firstAreaSpan = logElement.querySelector('.clickable-area');
        const firstPerimeterSpan = logElement.querySelector('.clickable-perimeter');

        if (firstAreaSpan) {
             const areaValue = firstAreaSpan.dataset.area;
             newLine = `н1\tн1\t${parseFloat(areaValue).toFixed(2)}`; // Use area for closed contours
        } else if (firstPerimeterSpan) {
             const perimeterValue = firstPerimeterSpan.dataset.perimeter;
             newLine = `н1\tн1\t${parseFloat(perimeterValue).toFixed(2)}`; // Use perimeter for open contours
        }


    } else {
        // Если выбраны разные точки
        const startPointIndex = parseInt(startComboBox.value) + 1;
        const endPointIndex = parseInt(endComboBox.value) + 1;
        if (typeof window.lastCalculatedDistance !== 'undefined') {
            newLine = `н${startPointIndex}\tн${endPointIndex}\t${window.lastCalculatedDistance.toFixed(2)}`;
        }
    }

    if (newLine) {
        textarea.value += (textarea.value ? '\n' : '') + newLine;
    }
}

function copyPointsList() {
    const textarea = document.querySelector('#pointsList textarea');
    if (textarea) {
        textarea.select();
        document.execCommand('copy');
        showNotification('Список скопирован в буфер обмена');
    }
}
        
        
function displayLog(objects) {
    const logElement = document.getElementById('log');
    logElement.innerHTML = ''; // Clear previous log entries

    objects.forEach((points, index) => {
        // Ensure points is an array and has enough elements
        if (!Array.isArray(points) || points.length === 0) {
             console.warn(`displayLog: Skipping empty or invalid object at index ${index}`);
             return;
         }

        let logMessage = '';
        const numPoints = points.length;

        // Use the dedicated function to check if the contour is closed
        // Note: A closed contour for area calculation typically needs at least 3 *distinct* vertices,
        // and the first and last coordinates must match.
        const isClosed = numPoints >= 3 && isContourClosed(points);

        if (isClosed) { // Check if it's a closed contour suitable for area calculation
            const area = calculateArea(points); // Calculate the precise area
            const perimeter = calculatePerimeter(points); // Calculate perimeter

            // Construct the message with both rounded and precise area (with 2 decimals)
            logMessage = `Контур ${index + 1}: Площадной объект, <span class="clickable-area" data-area="${area.toFixed(2)}">Площадь</span> = ${Math.round(area)} (${area.toFixed(2)}) кв. м, <span class="clickable-perimeter" data-perimeter="${perimeter.toFixed(2)}">Периметр</span> = ${perimeter.toFixed(2)} м`;

        } else if (numPoints >= 2) { // If not closed, but at least 2 points, it's a linear object
            const length = calculatePerimeter(points); // calculatePerimeter works for lines too
            logMessage = `Контур ${index + 1}: Линейный объект, <span class="clickable-perimeter" data-perimeter="${length.toFixed(2)}">Протяженность</span> = ${length.toFixed(2)} м`;
        } else if (numPoints === 1) { // Handle single point case
             logMessage = `Контур ${index + 1}: Точка`;
        } else {
             // Should not happen if initial check is done, but good for robustness
             logMessage = `Контур ${index + 1}: Неверный объект (мало точек)`;
        }


        const logEntry = document.createElement('p');
        logEntry.innerHTML = logMessage;
        logElement.appendChild(logEntry);
    });

    // Re-attach event listeners for clickable elements
    const clickableAreas = logElement.querySelectorAll('.clickable-area');
    clickableAreas.forEach(element => {
        element.removeEventListener('click', handleAreaClick); // Remove old listener if any
        element.addEventListener('click', handleAreaClick);
    });

    const clickablePerimeters = logElement.querySelectorAll('.clickable-perimeter');
    clickablePerimeters.forEach(element => {
        element.removeEventListener('click', handlePerimeterClick); // Remove old listener if any
        element.addEventListener('click', handlePerimeterClick);
    });
}

function handleAreaClick(event) {
    const area = parseFloat(event.target.dataset.area);
    const accuracyOptions = [0.1, 0.2, 0.5, 2.5, 5];
    
    const dialog = document.createElement('div');
    dialog.style.position = 'fixed';
    dialog.style.left = '50%';
    dialog.style.top = '50%';
    dialog.style.transform = 'translate(-50%, -50%)';
    dialog.style.backgroundColor = 'white';
    dialog.style.padding = '20px';
    dialog.style.border = '1px solid black';
    dialog.style.zIndex = '1000';

    dialog.innerHTML = '<p>Выберите погрешность (Mt):</p>';

    accuracyOptions.forEach(accuracy => {
        const button = document.createElement('button');
        button.textContent = accuracy;
        button.style.margin = '5px';
        button.addEventListener('click', () => {
            const deltaP = calculateDeltaP(area, accuracy);
            const resultString = `∆P=3.5*Mt*√P=3.5*${accuracy}*√${Math.round(area)}=${deltaP}`;

            navigator.clipboard.writeText(resultString).then(() => {
                flashElement(event.target);
                document.body.removeChild(dialog);
            }).catch(err => {
                console.error('Не удалось скопировать текст: ', err);
            });
        });
        dialog.appendChild(button);
    });

    document.body.appendChild(dialog);
}

function handlePerimeterClick(event) {
    const perimeter = event.target.dataset.perimeter;
    navigator.clipboard.writeText(perimeter).then(() => {
        flashElement(event.target);
    }).catch(err => {
        console.error('Не удалось скопировать текст: ', err);
    });
}

function calculateDeltaP(area, accuracy) {
    const result = 3.5 * accuracy * Math.sqrt(Math.round(area));
    return Math.round(result);
}

function flashElement(element) {
    element.style.transition = 'background-color 0.3s';
    element.style.backgroundColor = 'lime';
    setTimeout(() => {
        element.style.backgroundColor = 'transparent';
    }, 300);
}




function copyPerimeter() {
    const perimeterSpan = document.getElementById('perimeterSpan');
    const perimeterText = perimeterSpan.textContent;
    const perimeterValue = perimeterText.replace(/[^\d.]/g, '');
    
    navigator.clipboard.writeText(perimeterValue).then(() => {
        showNotification('Периметр скопирован в буфер обмена');
    }).catch(err => {
        console.error('Не удалось скопировать текст: ', err);
    });
}


function extractSingleNumberPerLine(text) {
    const lines = text.split('\n');
    // Filter out empty lines and trim whitespace
    const numbers = lines.filter(line => line.trim() !== '')
                         .map(line => line.trim());
    
    // Check if we have more than 3 lines
    if (numbers.length <= 3) {
        return [];
    }
    
    // Check if each line contains a single number (no spaces or tabs)
    const allSingleNumbers = numbers.every(line => {
        // Remove commas in numbers like "1234,56" -> "1234.56"
        const normalized = line.replace(',', '.');
        // Check if this is a valid number and doesn't contain spaces or tabs
        return !isNaN(parseFloat(normalized)) && 
               normalized.trim() === normalized &&
               !normalized.includes(' ') && 
               !normalized.includes('\t');
    });
    
    if (!allSingleNumbers) {
        return [];
    }
    
    // Group numbers in pairs (X, Y)
    const coordinates = [];
    for (let i = 0; i < numbers.length; i += 2) {
        if (i + 1 < numbers.length) {
            const x = parseFloat(numbers[i].replace(',', '.'));
            const y = parseFloat(numbers[i + 1].replace(',', '.'));
            coordinates.push(`${x.toFixed(2)}\t${y.toFixed(2)}`);
        }
    }
    
    return coordinates;
}


function showNotification(message) {
    const notification = document.getElementById('notification');
    notification.textContent = message;
    notification.style.display = 'block';
    
    setTimeout(() => {
        notification.style.display = 'none';
    }, 2000);
}

function createComboBoxes(objects) {
    const comboBoxContainer = document.getElementById('comboBoxContainer');
    comboBoxContainer.innerHTML = '';

    const createComboBox = (labelText, comboBoxId) => {
        const label = document.createElement('label');
        label.innerHTML = labelText;

        const comboBox = document.createElement('select');
        comboBox.id = comboBoxId;

        const defaultOption = document.createElement('option');
        defaultOption.value = '';
        defaultOption.text = 'Выберите точку';
        comboBox.appendChild(defaultOption);

        let totalPoints = 0;
        objects.forEach((contour, contourIndex) => {
            const isClosedContour = isContourClosed(contour);
            const pointsCount = contour.length;

            for (let pointIndex = 0; pointIndex < pointsCount; pointIndex++) {
                const option = document.createElement('option');
                option.value = totalPoints + pointIndex;
                // If closed, the last point is logically the same as the first.
                // We should only list unique points or handle the numbering carefully.
                // Let's list all points as they appear in the array for simplicity,
                // but show 'Point 1' for the last point if closed.
                if (isClosedContour && pointIndex === pointsCount - 1) {
                     // Skip the last point if it's a duplicate of the first in a closed contour
                     // This prevents listing the same point twice (e.g., 1.1 and 1.5 for a 4-point closed contour)
                     // However, the current `isContourClosed` checks value, not array index.
                     // Let's list all points but adjust the label for the last point if the contour is closed.
                     option.text = `Контур ${contourIndex + 1}, Точка 1 (замыкающая)`;
                } else {
                    option.text = `Контур ${contourIndex + 1}, Точка ${pointIndex + 1}`;
                 }
                comboBox.appendChild(option);
            }

            totalPoints += pointsCount;
        });

        comboBox.addEventListener('change', calculateSelectedDistance);
        label.appendChild(comboBox);
        comboBoxContainer.appendChild(label);
    };

    createComboBox('Начальная точка: ', 'start-point');
    createComboBox('Конечная точка: ', 'end-point');

    // Добавляем кнопку "Копировать с точками"
    const copyButton = document.createElement('button');
    copyButton.innerHTML = '<i class="fas fa-copy"></i>';
    copyButton.className = 'custom-button btn-copy';
    copyButton.title = 'Копировать с точками';
    copyButton.addEventListener('click', copyWithPoints);
    comboBoxContainer.appendChild(copyButton);

    // Добавляем кнопку "Добавить в список"
    const addToListButton = document.createElement('button');
    addToListButton.innerHTML = '<i class="fas fa-list-ul"></i>';
    addToListButton.className = 'custom-button btn-add-to-list';
    addToListButton.title = 'Добавить в список';
    addToListButton.onclick = addToList;
    comboBoxContainer.appendChild(addToListButton);
}







function calculateSelectedDistance() {
    const startComboBox = document.getElementById('start-point');
    const endComboBox = document.getElementById('end-point');

    const startPointGlobalIndex = parseInt(startComboBox.value);
    const endPointGlobalIndex = parseInt(endComboBox.value);

    if (!isNaN(startPointGlobalIndex) && !isNaN(endPointGlobalIndex)) {
        // Flatten savedContours to get a single array of all points
        const allPointsFlat = savedContours.flat();

        if (startPointGlobalIndex < 0 || startPointGlobalIndex >= allPointsFlat.length ||
            endPointGlobalIndex < 0 || endPointGlobalIndex >= allPointsFlat.length) {
            console.error("Invalid point index selected.");
            return;
        }

        const [x1, y1] = allPointsFlat[startPointGlobalIndex].split('\t').map(Number);
        const [x2, y2] = allPointsFlat[endPointGlobalIndex].split('\t').map(Number);
        
        const directDistance = Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);

        let distanceText = `Расстояние между точкой ${startPointGlobalIndex + 1} и точкой ${endPointGlobalIndex + 1} = ${directDistance.toFixed(2)} м`;

        // Check if points are in the same contour
        let sameContour = false;
        let startContourIndex = -1;
        let endContourIndex = -1;
        let startIdxInContour = -1;
        let endIdxInContour = -1;
        
        let currentGlobalIndex = 0;
        for(let i = 0; i < savedContours.length; i++) {
            const contour = savedContours[i];
            for(let j = 0; j < contour.length; j++) {
                if (currentGlobalIndex === startPointGlobalIndex) {
                    startContourIndex = i;
                    startIdxInContour = j;
                }
                if (currentGlobalIndex === endPointGlobalIndex) {
                    endContourIndex = i;
                    endIdxInContour = j;
                }
                currentGlobalIndex++;
            }
        }

        if (startContourIndex !== -1 && startContourIndex === endContourIndex) {
             sameContour = true;
             const contour = savedContours[startContourIndex];
             const isClosedContour = isContourClosed(contour);
             const numPointsInContour = contour.length;
             let boundaryDistance = 0;

             // Calculate forward boundary distance
             let distForward = 0;
             if (startIdxInContour !== endIdxInContour) { // Only calculate if points are different
                 let tempIdxForward = startIdxInContour;
                 while (tempIdxForward !== endIdxInContour) {
                     const nextIdx = (tempIdxForward + 1) % numPointsInContour;
                     distForward += calculatePointDistance(contour[tempIdxForward].split('\t').map(Number), contour[nextIdx].split('\t').map(Number));
                     tempIdxForward = nextIdx;
                     // Safety break for very large or problematic contours
                     if (distForward > 1e9 || (tempIdxForward === startIdxInContour && distForward > 0) ) {
                         console.warn("Boundary distance calculation (forward) seems to be in an infinite loop or too large. Breaking.");
                         distForward = Infinity; // Mark as problematic
                         break;
                     }
                 }
             }


             if (isClosedContour) {
                 boundaryDistance = distForward; // Use the 'forward' path calculation
             } else {
                 // For an open contour, sum segments *between* the selected points in their linear order
                 boundaryDistance = 0; // Initialize
                 if (startIdxInContour !== endIdxInContour) {
                    const pathStartIdx = Math.min(startIdxInContour, endIdxInContour);
                    const pathEndIdx = Math.max(startIdxInContour, endIdxInContour);
                    for(let k = pathStartIdx; k < pathEndIdx; k++) {
                        boundaryDistance += calculatePointDistance(contour[k].split('\t').map(Number), contour[k+1].split('\t').map(Number));
                    }
                 }
             }

            if (boundaryDistance === Infinity) { // Check if calculation was problematic
                distanceText += `, не удалось рассчитать протяженность частей границы (слишком сложный путь).`;
                 window.lastCalculatedDistance = directDistance; // Fallback to direct distance
                 navigator.clipboard.writeText(directDistance.toFixed(2));
            } else {
                distanceText += `, протяженность частей границы = ${boundaryDistance.toFixed(2)} м`;
                navigator.clipboard.writeText(boundaryDistance.toFixed(2));
                window.lastCalculatedDistance = boundaryDistance; // Save boundary distance
            }

        } else {
             // If points are in different contours or one is not found, use direct distance
             navigator.clipboard.writeText(directDistance.toFixed(2));
             window.lastCalculatedDistance = directDistance; // Save direct distance
        }
                const distanceLog = document.getElementById('distanceLog');
        distanceLog.innerHTML = distanceText;

        distanceLog.style.transition = 'background-color 0.3s';
        distanceLog.style.backgroundColor = 'lime';
        setTimeout(() => {
            distanceLog.style.backgroundColor = 'transparent';
        }, 300);

        
        window.lastStartPointIndex = startPointGlobalIndex;
        window.lastEndPointIndex = endPointGlobalIndex;
    }
}

// Вспомогательная функция для проверки равенства точек
function isPointsEqual(point1, point2) {
    return Math.abs(point1[0] - point2[0]) < 0.000001 && 
           Math.abs(point1[1] - point2[1]) < 0.000001;
}

// Вспомогательная функция для расчета расстояния между точками
function calculatePointDistance(point1, point2) {
    const dx = point2[0] - point1[0];
    const dy = point2[1] - point1[1];
    return Math.sqrt(dx * dx + dy * dy);
}
        
        
        




function updateImportButtonText(fileName) {
    const importButton = document.querySelector('.import-button span'); // Update span text
    importButton.textContent = fileName;
    const importButtonElement = document.querySelector('.import-button');
    importButtonElement.title = fileName; // Добавляем полное имя файла в подсказку
}


function copyWithPoints() {
    if (typeof window.lastCalculatedDistance !== 'undefined' && 
        typeof window.lastStartPointIndex !== 'undefined' && 
        typeof window.lastEndPointIndex !== 'undefined') {
        
        const startPointText = document.getElementById('start-point').options[window.lastStartPointIndex + 1].text;
        const endPointText = document.getElementById('end-point').options[window.lastEndPointIndex + 1].text;

        // Extract contour and point numbers from the text
        const startMatch = startPointText.match(/Контур (\d+), Точка (\d+)/);
        const endMatch = endPointText.match(/Контур (\d+), Точка (\d+)/);

        let startLabel = `н${window.lastStartPointIndex + 1}`;
        let endLabel = `н${window.lastEndPointIndex + 1}`;

        if (startMatch && endMatch && startMatch[1] === endMatch[1]) {
             // If in the same contour, use contour.point format
             startLabel = `${startMatch[1]}.${startMatch[2]}`;
             endLabel = `${endMatch[1]}.${endMatch[2]}`;
        } else if (startMatch) {
             // If only start is in a contour, use its contour.point format
             startLabel = `${startMatch[1]}.${startMatch[2]}`;
             endLabel = `н${window.lastEndPointIndex + 1}`; // Keep global index for end
        } else if (endMatch) {
             // If only end is in a contour, use its contour.point format
             startLabel = `н${window.lastStartPointIndex + 1}`; // Keep global index for start
             endLabel = `${endMatch[1]}.${endMatch[2]}`;
        }
        // If neither is in a contour (shouldn't happen with current logic but for safety),
        // keep the global index format.

        const copyText = `${startLabel}\t${endLabel}\t${window.lastCalculatedDistance.toFixed(2)}`;

        navigator.clipboard.writeText(copyText).then(() => {
            showNotification('Расстояние с точками скопировано в буфер обмена');
        });
    } else {
        showNotification('Сначала выберите две точки');
    }
}

function showNotification(message) {
    const notification = document.getElementById('notification');
    notification.textContent = message;
    notification.style.display = 'block';
    
    setTimeout(() => {
        notification.style.display = 'none';
    }, 2000);
}


function toggleDropdown() {
    document.getElementById("importDropdown").classList.toggle("show");
}

// Закрытие выпадающего списка при клике вне его
window.onclick = function(event) {
    if (!event.target.matches('.import-button') && !event.target.closest('.import-button')) {
        var dropdowns = document.getElementsByClassName("dropdown-content");
        for (var i = 0; i < dropdowns.length; i++) {
            var openDropdown = dropdowns[i];
            if (openDropdown.classList.contains('show')) {
                openDropdown.classList.remove('show');
            }
        }
    }
}




function extractCoordinatesFromSpelementUnit(text) {
    // **** ADD THIS LOG ****
    console.log(">>> Executing extractCoordinatesFromSpelementUnit");
    // *********************
    const coordinates = [];
    // Regex needs to be less strict about surrounding tags and leading characters
    const regex = /<NewOrdinate[^>]*?Num_Geopoint\s*=\s*["'](\d+)["'][^>]*?X\s*=\s*["'](\d+(?:\.\d+)?)["'][^>]*?Y\s*=\s*["'](\d+(?:\.\d+)?)["'][^>]*?\/>/gi;
    let match;
    let lastPointNum = -1;
    let currentContourPoints = 0;
    let matchesFound = 0; // Counter for debugging

    while ((match = regex.exec(text)) !== null) {
        matchesFound++; // Increment match counter
        // ... (rest of the function logic remains the same) ...
        try {
            const pointNum = parseInt(match[1]);
            const xStr = match[2].replace(',', '.');
            const yStr = match[3].replace(',', '.');
            const x = parseFloat(xStr);
            const y = parseFloat(yStr);

            if (!isNaN(pointNum) && !isNaN(x) && !isNaN(y)) {
                // Add separator if point number resets to 1 and we already have points in the current contour
                // This logic assumes point numbers reset to 1 for each new contour.
                if (pointNum === 1 && currentContourPoints > 0) {
                     coordinates.push('');
                     currentContourPoints = 0; // Reset point count for the new contour
                }
                coordinates.push(`${x.toFixed(2)}\t${y.toFixed(2)}`);
                lastPointNum = pointNum; // Keep track of the last point number (not strictly needed with the pointNum === 1 check)
                currentContourPoints++;

            } else {
                console.warn("Spelement_Unit: Failed to parse coordinates/point number from match:", match[0]);
            }
        } catch (e) {
            console.error("Spelement_Unit: Error processing match:", match[0], e);
        }
    }

    // **** ADD DEBUG LOGS AT THE END ****
    console.log(`<<< extractCoordinatesFromSpelementUnit: Regex found ${matchesFound} potential matches.`);
    if (coordinates.length > 0) {
        console.log(`<<< extractCoordinatesFromSpelementUnit: Successfully extracted ${coordinates.filter(c => c !== '').length} coordinate pairs.`);
    } else {
         console.log("<<< extractCoordinatesFromSpelementUnit: Failed to extract coordinates.");
    }
    // **********************************

    // ... (rest of the cleanup logic) ...
     while (coordinates.length > 0 && coordinates[coordinates.length - 1] === '') {
        coordinates.pop();
    }

    return coordinates;
}



function extractCoordinatesFromXMLType1(text) {
    const coordinates = [];
    
    // Проверяем наличие маркера
    const startMarker = "<contours_location>";
    const hasMarker = text.includes(startMarker);
    
    // Определяем текст для обработки
    let textToProcess;
    if (hasMarker) {
        // Если маркер есть, берем текст после него
        const startIndex = text.indexOf(startMarker);
        textToProcess = text.substring(startIndex + startMarker.length);
    } else {
        // Если маркер нет, обрабатываем весь текст
        textToProcess = text;
    }
    
    // Разделяем на контуры
    const contours = textToProcess.split('</entity_spatial>');

    contours.forEach((contour, index) => {
        const regex = /<x>(\d+(?:\.\d+)?)<\/x>\s*<y>(\d+(?:\.\d+)?)<\/y>/g;
        let matches;
        let currentContour = [];

        while ((matches = regex.exec(contour)) !== null) {
            const x = parseFloat(matches[1]).toFixed(2);
            const y = parseFloat(matches[2]).toFixed(2);
            currentContour.push(`${x}\t${y}`);
        }

        if (currentContour.length > 0) {
            if (coordinates.length > 0) coordinates.push('');
            coordinates.push(...currentContour);
        }
    });

    return coordinates;
}

function extractCoordinatesFromXMLType2(text) {
    const coordinates = [];
    
    // Удаляем все содержимое между тегами SpecifyRelatedParcel
    text = text.replace(/<SpecifyRelatedParcel[\s\S]*?<\/SpecifyRelatedParcel>/g, '');
    
    // Ищем координаты во втором формате
    const regex2 = /X="(\d+(?:\.\d+)?)"[^>]+Y="(\d+(?:\.\d+)?)"[^>]+/g;
    let matches2 = Array.from(text.matchAll(regex2));
    
    if (matches2.length > 0) {
        // Разделяем на контуры по тегу SpatialElement
        const contours = text.split('</SpatialElement>');
        
        contours.forEach((contour, index) => {
            const contourMatches = Array.from(contour.matchAll(regex2));
            let currentContour = [];

            contourMatches.forEach(match => {
                const x = parseFloat(match[1]).toFixed(2);
                const y = parseFloat(match[2]).toFixed(2);
                currentContour.push(`${x}\t${y}`);
            });

            if (currentContour.length > 0) {
                if (coordinates.length > 0) coordinates.push('');
                coordinates.push(...currentContour);
            }
        });
    }

    return coordinates;
}

function extractCoordinatesFromXML(text) {
    // Сначала пробуем первый тип
    const coordinates1 = extractCoordinatesFromXMLType1(text);
    
    // Если первый тип не дал результатов, пробуем второй
    if (coordinates1.length === 0) {
        return extractCoordinatesFromXMLType2(text);
    }
    
    return coordinates1;
}


function appendCoordinates(coordinates) {
    const coordsInput = document.getElementById('coordsInput');
    let currentValue = coordsInput.value.trim();
    
    // If there are coordinates in the current value
    if (currentValue) {
        // Ensure there's a double newline separator
        if (!currentValue.endsWith('\n\n')) {
            currentValue += '\n\n';
        } else if (currentValue.endsWith('\n')) {
             currentValue += '\n'; // Ensure it's double newline
        }
        coordsInput.value = currentValue + coordinates.join('\n');
    } else {
        // If the input is empty, just set the value
        coordsInput.value = coordinates.join('\n');
    }
    // Trigger handleInput to process the updated text
    handleInput(true);
}



function extractCoordinatesFromInteractEntryBoundaries(text) {
    const coordinates = [];
    const contours = text.split('</EnSpa2:entity_spatial>');

    contours.forEach((contour, index) => {
        const regex = /<EnSpa2:x>(\d+(?:\.\d+)?)<\/EnSpa2:x>\s*<EnSpa2:y>(\d+(?:\.\d+)?)<\/EnSpa2:y>/g;
        let matches;
        let currentContour = [];

        while ((matches = regex.exec(contour)) !== null) {
            const x = parseFloat(matches[1]).toFixed(2);
            const y = parseFloat(matches[2]).toFixed(2);
            currentContour.push(`${x}\t${y}`);
        }

        if (currentContour.length > 0) {
            if (coordinates.length > 0) coordinates.push(''); // Добавляем пустую строку между контурами
            coordinates.push(...currentContour);
        }
    });

    return coordinates;
}





    
// Модифицированная версия importFile()
function importFile(isAppend = false) {
    const fileInput = document.createElement('input');
    fileInput.type = 'file';
    fileInput.accept = '.xml,.zip,.dxf,.mif,.csv,.txt';
    
    fileInput.onchange = function(e) {
        const file = e.target.files[0];
        if (!file) return;

        const extension = file.name.split('.').pop().toLowerCase();
        const reader = new FileReader();

        reader.onload = function(event) {
            let content = event.target.result;
            let coordinates;

            switch (extension) {
                case 'xml':
                case 'zip':
                    if (extension === 'zip') {
                        handleZipFile(file, isAppend);
                        return;
                    }
                    // Проверяем, содержит ли файл interact_entry_boundaries
                    if (content.includes('interact_entry_boundaries')) {
                        coordinates = extractCoordinatesFromInteractEntryBoundaries(content);
                    } else {
                        coordinates = extractCoordinatesFromXML(content);
                    }
                    break;
                case 'dxf':
                    coordinates = extractCoordinatesFromDXF(content);
                    break;
                case 'mif':
                    coordinates = extractCoordinatesFromMIF(content);
                    break;
                case 'csv':
                case 'txt':
                    coordinates = extractCoordinatesFromText(content);
                    break;
                default:
                    showNotification('Неподдерживаемый формат файла');
                    return;
            }

            if (coordinates && coordinates.length > 0) {
                if (isAppend) {
                    appendCoordinates(coordinates);
                } else {
                    document.getElementById('coordsInput').value = coordinates.join('\n');
                    handleInput(true);
                }
                updateImportButtonText(file.name);
            } else {
                showNotification('Не удалось найти координаты в файле');
            }
        };

        reader.onerror = function() {
            showNotification('Ошибка при чтении файла');
        };

        if (extension === 'zip') {
            reader.readAsArrayBuffer(file);
        } else {
            reader.readAsText(file, 'UTF-8');
        }
    };

    fileInput.click();
}

function generateAndDownloadJSON() {
    const input = document.getElementById('coordsInput').value.trim();
    const contours = input.split('\n\n').filter(contour => contour.trim() !== '');

    // Корректируем координаты: X всегда меньше Y
    const correctedContours = contours.map(contour => {
        return contour.split('\n').map(line => {
            let [x, y] = line.split(/\s+/).map(Number);
            if (x > y) {
                [x, y] = [y, x]; // Меняем местами, если X > Y
            }
            return [x, y];
        });
    });

    // Формируем GeoJSON
    const geoJSON = {
        type: "FeatureCollection",
        features: [
            {
                type: "Feature",
                geometry: {
                    type: "MultiPolygon",
                    coordinates: correctedContours.map(contour => [
                        contour.map(([x, y]) => [y, x]) // Формат GeoJSON: [Y, X]
                    ])
                }
            }
        ]
    };

    // Преобразуем в строку и скачиваем файл
    const jsonContent = JSON.stringify(geoJSON, null, 2);
    const jsonBlob = new Blob([jsonContent], { type: 'application/json;charset=utf-8;' });
    const jsonUrl = URL.createObjectURL(jsonBlob);
    const jsonLink = document.createElement('a');
    jsonLink.href = jsonUrl;
    jsonLink.download = 'nspd.geojson';
    document.body.appendChild(jsonLink);
    jsonLink.click();
    document.body.removeChild(jsonLink);
    URL.revokeObjectURL(jsonUrl);

    // Скачиваем CSV
    nspdcsv(correctedContours);
}

function nspdcsv(correctedContours) {
    let csvContent = ""; // Без заголовка
    correctedContours.forEach(contour => {
        contour.forEach(([x, y]) => {
            csvContent += `${y} ${x}\n`; // Формат: Y X
        });
        csvContent += '\n'; // Пустая строка между контур
    });

    // Создаем и скачиваем файл
    const csvBlob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
    const csvUrl = URL.createObjectURL(csvBlob);
    const csvLink = document.createElement('a');
    csvLink.href = csvUrl;
    csvLink.download = 'nspd.csv';
    document.body.appendChild(csvLink);
    csvLink.click();
    document.body.removeChild(csvLink);
    URL.revokeObjectURL(csvUrl);
}



function handleZipFile(file, isAppend = false) {
    const reader = new FileReader();
    
    reader.onload = function(event) {
        const zipData = event.target.result;
        JSZip.loadAsync(zipData).then(function(zip) {
            let xmlFile = null;
            
            zip.forEach(function(relativePath, zipEntry) {
                if (relativePath.toLowerCase().endsWith('.xml')) {
                    xmlFile = zipEntry;
                }
            });
            
            if (xmlFile) {
                xmlFile.async("string").then(function(xmlContent) {
                    let coordinates;
                    if (xmlContent.includes('interact_entry_boundaries')) {
                        coordinates = extractCoordinatesFromInteractEntryBoundaries(xmlContent);
                    } else {
                        coordinates = extractCoordinatesFromXML(xmlContent);
                    }
                    
                    if (coordinates && coordinates.length > 0) {
                        if (isAppend) {
                            appendCoordinates(coordinates);
                        } else {
                            document.getElementById('coordsInput').value = coordinates.join('\n');
                            handleInput(true);
                        }
                        updateImportButtonText(file.name);
                    } else {
                        showNotification('Не удалось найти координаты в XML файле внутри архива');
                    }
                });
            } else {
                showNotification('XML файл не найден в архиве');
            }
        }).catch(function(err) {
            showNotification('Ошибка при разархивации ZIP файла');
            console.error('Ошибка разархивации:', err);
        });
    };
    
    reader.onerror = function() {
        showNotification('Ошибка при чтении ZIP файла');
    };
    
    reader.readAsArrayBuffer(file);
}



function handleXmlFile(file) {
    const reader = new FileReader();
    
    reader.onload = function(event) {
        const xmlContent = event.target.result;
        processXmlContent(xmlContent);
    };
    
    reader.onerror = function() {
        showNotification('Ошибка при чтении XML файла');
    };
    
    reader.readAsText(file, 'UTF-8');
}

function processXmlContent(xmlContent) {
    const coordinates = extractCoordinatesFromXML(xmlContent);
    
    if (coordinates.length > 0) {
        document.getElementById('coordsInput').value = coordinates.join('\n');
        handleInput(true); // true означает показывать уведомления
    } else {
        showNotification('Не удалось найти координаты в XML файле');
    }
}




function extractCoordinatesFromDXF(dxfContent) {
    const lines = dxfContent.split('\n');
    const coordinates = [];
    let currentContour = [];
    let isReadingCoords = false;
    let isPolyline = false;
    let isClosed = false;
    let x, y;

    for (let i = 0; i < lines.length; i++) {
        const line = lines[i].trim();

        if (line === 'POLYLINE') {
            isReadingCoords = true;
            isPolyline = true;
            isClosed = false;
            if (currentContour.length > 0) {
                processDXFContour(currentContour, coordinates, isClosed);
                currentContour = [];
            }
        } else if (line === 'LWPOLYLINE') {
            isReadingCoords = true;
            isPolyline = false;
            isClosed = false;
            if (currentContour.length > 0) {
                processDXFContour(currentContour, coordinates, isClosed);
                currentContour = [];
            }
        } else if (line === 'SEQEND') {
            isReadingCoords = false;
            if (currentContour.length > 0) {
                processDXFContour(currentContour, coordinates, isClosed);
                currentContour = [];
            }
        } else if (isReadingCoords) {
            if (line === '70') {
                isClosed = parseInt(lines[++i].trim()) === 1;
            } else if (isPolyline) { // Handling for POLYLINE -> VERTEX
                if (line === 'VERTEX') {
                    x = y = undefined;
                } else if (line === '10') {
                    x = parseFloat(lines[++i].trim());
                } else if (line === '20') {
                    y = parseFloat(lines[++i].trim());
                    if (x !== undefined && y !== undefined) {
                        // START OF CHANGE 1
                        if (x !== 0 && y !== 0) { // Ignore if x or y is 0
                            currentContour.push([Math.min(x, y), Math.max(x, y)]);
                        }
                        // END OF CHANGE 1
                        x = y = undefined;
                    }
                }
            } else { // Handling for LWPOLYLINE
                if (line === '10') {
                    x = parseFloat(lines[++i].trim());
                } else if (line === '20') {
                    y = parseFloat(lines[++i].trim());
                    if (x !== undefined && y !== undefined) {
                        // START OF CHANGE 2
                        if (x !== 0 && y !== 0) { // Ignore if x or y is 0
                           currentContour.push([Math.min(x, y), Math.max(x, y)]);
                        }
                        // END OF CHANGE 2
                        x = y = undefined;
                    }
                }
            }
        }
    }

    // Обработка последнего контура, если он есть
    if (currentContour.length > 0) {
        processDXFContour(currentContour, coordinates, isClosed);
    }

    return coordinates;
}

function processDXFContour(contour, coordinates, isClosed) {
    // Добавляем пустую строку перед новым контуром, если это не первый контур
    if (coordinates.length > 0) {
        coordinates.push('');
    }

    // Добавляем координаты контура
    contour.forEach(([x, y]) => {
        coordinates.push(`${x.toFixed(2)}\t${y.toFixed(2)}`);
    });

    // Если контур замкнут и первая точка не совпадает с последней, добавляем первую точку в конец
    if (isClosed && contour.length > 1) {
        const [firstX, firstY] = contour[0];
        const [lastX, lastY] = contour[contour.length - 1];
        if (firstX !== lastX || firstY !== lastY) {
            coordinates.push(`${firstX.toFixed(2)}\t${firstY.toFixed(2)}`);
        }
    }
}


function generateCSV(coords) {
    let csvContent = "Контур;Префикс номера;Номер;Старый X;Старый Y;Новый X;Новый Y;Метод определения;Формула;Радиус;Погрешность;Описание закрепления\n";
    csvContent += ";;;;;;;;;;;\n";

    let contourNumber = 1;
    let pointNumber = 1;
    let contour = [];

    coords.forEach((coord, index) => {
        if (coord.trim() === '') {
            // Завершаем текущий контур
            if (contour.length > 0) {
                csvContent += processContour(contour, contourNumber, pointNumber);
                contourNumber++;
                pointNumber = 1;
                contour = [];
                csvContent += ";;;;;;;;;;;\n"; // Пустая строка между контурами
            }
        } else {
            const [x, y] = coord.split(/\s+|\t/).map(Number);
            if (!isNaN(x) && !isNaN(y)) {
                contour.push([x, y]);
            } else {
                console.warn('Некорректные координаты:', coord);
            }
        }
    });

    // Обрабатываем последний контур, если он есть
    if (contour.length > 0) {
        csvContent += processContour(contour, contourNumber, pointNumber);
    }

    return csvContent;
}

function processContour(contour, contourNumber, startPointNumber) {
    let csvContent = '';
    const isClosed = (contour.length > 1 && contour[0][0] === contour[contour.length - 1][0] &&
                      contour[0][1] === contour[contour.length - 1][1]);
    
    contour.forEach(([x, y], index) => {
        if (index === contour.length - 1 && isClosed) {
            return; // Пропускаем последнюю точку, если она совпадает с первой
        }
        
        csvContent += `[${contourNumber}];н;${startPointNumber + index};;;${x.toFixed(2)};${y.toFixed(2)};;;;0,1;Долговременный межевой знак\n`;
    });

    // Добавляем первую точку в конец для замкнутого контура
    if (isClosed) {
        const [x, y] = contour[0];
        csvContent += `[${contourNumber}];н;${startPointNumber};;;${x.toFixed(2)};${y.toFixed(2)};;;;0,1;Долговременный межевой знак\n`;
    }

    return csvContent;
}


function extractCoordinatesFromMIF(mifContent) {
    const lines = mifContent.split('\n');
    const coordinates = [];
    let isDataSection = false;
    let currentContour = [];
    let pointsInContour = 0;
    let isRegionType = false;

    for (let i = 0; i < lines.length; i++) {
        const line = lines[i].trim();

        if (line === 'Data') {
            isDataSection = true;
            continue;
        }

        if (!isDataSection) continue;

        if (line.startsWith('Region')) {
            isRegionType = true;
            if (currentContour.length > 0) {
                coordinates.push(...currentContour, '');
                currentContour = [];
            }
            // Read the number of points for the region
            const numPointsMatch = line.match(/Region\s+\d+\s*(\d+)/);
            if (numPointsMatch && numPointsMatch[1]) {
                 pointsInContour = parseInt(numPointsMatch[1]);
            } else {
                 // If number of points is not on the same line, assume it's on the next line
                 if (i + 1 < lines.length) {
                     pointsInContour = parseInt(lines[i+1].trim());
                     if (!isNaN(pointsInContour)) {
                         i++; // Skip the next line as it was the point count
                     } else {
                         pointsInContour = 0; // Reset if parsing fails
                     }
                 } else {
                     pointsInContour = 0; // Reset if no next line
                 }
            }
            continue;
        }

        if (line.startsWith('PLINE')) {
            isRegionType = false;
            if (currentContour.length > 0) {
                coordinates.push(...currentContour, '');
                currentContour = [];
            }
            pointsInContour = parseInt(line.split(' ')[1]);
            continue;
        }

        // Check if the line contains coordinates (two numbers separated by space/tab/comma)
        const coordMatch = line.match(/^(\d+(?:[.,]\d+)?)\s*[,;\t]?\s*(\d+(?:[.,]\d+)?)$/);
        if (coordMatch) {
             const x = parseFloat(coordMatch[1].replace(',', '.'));
             const y = parseFloat(coordMatch[2].replace(',', '.'));

             if (!isNaN(x) && !isNaN(y)) {
                 currentContour.push(`${Math.min(x, y).toFixed(2)}\t${Math.max(x, y).toFixed(2)}`);

                 // For PLINE, we know the total points beforehand
                 if (!isRegionType && currentContour.length === pointsInContour) {
                     coordinates.push(...currentContour, '');
                     currentContour = [];
                     pointsInContour = 0; // Reset for next PLINE
                 }
                 // For Region, we don't know total points until we've read them all,
                 // or if they are specified on the Region line.
                 // The logic below handles the case where points are listed after the Region line.
             }
        } else if (line.startsWith('Pen') || line.startsWith('PEN') || line.startsWith('Point')) {
            // Ignore lines with pen settings or single points
            continue;
        } else if (isDataSection && line.trim() !== '') {
             // If we are in the Data section and the line is not empty,
             // but it's not a coordinate line or a known object type (Region/PLINE),
             // it might be a point count line for a Region object.
             const potentialPointCount = parseInt(line.trim());
             if (!isNaN(potentialPointCount) && isRegionType && pointsInContour === 0) {
                 pointsInContour = potentialPointCount;
             } else {
                 // If it's not a point count or coordinate, and we have a current contour,
                 // it might be the end of a contour followed by non-coordinate data.
                 if (currentContour.length > 0) {
                     coordinates.push(...currentContour, '');
                     currentContour = [];
                     pointsInContour = 0; // Reset
                 }
             }
        }
    }

    // Add the last contour if it exists and wasn't followed by a separator
    if (currentContour.length > 0) {
        coordinates.push(...currentContour);
    }

    // Remove trailing empty lines
    while (coordinates.length > 0 && coordinates[coordinates.length - 1] === '') {
        coordinates.pop();
    }

    return coordinates;
}

function processMIFContour(contour, coordinates) {
    // This function seems redundant now that MIF parsing is done in extractCoordinatesFromMIF
    // Keeping it for reference or if needed elsewhere, but it's not called by extractCoordinatesFromMIF
    console.warn("processMIFContour called - this might be unexpected.");
    // Add empty line before new contour if not the first
    if (coordinates.length > 0) {
        coordinates.push('');
    }

    // Check if contour is closed
    const isClosed = (contour.length > 1 && contour[0][0] === contour[contour.length - 1][0] &&
                      contour[0][1] === contour[contour.length - 1][1]);

    // Add contour coordinates
    contour.forEach(([x, y], index) => {
        if (index === contour.length - 1 && isClosed) {
            return; // Skip last point if it's a duplicate of the first in a closed contour
        }
        coordinates.push(`${x.toFixed(2)}\t${y.toFixed(2)}`);
    });

    // If closed, add the first point again to explicitly close it in the output format
    if (isClosed) {
        const [x, y] = contour[0];
        coordinates.push(`${x.toFixed(2)}\t${y.toFixed(2)}`);
    }
}



function extractCoordinatesFromText(content) {
    const lines = content.split('\n');
    const coordinates = [];
    const numberRegex = /[-+]?[0-9]*[.,]?[0-9]+/g;
    let lastLineHadCoordinates = false;

    for (let i = 0; i < lines.length; i++) {
        const line = lines[i].trim();
        
        if (line === '') {
             // If current line is empty and the previous one had coordinates,
             // it signifies the end of a contour.
            if (lastLineHadCoordinates && coordinates.length > 0 && coordinates[coordinates.length - 1] !== '') {
                coordinates.push('');
            }
            lastLineHadCoordinates = false; // Reset flag for empty line
            continue; // Skip empty lines
        }

        const numbers = line.match(numberRegex);
        const potentialCoords = numbers ? numbers.map(n => parseFloat(n.replace(',', '.')))
                                                 .filter(n => Math.abs(n) >= 10000)
                                        : [];

        if (potentialCoords.length >= 2) {
            const [x, y] = potentialCoords[0] < potentialCoords[1] 
                ? [potentialCoords[0], potentialCoords[1]]
                : [potentialCoords[1], potentialCoords[0]];

            coordinates.push(`${x.toFixed(2)}\t${y.toFixed(2)}`);
            lastLineHadCoordinates = true;
        } else {
            // If current line has text but no coordinates, and previous had coords,
            // it also signifies the end of a contour (text as description).
            if (lastLineHadCoordinates && coordinates.length > 0 && coordinates[coordinates.length - 1] !== '') {
                coordinates.push(''); // Add contour separator
            }
            lastLineHadCoordinates = false; // Reset flag as this line didn't have coords
        }
    }

    // Remove trailing empty lines
    while (coordinates.length > 0 && coordinates[coordinates.length - 1] === '') {
        coordinates.pop();
    }

    // If coordinates were found using the text parsing logic, return them.
    // Otherwise, try the importGeo logic as a fallback.
    // Note: This might be problematic if text contains both formats.
    // A better approach might be to try all parsers and merge results,
    // but that's more complex. For now, prioritize text/tab/description parsing,
    // then fall back to importGeo if nothing was found.
     const hasTextCoords = coordinates.some(c => c.trim() !== '');
     if (hasTextCoords) {
         return coordinates;
     } else {
         console.log("extractCoordinatesFromText: No text/tab/description coords found, trying importGeo.");
         return importGeo(content);
     }
}


  const schemeButton = document.getElementById('schemeButton');
    const schemeMenu = document.getElementById('schemeMenu');
    const expandLinearObject = document.getElementById('expandLinearObject');
    const widthDialog = document.getElementById('widthDialog');
    const widthInput = document.getElementById('widthInput');
    const applyWidth = document.getElementById('applyWidth');
    const cancelWidth = document.getElementById('cancelWidth');

    schemeButton.addEventListener('click', () => {
        schemeMenu.style.display = schemeMenu.style.display === 'none' ? 'block' : 'none';
    });

    expandLinearObject.addEventListener('click', () => {
        widthDialog.style.display = 'block';
    });

    cancelWidth.addEventListener('click', () => {
        widthDialog.style.display = 'none';
    });

    applyWidth.addEventListener('click', () => {
        const width = parseFloat(widthInput.value);
        if (isNaN(width) || width <= 0) {
            alert('Пожалуйста, введите положительное число для ширины.');
            return;
        }
        expandLinearObjectToArea(width);
        widthDialog.style.display = 'none';
    });




function generateDistancesCSV() {
    const input = document.getElementById('coordsInput').value.trim();
    const contours = input.split('\n\n').filter(contour => contour.trim() !== '');

    // Подготовка данных для Excel
    let data = [
        ['от точки', 'до точки', 'Горизонтальное проложение (S), м']
    ];
    let shortDistances = [];

    // Keep track of global point index
    let globalPointIndex = 0;

    contours.forEach((contour, contourIndex) => {
        const points = contour.split('\n').map(line => {
            const [x, y] = line.split(/\s+|\t/).map(Number);
            return { x, y };
        });

        // Skip empty contours
        if (points.length === 0) {
             return;
        }

        // Convert points array of objects back to string format for isContourClosed
        const pointsStringFormat = points.map(p => `${p.x}\t${p.y}`);

        // Проверяем, является ли контур замкнутым (первая и последняя точки совпадают с учетом погрешности)
        const isClosedContour = isContourClosed(pointsStringFormat);


        // Расчёт расстояний между последовательными точками
        // Iterate through all points. The segment is from points[i] to the next point.
        // The 'next point' wraps around for the last point if it's a closed contour.
        for (let i = 0; i < points.length; i++) {
            let next_i = (i + 1) % points.length; // Index of the next point (0 for the point after the last)

            // If it's a closed contour AND we are processing the segment from the last point (index points.length - 1)
            // back to the first point (index 0), skip this segment as per user request.
            // This check now correctly uses the tolerance-based isClosedContour
            if (isClosedContour && i === points.length - 1) {
                 continue;
            }

            const p1 = points[i];
            const p2 = points[next_i];

            const distance = calculateDistance(p1, p2);

            // Determine point numbers for the output (global index + 1)
            let pointNumber1 = globalPointIndex + i + 1;
            let pointNumber2;
            // If next_i is 0 (meaning we wrapped around from the last point to the first)
            // and the contour is closed, the second point is the *first* point of the contour.
            if (isClosedContour && next_i === 0) {
                 pointNumber2 = globalPointIndex + 1; // Global index of the first point
            } else {
                 // Otherwise, the second point is simply the next point in the sequence
                 pointNumber2 = globalPointIndex + next_i + 1;
            }


            data.push([{v: pointNumber1, t: 's'}, {v: pointNumber2, t: 's'}, Number(distance.toFixed(2))]);

            if (distance < 0.1) {
                shortDistances.push({
                    point1: pointNumber1,
                    point2: pointNumber2,
                    distance: Number(distance.toFixed(2)),
                    x1: p1.x,
                    y1: p1.y,
                    x2: p2.x,
                    y2: p2.y
                });
            }
        }

        // Update global point index for the next contour
        globalPointIndex += points.length;


        // Добавляем пустую строку между контурами (только если это не последний контур)
        if (contourIndex < contours.length - 1) {
            data.push([]);
        }
    });

    // Добавляем три пустые строки
    data.push([]);
    data.push([]);
    data.push([]);

    // Добавляем информацию о коротких расстояниях
    if (shortDistances.length > 0) {
        data.push(['Расстояние менее 10 см:']);
        data.push([]); // Пустая строка

        shortDistances.forEach(dist => {
            data.push([
                {v: dist.point1, t: 's'},
                {v: dist.point2, t: 's'},
                dist.distance,
                '',  // Пустая колонка для разделения
                dist.x1.toFixed(2),
                dist.y1.toFixed(2),
                dist.x2.toFixed(2),
                dist.y2.toFixed(2)
            ]);
        });
    } else {
        data.push(['Расстояний между точками менее 10 см не обнаружено']);
    }

    // Создаем рабочую книгу
    const wb = XLSX.utils.book_new();
    const ws = XLSX.utils.aoa_to_sheet(data);

    // Настройка стилей и форматирования
    ws['!cols'] = [
        { wch: 10 }, // от точки
        { wch: 10 }, // до точки
        { wch: 30 }, // расстояние
        { wch: 5 },  // пустой разделитель
        { wch: 15 }, // x1
        { wch: 15 }, // y1
        { wch: 15 }, // x2
        { wch: 15 }  // y2
    ];

    // Добавляем заголовки для координат в секции коротких расстояний
    if (shortDistances.length > 0) {
        // Find the row index where short distances start
        let shortDistancesStartRow = -1;
        for(let i = 0; i < data.length; i++) {
                if (data[i] && data[i][0] === 'Расстояние менее 10 см:') {
                shortDistancesStartRow = i + 2; // Header is 2 rows below the title
                break;
            }
        }

        if (shortDistancesStartRow !== -1) {
            const headerCell1 = XLSX.utils.encode_cell({ r: shortDistancesStartRow -1 , c: 4 }); // Row above first data row
            const headerCell2 = XLSX.utils.encode_cell({ r: shortDistancesStartRow -1, c: 5 });
            const headerCell3 = XLSX.utils.encode_cell({ r: shortDistancesStartRow -1, c: 6 });
            const headerCell4 = XLSX.utils.encode_cell({ r: shortDistancesStartRow -1, c: 7 });

            ws[headerCell1] = { v: 'X1', t: 's' };
            ws[headerCell2] = { v: 'Y1', t: 's' };
            ws[headerCell3] = { v: 'X2', t: 's' };
            ws[headerCell4] = { v: 'Y2', t: 's' };
        }
    }

    // Применяем числовой формат для колонок с числами
    for (let i = 1; i < data.length; i++) {
        const row = data[i];
        if (row && row.length > 0) {
            // Format distance column (column index 2)
            const distCellRef = XLSX.utils.encode_cell({ r: i, c: 2 });
            if (ws[distCellRef] && typeof ws[distCellRef].v === 'number') {
                ws[distCellRef].z = '0.00';
            }

            // Format coordinate columns (indices 4 to 7) in the short distances section
            // Check if this row is part of the short distances section
             let isShortDistanceRow = false;
             if (shortDistances.length > 0) {
                 const shortDistancesDataStartRow = data.findIndex(row => row && row[0] === 'Расстояние менее 10 см:') + 2; // Ensure row is not null/undefined
                 if (i >= shortDistancesDataStartRow && i < shortDistancesDataStartRow + shortDistances.length) {
                     isShortDistanceRow = true;
                 }
             }

             if (isShortDistanceRow) {
                 for (let j = 4; j <= 7; j++) {
                     const coordCellRef = XLSX.utils.encode_cell({ r: i, c: j });
                     // Check if the cell exists and contains a number before formatting
                     if (ws[coordCellRef] && typeof ws[coordCellRef].v === 'number') {
                         ws[coordCellRef].z = '0.00';
                     }
                 }
             }
        }
    }


    // Add sheet to workbook and save file
    XLSX.utils.book_append_sheet(wb, ws, 'Расстояния');
    XLSX.writeFile(wb, 'distances.xlsx');
}

function downloadCSV(content, fileName) {
    const bom = '\uFEFF'; // BOM для корректного отображения кириллицы
    const blob = new Blob([bom + content], { type: 'text/plain;charset=utf-8;' });
    const link = document.createElement('a');
    link.href = URL.createObjectURL(blob);
    link.download = fileName;
    link.style.display = 'none';
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
}

function calculateDistance(point1, point2) {
    const dx = point2.x - point1.x;
    const dy = point2.y - point1.y;
    return Math.sqrt(dx * dx + dy * dy);
}



function expandLinearObjectToArea(width) {
    const coordsInput = document.getElementById('coordsInput');
    const inputText = coordsInput.value.trim();
    const halfWidth = width / 2.0; // Смещение в каждую сторону

    // Векторные операции
    const vecSubtract = (a, b) => ({ x: a.x - b.x, y: a.y - b.y });
    const vecAdd = (a, b) => ({ x: a.x + b.x, y: a.y + b.y });
    const vecScale = (v, s) => ({ x: v.x * s, y: v.y * s });
    const vecLength = (v) => Math.sqrt(v.x * v.x + v.y * v.y);
    const vecNormalize = (v) => {
        const len = vecLength(v);
        return len > 0.00001 ? vecScale(v, 1 / len) : { x: 0, y: 0 };
    };
    // Перпендикулярный вектор (поворот на 90 градусов против часовой стрелки)
    const vecPerpendicular = (v) => ({ x: -v.y, y: v.x });

    // --- Получение и проверка точек первого контура ---
    const contours = inputText.split('\n\n');
    if (!contours || contours.length === 0) {
         alert('Нет координат для обработки.');
         return;
    }
    const firstContourStr = contours[0].trim();
     if (!firstContourStr) {
        alert('Первый контур пуст.');
        return;
    }
    const coords = firstContourStr.split('\n');
    if (coords.length < 2) {
        alert('Недостаточно точек (минимум 2) в первом контуре для создания утолщения.');
        return;
    }

    // Парсинг точек
    const points = coords.map(coord => {
        const parts = coord.split(/\s+|\t/);
        if (parts.length >= 2) {
            const xStr = parts[0].replace(',', '.');
            const yStr = parts[1].replace(',', '.');
            const x = parseFloat(xStr);
            const y = parseFloat(yStr);
            if (!isNaN(x) && !isNaN(y)) return { x, y };
        }
        return null;
    }).filter(p => p !== null);

    if (points.length < 2) {
        alert('Недостаточно валидных точек (минимум 2) в первом контуре.');
        return;
    }

    // Проверка, не замкнут ли уже контур
    const firstP = points[0];
    const lastP = points[points.length - 1];
    const tolerance = 0.001;
    if (Math.abs(firstP.x - lastP.x) < tolerance && Math.abs(firstP.y - lastP.y) < tolerance) {
         alert('Первый объект уже является замкнутым (площадным). Утолщение применяется к линейным объектам.');
         return;
    }

    // --- Вычисление точек смещения ---
    const leftPoints = [];
    const rightPoints = [];

    for (let i = 0; i < points.length; i++) {
        const p_curr = points[i];
        let normal;

        if (i === 0) {
            // Начальная точка: используем нормаль первого сегмента
            const p_next = points[i + 1];
            const segmentVec = vecSubtract(p_next, p_curr);
            normal = vecNormalize(vecPerpendicular(segmentVec));
        } else if (i === points.length - 1) {
            // Конечная точка: используем нормаль последнего сегмента
            const p_prev = points[i - 1];
            const segmentVec = vecSubtract(p_curr, p_prev); // Направление то же
            normal = vecNormalize(vecPerpendicular(segmentVec));
        } else {
            // Внутренняя точка (угол): усредняем нормали соседних сегментов
            const p_prev = points[i - 1];
            const p_next = points[i + 1];

            const vecIn = vecNormalize(vecSubtract(p_curr, p_prev));
            const vecOut = vecNormalize(vecSubtract(p_next, p_curr));

            const normalIn = vecPerpendicular(vecIn);
            const normalOut = vecPerpendicular(vecOut);

            // Усредненная нормаль (направление биссектрисы угла между нормалями)
            // Суммируем и нормализуем
            normal = vecNormalize(vecAdd(normalIn, normalOut));

             // Коррекция длины для острых углов (Miter join adjustment)
            // Вычисляем косинус половины угла между сегментами (через скалярное произведение нормалей)
            // dot product = cos(angle between normals)
            let dot = normalIn.x * normalOut.x + normalIn.y * normalOut.y;
            // Ограничиваем dot product в диапазоне [-1, 1] для избежания ошибок acos
             dot = Math.max(-1.0, Math.min(1.0, dot));
             // Угол между нормалями = угол между сегментами
             // Половина угла для miter join: angle/2
             // cos(angle/2) = sqrt((1 + cos(angle))/2)
             let cosHalfAngle = Math.sqrt((1.0 + dot) / 2.0);

             // Если угол очень маленький (почти прямая линия) или развернутый, используем простую нормаль
             // и избегаем деления на ноль или очень маленькое число
             if (cosHalfAngle < 0.1) {
                 // Если угол почти 180 градусов, нормали почти противоположны, их сумма ~0.
                 // В этом случае просто используем нормаль одного из сегментов.
                 normal = normalIn; // или normalOut
             }
             // else { // Эта коррекция длины может давать слишком большие выступы на острых углах
                 // miterScale = 1.0 / cosHalfAngle; // Масштаб для смещения вдоль биссектрисы
             // }
             // Пока оставим без коррекции масштаба для простоты, можно добавить позже если нужно
        }

        // Добавляем смещенные точки
        leftPoints.push(vecAdd(p_curr, vecScale(normal, halfWidth)));
        rightPoints.push(vecAdd(p_curr, vecScale(normal, -halfWidth))); // или vecSubtract
    }

    // --- Формирование полигона ---
    // Идем по левым точкам вперед, затем по правым точкам назад
    const polygonPoints = [
        ...leftPoints,          // L1, L2, ..., Ln
        ...rightPoints.reverse() // Rn, Rn-1, ..., R1
    ];

    // Замыкаем полигон, добавляя первую левую точку в конец
    polygonPoints.push(leftPoints[0]);

    // --- Форматирование и добавление в поле ввода ---
    const newCoordsArray = polygonPoints.map(p => `${p.x.toFixed(2)}\t${p.y.toFixed(2)}`);
    const newCoordsString = newCoordsArray.join('\n');

    const separator = coordsInput.value.trim() ? '\n\n' : '';
    coordsInput.value += separator + newCoordsString;

    // Обновляем отображение
    handleInput(true);
    showNotification(`Создан площадной объект толщиной ${width}м из первого линейного.`);
}



function checkDistances() {
    const input = document.getElementById('coordsInput').value.trim();
    if (!input) {
        showNotification('Нет координат для проверки расстояний.');
        return;
    }

    const contours = input.split('\n\n').filter(contour => contour.trim() !== '');
    let shortDistances = [];
    
    contours.forEach((contour) => {
        const points = contour.split('\n').map(line => {
            const [x, y] = line.split(/\s+|\t/).map(Number);
            return { x, y };
        });

        // Convert points array of objects back to string format for isContourClosed
        const pointsStringFormat = points.map(p => `${p.x}\t${p.y}`);

        const isClosedContour = isContourClosed(pointsStringFormat);

        const segmentsToProcess = isClosedContour ? points.length : points.length - 1;

        for (let i = 0; i < segmentsToProcess; i++) {
            const p1 = points[i];
            const p2 = points[(i + 1) % points.length]; // Use modulo for closed contours

             // Skip the last segment if it's a duplicate closing segment in a closed contour
             // This check now correctly uses the tolerance-based isClosedContour
            if (isClosedContour && i === points.length - 1) {
                 continue;
            }

            const distance = calculateDistance(p1, p2);
            if (distance < 0.1) {
                shortDistances.push({
                    point1: i + 1, // Point number within the contour
                    point2: (i + 1) % points.length + 1, // Next point number within the contour
                    distance: distance
                });
            }
        }
    });

    // Remove existing notification if any
    const existingNotification = document.getElementById('distanceNotification');
    if (existingNotification) {
        document.body.removeChild(existingNotification);
    }

    const notification = document.createElement('div');
    notification.id = 'distanceNotification';
    notification.style.position = 'fixed';
    notification.style.top = '20px';
    notification.style.left = '50%';
    notification.style.transform = 'translateX(-50%)';
    notification.style.padding = '15px';
    notification.style.borderRadius = '5px';
    notification.style.cursor = 'pointer';
    notification.style.zIndex = '1000';
    notification.style.boxShadow = '0 2px 5px rgba(0,0,0,0.2)';

    if (shortDistances.length === 0) {
        notification.style.backgroundColor = '#4CAF50'; // Green
        notification.style.color = 'white';
        notification.textContent = 'Расстояний между точками менее 10 см нет';

        // Add click handler to generate CSV even if no short distances
        notification.addEventListener('click', () => {
            generateDistancesCSV();
            document.body.removeChild(notification);
        });

    } else {
         notification.style.backgroundColor = '#ff9800'; // Orange
         notification.style.color = 'white';
         notification.textContent = `Обнаружено ${shortDistances.length} расстояний менее 10 см. Нажмите для создания отчета.`;

         // Add click handler to generate CSV
         notification.addEventListener('click', () => {
             generateDistancesCSV();
             document.body.removeChild(notification);
         });
    }

    // Add notification to the page
    document.body.appendChild(notification);

    // Remove notification after 10 seconds
    setTimeout(() => {
        if (document.body.contains(notification)) {
            document.body.removeChild(notification);
        }
    }, 10000);

     // Hide scheme menu
     document.getElementById('schemeMenu').style.display = 'none';
}


function generateTXTFile() {
    const startNumberInput = prompt("Укажите первый номер для точки (например, 501):");
    if (startNumberInput === null) { // Handle Cancel button
        document.getElementById('schemeMenu').style.display = 'none'; // Hide menu
        return;
    }
    const startNumber = parseInt(startNumberInput);

    if (isNaN(startNumber) || startNumber <= 0) {
        alert("Пожалуйста, введите корректный положительный номер.");
        document.getElementById('schemeMenu').style.display = 'none'; // Hide menu
        return;
    }

    const input = document.getElementById('coordsInput').value.trim();
    if (!input) {
        alert("Нет координат для обработки.");
        document.getElementById('schemeMenu').style.display = 'none'; // Hide menu
        return;
    }

    const coords = input.split('\n').filter(line => line.trim() !== '');
    let currentNumber = startNumber;
    let txtContent = "";

    coords.forEach(coord => {
        const [x, y] = coord.split(/\s+|\t/).map(Number);
        if (!isNaN(x) && !isNaN(y)) {
            txtContent += `${currentNumber},${x.toFixed(2)},${y.toFixed(2)}\n`;
            currentNumber++;
        }
    });

    if (txtContent) {
        const blob = new Blob([txtContent], { type: 'text/plain;charset=utf-8' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `points_from_${startNumber}.txt`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
        
        showNotification(`Файл TXT с номерами от ${startNumber} создан и загружен`);
    } else {
        showNotification("Не удалось создать TXT файл: нет валидных координат");
    }

    // Скрываем меню после выполнения
    document.getElementById('schemeMenu').style.display = 'none';
}





// Добавляем обработчик события paste
document.getElementById('coordsInput').addEventListener('paste', function(e) {
    // Небольшая задержка, чтобы дать время вставить текст
    setTimeout(() => {
        handleInput(true); // true означает показывать уведомления
    }, 0);
});

    function fileToBase64(file) {
        return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.readAsDataURL(file);
            reader.onload = () => resolve(reader.result);
            reader.onerror = error => reject(error);
        });
    }
    
    


// Функция для автоматического добавления разделителей между контурами
function addContourSeparators(coordinatesText) {
    console.log("=== Starting addContourSeparators ===");
    console.log("Input text:", coordinatesText);
    
    if (!coordinatesText || coordinatesText.trim() === '') {
        console.log("Empty input, returning as is");
        return coordinatesText;
    }
    
    const lines = coordinatesText.split('\n').filter(line => line.trim() !== '');
    console.log("Lines after filtering:", lines);
    console.log("Total lines count:", lines.length);
    
    if (lines.length <= 1) {
        console.log("Only 1 or fewer lines, returning as is");
        return coordinatesText;
    }
    
    const result = [];
    
    for (let i = 0; i < lines.length; i++) {
        const currentLine = lines[i].trim();
        console.log(`\n--- Processing line ${i}: "${currentLine}"`);
        
        result.push(currentLine);
        
        // Ищем замыкание контура: текущая координата повторяется в предыдущих строках
        // и после неё идет следующая координата (т.е. это не последняя строка)
        if (i < lines.length - 1) {
            console.log(`Not last line (${i} < ${lines.length - 1}), checking for duplicates`);
            
            // Ищем первое вхождение текущей координаты
            const firstOccurrenceIndex = lines.findIndex(line => line.trim() === currentLine);
            console.log(`First occurrence of "${currentLine}" at index: ${firstOccurrenceIndex}`);
            console.log(`Current index: ${i}`);
            
            // Если текущая координата уже встречалась ранее (не первое вхождение)
            // и между первым и текущим вхождением есть другие координаты
            if (firstOccurrenceIndex >= 0 && firstOccurrenceIndex < i && i - firstOccurrenceIndex >= 2) {
                console.log(`✓ Adding separator! Conditions met:`);
                console.log(`  - firstOccurrenceIndex >= 0: ${firstOccurrenceIndex >= 0}`);
                console.log(`  - firstOccurrenceIndex < i: ${firstOccurrenceIndex} < ${i} = ${firstOccurrenceIndex < i}`);
                console.log(`  - i - firstOccurrenceIndex >= 2: ${i} - ${firstOccurrenceIndex} = ${i - firstOccurrenceIndex} >= 2 = ${i - firstOccurrenceIndex >= 2}`);
                
                // Добавляем пустую строку как разделитель контуров
                result.push('');
            } else {
                console.log(`✗ No separator added. Conditions:`);
                console.log(`  - firstOccurrenceIndex >= 0: ${firstOccurrenceIndex >= 0}`);
                console.log(`  - firstOccurrenceIndex < i: ${firstOccurrenceIndex} < ${i} = ${firstOccurrenceIndex < i}`);
                console.log(`  - i - firstOccurrenceIndex >= 2: ${i} - ${firstOccurrenceIndex} = ${i - firstOccurrenceIndex} >= 2 = ${i - firstOccurrenceIndex >= 2}`);
            }
        } else {
            console.log(`Last line (${i} >= ${lines.length - 1}), skipping duplicate check`);
        }
        
        console.log(`Result so far (length ${result.length}):`, result);
    }
    
    const finalResult = result.join('\n');
    console.log("=== Final result ===");
    console.log(finalResult);
    console.log("=== End addContourSeparators ===");
    
    return finalResult;
}




    </script>

    
</body>
</html>