<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ЗУ из XML и ЕГРН</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/proj4js/2.11.0/proj4.js"></script>
    <link rel="icon" href="img/zu.png" type="image/png">
  <script src="sk.js"></script>
<script src="msk.js"></script>
   <script src="webfonts/proj4.js"></script>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            line-height: 1.6;
            margin: 0;
            padding: 0;
            background-color: #f4f7f6;
            color: #333;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
        }

        .container {
            width: 100%;
            max-width: 600px;
            padding: 20px;
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .input-section {
            background-color: #fff;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.05);
            display: flex;
            flex-direction: column;
            gap: 10px;
            position: relative;
        }

        #cadastralInput {
            width: 100%;
            padding: 12px 15px;
            border: 1px solid #ced4da;
            border-radius: 6px;
            box-sizing: border-box;
            font-size: 17px;
            text-align: center;
            transition: border-color 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
        }

        #cadastralInput:focus {
            border-color: #007bff;
            box-shadow: 0 0 0 0.2rem rgba(0, 123, 255, 0.25);
            outline: none;
        }

        #loadParcelBtn {
            padding: 10px 15px;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
            transition: background-color 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }

        #loadParcelBtn:hover {
            background-color: #0056b3;
        }
        #loadParcelBtn:disabled {
            background-color: #305CDE;
            cursor: not-allowed;
        }

        .loader-common {
            text-align: center;
            padding: 10px;
            font-size: 16px;
            color: #007bff;
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }
         .loader-common .loader-text {
            margin-bottom: 8px;
        }
         .loader-common i.fa-spinner {
            margin-left: 8px;
            display: inline-block;
         }
        .loader-common .progress-bar-container {
            width: 80%;
            margin: 10px auto 0;
            background-color: #e0e0e0;
            border-radius: 4px;
            overflow: hidden;
            height: 10px;
            display: none;
        }
        .loader-common .progress-bar {
            width: 0%;
            height: 100%;
            background-color: #007bff;
            transition: width 0.2s ease-out;
        }

        .error-messages-common {
            color: #dc3545;
            padding: 10px;
            background-color: #f8d7da;
            border: 1px solid #f5c6cb;
            border-radius: 4px;
            margin-top: 10px;
        }

        .results-parent-container {
            width: 100%;
            max-width: 1240px;
            padding: 0 20px;
            box-sizing: border-box;
            margin-top: 20px;
        }

        .results-container {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .info-section, .drawing-section {
            background-color: #fff;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.05);
        }

        .info-section h2 {
            margin-top: 0;
            color: #0056b3;
            font-size: 1.2em;
            border-bottom: 1px solid #eee;
            padding-bottom: 8px;
            margin-bottom: 15px;
            text-align: center;
        }

        .info-section h2.clickable-header {
            color: white;
            padding: 10px 15px;
            border-radius: 6px;
            font-size: 1.1em;
            cursor: pointer;
            transition: background-color 0.2s ease, transform 0.1s ease, box-shadow 0.2s ease;
            border-bottom: none;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            display: block;
            text-align: center;
            margin-bottom: 15px;
            margin-top: 0;
        }

        #h2XMLHeader.clickable-header {
            background-color: cornflowerblue;
            color: white;
        }
        #h2XMLHeader.clickable-header:hover {
            background-color: #507cb8;
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.15);
        }
        #h2XMLHeader.clickable-header:active {
            background-color: #406394;
            transform: translateY(0px);
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        #h2EGRNHeader.clickable-header {
            background-color: #4CBB17;
            color: white;
        }
        #h2EGRNHeader.clickable-header:hover {
            background-color: #3E9A13;
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.15);
        }
        #h2EGRNHeader.clickable-header:active {
            background-color: #337F0F;
            transform: translateY(0px);
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .drawing-section h2 {
            margin-top: 0;
            color: #0056b3;
            font-size: 1.2em;
            border-bottom: 1px solid #eee;
            padding-bottom: 8px;
            margin-bottom: 15px;
            text-align: center;
        }


        #parcelCanvasXML, #parcelCanvasEGRN {
            width: 100%;
            border: 1px solid #eee;
            border-radius: 4px;
            display: block;
            background-color: #f0f8ff;
        }
        .drawing-section {
             padding: 5px;
             position: relative;
        }

        .parcel-data-table table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.9em;
        }
        .parcel-data-table th, .parcel-data-table td {
            border: 1px solid #eee;
            padding: 8px;
            text-align: left;
            word-break: break-word;
        }
        .parcel-data-table th {
            background-color: #f9f9f9;
            font-weight: 500;
            width: 40%;
        }
        .parcel-data-table tr.area-same {
            background-color: #e6ffe6 !important;
        }
        .parcel-data-table tr.area-different {
            background-color: #ffe6e6 !important;
        }

        .parcel-data-table tr.accuracy-good-row {
            background-color: #e6ffe6 !important;
        }

        .parcel-data-table tr.accuracy-bad-row {
            background-color: #ffe6e6 !important;
        }

        .parcel-data-table tr.points-same {
            background-color: #e6ffe6 !important;
        }
        .parcel-data-table tr.points-different {
            background-color: #ffe6e6 !important;
        }


        .export-section {
            display: flex;
            justify-content: space-around;
            padding: 10px;
            background-color: #fff;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.05);
            margin-top: 15px;
        }

        .export-section button {
            color: white;
            border: none;
            border-radius: 50%;
            width: 44px;
            height: 44px;
            font-size: 18px;
            cursor: pointer;
            transition: background-color 0.2s, transform 0.1s, opacity 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .export-section button:hover:not(:disabled) {
            opacity: 0.8;
            transform: translateY(-2px);
        }
         .export-section button:disabled {
            background-color: #ccc !important;
            color: #666 !important;
            cursor: not-allowed;
            transform: none;
         }

        .toggle-container {
            position: absolute;
            top: 10px;
            right: 10px;
            z-index: 10;
        }
        .toggle-container .toggle {
            display: none;
        }
        .toggle-container .toggle + label {
            display: inline-block;
            width: 40px;
            height: 20px;
            background-color: #ccc;
            border-radius: 20px;
            position: relative;
            cursor: pointer;
            transition: background-color 0.3s ease;
            border: 1px solid #bbb;
            box-shadow: inset 0 1px 3px rgba(0,0,0,0.2);
        }
        .toggle-container .toggle + label:after {
            content: '';
            display: inline-block;
            position: absolute;
            width: 16px;
            height: 16px;
            background-color: #fff;
            top: 2px;
            left: 2px;
            border-radius: 50%;
            transition: all 0.3s ease;
            box-shadow: 0 1px 2px rgba(0,0,0,0.3);
        }
        .toggle-container .toggle + label:hover:after {
             box-shadow: 0 1px 3px rgba(0,0,0,0.4);
        }
        .toggle-container .toggle:checked + label {
            background-color: #007bff;
            border-color: #0056b3;
        }
        .toggle-container .toggle:checked + label:after {
            left: 22px;
        }

        #outdatedDataNotification {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(255, 193, 7, 0.95);
            color: black;
            padding: 20px 30px;
            border-radius: 8px;
            box-shadow: 0 5px 20px rgba(0,0,0,0.25);
            z-index: 1000;
            text-align: center;
            font-size: 1.1em;
            font-weight: 500;
            border: 1px solid rgba(0,0,0,0.1);
        }
        #outdatedDataNotification i {
            margin-right: 10px;
            color: #d9534f;
        }

        #comparisonSection {
            margin-top: 15px;
        }
        .comparison-toggle-btn {
            width: 100%;
            padding: 10px;
            border-radius: 5px;
            border: none;
            color: white;
            font-weight: bold;
            font-size: 15px;
            cursor: pointer;
            transition: background-color 0.2s, transform 0.1s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
        }
        .comparison-toggle-btn.success { background-color: #dc3545; }
        .comparison-toggle-btn.failure { background-color: #28a745; }
        .comparison-toggle-btn:hover { opacity: 0.9; }
        .comparison-toggle-btn:active { transform: scale(0.98); }

        #comparisonTableContainer {
            margin-top: 10px;
            max-height: 400px;
            overflow-y: auto;
            border: 1px solid #ddd;
            border-radius: 4px;
            display: none;
        }
        .comparison-table {
            width: 100%;
            border-collapse: collapse;
        }
        .comparison-table th, .comparison-table td {
            padding: 8px;
            border: 1px solid #ddd;
            text-align: center;
            font-size: 0.85em;
        }
        .comparison-table thead {
            position: sticky;
            top: 0;
            background-color: #f2f2f2;
            z-index: 1;
        }
        .comparison-table .mismatch-row {
            background-color: #ffe6e6;
            color: #b30000;
            font-weight: bold;
        }
        .comparison-table .match-row {
            background-color: #e6ffe6;
        }


        @media (min-width: 769px) {
            .container {
                 max-width: 800px;
            }
            .results-container {
                display: grid;
                grid-template-columns: 1fr 1fr;
                grid-template-rows: auto auto;
                grid-template-areas:
                    "xmlInfo egrnInfo"
                    "xmlDrawing egrnDrawing";
                gap: 20px;
            }
            #parcelInfoSectionXML { grid-area: xmlInfo; }
            #parcelInfoSectionEGRN { grid-area: egrnInfo; }
            #drawingSectionXML { grid-area: xmlDrawing; }
            #drawingSectionEGRN { grid-area: egrnDrawing; }
            .export-section {
                max-width: 600px;
                margin: 20px auto;
            }
        }
        
        .comparison-toggle-btn.success { background-color: #28a745; } /* Зеленый */
        .comparison-toggle-btn.failure { background-color: #dc3545; } /* Красный */
    </style>
</head>
<body>
    <div class="container">
        <div class="input-section">
            <input type="text" id="cadastralInput" placeholder="Кадастровый номер">
            <button id="loadParcelBtn"><i class="fas fa-search"></i> Загрузить</button>
        </div>
        <div id="loaderXML" class="loader-common">
            <span class="loader-text">Загрузка XML...</span> <i class="fas fa-spinner fa-spin"></i>
            <div class="progress-bar-container">
                <div class="progress-bar"></div>
            </div>
        </div>
        <div id="errorMessagesXML" class="error-messages-common" style="display:none;"></div>
    </div>

    <div class="results-parent-container">
        <div class="results-container" style="display:none;">
            <div id="parcelInfoSectionXML" class="info-section" style="display:none;">
                <h2 id="h2XMLHeader">XML КПТ</h2>
                <div id="parcelDataTableXML" class="parcel-data-table"></div>
                <div id="comparisonSection" style="display:none;">
                    <button id="comparisonToggleBtn" class="comparison-toggle-btn"></button>
                    <div id="comparisonTableContainer"></div>
                </div>
            </div>

            <div id="parcelInfoSectionEGRN" class="info-section" style="display:none;">
                <h2 id="h2EGRNHeader">ЕГРН</h2>
                <div id="loaderEGRN" class="loader-common" style="padding: 5px 0;">
                    <span class="loader-text"></span><i class="fas fa-spinner fa-spin"></i>
                </div>
                <div id="errorMessagesEGRN" class="error-messages-common" style="display:none;"></div>
                <div id="parcelDataTableEGRN" class="parcel-data-table"></div>
            </div>

            <div id="drawingSectionXML" class="drawing-section" style="display:none;">
                 <div class="toggle-container toggle-container-xml">
                    <input type="checkbox" id="distanceToggleXML" class="toggle">
                    <label for="distanceToggleXML" title="Показать/скрыть длины линий и площадь/периметр (XML)"></label>
                </div>
                <canvas id="parcelCanvasXML"></canvas>
            </div>

            <div id="drawingSectionEGRN" class="drawing-section" style="display:none;">
                 <div class="toggle-container toggle-container-egrn">
                    <input type="checkbox" id="distanceToggleEGRN" class="toggle">
                    <label for="distanceToggleEGRN" title="Показать/скрыть длины линий и площадь/периметр (ЕГРН)"></label>
                </div>
                <canvas id="parcelCanvasEGRN"></canvas>
            </div>
        </div>

        <div id="exportSectionXML" class="export-section" style="display:none;">
               <button id="generateSchemaBtn" title="Схема"><i class="fas fa-sitemap"></i></button>
            <button id="exportMifBtn" title="Экспорт в MIF (из XML)" disabled><i class="fas fa-file-invoice"></i></button>
            <button id="exportDxfBtn" title="Экспорт в DXF (из XML)" disabled><i class="fas fa-drafting-compass"></i></button>
            <button id="exportTxtBtn" title="Экспорт в TXT (из XML)" disabled><i class="fas fa-file-alt"></i></button>
        </div>
    </div>

    <div id="outdatedDataNotification">
        <i class="fas fa-exclamation-triangle"></i>Данные в XML неактуальны
    </div>


  <script>
        let currentParcelDataXML = null;
        let currentParcelContoursXML = null;
        let convertedEgrnContours = null;
        let kptDate = '';
        let kptRegNum = '';
        let currentEgrnFeature = null;

        let showDistanceLabelsXML = false;
        let showDistanceLabelsEGRN = false;

        let areaXMLValue = null;
        let areaEGRNValue = null;
        let xmlTotalPointCount = null;
        let egrnTotalPointCount = null;
        let xmlIsDeclared = false;
        let egrnIsDeclared = false;

        const STORAGE_API_URL = 'https://mapruapp.ru/storage';
        const BUCKET_NAME = 'kpt';

        const cadastralInput = document.getElementById('cadastralInput');
        const loadParcelBtn = document.getElementById('loadParcelBtn');
        const loaderXMLDiv = document.getElementById('loaderXML');
        const loaderXMLTextSpan = loaderXMLDiv.querySelector('.loader-text');
        const progressBarContainerXML = loaderXMLDiv.querySelector('.progress-bar-container');
        const progressBarXML = loaderXMLDiv.querySelector('.progress-bar');
        const spinnerIconXML = loaderXMLDiv.querySelector('.fa-spinner');
        const errorMessagesXMLDiv = document.getElementById('errorMessagesXML');

        const drawingSectionXMLDiv = document.getElementById('drawingSectionXML');
        const parcelCanvasXML = document.getElementById('parcelCanvasXML');
        const distanceToggleXML = document.getElementById('distanceToggleXML');
        const parcelInfoSectionXMLDiv = document.getElementById('parcelInfoSectionXML');
        const parcelDataTableXMLDiv = document.getElementById('parcelDataTableXML');

        const exportSectionXMLDiv = document.getElementById('exportSectionXML');
        const generateSchemaBtn = document.getElementById('generateSchemaBtn');
        const exportMifBtn = document.getElementById('exportMifBtn');
        const exportDxfBtn = document.getElementById('exportDxfBtn');
        const exportTxtBtn = document.getElementById('exportTxtBtn');

        const loaderEGRNDiv = document.getElementById('loaderEGRN');
        const loaderEGRNTextSpan = loaderEGRNDiv.querySelector('.loader-text');
        const errorMessagesEGRNDiv = document.getElementById('errorMessagesEGRN');
        const drawingSectionEGRNDiv = document.getElementById('drawingSectionEGRN');
        const parcelCanvasEGRN = document.getElementById('parcelCanvasEGRN');
        const distanceToggleEGRN = document.getElementById('distanceToggleEGRN');
        const parcelInfoSectionEGRNDiv = document.getElementById('parcelInfoSectionEGRN');
        const parcelDataTableEGRNDiv = document.getElementById('parcelDataTableEGRN');
        const comparisonSectionDiv = document.getElementById('comparisonSection');

        const resultsContainerDiv = document.querySelector('.results-container');
        const outdatedDataNotificationDiv = document.getElementById('outdatedDataNotification');
        const sevenDigitsRegions = ['06', '07', '09', '10', '11', '12', '13', '14', '17', '23','24', '27', '31', '32', '35', '36', '41', '42', '47', '48','50', '52', '53', '56', '57', '58', '59', '60', '61', '62','63', '64', '65', '66', '67', '69', '70', '71', '72', '74','77', '78', '79', '91'];

        if (typeof proj4 === 'undefined' || typeof COORDINATE_SYSTEMS === 'undefined' || typeof MskFinder === 'undefined') {
            console.error("Proj4, sk.js, or msk.js library not loaded.");
            showError("Ошибка загрузки библиотек. Функционал сравнения координат ЕГРН может быть ограничен.", 'egrn');
        }

        loadParcelBtn.addEventListener('click', handleLoadParcel);
        cadastralInput.addEventListener('input', () => { formatCadastralNumber(cadastralInput); });
        cadastralInput.addEventListener('keypress', (e) => { if (e.key === 'Enter') handleLoadParcel(); });

        distanceToggleXML.addEventListener('change', () => {
            showDistanceLabelsXML = distanceToggleXML.checked;
            localStorage.setItem('showDistanceLabelsXML', String(showDistanceLabelsXML));
            if (currentParcelContoursXML && currentParcelContoursXML.length > 0) {
                drawParcelOnCanvasXML(currentParcelContoursXML);
            }
        });

        distanceToggleEGRN.addEventListener('change', () => {
            showDistanceLabelsEGRN = distanceToggleEGRN.checked;
            localStorage.setItem('showDistanceLabelsEGRN', String(showDistanceLabelsEGRN));
            if (currentEgrnFeature && currentEgrnFeature.geometry) {
                drawEgrnParcelOnCanvas(currentEgrnFeature.geometry);
            }
        });

        showDistanceLabelsXML = localStorage.getItem('showDistanceLabelsXML') === 'true';
        distanceToggleXML.checked = showDistanceLabelsXML;
        showDistanceLabelsEGRN = localStorage.getItem('showDistanceLabelsEGRN') === 'true';
        distanceToggleEGRN.checked = showDistanceLabelsEGRN;

        function getRandomColor() {
            const letters = '0123456789ABCDEF';
            let color = '#';
            for (let i = 0; i < 6; i++) color += letters[Math.floor(Math.random() * 16)];
            return color;
        }

        function getContrastYIQ(hexcolor) {
            hexcolor = hexcolor.replace('#', '');
            const r = parseInt(hexcolor.substr(0, 2), 16);
            const g = parseInt(hexcolor.substr(2, 2), 16);
            const b = parseInt(hexcolor.substr(4, 2), 16);
            const yiq = ((r * 299) + (g * 587) + (b * 114)) / 1000;
            return (yiq >= 128) ? 'black' : 'white';
        }

        function setRandomExportButtonColors() {
            [generateSchemaBtn, exportMifBtn, exportDxfBtn, exportTxtBtn].forEach(button => {
                const randomColor = getRandomColor();
                button.style.backgroundColor = randomColor;
                button.style.color = getContrastYIQ(randomColor);
            });
        }
        setRandomExportButtonColors();

        function drawRotatedText(ctx, text, x1, y1, x2, y2, font, color, yOffset = -3) {
            ctx.save();
            ctx.translate((x1 + x2) / 2, (y1 + y2) / 2);
            let angle = Math.atan2(y2 - y1, x2 - x1);
            if (angle < -Math.PI / 2 || angle > Math.PI / 2) {
                angle += Math.PI;
            }
            ctx.rotate(angle);
            ctx.fillStyle = color;
            ctx.font = font;
            ctx.textAlign = 'center';
            ctx.fillText(text, 0, yOffset);
            ctx.restore();
        }

        function makeHeaderClickable(headerElement, urlToOpen, descriptiveText) {
            if (!headerElement) return;
            headerElement.classList.add('clickable-header');
            headerElement.setAttribute('title', `Нажмите, чтобы скопировать КН и открыть ${descriptiveText} в новой вкладке`);
            if (headerElement._clickHandler) {
                headerElement.removeEventListener('click', headerElement._clickHandler);
            }
            headerElement._clickHandler = async function() {
                const cadNumber = cadastralInput.value.trim();
                if (cadNumber) {
                    try {
                        await navigator.clipboard.writeText(cadNumber);
                    } catch (err) {
                        console.error('Не удалось скопировать кадастровый номер:', err);
                    }
                }
                window.open(urlToOpen, '_blank');
            };
            headerElement.addEventListener('click', headerElement._clickHandler);
        }

        function resetButtonHeader(headerElement) {
            if (!headerElement) return;
            headerElement.classList.remove('clickable-header');
            headerElement.removeAttribute('title');
            if (headerElement._initialTextContent) {
                headerElement.textContent = headerElement._initialTextContent;
            }
            if (headerElement._clickHandler) {
                headerElement.removeEventListener('click', headerElement._clickHandler);
                delete headerElement._clickHandler;
            }
        }

        async function handleLoadParcel() {
            const fullCadNumber = cadastralInput.value.trim();
            if (!isValidCadastralNumber(fullCadNumber)) {
                showError("Неверный формат кадастрового номера. Ожидается XX:XX:XXXXXX(X):YY", 'xml');
                return;
            }
            const parts = fullCadNumber.split(':');
            const quarterNumber = parts.slice(0, 3).join(':');
            resetUI();
            resultsContainerDiv.style.display = 'grid';

            const xmlProcessingPromise = async () => {
                showLoaderXML(true, null, 0);
                parcelInfoSectionXMLDiv.style.display = 'block';
                try {
                    const { xmlContent, kptFileName } = await fetchAndProcessKPT(quarterNumber, fullCadNumber);
                    showLoaderXML(true, null, 95);
                    const { parcelData, parcelContours } = await processXMLData(xmlContent, fullCadNumber, kptFileName);
                    currentParcelDataXML = parcelData;
                    displayParcelInfoTableXML(currentParcelDataXML);
                    if (currentParcelDataXML) {
                        makeHeaderClickable(document.querySelector('#h2XMLHeader'), 'схема.html', 'схему XML');
                    }
                    if (currentParcelContoursXML && currentParcelContoursXML.length > 0 && currentParcelContoursXML.some(c => c.length > 0)) {
                        drawingSectionXMLDiv.style.display = 'block';
                        drawParcelOnCanvasXML(currentParcelContoursXML);
                        setExportButtonsState(true);
                        exportSectionXMLDiv.style.display = 'flex';
                    } else {
                        drawingSectionXMLDiv.style.display = 'none';
                        setExportButtonsState(false);
                        exportSectionXMLDiv.style.display = 'none';
                        if (currentParcelDataXML) {
                             showError(`Координаты для участка ${fullCadNumber} не найдены или пусты в XML`, 'xml');
                        }
                    }
                    showLoaderXML(true, ``, 100);
                    await new Promise(resolve => setTimeout(resolve, 500));
                    return { success: true };
                } catch (error) {
                    console.error("Error in XML processing:", error);
                    showError(error.message || "Произошла ошибка при загрузке XML данных", 'xml');
                    setExportButtonsState(false);
                    exportSectionXMLDiv.style.display = 'none';
                    drawingSectionXMLDiv.style.display = 'none';
                    displayParcelInfoTableXML(null);
                    return { success: false, error };
                } finally {
                    showLoaderXML(false);
                }
            };

            const egrnProcessingPromise = async () => {
                showLoaderEGRN(true, '');
                parcelInfoSectionEGRNDiv.style.display = 'block';
                try {
                    await fetchAndProcessEGRN(fullCadNumber);
                    if (currentEgrnFeature) {
                        makeHeaderClickable(document.querySelector('#h2EGRNHeader'), `https://pkk.rosreestr.ru/#/search/${fullCadNumber}/`, 'данные ЕГРН');
                    }
                    return { success: true };
                } catch (error) {
                    console.error("Error in EGRN processing:", error);
                    let egrnErrorMessage;
                    if (error.message === 'EGRN_NOT_FOUND_404' || error.message === 'Участок не найден в ЕГРН') {
                        egrnErrorMessage = "Кадастровый номер не найден в ЕГРН";
                    } else if (error.message && error.message.startsWith('Ошибка сети ЕГРН')) {
                        egrnErrorMessage = "Сервер ЕГРН не доступен.";
                    } else if (error instanceof SyntaxError) {
                        egrnErrorMessage = "Ошибка обработки ответа от сервера ЕГРН (неверный формат).";
                    } else {
                        egrnErrorMessage = error.message || "Произошла непредвиденная ошибка при загрузке данных ЕГРН.";
                    }
                    showError(egrnErrorMessage, 'egrn');
                    drawingSectionEGRNDiv.style.display = 'none';
                    parcelDataTableEGRNDiv.innerHTML = `<p style="color:red;">Данные ЕГРН не загружены: ${egrnErrorMessage}</p>`;
                    return { success: false, error };
                } finally {
                    showLoaderEGRN(false);
                }
            };

            await Promise.allSettled([ xmlProcessingPromise(), egrnProcessingPromise() ]);

            if (currentParcelContoursXML && convertedEgrnContours) {
                const comparisonResult = compareParcelCoordinates(currentParcelContoursXML, convertedEgrnContours);
                displayComparisonResultUI(comparisonResult);
            }
             compareAndHighlightAreas();
             compareAndHighlightPointCounts();
        }

        function showLoaderXML(show, message = null, progress = null) {
            if (show) {
                loaderXMLDiv.style.display = 'flex';
                loadParcelBtn.disabled = true;
                if (progress !== null && progress >= 0 && progress <= 100) {
                    progressBarContainerXML.style.display = 'block';
                    progressBarXML.style.width = `${progress}%`;
                    loaderXMLTextSpan.style.display = 'none';
                    spinnerIconXML.style.display = 'none';
                    if (progress === 100 && message && message.includes("Готово")) {
                        loaderXMLTextSpan.textContent = message;
                        loaderXMLTextSpan.style.display = 'block';
                    }
                } else {
                    progressBarContainerXML.style.display = 'none';
                    progressBarXML.style.width = `0%`;
                    loaderXMLTextSpan.textContent = message || "Загрузка XML...";
                    loaderXMLTextSpan.style.display = 'block';
                    spinnerIconXML.style.display = 'inline-block';
                }
            } else {
                loaderXMLDiv.style.display = 'none';
                loadParcelBtn.disabled = false;
            }
        }

        function showLoaderEGRN(show, message = "Загрузка ЕГРН...") {
            loaderEGRNTextSpan.textContent = message;
            loaderEGRNDiv.style.display = show ? 'flex' : 'none';
        }

        async function fetchAndProcessKPT(quarterNumber, fullCadNumber) {
            const serverQuarterPrefix = quarterNumber.replace(/:/g, '_');
            showLoaderXML(true, null, 10);
            const responseList = await fetch(`${STORAGE_API_URL}/${BUCKET_NAME}?search=${serverQuarterPrefix}`);
            if (!responseList.ok) throw new Error(`Ошибка получения списка файлов: ${responseList.statusText}`);
            const fileList = await responseList.json();
            if (!fileList || fileList.length === 0) throw new Error(`КПТ для квартала ${quarterNumber} не найдены на сервере.`);
            showLoaderXML(true, null, 25);

            const matchingFiles = fileList.filter(file => file.name.startsWith(serverQuarterPrefix) && file.name.toLowerCase().endsWith('.zip'));
            if (matchingFiles.length === 0) throw new Error(`ZIP-архивы КПТ для квартала ${quarterNumber} не найдены.`);
            const latestFile = findLatestKptFile(matchingFiles);
            if (!latestFile) throw new Error("Не удалось определить последний файл КПТ.");
            showLoaderXML(true, null, 40);

            const responseDownload = await fetch(`${STORAGE_API_URL}/${BUCKET_NAME}/${latestFile.name}`);
            if (!responseDownload.ok) throw new Error(`Ошибка загрузки файла ${latestFile.name}: ${responseDownload.statusText}`);
            const blob = await responseDownload.blob();
            if (!blob) throw new Error("Не удалось получить содержимое файла КПТ с сервера.");
            showLoaderXML(true, null, 65);

            const zip = await JSZip.loadAsync(blob);
            let xmlFileEntry = Object.values(zip.files).find(f => f.name.toLowerCase().endsWith('.xml') && !f.dir);
            if (!xmlFileEntry) throw new Error("XML-файл не найден в архиве КПТ.");
            showLoaderXML(true, null, 85);
            const xmlContent = await xmlFileEntry.async('string');
            return { xmlContent, kptFileName: latestFile.name };
        }

        async function processXMLData(xmlContent, fullCadNumber, kptFileName) {
            const parser = new DOMParser();
            const xmlDoc = parser.parseFromString(xmlContent, "text/xml");
            kptDate = getElementValue(xmlDoc, 'extract_cadastral_plan_territory > details_statement > group_top_requisites > date_formation')?.split('-').reverse().join('.') || '';
            kptRegNum = getElementValue(xmlDoc, 'extract_cadastral_plan_territory > details_statement > group_top_requisites > registration_number') || '';
            const foundLandRecord = Array.from(xmlDoc.querySelectorAll('land_record')).find(record => getElementValue(record, 'object > common_data > cad_number') === fullCadNumber);
            if (!foundLandRecord) throw new Error(`Участок ${fullCadNumber} не найден в XML файле ${kptFileName}.`);
            const parcelData = extractParcelDataXML(foundLandRecord);
            currentParcelContoursXML = extractParcelCoordinatesXML(foundLandRecord);
            xmlTotalPointCount = currentParcelContoursXML ? currentParcelContoursXML.reduce((sum, contour) => sum + contour.length, 0) : 0;
            return { parcelData, parcelContours: currentParcelContoursXML };
        }

        function resetUI() {
            [resultsContainerDiv, errorMessagesXMLDiv, drawingSectionXMLDiv, parcelInfoSectionXMLDiv, exportSectionXMLDiv, errorMessagesEGRNDiv, drawingSectionEGRNDiv, parcelInfoSectionEGRNDiv, outdatedDataNotificationDiv, comparisonSectionDiv].forEach(el => el.style.display = 'none');
            [errorMessagesXMLDiv, parcelDataTableXMLDiv, errorMessagesEGRNDiv, parcelDataTableEGRNDiv].forEach(el => el.innerHTML = '');
            [parcelCanvasXML, parcelCanvasEGRN].forEach(canvas => canvas && canvas.getContext('2d').clearRect(0, 0, canvas.width, canvas.height));
            resetButtonHeader(document.getElementById('h2XMLHeader'));
            resetButtonHeader(document.getElementById('h2EGRNHeader'));
            currentParcelDataXML = currentParcelContoursXML = convertedEgrnContours = currentEgrnFeature = areaXMLValue = areaEGRNValue = xmlTotalPointCount = egrnTotalPointCount = null;
            kptDate = kptRegNum = '';
            xmlIsDeclared = egrnIsDeclared = false;
            setExportButtonsState(false);
        }

        function showError(message, type = 'xml') {
            let errorDiv = (type === 'egrn') ? errorMessagesEGRNDiv : errorMessagesXMLDiv;
            errorDiv.textContent = message;
            errorDiv.style.display = 'block';
        }

        function extractParcelDataXML(landRecordNode) {
            const data = {};
            data.cadNumber = getElementValue(landRecordNode, 'object > common_data > cad_number');
            data.objectType = getElementValue(landRecordNode, 'object > common_data > type > value');
            data.address = getElementValue(landRecordNode, 'address_location > address > readable_address') || 'Нет данных';

            const areaElement = landRecordNode.querySelector('params > area');
            const areaValueText = getElementValue(areaElement, 'value');
            data.areaNumeric = areaValueText ? parseFloat(areaValueText.replace(',', '.')) : null;
            const inaccuracy = getElementValue(areaElement, 'inaccuracy');
            data.areaString = data.areaNumeric !== null ? (inaccuracy ? `Уточненная: ${formatNumberWithSpaces(data.areaNumeric)} ±${inaccuracy} кв.м.` : `Декларированная: ${formatNumberWithSpaces(data.areaNumeric)} кв.м.`) : 'Нет данных';

            data.permittedUse = getElementValue(landRecordNode, 'params > permitted_use > permitted_use_established > by_document') || 'Нет данных';
            data.category = getElementValue(landRecordNode, 'params > category > type > value') || 'Нет данных';
            const costValue = getElementValue(landRecordNode, 'cost > value');
            data.cadastralValue = costValue ? parseFloat(costValue).toLocaleString('ru-RU') + ' руб.' : 'Нет данных';

            const allDeltaValues = Array.from(landRecordNode.querySelectorAll("delta_geopoint"))
                .map(el => parseFloat(el.textContent.trim()))
                .filter(val => !isNaN(val));

            data.maxDeltaGeopoint = allDeltaValues.length > 0 ? Math.max(...allDeltaValues).toString() : '—';
            return data;
        }

        function displayParcelInfoTableXML(data) {
            areaXMLValue = null;
            xmlIsDeclared = false;
            if (!data && !kptDate && !kptRegNum) {
                 parcelInfoSectionXMLDiv.style.display = 'none';
                 currentParcelDataXML = null;
                 xmlTotalPointCount = null;
                 compareAndHighlightAreas();
                 compareAndHighlightPointCounts();
                 return;
            }
            let tableHTML = '<table>';
            const displayOrder = [
                { key: 'cadNumber', label: 'Кадастровый номер' },
                { key: 'objectType', label: 'Тип объекта' },
                { key: 'address', label: 'Адрес' },
                { key: 'areaString', label: 'Площадь' },
                { key: 'permittedUse', label: 'Разрешенное использование' },
                { key: 'category', label: 'Категория земель' },
                { key: 'maxDeltaGeopoint', label: 'Погрешность' },
                { key: 'cadastralValue', label: 'Кадастровая стоимость' }
            ];
            if (data) {
                displayOrder.forEach(item => {
                    if (data[item.key] || data[item.key] === '—' || typeof data[item.key] === 'number') {
                        let rowAttributes = '';
                        if (item.key === 'areaString') {
                            areaXMLValue = data.areaNumeric;
                            rowAttributes += ' id="xmlAreaRow"';
                            if (data.areaString && data.areaString.startsWith("Декларированная:")) xmlIsDeclared = true;
                        }
                        if (item.key === 'maxDeltaGeopoint' && data[item.key] !== '—') {
                            const deltaValue = parseFloat(data[item.key]);
                            if (!isNaN(deltaValue)) {
                                let accuracyClass = (deltaValue === 0.1) ? 'accuracy-good-row' : (deltaValue === 0.2 || deltaValue === 0.3) ? 'accuracy-bad-row' : '';
                                if (accuracyClass) rowAttributes += ` class="${accuracyClass}"`;
                            }
                        }
                        tableHTML += `<tr${rowAttributes}><th>${item.label}</th><td>${data[item.key]}</td></tr>`;
                    }
                });
            }
            if (kptDate || kptRegNum) {
                let fileInfoText = [kptRegNum, kptDate].filter(Boolean).join(' от ');
                tableHTML += `<tr><th>Источник XML</th><td>${fileInfoText}</td></tr>`;
            }
            let pointDisplayText = xmlTotalPointCount !== null ? (xmlTotalPointCount > 0 ? xmlTotalPointCount : '0 (нет координат)') : '—';
            tableHTML += `<tr id="xmlPointCountRow"><th>Кол-во точек (XML)</th><td>${pointDisplayText}</td></tr>`;
            tableHTML += '</table>';
            parcelDataTableXMLDiv.innerHTML = tableHTML;
            parcelInfoSectionXMLDiv.style.display = 'block';
        }

        function drawParcelOnCanvasXML(contours) {
            const canvas = parcelCanvasXML;
            const ctx = canvas.getContext('2d');
            const resolvedContainerWidth = drawingSectionXMLDiv.clientWidth > 0 ? drawingSectionXMLDiv.clientWidth : 300;
            canvas.width = resolvedContainerWidth;
            canvas.height = canvas.width * (3/4);
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            const allPoints = contours.flat();
            if (allPoints.length === 0) return;

            const { minGeoX, maxGeoX, minGeoY, maxGeoY, scale, offsetX_canvas, offsetY_canvas } = calculateCanvasTransforms(allPoints, canvas);

            ctx.strokeStyle = '#007bff'; ctx.lineWidth = 2; ctx.fillStyle = 'rgba(0, 123, 255, 0.1)';
            let totalGeometricAreaXML = 0, totalGeometricPerimeterXML = 0;

            contours.forEach(contour => {
                if (contour.length < 1) return;
                ctx.beginPath();
                const canvasPoints = contour.map(point => ({
                    x_canvas: offsetX_canvas + (point.y - minGeoY) * scale,
                    y_canvas: offsetY_canvas + (maxGeoX - point.x) * scale
                }));
                canvasPoints.forEach((cp, index) => (index === 0) ? ctx.moveTo(cp.x_canvas, cp.y_canvas) : ctx.lineTo(cp.x_canvas, cp.y_canvas));
                const isClosed = contour.length > 2 && Math.abs(contour[0].x - contour[contour.length-1].x) < 1e-6 && Math.abs(contour[0].y - contour[contour.length-1].y) < 1e-6;
                if (isClosed) { ctx.closePath(); ctx.fill(); }
                ctx.stroke();

                if (showDistanceLabelsXML) {
                    let contourPerimeter = 0;
                    for (let i = 0; i < contour.length; i++) {
                        const p1 = contour[i], p2 = contour[(i + 1) % contour.length];
                        if (i === contour.length - 1 && !isClosed) break;
                        const dist = Math.sqrt(Math.pow(p2.y - p1.y, 2) + Math.pow(p2.x - p1.x, 2));
                        contourPerimeter += dist;
                        const cp1 = canvasPoints[i], cp2 = canvasPoints[(i + 1) % contour.length];
                        drawRotatedText(ctx, dist.toFixed(2) + "м", cp1.x_canvas, cp1.y_canvas, cp2.x_canvas, cp2.y_canvas, '10px Arial', 'black');
                    }
                    totalGeometricPerimeterXML += contourPerimeter;
                    if (isClosed) totalGeometricAreaXML += calculatePolygonArea(contour);
                }
            });

            if (showDistanceLabelsXML) {
                ctx.fillStyle = 'black'; ctx.font = '11px Arial'; ctx.textAlign = 'left';
                ctx.fillText(`Площадь (XML): ~${formatNumberWithSpaces(Math.round(totalGeometricAreaXML))} м²`, 10, canvas.height - 25);
                ctx.fillText(`Периметр (XML): ~${formatNumberWithSpaces(Math.round(totalGeometricPerimeterXML))} м`, 10, canvas.height - 10);
            }
        }

        function calculateCanvasTransforms(points, canvas) {
            let minGeoX = Infinity, maxGeoX = -Infinity, minGeoY = Infinity, maxGeoY = -Infinity;
            points.forEach(p => {
                minGeoX = Math.min(minGeoX, p.x); maxGeoX = Math.max(maxGeoX, p.x);
                minGeoY = Math.min(minGeoY, p.y); maxGeoY = Math.max(maxGeoY, p.y);
            });
            const dataGeoWidth = (maxGeoY - minGeoY) || 1;
            const dataGeoHeight = (maxGeoX - minGeoX) || 1;
            const jsInternalPadding = 20, scaleMultiplier = 0.9;
            const effectiveCanvasWidth = canvas.width - 2 * jsInternalPadding;
            const effectiveCanvasHeight = canvas.height - 2 * jsInternalPadding;
            const scale = Math.min(effectiveCanvasWidth / dataGeoWidth, effectiveCanvasHeight / dataGeoHeight) * scaleMultiplier;
            const offsetX_canvas = jsInternalPadding + (effectiveCanvasWidth - dataGeoWidth * scale) / 2;
            const offsetY_canvas = jsInternalPadding + (effectiveCanvasHeight - dataGeoHeight * scale) / 2;
            return { minGeoX, maxGeoX, minGeoY, maxGeoY, scale, offsetX_canvas, offsetY_canvas };
        }

        function calculatePolygonArea(contour) {
            let area = 0;
            for (let j = 0; j < contour.length; j++) {
                const p_curr = contour[j], p_next = contour[(j + 1) % contour.length];
                area += (p_curr.y * p_next.x - p_next.y * p_curr.x);
            }
            return Math.abs(area / 2.0);
        }

        function setExportButtonsState(enabled) {
            exportMifBtn.disabled = !enabled;
            exportDxfBtn.disabled = !enabled;
            exportTxtBtn.disabled = !enabled;
        }

        function getElementValue(element, tagName) {
             if (!element) return '';
            const node = element.querySelector(tagName.replace(/ > /g, ' '));
            return node ? node.textContent.trim() : '';
        }

        function formatCadastralNumber(input) {
            let value = input.value.replace(/[^\d]/g, '');
            let formatted = '';
            const originalLength = value.length;
            if (originalLength > 0) formatted += value.substring(0, Math.min(2, originalLength));
            if (originalLength > 2) formatted += ':' + value.substring(2, Math.min(4, originalLength));
            const firstTwoDigits = value.substring(0, 2);
            const quarterMaxLength = sevenDigitsRegions.includes(firstTwoDigits) ? 7 : 6;
            if (originalLength > 4) formatted += ':' + value.substring(4, Math.min(4 + quarterMaxLength, originalLength));
            if (originalLength > (4 + quarterMaxLength)) formatted += ':' + value.substring(4 + quarterMaxLength);
            input.value = formatted;
        }

        function isValidCadastralNumber(text) {
            if (!text) return false;
            const firstTwoDigits = text.slice(0, 2);
            const digitsAfterSecondColon = sevenDigitsRegions.includes(firstTwoDigits) ? 7 : 6;
            const pattern = new RegExp(`^\\d{2}:\\d{2}:\\d{${digitsAfterSecondColon}}:\\d+$`);
            return pattern.test(text);
        }

        function findLatestKptFile(files) {
            if (!files || files.length === 0) return null;
            return files.sort((a, b) => b.name.localeCompare(a.name))[0];
        }

        function extractParcelCoordinatesXML(landRecordNode) {
            const result = [];
            const contoursLocationNode = landRecordNode.querySelector("contours_location");
            if (contoursLocationNode) {
                const processSpatialElements = (parentNode) => {
                    parentNode.querySelectorAll(":scope > spatial_element").forEach(el => {
                        const contourCoords = Array.from(el.querySelectorAll("ordinates > ordinate")).map(ord => {
                            const x = parseFloat(getElementValue(ord, "x")), y = parseFloat(getElementValue(ord, "y"));
                            return !isNaN(x) && !isNaN(y) ? { x, y } : null;
                        }).filter(Boolean);
                        if (contourCoords.length > 0) result.push(contourCoords);
                    });
                };
                const contourNodes = contoursLocationNode.querySelectorAll("contours > contour");
                if (contourNodes.length > 0) {
                    contourNodes.forEach(c => processSpatialElements(c.querySelector("entity_spatial > spatials_elements") || c.querySelector("entity_spatial") || c));
                } else {
                    processSpatialElements(contoursLocationNode.querySelector("entity_spatial > spatials_elements") || contoursLocationNode.querySelector("entity_spatial") || contoursLocationNode);
                }
            }
            return result;
        }

async function fetchAndProcessEGRN(cadNumber) {
            const url = `https://nspd.gov.ru/api/geoportal/v2/search/geoportal?thematicSearchId=1&query=${encodeURIComponent(cadNumber)}`;
            try {
                const response = await fetch(url);
                if (response.status === 404) throw new Error('EGRN_NOT_FOUND_404');
                if (!response.ok) throw new Error(`Ошибка сети ЕГРН: ${response.status} ${response.statusText}`);
                const data = await response.json();
                if (data.data?.features?.length > 0) {
                    currentEgrnFeature = data.data.features[0];
                    if (currentEgrnFeature.geometry) {
                        // --- ИЗМЕНЕНИЕ НАЧАЛО: Сохраняем сконвертированные координаты ---
                        const { convertedContours, detectedMskName } = autoDetectAndConvertEgrnCoords(currentEgrnFeature.geometry, cadNumber);
                        convertedEgrnContours = convertedContours; // <--- ВОТ ЭТА СТРОКА ДОБАВЛЕНА
                        // --- ИЗМЕНЕНИЕ КОНЕЦ ---

                        const allPointsFlat = convertedEgrnContours.flat();
                        egrnTotalPointCount = allPointsFlat.length;
                        drawingSectionEGRNDiv.style.display = 'block';
                        drawEgrnParcelOnCanvas(currentEgrnFeature.geometry); // Для отрисовки по-прежнему используем исходные, т.к. функция отрисовки сама их конвертирует для себя
                    } else {
                        egrnTotalPointCount = 0;
                        convertedEgrnContours = null; // Очищаем, если геометрии нет
                        showError('Геометрия не найдена в ЕГРН для данного объекта.', 'egrn');
                        drawingSectionEGRNDiv.style.display = 'none';
                    }
                    displayEgrnInfoTable(currentEgrnFeature.properties.options, currentEgrnFeature.properties);
                } else {
                    throw new Error('Участок не найден в ЕГРН');
                }
            } catch (error) {
                if (error instanceof TypeError && error.message === 'Failed to fetch') throw new Error('Ошибка сети ЕГРН: Не удалось выполнить запрос (Failed to fetch)');
                throw error;
            }
        }

        function displayEgrnInfoTable(options, properties) {
            parcelDataTableEGRNDiv.innerHTML = '';
            areaEGRNValue = null;
            egrnIsDeclared = false;
            let tableHTML = '<table>';
            const categoryName = properties.categoryName || "Неизвестный тип";
            const dataRows = [];
            dataRows.push({ label: 'Тип объекта', value: categoryName });
            dataRows.push({ label: 'Кадастровый номер', value: options.cad_num || options.cad_number });
            dataRows.push({ label: 'Статус', value: options.status || options.common_data_status });
            dataRows.push({ label: 'Адрес', value: options.readable_address || options.address_readable_address });
            let areaValueForCost = null, areaDisplayValue = 'Нет данных';
            let isAreaRowForEGRN = false;
            if (categoryName === "Земельные участки ЕГРН") {
                const areaValue = options.specified_area || options.land_record_area_verified || options.declared_area || options.land_record_area_declaration || options.land_record_area;
                if(areaValue && !isNaN(parseFloat(areaValue))) {
                    areaValueForCost = parseFloat(areaValue);
                    const isDeclared = !options.specified_area && !options.land_record_area_verified;
                    areaDisplayValue = `${isDeclared ? 'Декларированная' : 'Уточненная'}: ${formatNumberWithSpaces(areaValueForCost)} м²`;
                    egrnIsDeclared = isDeclared;
                }
                dataRows.push({ label: 'Площадь', value: areaDisplayValue, isArea: true });
                isAreaRowForEGRN = true;
                dataRows.push({ label: 'Категория земель', value: options.land_record_category_type });
                dataRows.push({ label: 'Разрешенное использование', value: options.permitted_use_established_by_document });
                dataRows.push({ label: 'Дата присвоения КН', value: formatDateEGRN(options.land_record_reg_date) });
            }
            if (isAreaRowForEGRN) areaEGRNValue = areaValueForCost;
            let costDisplayValue = 'Нет данных';
            if (options.cost_value && !isNaN(parseFloat(options.cost_value))) {
                const cost = parseFloat(options.cost_value);
                costDisplayValue = formatNumberWithSpaces(cost) + " руб.";
                if (areaValueForCost > 0) costDisplayValue += ` (${formatNumberWithSpaces(Math.round(cost / areaValueForCost))} руб/м²)`;
            }
            dataRows.push({ label: 'Кадастровая стоимость', value: costDisplayValue });
            dataRows.push({ label: 'Дата определения КС', value: formatDateEGRN(options.cost_determination_date) });
            dataRows.push({ label: 'Дата обновления в ЕГРН', value: formatDateEGRN(properties.systemInfo?.updated) });
            dataRows.forEach(row => {
                if (row.value) tableHTML += `<tr${row.isArea ? ' id="egrnAreaRow"' : ''}><th>${row.label}</th><td>${row.value}</td></tr>`;
            });
            tableHTML += `<tr id="egrnPointCountRow"><th>Кол-во точек (ЕГРН)</th><td>${egrnTotalPointCount ?? '—'}</td></tr>`;
            tableHTML += '</table>';
            parcelDataTableEGRNDiv.innerHTML = tableHTML;
        }

        function compareAndHighlightAreas() {
            const xmlAreaRow = document.getElementById('xmlAreaRow'), egrnAreaRow = document.getElementById('egrnAreaRow');
            if (xmlAreaRow) xmlAreaRow.classList.remove('area-same', 'area-different');
            if (egrnAreaRow) egrnAreaRow.classList.remove('area-same', 'area-different');
            outdatedDataNotificationDiv.style.display = 'none';
            const areasComparable = areaXMLValue !== null && areaEGRNValue !== null;
            const areasDiffer = areasComparable && Math.round(areaXMLValue) !== Math.round(areaEGRNValue);
            if (xmlAreaRow) xmlAreaRow.classList.add(xmlIsDeclared || (areasComparable && areasDiffer) ? 'area-different' : 'area-same');
            if (egrnAreaRow) egrnAreaRow.classList.add(egrnIsDeclared ? 'area-different' : (areasComparable ? (areasDiffer ? 'area-different' : 'area-same') : ''));
            if ((areasComparable && areasDiffer) || (xmlIsDeclared && !egrnIsDeclared && areaXMLValue !== null && areaEGRNValue !== null) || (xmlTotalPointCount !== null && egrnTotalPointCount !== null && xmlTotalPointCount !== egrnTotalPointCount)) {
                outdatedDataNotificationDiv.style.display = 'block';
            }
        }

        function compareAndHighlightPointCounts() {
            const xmlRow = document.getElementById('xmlPointCountRow'), egrnRow = document.getElementById('egrnPointCountRow');
            if(xmlRow) xmlRow.className = ''; if(egrnRow) egrnRow.className = '';
            if (xmlTotalPointCount !== null && egrnTotalPointCount !== null && xmlRow && egrnRow) {
                const className = xmlTotalPointCount === egrnTotalPointCount ? 'points-same' : 'points-different';
                xmlRow.classList.add(className); egrnRow.classList.add(className);
            }
        }

        function getCoordinatesForSchema(contours) {
            return contours?.flat().map(p => `${p.x.toFixed(2)}\t${p.y.toFixed(2)}`).join('\n') || '';
        }

        generateSchemaBtn.addEventListener('click', async () => {
            const coordsString = getCoordinatesForSchema(currentParcelContoursXML);
            if (coordsString) {
                try {
                    await navigator.clipboard.writeText(coordsString);
                    window.open('схема.html', '_blank');
                } catch (err) { console.error('Не удалось скопировать координаты: ', err); }
            }
        });

        function formatDateEGRN(dateString) {
            if (!dateString) return '';
            try { return new Date(dateString).toLocaleDateString('ru-RU'); } catch (e) { return dateString; }
        }
        function formatNumberWithSpaces(number) {
            return number?.toLocaleString('ru-RU', { maximumFractionDigits: 2 }) ?? number;
        }

function drawEgrnParcelOnCanvas() { // Убрали аргумент, так как используем глобальные переменные
            const canvas = parcelCanvasEGRN;
            const ctx = canvas.getContext('2d');
            const resolvedContainerWidthEGRN = drawingSectionEGRNDiv.clientWidth > 0 ? drawingSectionEGRNDiv.clientWidth : 300;
            canvas.width = resolvedContainerWidthEGRN;
            canvas.height = canvas.width * (3/4);
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // --- ИЗМЕНЕНИЕ НАЧАЛО: Используем сконвертированные координаты ---
            if (!convertedEgrnContours || convertedEgrnContours.length === 0) return;
            const allPointsFlat = convertedEgrnContours.flat();
            if (allPointsFlat.length === 0) return;
            // --- ИЗМЕНЕНИЕ КОНЕЦ ---

            const { minGeoX, maxGeoX, minGeoY, maxGeoY, scale, offsetX_canvas, offsetY_canvas } = calculateCanvasTransforms(allPointsFlat, canvas);

            ctx.strokeStyle = '#28a745'; ctx.lineWidth = 2; ctx.fillStyle = 'rgba(40, 167, 69, 0.1)';
            let totalGeometricAreaEGRN = 0, totalGeometricPerimeterEGRN = 0;

            convertedEgrnContours.forEach(contour => {
                if (contour.length < 1) return;
                ctx.beginPath();
                const canvasPoints = contour.map(point => ({
                    x_canvas: offsetX_canvas + (point.y - minGeoY) * scale,
                    y_canvas: offsetY_canvas + (maxGeoX - point.x) * scale
                }));
                canvasPoints.forEach((cp, index) => (index === 0) ? ctx.moveTo(cp.x_canvas, cp.y_canvas) : ctx.lineTo(cp.x_canvas, cp.y_canvas));
                const isClosed = contour.length > 2 && Math.abs(contour[0].x - contour[contour.length-1].x) < 1e-6 && Math.abs(contour[0].y - contour[contour.length-1].y) < 1e-6;
                if (isClosed) { ctx.closePath(); ctx.fill(); }
                ctx.stroke();

                if (showDistanceLabelsEGRN) {
                    let contourPerimeter = 0;
                    for (let i = 0; i < contour.length; i++) {
                        const p1 = contour[i], p2 = contour[(i + 1) % contour.length];
                        if (i === contour.length - 1 && !isClosed) break;
                        const dist = Math.sqrt(Math.pow(p2.y - p1.y, 2) + Math.pow(p2.x - p1.x, 2));
                        contourPerimeter += dist;
                        const cp1 = canvasPoints[i], cp2 = canvasPoints[(i + 1) % contour.length];
                        drawRotatedText(ctx, dist.toFixed(2) + "м", cp1.x_canvas, cp1.y_canvas, cp2.x_canvas, cp2.y_canvas, '10px Arial', 'black');
                    }
                    totalGeometricPerimeterEGRN += contourPerimeter;
                    if (isClosed) totalGeometricAreaEGRN += calculatePolygonArea(contour);
                }
            });

            if (showDistanceLabelsEGRN) {
                ctx.fillStyle = 'black'; ctx.font = '11px Arial'; ctx.textAlign = 'left';
                ctx.fillText(`Площадь (ЕГРН): ~${formatNumberWithSpaces(Math.round(totalGeometricAreaEGRN))} м²`, 10, canvas.height - 25);
                ctx.fillText(`Периметр (ЕГРН): ~${formatNumberWithSpaces(Math.round(totalGeometricPerimeterEGRN))} м`, 10, canvas.height - 10);
            }
        }

        function convertToWGS84(x_merc, y_merc) {
            return (typeof proj4 !== 'undefined') ? proj4("EPSG:3857", "EPSG:4326", [x_merc, y_merc]) : [0,0];
        }

        function haversineDistance(coords1_wgs_lonlat, coords2_wgs_lonlat) {
            const R = 6371e3;
            const toRad = val => val * Math.PI/180;
            const [lon1, lat1] = coords1_wgs_lonlat, [lon2, lat2] = coords2_wgs_lonlat;
            const [phi1, phi2] = [toRad(lat1), toRad(lat2)];
            const dPhi = toRad(lat2 - lat1), dLambda = toRad(lon2 - lon1);
            const a = Math.sin(dPhi/2)**2 + Math.cos(phi1) * Math.cos(phi2) * Math.sin(dLambda/2)**2;
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
            return R * c;
        }

        function getCoordinatesForDefaultTxtExport(contours) {
            return contours?.map(c => c.map(p => `${p.x.toFixed(2)}\t${p.y.toFixed(2)}`).join('\n')).join('\n\n').trim() || [];
        }

        function generateMIF(contours) {
            let mifContent = `Version 300\nCharset "WindowsCyrillic"\nDelimiter ","\nCoordSys NonEarth Units "m"\nColumns 1\n  ID Char(254)\nData\n`;
            const validContours = contours.filter(c => c.length > 0);
            if (validContours.length === 0) return "";
            mifContent += `Region ${validContours.length}\n`;
            validContours.forEach(c => { mifContent += `${c.length}\n` + c.map(p => `${p.y.toFixed(2)} ${p.x.toFixed(2)}`).join('\n') + '\n'; });
            return mifContent;
        }

        function generateDXF(contours) {
            let dxf = `0\nSECTION\n2\nENTITIES\n`;
            contours.filter(c => c.length > 0).forEach(c => {
                const isClosed = c.length > 2 && Math.abs(c[0].x - c[c.length-1].x) < 1e-3 && Math.abs(c[0].y - c[c.length-1].y) < 1e-3;
                dxf += `0\nLWPOLYLINE\n8\n0\n66\n1\n70\n${isClosed ? 1 : 0}\n90\n${c.length}\n` + c.map(p => `10\n${p.y.toFixed(2)}\n20\n${p.x.toFixed(2)}`).join('\n') + '\n';
            });
            dxf += `0\nENDSEC\n0\nEOF\n`;
            return dxf;
        }

        function downloadFile(content, filename, contentType) {
            const blob = new Blob([content], { type: contentType });
            const a = document.createElement('a');
            a.href = URL.createObjectURL(blob);
            a.download = filename;
            document.body.appendChild(a); a.click(); document.body.removeChild(a);
            URL.revokeObjectURL(a.href);
        }

        exportMifBtn.addEventListener('click', () => currentParcelContoursXML && downloadFile(generateMIF(currentParcelContoursXML), `${currentParcelDataXML?.cadNumber?.replace(/:/g,'_') || 'parcel'}.mif`, 'application/vnd.mif'));
        exportDxfBtn.addEventListener('click', () => currentParcelContoursXML && downloadFile(generateDXF(currentParcelContoursXML), `${currentParcelDataXML?.cadNumber?.replace(/:/g,'_') || 'parcel'}.dxf`, 'application/dxf'));
        exportTxtBtn.addEventListener('click', () => {
            if (!currentParcelContoursXML?.some(c => c.length > 0)) return;
            const startNumStr = prompt("Введите номер для первой точки (оставьте пустым для формата N[tab]E):", "");
            if (startNumStr === null) return;
            const cadNum = currentParcelDataXML?.cadNumber?.replace(/:/g,'_') || 'parcel';
            let content, filename;
            if (startNumStr.trim() === "") {
                content = getCoordinatesForDefaultTxtExport(currentParcelContoursXML);
                filename = `${cadNum}_coords_N_E.txt`;
            } else {
                const startNum = parseInt(startNumStr, 10);
                if (!isNaN(startNum)) {
                    let pointNum = startNum;
                    content = currentParcelContoursXML.map(c => c.map(p => `${pointNum++},${p.x.toFixed(2)},${p.y.toFixed(2)}`).join('\n')).join('\n\n');
                    filename = `${cadNum}_coords_Num_N_E.txt`;
                } else {
                    alert("Номер введен некорректно. Экспорт в формате N[tab]E.");
                    content = getCoordinatesForDefaultTxtExport(currentParcelContoursXML);
                    filename = `${cadNum}_coords_N_E.txt`;
                }
            }
            downloadFile(content, filename, 'text/plain;charset=utf-8');
        });

        async function checkClipboardAndAutoSearch() {
            if (!navigator.clipboard?.readText) return;
            try {
                const text = (await navigator.clipboard.readText()).trim();
                if (!text || /[a-zA-Zа-яА-Я]/.test(text) || text.length > 30) return;
                const tempInput = { value: text };
                formatCadastralNumber(tempInput);
                if (isValidCadastralNumber(tempInput.value) && cadastralInput && !loadParcelBtn.disabled) {
                    cadastralInput.value = tempInput.value;
                    loadParcelBtn.click();
                }
            } catch (err) {}
        }

        window.addEventListener('DOMContentLoaded', () => {
            document.querySelectorAll('h2[id]').forEach(h => h._initialTextContent = h.textContent);
            checkClipboardAndAutoSearch();
        });

function autoDetectAndConvertEgrnCoords(geometry, cadNumber) {
            const mskCode = MskFinder.findMskCode(cadNumber);
            if (!mskCode) throw new Error("Не удалось автоматически определить МСК для данного региона.");

            // --- ИЗМЕНЕНИЕ НАЧАЛО: Логика поиска как в "Схема XML" ---
            // Извлекаем код региона (например, "16") из "16-2"
            const regionCode = mskCode.split('-')[0];
            
            // Ищем систему координат, у которой `value` содержит код региона и номер зоны (mskCode)
            // Пример: ищем "16" и "16-2" в "EPSG:6331602" (где 16 - код региона)
            // Этот поиск не очень надежен, если value не содержит mskCode.
            // Более надежный способ - искать по имени, но с учетом разных форматов.
            
            // УЛУЧШЕННЫЙ И НАДЕЖНЫЙ ПОИСК:
            // Сначала пытаемся найти точное совпадение "МСК-КОД"
            let targetSystem = COORDINATE_SYSTEMS.find(s => s.text.includes(`МСК-${mskCode}`));
            
            // Если не нашли, пытаемся найти "МСК КОД" (с пробелом)
            if (!targetSystem) {
                targetSystem = COORDINATE_SYSTEMS.find(s => s.text.includes(`МСК ${mskCode}`));
            }

            // Если снова не нашли, ищем просто код (например, "16-2") в названии
            if (!targetSystem) {
                targetSystem = COORDINATE_SYSTEMS.find(s => s.text.includes(mskCode));
            }
            // --- ИЗМЕНЕНИЕ КОНЕЦ ---

            if (!targetSystem) {
                // Если после всех попыток ничего не найдено, выбрасываем ошибку
                throw new Error(`Определение для МСК-${mskCode} не найдено.`);
            }

            // Устанавливаем определение проекции для proj4
            proj4.defs(targetSystem.value, targetSystem.def);
            const { offsetX = 0, offsetY = 0 } = targetSystem;

            const convertedContours = [];
            // Функция для конвертации одного "кольца" (массива точек)
            const convertRing = ring => ring.map(coord => {
                // Пересчитываем координаты из EPSG:3857 в целевую систему
                const [lon, lat] = proj4('EPSG:3857', targetSystem.value, coord);
                // Применяем смещения и возвращаем объект в формате {x, y}
                return { x: lat + offsetX, y: lon + offsetY };
            });

            // Рекурсивная функция для обработки разных типов геометрии из GeoJSON
            const processGeom = (geom) => {
                if (!geom) return;
                if (geom.type === 'Polygon') {
                    geom.coordinates.forEach(ring => convertedContours.push(convertRing(ring)));
                } else if (geom.type === 'MultiPolygon') {
                    geom.coordinates.forEach(polygon => polygon.forEach(ring => convertedContours.push(convertRing(ring))));
                } else if (geom.type === 'GeometryCollection') {
                    geom.geometries.forEach(processGeom);
                }
            };

            processGeom(geometry); // Запускаем обработку
            return { convertedContours, detectedMskName: targetSystem.text };
        }

        function compareParcelCoordinates(xmlContours, egrnContours) {
            const comparisonTable = [];
            let overallMatch = true;
            const tolerance = 0.01;

            if (xmlContours.length !== egrnContours.length) {
                return { match: false, comparisonTable: [{ message: `Разное количество контуров (XML: ${xmlContours.length}, ЕГРН: ${egrnContours.length})` }] };
            }

            for (let i = 0; i < xmlContours.length; i++) {
                const xmlContour = xmlContours[i];
                let egrnContour = egrnContours[i];
                
                if (xmlContour.length !== egrnContour.length) {
                    overallMatch = false;
                    const maxRows = Math.max(xmlContour.length, egrnContour.length);
                    for(let j=0; j < maxRows; j++) {
                        comparisonTable.push({
                            index: j + 1,
                            xml: xmlContour[j] ? `${xmlContour[j].x.toFixed(2)}, ${xmlContour[j].y.toFixed(2)}` : '—',
                            egrn: egrnContour[j] ? `${egrnContour[j].x.toFixed(2)}, ${egrnContour[j].y.toFixed(2)}` : '—',
                            match: false
                        });
                    }
                    continue; 
                }
                
                let attempt1Match = true;
                const attempt1Table = [];
                for (let j = 0; j < xmlContour.length; j++) {
                    const match = Math.abs(xmlContour[j].x - egrnContour[j].x) <= tolerance && Math.abs(xmlContour[j].y - egrnContour[j].y) <= tolerance;
                    if (!match) attempt1Match = false;
                    attempt1Table.push({
                        index: j + 1,
                        xml: `${xmlContour[j].x.toFixed(2)}, ${xmlContour[j].y.toFixed(2)}`,
                        egrn: `${egrnContour[j].x.toFixed(2)}, ${egrnContour[j].y.toFixed(2)}`,
                        match
                    });
                }
                
                if (attempt1Match) {
                    comparisonTable.push(...attempt1Table);
                    continue;
                }

                let attempt2Match = true;
                const attempt2Table = [];
                const egrnReversed = [egrnContour[0], ...egrnContour.slice(1, -1).reverse(), egrnContour[egrnContour.length - 1]];
                for (let j = 0; j < xmlContour.length; j++) {
                    const match = Math.abs(xmlContour[j].x - egrnReversed[j].x) <= tolerance && Math.abs(xmlContour[j].y - egrnReversed[j].y) <= tolerance;
                    if (!match) attempt2Match = false;
                    attempt2Table.push({
                        index: j + 1,
                        xml: `${xmlContour[j].x.toFixed(2)}, ${xmlContour[j].y.toFixed(2)}`,
                        egrn: `${egrnReversed[j].x.toFixed(2)}, ${egrnReversed[j].y.toFixed(2)} (R)`,
                        match
                    });
                }

                if (attempt2Match) {
                    comparisonTable.push(...attempt2Table);
                } else {
                    overallMatch = false;
                    comparisonTable.push(...attempt1Table);
                }
            }
            return { match: overallMatch, comparisonTable };
        }
        
function displayComparisonResultUI(result) {
            const btn = document.getElementById('comparisonToggleBtn');
            const tableContainer = document.getElementById('comparisonTableContainer');
            if (!result || !result.comparisonTable) {
                comparisonSectionDiv.style.display = 'none';
                return;
            }

            btn.className = 'comparison-toggle-btn';
            
            // --- ИЗМЕНЕНИЕ НАЧАЛО: Исправлены цвета кнопки ---
            if (result.match) {
                btn.classList.add('success'); // Зеленый цвет
                btn.innerHTML = `<i class="fas fa-check-circle"></i> Контроль пройден`;
            } else {
                btn.classList.add('failure'); // Красный цвет
                btn.innerHTML = `<i class="fas fa-exclamation-triangle"></i> Контроль не пройден`;
            }
            // --- ИЗМЕНЕНИЕ КОНЕЦ ---

            let tableHTML = '<table class="comparison-table"><thead><tr><th>№</th><th>XML</th><th>ЕГРН</th></tr></thead><tbody>';
            if (result.comparisonTable[0]?.message) {
                 tableHTML += `<tr><td colspan="3" class="mismatch-row">${result.comparisonTable[0].message}</td></tr>`;
            } else {
                 result.comparisonTable.forEach(row => {
                    tableHTML += `<tr class="${row.match ? 'match-row' : 'mismatch-row'}">
                        <td>${row.index}</td>
                        <td>${row.xml}</td>
                        <td>${row.egrn}</td>
                    </tr>`;
                });
            }
            tableHTML += '</tbody></table>';
            tableContainer.innerHTML = tableHTML;

            if (btn._clickHandler) btn.removeEventListener('click', btn._clickHandler);
            btn._clickHandler = () => {
                const isVisible = tableContainer.style.display === 'block';
                tableContainer.style.display = isVisible ? 'none' : 'block';
            };
            btn.addEventListener('click', btn._clickHandler);

            comparisonSectionDiv.style.display = 'block';
        }
        
  </script>
</body>
</html>