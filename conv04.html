<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Конвертер выписки КПТ - Финальная Версия</title>
    <!-- Подключаем библиотеку для работы с ZIP -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <style>
        :root {
            --primary-color: #4A89F2; --primary-hover: #3578E5; --success-color: #28a745;
            --success-bg: #e9f7ef; --danger-color: #dc3545; --danger-bg: #f8d7da;
            --light-bg: #f8f9fa; --text-color: #343a40; --text-light: #6c757d;
            --border-color: #dee2e6; --border-dashed: #cdd2d8; --border-radius: 12px;
            --box-shadow: 0 6px 25px rgba(0,0,0,0.07);
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            line-height: 1.6; margin: 0; padding: 20px; background-color: #f0f2f5;
            color: var(--text-color); display: flex; justify-content: center; align-items: flex-start; min-height: 100vh;
        }
        .container {
            max-width: 700px; width: 100%; background: #fff; padding: 40px;
            border-radius: var(--border-radius); box-shadow: var(--box-shadow); text-align: center;
        }
        h1 { color: #2c3e50; margin-bottom: 10px; font-size: 28px; }
        .subtitle { color: var(--text-light); margin-bottom: 40px; }
        .stage { display: none; margin-top: 25px; }
        .stage.active { display: block; }
        .upload-wrapper {
            border: 2px dashed var(--border-dashed); border-radius: var(--border-radius); padding: 40px;
            cursor: pointer; transition: background-color 0.3s, border-color 0.3s;
        }
        .upload-wrapper.highlight { background-color: #f0f5fe; border-color: var(--primary-color); }
        .upload-icon {
            width: 50px; height: 50px; margin: 0 auto 20px; background-color: #e8effc; border-radius: 50%;
            display: flex; align-items: center; justify-content: center;
        }
        .upload-icon svg { width: 28px; height: 28px; fill: var(--primary-color); }
        .upload-text { font-size: 18px; font-weight: 500; color: var(--text-color); }
        .upload-text span { color: var(--primary-color); font-weight: 600; }
        .upload-hint { color: var(--text-light); font-size: 14px; margin-top: 8px; }
        .encoding-selector { margin-top: 25px; text-align: center; }
        .encoding-selector label { margin-right: 10px; color: var(--text-light); font-size: 14px; }
        .encoding-selector select { padding: 5px 10px; border-radius: 6px; border: 1px solid var(--border-color); background-color: var(--light-bg); cursor: pointer; }
        input[type="file"] { display: none; }
        #options-stage h2 { font-size: 20px; margin-bottom: 20px; border-bottom: 1px solid var(--border-color); padding-bottom: 10px; text-align: left;}
        .options-list { list-style: none; padding: 0; margin: 0; text-align: left;}
        .options-list li { display: flex; align-items: center; padding: 12px 0; border-bottom: 1px solid #f0f0f0; }
        .options-list li:last-child { border-bottom: none; }
        .custom-checkbox { display: flex; align-items: center; cursor: pointer; width: 100%; }
        .custom-checkbox input { display: none; }
        .custom-checkbox .checkmark { min-width: 20px; height: 20px; border: 2px solid var(--border-color); border-radius: 4px; margin-right: 15px; display: inline-block; position: relative; transition: all 0.2s; }
        .custom-checkbox input:checked ~ .checkmark { background-color: var(--primary-color); border-color: var(--primary-color); }
        .custom-checkbox .checkmark::after { content: ""; position: absolute; display: none; left: 6px; top: 2px; width: 5px; height: 10px; border: solid white; border-width: 0 3px 3px 0; transform: rotate(45deg); }
        .custom-checkbox input:checked ~ .checkmark::after { display: block; }
        .custom-checkbox .label-text { font-weight: 500; }
        .custom-checkbox .count { margin-left: auto; background-color: var(--light-bg); padding: 3px 8px; border-radius: 12px; font-size: 14px; color: var(--text-light); font-weight: bold; }
        .actions { margin-top: 30px; display: flex; justify-content: flex-end; gap: 15px; }
        .btn { padding: 12px 25px; font-size: 16px; font-weight: bold; border: none; border-radius: 8px; cursor: pointer; transition: all 0.3s; }
        .btn-primary { background-color: var(--primary-color); color: white; box-shadow: 0 4px 15px rgba(74, 137, 242, 0.3); }
        .btn-primary:hover { background-color: var(--primary-hover); transform: translateY(-2px); box-shadow: 0 6px 20px rgba(74, 137, 242, 0.4); }
        .btn-secondary { background-color: #6c757d; color: white; }
        .btn-secondary:hover { background-color: #5a6268; }
        #result-content { padding: 20px; border-radius: var(--border-radius); margin-top: 20px; }
        #result-content.success { background-color: var(--success-bg); border: 1px solid var(--success-color); }
        #result-content.error { background-color: var(--danger-bg); border: 1px solid var(--danger-color); color: #721c24; }
        #result-content p { margin: 0 0 15px; font-weight: bold; }
        #downloadLink { display: inline-block; background-color: var(--success-color); color: white; padding: 12px 20px; text-decoration: none; border-radius: 5px; font-weight: bold; transition: background-color 0.3s; }
        #downloadLink:hover { background-color: #218838; }
        #loader { text-align: center; padding: 20px; }
        .spinner { border: 4px solid rgba(0,0,0,0.1); width: 36px; height: 36px; border-radius: 50%; border-left-color: var(--primary-color); animation: spin 1s ease infinite; margin: 0 auto 10px; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
    </style>
</head>
<body>
    <div class="container">
        <h1>Конвертер выписки КПТ</h1>
        <p class="subtitle">Преобразование XML/ZIP в схему KPT v.10 с выбором объектов</p>
        <div id="upload-stage" class="stage active">
            <input type="file" id="fileInput" accept=".xml,.zip">
            <label for="fileInput" class="upload-wrapper" id="uploadWrapper">
                <div class="upload-icon">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M18.71,11.29l-5-5a1,1,0,0,0-1.42,0l-5,5a1,1,0,0,0,1.42,1.42L12,9.41V19a1,1,0,0,0,2,0V9.41l3.29,3.3a1,1,0,0,0,1.42-1.42Z M6,6H8A1,1,0,0,0,8,4H6A3,3,0,0,0,3,7V17a3,3,0,0,0,3,3H18a3,3,0,0,0,3-3V7a3,3,0,0,0-3-3H16a1,1,0,0,0,0,2h2a1,1,0,0,1,1,1V17a1,1,0,0,1-1-1H6a1,1,0,0,1-1-1V7A1,1,0,0,1,6,6Z"/></svg>
                </div>
                <div id="uploadText" class="upload-text"><span>Нажмите для выбора</span> или перетащите файл</div>
                <div class="upload-hint">Поддерживаются форматы XML и ZIP</div>
            </label>
            <div class="encoding-selector">
                <label for="encodingSelector">Кодировка исходного файла:</label>
                <select id="encodingSelector">
                    <option value="UTF-8">UTF-8 (стандарт)</option>
                    <option value="windows-1251">Windows-1251 (для старых файлов)</option>
                </select>
            </div>
        </div>
        <div id="options-stage" class="stage">
             <h2>Выберите объекты для конвертации:</h2>
            <p id="fileNameInfo" style="font-size: 14px; color: var(--text-light); margin-bottom: 20px; text-align: left;"></p>
            <ul id="optionsList" class="options-list"></ul>
            <div class="actions">
                 <button id="resetButton" class="btn btn-secondary">Начать заново</button>
                 <button id="convertButton" class="btn btn-primary">Конвертировать</button>
            </div>
        </div>
        <div id="result-stage" class="stage">
            <div id="loader"><div class="spinner"></div>Обработка файла...</div>
            <div id="result-content"></div>
             <div class="actions" style="justify-content: center; margin-top: 20px;">
                 <button id="startOverButton" class="btn btn-primary">Конвертировать другой файл</button>
            </div>
        </div>
    </div>

<script>
let currentXmlDoc = null;
let currentFileName = '';
const stages = { upload: document.getElementById('upload-stage'), options: document.getElementById('options-stage'), result: document.getElementById('result-stage') };
const fileInput = document.getElementById('fileInput');
const uploadWrapper = document.getElementById('uploadWrapper');
const optionsList = document.getElementById('optionsList');
const fileNameInfo = document.getElementById('fileNameInfo');
const convertButton = document.getElementById('convertButton');
const resetButton = document.getElementById('resetButton');
const startOverButton = document.getElementById('startOverButton');
const loader = document.getElementById('loader');
const resultContent = document.getElementById('result-content');
const encodingSelector = document.getElementById('encodingSelector');

const OBJECT_TYPES = {
    parcels: { label: 'Земельные участки', selector: 'land_record' },
    buildings: { label: 'Здания', selector: 'build_record' },
    constructions: { label: 'Сооружения', selector: 'construction_record' },
    bounds: { label: 'Границы (муниципальные, н.п.)', selector: 'municipal_boundary_record, inhabited_locality_boundary_record' },
    zones: { label: 'Зоны и территории', selector: 'zones_and_territories_record' }
};

function updateUIState(activeStage) {
    Object.values(stages).forEach(stage => stage.classList.remove('active'));
    if (stages[activeStage]) stages[activeStage].classList.add('active');
}
function resetApp() {
    currentXmlDoc = null; currentFileName = ''; fileInput.value = '';
    resultContent.innerHTML = ''; resultContent.className = '';
    updateUIState('upload');
}

fileInput.addEventListener('change', () => handleFileSelect(fileInput.files));
uploadWrapper.addEventListener('drop', handleFileDrop, false);
['dragenter', 'dragover', 'dragleave', 'drop'].forEach(e => uploadWrapper.addEventListener(e, preventDefaults, false));
['dragenter', 'dragover'].forEach(e => uploadWrapper.addEventListener(e, () => uploadWrapper.classList.add('highlight'), false));
['dragleave', 'drop'].forEach(e => uploadWrapper.addEventListener(e, () => uploadWrapper.classList.remove('highlight'), false));
convertButton.addEventListener('click', handleConversion);
resetButton.addEventListener('click', resetApp);
startOverButton.addEventListener('click', resetApp);

function preventDefaults(e) { e.preventDefault(); e.stopPropagation(); }
function handleFileDrop(e) { fileInput.files = e.dataTransfer.files; handleFileSelect(e.dataTransfer.files); }

function handleFileSelect(files) {
    if (files.length === 0) return;
    const file = files[0];
    currentFileName = file.name;
    showLoaderWithMessage(`Анализ файла: ${file.name}`);
    if (file.name.toLowerCase().endsWith('.zip')) {
        handleZipFile(file);
    } else {
        handleXmlFile(file);
    }
}

function handleZipFile(file) {
    const encoding = encodingSelector.value;
    JSZip.loadAsync(file).then(zip => {
        const xmlFile = Object.values(zip.files).find(f => f.name.toLowerCase().endsWith('.xml'));
        if (xmlFile) return xmlFile.async("blob");
        throw new Error("XML-файл не найден в ZIP-архиве.");
    }).then(blob => {
        const reader = new FileReader();
        reader.onload = e => processXmlString(e.target.result);
        reader.onerror = () => showError('Не удалось прочитать XML из ZIP.');
        reader.readAsText(blob, encoding);
    }).catch(error => showError(`Ошибка при обработке ZIP: ${error.message}`));
}

function handleXmlFile(file) {
    const encoding = encodingSelector.value;
    const reader = new FileReader();
    reader.onload = (event) => processXmlString(event.target.result);
    reader.onerror = () => showError('Не удалось прочитать XML-файл.');
    reader.readAsText(file, encoding);
}

function processXmlString(xmlString) {
    try {
        const parser = new DOMParser();
        const xmlDoc = parser.parseFromString(xmlString, "application/xml");
        const parserError = xmlDoc.querySelector("parsererror");
        if (parserError) throw new Error(`Ошибка разбора XML: ${parserError.textContent}. Попробуйте сменить кодировку.`);
        currentXmlDoc = xmlDoc;
        analyzeAndDisplayOptions(xmlDoc);
    } catch (error) {
        showError(`Ошибка: ${error.message}`);
    }
}

function analyzeAndDisplayOptions(xmlDoc) {
    optionsList.innerHTML = '';
    let hasObjects = false;
    Object.entries(OBJECT_TYPES).forEach(([key, config]) => {
        const count = xmlDoc.querySelectorAll(config.selector).length;
        if (count > 0) {
            hasObjects = true;
            optionsList.innerHTML += `<li><label class="custom-checkbox"><input type="checkbox" data-type="${key}" checked><span class="checkmark"></span><span class="label-text">${config.label}</span><span class="count">${count}</span></label></li>`;
        }
    });
    if (!hasObjects) { showError('В файле не найдено поддерживаемых объектов для конвертации.'); return; }
    fileNameInfo.textContent = `Файл: ${currentFileName}`;
    updateUIState('options');
}

function handleConversion() {
    if (!currentXmlDoc) { showError('XML документ не загружен.'); return; }
    updateUIState('result');
    loader.style.display = 'block';
    resultContent.style.display = 'none';
    setTimeout(() => {
        try {
            const selection = {};
            optionsList.querySelectorAll('input[type="checkbox"]').forEach(c => { selection[c.dataset.type] = c.checked; });
            const newXmlString = convertXml(currentXmlDoc, selection);
            const blob = new Blob([newXmlString], { type: 'application/xml;charset=utf-8' });
            const url = URL.createObjectURL(blob);
            const cadNum = currentXmlDoc.querySelector('cadastral_block > cadastral_number')?.textContent || 'unknown';
            const fileName = `KPT_${cadNum.replace(/:/g, '_')}_v10.xml`;
            showSuccess(url, fileName);
        } catch (error) {
            console.error(error);
            showError(`Ошибка конвертации: ${error.message}`);
        } finally {
            loader.style.display = 'none';
        }
    }, 100);
}

function showLoaderWithMessage(message) {
    updateUIState('result');
    loader.style.display = 'block';
    loader.lastChild.textContent = message;
    resultContent.style.display = 'none';
}
function showSuccess(url, fileName) {
    resultContent.className = 'success';
    resultContent.innerHTML = `<p>✅ <strong>Конвертация успешно завершена!</strong></p><a href="${url}" id="downloadLink" download="${fileName}">Скачать новый XML-файл</a>`;
    resultContent.style.display = 'block';
}
function showError(message) {
    updateUIState('result');
    loader.style.display = 'none';
    resultContent.className = 'error';
    resultContent.innerHTML = `<p>❌ <strong>Ошибка!</strong></p>${message}`;
    resultContent.style.display = 'block';
}

const NS = {
    KPT: "urn://x-artefacts-rosreestr-ru/outgoing/kpt/10.0.1",
    ADR: "urn://x-artefacts-rosreestr-ru/commons/complex-types/address-output/4.0.1",
    SPATIAL: "urn://x-artefacts-rosreestr-ru/commons/complex-types/entity-spatial/5.0.1",
    OKS: "urn://x-artefacts-rosreestr-ru/commons/complex-types/parameters-oks/2.0.1",
    CERT: "urn://x-artefacts-rosreestr-ru/commons/complex-types/certification-doc/1.0",
    DOC: "urn://x-artefacts-rosreestr-ru/commons/complex-types/document-output/4.0.1",
    SMEV: "urn://x-artefacts-smev-gov-ru/supplementary/commons/1.0.1"
};
const getNodeValue = (parent, selector) => parent.querySelector(selector)?.textContent.trim() || '';

function convertXml(oldDoc, selection) {
    const newDoc = document.implementation.createDocument(NS.KPT, 'KPT', null);
    const root = newDoc.documentElement;
    root.setAttributeNS('http://www.w3.org/2000/xmlns/', 'xmlns', NS.KPT);
    root.setAttributeNS('http://www.w3.org/2000/xmlns/', 'xmlns:adrOut4', NS.ADR);
    root.setAttributeNS('http://www.w3.org/2000/xmlns/', 'xmlns:ns3', NS.SPATIAL);
    root.setAttributeNS('http://www.w3.org/2000/xmlns/', 'xmlns:ns4', NS.OKS);
    root.setAttributeNS('http://www.w3.org/2000/xmlns/', 'xmlns:ns5', NS.DOC);
    root.setAttributeNS('http://www.w3.org/2000/xmlns/', 'xmlns:ns6', NS.CERT);
    root.setAttributeNS('http://www.w3.org/2000/xmlns/', 'xmlns:ns7', NS.SMEV);
    
    const coordSystems = new Map();
    const csCounter = { value: 1 };
    
    const cadastralBlocks = createElement(newDoc, NS.KPT, 'CadastralBlocks');
    oldDoc.querySelectorAll('cadastral_block').forEach(oldBlock => {
        const newBlock = createElement(newDoc, NS.KPT, 'CadastralBlock');
        newBlock.setAttribute('CadastralNumber', getNodeValue(oldBlock, 'cadastral_number'));
        const area = createElement(newDoc, NS.KPT, 'Area');
        area.appendChild(createElementWithText(newDoc, NS.KPT, 'Total', getNodeValue(oldBlock, 'area_quarter area')));
        area.appendChild(createElementWithText(newDoc, NS.KPT, 'Unit', getNodeValue(oldBlock, 'area_quarter unit')));
        newBlock.appendChild(area);
        
        if (selection.parcels) appendChildIfNotEmpty(newBlock, convertParcels(oldBlock, newDoc, coordSystems, csCounter));
        if (selection.buildings || selection.constructions) appendChildIfNotEmpty(newBlock, convertObjectsRealty(oldBlock, newDoc, coordSystems, csCounter, selection));
        if (selection.bounds) appendChildIfNotEmpty(newBlock, convertBounds(oldBlock, newDoc, coordSystems, csCounter));
        if (selection.zones) appendChildIfNotEmpty(newBlock, convertZones(oldBlock, newDoc, coordSystems, csCounter));
        appendChildIfNotEmpty(newBlock, convertSpatialData(oldBlock, newDoc, coordSystems, csCounter));
        
        cadastralBlocks.appendChild(newBlock);
    });
    root.appendChild(cadastralBlocks);

    root.appendChild(createCoordSystemsNode(newDoc, coordSystems));
    root.appendChild(createCertificationDocNode(oldDoc, newDoc));
    
    const serializer = new XMLSerializer();
    let xmlString = serializer.serializeToString(newDoc);
    const styleSheet = '<?xml-stylesheet type="text/xsl" href="https://portal.rosreestr.ru/xsl/GKN/KPT_b/10/common.xsl"?>';
    return `<?xml version="1.0" encoding="UTF-8"?>\n${styleSheet}\n` + xmlString;
}

function appendChildIfNotEmpty(parent, child) { if (child && child.hasChildNodes()) parent.appendChild(child); }
function createElement(doc, ns, qualifiedName) { return doc.createElementNS(ns, qualifiedName); }
function createElementWithText(doc, ns, qualifiedName, text) { const el = createElement(doc, ns, qualifiedName); if (text) el.textContent = text; return el; }

function createCertificationDocNode(oldDoc, newDoc) {
    const certDoc = createElement(newDoc, NS.KPT, 'CertificationDoc');
    const statement = oldDoc.querySelector('details_statement');
    if (!statement) return certDoc;
    certDoc.appendChild(createElementWithText(newDoc, NS.CERT, 'ns6:Organization', getNodeValue(statement, 'organ_registr_rights')));
    certDoc.appendChild(createElementWithText(newDoc, NS.CERT, 'ns6:Date', getNodeValue(statement, 'date_formation')));
    certDoc.appendChild(createElementWithText(newDoc, NS.CERT, 'ns6:Number', getNodeValue(statement, 'registration_number')));
    return certDoc;
}

function createAddressNode(oldAddress, newDoc) {
    const locationNode = createElement(newDoc, NS.KPT, 'Location');
    if (!oldAddress) return locationNode;
    const address = createElement(newDoc, NS.KPT, 'Address'); // Standard element, not non-self-closing
    locationNode.appendChild(address);
    const addressTypeCode = getNodeValue(oldAddress, 'address_type code');
    if (addressTypeCode === '02') { address.setAttribute('adrOut4:AddressOrLocation', '0'); }
    const addrSource = oldAddress.querySelector('address, location');
    if (!addrSource) return locationNode;
    
    const createAdrEl = (name, val) => { if (!val) return null; return createElementWithText(newDoc, NS.ADR, `adrOut4:${name}`, val); };
    const createAdrElWithAttr = (name, attrs) => {
        const hasValues = Object.values(attrs).some(v => v);
        if (!hasValues) return null;
        const el = createElement(newDoc, NS.ADR, `adrOut4:${name}`); // Standard element
        Object.entries(attrs).forEach(([key, value]) => value && el.setAttribute(key, value));
        return el;
    };
    
    const elements = [
        createAdrEl('OKATO', getNodeValue(addrSource, 'okato')), createAdrEl('KLADR', getNodeValue(addrSource, 'kladr')),
        createAdrEl('PostalCode', getNodeValue(addrSource, 'postal_code')),
        createAdrEl('Region', getNodeValue(addrSource, 'region code')),
        createAdrElWithAttr('District', { Type: getNodeValue(addrSource, 'district type_district'), Name: getNodeValue(addrSource, 'district name_district') }),
        createAdrElWithAttr('City', { Type: getNodeValue(addrSource, 'city type_city'), Name: getNodeValue(addrSource, 'city name_city') }),
        createAdrElWithAttr('Street', { Type: getNodeValue(addrSource, 'street type_street'), Name: getNodeValue(addrSource, 'street name_street') }),
        createAdrElWithAttr('Level1', { Type: getNodeValue(addrSource, 'level1 type_level1'), Value: getNodeValue(addrSource, 'level1 name_level1') }),
        createAdrEl('Note', getNodeValue(oldAddress, 'readable_address'))
    ];
    elements.forEach(el => el && address.appendChild(el));
    return locationNode;
}

function createEntitySpatialNode(oldSpatial, newDoc, coordSystems, csCounter) {
    const entSpatial = createElement(newDoc, NS.KPT, 'EntitySpatial');
    if (!oldSpatial) return entSpatial;
    const csId = getNodeValue(oldSpatial, 'sk_id') || 'UNKNOWN_CS';
    let sysId = coordSystems.get(csId);
    if (!sysId) { sysId = `ID${csCounter.value++}`; coordSystems.set(csId, sysId); }
    entSpatial.setAttribute('EntSys', sysId);
    const spatialElements = oldSpatial.querySelectorAll('contour > entity_spatial > spatials_elements > spatial_element, spatials_elements > spatial_element');
    spatialElements.forEach(oldElement => {
        const spatialElementNode = createElement(newDoc, NS.SPATIAL, 'ns3:SpatialElement');
        oldElement.querySelectorAll(':scope > ordinates > ordinate').forEach(ord => {
            const suNmb = getNodeValue(ord, 'ord_nmb') || getNodeValue(ord, 'number_pp');
            const spelementUnit = createElement(newDoc, NS.SPATIAL, 'ns3:SpelementUnit');
            spelementUnit.setAttribute('TypeUnit', 'Точка');
            if (suNmb) spelementUnit.setAttribute('SuNmb', suNmb);
            const ordinate = createElement(newDoc, NS.SPATIAL, 'ns3:Ordinate'); // Standard element
            ordinate.setAttribute('X', getNodeValue(ord, 'x'));
            ordinate.setAttribute('Y', getNodeValue(ord, 'y'));
            ordinate.setAttribute('OrdNmb', '1');
            const numGeopoint = getNodeValue(ord, 'num_geopoint');
            if (numGeopoint) ordinate.setAttribute('NumGeopoint', numGeopoint);
            const delta = getNodeValue(ord, 'delta_geopoint');
            if (delta) ordinate.setAttribute('DeltaGeopoint', delta);
            const zacrep = getNodeValue(ord, 'geopoint_zacrep');
            if (zacrep && zacrep !== "-") { ordinate.setAttribute('GeopointZacrep', zacrep); } 
            else if (!numGeopoint) { ordinate.setAttribute('GeopointZacrep', 'Закрепление отсутствует'); }
            spelementUnit.appendChild(ordinate);
            spatialElementNode.appendChild(spelementUnit);
        });
        if (spatialElementNode.hasChildNodes()) { entSpatial.appendChild(spatialElementNode); }
    });
    return entSpatial;
}

function createCoordSystemsNode(newDoc, coordSystems) {
    const csNode = createElement(newDoc, NS.KPT, 'CoordSystems');
    for (const [name, id] of coordSystems.entries()) {
        const system = createElement(newDoc, NS.SPATIAL, 'ns3:CoordSystem');
        system.setAttribute('Name', name);
        system.setAttribute('CsId', id);
        csNode.appendChild(system);
    }
    return csNode;
}

function convertParcels(oldBlock, newDoc, coordSystems, csCounter) {
    const parcelsNode = createElement(newDoc, NS.KPT, 'Parcels');
    oldBlock.querySelectorAll('land_record').forEach(oldParcel => {
        const newParcel = createElement(newDoc, NS.KPT, 'Parcel');
        newParcel.setAttribute('CadastralNumber', getNodeValue(oldParcel, 'object common_data cad_number'));
        newParcel.setAttribute('State', '01');
        const areaNode = createElement(newDoc, NS.KPT, 'Area');
        areaNode.appendChild(createElementWithText(newDoc, NS.KPT, 'Area', getNodeValue(oldParcel, 'params area value')));
        areaNode.appendChild(createElementWithText(newDoc, NS.KPT, 'Unit', '055'));
        const inaccuracy = getNodeValue(oldParcel, 'params area inaccuracy');
        if (inaccuracy) areaNode.appendChild(createElementWithText(newDoc, NS.KPT, 'Inaccuracy', inaccuracy));
        newParcel.appendChild(areaNode);
        if (getNodeValue(oldParcel, 'object subtype value').toLowerCase().includes('землепользование')) {
            newParcel.appendChild(createElementWithText(newDoc, NS.KPT, 'Name', '01'));
        }
        newParcel.appendChild(createAddressNode(oldParcel.querySelector('address_location'), newDoc));
        newParcel.appendChild(createElementWithText(newDoc, NS.KPT, 'Category', getNodeValue(oldParcel, 'params category type code')));
        const utilNode = createElement(newDoc, NS.KPT, 'Utilization');
        utilNode.setAttribute('ByDoc', getNodeValue(oldParcel, 'params permitted_use by_document, params permitted_use permitted_use_established by_document'));
        newParcel.appendChild(utilNode);
        const costVal = getNodeValue(oldParcel, 'cost value');
        if (costVal) {
            const costNode = createElement(newDoc, NS.KPT, 'CadastralCost');
            costNode.setAttribute('Value', costVal);
            costNode.setAttribute('Unit', '383');
            newParcel.appendChild(costNode);
        }
        const oldSpatial = oldParcel.querySelector('contours_location, entity_spatial');
        if (oldSpatial) newParcel.appendChild(createEntitySpatialNode(oldSpatial, newDoc, coordSystems, csCounter));
        parcelsNode.appendChild(newParcel);
    });
    return parcelsNode;
}

function convertObjectsRealty(oldBlock, newDoc, coordSystems, csCounter, selection) {
    const objectsNode = createElement(newDoc, NS.KPT, 'ObjectsRealty');
    if (selection.buildings) {
        oldBlock.querySelectorAll('build_record').forEach(oldBuild => {
            const objectRealty = createElement(newDoc, NS.KPT, 'ObjectRealty');
            const building = createElement(newDoc, NS.KPT, 'Building');
            building.setAttribute('CadastralNumber', getNodeValue(oldBuild, 'object common_data cad_number'));
            building.appendChild(createElementWithText(newDoc, NS.KPT, 'ObjectType', getNodeValue(oldBuild, 'object common_data type code')));
            building.appendChild(createElementWithText(newDoc, NS.KPT, 'AssignationBuilding', getNodeValue(oldBuild, 'params purpose code')));
            building.appendChild(createElementWithText(newDoc, NS.KPT, 'Area', getNodeValue(oldBuild, 'params area')));
            building.appendChild(createAddressNode(oldBuild.querySelector('address_location'), newDoc));
            const cost = getNodeValue(oldBuild, 'cost value');
            if(cost) {
                const costNode = createElement(newDoc, NS.KPT, 'CadastralCost');
                costNode.setAttribute('Value', cost); costNode.setAttribute('Unit', '383');
                building.appendChild(costNode);
            }
            const oldSpatial = oldBuild.querySelector('contours, entity_spatial');
            if (oldSpatial) building.appendChild(createEntitySpatialNode(oldSpatial, newDoc, coordSystems, csCounter));
            objectRealty.appendChild(building);
            objectsNode.appendChild(objectRealty);
        });
    }
    if (selection.constructions) {
        oldBlock.querySelectorAll('construction_record').forEach(oldConstr => {
            const objectRealty = createElement(newDoc, NS.KPT, 'ObjectRealty');
            const constr = createElement(newDoc, NS.KPT, 'Construction');
            constr.setAttribute('CadastralNumber', getNodeValue(oldConstr, 'object common_data cad_number'));
            constr.appendChild(createElementWithText(newDoc, NS.KPT, 'ObjectType', getNodeValue(oldConstr, 'object common_data type code')));
            constr.appendChild(createElementWithText(newDoc, NS.KPT, 'AssignationName', getNodeValue(oldConstr, 'params purpose')));
            const extension = getNodeValue(oldConstr, 'base_parameters extension');
            if (extension) {
                const keyParams = createElement(newDoc, NS.KPT, 'KeyParameters');
                const keyParam = createElement(newDoc, NS.OKS, 'ns4:KeyParameter');
                keyParam.setAttribute('Type', '01');
                keyParam.setAttribute('Value', extension);
                keyParams.appendChild(keyParam);
                constr.appendChild(keyParams);
            }
            constr.appendChild(createAddressNode(oldConstr.querySelector('address_location'), newDoc));
            const cost = getNodeValue(oldConstr, 'cost value');
            if(cost) {
                const costNode = createElement(newDoc, NS.KPT, 'CadastralCost');
                costNode.setAttribute('Value', cost); costNode.setAttribute('Unit', '383');
                constr.appendChild(costNode);
            }
            const oldSpatial = oldConstr.querySelector('contours, entity_spatial');
            if (oldSpatial) constr.appendChild(createEntitySpatialNode(oldSpatial, newDoc, coordSystems, csCounter));
            objectRealty.appendChild(constr);
            objectsNode.appendChild(objectRealty);
        });
    }
    return objectsNode;
}

function convertSpatialData(oldBlock, newDoc, coordSystems, csCounter) {
    const spatialNode = createElement(newDoc, NS.KPT, 'SpatialData');
    const oldSpatial = oldBlock.querySelector(':scope > spatial_data > entity_spatial');
    if (oldSpatial) {
        spatialNode.appendChild(createEntitySpatialNode(oldSpatial, newDoc, coordSystems, csCounter));
    }
    return spatialNode;
}

function convertBounds(oldBlock, newDoc, coordSystems, csCounter) {
    const boundsNode = createElement(newDoc, NS.KPT, 'Bounds');
    oldBlock.querySelectorAll('municipal_boundary_record, inhabited_locality_boundary_record').forEach(oldBoundRec => {
        const boundNode = createElement(newDoc, NS.KPT, 'Bound');
        const bObject = oldBoundRec.querySelector('b_object');
        boundNode.appendChild(createElementWithText(newDoc, NS.KPT, 'Description', getNodeValue(bObject, 'type_boundary value')));
        boundNode.appendChild(createElementWithText(newDoc, NS.KPT, 'AccountNumber', getNodeValue(bObject, 'reg_numb_border')));
        const boundaries = createElement(newDoc, NS.KPT, 'Boundaries');
        const oldSpatial = oldBoundRec.querySelector('b_contours_location');
        if (oldSpatial) {
            const boundary = createElement(newDoc, NS.KPT, 'Boundary');
            boundary.appendChild(createEntitySpatialNode(oldSpatial, newDoc, coordSystems, csCounter));
            boundaries.appendChild(boundary);
        }
        appendChildIfNotEmpty(boundNode, boundaries);
        boundsNode.appendChild(boundNode);
    });
    return boundsNode;
}

function convertZones(oldBlock, newDoc, coordSystems, csCounter) {
    const zonesNode = createElement(newDoc, NS.KPT, 'Zones');
    oldBlock.querySelectorAll('zones_and_territories_record').forEach(oldZoneRec => {
        const zoneNode = createElement(newDoc, NS.KPT, 'Zone');
        const bObject = oldZoneRec.querySelector('b_object_zones_and_territories');
        zoneNode.appendChild(createElementWithText(newDoc, NS.KPT, 'Description', getNodeValue(bObject, 'type_boundary value')));
        zoneNode.appendChild(createElementWithText(newDoc, NS.KPT, 'AccountNumber', getNodeValue(bObject, 'b_object reg_numb_border')));
        const oldSpatial = oldZoneRec.querySelector('b_contours_location');
        if(oldSpatial) zoneNode.appendChild(createEntitySpatialNode(oldSpatial, newDoc, coordSystems, csCounter));
        const specialZone = createElement(newDoc, NS.KPT, 'SpecialZone');
        const content = `${getNodeValue(bObject, 'type_zone code')} ${getNodeValue(bObject, 'type_zone value')}`;
        specialZone.appendChild(createElementWithText(newDoc, NS.KPT, 'ContentRestrictions', content.trim()));
        zoneNode.appendChild(specialZone);
        zonesNode.appendChild(zoneNode);
    });
    return zonesNode;
}
</script>
</body>
</html>