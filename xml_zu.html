<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Просмотр ЗУ (КПТ)</title>
    <link rel="stylesheet" href="/webfonts/all.min.css">
    <script src="/webfonts/jszip.min.js"></script>
    <script src="/webfonts/xlsx.full.min.js"></script>
    <link rel="icon" href="https://img.icons8.com/?size=100&id=TRbq1cXtHlF8&format=png&color=000000" type="image/png">
    <style>
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            margin: 20px;
            background-color: #f0f0f0;
        }

        .file-input-wrapper {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            margin: 20px auto;
            text-align: center;
            width: 100%;
        }
        .document-info {
            align-self: flex-end;
            text-align: right;
            font-size: 14px;
            color: #4a4a4a;
            cursor: pointer;
            padding: 5px 10px;
            border-radius: 5px;
            transition: background-color 0.3s;
            margin-top: 10px;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.1);
            transition: all 0.3s ease;
        }
        .document-info:hover {
            background-color: #f0f0f0;
        }
        .document-info.flash {
            background-color: #f0f0f0;
        }

        #showKPTScheme {
            background-color: #4a69bd;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s;
        }

        #showKPTScheme:hover {
            background-color: #1e3799;
        }
        .file-input-wrapper input[type="file"] {
            position: absolute;
            left: -9999px;
        }
        .file-input-wrapper label {
            display: inline-block;
            padding: 10px 20px;
            background-color: #4CAF50;
            color: white;
            cursor: pointer;
            border-radius: 5px;
            font-size: 16px;
            transition: all 0.3s ease;
            transform: translateY(-50px);
            opacity: 0;
            animation: dropIn 0.5s forwards;
        }
        @keyframes dropIn {
            0% {
                transform: translateY(-50px);
                opacity: 0;
            }
            100% {
                transform: translateY(0);
                opacity: 1;
            }

        }

        @keyframes flash {
            0% { background-color: initial; }
            50% { background-color: #4CAF50; }
            100% { background-color: initial; }
        }

        .flash {
            animation: flash 1s;
        }


        .sticky-filter {
            position: sticky;
            top: 10px;
            background-color: white;
            padding: 10px;
            z-index: 1000;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }


        .file-input-wrapper label:hover {
            background-color: #45a049;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.1);
        }
        td, th {
            border: 1px solid #ddd;
            padding: 12px;
            text-align: left;
            transition: background-color 0.3s;
        }
        tr:nth-child(even) {
            background-color: #f8f8f8;
        }
        tr:nth-child(odd) {
            background-color: #ffffff;
        }
        tr:hover {
            background-color: #f8f8f8;
            box-shadow: 0 0 10px rgba(0, 0, 255, 0.2);
        }
        .copyable {
            cursor: pointer;
            transition: color 0.3s;
        }
        .copyable:hover {
            color: black;
        }
        .flash {
            animation: flash 1s;
        }
        @keyframes flash {
            0%, 100% { background-color: inherit; }
            50% { background-color:  #00FF7F; }
        }
        .clickable {
            cursor: pointer;
            color: black;
            transition: color 0.3s;
        }
        .coordinates-table {
            width: 100%;
            border-collapse: collapse;
            display: none;
            margin-top: 10px;
        }
        .coordinates-table th, .coordinates-table td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: center;
        }
        .coordinates-table th {
            background-color: #f2f2f2;
        }
        .button-group {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 10px;
        }
        .button {
            padding: 14px 21px;
            color: white;
            border: none;
            border-radius: 12px;
            cursor: pointer;
            font-size: 16px;
            transition: all 0.6s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: rgba(76, 175, 80, 0.9);
            position: relative;
            overflow: hidden;
        }
        .button:hover {
            background-color: rgba(76, 175, 80, 0.9);
        }
        .button:active {
            transform: translateY(1px);
        }
        .button i {
            margin-right: 8px;
        }
        .button::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: #0FF7F;
            transform: rotate(45deg);
            transition: all 0.3s ease;
            opacity: 0;
        }
        .button:hover::before {
            animation: flashButton 0.6s;
        }
        .button.export {
            background-color: rgba(65, 105, 225, 0.7);
        }
        .button.export:hover {
            background-color: rgba(65, 105, 225, 0.9);
        }
        @keyframes flashButton {
            0% {
                opacity: 0;
                transform: translate(-50%, -50%) rotate(45deg);
            }
            50% {
                opacity: 1;
            }
            100% {
                opacity: 0;
                transform: translate(50%, 50%) rotate(45deg);
            }
        }
        .rights-header {
            cursor: pointer;
            color: black;
        }
        .rights-info {
            cursor: default;
        }
        .right-info {
            cursor: pointer;
        }
        .right-info:hover {
            background-color: #f0f0f0;
        }


        .button#showKPTScheme {
            background-color: #4a69bd;
        }
        .button#showKPTScheme:hover {
            background-color: #1e3799;
        }
        #cadastralNumbersList {
            margin-top: 20px;
            padding: 10px;
            background-color: #f0f0f0;
            border-radius: 5px;
        }

        #cadastralNumbersList div {
            cursor: pointer;
            padding: 10px;
            margin: 5px 0;
            transition: background-color 0.3s;
            border: 1px solid #e0e0e0;
            border-radius: 5px;
        }

        #cadastralNumbersList div:hover {
            background-color: #f0f0f0;
        }

        #cadastralNumbersList div small {
            color: #666;
            display: block;
            margin-top: 5px;
        }

        .sticky-header {
            position: sticky;
            top: 0;
            background-color: white;
            padding: 10px;
            z-index: 1000;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }

        #controlsContainer {
            position: sticky;
            top: 10px;
            background-color: white;
            padding: 10px;
            z-index: 1000;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            margin-bottom: 20px;
        }

        .filter-container {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 10px;
        }


        #filterInput {
            flex-grow: 1;
            padding: 5px;
        }

        #showKPTScheme {
            background-color: #4a69bd;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s;
        }

        #showKPTScheme:hover {
            background-color: #1e3799;
        }

        .button#showKPTScheme {
            background-color: #4a69bd;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s;
            font-size: 16px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 180px; /* Фиксированная ширина для обеих кнопок */
        }


        .button#findOnScheme {
            background-color: #ffa500;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s;
            font-size: 16px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 180px; /* Фиксированная ширина для обеих кнопок */
        }

        .button#showKPTScheme:hover {
            background-color: #1e3799;
        }


        .button#findOnScheme:hover {
            background-color: #942222;
        }

        .button#exportExcel {
            background-color: #1d6f42;
            color: white;
        }

        .button#exportExcel:hover {
            background-color: #15522f;
        }


    </style>
</head>
<body>
<div class="file-input-wrapper">
    <input type="file" id="fileInput" accept=".xml,.zip">
    <label for="fileInput" id="fileInputLabel">Открыть XML КПТ - Земельные участки</label>

</div>



<div style="position: sticky; top: 10px; background-color: white; padding: 10px; z-index: 1000;">
    <div class="sticky-header">



    </div>
    <div id="controlsContainer" style="display: none;">
        <div class="filter-container">
            <input type="text" id="filterInput" placeholder="Фильтр">
            <button id="showKPTScheme" class="button">
                <i class="fas fa-map"></i> Схема КПТ
            </button>
            <button id="findOnScheme" class="button">
                <i class="fas fa-search-location"></i> Найти
            </button>
            <button id="exportExcel" class="button">
                <i class="fas fa-file-excel"></i> Экспорт
            </button>
        </div>
    </div>

    <div id="cadastralNumbersList"></div>
    <div id="output"></div>



    <script>


        function getElementValue(element, tagName) {
            if (!element) return '';
            const parts = tagName.split('>');
            let currentElement = element;
            for (let part of parts) {
                currentElement = currentElement.querySelector(part);
                if (!currentElement) return '';
            }
            return currentElement.textContent.trim();
        }

        function extractCoordinatesFromXML(landRecord) {
            const result = [];
            const contoursLocation = landRecord.querySelector("contours_location");
            if (contoursLocation) {
                const spatialElements = contoursLocation.querySelectorAll("spatial_element");
                spatialElements.forEach((spatialElement, index) => {
                    const contour = [];
                    const ordinates = spatialElement.getElementsByTagName("ordinate");
                    for (let i = 0; i < ordinates.length; i++) {
                        const x = parseFloat(ordinates[i].getElementsByTagName("x")[0].textContent);
                        const y = parseFloat(ordinates[i].getElementsByTagName("y")[0].textContent);
                        const ordNmb = parseInt(ordinates[i].getElementsByTagName("ord_nmb")[0].textContent);
                        const delta = parseFloat(ordinates[i].getElementsByTagName("delta_geopoint")[0]?.textContent) || 0;
                        contour.push({x, y, ordNmb, delta});
                    }
                    result.push(contour);
                });
            }
            return result;
        }

        function drawScheme(contours) {
            const canvas = document.getElementById('schemeCanvas');
            if (!canvas) return;

            const ctx = canvas.getContext('2d');
            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;

            ctx.fillStyle = 'white';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            if (!contours || contours.length === 0) return;

            const allCoords = contours.flat();
            const minX = Math.min(...allCoords.map(p => p.x));
            const minY = Math.min(...allCoords.map(p => p.y));
            const maxX = Math.max(...allCoords.map(p => p.x));
            const maxY = Math.max(...allCoords.map(p => p.y));

            const scaleX = (canvas.width - 60) / (maxY - minY);
            const scaleY = (canvas.height - 60) / (maxX - minX);
            const scale = Math.min(scaleX, scaleY) * 0.9;

            const offsetX = (canvas.width - (maxY - minY) * scale) / 2;
            const offsetY = (canvas.height - (maxX - minX) * scale) / 2;

            const transformCoord = (x, y) => [
                offsetX + (y - minY) * scale,
                canvas.height - (offsetY + (x - minX) * scale)
            ];

            contours.forEach((contour, contourIndex) => {
                ctx.beginPath();
                contour.forEach(({x, y}, index) => {
                    const [canvasX, canvasY] = transformCoord(x, y);
                    if (index === 0) {
                        ctx.moveTo(canvasX, canvasY);
                    } else {
                        ctx.lineTo(canvasX, canvasY);
                    }
                });

                if (isClosedContour(contour)) {
                    ctx.closePath();
                }

                ctx.strokeStyle = contourIndex === 0 ? 'black' : 'red';
                ctx.lineWidth = 1;
                ctx.stroke();

                ctx.fillStyle = contourIndex === 0 ? 'red' : 'red';
                ctx.font = '12px Arial';
                contour.forEach(({x, y, ordNmb}, index) => {
                    if (index === contour.length - 1 && isClosedContour(contour)) return;
                    const [canvasX, canvasY] = transformCoord(x, y);
                    ctx.beginPath();
                    ctx.arc(canvasX, canvasY, 4, 0, 2 * Math.PI);
                    ctx.fill();
                    ctx.fillText(ordNmb, canvasX + 7, canvasY - 7);
                });
            });
        }

        function extractShortAddress(fullAddress) {
            let settlement = fullAddress.match(/\s(с|г|город|д|д\.)\s([А-Яа-я\-]+)/);
            settlement = settlement ? settlement[2] : '';

            let street = fullAddress.match(/\s(ул|ул\.|улица)\s*\.?\s*([А-Яа-я\-]+)/);
            street = street ? street[2] : '';

            let houseNumber = fullAddress.match(/(\d+)(?!.*\d)/);
            houseNumber = houseNumber ? houseNumber[1] : '';

            let shortAddress = [settlement, street, houseNumber].filter(Boolean).join(' ');

            return shortAddress;
        }

function extractData(landRecord) {
    const cadNumber = getElementValue(landRecord, 'object > common_data > cad_number');
    const formattedCadNumber = cadNumber.replace(/:/g, '_');
    const objectType = getElementValue(landRecord, 'object > common_data > type > value');
    const address = getElementValue(landRecord, 'address_location > address > readable_address');
    const shortAddress = extractShortAddress(address);

    const includedObjects = Array.from(landRecord.querySelectorAll('cad_links > included_objects > included_object > cad_number'))
        .map(el => el.textContent);
    const includedObjectsString = includedObjects.join(' ');

    const areaElement = landRecord.querySelector('params > area');
    const areaType = getElementValue(areaElement, 'type > value');
    const areaValues = areaElement.querySelectorAll('value');
    let areaValue = '';
    for (let valueElement of areaValues) {
        const value = valueElement.textContent.trim();
        if (/^\d+(\.\d+)?$/.test(value)) {
            areaValue = value;
            break;
        }
    }
    const areaInaccuracy = getElementValue(areaElement, 'inaccuracy');

    let areaString = '';
    if (areaValue) {
        if (areaInaccuracy && areaInaccuracy !== '') {
            areaString = `${areaValue} +/- ${areaInaccuracy} кв.м.`;
        } else {
            areaString = `${areaValue} кв.м.`;
        }
    }

    let displayAreaType = areaType || 'Площадь';

    const permittedUse = getElementValue(landRecord, 'params > permitted_use > permitted_use_established > by_document');

    const cadastralValue = getElementValue(landRecord, 'cost > value');
    const formattedCadastralValue = cadastralValue ? parseFloat(cadastralValue).toLocaleString('ru-RU', { minimumFractionDigits: 2, maximumFractionDigits: 2 }) + ' руб.' : 'Нет данных';

    const contours = extractCoordinatesFromXML(landRecord);

    let mainContourIndex = 1;
    let innerContourIndex = 1;

    const coordinatesString = `
    <div class="button-group">
       <button class="button" id="toggleCoordinates"><i class="fas fa-eye"></i></button>
       <button class="button" id="copyCoordinates"><i class="fas fa-copy"></i></button>
       <button class="button secondary" id="exportDXF">DXF</button>
       <button class="button secondary" id="exportMIF">MIF</button>
       <button class="button secondary" id="exportCSV">CSV</button>
   <button class="button" id="showKPTScheme" style="display: none;">Схема КПТ</button>
    </div>
    <canvas id="schemeCanvas" style="width: 100%; height: 400px; border: 1px solid #007bff; border-radius: 10px; margin-top: 10px;"></canvas>
    <table class="coordinates-table" style="display: none;">
        <tr>
            <th>Контур</th>
            <th>№ точки</th>
            <th>Координата X</th>
            <th>Координата Y</th>
            <th>Погрешность</th>
        </tr>
        ${contours.map((contour, contourIndex) => {
                let contourName;
                if (contourIndex === 0) {
                    contourName = `${mainContourIndex}`;
                    mainContourIndex++;
                } else if (isContourInside(contour, contours[0])) {
                    contourName = `${mainContourIndex - 1}.${innerContourIndex}`;
                    innerContourIndex++;
                } else {
                    contourName = `${mainContourIndex}`;
                    mainContourIndex++;
                    innerContourIndex = 1;
                }

                const isClosed = isClosedContour(contour);

                return contour.map((coord, pointIndex) => {
                    let pointNumber = coord.ordNmb;
                    if (isClosed && pointIndex === contour.length - 1) {
                        pointNumber = contour[0].ordNmb;
                    }
                    return `
                    <tr>
                        <td>${contourName}</td>
                        <td>${pointNumber}</td>
                        <td>${coord.x.toFixed(2)}</td>
                        <td>${coord.y.toFixed(2)}</td>
                        <td>${coord.delta.toFixed(2)}</td>
                    </tr>
                `;
                }).join('');
            }).join('')}
    </table>
`;

    const result = `
        <table>
            <tr><td class="clickable" onclick="copyToClipboard('${cadNumber}'); window.open('map.html', '_blank')">Кадастровый номер</td><td><span class="copyable">${cadNumber}</span></td></tr>
            <tr><td>Тип объекта</td><td><span class="copyable">${objectType}</span></td></tr>
            <tr><td class="clickable" onclick="window.open('https://yandex.ru/maps/?text=${encodeURIComponent(shortAddress)}', '_blank')">Адрес</td><td><span class="copyable">${address}</span></td></tr>
            <tr><td class="clickable" onclick="copyToClipboard('${includedObjectsString}'); window.open('map.html', '_blank')">ОКС</td><td><span class="copyable">${includedObjectsString}</span></td></tr>
            <tr><td>${displayAreaType}</td><td><span class="copyable">${areaString}</span></td></tr>
            <tr><td>Вид разрешенного использования</td><td><span class="copyable">${permittedUse}</span></td></tr>
            <tr><td>Кадастровая стоимость</td><td><span class="copyable">${formattedCadastralValue}</span></td></tr>
            <tr><td>Координаты</td><td>${coordinatesString}</td></tr>
        </table>`;

    return { html: result, contours: contours };
}




        function isContourInside(innerContour, outerContour) {
            return innerContour.some(point => isPointInside(point, outerContour));
        }

        function isPointInside(point, polygon) {
            let inside = false;
            for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
                const xi = polygon[i].x, yi = polygon[i].y;
                const xj = polygon[j].x, yj = polygon[j].y;

                const intersect = ((yi > point.y) !== (yj > point.y))
                    && (point.x < (xj - xi) * (point.y - yi) / (yj - yi) + xi);
                if (intersect) inside = !inside;
            }
            return inside;
        }






        function extractCadastralNumbers(xmlContent) {
            const parser = new DOMParser();
            const xmlDoc = parser.parseFromString(xmlContent, "text/xml");
            const landRecords = xmlDoc.querySelectorAll('land_record');
            allContours = [];

            landRecords.forEach(record => {
                const cadNumber = record.querySelector('cad_number');
                const address = record.querySelector('address_location > address > readable_address');
                const area = record.querySelector('params > area');
                const permittedUse = record.querySelector('params > permitted_use > permitted_use_established > by_document');

                if (cadNumber && address && area) {
                    const areaValue = area.querySelector('value')?.textContent;
                    const inaccuracy = area.querySelector('inaccuracy')?.textContent;
                    let areaString = '';

                    if (areaValue) {
                        if (inaccuracy) {
                            areaString = `Уточненная площадь: ${areaValue} +/- ${inaccuracy}`;
                        } else {
                            areaString = `Декларированная площадь: ${areaValue}`;
                        }
                    }

                    const permittedUseString = permittedUse ? permittedUse.textContent : '';

                    allContours.push({
                        number: cadNumber.textContent,
                        address: address.textContent,
                        area: areaString,
                        permittedUse: `Вид разрешенного использования: ${permittedUseString}`
                    });
                }
            });


            return allContours;
        }


        function displayCadastralNumbers(data) {
            const listContainer = document.getElementById('cadastralNumbersList');
            const filterInput = document.getElementById('filterInput');

            function renderList(filter = '') {
                listContainer.innerHTML = '';

                const useAddressOnly = filter.includes(' ');
                const filterTerms = filter.toLowerCase().split(' ').filter(term => term.length > 0);

                data.forEach(item => {
                    let matchesFilter;

                    if (useAddressOnly) {
                        const addressLower = item.address.toLowerCase();
                        matchesFilter = filterTerms.every(term => addressLower.includes(term));
                    } else {
                        const fullText = (item.number + ' ' + item.address + ' ' + item.area + ' ' + item.permittedUse).toLowerCase();
                        matchesFilter = fullText.includes(filter.toLowerCase());
                    }

                    if (matchesFilter) {
                        const div = document.createElement('div');
                        let contoursInfo = '';
                        if (item.contoursCount > 1) {
                            contoursInfo = `<span style="color: #ff6600; font-weight: bold;"> (${item.contoursCount})</span>`;
                        }
                        div.innerHTML = `
                    <strong>${item.number}</strong>${contoursInfo}<br>
                    <small>${item.address}</small><br>
                    <small>${item.area}</small><br>
                    <small>${item.permittedUse}</small>
                `;
                        div.addEventListener('dblclick', () => {
                           displayLandRecordInfo(item.number);
                            setTimeout(() => {
                                window.scrollTo(0, document.body.scrollHeight);
                            }, 100);
                        });
                        listContainer.appendChild(div);
                    }
                });
            }

            filterInput.addEventListener('input', (e) => {
                renderList(e.target.value);
            });

            renderList();
        }

        let selectedCadastralNumber = null;

        function displayLandRecordInfo(cadastralNumber) {
            selectedCadastralNumber = cadastralNumber;
            const parser = new DOMParser();
            const xmlDoc = parser.parseFromString(window.xmlContent, "text/xml");
            const landRecord = Array.from(xmlDoc.querySelectorAll('land_record')).find(record =>
                record.querySelector('cad_number').textContent === cadastralNumber
            );

            if (landRecord) {
                const { html, contours } = extractData(landRecord);
                document.getElementById('output').innerHTML = html;

                setTimeout(() => {
                    drawScheme(contours);
                }, 0);

                const copyables = document.querySelectorAll('.copyable, .rights-header, .right-info');
                copyables.forEach(el => {
                    el.addEventListener('click', copyHandler);
                });

                const toggleCoordinatesButton = document.getElementById('toggleCoordinates');
                if (toggleCoordinatesButton) {
                    toggleCoordinatesButton.addEventListener('click', toggleCoordinates);
                }

                const copyCoordinatesButton = document.getElementById('copyCoordinates');
                if (copyCoordinatesButton) {
                    copyCoordinatesButton.addEventListener('click', () => copyCoordinates(contours));
                }

                const exportDXFButton = document.getElementById('exportDXF');
                if (exportDXFButton) {
                    exportDXFButton.addEventListener('click', () => generateAndDownloadDXF(contours));
                }

                const exportMIFButton = document.getElementById('exportMIF');
                if (exportMIFButton) {
                    exportMIFButton.addEventListener('click', () => generateAndDownloadMIF(contours));
                }

                const exportCSVButton = document.getElementById('exportCSV');
                if (exportCSVButton) {
                    exportCSVButton.addEventListener('click', () => generateAndDownloadCSV(contours));
                }
            }
        }




        function exportToExcel() {
            if (allContours.length === 0) {
                alert("Нет данных для экспорта. Пожалуйста, загрузите XML файл сначала.");
                return;
            }

            const exportData = allContours.map(parcel => {
                const cadastralInfo = cadastralData.find(item => item.number === parcel.cadastralNumber);
                return {
                    ...parcel,
                    ...cadastralInfo
                };
            });

            function escapeCSV(str) {
                if (str === undefined || str === null) return '';
                return String(str).replace(/"/g, '""').replace(/\n/g, ' ');
            }

            function extractAreaInfo(areaElement) {
                if (!areaElement) return { type: '', value: '', inaccuracy: '' };

                // Если area - это простое число или строка
                if (typeof areaElement === 'string' || typeof areaElement === 'number') {
                    return { type: 'Декларированная площадь', value: areaElement.toString(), inaccuracy: '' };
                }

                // Если area - это объект с более сложной структурой
                const areaType = areaElement.querySelector('type > value')?.textContent || 'Декларированная площадь';
                let areaValue = '';
                let areaInaccuracy = '';

                // Пробуем найти значение площади
                const valueElements = areaElement.querySelectorAll('value');
                for (let valueElement of valueElements) {
                    const value = valueElement.textContent.trim();
                    if (/^\d+(\.\d+)?$/.test(value)) {
                        areaValue = value;
                        break;
                    }
                }

                // Если значение не найдено в <value>, ищем непосредственно в теге <area>
                if (!areaValue) {
                    areaValue = areaElement.textContent.trim();
                }

                const inaccuracyElement = areaElement.querySelector('inaccuracy');
                if (inaccuracyElement) {
                    areaInaccuracy = inaccuracyElement.textContent.trim();
                }

                return { type: areaType, value: areaValue, inaccuracy: areaInaccuracy };
            }

            let csvContent = "Кадастровый номер;Адрес;Тип площади;Площадь;Погрешность;Вид разрешенного использования;Количество контуров\n";
            exportData.forEach(parcel => {
                const areaInfo = extractAreaInfo(parcel.area);
                const row = [
                    escapeCSV(parcel.cadastralNumber),
                    escapeCSV(parcel.address),
                    escapeCSV(areaInfo.type),
                    escapeCSV(areaInfo.value), // Теперь здесь будет только значение площади
                    escapeCSV(areaInfo.inaccuracy || ''),
                    escapeCSV(parcel.permittedUse?.replace('Вид разрешенного использования: ', '') || ''),
                    parcel.contours?.length || ''
                ];
                csvContent += row.join(';') + "\n";
            });

            function downloadCSV(content, filename) {
                const blob = new Blob(["\ufeff" + content], { type: 'text/csv;charset=utf-8;' });
                const link = document.createElement("a");
                if (link.download !== undefined) {
                    const url = URL.createObjectURL(blob);
                    link.setAttribute("href", url);
                    link.setAttribute("download", filename);
                    
 link.style.visibility = 'hidden';
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);
                }
            }

            downloadCSV(csvContent, 'cadastral_data.csv');
        }



        function copyHandler(event) {
            const element = event.target;
            let textToCopy = '';

            if (element.classList.contains('rights-header')) {
                textToCopy = element.nextElementSibling.textContent;
            } else




            if (element.classList.contains('right-info') || element.closest('.right-info')) {
                const rightInfo = element.classList.contains('right-info') ? element.textContent : element.closest('.right-info').textContent;
                const match = rightInfo.match(/^([А-Яа-я\s]+)(?:\s\d{2}\.\d{2}\.\d{4}|\s[А-Яа-я]+)/);
                if (match) {
                    textToCopy = match[1].trim();
                } else {
                    textToCopy = rightInfo.split(/\s\d{2}\.\d{2}\.\d{4}|\s(?:Собственность|Аренда)/)[0].trim();
                }
            } else if (element.classList.contains('copyable')) {
                textToCopy = element.textContent;
            } else {
                return;
            }

            if (textToCopy) {
                copyToClipboard(textToCopy, element.closest('tr'));
            }
        }

        function copyToClipboard(text, element) {
            navigator.clipboard.writeText(text).then(() => {
                element.classList.add('flash');
                setTimeout(() => {
                    element.classList.remove('flash');
                }, 1000);
            }).catch(err => {
                console.error('Ошибка при копировании: ', err);
            });
        }

        function copyCoordinates(contours) {
            const textToCopy = contours.map(contour =>
                contour.map(coord => `${coord.x.toFixed(2)}\t${coord.y.toFixed(2)}`).join('\n')
            ).join('\n\n');

            navigator.clipboard.writeText(textToCopy).then(() => {
                const copyButton = document.getElementById('copyCoordinates');
                copyButton.classList.add('flash');
                setTimeout(() => {
                    copyButton.classList.remove('flash');
                }, 1000);
            }).catch(err => {
                console.error('Ошибка при копировании: ', err);
            });
        }

        function toggleCoordinates() {
            const table = document.querySelector('.coordinates-table');
            if (table.style.display === "none" || table.style.display === "") {
                table.style.display = "table";
            } else {
                table.style.display = "none";
            }
        }

        function generateDXF(contours) {
            let dxfContent = `0\nSECTION\n2\nHEADER\n0\nENDSEC\n`;
            dxfContent += `0\nSECTION\n2\nTABLES\n0\nENDSEC\n`;
            dxfContent += `0\nSECTION\n2\nBLOCKS\n0\nENDSEC\n`;
            dxfContent += `0\nSECTION\n2\nENTITIES\n`;

            contours.forEach((contour, contourIndex) => {
                const isClosed = isClosedContour(contour);
                const pointsToProcess = isClosed ? contour.length - 1 : contour.length;

                dxfContent += `0\nLWPOLYLINE\n8\n${contourIndex}\n70\n${isClosed ? 1 : 0}\n`;
                dxfContent += `90\n${pointsToProcess}\n`;

                for (let i = 0; i < pointsToProcess; i++) {
                    dxfContent += `10\n${contour[i].y.toFixed(2)}\n20\n${contour[i].x.toFixed(2)}\n`;
                }
            });

            dxfContent += `0\nENDSEC\n0\nSECTION\n2\nOBJECTS\n0\nENDSEC\n0\nEOF\n`;
            return dxfContent;
        }

        function isClosedContour(contour) {
            if (contour.length < 3) return false;
            const firstPoint = contour[0];
            const lastPoint = contour[contour.length - 1];
            return Math.abs(firstPoint.x - lastPoint.x) < 0.001 &&
                Math.abs(firstPoint.y - lastPoint.y) < 0.001;
        }

        function generateMIF(contours) {

            const allPoints = contours.flat();
            const minX = Math.min(...allPoints.map(p => p.x));
            const minY = Math.min(...allPoints.map(p => p.y));
            const maxX = Math.max(...allPoints.map(p => p.x));
            const maxY = Math.max(...allPoints.map(p => p.y));

            let mifContent = `Version 300
Charset "WindowsCyrillic"
Delimiter ";"
CoordSys Nonearth Units "m" Bounds 
(${minY.toFixed(2)}, ${minX.toFixed(2)}) (${maxY.toFixed(2)}, ${maxX.toFixed(2)})
Columns 7
LayerName Char(32)
LayerNumber Integer
ObjectName Char(32)
ObjectCode Integer
ObjectNumber Integer
ObjectLocal Integer
ObjectKey Char(32)
Data
`;

            contours.forEach((contour, index) => {
                mifContent += `Pline ${contour.length}\n`;
                contour.forEach(point => {
                    mifContent += `${point.y.toFixed(3)} ${point.x.toFixed(3)}\n`;
                });
                mifContent += `Pen (1,2,16733695)\n`;
                if (index < contours.length - 1) {
                    mifContent += '\n';
                }
            });

            return mifContent;
        }

        function generateAndDownloadMIF(contours) {
            const mifContent = generateMIF(contours);
            const blob = new Blob([mifContent], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'output.mif';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
        }

        function generateCSV(contours) {
            let csvContent = "Контур;Префикс номера;Номер;Старый X;Старый Y;Новый X;Новый Y;Метод определения;Формула;Радиус;Погрешность;Описание закрепления\n";
            csvContent += ";;;;;;;;;;;\n";

            let mainContourIndex = 1;
            let innerContourIndex = 1;

            contours.forEach((contour, contourIndex) => {
                if (contourIndex > 0) {
                    csvContent += ";;;;;;;;;;;\n";
                }

                let contourName;
                let isInner = false;
                if (contourIndex === 0) {
                    contourName = `${mainContourIndex}`;
                    mainContourIndex++;
                } else if (isContourInside(contour, contours[0])) {
                    contourName = `${mainContourIndex - 1}.${innerContourIndex}`;
                    innerContourIndex++;
                    isInner = true;
                } else {
                    contourName = `${mainContourIndex}`;
                    mainContourIndex++;
                    innerContourIndex = 1;
                }

                const isClosed = isClosedContour(contour);

                contour.forEach((point, index) => {
                    let pointNumber = index + 1;
                    let prefix = isInner ? '' : 'н';

                    if (isClosed && index === contour.length - 1) {
                        pointNumber = 1;
                    }

                    csvContent += `[${contourName}];${prefix};${pointNumber};;;${point.x.toFixed(2)};${point.y.toFixed(2)};;;;${point.delta.toFixed(2)};Долговременный межевой знак\n`;
                });
            });

            return csvContent;
        }

        function generateAndDownloadDXF(contours) {
            const dxfContent = generateDXF(contours);
            const blob = new Blob([dxfContent], { type: 'application/dxf' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'output.dxf';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
        }


        function generateAndDownloadCSV(contours) {
            const csvContent = generateCSV(contours);

            const bom = '\uFEFF';
            const csvWithBom = bom + csvContent;

            const blob = new Blob([csvWithBom], { type: 'text/csv;charset=utf-8;' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'output.csv';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
        }

        document.getElementById('fileInput').addEventListener('change', function(event) {
            const file = event.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = function(e) {
                    const fileContent = e.target.result;
                    if (file.name.endsWith('.xml')) {
                        processXMLContent(fileContent, file.name);
                    } else if (file.name.endsWith('.zip')) {
                        processZipFile(fileContent);
                    } else {
                        alert('Пожалуйста, выберите файл XML или ZIP.');
                    }
                };
                if (file.name.endsWith('.xml')) {
                    reader.readAsText(file);
                } else if (file.name.endsWith('.zip')) {
                    reader.readAsArrayBuffer(file);
                }
            }
        });

        function isPointInPolygon(point, polygon) {
            let inside = false;
            for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
                const xi = polygon[i].x, yi = polygon[i].y;
                const xj = polygon[j].x, yj = polygon[j].y;

                // Проверяем, лежит ли точка на границе
                if ((Math.abs(xi - point.x) < 1e-8 && Math.abs(yi - point.y) < 1e-8) ||
                    (Math.abs(xj - point.x) < 1e-8 && Math.abs(yj - point.y) < 1e-8)) {
                    return true; // Точка лежит на вершине полигона
                }

                // Проверяем, лежит ли точка на ребре
                if (Math.abs(yi - yj) < 1e-8) { // горизонтальное ребро
                    if (Math.abs(point.y - yi) < 1e-8 &&
                        point.x > Math.min(xi, xj) &&
                        point.x < Math.max(xi, xj)) {
                        return true; // Точка лежит на горизонтальном ребре
                    }
                } else { // наклонное или вертикальное ребро
                    const slope = (xj - xi) / (yj - yi);
                    const x = xi + (point.y - yi) * slope;
                    if (Math.abs(point.x - x) < 1e-8 &&
                        point.y >= Math.min(yi, yj) &&
                        point.y <= Math.max(yi, yj)) {
                        return true; // Точка лежит на наклонном или вертикальном ребре
                    }
                }

                // Проверка пересечения луча с ребром (алгоритм ray-casting)
                const intersect = ((yi > point.y) !== (yj > point.y))
                    && (point.x < (xj - xi) * (point.y - yi) / (yj - yi) + xi);
                if (intersect) inside = !inside;
            }
            return inside;
        }


        function processXMLContent(xmlContent, fileName) {
            window.cadastralData = extractCadastralNumbers(xmlContent);
            window.xmlContent = xmlContent;
            cadastralData = extractCadastralNumbers(xmlContent);
            extractAllContours(xmlContent);

            const label = document.getElementById('fileInputLabel');
            if (label) {
                label.textContent = fileName;
            }

            // Извлечение и отображение информации о документе
            const parser = new DOMParser();
            const xmlDoc = parser.parseFromString(xmlContent, "text/xml");
            const registrationNumber = xmlDoc.querySelector('registration_number')?.textContent;
            const dateFormation = xmlDoc.querySelector('date_formation')?.textContent;

            if (registrationNumber && dateFormation) {
                const formattedDate = formatDate(dateFormation);
                const documentInfo = `${registrationNumber} от ${formattedDate}`;
                let documentInfoElement = document.getElementById('documentInfo');

                if (!documentInfoElement) {
                    documentInfoElement = document.createElement('div');
                    documentInfoElement.id = 'documentInfo';
                    documentInfoElement.className = 'document-info';
                    const fileInputWrapper = document.querySelector('.file-input-wrapper');
                    if (fileInputWrapper) {
                        fileInputWrapper.appendChild(documentInfoElement);
                    } else {
                        console.warn("Элемент '.file-input-wrapper' не найден");
                    }
                }

                documentInfoElement.textContent = documentInfo;
                documentInfoElement.style.display = 'block';

                documentInfoElement.addEventListener('click', function() {
                    copyToClipboard(documentInfo);
                    showCopiedNotification(documentInfoElement);
                });
            }

            // Показываем контейнер с элементами управления
            document.getElementById('controlsContainer').style.display = 'block';

            // Отображаем список кадастровых номеров
            displayCadastralNumbers(cadastralData);

            // Настраиваем обработчики событий для кнопок
            const showKPTSchemeButton = document.getElementById('showKPTScheme');
            if (showKPTSchemeButton) {
                showKPTSchemeButton.addEventListener('click', () => showKPTScheme(false));
            } else {
                console.warn("Кнопка 'Схема КПТ' не найдена");
            }

            const findOnSchemeButton = document.getElementById('findOnScheme');
            if (findOnSchemeButton) {
                findOnSchemeButton.addEventListener('click', findObjectOnScheme);
            } else {
                console.warn("Кнопка 'Найти' не найдена");
            }
        }

        let allContours = [];

        let scale = 1;
        let offsetX = 0;
        let offsetY = 0;
        let isDragging = false;
        let startX, startY;

        function showKPTScheme(showObject = false) {
            const container = document.getElementById('kptSchemeContainer');
            const canvas = document.getElementById('kptSchemeCanvas');
            if (!container || !canvas) {
                console.error('Элементы схемы КПТ не найдены');
                return;
            }
            container.style.display = 'block';

            const ctx = canvas.getContext('2d');
            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;

            let offsetX = 0, offsetY = 0, scale = 1;
            let isDragging = false, startX, startY;
            let clickableArea = null;

            function draw() {
                ctx.setTransform(1, 0, 0, 1, 0, 0);
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.translate(offsetX, offsetY);
                ctx.scale(scale, scale);
               
                clickableArea = drawKPTScheme(ctx, canvas.width, canvas.height, showObject, scale);
            }

            function handleMouseDown(e) {
                isDragging = true;
                startX = e.clientX - offsetX;
                startY = e.clientY - offsetY;
                canvas.style.cursor = 'grabbing';
            }

            function handleMouseMove(e) {
                if (!isDragging) return;
                offsetX = e.clientX - startX;
                offsetY = e.clientY - startY;
                draw();
            }

            function handleMouseUp() {
                isDragging = false;
                canvas.style.cursor = 'grab';
            }

            function handleWheel(e) {
                e.preventDefault();
                const wheel = e.deltaY < 0 ? 1 : -1;
                const zoom = Math.exp(wheel * 0.1);

                const rect = canvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;

                const newScale = scale * zoom;
                offsetX = mouseX - (mouseX - offsetX) * (newScale / scale);
                offsetY = mouseY - (mouseY - offsetY) * (newScale / scale);
                scale = newScale;

                draw();
            }

            function handleClick(event) {
                const rect = canvas.getBoundingClientRect();
                const x = (event.clientX - rect.left - offsetX) / scale;
                const y = (event.clientY - rect.top - offsetY) / scale;

                if (clickableArea &&
                    x >= clickableArea.x && x <= clickableArea.x + clickableArea.width &&
                    y >= clickableArea.y && y <= clickableArea.y + clickableArea.height) {
                    const containingParcels = findContainingParcels(objectCoordinates);
                    if (containingParcels.length > 0) {
                        downloadCadastralNumbers(containingParcels);
                    } else {
                        console.log('Нет участков для скачивания');
                    }
                }


            }
          function handleDoubleClick(event) {
                const rect = canvas.getBoundingClientRect();
                const x = (event.clientX - rect.left - offsetX) / scale;
                const y = (event.clientY - rect.top - offsetY) / scale;

                const clickedParcel = findClickedParcel(x, y);
                if (clickedParcel) {
                    console.log('Клик по участку:', clickedParcel.cadastralNumber);
                    displayLandRecordInfo(clickedParcel.cadastralNumber);
                    
                    draw();
                }
            }

           function findClickedParcel(clickX, clickY) {
                const allCoords = allContours.flatMap(parcel => parcel.contours.flat());
                const minX = Math.min(...allCoords.map(p => p.x));
                const minY = Math.min(...allCoords.map(p => p.y));
                const maxX = Math.max(...allCoords.map(p => p.x));
                const maxY = Math.max(...allCoords.map(p => p.y));

                const dataWidth = maxY - minY;
                const dataHeight = maxX - minX;

                const scaleX = canvas.width / dataWidth;
                const scaleY = canvas.height / dataHeight;
                const mapScale = Math.min(scaleX, scaleY) * 0.9;

                const scaledWidth = dataWidth * scale;
                const scaledHeight = dataHeight * scale;

                const offsetX = (canvas.width - scaledWidth) / 2;
                const offsetY = (canvas.height - scaledHeight) / 2;

                const transformCoord = (x, y) => [
                    offsetX + (y - minY) * scale,
                    canvas.height - (offsetY + (x - minX) * scale)
                ];

                for (const parcel of allContours) {
                    for (const contour of parcel.contours) {
                        let polygonPoints = contour.map(coord => {
                            const [canvasX, canvasY] = transformCoord(coord.x, coord.y);
                            return { x: canvasX, y: canvasY };
                        });


                        if (isPointInPolygon({ x: clickX, y: clickY }, polygonPoints)) {

                            return parcel;

                        }

                    }
                }
                return null;
            }



            // Удаляем старые обработчики событий
            canvas.removeEventListener('mousedown', handleMouseDown);
            canvas.removeEventListener('mousemove', handleMouseMove);
            canvas.removeEventListener('mouseup', handleMouseUp);
            canvas.removeEventListener('mouseleave', handleMouseUp);
            canvas.removeEventListener('wheel', handleWheel);
            canvas.removeEventListener('click', handleClick);
             canvas.removeEventListener('dblclick', handleDoubleClick);

            // Добавляем новые обработчики событий
            canvas.addEventListener('mousedown', handleMouseDown);
            canvas.addEventListener('mousemove', handleMouseMove);
            canvas.addEventListener('mouseup', handleMouseUp);
            canvas.addEventListener('mouseleave', handleMouseUp);
            canvas.addEventListener('wheel', handleWheel);
            canvas.addEventListener('click', handleClick);
            canvas.addEventListener('dblclick', handleDoubleClick);


            canvas.style.cursor = 'grab';

            draw();

            const closeButton = document.getElementById('closeKPTScheme') || document.createElement('button');
            closeButton.id = 'closeKPTScheme';
            closeButton.textContent = 'Закрыть';
            closeButton.style.position = 'absolute';
            closeButton.style.top = '10px';
            closeButton.style.right = '10px';
            closeButton.style.zIndex = '1001';
            container.appendChild(closeButton);

            closeButton.onclick = function() {
                container.style.display = 'none';
                objectCoordinates = null;
                canvas.removeEventListener('mousedown', handleMouseDown);
                canvas.removeEventListener('mousemove', handleMouseMove);
                canvas.removeEventListener('mouseup', handleMouseUp);
                canvas.removeEventListener('mouseleave', handleMouseUp);
                canvas.removeEventListener('wheel', handleWheel);
                canvas.removeEventListener('click', handleClick);
                canvas.removeEventListener('dblclick', handleDoubleClick);
            };
        }

        function drawKPTScheme(ctx, width, height, showObject, scale) {
            if (allContours.length === 0) return;

            const allCoords = allContours.flatMap(parcel => parcel.contours.flat());
            const minX = Math.min(...allCoords.map(p => p.x));
            const minY = Math.min(...allCoords.map(p => p.y));
            const maxX = Math.max(...allCoords.map(p => p.x));
            const maxY = Math.max(...allCoords.map(p => p.y));

            const dataWidth = maxY - minY;
            const dataHeight = maxX - minX;

            const scaleX = width / dataWidth;
            const scaleY = height / dataHeight;
            const mapScale = Math.min(scaleX, scaleY) * 0.9;

            const scaledWidth = dataWidth * scale;
            const scaledHeight = dataHeight * scale;

            const offsetX = (width - scaledWidth) / 2;
            const offsetY = (height - scaledHeight) / 2;

            const transformCoord = (x, y) => [
                offsetX + (y - minY) * scale,
                height - (offsetY + (x - minX) * scale)
            ];

            ctx.clearRect(0, 0, width, height);

            // Отрисовка всех участков
            allContours.forEach((parcel, parcelIndex) => {
                ctx.beginPath();
                parcel.contours.forEach((contour, contourIndex) => {
                    contour.forEach(({x, y}, pointIndex) => {
                        const [canvasX, canvasY] = transformCoord(x, y);
                        if (pointIndex === 0) {
                            ctx.moveTo(canvasX, canvasY);
                        } else {
                            ctx.lineTo(canvasX, canvasY);
                        }
                    });
                    if (isClosedContour(contour)) {
                        ctx.closePath();
                    }
                });
                ctx.strokeStyle = `hsl(${(parcelIndex * 137) % 360}, 50%, 50%)`;
                ctx.lineWidth = 0.5 / scale;
                ctx.stroke();
            });

            // Отрисовка выбранного участка
            if (selectedCadastralNumber) {
                const selectedParcel = allContours.find(parcel => parcel.cadastralNumber === selectedCadastralNumber);
                if (selectedParcel) {
                    ctx.beginPath();
                    selectedParcel.contours.forEach((contour, contourIndex) => {
                        contour.forEach(({x, y}, pointIndex) => {
                            const [canvasX, canvasY] = transformCoord(x, y);
                            if (pointIndex === 0) {
                                ctx.moveTo(canvasX, canvasY);
                            } else {
                                ctx.lineTo(canvasX, canvasY);
                            }
                        });
                        if (isClosedContour(contour)) {
                            ctx.closePath();
                        }
                    });
                    ctx.strokeStyle = 'white';
                    ctx.lineWidth = 3 / scale;
                    ctx.stroke();
                }
            }

            // Отрисовка выделенных участков, содержащих объект
            let containingParcels = [];
            if (showObject && objectCoordinates && objectCoordinates.length > 0) {
                containingParcels = findContainingParcels(objectCoordinates);
                containingParcels.forEach(parcel => {
                    ctx.beginPath();
                    parcel.contours.forEach((contour, contourIndex) => {
                        contour.forEach(({x, y}, pointIndex) => {
                            const [canvasX, canvasY] = transformCoord(x, y);
                            if (pointIndex === 0) {
                                ctx.moveTo(canvasX, canvasY);
                            } else {
                                ctx.lineTo(canvasX, canvasY);
                            }
                        });
                        if (isClosedContour(contour)) {
                            ctx.closePath();
                        }
                    });
                    ctx.strokeStyle = 'yellow';
                    ctx.lineWidth = 2 / scale;
                    ctx.stroke();
                });

                // Отрисовка объекта (точки или линии)
                if (showObject && objectCoordinates.length > 0) {
                    objectCoordinates.forEach(lineGroup => {
                        ctx.beginPath();
                        lineGroup.forEach(({x, y}, index) => {
                            const [objX, objY] = transformCoord(x, y);
                            if (index === 0) {
                                ctx.moveTo(objX, objY);
                            } else {
                                ctx.lineTo(objX, objY);
                            }
                        });
                        ctx.strokeStyle = 'red';
                        ctx.lineWidth = 2 / scale;
                        ctx.stroke();

                        // Отрисовка точек объекта
                        lineGroup.forEach(({x, y}) => {
                            const [objX, objY] = transformCoord(x, y);
                            const baseRadius = 3;
                            const maxRadius = 10;
                            const radius = Math.min(baseRadius / scale, maxRadius);

                            ctx.beginPath();
                            ctx.arc(objX, objY, radius, 0, 2 * Math.PI);
                            ctx.fillStyle = 'red';
                            ctx.fill();
                            ctx.strokeStyle = 'black';
                            ctx.lineWidth = 1 / scale;
                            ctx.stroke();

                            ctx.beginPath();
                            ctx.arc(objX, objY, radius + 1 / scale, 0, 2 * Math.PI);
                            ctx.strokeStyle = 'white';
                            ctx.lineWidth = 1 / scale;
                            ctx.stroke();
                        });
                    });
                }
            }

            let clickableArea = null;

            // Вывод информации о номерах земельных участков
            ctx.fillStyle = 'white';
            ctx.font = `${14 / scale}px Arial`;
            ctx.textAlign = 'left';
            ctx.textBaseline = 'top';

            let infoText = '';
            if (selectedCadastralNumber) {
                infoText = `Выбранный участок: ${selectedCadastralNumber}`;
            }
            if (showObject && containingParcels.length > 0) {
                infoText += infoText ? '\n' : '';
                infoText += `Объект на участках:\n${containingParcels.map(p => p.cadastralNumber).join('\n')}`;
            }

            if (infoText) {
                const lines = infoText.split('\n');
                const lineHeight = 18 / scale;
                const padding = 5 / scale;
                const textWidth = Math.max(...lines.map(line => ctx.measureText(line).width));
                const textHeight = lines.length * lineHeight;

                ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                ctx.fillRect(10 / scale, 10 / scale, textWidth + padding * 2, textHeight + padding * 2);

                ctx.fillStyle = 'white';
                lines.forEach((line, index) => {
                    ctx.fillText(line, (10 + padding) / scale, (10 + padding + index * lineHeight) / scale);
                });

                clickableArea = {
                    x: 10 / scale,
                    y: 10 / scale,
                    width: (textWidth + padding * 2),
                    height: (textHeight + padding * 2)
                };
            }

            return clickableArea;
        }

        function getCadastralNumberByIndex(index) {
            const parser = new DOMParser();
            const xmlDoc = parser.parseFromString(window.xmlContent, "text/xml");
            const landRecords = xmlDoc.querySelectorAll('land_record');
            if (index >= 0 && index < landRecords.length) {
                return landRecords[index].querySelector('cad_number').textContent;
            }
            return null;
        }

        function extractAllContours(xmlContent) {
            const parser = new DOMParser();
            const xmlDoc = parser.parseFromString(xmlContent, "text/xml");
            const landRecords = xmlDoc.querySelectorAll('land_record');

            allContours = Array.from(landRecords).map(record => ({
                cadastralNumber: record.querySelector('cad_number').textContent,
                contours: extractCoordinatesFromXML(record)
            }));
        }

        function processZipFile(zipContent) {
            JSZip.loadAsync(zipContent).then(function(zip) {
                let xmlFile = null;
                zip.forEach(function(relativePath, zipEntry) {
                    if (relativePath.endsWith('.xml')) {
                        xmlFile = zipEntry;
                    }
                });

                if (xmlFile) {
                    xmlFile.async('string').then(function(xmlContent) {
                        processXMLContent(xmlContent, xmlFile.name);
                    });
                } else {
                    alert('XML-файл не найден в архиве ZIP.');
                }
            }).catch(function(error) {
                console.error('Ошибка при обработке ZIP-файла:', error);
                alert('Ошибка при обработке ZIP-файла.');
            });
        }


        document.getElementById('findOnScheme').addEventListener('click', findObjectOnScheme);

        let objectCoordinates = [];

        function findObjectOnScheme() {
            const dialog = document.createElement('div');
            dialog.innerHTML = `
        <div style="background: white; padding: 20px; border-radius: 10px; max-width: 400px; margin: 50px auto;">
            <h3>Введите координаты объекта</h3>
            <p>Введите координаты в формате "X Y" для одной точки или несколько строк координат для линейного объекта. Используйте пустую строку для разделения нескольких объектов:</p>
            <textarea id="coordinatesInput" rows="5" style="width: 100%; margin-bottom: 10px;"></textarea>
            <button id="submitCoordinates">Найти</button>
            <button id="cancelCoordinates">Отмена</button>
        </div>
    `;
            dialog.style.position = 'fixed';
            dialog.style.top = '0';
            dialog.style.left = '0';
            dialog.style.width = '100%';
            dialog.style.height = '100%';
            dialog.style.background = 'rgba(0,0,0,0.5)';
            dialog.style.zIndex = '1000';
            document.body.appendChild(dialog);

            document.getElementById('submitCoordinates').onclick = function() {
                const input = document.getElementById('coordinatesInput').value;
                const groups = input.split(/\n\s*\n/).filter(group => group.trim() !== '');

                if (groups.length > 0) {
                    objectCoordinates = groups.map(group => {
                        return group.split('\n').filter(line => line.trim() !== '').map(line => {
                            const [x, y] = line.split(/[ \t]+/).map(Number);
                            return { x, y };
                        });
                    });
                    document.body.removeChild(dialog);
                    showKPTScheme(true);
                } else {
                    alert("Пожалуйста, введите хотя бы одну пару координат.");
                }
            };

            document.getElementById('cancelCoordinates').onclick = function() {
                document.body.removeChild(dialog);
            };
        }

        function findContainingParcels(points) {
            return allContours.filter(parcel =>
                parcel.contours.some(contour =>
                    points.some(lineGroup =>
                        lineGroup.some(point =>
                            isPointInPolygon(point, contour) ||
                            contour.some(coord => Math.abs(coord.x - point.x) < 1e-8 && Math.abs(coord.y - point.y) < 1e-8)
                        ) ||
                        isLineIntersectingPolygon(lineGroup, contour)
                    )
                )
            );
        }

        function isLineIntersectingPolygon(line, polygon) {
            for (let i = 0; i < line.length - 1; i++) {
                for (let j = 0; j < polygon.length; j++) {
                    const next = (j + 1) % polygon.length;
                    if (doLinesIntersect(line[i], line[i+1], polygon[j], polygon[next])) {
                        return true;
                    }
                }
            }
            return false;
        }

        function doLinesIntersect(p1, p2, p3, p4) {
            const d1 = direction(p3, p4, p1);
            const d2 = direction(p3, p4, p2);
            const d3 = direction(p1, p2, p3);
            const d4 = direction(p1, p2, p4);

            if (((d1 > 0 && d2 < 0) || (d1 < 0 && d2 > 0)) &&
                ((d3 > 0 && d4 < 0) || (d3 < 0 && d4 > 0))) {
                return true;
            }

            return d1 === 0 && onSegment(p3, p4, p1) ||
                d2 === 0 && onSegment(p3, p4, p2) ||
                d3 === 0 && onSegment(p1, p2, p3) ||
                d4 === 0 && onSegment(p1, p2, p4);
        }

        function direction(p1, p2, p3) {
            return (p3.x - p1.x) * (p2.y - p1.y) - (p2.x - p1.x) * (p3.y - p1.y);
        }

        function onSegment(p1, p2, p3) {
            return Math.min(p1.x, p2.x) <= p3.x && p3.x <= Math.max(p1.x, p2.x) &&
                Math.min(p1.y, p2.y) <= p3.y && p3.y <= Math.max(p1.y, p2.y);
        }

        function formatDate(dateString) {
            const date = new Date(dateString);
            const day = date.getDate().toString().padStart(2, '0');
            const month = (date.getMonth() + 1).toString().padStart(2, '0');
            const year = date.getFullYear();
            return `${day}.${month}.${year}`;
        }



        function showCopiedNotification(element) {
            element.classList.add('flash');
            setTimeout(() => {
                element.classList.remove('flash');
            }, 1000);
        }

        function downloadCadastralNumbers(parcels) {
            if (parcels.length === 0) return;

            const content = parcels.map(p => p.cadastralNumber).join('\n');
            const blob = new Blob([content], {type: 'text/plain'});
            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            link.download = 'cadastral_numbers.txt';
            link.click();
            URL.revokeObjectURL(link.href);
        }

        function copyToClipboard(text) {
            navigator.clipboard.writeText(text).then(() => {
                // Удалено сообщение о копировании
            }).catch(err => {
                console.error('Ошибка при копировании текста: ', err);
            });
        }


        document.getElementById('showKPTScheme').addEventListener('click', () => showKPTScheme(false));

        document.getElementById('exportExcel').addEventListener('click', exportToExcel);

    </script>
    <div id="kptSchemeContainer" style="display: none; position: fixed; left: 0; top: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); z-index: 1000;">
        <canvas id="kptSchemeCanvas" style="width: 100%; height: 100%;"></canvas>
        <button id="closeKPTScheme" style="position: absolute; top: 10px; right: 10px; z-index: 1001;">Закрыть</button>
    </div>
</body>
</html>                