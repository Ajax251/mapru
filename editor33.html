<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ГеоРедактор</title>
    <link rel="stylesheet" href="webfonts/all.min.css">
    <link rel="icon" href="img/ed.png" type="image/png">
    <script src="webfonts/jszip.min.js"></script>
 

    <style>
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            margin: 0;
            background-color: #f0f0f0;
            overflow: hidden;
        }

        #objectAnalysisContainer {
            position: fixed;
            left: 20%;
            top: 0;
            width: 80%;
            height: 100vh;
            background: white;
            z-index: 999;
        }

        #objectAnalysisCanvas {
            width: 100%;
            height: 100%;
            cursor: grab;
        }
         #objectAnalysisCanvas.drawing-mode {
             cursor: crosshair;
         }
         #objectAnalysisCanvas.editing-point-mode {
             cursor: move;
         }
         #objectAnalysisCanvas.geometry-edit-mode-add {
            cursor: cell;
         }
         #objectAnalysisCanvas.geometry-edit-mode-hover-point {
            cursor: pointer;
         }


        #infoPanel {
            position: fixed;
            top: 0;
            left: 0;
            width: 20%;
            height: 100vh;
            background-color: #f8f8f8;
            border-right: 1px solid #ddd;
            overflow-y: auto;
            z-index: 1000;
            padding: 20px;
            user-select: none;
            box-shadow: 2px 0 10px rgba(0,0,0,0.1);
        }

        .action-button {
            position: absolute;
            right: 20px;
            background-color: #4a69bd;
            color: white;
            border: none;
            padding: 10px;
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            width: 50px;
            height: 50px;
            font-size: 18px;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }
        .action-button:hover {
            transform: scale(1.1);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.3);
        }
         .action-button:active {
             transform: scale(0.95);
         }
         .action-button.active {
              box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
              transform: scale(0.98);
         }

        #addObjectBtn {
            bottom: 20px;
            background-color: #4a69bd;
        }
        #addObjectBtn:hover { background-color: #354f9e; }

        #drawObjectBtn {
             bottom: 80px;
             background-color: #f39c12;
         }
         #drawObjectBtn:hover { background-color: #e67e22; }
         #drawObjectBtn.active { background-color: #d35400; }

         #finishDrawingBtn {
             bottom: 80px;
             background-color: #2ecc71;
             display: none;
         }
         #finishDrawingBtn:hover { background-color: #27ae60; }

        #togglePointsBtn {
             bottom: 140px;
             background-color: #e74c3c;
         }
        #togglePointsBtn:hover { background-color: #c0392b; }

        #rulerBtn {
            bottom: 200px;
            background-color: #3498db;
        }
        #rulerBtn:hover { background-color: #2980b9; }
        #rulerBtn.active { background-color: #27ae60; }


               #toggleGeometryEditBtn {
            bottom: 260px;
            background-color: #9b59b6;
        }
        #toggleGeometryEditBtn:hover {
            background-color: #8e44ad; 
        }
        #toggleGeometryEditBtn.active {
            background-color: #e74c3c; 
        }
        #toggleGeometryEditBtn.active:hover {
            background-color: #c0392b; 
        }


        #undoGeometryChangeBtn {
            bottom: 320px;
            background-color: #e67e22;
            display: none;
        }
        #undoGeometryChangeBtn:hover { background-color: #d35400; }
        #undoGeometryChangeBtn:disabled {
            background-color: #bdc3c7;
            cursor: not-allowed;
            transform: scale(1);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }


        #measurementPanel {
            position: absolute;
            bottom: 80px;
            left: 20px;
            background-color: rgba(255, 255, 255, 0.9);
            padding: 10px 15px;
            border-radius: 5px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
            font-size: 14px;
            max-width: 300px;
            display: none;
            z-index: 1100;
        }
        #measurementPanel.active { display: block; animation: fadeIn 0.3s; }
        .measurement-title { font-weight: bold; margin-bottom: 8px; color: #2c3e50; display: flex; align-items: center; }
        .measurement-title i { margin-right: 5px; color: #3498db; }
        .measurement-coordinates { margin-bottom: 8px; padding-left: 10px; border-left: 3px solid #3498db; font-family: monospace; }
        .measurement-distance { font-weight: bold; color: #e74c3c; font-size: 16px; text-align: center; margin-top: 8px; padding: 5px; background-color: rgba(231, 76, 60, 0.1); border-radius: 3px; }
        #resetMeasurementBtn { background-color: #3498db; color: white; border: none; padding: 5px 10px; border-radius: 3px; margin-top: 8px; cursor: pointer; width: 100%; transition: background-color 0.3s; }
        #resetMeasurementBtn:hover { background-color: #2980b9; }

               #gridInfoPanel {
            position: absolute;
            bottom: 20px;
            left: calc(20% + 20px);
            background-color: rgba(255, 255, 255, 0.85);
            padding: 8px 12px;
            border-radius: 5px;
            font-size: 12px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            z-index: 1000;
            display: flex;
            align-items: center;
            pointer-events: none;
            transition: opacity 0.3s;
            opacity: 0.8;
            color: royalblue;
        }
        #gridInfoPanel i { margin-right: 5px; color: royalblue; }
        #gridInfoPanel:hover { opacity: 1; }

        #cursorInfoPanel {
            position: absolute;
            bottom: 20px;
            left: calc(20% + 150px);
            background-color: rgba(255, 255, 255, 0.85);
            padding: 8px 12px;
            border-radius: 5px;
            font-size: 12px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            z-index: 1000;
            display: flex;
            align-items: center;
            pointer-events: none;
            transition: opacity 0.3s;
            opacity: 0.8;
            color: royalblue;
        }
        #cursorInfoPanel i { margin-right: 5px; color: royalblue; }
        #cursorInfoPanel:hover { opacity: 1; }


        #selectedObjectInfo h3 {
            text-align: center;
            font-size: 1.2em;
            margin-bottom: 10px;
            color: #336699;
            border-bottom: 2px solid #336699;
            padding-bottom: 5px;
            font-weight: bold;
            cursor: pointer;
        }
         #selectedObjectInfo h3:hover {
             color: #4a69bd;
         }
        #selectedObjectInfo .info-item {
            display: flex;
            justify-content: space-between;
            padding: 6px 0;
            border-bottom: 1px solid #eee;
        }
        #selectedObjectInfo .info-item span:first-child {
            font-weight: bold;
            color: #555;
            margin-right: 10px;
        }
        #selectedObjectInfo .info-item span:last-child {
            color: #333;
            text-align: right;
        }
        #selectedObjectInfo .info-item span.copyable {
             cursor: pointer;
             transition: color 0.2s;
        }
         #selectedObjectInfo .info-item span.copyable:hover {
              color: #4a69bd;
         }
         .flash {
            animation: flash 0.5s;
        }
        @keyframes flash {
            0%, 100% { background-color: inherit; }
            50% { background-color: #90EE90; }
        }


        #coordsDialog {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 400px;
            background-color: white;
            border-radius: 10px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            z-index: 2000;
            padding: 20px;
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        @keyframes fadeInDialog { from { opacity: 0; transform: translate(-50%, -50%) scale(0.95); } to { opacity: 1; transform: translate(-50%, -50%) scale(1); } }
        #coordsDialog.show {
             opacity: 1;
             animation: fadeInDialog 0.3s ease-out forwards;
        }
        #coordsDialog h3 { margin: 0 0 15px; font-size: 18px; color: #333; }
        #coordsInput {
            width: 100%;
            height: 150px;
            padding: 8px;
            border: 1px solid #ccc;
            border-radius: 4px;
            box-sizing: border-box;
            resize: vertical;
            font-size: 14px;
            margin-bottom: 15px;
            transition: border-color 0.3s;
        }
        #coordsInput:focus { border-color: #4a69bd; box-shadow: 0 0 5px rgba(74, 105, 189, 0.5); outline: none; }
        .dialog-buttons { display: flex; justify-content: space-between; gap: 10px; }
        #importCoordsBtn, #importFromFileBtn, #closeDialogBtn {
            background-color: #4a69bd;
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s;
            flex: 1;
            font-size: 14px;
            position: relative;
            overflow: hidden;
        }
        #importCoordsBtn:hover, #importFromFileBtn:hover {
            background-color: #354f9e;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }
        #importCoordsBtn:active, #importFromFileBtn:active, #closeDialogBtn:active {
            transform: translateY(1px);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        #closeDialogBtn { background-color: #dc3545; }
        #closeDialogBtn:hover { background-color: #c82333; transform: translateY(-2px); box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2); }

        #dialogOverlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0);
            z-index: 1999;
            backdrop-filter: blur(0px);
            opacity: 0;
            transition: opacity 0.3s ease, background-color 0.3s ease, backdrop-filter 0.3s ease;
        }
        #dialogOverlay.show {
             opacity: 1;
             background-color: rgba(0, 0, 0, 0.5);
             backdrop-filter: blur(2px);
        }


        #tooltip {
            position: absolute;
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 12px;
            pointer-events: none;
            z-index: 1001;
            display: none;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
            font-weight: bold;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
        }

        .notification {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 15px 20px;
            border-radius: 5px;
            color: white;
            font-size: 14px;
            z-index: 9999;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            transform: translateX(120%);
            transition: transform 0.3s ease;
            max-width: 300px;
            border: 1px solid rgba(0, 0, 0, 0.1);
            text-shadow: 0 0 2px rgba(0, 0, 0, 0.5);
        }
        .notification.info { background-color: #3498db; }
        .notification.success { background-color: #4CAF50; }
        .notification.error { background-color: #F44336; }
        .notification.warning { background-color: #FF9800; }
        .notification.show { transform: translateX(0); }
        .notification i { margin-right: 10px; }

        #loaderContainer {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background-color: rgba(173, 216, 230, 0.9);
            display: none; justify-content: center; align-items: center;
            z-index: 10000; backdrop-filter: blur(3px); flex-direction: column;
        }
        .spinner-container { width: 80px; height: 80px; position: relative; }
        .spinner-ring { position: absolute; width: 100%; height: 100%; border-radius: 50%; border: 6px solid transparent; border-top-color: #3498db; animation: spin 1.2s cubic-bezier(0.5, 0, 0.5, 1) infinite; box-sizing: border-box; }
        .spinner-ring:before, .spinner-ring:after { content: ''; position: absolute; border-radius: 50%; border: 6px solid transparent; box-sizing: border-box; }
        .spinner-ring:before { top: -6px; left: -6px; right: -6px; bottom: -6px; border-top-color: #2980b9; animation: spin 2s cubic-bezier(0.5, 0, 0.5, 1) infinite; }
        .spinner-ring:after { top: 6px; left: 6px; right: 6px; bottom: 6px; border-top-color: #6ab7e2; animation: spin 0.8s cubic-bezier(0.5, 0, 0.5, 1) infinite; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        .loading-text { color: #2c3e50; font-size: 18px; font-weight: bold; margin-top: 30px; letter-spacing: 1px; text-shadow: 0 1px 2px rgba(255, 255, 255, 0.5); animation: pulse 1.5s ease infinite; text-align: center; line-height: 1.5; min-height: 50px; }
        @keyframes pulse { 0%, 100% { opacity: 0.7; } 50% { opacity: 1; } }

        .coordinates-table {
            width: 100%; border-collapse: collapse; margin-top: 15px;
            animation: fadeInCoords 0.3s ease;
        }
        @keyframes fadeInCoords {
            from { opacity: 0; transform: translateY(-10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .coordinates-table th, .coordinates-table td { border: 1px solid #ddd; padding: 8px; text-align: center; }
        .coordinates-table th { background-color: #f2f2f2; }
        .coordinate-row { cursor: pointer; transition: background-color 0.3s; }
        .coordinate-row:hover { background-color: #f0f8ff; }
        .coordinate-row.selected-coordinate { background-color: #ffebee !important; border-left: 3px solid #f44336; font-weight: bold; }
        .coordinate-row .copyable { cursor: pointer; }

        .panel-button {
            margin-top: 10px; width: 100%; padding: 10px; color: white;
            border: none; border-radius: 5px; cursor: pointer; transition: all 0.3s;
            display: flex; align-items: center; justify-content: center;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
        .panel-button:hover { transform: translateY(-2px); box-shadow: 0 4px 8px rgba(0,0,0,0.3); }
        .panel-button:active { transform: translateY(1px); box-shadow: 0 1px 2px rgba(0,0,0,0.2); }
        .panel-button i { margin-right: 8px; }

        #showCoordinatesBtn { background-color: #4a69bd; margin-bottom: 10px; }
        #showCoordinatesBtn:hover { background-color: #354f9e; }

        #copyAllCoordinatesBtn {
            background-color: #1abc9c;
            margin-bottom: 10px;
        }
        #copyAllCoordinatesBtn:hover {
            background-color: #16a085;
        }

        #centerObjectBtn { background-color: #2ecc71; margin-bottom: 10px; }
        #centerObjectBtn:hover { background-color: #27ae60; }
        #renameObjectBtn { background-color: #f39c12; margin-bottom: 10px; }
        #renameObjectBtn:hover { background-color: #e67e22; }
        #deleteObjectBtn { background-color: #e74c3c; }
        #deleteObjectBtn:hover { background-color: #c0392b; }


        .panel-section {
            padding-bottom: 15px;
            margin-bottom: 15px;
            border-bottom: 1px solid #ddd;
        }
        .panel-section:last-child { border-bottom: none; margin-bottom: 0; }
        .section-title {
            background-color: #4a69bd; color: white; padding: 8px 12px;
            border-radius: 4px; margin-top: 15px; margin-bottom: 10px;
            font-weight: bold; position: relative; overflow: hidden;
            font-size: 0.9em;
        }
        .section-title i { margin-right: 8px; }

        .section-title-action {
            position: absolute;
            right: 12px;
            top: 50%;
            transform: translateY(-50%);
            cursor: pointer;
            transition: color 0.2s, transform 0.2s;
            opacity: 0.8;
        }
        .section-title-action:hover {
            color: #ffdddd;
            transform: translateY(-50%) scale(1.15);
            opacity: 1;
        }
        .section-title-action:active {
             transform: translateY(-50%) scale(1.05);
        }

        #intersectionList {
            list-style: none; padding: 0; margin-top: 10px;
        }
        #intersectionList li {
            padding: 8px 12px; border: 1px solid #ddd; margin-bottom: 5px;
            border-radius: 4px; background-color: #fff; cursor: pointer;
            transition: all 0.2s; position: relative; overflow: hidden;
            font-size: 0.9em;
        }
        #intersectionList li:hover {
            background-color: #f0f0f0; transform: translateX(5px);
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        #intersectionList li:before {
            content: ''; position: absolute; left: 0; top: 0; height: 100%;
            width: 3px; background-color: #4a69bd; transform: scaleY(0);
            transition: transform 0.2s;
        }
        #intersectionList li:hover:before { transform: scaleY(1); }
         #intersectionList li.full-containment { border-left: 3px solid #27ae60; background-color: #e8f8f5; }
         #intersectionList li.contained-by { border-left: 3px solid #af7ac5; background-color: #f4ecf7; }
         #intersectionList li.partial-overlap { border-left: 3px solid #f39c12; background-color: #fef9e7; }
         #intersectionList li .overlap-details { font-size: 0.8em; color: #666; margin-top: 3px; display: block; }

        #objectListContainer { max-height: 250px; overflow-y: auto; }
        #objectList li {
             padding: 5px 8px; margin-bottom: 3px; border-radius: 3px;
             cursor: pointer; display: flex; align-items: center;
             border: 1px solid transparent; transition: background-color 0.2s, border-color 0.2s;
             font-size: 0.9em;
        }
         #objectList li:hover { background-color: #f0f0f0; }
         #objectList li.selected { background-color: #e0f2f7; border-color: #b3e5fc; font-weight: bold; }
         #objectList li .color-indicator {
             display: inline-block; width: 12px; height: 12px; border-radius: 3px;
             margin-right: 8px; flex-shrink: 0; border: 1px solid #ccc;
         }
         #objectList li .name-span {
             flex-grow: 1; overflow: hidden; white-space: nowrap; text-overflow: ellipsis;
         }


        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-10px); }
            to { opacity: 1; transform: translateY(0); }
        }


        #namePromptOverlay {
            display: none;
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background-color: rgba(0, 0, 0, 0.4);
            z-index: 2999;
            backdrop-filter: blur(1.5px);
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        #namePromptOverlay.show {
            opacity: 1;
            display: block;
        }

        #namePromptDialog {
            display: none;
            position: fixed;
            top: 40%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0.95);
            width: 350px;
            background-color: white;
            border-radius: 10px;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.25);
            z-index: 3000;
            padding: 25px;
            opacity: 0;
            transition: opacity 0.3s ease, transform 0.3s ease;
            box-sizing: border-box;
        }

        #namePromptDialog.show {
            opacity: 1;
            transform: translate(-50%, -50%) scale(1);
            display: block;
        }

        #namePromptDialog h3 {
            margin: 0 0 20px;
            font-size: 1.2em;
            color: #333;
            text-align: center;
            font-weight: 600;
        }

        #namePromptInput {
            width: 100%;
            padding: 12px 10px;
            border: 1px solid #ccc;
            border-radius: 5px;
            box-sizing: border-box;
            font-size: 1em;
            margin-bottom: 20px;
            transition: border-color 0.3s, box-shadow 0.3s;
        }
        #namePromptInput:focus {
            border-color: #4a69bd;
            box-shadow: 0 0 0 3px rgba(74, 105, 189, 0.2);
            outline: none;
        }
        #namePromptDialog .dialog-buttons {
            justify-content: space-between;
        }

        #namePromptSaveBtn, #namePromptCancelBtn {
            background-color: #4a69bd;
            color: white; border: none; padding: 10px 15px; border-radius: 5px;
            cursor: pointer; transition: all 0.3s; flex-basis: 48%;
            font-size: 0.95em; display: flex; align-items: center; justify-content: center; gap: 5px;
        }
        #namePromptSaveBtn:hover { background-color: #354f9e; transform: translateY(-1px); }
        #namePromptSaveBtn:active { transform: translateY(0px); }

        #namePromptCancelBtn {
            background-color: #6c757d;
        }
        #namePromptCancelBtn:hover { background-color: #5a6268; transform: translateY(-1px); }
        #namePromptCancelBtn:active { transform: translateY(0px); }

         #viewInfoPanel {
            position: absolute;
            bottom: 20px;
            left: calc(20% + 420px);
            background-color: rgba(255, 255, 255, 0.85);
            padding: 8px 12px;
            border-radius: 5px;
            font-size: 12px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            z-index: 1000;
            display: flex;
            align-items: center;
            pointer-events: none;
            transition: opacity 0.3s;
            opacity: 0.8;
            color: #27ae60;
            white-space: nowrap;
        }
        #viewInfoPanel i {
             margin-right: 5px;
             color: #27ae60;
         }
        #viewInfoPanel:hover {
             opacity: 1;
         }
         
           @media (max-width: 768px) {
            /* Перемещаем кнопки действий в правый верхний угол на мобильных */
            .action-button {
                /* Обнуляем bottom, чтобы top сработал */
                bottom: auto !important; /* Используем !important для переопределения инлайновых стилей, если они есть, или высокой специфичности */
            }

            #addObjectBtn {
                top: 20px;
            }
            #drawObjectBtn, #finishDrawingBtn { /* finishDrawingBtn делит место с drawObjectBtn */
                top: 80px;
            }
            #togglePointsBtn {
                top: 140px;
            }
            #rulerBtn {
                top: 200px;
            }
            #toggleGeometryEditBtn {
                top: 260px;
            }
            #undoGeometryChangeBtn {
                top: 320px;
            }

            /* Если информационные панели снизу мешают кнопкам, их тоже можно сдвинуть */
            /* Например, если они накладываются */
            /*
            #gridInfoPanel, #cursorInfoPanel, #viewInfoPanel {
                bottom: auto;
                top: 20px;
            }
            #gridInfoPanel { left: 20px; }
            #cursorInfoPanel { left: 150px; }
            #viewInfoPanel { left: 280px; }
            */
        }
        
        #quarterLoadOptionsButtons .panel-button:hover {
    filter: brightness(110%);
}

/* Существующие стили для undo оставляем, добавляем для cutObjectBtn */
        #cutObjectBtn {
            bottom: 380px; /* Располагаем НАД кнопкой отмены (которая на 320px) */
            background-color: #34495e;
        }
        #cutObjectBtn:hover {
            background-color: #2c3e50;
        }
        #cutObjectBtn.active {
            background-color: #e74c3c; /* Красный при активности */
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.5);
        }

        @media (max-width: 768px) {
            #cutObjectBtn {
                top: 380px; /* Для мобильных */
                bottom: auto !important;
            }
        }
        
        #intersectPointsBtn {
            bottom: 440px; /* Располагаем НАД кнопкой ножниц (380px) */
            background-color: #8e44ad;
        }
        #intersectPointsBtn:hover {
            background-color: #732d91;
        }
        #intersectPointsBtn.active {
            background-color: #e74c3c;
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.5);
        }
        
        @media (max-width: 768px) {
            #intersectPointsBtn {
                top: 440px;
                bottom: auto !important;
            }
        }
        
        #findCoordsBtn {
            background-color: #8e44ad; /* Фиолетовый цвет */
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 50%; /* Круглые края как у остальных */
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s;
            flex: 1;
            font-size: 14px;
        }
        #findCoordsBtn:hover {
            background-color: #732d91;
            transform: translateY(-2px);
        }
        
       #openSchemaBtn {
            background-color: #9b59b6;
            margin-bottom: 10px;
        }
        #openSchemaBtn:hover {
            background-color: #8e44ad; 
        }

    </style>
</head>
<body>

<div id="infoPanel">
    <div class="panel-section">
        <h4>Информация об объекте</h4>
        <div id="selectedObjectInfo">
            <p style="color: #777; font-style: italic; text-align: center;">Выберите объект на схеме (двойной клик) или добавьте новый.</p>
        </div>
        <div id="coordinatesTableContainer"></div>
    </div>

    <div class="panel-section">
        <div class="section-title" style="display: none;" id="intersectionsTitle">
            <i class="fas fa-vector-square"></i> Пересечения и Наложения
        </div>
        <div id="intersectionsContainer">
            <ul id="intersectionList"></ul>
        </div>
    </div>

    <div class="panel-section">
       <div class="section-title">
            <i class="fas fa-list"></i> Список объектов (<span id="objectCount">0</span>)
            <span id="deleteAllObjectsBtn" class="section-title-action" title="Удалить все объекты">
                <i class="fas fa-eraser"></i>
            </span>
        </div>
        <div id="objectListContainer">
            <ul id="objectList"></ul>
        </div>
    </div>
</div>

<div id="objectAnalysisContainer">
    <canvas id="objectAnalysisCanvas"></canvas>
    <button id="addObjectBtn" class="action-button" title="Добавить объект из координат">
        <i class="fas fa-plus"></i>
    </button>
    <button id="drawObjectBtn" class="action-button" title="Нарисовать объект">
        <i class="fas fa-pencil-alt"></i>
    </button>
    <button id="finishDrawingBtn" class="action-button" title="Завершить создание объекта">
        <i class="fas fa-check"></i>
    </button>
    <button id="togglePointsBtn" class="action-button" title="Показать/скрыть точки">
        <i class="fas fa-map-marker-alt"></i>
    </button>
    <button id="rulerBtn" class="action-button" title="Измерить расстояние">
        <i class="fas fa-ruler"></i>
    </button>
    <button id="toggleGeometryEditBtn" class="action-button" title="Редактировать геометрию">
        <i class="fas fa-edit"></i>
    </button>
    <button id="undoGeometryChangeBtn" class="action-button" title="Отменить изменение геометрии">
        <i class="fas fa-undo"></i>
    </button>
    
      <button id="cutObjectBtn" class="action-button" title="Рассечение объекта (Разность)" style="display: none;">
        <i class="fas fa-cut"></i>
    </button>
    
       <button id="intersectPointsBtn" class="action-button" title="Создать точки пересечения" style="display: none;">
        <i class="fas fa-project-diagram"></i>
    </button>


    <div id="measurementPanel">
        <div class="measurement-title"><i class="fas fa-ruler"></i> Измерение</div>
        <div class="measurement-coordinates" id="measurementCoordinates">...</div>
        <div class="measurement-distance" id="measurementDistance">Расстояние: -</div>
        <button id="resetMeasurementBtn">Сбросить</button>
    </div>

    <div id="gridInfoPanel">
        <i class="fas fa-th"></i>
        <span id="gridStepText"></span>
    </div>
    <div id="cursorInfoPanel">
        <i class="fas fa-mouse-pointer"></i>
        <span id="cursorCoordinates">X: 0.00, Y: 0.00</span>
    </div>
      <div id="viewInfoPanel">
        <i class="fas fa-ruler-horizontal"></i>
        <span id="viewInfoText">Обзор: -</span>
    </div>
</div>

<div id="tooltip"></div>

<div id="dialogOverlay"></div>
<div id="coordsDialog">
    <h3>Добавить объект</h3>
       <div style="margin-bottom: 15px; text-align: left;">
        <label for="importModeSelect" style="text-align: left; margin-bottom: 5px; font-size: 14px;">Режим загрузки для кадастровых номеров:</label>
        <select id="importModeSelect" style="width: 100%; padding: 8px; border-radius: 4px; border: 1px solid #ccc;">
            <!-- Опции будут добавлены через JavaScript -->
        </select>
    </div>
    <textarea id="coordsInput" placeholder="Вставьте координаты (X Y или Y X на каждой строке, разделенные пробелом/табуляцией) ИЛИ кадастровый номер объекта или квартала (каждый на новой строке)"></textarea>
<div class="dialog-buttons">
        <button id="importCoordsBtn">
            <i class="fas fa-cloud-download-alt"></i> Загрузить и Добавить
        </button>
        <button id="importFromFileBtn" title="Импорт координат из TXT/CSV файла (X Y или Y X)">
            <i class="fas fa-file-upload"></i> Файл (X Y)
        </button>
        <!-- НОВАЯ КНОПКА -->
        <button id="findCoordsBtn" title="Отобразить каждую координату как отдельную точку (прицел)">
            <i class="fas fa-crosshairs"></i> Найти координаты
        </button>
        <!-- КОНЕЦ НОВОЙ КНОПКИ -->
        <button id="closeDialogBtn">
            <i class="fas fa-times"></i> Закрыть
        </button>
    </div>
</div>

<div id="loaderContainer">
  <div class="spinner-container">
    <div class="spinner-ring"></div>
  </div>
  <div class="loading-text">Загрузка...</div>
  <!-- Добавлена кнопка отмены -->
  <button id="cancelLoadBtn" style="margin-top: 20px; padding: 8px 20px; background: #e74c3c; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 14px; display: none;">
      <i class="fas fa-times"></i> Отменить
  </button>
</div>

<div id="namePromptOverlay"></div>
<div id="namePromptDialog">
    <h3 id="namePromptTitle">Имя объекта</h3>
    <input type="text" id="namePromptInput" placeholder="Введите имя...">
    <div class="dialog-buttons">
        <button id="namePromptSaveBtn">
            <i class="fas fa-check"></i> Сохранить
        </button>
        <button id="namePromptCancelBtn">
            <i class="fas fa-times"></i> Отмена
        </button>
    </div>
</div>

<div id="quarterLoadOptionsDialog" style="display: none; position: fixed; top: 40%; left: 50%; transform: translate(-50%, -50%); width: 400px; background-color: white; border-radius: 10px; box-shadow: 0 5px 20px rgba(0, 0, 0, 0.25); z-index: 3000; padding: 25px; box-sizing: border-box; text-align: center;">
    <h3 id="quarterLoadOptionsTitle" style="margin: 0 0 20px; font-size: 1.2em; color: #333; font-weight: 600;">Режим загрузки квартала</h3>
    <div id="quarterLoadOptionsButtons" style="display: flex; flex-direction: column; gap: 10px;">
        <button data-load-type="all" class="panel-button" style="background-color: #3498db; margin: 0;"><i class="fas fa-layer-group"></i> Загрузить все объекты</button>
        <button data-load-type="zu" class="panel-button" style="background-color: #2ecc71; margin: 0;"><i class="fas fa-map-marked-alt"></i> Только Земельные Участки (ЗУ)</button>
       <button data-load-type="oks" class="panel-button" style="background-color: #e67e22; margin: 0;"><i class="fas fa-building"></i> Только Здания</button>
        <button data-load-type="construction" class="panel-button" style="background-color: #f1c40f; margin: 0;"><i class="fas fa-industry"></i> Только Сооружения</button>
        <button data-load-type="adjacent" class="panel-button" style="background-color: #9b59b6; margin: 0;"><i class="fas fa-vector-square"></i> Только смежные объекты</button>
    </div>
    <button id="quarterLoadOptionsCancelBtn" class="panel-button" style="background-color: #6c757d; margin-top: 20px;">
        <i class="fas fa-times"></i> Отмена
    </button>
</div>


<!-- Диалог выбора действия при пересечении -->
<div id="intersectionOptionsDialog" style="display: none; position: fixed; top: 40%; left: 50%; transform: translate(-50%, -50%); width: 450px; background-color: white; border-radius: 10px; box-shadow: 0 5px 20px rgba(0, 0, 0, 0.25); z-index: 3000; padding: 25px; box-sizing: border-box; text-align: center;">
    <h3 style="margin: 0 0 15px; font-size: 1.2em; color: #333; font-weight: 600;">Пересечение найдено</h3>
    <p id="intersectionCountText" style="margin-bottom: 20px; color: #666;">Найдено точек: 0</p>
    
    <div style="display: flex; flex-direction: column; gap: 10px;">
        <button onclick="applyIntersectionChoice('create_only')" class="panel-button" style="background-color: #3498db; margin: 0;">
            <i class="fas fa-map-marker-alt"></i> 1. Создать только точки (новые объекты)
        </button>
        <button onclick="applyIntersectionChoice('modify_both')" class="panel-button" style="background-color: #8e44ad; margin: 0;">
            <i class="fas fa-vector-square"></i> 2. Создать точки в обоих полигонах
        </button>
        <button onclick="applyIntersectionChoice('modify_first')" class="panel-button" style="background-color: #e67e22; margin: 0;">
            <i class="fas fa-draw-polygon"></i> 3. Создать точки только в объекте №1
        </button>
        <button onclick="applyIntersectionChoice('modify_second')" class="panel-button" style="background-color: #2ecc71; margin: 0;">
            <i class="fas fa-draw-polygon"></i> 4. Создать точки только в объекте №2
        </button>
    </div>
    
    <button onclick="closeIntersectionDialog()" class="panel-button" style="background-color: #6c757d; margin-top: 20px;">
        <i class="fas fa-times"></i> Отмена
    </button>
</div>



  <script src="cb.js"></script> 
  <script src="webfonts/proj4.js"></script>
<script src="sk.js"></script>

<script>

     let userObjects = [];
    let selectedObjectIndex = -1;
    let nextObjectId = 1;
    const objectColors = [ '#FF6347', '#4682B4', '#32CD32', '#FFD700', '#6A5ACD', '#FF4500', '#1E90FF', '#ADFF2F', '#DAA520', '#8A2BE2', '#DC143C', '#00CED1', '#9ACD32', '#FF8C00', '#9932CC' ];
    let nextColorIndex = 0;

    let scale = 1;
    let offsetX = 0;
    let offsetY = 0;
    let minX = undefined, minY = undefined, maxX = undefined, maxY = undefined;

    let isDragging = false;
    let startX, startY;
    let lastOffsetX = 0, lastOffsetY = 0;
    let selectedCoordinate = null;
    let showPoints = true;

    let rulerMode = false;
    let rulerPoints = [];
    let isDrawingMode = false;
    let isDrawingActive = false;
    let currentDrawingPoints = [];
    let currentMousePos = { x: 0, y: 0 };

    let isGeometryEditMode = false;
    let editingObjectIndex = -1;
    let isMovingPoint = false;
    let movedPointInfo = null;
    let snappedToPointVisual = null;
    let geometryHistory = [];
    
    let isNspdLoadCancelled = false; 
    
       let isCutToolActive = false;
    let cutTargetIndex = -1; 
    
    let isIntersectToolActive = false;
let intersectTargetIndex = -1;

 let pendingIntersectionData = null
    
    const MAX_GEOMETRY_HISTORY = 10;

    const SNAP_RADIUS_SCREEN = 10;
    const ADD_POINT_THRESHOLD_SCREEN = 7;
    const GRAB_POINT_RADIUS_SCREEN = 7;
    window.lastPointMoveEndTime = 0;

const STORAGE_API_URL = 'https://mapruapp.ru/storage';
const BUCKET_NAME = 'kpt';

    const sevenDigitsRegions = ['24', '50', '63', '66', '77', '78', '91'];


    const canvas = document.getElementById('objectAnalysisCanvas');
    const ctx = canvas.getContext('2d');
    const tooltip = document.getElementById('tooltip');
    const selectedObjectInfoDiv = document.getElementById('selectedObjectInfo');
    const coordinatesTableContainer = document.getElementById('coordinatesTableContainer');
    const intersectionsTitle = document.getElementById('intersectionsTitle');
    const intersectionList = document.getElementById('intersectionList');
    const objectListUL = document.getElementById('objectList');
    const objectCountSpan = document.getElementById('objectCount');
    const coordsDialog = document.getElementById('coordsDialog');
    const dialogOverlay = document.getElementById('dialogOverlay');
    const coordsInput = document.getElementById('coordsInput');
    const gridInfoText = document.getElementById('gridStepText');
    const cursorCoordinates = document.getElementById('cursorCoordinates');
    const measurementPanel = document.getElementById('measurementPanel');
    const measurementCoordinates = document.getElementById('measurementCoordinates');
    const measurementDistance = document.getElementById('measurementDistance');
    const loaderContainer = document.getElementById('loaderContainer');
    const loaderTextElement = loaderContainer.querySelector('.loading-text');
    const drawObjectBtn = document.getElementById('drawObjectBtn');
    const finishDrawingBtn = document.getElementById('finishDrawingBtn');
    const namePromptDialog = document.getElementById('namePromptDialog');
    const namePromptOverlay = document.getElementById('namePromptOverlay');
    const namePromptTitle = document.getElementById('namePromptTitle');
    const namePromptInput = document.getElementById('namePromptInput');
    const viewInfoText = document.getElementById('viewInfoText');
    const toggleGeometryEditBtn = document.getElementById('toggleGeometryEditBtn');
    const undoGeometryChangeBtn = document.getElementById('undoGeometryChangeBtn');
    const rulerBtn = document.getElementById('rulerBtn');
    
    const nextObjectIdPlaceholder = "%%NEXT_OBJECT_ID_PLACEHOLDER%%"; // Для временных имен


    function roundCoord(value) {
        if (!isFinite(value)) return value;
        return parseFloat(value.toFixed(2));
    }

function updateObjectMetrics(obj) {
    if (!obj || !obj.contours || obj.contours.length === 0) {
        obj.area = 0;
        obj.perimeter = 0;
        return;
    }

    obj.contours.forEach((contour, cIdx) => {
        if (contour) {
            for(let i=0; i < contour.length; i++) {
                if(contour[i]) {
                    contour[i].x = roundCoord(contour[i].x);
                    contour[i].y = roundCoord(contour[i].y);
                }
            }
            
            if (obj.type === 'polygon' && obj.subType !== 'construction_record' && contour.length >= 3) {
                const firstPt = contour[0];
                const lastPt = contour[contour.length - 1];
                const PRECISION_THRESHOLD = 0.001;
                if (!(Math.abs(firstPt.x - lastPt.x) < PRECISION_THRESHOLD && Math.abs(firstPt.y - lastPt.y) < PRECISION_THRESHOLD)) {
                    contour.push({ x: firstPt.x, y: firstPt.y });
                }
            }
        }
    });

    const isConsideredPolygonForCalc = obj.type === 'polygon' && obj.subType !== 'construction_record';
    obj.area = isConsideredPolygonForCalc && obj.contours[0] ? calculatePolygonArea(obj.contours[0]) : 0;
    
    let totalPerimeter = 0;
    obj.contours.forEach(c => {
        totalPerimeter += calculatePolygonPerimeter(c, isConsideredPolygonForCalc);
    });
    obj.perimeter = roundCoord(totalPerimeter);
}

    function deepCloneContours(contours) {
        if (!contours) return [];
        return contours.map(contour => {
            if (!contour) return null;
            return contour.map(p => (p ? { ...p } : null));
        });
    }

    function saveGeometryStateForUndo(objIndex) {
        if (objIndex < 0 || objIndex >= userObjects.length || !userObjects[objIndex]) return;
        const obj = userObjects[objIndex];
        geometryHistory.push(deepCloneContours(obj.contours));
        if (geometryHistory.length > MAX_GEOMETRY_HISTORY) {
            geometryHistory.shift();
        }
        updateUndoButtonState();
    }

    function undoLastGeometryChange() {
        if (!isGeometryEditMode || editingObjectIndex === -1 || geometryHistory.length === 0) return;
        const obj = userObjects[editingObjectIndex];
        if (!obj) return;

        const previousContours = geometryHistory.pop();
        if (previousContours) {
            obj.contours = previousContours;
            updateObjectMetrics(obj);
            displayObjectInfo(editingObjectIndex);
            redraw(true);
            saveState();
            showNotification("Действие отменено", "info", "undo");
        }
        updateUndoButtonState();
    }

function updateUndoButtonState() {
        const undoBtn = document.getElementById('undoGeometryChangeBtn');
        const cutBtn = document.getElementById('cutObjectBtn');
        const intBtn = document.getElementById('intersectPointsBtn');

        if (isGeometryEditMode) {
            // 1. Показываем инструменты редактирования
            cutBtn.style.display = 'flex';
            intBtn.style.display = 'flex';

            // 2. Логика кнопки Undo
            // Кнопка Undo должна быть видна, если выбран объект для редактирования (editingObjectIndex != -1)
            // ИЛИ если у нас есть история изменений (чтобы не потерять возможность отмены при смене фокуса)
            if (editingObjectIndex !== -1) {
                undoBtn.style.display = 'flex';
                undoBtn.disabled = geometryHistory.length === 0;
            } else {
                // Если объект не выбран, Undo скрываем, так как нечего отменять
                undoBtn.style.display = 'none';
            }

            // Управление активностью кнопок инструментов при потере фокуса
            if (editingObjectIndex === -1) {
                // Если мы потеряли объект редактирования, сбрасываем инструменты
                if (isCutToolActive) toggleCutTool();
                if (isIntersectToolActive) toggleIntersectTool();
            }

        } else {
            // Если режим редактирования выключен - скрываем всё
            undoBtn.style.display = 'none';
            undoBtn.disabled = true;

            cutBtn.style.display = 'none';
            cutBtn.classList.remove('active');
            isCutToolActive = false;
            cutTargetIndex = -1;

            intBtn.style.display = 'none';
            intBtn.classList.remove('active');
            isIntersectToolActive = false;
            intersectTargetIndex = -1;
        }
    }
    
    function toggleCutTool() {
        if (!isGeometryEditMode) return;
        
        isCutToolActive = !isCutToolActive;
        const btn = document.getElementById('cutObjectBtn');
        
        if (isCutToolActive) {
            btn.classList.add('active');
            cutTargetIndex = -1;
            showNotification("Инструмент «Ножницы»: Двойной клик по РАССЕКАЕМОМУ объекту.", "info", "cut");
            canvas.style.cursor = 'crosshair';
        } else {
            btn.classList.remove('active');
            cutTargetIndex = -1;
            showNotification("Инструмент «Ножницы» выключен.", "info", "times");
            canvas.style.cursor = 'default';
        }
        redraw(true);
    }


    function loadState() {
        try {
            const savedStateJSON = localStorage.getItem('geoAnalyzerState');
            if (savedStateJSON) {
                const state = JSON.parse(savedStateJSON);
                // Фильтруем null/undefined объекты, которые могли сохраниться из-за ошибки
                userObjects = (state.userObjects || []).filter(o => o && o.id && o.contours);
                nextObjectId = state.nextObjectId || 1;
                nextColorIndex = state.nextColorIndex || 0;
                showPoints = state.showPoints === undefined ? true : state.showPoints;

                if (state.view && state.view.minX !== undefined && isFinite(state.view.scale)) {
                    scale = state.view.scale;
                    offsetX = state.view.offsetX;
                    offsetY = state.view.offsetY;
                    minX = state.view.minX;
                    minY = state.view.minY;
                    maxX = state.view.maxX;
                    maxY = state.view.maxY;
                    if (!hasValidView()) {
                        console.warn("Загруженное состояние вида невалидно, сброс.");
                        calculateBounds(); // Рассчитать границы на основе загруженных объектов
                        resetView();     // Затем сбросить вид
                    }
                } else {
                    calculateBounds();
                    resetView();
                }
                console.log("Состояние загружено из localStorage.");
            } else {
                userObjects = []; // Инициализация, если состояния нет
                nextObjectId = 1;
                nextColorIndex = 0;
                showPoints = true;
                calculateBounds();
                resetView();
                console.log("Сохраненное состояние не найдено, начинаем с чистого листа.");
            }
        } catch (e) {
            console.error("Ошибка загрузки состояния:", e);
            userObjects = []; // Сброс при ошибке
            nextObjectId = 1;
            nextColorIndex = 0;
            showPoints = true;
            calculateBounds();
            resetView();
            showNotification("Ошибка загрузки сохраненного состояния. Начинаем с чистого листа.", "warning", "hdd");
        }
        // Обновление метрик объектов после загрузки
        userObjects.forEach(obj => updateObjectMetrics(obj));
    }

async function initializeApp() { // Сделана асинхронной
       canvas.width = canvas.offsetWidth;
       canvas.height = canvas.offsetHeight;
        setupEventListeners();
       loadState();
        populateImportModeSelect(); 

        // 2. Проверка буфера обмена. Если успешно и пользователь согласен, userObjects будут очищены и заполнены заново.
        const clipboardImported = await checkClipboardForObjects();

        // 3. Обновление UI и состояния
        // Если из буфера не было импорта, то userObjects остаются те, что из loadState.
        // Если был импорт, userObjects уже обновлены.
        updateObjectList();


        if (userObjects.length > 0 && (!hasValidView() || clipboardImported)) {
             calculateBounds();
             resetView();
        } else if (userObjects.length === 0) {
            calculateBounds();
            resetView();
        }

        redraw(false);
        updateViewInfo();
        updateToggleButtonStates();
        updateUndoButtonState();
    }

    const cMinXGlob = () => (minX === undefined || !isFinite(minX)) ? 0 : minX;
    const cMinYGlob = () => (minY === undefined || !isFinite(minY)) ? 0 : minY;

    function calculateBounds() {
        const canvasWidth = canvas.width || 100;
        const canvasHeight = canvas.height || 100;

        if (userObjects.length === 0) {
             minX = 0; minY = 0; maxX = canvasWidth; maxY = canvasHeight;
             return;
         }

         let currentMinX = Infinity, currentMinY = Infinity, currentMaxX = -Infinity, currentMaxY = -Infinity;
         let hasValidPoints = false;
         userObjects.forEach(obj => {
             if (!obj || !obj.contours) return;
             obj.contours.forEach(contour => {
                 if (!contour) return;
                 contour.forEach(p => {
                     if (p && isFinite(p.x) && isFinite(p.y)) {
                         currentMinX = Math.min(currentMinX, p.x); currentMinY = Math.min(currentMinY, p.y);
                         currentMaxX = Math.max(currentMaxX, p.x); currentMaxY = Math.max(currentMaxY, p.y);
                         hasValidPoints = true;
                     }
                 });
             });
         });

         if (hasValidPoints && isFinite(currentMinX)) {
            minX = currentMinX; minY = currentMinY; maxX = currentMaxX; maxY = currentMaxY;
         } else {
              minX = 0; minY = 0; maxX = canvasWidth; maxY = canvasHeight;
         }
    }
    
function processSingleObjectBlock(blockLines, defaultNameBase = "Объект") {
        if (blockLines.length === 0) return null;

        let objectName;
        let coordinateLinesStartIdx = 0;

        const firstLine = blockLines[0].trim();

        // 1. Проверяем, является ли первая строка валидным кадастровым номером
        if (isValidCadastralNumberFormat(firstLine)) {
            objectName = firstLine;
            coordinateLinesStartIdx = 1;
        } else {
            // 2. Если не КН, проверяем, похожа ли она на координаты
            // Более строгая проверка: X<разделитель>Y, где X и Y - числа с возможной дробной частью
            // Разделитель - пробел или таб. Должно быть ДВА числа.
            const coordParts = firstLine.replace(/,/g, '.').split(/[\s\t]+/);
            let firstLineIsCoords = false;
            if (coordParts.length >= 2) {
                const xCand = parseFloat(coordParts[0]);
                const yCand = parseFloat(coordParts[1]);
                if (isFinite(xCand) && isFinite(yCand)) {
                    firstLineIsCoords = true;
                } else if (coordParts.length > 2) { // Попробовать вторую и третью, если первая пара не числа
                    const xCand2 = parseFloat(coordParts[1]);
                    const yCand2 = parseFloat(coordParts[2]);
                     if (isFinite(xCand2) && isFinite(yCand2)) {
                        firstLineIsCoords = true;
                    }
                }
            }


            if (firstLineIsCoords) {
                // Первая строка - это координаты, генерируем имя
                objectName = `${defaultNameBase} #${nextObjectIdPlaceholder}`;
                coordinateLinesStartIdx = 0; // Все строки из blockLines - потенциальные координаты
            } else {
                // Первая строка не КН и не явные координаты - считаем ее произвольным именем
                objectName = firstLine;
                coordinateLinesStartIdx = 1;
            }
        }

        if (coordinateLinesStartIdx >= blockLines.length && objectName !== `${defaultNameBase} #${nextObjectIdPlaceholder}` && !isValidCadastralNumberFormat(objectName) ) {
             // Если было произвольное имя (не КН и не автоген), но не было координат
             console.warn(`Объект с именем "${objectName}" не имел координатных строк.`);
             return null;
        }
         // Если это был КН и нет координатных строк, это нормально - КН может быть без координат в данном тексте
         // и должен быть добавлен как объект, координаты для него могут быть загружены позже, если это единичный КН из буфера.
         // Но если это КН как часть большого блока, и мы не нашли для него координат в ЭТОМ блоке,
         // то сам processSingleObjectBlock вернет contours.length === 0, и он не будет добавлен.


        const contours = [];
        let currentContour = [];

        for (let i = coordinateLinesStartIdx; i < blockLines.length; i++) {
            const line = blockLines[i];
            if (line === "") {
                if (currentContour.length > 0) {
                    contours.push(currentContour);
                    currentContour = [];
                }
            } else {
                const parts = line.replace(/,/g, '.').split(/[\s\t]+/);
                if (parts.length >= 2) {
                    let x = parseFloat(parts[0]);
                    let y = parseFloat(parts[1]);
                    if (!isFinite(x) || !isFinite(y)) {
                        x = parseFloat(parts[1]);
                        y = parseFloat(parts[0]);
                    }
                    if (isFinite(x) && isFinite(y)) {
                        currentContour.push({ x: roundCoord(x), y: roundCoord(y) });
                    }
                }
            }
        }
        if (currentContour.length > 0) {
            contours.push(currentContour);
        }

        // Важно: если это был КН (objectName = firstLine и isValidCadastralNumberFormat(objectName)),
        // и для него не нашлось координат В ЭТОМ БЛОКЕ (contours.length == 0),
        // то мы все равно должны вернуть объект с именем КН и пустыми контурами.
        // Это позволит функции checkClipboardForObjects решить, что делать дальше
        // (например, если это единственный КН, то загрузить из Supabase).
        // Если же это был КН как часть мульти-блока, и дальше нет координат - то он не добавится в addedObjectsBatch.

        if (contours.length > 0 && contours.some(c => c.length > 0)) {
            return { name: objectName, contours: contours.filter(c => c.length > 0) };
        } else if (isValidCadastralNumberFormat(objectName) && coordinateLinesStartIdx === 1) {
            // Если это был КН и после него не было координатных строк ВООБЩЕ
            // (т.е. blockLines состоял только из КН или КН + пустые строки)
            // Возвращаем его с пустыми контурами, чтобы checkClipboardForObjects мог его обработать как одиночный КН
            return { name: objectName, contours: [] };
        }


        return null;
    }
    
    
     function processObjectBlock(objectLines, parsedObjectsArray) {
        if (objectLines.length < 2) return; // Нужно имя и хотя бы одна координата

        const objectName = objectLines[0];
        const coordinateLines = objectLines.slice(1);

        const contours = [];
        let currentContour = [];

        for (const coordLine of coordinateLines) {
            // coordLine уже очищена от пробелов по краям из внешнего цикла
            // Пустая строка ВНУТРИ блока объекта означает новый контур
            if (coordLine === "") {
                if (currentContour.length > 0) {
                    contours.push(currentContour);
                    currentContour = [];
                }
            } else {
                const parts = coordLine.replace(/,/g, '.').split(/[\s\t]+/);
                if (parts.length >= 2) {
                    let x = parseFloat(parts[0]);
                    let y = parseFloat(parts[1]);
                    if (!isFinite(x) || !isFinite(y)) { // Попробовать поменять местами
                        x = parseFloat(parts[1]);
                        y = parseFloat(parts[0]);
                    }
                    if (isFinite(x) && isFinite(y)) {
                        currentContour.push({ x: roundCoord(x), y: roundCoord(y) });
                    }
                }
            }
        }
        if (currentContour.length > 0) { // Добавить последний контур
            contours.push(currentContour);
        }

        if (contours.length > 0 && contours.some(c => c.length > 0)) {
            parsedObjectsArray.push({ name: objectName, contours: contours.filter(c => c.length > 0) });
        }
    }

 function parseObjectsFromClipboardText(text) {
        const parsedObjectData = [];
        // Сначала разбиваем весь текст на блоки, где каждый блок - это потенциальный объект.
        // Разделитель между объектами - две или более последовательные пустые строки.
        // Используем регулярное выражение для разделения по двум и более переводам строки.
        // trim() в начале убирает лишние пробелы и пустые строки в начале/конце всего текста.
        const objectBlocksAsStrings = text.trim().split(/\n\s*\n\s*\n*/); // Две или более пустые строки

        for (const blockStr of objectBlocksAsStrings) {
            if (blockStr.trim() === "") continue; // Пропускаем полностью пустые блоки

            // Теперь каждую строку внутри блока объекта тримим и разбиваем
            const blockLines = blockStr.split('\n').map(line => line.trim()).filter(line => line !== "" || blockStr.split('\n').map(l => l.trim()).indexOf(line.trim()) !== blockStr.split('\n').map(l => l.trim()).lastIndexOf(line.trim()) );
            // Фильтр (line => line !== "" || ...) нужен, чтобы сохранить одну пустую строку, если она разделяет контуры,
            // но удалить множественные пустые строки внутри одного блока объекта, которые не являются разделителями контуров.
            // Проще: разбиваем блок на строки, потом передаем в processSingleObjectBlock, который сам обработает пустые строки как разделители контуров.

            const linesForSingleObject = blockStr.split('\n').map(l => l.trim());


            const obj = processSingleObjectBlock(linesForSingleObject);
            if (obj) {
                // Проверка, если имя объекта - это валидный КН, и у него нет координат,
                // то это может быть случай, когда КН был частью блока с координатами.
                // Такой КН не должен обрабатываться как отдельный объект, если он не единственный в буфере.
                if (isValidCadastralNumberFormat(obj.name) && obj.contours.length === 0) {
                     // Пропускаем, если это КН без координат, который мог быть "заголовком"
                     console.log(`Пропущен КН "${obj.name}" без координат как потенциальный заголовок.`);
                } else {
                    parsedObjectData.push(obj);
                }
            }
        }
        return parsedObjectData;
    }

async function checkClipboardForObjects() {
        try {
            const text = await navigator.clipboard.readText();
            if (!text || text.trim().length === 0) return false;

            const trimmedText = text.trim();
            const lines = trimmedText.split('\n');

            // 1. Проверка на одиночный кадастровый номер
            if (lines.length === 1 && isValidCadastralNumberFormat(trimmedText)) {
                // REMOVED: const userConfirmation = window.confirm(`В буфере обмена обнаружен кадастровый номер: ${trimmedText}. Загрузить его из базы данных? (Это очистит текущие объекты)`);
                // REMOVED: if (userConfirmation) {
                showLoader(true, `Загрузка ${trimmedText}...`);
                userObjects = []; nextObjectId = 1; nextColorIndex = 0; selectedObjectIndex = -1; editingObjectIndex = -1; geometryHistory = [];
                console.log("Состояние очищено перед импортом КН из буфера обмена.");

                await handleImportFromCadNumbers([trimmedText]);
                showLoader(false);
                return true;
                // REMOVED: }
                // REMOVED: return false;
            }

            // 2. Проверка на многострочные данные
            const looksLikeCoordinateData = /\d/.test(trimmedText) && /[ \t,.]/.test(trimmedText);

            if (looksLikeCoordinateData) {
                // REMOVED: const userConfirmation = window.confirm("В буфере обмена обнаружены данные, похожие на координаты объектов. Хотите импортировать их? (Это очистит текущие объекты)");
                // REMOVED: if (!userConfirmation) {
                // REMOVED:     console.log("Пользователь отклонил импорт из буфера обмена.");
                // REMOVED:     return false;
                // REMOVED: }

                showLoader(true, "Импорт из буфера обмена...");
                userObjects = []; nextObjectId = 1; nextColorIndex = 0; selectedObjectIndex = -1; editingObjectIndex = -1; geometryHistory = [];
                console.log("Состояние очищено перед импортом объектов из буфера обмена.");

                const parsedClipboardObjects = parseObjectsFromClipboardText(trimmedText);
                let tempNextObjectIdForNaming = 1;

                if (parsedClipboardObjects.length > 0) {
                    let addedObjectsBatch = [];
                    for (const objData of parsedClipboardObjects) {
                        if (isValidCadastralNumberFormat(objData.name) && objData.contours.length === 0 && parsedClipboardObjects.length > 1) {
                            console.log(`Пропущен КН "${objData.name}" без координат, так как он не единственный в буфере и является заголовком.`);
                            continue;
                        }

                        let finalName = objData.name;
                        if (finalName === `Объект #${nextObjectIdPlaceholder}`) {
                            finalName = `Объект #${tempNextObjectIdForNaming++}`;
                        }

                        let objectType = 'point';
                         if (objData.contours && objData.contours.length > 0) {
                            const firstPrimaryContour = objData.contours.find(c => c && c.length > 0);
                            if (firstPrimaryContour) {
                                if (firstPrimaryContour.length >= 3) {
                                    const firstPt = firstPrimaryContour[0];
                                    const lastPt = firstPrimaryContour[firstPrimaryContour.length - 1];
                                    const PRECISION_THRESHOLD = 0.001;
                                    if (Math.abs(firstPt.x - lastPt.x) < PRECISION_THRESHOLD && Math.abs(firstPt.y - lastPt.y) < PRECISION_THRESHOLD) {
                                        objectType = 'polygon';
                                    } else {
                                        objectType = 'line';
                                    }
                                } else if (firstPrimaryContour.length === 2) {
                                    objectType = 'line';
                                }
                            }
                        }

                        if (objData.contours.length > 0 || isValidCadastralNumberFormat(finalName)) {
                            const newObj = addObjectInternal(objData.contours, finalName, objectType, true);
                            if (newObj) {
                                addedObjectsBatch.push(newObj);
                            }
                        } else if (objData.name !== `Объект #${nextObjectIdPlaceholder}`) {
                            console.warn(`Объект "${finalName}" не был добавлен, так как не имеет валидных контуров.`);
                        }
                    }
                    if (addedObjectsBatch.length > 0) {
                        finalizeBatchAdd(addedObjectsBatch);
                        showNotification(`Импортировано ${addedObjectsBatch.length} объектов из буфера обмена.`, "success", "clipboard-check");
                    } else {
                        showNotification("Не удалось импортировать объекты из буфера обмена. Проверьте формат или убедитесь, что есть валидные координаты.", "warning", "exclamation-triangle");
                    }
                } else {
                     showNotification("Не найдено валидных объектов для импорта в буфере обмена.", "info", "clipboard");
                }
                showLoader(false);
                return parsedClipboardObjects.length > 0;
            }
        } catch (err) {
             if (err.name === 'NotAllowedError' || (err.message && err.message.toLowerCase().includes('permission denied'))) {
                 console.warn('Чтение из буфера обмена не удалось (разрешения/фокус).', err.name);
            } else if (err.name === 'TypeError' && (err.message && err.message.toLowerCase().includes('readtext'))) {
                console.warn('API буфера обмена navigator.clipboard недоступно.');
            } else {
                console.error('Ошибка чтения/парсинга буфера обмена:', err);
            }
            showLoader(false);
        }
        return false;
    }
  


    
    function updateViewInfo() {
        if (!viewInfoText || !hasValidView() || !canvas || canvas.width <= 0 || scale <= 1e-9) {
            if(viewInfoText) viewInfoText.textContent = `Обзор: -`;
            return;
        }
        const visibleWidthMeters = canvas.width / scale;
        let displayText;
        if (!isFinite(visibleWidthMeters)) {
             displayText = `Высота: -`;
        } else if (visibleWidthMeters >= 1000) {
            displayText = `Высота: ${(visibleWidthMeters / 1000).toFixed(2)} км`;
        } else {
            displayText = `Высота: ${visibleWidthMeters.toFixed(1)} м`;
        }
        viewInfoText.textContent = displayText;
    }
    function resetView() {
        calculateBounds();
        const canvasWidth = canvas.width || 100;
        const canvasHeight = canvas.height || 100;

        if (minX === undefined || !isFinite(minX) || maxX === undefined || !isFinite(maxX) ||
            minY === undefined || !isFinite(minY) || maxY === undefined || !isFinite(maxY))
        {
             scale = 1; offsetX = 0; offsetY = 0;
             minX = 0; minY = 0; maxX = canvasWidth; maxY = canvasHeight;
        } else {
            const dataWidth = Math.max(1e-6, maxX - minX);
            const dataHeight = Math.max(1e-6, maxY - minY);
            const scaleX = canvasWidth / dataWidth * 0.9;
            const scaleY = canvasHeight / dataHeight * 0.9;
            scale = Math.max(1e-9, Math.min(Math.min(scaleX, scaleY), 10000));
            if (!isFinite(scale) || scale <= 0) scale = 1;

            const centerX = minX + dataWidth / 2;
            const centerY = minY + dataHeight / 2;
            offsetX = canvasWidth / 2 - (centerY - cMinYGlob()) * scale;
            offsetY = canvasHeight / 2 - (centerX - cMinXGlob()) * scale;
        }

        if (!isFinite(scale) || scale <= 0) scale = 1;
        if (!isFinite(offsetX)) offsetX = 0;
        if (!isFinite(offsetY)) offsetY = 0;

        if (!hasValidView()) {
             scale = 1; offsetX = 0; offsetY = 0;
             minX = 0; minY = 0; maxX = canvasWidth; maxY = canvasHeight;
        }
         updateViewInfo();
    }
    function hasValidView() {
        return isFinite(scale) && scale > 1e-9 &&
               isFinite(offsetX) && isFinite(offsetY) &&
               minX !== undefined && minY !== undefined && maxX !== undefined && maxY !== undefined &&
               isFinite(minX) && isFinite(minY) && isFinite(maxX) && isFinite(maxY);
    }

     function updateToggleButtonStates() {
         document.getElementById('togglePointsBtn').style.backgroundColor = showPoints ? '#e74c3c' : '#7f8c8d';
         rulerBtn.classList.toggle('active', rulerMode);
         drawObjectBtn.classList.toggle('active', isDrawingMode);
         finishDrawingBtn.style.display = isDrawingActive ? 'flex' : 'none';
         toggleGeometryEditBtn.classList.toggle('active', isGeometryEditMode);
         updateUndoButtonState();

         canvas.classList.toggle('drawing-mode', isDrawingMode && isDrawingActive);
         canvas.classList.toggle('editing-point-mode', isMovingPoint);
     }

function setupEventListeners() {
        canvas.addEventListener('mousedown', handleMouseDown);
        canvas.addEventListener('mousemove', handleMouseMove);
        canvas.addEventListener('mouseup', handleMouseUp);
        canvas.addEventListener('wheel', handleWheel, { passive: false });
        canvas.addEventListener('click', handleClick);
        canvas.addEventListener('dblclick', handleDoubleClick);
        canvas.addEventListener('mouseout', handleMouseOut);
        canvas.addEventListener('contextmenu', handleContextMenu);
        document.getElementById('findCoordsBtn').addEventListener('click', handleFindCoordinates);

        document.getElementById('addObjectBtn').addEventListener('click', openCoordsDialog);
        document.getElementById('togglePointsBtn').addEventListener('click', togglePointsVisibility);
        document.getElementById('rulerBtn').addEventListener('click', () => toggleMode('ruler'));
        document.getElementById('resetMeasurementBtn').addEventListener('click', resetMeasurement);
        drawObjectBtn.addEventListener('click', () => toggleMode('draw'));
        document.getElementById('cutObjectBtn').addEventListener('click', toggleCutTool);

        document.getElementById('intersectPointsBtn').addEventListener('click', toggleIntersectTool);

        finishDrawingBtn.addEventListener('click', finishDrawingAsLineOrPoint);
        toggleGeometryEditBtn.addEventListener('click', () => toggleMode('geometryEdit'));
        undoGeometryChangeBtn.addEventListener('click', undoLastGeometryChange);

        document.getElementById('importCoordsBtn').addEventListener('click', handleUniversalImport);
        document.getElementById('importFromFileBtn').addEventListener('click', handleImportFromFile);
        document.getElementById('closeDialogBtn').addEventListener('click', closeCoordsDialog);
        dialogOverlay.addEventListener('click', closeCoordsDialog);
        coordsDialog.addEventListener('click', (e) => e.stopPropagation());

        window.addEventListener('resize', () => {
             canvas.width = canvas.offsetWidth;
             canvas.height = canvas.offsetHeight;
             calculateBounds();
             redraw(true);
        });

        // --- ИЗМЕНЕНИЕ: Расширенный обработчик клавиатуры (Стрелки + Escape) ---
        document.addEventListener('keydown', (e) => {
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') {
                return;
            }

            const panStep = 50;
            const zoomStep = 1.2; 
            let handled = false;

            if (e.key === 'ArrowLeft') {
                offsetX += panStep;
                handled = true;
            } else if (e.key === 'ArrowRight') {
                offsetX -= panStep;
                handled = true;
            } else if (e.key === 'ArrowUp') {
                offsetY -= panStep;
                handled = true;
            } else if (e.key === 'ArrowDown') {
                offsetY += panStep;
                handled = true;
            } 
            else if (e.key === '+' || e.key === '=') {
                const cX = canvas.width / 2;
                const cY = canvas.height / 2;
                const dataPoint = inverseTransformCoord(cX, cY);

                if (isFinite(dataPoint.x) && isFinite(dataPoint.y)) {
                    let newScale = scale * zoomStep;
                    newScale = Math.max(1e-9, Math.min(newScale, 10000));
                    scale = newScale;

                    offsetX = cX - (dataPoint.y - cMinYGlob()) * scale;
                    offsetY = canvas.height - cY - (dataPoint.x - cMinXGlob()) * scale;
                    
                    updateViewInfo();
                    handled = true;
                }
            } 
            else if (e.key === '-' || e.key === '_') {
                const cX = canvas.width / 2;
                const cY = canvas.height / 2;
                const dataPoint = inverseTransformCoord(cX, cY);

                if (isFinite(dataPoint.x) && isFinite(dataPoint.y)) {
                    let newScale = scale / zoomStep;
                    newScale = Math.max(1e-9, Math.min(newScale, 10000));
                    scale = newScale;

                    offsetX = cX - (dataPoint.y - cMinYGlob()) * scale;
                    offsetY = canvas.height - cY - (dataPoint.x - cMinXGlob()) * scale;
                    
                    updateViewInfo();
                    handled = true;
                }
            }

            if (handled) {
                e.preventDefault();
                redraw(true);
                return;
            }

            if (e.key === 'Escape') {
                if (loaderContainer.style.display === 'flex') {
                    isNspdLoadCancelled = true;
                    showLoader(false);
                    showNotification("Загрузка отменена пользователем.", "warning", "hand-paper");
                    return;
                }
                if (isGeometryEditMode) {
                    deactivateGeometryEditMode();
                }
                if (isDrawingMode) {
                    cancelDrawing();
                }
                if (rulerMode) {
                    toggleMode('ruler');
                }
            }
        });

        document.getElementById('cancelLoadBtn').addEventListener('click', () => {
            isNspdLoadCancelled = true;
            showNotification("Отмена загрузки...", "warning");
            document.getElementById('cancelLoadBtn').style.display = 'none';
            loaderTextElement.textContent = "Остановка...";
        });
        
        document.getElementById('deleteAllObjectsBtn').addEventListener('click', deleteAllObjects);
        document.getElementById('importModeSelect').addEventListener('change', (e) => {
            localStorage.setItem('selectedImportMode', e.target.value);
        });
    }

    function activateGeometryEditMode() {
        if (selectedObjectIndex === -1) {
            showNotification("Сначала выберите объект для редактирования.", "warning", "hand-pointer");
            return false;
        }
        isGeometryEditMode = true;
        editingObjectIndex = selectedObjectIndex;
        geometryHistory = [];
        saveGeometryStateForUndo(editingObjectIndex);

        if (rulerMode) { rulerMode = false; measurementPanel.classList.remove('active'); rulerPoints = []; }
        if (isDrawingMode) { isDrawingMode = false; isDrawingActive = false; currentDrawingPoints = []; }

        showNotification(`Режим редактирования для "${userObjects[editingObjectIndex].name || 'Объект ' + userObjects[editingObjectIndex].id}". Клик на сегмент - добавить. ПКМ на точку - удалить.`, "info", "edit");
        redraw(true);
        return true;
    }

    function deactivateGeometryEditMode(showNotif = true) {
        if (!isGeometryEditMode) return;
        isGeometryEditMode = false;
        editingObjectIndex = -1;
        isMovingPoint = false;
        movedPointInfo = null;
        snappedToPointVisual = null;
        geometryHistory = [];

        if (showNotif) showNotification("Режим редактирования геометрии выключен.", "info", "edit");
        if (!rulerMode && !isDrawingMode) canvas.style.cursor = 'grab';
        redraw(true);
    }


   function toggleMode(modeToToggle) {
        if (modeToToggle !== 'ruler' && rulerMode) {
            rulerMode = false; measurementPanel.classList.remove('active'); rulerPoints = [];
        }
        if (modeToToggle !== 'draw' && isDrawingMode) {
            isDrawingMode = false; isDrawingActive = false; currentDrawingPoints = [];
        }
        if (modeToToggle !== 'geometryEdit' && isGeometryEditMode) {
            deactivateGeometryEditMode(false);
        }

        if (modeToToggle === 'ruler') {
            rulerMode = !rulerMode;
            if (rulerMode) {
                resetMeasurement(); measurementPanel.classList.add('active');
                showNotification('Режим измерения включен.', 'info', 'ruler');
                canvas.style.cursor = 'crosshair';
            } else {
                // --- ИЗМЕНЕНИЕ: Скрываем панель и сбрасываем точки при выключении ---
                measurementPanel.classList.remove('active');
                rulerPoints = [];
                // -------------------------------------------------------------------
                showNotification('Режим измерения выключен.', 'info', 'ruler');
            }
        } else if (modeToToggle === 'draw') {
            isDrawingMode = !isDrawingMode;
            if (isDrawingMode) activateDrawingMode();
            else cancelDrawing();
        } else if (modeToToggle === 'geometryEdit') {
            if (isGeometryEditMode) {
                deactivateGeometryEditMode();
            } else {
                activateGeometryEditMode();
            }
        }

        if (!rulerMode && !isDrawingMode && !isGeometryEditMode && !isMovingPoint) {
            canvas.style.cursor = 'grab';
        }
        updateToggleButtonStates();
        redraw(true);
    }


     function saveState() {
        try {
            const maxObjectsToSave = 50;
            const validObjects = userObjects.filter(o => o);
            const objectsToSave = validObjects.slice(-maxObjectsToSave);
            const state = {
                userObjects: objectsToSave, nextObjectId, nextColorIndex,
                view: hasValidView() ? { scale, offsetX, offsetY, minX, minY, maxX, maxY } : null,
                showPoints
            };
            localStorage.setItem('geoAnalyzerState', JSON.stringify(state));
        } catch (e) {
             if (e.name === 'QuotaExceededError') {
                  localStorage.removeItem('geoAnalyzerState');
                   showNotification("Хранилище переполнено. Старые данные удалены.", "warning", "hdd");
             } else { console.error("Ошибка сохранения состояния:", e); showNotification("Ошибка сохранения состояния.", "error", "save"); }
        }
    }

function addObjectInternal(contoursData, name, objectType, isMultiPart = false, subType = null) {
    if (!contoursData || contoursData.length === 0 || contoursData.every(c => !c || c.length === 0)) {
        if (!isMultiPart) showNotification("Не удалось добавить объект: нет контуров или они пусты.", "error", "exclamation-circle");
        return null;
    }

    const processedContours = contoursData.map(contour => {
        if (!contour || contour.length === 0) return null;
        const roundedContour = contour.map(p => ({ x: roundCoord(p.x), y: roundCoord(p.y) }));
        const validPoints = roundedContour.filter(p => p && isFinite(p.x) && isFinite(p.y));
        if (validPoints.length === 0) return null;
        return validPoints;
    }).filter(c => c !== null && c.length > 0);

    if (processedContours.length === 0) {
        if (!isMultiPart) showNotification("Не удалось добавить объект: нет валидных координат в контурах.", "error", "exclamation-circle");
        return null;
    }

    let finalObjectType = objectType;
    const firstValidContour = processedContours[0];
    if (firstValidContour.length < 3 && objectType === 'polygon') {
        finalObjectType = firstValidContour.length === 2 ? 'line' : 'point';
    } else if (firstValidContour.length < 2 && objectType === 'line') {
        finalObjectType = 'point';
    }
    if ((finalObjectType === 'line' || finalObjectType === 'polygon') && firstValidContour.length === 1) {
        finalObjectType = 'point';
    }

    const newId = nextObjectId++;
    const newColor = objectColors[nextColorIndex % objectColors.length]; nextColorIndex++;

    const newObject = {
        id: newId,
        name,
        type: finalObjectType,
        subType: subType,
        contours: processedContours,
        color: newColor,
        area: 0,
        perimeter: 0
    };
    
    updateObjectMetrics(newObject);

    userObjects.push(newObject);
    const newIndex = userObjects.length - 1;

    if (!isMultiPart) {
        updateObjectList();
        selectedObjectIndex = newIndex;
        calculateBounds();
        displayObjectInfo(selectedObjectIndex);
        setTimeout(() => { centerOnObject(newIndex, true); }, 50);
        saveState();
        redraw(true);
    }
    return newObject;
}

    function deleteObject(index) {
        if (index < 0 || index >= userObjects.length || !userObjects[index]) return;
        const obj = userObjects[index];
        const objectName = obj.name || `Объект ${obj.id}`;
        if (window.confirm(`Вы уверены, что хотите удалить "${objectName}"?`)) {
             if(isGeometryEditMode && editingObjectIndex === index) {
                deactivateGeometryEditMode(false);
            }
            userObjects.splice(index, 1);
            const wasSelected = (selectedObjectIndex === index);

            if (wasSelected) { selectedObjectIndex = -1; displayObjectInfo(-1); }
            else if (selectedObjectIndex > index) { selectedObjectIndex--; }

            if(editingObjectIndex > index) editingObjectIndex--;
            else if (editingObjectIndex === index) editingObjectIndex = -1;


            showNotification(`"${objectName}" удален`, "info", "trash-alt");
            updateObjectList();
            calculateBounds();
            if (!hasValidView()) {
                resetView();
                redraw(false);
            } else {
                 redraw(true);
            }
            saveState();
        }
    }
    async function renameObject(index, newName) {
         if (index < 0 || index >= userObjects.length || !userObjects[index] || !newName || !newName.trim()) {
              showNotification("Имя объекта не может быть пустым.", "warning", "exclamation-triangle"); return;
         }
         const finalName = newName.trim(); userObjects[index].name = finalName;
         displayObjectInfo(index); updateObjectList(); redraw(true);
         showNotification(`Объект переименован в "${finalName}"`, "success", "pencil-alt"); saveState();
    }

    function openCoordsDialog() {
        if (isDrawingMode || isMovingPoint || isGeometryEditMode) {
            showNotification("Завершите текущее действие перед импортом.", "warning", "pause-circle"); return;
        }
        coordsInput.value = ''; coordsDialog.style.display = 'block'; dialogOverlay.style.display = 'block';
        requestAnimationFrame(() => { dialogOverlay.classList.add('show'); coordsDialog.classList.add('show'); coordsInput.focus(); });
    }
    function closeCoordsDialog() {
        dialogOverlay.classList.remove('show'); coordsDialog.classList.remove('show');
        setTimeout(() => { coordsDialog.style.display = 'none'; dialogOverlay.style.display = 'none'; }, 300);
    }
    async function promptAndAddObjectInternal(contoursData, objectType, defaultName) {
        const name = await showNamePrompt(`Имя нового объекта (${defaultName}):`, defaultName || `Объект ${nextObjectId}`);
        if (name !== null) {
            // Ensure contoursData is an array of contours
            const contoursArray = Array.isArray(contoursData[0]) ? contoursData : [contoursData];
            return addObjectInternal(contoursArray, name, objectType, true);
        } else {
            showNotification(`Добавление "${defaultName || 'объекта'}" отменено.`, 'warning', 'times-circle');
            return null;
        }
    }
    
        // --- НОВАЯ ФУНКЦИЯ для заполнения нового селектора в модальном окне ---
function populateImportModeSelect() {
        const select = document.getElementById('importModeSelect');
        if (!select) return;

        // (Эта часть остается без изменений - она заполняет список)
        select.innerHTML = '<option value="xml">Из архива КПТ (XML файл)</option>';
        if (typeof COORDINATE_SYSTEMS !== 'undefined') {
            const mskSystems = COORDINATE_SYSTEMS.filter(sys => sys.value.startsWith('EPSG:') && sys.value !== 'EPSG:4326' && sys.value !== 'EPSG:3857');
            mskSystems.forEach(sys => {
                const option = document.createElement('option');
                option.value = sys.value;
                option.textContent = `EPSG3857 -> ${sys.text}`;
                select.appendChild(option);
            });
        }
        
        // --- ДОБАВЬТЕ ЭТОТ КОД ---
        // Загружаем и устанавливаем сохраненное значение
        const savedMode = localStorage.getItem('selectedImportMode');
        if (savedMode) {
            // Проверяем, существует ли такая опция в списке, на случай если список изменился
            if (select.querySelector(`option[value="${savedMode}"]`)) {
                select.value = savedMode;
            }
        }
    }

async function handleImportFromNspdAndConvertToMsk(cadNumbers, destScId) {
    closeCoordsDialog();
    if (cadNumbers.length > 100) {
        showNotification("Превышен лимит в 100 кадастровых номеров.", "error");
        return;
    }

    const destSystem = COORDINATE_SYSTEMS.find(s => s.value === destScId);
    if (!destSystem || !destSystem.def) {
        showNotification(`Не найдено определение для целевой СК: ${destScId}`, "error");
        return;
    }

    proj4.defs(destSystem.value, destSystem.def);
    if (typeof proj4.defs['EPSG:3857'] === 'undefined') {
         proj4.defs("EPSG:3857", COORDINATE_SYSTEMS.find(s => s.value === "EPSG:3857").def);
    }
    if (typeof proj4.defs['EPSG:4326'] === 'undefined') {
         proj4.defs("EPSG:4326", COORDINATE_SYSTEMS.find(s => s.value === "EPSG:4326").def);
    }

    let addedObjects = [];
    let errors = 0;
    
    isNspdLoadCancelled = false; 
    
    showLoader(true, `Подготовка к загрузке ${cadNumbers.length} участков...`);

    for (let i = 0; i < cadNumbers.length; i++) {
        if (isNspdLoadCancelled) {
            console.log("Загрузка прервана пользователем.");
            break; 
        }

        const kn = cadNumbers[i];
        showLoader(true, `Загрузка ${i + 1}/${cadNumbers.length}: ${kn}`);

        try {
            const feature = await fetchCadastralData(kn);
            if (!feature.geometry || !feature.geometry.coordinates) {
                throw new Error('У объекта нет координат в ЕГРН.');
            }

            // --- НАЧАЛО КЛЮЧЕВОГО ИЗМЕНЕНИЯ ---
            // Определяем subType на основе категории из ответа НСПД
            const categoryId = feature.properties.category;
            let subType = null;
            if (categoryId === 36368) { // ID для Земельных участков
                subType = 'land_record';
            } else if (categoryId === 36369) { // ID для Зданий
                subType = 'build_record';
            } else if (categoryId === 36383) { // ID для Сооружений
                subType = 'construction_record';
            }
            console.log(`[handleImportFromNspd] Для КН ${kn} определен subType: ${subType} (ID категории: ${categoryId})`);
            // --- КОНЕЦ КЛЮЧЕВОГО ИЗМЕНЕНИЯ ---
            
            const geometryType = feature.geometry.type;
            const polygonsData = geometryType === 'MultiPolygon' ? feature.geometry.coordinates : [feature.geometry.coordinates];
            
            const objectMskContours = [];
            polygonsData.forEach(polygonRings => {
                polygonRings.forEach(ring => {
                    const mskPoints = ring.map(coord_3857 => {
                        const wgs84 = proj4('EPSG:3857', 'EPSG:4326', coord_3857);
                        const msk = proj4('EPSG:4326', destSystem.value, wgs84);
                        
                        const finalX = msk[1] + (destSystem.offsetX || 0);
                        const finalY = msk[0] + (destSystem.offsetY || 0);

                        return { x: roundCoord(finalX), y: roundCoord(finalY) };
                    });
                    objectMskContours.push(mskPoints);
                });
            });

            if (objectMskContours.length > 0) {
                // --- НАЧАЛО КЛЮЧЕВОГО ИЗМЕНЕНИЯ ---
                // Передаем определенный subType в функцию создания объекта
                const newObj = addObjectInternal(objectMskContours, kn, "polygon", true, subType);
                // --- КОНЕЦ КЛЮЧЕВОГО ИЗМЕНЕНИЯ ---
                if (newObj) {
                    addedObjects.push(newObj);
                }
            } else {
                throw new Error('Не удалось извлечь контуры.');
            }

        } catch (error) {
            console.error(`Ошибка для КН ${kn}:`, error);
            showNotification(`Ошибка для ${kn}: ${error.message}`, "error");
            errors++;
        }

        if (i < cadNumbers.length - 1) {
            await new Promise(resolve => setTimeout(resolve, 500));
        }
    }

    showLoader(false);
    if (addedObjects.length > 0) {
        finalizeBatchAdd(addedObjects);
        showNotification(`Загружено ${addedObjects.length} участков. ${errors > 0 ? errors + ' с ошибками.' : ''}`, "success", "check-circle");
    } else if (errors > 0 && !isNspdLoadCancelled) {
        showNotification(`Не удалось загрузить участки. Ошибок: ${errors}.`, "error", "exclamation-triangle");
    }
}
    
    function isQuarterFormat(text) {
        if (!text) return false;
        // Проверяет формат XX:XX:XXXXXX или XX:XX:XXXXXXX
        const quarterRegex = /^\d{2}:\d{2}:(\d{6}|\d{7})$/;
        return quarterRegex.test(text.trim());
    }

    function showQuarterLoadOptionsDialog(quarterNumber) {
        const dialog = document.getElementById('quarterLoadOptionsDialog');
        const overlay = document.getElementById('dialogOverlay');
        const title = document.getElementById('quarterLoadOptionsTitle');
        const adjacentBtn = dialog.querySelector('button[data-load-type="adjacent"]');

        title.textContent = `Загрузка квартала ${quarterNumber}`;

        // Делаем кнопку "Смежные объекты" неактивной, если на карте пусто
        if (userObjects.length === 0) {
            adjacentBtn.disabled = true;
            adjacentBtn.style.opacity = '0.5';
            adjacentBtn.title = 'Эта опция доступна, когда на карте уже есть объекты';
        } else {
            adjacentBtn.disabled = false;
            adjacentBtn.style.opacity = '1';
            adjacentBtn.title = '';
        }
        
        // Удаляем старые обработчики, чтобы избежать многократных вызовов
        const newButtons = document.getElementById('quarterLoadOptionsButtons').cloneNode(true);
        document.getElementById('quarterLoadOptionsButtons').parentNode.replaceChild(newButtons, document.getElementById('quarterLoadOptionsButtons'));

        newButtons.querySelectorAll('button').forEach(button => {
            button.onclick = () => processQuarterLoad(quarterNumber, button.dataset.loadType);
        });

        document.getElementById('quarterLoadOptionsCancelBtn').onclick = closeQuarterLoadOptionsDialog;
        overlay.onclick = closeQuarterLoadOptionsDialog;
        dialog.style.display = 'block';
        overlay.classList.add('show');
    }

    function closeQuarterLoadOptionsDialog() {
        document.getElementById('quarterLoadOptionsDialog').style.display = 'none';
        document.getElementById('dialogOverlay').classList.remove('show');
    }
    
    

async function handleUniversalImport() {
    const inputText = coordsInput.value.trim();
    if (!inputText) {
        showNotification("Поле ввода пустое.", "warning", "exclamation-triangle");
        return;
    }

    const lines = inputText.split('\n').map(line => line.trim()).filter(line => line);
    const isSingleLine = lines.length === 1;
    
    // Проверяем, являются ли ВСЕ строки кадастровыми номерами
    const isKnList = lines.length > 0 && lines.every(line => isValidCadastralNumberFormat(line));
    
    const isSingleQuarter = isSingleLine && isQuarterFormat(lines[0]);

    // Логика для "КН + Координаты" (Сооружение).
    // Срабатывает ТОЛЬКО если первая строка КН, строк > 1, И вторая строка НЕ КН (значит координаты)
    if (lines.length > 1 && isValidCadastralNumberFormat(lines[0]) && !isValidCadastralNumberFormat(lines[1])) {
        const cadNumber = lines[0];
        const coordinatesText = lines.slice(1).join('\n');
        
        console.log(`[handleUniversalImport] Обнаружен блок с КН (${cadNumber}) и координатами.`);
        
        closeCoordsDialog();
        
        const parsedContours = parseCoordinatesFromText(coordinatesText);
        if (parsedContours && parsedContours.length > 0) {
            const newObj = addObjectInternal(parsedContours, cadNumber, "polygon", true, 'construction_record');
            if (newObj) {
                finalizeBatchAdd([newObj]);
            }
        } else {
            showNotification("Не удалось распознать координаты после кадастрового номера.", "error");
        }
        return;
    }

    if (isSingleQuarter) {
        closeCoordsDialog();
        showQuarterLoadOptionsDialog(lines[0]);
        return; 
    }

    // Если это список КН (один или много)
    if (isKnList) {
        const importMode = document.getElementById('importModeSelect').value;
        if (importMode === 'xml') {
            await handleImportFromCadNumbers(lines);
        } else {
            // Лимит можно проверить здесь, если нужно
            if (lines.length > 20) {
                 if(!confirm(`В списке ${lines.length} объектов. Загрузка может занять время. Продолжить?`)) return;
            }
            await handleImportFromNspdAndConvertToMsk(lines, importMode);
        }
    } else {
        // Иначе пытаемся парсить просто как текст координат
        await handleImportFromTextareaCoordinates(inputText);
    }
}


async function processQuarterLoad(quarterNumber, filterType) {
    closeQuarterLoadOptionsDialog();

    // Определяем источник данных из основного диалогового окна
    const importMode = document.getElementById('importModeSelect').value;

    if (importMode === 'xml') {
        // --- Существующая логика для загрузки из XML-архива КПТ ---
        showLoader(true, `Загрузка данных КПТ для квартала ${quarterNumber}...`);
        try {
            const xmlContent = await fetchKptXmlContent(quarterNumber);
            if (!xmlContent) {
                showLoader(false);
                return;
            }

            showLoader(true, `Обработка XML, фильтр: ${filterType}...`);
            await new Promise(resolve => setTimeout(resolve, 50));
            
            const objectsToAdd = extractObjectsFromXml(xmlContent, filterType);
            
            if (objectsToAdd.length === 0) {
                showNotification(`В файле КПТ для квартала ${quarterNumber} не найдено объектов, соответствующих фильтру.`, "info");
                showLoader(false);
                return;
            }

            let addedObjectsBatch = [];
            objectsToAdd.forEach(objData => {
                const isPolygon = objData.contours.some(c => c.length >= 3);
                const objectType = isPolygon ? 'polygon' : (objData.contours.some(c => c.length >= 2) ? 'line' : 'point');
                const newObj = addObjectInternal(objData.contours, objData.name, objectType, true);
                if (newObj) {
                    addedObjectsBatch.push(newObj);
                }
            });

            if (addedObjectsBatch.length > 0) {
                finalizeBatchAdd(addedObjectsBatch);
                showNotification(`Загружено ${addedObjectsBatch.length} объектов из файла КПТ ${quarterNumber}.`, "success");
            }
        } catch (error) {
            console.error("Ошибка при загрузке квартала из КПТ XML:", error);
            showNotification(`Ошибка загрузки из КПТ: ${error.message}`, "error");
        } finally {
            showLoader(false);
        }
    } else {

        if (filterType === 'adjacent') {
            showNotification(`Загрузка смежных объектов не поддерживается.`, "warning");
            return;
        }
        // 'importMode' в этом случае является ID целевой системы координат, например 'EPSG:6331602'
        await handleImportQuarterFromNspdAndConvertToMsk(quarterNumber, filterType, importMode);
    }
}

// НОВАЯ ФУНКЦИЯ
async function handleImportQuarterFromNspdAndConvertToMsk(quarterNumber, filterType, destScId) {
    isNspdLoadCancelled = false;
    showLoader(true, `Загрузка данных EPSG3857 для квартала ${quarterNumber}...`);

    try {
        const destSystem = COORDINATE_SYSTEMS.find(s => s.value === destScId);
        if (!destSystem || !destSystem.def) {
            throw new Error(`Не найдено определение для целевой СК: ${destScId}`);
        }
        proj4.defs(destSystem.value, destSystem.def);
        if (typeof proj4.defs['EPSG:3857'] === 'undefined') {
             proj4.defs("EPSG:3857", COORDINATE_SYSTEMS.find(s => s.value === "EPSG:3857").def);
        }
        if (typeof proj4.defs['EPSG:4326'] === 'undefined') {
             proj4.defs("EPSG:4326", COORDINATE_SYSTEMS.find(s => s.value === "EPSG:4326").def);
        }

        showLoader(true, `Запрос геометрии квартала ${quarterNumber}...`);
        if (isNspdLoadCancelled) return; 

        const quarterGeomUrl = `https://nspd.gov.ru/api/geoportal/v2/search/geoportal?thematicSearchId=2&query=${quarterNumber}`;
        const quarterGeomData = await fetchNspd(quarterGeomUrl);
        const quarterFeature = quarterGeomData?.data?.features?.[0];
        if (!quarterFeature || !quarterFeature.geometry) {
            throw new Error(`Не найдена геометрия для квартала ${quarterNumber}`);
        }
        
        const categories = [];
        if (filterType === 'zu' || filterType === 'all') categories.push({ "id": 36368, "name": "land_record" });
        if (filterType === 'oks' || filterType === 'all') categories.push({ "id": 36369, "name": "build_record" });
        if (filterType === 'construction' || filterType === 'all') categories.push({ "id": 36383, "name": "construction_record" });
        
        if (categories.length === 0) {
             throw new Error(`Неизвестный тип фильтра: ${filterType}`);
        }
        
        showLoader(true, `Загрузка объектов (${filterType}) в квартале ${quarterNumber}...`);
        if (isNspdLoadCancelled) return; 

        const requestBody = {
            "geom": { "type": "FeatureCollection", "features": [{ "type": "Feature", "geometry": quarterFeature.geometry, "properties": {} }] },
            "categories": categories.map(c => ({ "id": c.id }))
        };
        const intersectsUrl = 'https://nspd.gov.ru/api/geoportal/v1/intersects?typeIntersect=fullObject';
        
        const intersectsResponse = await fetch(intersectsUrl, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json', 'Referer': 'https://nspd.gov.ru/' },
            body: JSON.stringify(requestBody)
        });
        if (!intersectsResponse.ok) throw new Error(`Ошибка при запросе объектов: ${intersectsResponse.statusText}`);
        const objectsData = await intersectsResponse.json();
        
        const featuresToConvert = objectsData.features || [];
        if (featuresToConvert.length === 0) {
            showNotification(`В квартале ${quarterNumber} не найдено объектов типа '${filterType}' `, "info");
            return;
        }

        showLoader(true, `Конвертация ${featuresToConvert.length} объектов...`);
        let addedObjectsBatch = [];
        let errors = 0;

        for (const feature of featuresToConvert) {
            if (isNspdLoadCancelled) {
                console.log("Конвертация объектов квартала прервана пользователем.");
                break;
            }

            try {
                const cadNumber = feature.properties.descr || feature.properties.options?.cad_num || `Объект без КН`;
                if (!feature.geometry || !feature.geometry.coordinates) {
                    console.warn(`Пропущен объект ${cadNumber} - нет геометрии.`);
                    continue;
                }

                const categoryId = feature.properties.category;
                const categoryInfo = categories.find(c => c.id === categoryId);
                const subType = categoryInfo ? categoryInfo.name : null;

                const geometryType = feature.geometry.type;
                const coordinatesArray = feature.geometry.coordinates;

                // --- НАЧАЛО ИЗМЕНЕНИЙ ---
                // Логика обработки координат для разных типов геометрии
                let rings = [];
                if (geometryType === "Polygon") {
                    // coordinates для Polygon это [ [ [x,y],... ], [ [x,y],... ] ] (внешний и дырки)
                    // Мы берем все эти массивы как отдельные контуры.
                    rings = coordinatesArray;
                } else if (geometryType === "MultiPolygon") {
                    // coordinates для MultiPolygon это [ [ [ [x,y],... ] ] , [ [ [ [x,y],... ] ] ] ]
                    // Уплощаем до уровня отдельных контуров
                    rings = coordinatesArray.flat(1);
                } else {
                    console.warn(`Неподдерживаемый тип геометрии "${geometryType}" для объекта ${cadNumber}`);
                    continue;
                }

                const objectMskContours = [];
                rings.forEach(ring => {
                    if (!ring || ring.length === 0) return;
                    const mskPoints = ring.map(coord_3857 => {
                        const wgs84 = proj4('EPSG:3857', 'EPSG:4326', coord_3857);
                        const msk = proj4('EPSG:4326', destSystem.value, wgs84);
                        const finalX = msk[1] + (destSystem.offsetX || 0);
                        const finalY = msk[0] + (destSystem.offsetY || 0);
                        return { x: roundCoord(finalX), y: roundCoord(finalY) };
                    });
                    if (mskPoints.length > 0) {
                        objectMskContours.push(mskPoints);
                    }
                });
                // --- КОНЕЦ ИЗМЕНЕНИЙ ---

                if (objectMskContours.length > 0) {
                    const newObj = addObjectInternal(objectMskContours, cadNumber, "polygon", true, subType);
                    if (newObj) {
                        addedObjectsBatch.push(newObj);
                    }
                } else {
                     errors++;
                }
            } catch (convertError) {
                errors++;
                console.error(`Ошибка конвертации для объекта`, feature, convertError);
            }
        }
        
        if (addedObjectsBatch.length > 0) {
            finalizeBatchAdd(addedObjectsBatch);
            showNotification(`Загружено и конвертировано ${addedObjectsBatch.length} объектов ${errors > 0 ? errors + ' с ошибками.' : ''}`, "success");
        } else if (errors > 0 && !isNspdLoadCancelled) {
             showNotification(`Не удалось загрузить или конвертировать объекты. Ошибок: ${errors}.`, "error");
        }

    } catch (error) {
        if (!isNspdLoadCancelled) { 
            console.error("Ошибка при загрузке квартала:", error);
            showNotification(`Ошибка загрузки: ${error.message}`, "error");
        }
    } finally {
        if (!isNspdLoadCancelled) { 
            showLoader(false); 
        }
    }
}


async function handleFindCoordinates() {
        const inputText = coordsInput.value.trim();
        if (!inputText) {
            showNotification("Поле ввода пустое.", "warning", "exclamation-triangle");
            return;
        }

        // Парсим координаты (используем существующую функцию)
        const parsedContours = parseCoordinatesFromText(inputText);
        
        if (parsedContours && parsedContours.length > 0) {
            closeCoordsDialog();
            
            // Собираем ВСЕ точки из всех контуров в один плоский массив
            const allPoints = [];
            parsedContours.forEach(contour => {
                contour.forEach(p => allPoints.push(p));
            });

            if (allPoints.length === 0) return;

            showLoader(true, `Создание ${allPoints.length} точек...`);

            // Добавляем каждую точку как отдельный объект
            // Используем subType = 'crosshair' для особого стиля отрисовки
            const addedBatch = [];
            let counter = 1;
            
            // Чтобы не вешать браузер при тысячах точек, делаем небольшую задержку
            await new Promise(resolve => setTimeout(resolve, 50));

            allPoints.forEach(pt => {
                // Создаем контур из одной точки
                const singlePointContour = [[{ x: pt.x, y: pt.y }]];
                const name = `Тчк ${counter++}`;
                
                // subType: 'crosshair' будет сигналом для drawObjects рисовать прицел
                const newObj = addObjectInternal(singlePointContour, name, 'point', true, 'crosshair');
                if (newObj) addedBatch.push(newObj);
            });

            if (addedBatch.length > 0) {
                finalizeBatchAdd(addedBatch);
                showNotification(`Добавлено ${addedBatch.length} точек поиска.`, "success", "crosshairs");
            }
            
            showLoader(false);
        } else {
            showNotification("Не удалось распознать координаты.", "error");
        }
    }
    
    
    
function extractObjectsFromXml(xmlContent, filterType) {
    // --- НАЧАЛО БЛОКА ЛОГИРОВАНИЯ ---
    console.log(`%c[DEBUG] Запуск extractObjectsFromXml. Режим фильтрации: "${filterType}"`, 'color: blue; font-weight: bold;');
    // --- КОНЕЦ БЛОКА ЛОГИРОВАНИЯ ---

    const parser = new DOMParser();
    const xmlDoc = parser.parseFromString(xmlContent, "text/xml");
    const extracted = [];
    const TOLERANCE_DIGITS = 2;

    if (filterType === 'adjacent') {
        // --- Логика ТОЛЬКО для режима "Смежные" ---
        console.log('%c[ADJACENT] Активирован режим поиска смежных объектов.', 'color: purple;');

        if (userObjects.length === 0) {
            showNotification("Для загрузки смежных объектов на карте должен быть хотя бы один объект.", "warning");
            console.warn('[ADJACENT] На карте нет объектов для сравнения. Прерывание.');
            return [];
        }
        
        console.log(`[ADJACENT] Объектов на карте для проверки: ${userObjects.length}`);

        // 1. Собираем все точки существующих объектов в Set
        const existingPoints = new Set();
        userObjects.forEach(obj => {
            if (!obj.contours) return;
            obj.contours.forEach(contour => {
                if (!contour) return;
                contour.forEach(p => {
                    if (p && isFinite(p.x) && isFinite(p.y)) {
                        existingPoints.add(`${p.x.toFixed(TOLERANCE_DIGITS)}_${p.y.toFixed(TOLERANCE_DIGITS)}`);
                    }
                });
            });
        });
        
        console.log(`[ADJACENT] Собрано уникальных точек с карты для сравнения: ${existingPoints.size}`);
        if (existingPoints.size === 0) {
             console.error('[ADJACENT] КРИТИЧЕСКАЯ ОШИБКА: Объекты на карте есть, но не удалось собрать их точки!');
             return [];
        }

        // 2. Извлекаем ВСЕ объекты из XML для проверки
        const allRecordsFromXml = xmlDoc.querySelectorAll('land_record, build_records build_record, construction_records construction_record');
        console.log(`[ADJACENT] Найдено в XML файле для проверки: ${allRecordsFromXml.length} объектов.`);

        allRecordsFromXml.forEach(record => {
            const cadNumber = getElementValueFromNode(record, 'object > common_data > cad_number');
            if (!cadNumber) return;

            console.log(`[ADJACENT] --- Проверка объекта из XML: ${cadNumber} ---`);

            const contours = extractCoordinatesFromXMLNode(record);
            if (contours.length === 0) {
                console.log(`[ADJACENT] У объекта ${cadNumber} не найдено координат. Пропуск.`);
                return;
            }

            let isAdjacent = false;
            let matchingPoint = null;

            // 3. Проверяем каждый объект из XML на наличие хотя бы одной общей точки
            for (const newContour of contours) {
                if (!newContour) continue;
                for (const newPoint of newContour) {
                    const pointKey = `${newPoint.x.toFixed(TOLERANCE_DIGITS)}_${newPoint.y.toFixed(TOLERANCE_DIGITS)}`;
                    if (existingPoints.has(pointKey)) {
                        isAdjacent = true;
                        matchingPoint = pointKey; // Запоминаем точку, на которой нашли совпадение
                        break;
                    }
                }
                if (isAdjacent) break;
            }

            // 4. Если объект был помечен как смежный, добавляем его в результат
            if (isAdjacent) {
                console.log(`%c[ADJACENT] РЕШЕНИЕ: Добавить объект ${cadNumber}. Найдена общая точка: ${matchingPoint}`, 'color: green;');
                extracted.push({
                    name: cadNumber,
                    contours: contours
                });
            } else {
                 console.log(`%c[ADJACENT] РЕШЕНИЕ: Пропустить объект ${cadNumber}. Общих точек не найдено.`, 'color: red;');
            }
        });
        
        console.log(`%c[DEBUG] Завершение extractObjectsFromXml. Всего для добавления: ${extracted.length} смежных объектов.`, 'color: blue; font-weight: bold;');
        return extracted;

    } else {
        // --- Логика для ВСЕХ ОСТАЛЬНЫХ режимов ---
        console.log(`[DEBUG] Активирован режим фильтрации "${filterType}".`);

        const processRecords = (records, objectCategory) => {
            if (filterType !== 'all' && filterType !== objectCategory) return;
            console.log(`[DEBUG] Обработка ${records.length} записей для категории "${objectCategory}".`);
            records.forEach(record => {
                const cadNumber = getElementValueFromNode(record, 'object > common_data > cad_number');
                if (!cadNumber) return;
                const contours = extractCoordinatesFromXMLNode(record);
                if (contours.length > 0) {
                    extracted.push({ name: cadNumber, contours: contours });
                }
            });
        };

        processRecords(xmlDoc.querySelectorAll('land_record'), 'zu');
        processRecords(xmlDoc.querySelectorAll('build_records build_record'), 'oks');
        processRecords(xmlDoc.querySelectorAll('construction_records construction_record'), 'construction');

        console.log(`%c[DEBUG] Завершение extractObjectsFromXml. Всего для добавления: ${extracted.length} объектов.`, 'color: blue; font-weight: bold;');
        return extracted;
    }
}

  function onSegment(p, q, r, tolerance) {
        return (q.x <= Math.max(p.x, r.x) + tolerance && q.x >= Math.min(p.x, r.x) - tolerance &&
                q.y <= Math.max(p.y, r.y) + tolerance && q.y >= Math.min(p.y, r.y) - tolerance);
    }

    function orientation(p, q, r, tolerance) {
        const val = (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
        if (Math.abs(val) < tolerance) return 0; // Коллинеарны
        return (val > 0) ? 1 : 2; // По часовой или против часовой стрелки
    }

    function segmentsCoincide(p1, q1, p2, q2, tolerance = 0.01) {
        // Проверяем, что все 4 точки коллинеарны
        if (orientation(p1, q1, p2, tolerance) !== 0 ||
            orientation(p1, q1, q2, tolerance) !== 0 ||
            orientation(p2, q2, p1, tolerance) !== 0 ||
            orientation(p2, q2, q1, tolerance) !== 0) {
            return false;
        }

        // Проверяем, что отрезки пересекаются (накладываются)
        if (onSegment(p1, p2, q1) || onSegment(p1, q2, q1) ||
            onSegment(p2, p1, q2) || onSegment(p2, q1, q2)) {
            return true;
        }

        return false;
    }
    
    
async function fetchKptXmlContent(quarterNumber) {
    const serverQuarterPrefix = quarterNumber.replace(/:/g, '_');
    try {
        const responseList = await fetch(`${STORAGE_API_URL}/${BUCKET_NAME}?search=${serverQuarterPrefix}`);
        if (!responseList.ok) throw new Error(`Ошибка сети: ${responseList.statusText}`);
        
        const fileList = await responseList.json();
        if (!fileList || fileList.length === 0) throw new Error(`КПТ для квартала ${quarterNumber} не найдены.`);

        const matchingFiles = fileList.filter(f => f.name.startsWith(serverQuarterPrefix) && f.name.toLowerCase().endsWith('.zip'));
        if (matchingFiles.length === 0) throw new Error(`Архивы КПТ для квартала ${quarterNumber} не найдены.`);

        const latestFile = matchingFiles.sort((a, b) => b.name.localeCompare(a.name))[0];
        
        const responseDownload = await fetch(`${STORAGE_API_URL}/${BUCKET_NAME}/${latestFile.name}`);
        if (!responseDownload.ok) throw new Error(`Ошибка загрузки файла: ${responseDownload.statusText}`);
        
        const blob = await responseDownload.blob();
        const zip = await JSZip.loadAsync(blob);
        
        let xmlFileEntry = null;
        for (const fileNameInZip in zip.files) {
            if (fileNameInZip.toLowerCase().endsWith('.xml') && !zip.files[fileNameInZip].dir) {
                xmlFileEntry = zip.files[fileNameInZip];
                break;
            }
        }
        if (!xmlFileEntry) throw new Error("XML-файл не найден в архиве.");

        return await xmlFileEntry.async('string');

    } catch (error) {
        throw new Error(error.message); // Перебрасываем ошибку для обработки в `processQuarterLoad`
    }
}

// Новые функции для расчета смежности по Bbox
function calculateObjectsBoundingBox(objects) {
    if (!objects || objects.length === 0) return null;
    let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
    let hasPoints = false;
    objects.forEach(obj => {
        if (!obj.contours) return;
        obj.contours.forEach(contour => {
            if (!contour) return;
            contour.forEach(p => {
                if (p && isFinite(p.x) && isFinite(p.y)) {
                    minX = Math.min(minX, p.x);
                    minY = Math.min(minY, p.y);
                    maxX = Math.max(maxX, p.x);
                    maxY = Math.max(maxY, p.y);
                    hasPoints = true;
                }
            });
        });
    });
    return hasPoints ? { minX, minY, maxX, maxY } : null;
}

function doBoundingBoxesIntersect(box1, box2) {
    if (!box1 || !box2) return false;
    return (
        box1.minX <= box2.maxX &&
        box1.maxX >= box2.minX &&
        box1.minY <= box2.maxY &&
        box1.maxY >= box2.minY
    );
}

    async function handleImportFromTextareaCoordinates(text) {
         const parsedContours = parseCoordinatesFromText(text); // Returns array of contours
         if (parsedContours && parsedContours.length > 0) {
            closeCoordsDialog();
            let addedObjects = [];
            for (let i = 0; i < parsedContours.length; i++) {
                const contour = parsedContours[i];
                if (contour && contour.length > 0) {
                     const isClosed = contour.length >= 3 &&
                                   Math.abs(contour[0].x - contour[contour.length - 1].x) < 0.001 &&
                                   Math.abs(contour[0].y - contour[contour.length - 1].y) < 0.001;
                    let objectType = isClosed ? 'polygon' : (contour.length >= 2 ? 'line' : 'point');
                    // For text input, we treat each block as a separate object, so pass [contour]
                    const newObj = await promptAndAddObjectInternal([contour], objectType, `Участок  ${nextObjectId -1}`); // -1 because nextObjectId was already incremented
                    if(newObj) addedObjects.push(newObj);
                }
            }
            if(addedObjects.length > 0) {
                finalizeBatchAdd(addedObjects);
            }

         } else { showNotification("Не удалось распознать валидные координаты X Y.", "error", "exclamation-circle"); }
    }


    async function handleImportFromFile() {
         const fileInput = document.createElement('input'); fileInput.type = 'file'; fileInput.accept = '.txt,.csv';
         fileInput.onchange = async (e) => {
             const file = e.target.files[0]; if (!file) return;
             const baseName = file.name.split('.').slice(0, -1).join('.') || `Файл ${nextObjectId}`;
             const reader = new FileReader();
             reader.onload = async (event) => {
                 const content = event.target.result;
                 const parsedContours = parseCoordinatesFromText(content);
                  if (parsedContours && parsedContours.length > 0) {
                      closeCoordsDialog();
                      let addedObjects = [];
                      for (let i = 0; i < parsedContours.length; i++) {
                          const contour = parsedContours[i];
                           if (contour && contour.length > 0) {
                               const isClosed = contour.length >= 3 &&
                                   Math.abs(contour[0].x - contour[contour.length - 1].x) < 0.001 &&
                                   Math.abs(contour[0].y - contour[contour.length - 1].y) < 0.001;
                               let objectType = isClosed ? 'polygon' : (contour.length >= 2 ? 'line' : 'point');
                               const newObj = await promptAndAddObjectInternal([contour], objectType, `${baseName}${parsedContours.length > 1 ? '_'+(i+1) : ''}`);
                               if(newObj) addedObjects.push(newObj);
                           }
                      }
                      if(addedObjects.length > 0) {
                          finalizeBatchAdd(addedObjects);
                      }
                  } else { showNotification('Не удалось найти валидные координаты в файле.', 'error', 'exclamation-circle'); }
             };
             reader.onerror = () => { showNotification('Ошибка чтения файла.', 'error', 'exclamation-circle'); };
             reader.readAsText(file);
         };
         fileInput.click();
    }

    function parseCoordinatesFromText(text) {
        const lines = text.split('\n');
        const contours = [];
        let currentContour = [];
        lines.forEach(line => {
            line = line.trim().replace(/,/g, '.');
            if (line === '') { // Пустая строка разделяет контуры
                if (currentContour.length > 0) {
                    contours.push(currentContour);
                    currentContour = [];
                }
            } else {
                const parts = line.split(/[\s\t]+/);
                if (parts.length >= 2) {
                    let x = parseFloat(parts[0]);
                    let y = parseFloat(parts[1]);
                     if (!isFinite(x) || !isFinite(y)) { // Try swapping if first parse failed
                         x = parseFloat(parts[1]);
                         y = parseFloat(parts[0]);
                     }
                    if (isFinite(x) && isFinite(y)) {
                        currentContour.push({ x: roundCoord(x), y: roundCoord(y) });
                    }
                }
            }
        });
        if (currentContour.length > 0) { // Добавляем последний контур, если он не пустой
            contours.push(currentContour);
        }
        return contours.filter(c => c.length > 0); // Возвращаем только непустые контуры
    }

    function showNamePrompt(title, initialValue = '') {
        return new Promise((resolve) => {
            namePromptTitle.textContent = title; namePromptInput.value = initialValue;
            namePromptDialog.classList.add('show'); namePromptOverlay.classList.add('show');
            namePromptInput.focus(); namePromptInput.select();
            let resolved = false;
            const cleanupAndResolve = (value) => { if (resolved) return; resolved = true; namePromptSaveBtn.onclick = null; namePromptCancelBtn.onclick = null; namePromptOverlay.onclick = null; namePromptInput.onkeydown = null; namePromptDialog.classList.remove('show'); namePromptOverlay.classList.remove('show'); resolve(value); };
            const handleSave = () => { const name = namePromptInput.value.trim(); if (name) cleanupAndResolve(name); else { showNotification("Имя не может быть пустым.", "warning"); namePromptInput.focus(); } };
            const handleCancel = () => cleanupAndResolve(null);
            const handleKeydown = (e) => { if (e.key === 'Enter') { e.preventDefault(); handleSave(); } else if (e.key === 'Escape') handleCancel(); };
            namePromptSaveBtn.onclick = handleSave; namePromptCancelBtn.onclick = handleCancel; namePromptOverlay.onclick = handleCancel; namePromptInput.onkeydown = handleKeydown;
        });
    }
    function calculatePolygonArea(polygon) {
        let area = 0; const n = polygon.length; if (n < 3) return 0;
        for (let i = 0; i < n; i++) {
            const p1 = polygon[i]; const p2 = polygon[(i + 1) % n];
            if (!p1 || !p2 || !isFinite(p1.x) || !isFinite(p1.y) || !isFinite(p2.x) || !isFinite(p2.y)) return 0;
            area += (p1.x * p2.y - p2.x * p1.y);
        }
        return roundCoord(Math.abs(area / 2.0));
    }
    function calculatePolygonPerimeter(polygon, isClosed = true) {
        let length = 0; const n = polygon.length; if (n < 1) return 0; if (n === 1) return 0;
        for (let i = 0; i < n - 1; i++) {
            const p1 = polygon[i]; const p2 = polygon[i + 1];
            if (!p1 || !p2 || !isFinite(p1.x) || !isFinite(p1.y) || !isFinite(p2.x) || !isFinite(p2.y)) return NaN;
            const dist = calculateDistance(p1,p2); if (isNaN(dist)) return NaN; length += dist;
        }
        if (isClosed && n >= 3) {
            const p1 = polygon[n - 1]; const p2 = polygon[0];
            // Ensure points are valid before calculating distance.
            if (!p1 || !p2 || !isFinite(p1.x) || !isFinite(p1.y) || !isFinite(p2.x) || !isFinite(p2.y)) return NaN;
             // Check if first and last points are indeed the same for a closed polygon before adding last segment.
            const PRECISION_THRESHOLD = 0.001;
            if (Math.abs(p1.x - p2.x) > PRECISION_THRESHOLD || Math.abs(p1.y - p2.y) > PRECISION_THRESHOLD) {
                // This case implies the polygon was not properly closed by having the last point identical to the first.
                // The updateObjectMetrics function should handle closing it.
                // For perimeter calculation, we should calculate distance if they are meant to be connected.
                 const dist = calculateDistance(p1, p2); if (isNaN(dist)) return NaN; length += dist;
            }
        }
        return roundCoord(length);
    }
   function checkIntersection(poly1, poly2) {
    if (!poly1 || poly1.length < 3 || !poly2 || poly2.length < 3) return { intersects: false, contains: false, containedBy: false, sharedVertices: 0 };
    let min1x=Infinity,min1y=Infinity,max1x=-Infinity,max1y=-Infinity,v1=false;
    let min2x=Infinity,min2y=Infinity,max2x=-Infinity,max2y=-Infinity,v2=false;
    poly1.forEach(p => { if(p&&isFinite(p.x)&&isFinite(p.y)){min1x=Math.min(min1x,p.x);min1y=Math.min(min1y,p.y);max1x=Math.max(max1x,p.x);max1y=Math.max(max1y,p.y);v1=true;} });
    poly2.forEach(p => { if(p&&isFinite(p.x)&&isFinite(p.y)){min2x=Math.min(min2x,p.x);min2y=Math.min(min2y,p.y);max2x=Math.max(max2x,p.x);max2y=Math.max(max2y,p.y);v2=true;} });
    if(!v1||!v2) return { intersects: false, contains: false, containedBy: false, sharedVertices: 0 };
    const sharedVertices = countSharedVertices(poly1, poly2);
    if(max1x < min2x || max2x < min1x || max1y < min2y || max2y < min1y) {
        return { intersects: sharedVertices > 0, contains: false, containedBy: false, sharedVertices };
    }
    let intersects=false;
    for(const p1 of poly1){if(p1&&isFinite(p1.x)&&isFinite(p1.y)&&isPointInPolygon(p1,poly2)){intersects=true;break;}}
    if(!intersects){for(const p2 of poly2){if(p2&&isFinite(p2.x)&&isFinite(p2.y)&&isPointInPolygon(p2,poly1)){intersects=true;break;}}}
    let contains=false, containedBy=false;
    if(intersects || !(max1x < min2x || max2x < min1x || max1y < min2y || max2y < min1y)) {
        contains = poly2.every(p => (p && isFinite(p.x) && isFinite(p.y)) ? isPointInPolygon(p, poly1) : true);
        containedBy = poly1.every(p => (p && isFinite(p.x) && isFinite(p.y)) ? isPointInPolygon(p, poly2) : true);
    }
    if(contains && containedBy){ contains = false; containedBy = false; intersects = true; }
    if(containedBy || contains) { intersects = true; }
    return { intersects, contains, containedBy, sharedVertices };
}
    function isPointInPolygon(point, polygon) {
        if (!polygon || polygon.length < 3 || !point || !isFinite(point.x) || !isFinite(point.y)) return false;
        let inside = false;
        const ptX = point.x;
        const ptY = point.y;
        for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
            const pi = polygon[i], pj = polygon[j];
            if (!pi || !pj || !isFinite(pi.x) || !isFinite(pi.y) || !isFinite(pj.x) || !isFinite(pj.y)) continue;
            const xi = pi.x, yi = pi.y;
            const xj = pj.x, yj = pj.y;
            if ((xi === ptX && yi === ptY) || (xj === ptX && yj === ptY)) return true;
            const onHorizontal = (Math.abs(yi - ptY) < 1e-9 && Math.abs(yj - ptY) < 1e-9) && (ptX >= Math.min(xi, xj) - 1e-9 && ptX <= Math.max(xi, xj) + 1e-9);
            const onVertical = (Math.abs(xi - ptX) < 1e-9 && Math.abs(xj - ptX) < 1e-9) && (ptY >= Math.min(yi, yj) - 1e-9 && ptY <= Math.max(yi, yj) + 1e-9);
            if (onHorizontal || onVertical) return true;
            const intersect = ((yi > ptY) !== (yj > ptY)) && (ptX < (xj - xi) * (ptY - yi) / (yj - yi) + xi);
            if (intersect) inside = !inside;
        }
        return inside;
    }
    function getContourCentroid(contour) {
        if (!contour || contour.length === 0) return { x: NaN, y: NaN };
        let sumX = 0, sumY = 0; let validPoints = 0;
        contour.forEach(p => { if (p && isFinite(p.x) && isFinite(p.y)) { sumX += p.x; sumY += p.y; validPoints++; } });
        if (validPoints === 0) return { x: NaN, y: NaN };
        return { x: roundCoord(sumX / validPoints), y: roundCoord(sumY / validPoints) };
    }
    const transformCoord = (dataX, dataY) => {
        const cH = canvas.height || 0;
        const cX = offsetX + (dataY - cMinYGlob()) * scale;
        const cY = cH - (offsetY + (dataX - cMinXGlob()) * scale);
        return [cX, cY];
    };
    const inverseTransformCoord = (canvasX, canvasY) => {
        const cH = canvas.height || 0;
        if (Math.abs(scale) < 1e-9) return { x: NaN, y: NaN };
        const dX_raw = cMinXGlob() + (cH - canvasY - offsetY) / scale;
        const dY_raw = cMinYGlob() + (canvasX - offsetX) / scale;
        return { x: roundCoord(dX_raw), y: roundCoord(dY_raw) };
    };

    function redraw(preserveTransform = false) {
        if (canvas.width !== canvas.offsetWidth || canvas.height !== canvas.offsetHeight) {
            canvas.width = canvas.offsetWidth; canvas.height = canvas.offsetHeight;
            if (!preserveTransform) { calculateBounds(); if (!hasValidView()) resetView(); }
        }
        ctx.setTransform(1, 0, 0, 1, 0, 0); ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = 'white'; ctx.fillRect(0, 0, canvas.width, canvas.height);
        if (userObjects.length === 0 && !rulerMode && !isDrawingActive && !isGeometryEditMode) {
             ctx.fillStyle = "#777"; ctx.font = "16px Arial"; ctx.textAlign = "center";
             ctx.fillText("Добавьте объекты (+), нарисуйте (✎), редактируйте () или измерьте (📏)", canvas.width / 2, canvas.height / 2);
        }
        if (!preserveTransform) calculateBounds();
        if (!hasValidView()) { ctx.fillStyle = "red"; ctx.font = "bold 18px Arial"; ctx.textAlign = "center"; ctx.fillText("Ошибка отображения: Невалидное состояние вида.", canvas.width / 2, canvas.height / 2); return; }

        const gridStep = determineGridStep();
        drawGrid(ctx, gridStep);
        drawObjects(ctx);
        drawActiveDrawingPreview(ctx);
        drawRuler(ctx);
        drawSelectedCoordinateMarker(ctx);
        drawSnapHighlight(ctx);

        updateGridInfo(gridStep);
        updateViewInfo();
    }

    function getPointState(pointToCheck, currentObjectIndex) {
        let isInsideOtherPolygon = false;
        let isCoincidentWithOther = false;
        if (!pointToCheck || !isFinite(pointToCheck.x) || !isFinite(pointToCheck.y)) {
            return { isCoincident: false, isInsideOther: false };
        }
        userObjects.forEach((otherObj, otherIndex) => {
            if (currentObjectIndex === otherIndex || !otherObj || !otherObj.contours) return;
            if (!isCoincidentWithOther) {
                for (const otherContour of otherObj.contours) {
                    if (!otherContour) continue;
                    for (const otherPoint of otherContour) {
                        if (otherPoint && isFinite(otherPoint.x) && isFinite(otherPoint.y)) {
                            if (pointToCheck.x === otherPoint.x && pointToCheck.y === otherPoint.y) {
                                isCoincidentWithOther = true; break;
                            }
                        }
                    }
                    if (isCoincidentWithOther) break;
                }
            }
            if (!isInsideOtherPolygon && otherObj.type === 'polygon' && otherObj.contours[0] && otherObj.contours[0].length >= 3) {
                let pointIsPartOfOtherPolygonBoundary = false;
                if (otherObj.contours[0]) {
                    for(const boundaryPoint of otherObj.contours[0]) {
                         if (boundaryPoint && isFinite(boundaryPoint.x) && isFinite(boundaryPoint.y)) {
                             if (pointToCheck.x === boundaryPoint.x && pointToCheck.y === boundaryPoint.y) {
                                pointIsPartOfOtherPolygonBoundary = true; break;
                             }
                         }
                    }
                }
                if (!pointIsPartOfOtherPolygonBoundary && isPointInPolygon(pointToCheck, otherObj.contours[0])) {
                    isInsideOtherPolygon = true;
                }
            }
        });
        return { isCoincident: isCoincidentWithOther, isInsideOther: isInsideOtherPolygon };
    }


function drawObjects(ctx) {
    userObjects.forEach((obj, index) => {
        if (!obj || !obj.contours) return;
        const isSelected = (index === selectedObjectIndex);
        const isBeingEdited = (isGeometryEditMode && index === editingObjectIndex);

        ctx.strokeStyle = obj.color || '#000000';
        ctx.lineWidth = (isSelected || isBeingEdited) ? 2.5 : 1.5;
        
        // Логика отрисовки в зависимости от типа
        if (obj.subType === 'construction_record') {
            // Для сооружений - всегда только обводка каждого контура
            obj.contours.forEach(contour => {
                if (!contour || contour.length < 1) return;
                ctx.beginPath();
                contour.forEach((point, pIdx) => {
                    const [canvasX, canvasY] = transformCoord(point.x, point.y);
                    if (pIdx === 0) {
                        ctx.moveTo(canvasX, canvasY);
                    } else {
                        ctx.lineTo(canvasX, canvasY);
                    }
                });
                ctx.stroke(); // НЕ используем closePath() и fill()
            });
        } else {
            // Стандартная логика для всех остальных объектов (ЗУ, Здания и т.д.)
            const fillColor = (obj.type === 'polygon') ? hexToRgba(obj.color || '#000000', (isSelected || isBeingEdited) ? 0.3 : 0.15) : 'transparent';
            ctx.fillStyle = fillColor;

            obj.contours.forEach((contour) => {
                if (!contour || contour.length === 0) return;
                ctx.beginPath();
                contour.forEach((point, pIdx) => {
                    const [canvasX, canvasY] = transformCoord(point.x, point.y);
                    if (pIdx === 0) ctx.moveTo(canvasX, canvasY);
                    else ctx.lineTo(canvasX, canvasY);
                });

                if (obj.type === 'polygon') {
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();
                } else if (obj.type === 'line') {
                    ctx.stroke();
                } else if (obj.type === 'point') {
                    if (contour[0] && isFinite(contour[0].x) && isFinite(contour[0].y)){
                        const [cx, cy] = transformCoord(contour[0].x, contour[0].y);
                        if(isFinite(cx) && isFinite(cy)){
                            ctx.save(); ctx.setTransform(1,0,0,1,0,0);
                            
                            // --- НОВАЯ ЛОГИКА ДЛЯ ПРИЦЕЛА (CROSSHAIR) ---
                            if (obj.subType === 'crosshair') {
                                const size = (isSelected || isBeingEdited) ? 10 : 7;
                                ctx.strokeStyle = obj.color || '#e74c3c'; // Красный по умолчанию или цвет объекта
                                ctx.lineWidth = (isSelected || isBeingEdited) ? 3 : 2;
                                
                                ctx.beginPath();
                                // Рисуем перекрестие
                                ctx.moveTo(cx - size, cy); ctx.lineTo(cx + size, cy);
                                ctx.moveTo(cx, cy - size); ctx.lineTo(cx, cy + size);
                                ctx.stroke();
                                
                            
                                ctx.beginPath();
                                ctx.arc(cx, cy, size / 1.5, 0, Math.PI * 2);
                                ctx.stroke();

                        
                                if (scale > 0.5) { // Только при приближении
                                    ctx.fillStyle = '#333';
                                    ctx.font = "10px monospace";
                                    ctx.fillText(`${contour[0].x.toFixed(2)}, ${contour[0].y.toFixed(2)}`, cx + size, cy - size);
                                }
                            } 
                            // --- СТАНДАРТНАЯ ОТРИСОВКА ТОЧКИ ---
                            else {
                                ctx.fillStyle=obj.color||'#000000';
                                ctx.beginPath(); ctx.arc(cx,cy,(isSelected || isBeingEdited)?5:3.5,0,Math.PI*2); ctx.closePath(); ctx.fill();
                                ctx.strokeStyle='white'; ctx.lineWidth=1; ctx.stroke();
                            }
                            ctx.restore();
                        }
                    }
                }
            });
        }

        // --- НАЧАЛО ИСПРАВЛЕНИЯ: ЭТОТ БЛОК ТЕПЕРЬ СНАРУЖИ IF/ELSE ---
        // Отрисовка точек (включая зеленые кружки) для ВСЕХ объектов
        if (showPoints && obj.contours.some(c => c && c.length > 0) && obj.type !== 'point') {
            obj.contours.forEach((contour, cIdx) => {
                if (!contour) return;
                contour.forEach((point, pIdx) => {
                    if (!point || !isFinite(point.x) || !isFinite(point.y)) return;
                    const [px, py] = transformCoord(point.x, point.y);
                    if (!isFinite(px) || !isFinite(py)) return;

                    const pointState = getPointState(point, index);
                    ctx.save(); ctx.setTransform(1, 0, 0, 1, 0, 0);
                    ctx.lineWidth = 1;
                    const isCurrentMovingPoint = isMovingPoint && movedPointInfo?.objectIndex === index && movedPointInfo?.contourIndex === cIdx && movedPointInfo?.pointIndex === pIdx;
                    const highlightRadius = (isSelected || isBeingEdited || isCurrentMovingPoint ? 4 : 3) + 2.5;

                    if (pointState.isCoincident && !isCurrentMovingPoint) {
                        ctx.strokeStyle = 'rgba(0, 200, 0, 0.9)';
                        ctx.beginPath(); ctx.arc(px, py, highlightRadius, 0, Math.PI * 2); ctx.stroke();
                    } else if (pointState.isInsideOther && !isCurrentMovingPoint) {
                        ctx.strokeStyle = 'rgba(255, 0, 0, 0.8)';
                        ctx.beginPath(); ctx.arc(px, py, highlightRadius, 0, Math.PI * 2); ctx.stroke();
                    }
                    ctx.restore();

                    ctx.save(); ctx.setTransform(1, 0, 0, 1, 0, 0);
                    let pointFill = isSelected || isBeingEdited ? hexToRgba(obj.color, 0.9) : hexToRgba(obj.color, 0.7);
                    let pointRadius = isSelected || isBeingEdited ? 4 : 3;
                    if(isCurrentMovingPoint){
                        pointFill = 'yellow'; pointRadius = 5;
                    }

                    ctx.fillStyle = pointFill;
                    ctx.beginPath(); ctx.arc(px, py, pointRadius, 0, Math.PI * 2); ctx.closePath(); ctx.fill();
                    ctx.strokeStyle = 'white'; ctx.lineWidth = 0.5; ctx.stroke();
                    ctx.restore();
                });
            });
        }
        // --- КОНЕЦ ИСПРАВЛЕНИЯ ---

        // Отрисовка подписей (без изменений)
        if (scale > 0.005 && obj.contours.length > 0 && obj.contours[0] && obj.contours[0].length > 0) {
            const firstContour = obj.contours[0];
            if (firstContour.every(p => p && isFinite(p.x) && isFinite(p.y))) {
                const labelPos = getContourCentroid(firstContour);
                if (labelPos && isFinite(labelPos.x) && isFinite(labelPos.y)) {
                    const [labelX, labelY] = transformCoord(labelPos.x, labelPos.y);
                    if (isFinite(labelX) && isFinite(labelY)) {
                        ctx.save(); ctx.setTransform(1, 0, 0, 1, 0, 0);
                        ctx.font = "bold 11px Arial";
                        ctx.fillStyle = obj.color || '#000000';
                        ctx.strokeStyle = 'white'; ctx.lineWidth = 2.5;
                        ctx.textAlign = "center"; ctx.textBaseline = "bottom";
                        ctx.strokeText(obj.name || `Объект ${obj.id}`, labelX, labelY - 5);
                        ctx.fillText(obj.name || `Объект ${obj.id}`, labelX, labelY - 5);
                        ctx.restore();
                    }
                }
            }
        }
    });
}


    
    function drawActiveDrawingPreview(ctx) {
        if (!isDrawingActive || currentDrawingPoints.length === 0) return;
        ctx.save(); ctx.setTransform(1, 0, 0, 1, 0, 0);
        ctx.strokeStyle = '#f39c12'; ctx.fillStyle = 'rgba(243, 156, 18, 0.7)';
        ctx.lineWidth = 1.5; ctx.globalAlpha = 0.8;
        ctx.beginPath();
        let firstDrawPoint = true;
        currentDrawingPoints.forEach((point) => {
            if (!point || !isFinite(point.x) || !isFinite(point.y)) return;
            const [cx, cy] = transformCoord(point.x, point.y);
            if (!isFinite(cx) || !isFinite(cy)) return;
            if (firstDrawPoint) { ctx.moveTo(cx, cy); firstDrawPoint = false; }
            else { ctx.lineTo(cx, cy); }
        });
        if (!firstDrawPoint) ctx.stroke();

        currentDrawingPoints.forEach((point) => {
            if (!point || !isFinite(point.x) || !isFinite(point.y)) return;
            const [cx, cy] = transformCoord(point.x, point.y);
            if (!isFinite(cx) || !isFinite(cy)) return;
            ctx.save();
            ctx.fillStyle = 'rgba(243, 156, 18, 0.7)'; ctx.strokeStyle = 'white'; ctx.lineWidth = 1;
            ctx.beginPath(); ctx.arc(cx, cy, 4, 0, Math.PI * 2); ctx.fill(); ctx.stroke();
            ctx.restore();
        });

        if (!firstDrawPoint && currentMousePos && isFinite(currentMousePos.x) && isFinite(currentMousePos.y)) {
            const lastPoint = currentDrawingPoints[currentDrawingPoints.length - 1];
            if (lastPoint && isFinite(lastPoint.x) && isFinite(lastPoint.y)) {
                const [lastX, lastY] = transformCoord(lastPoint.x, lastPoint.y);
                const [cursorCanvasX, cursorCanvasY] = transformCoord(currentMousePos.x, currentMousePos.y);
                if (isFinite(lastX) && isFinite(lastY) && isFinite(cursorCanvasX) && isFinite(cursorCanvasY)) {
                    ctx.beginPath(); ctx.moveTo(lastX, lastY); ctx.lineTo(cursorCanvasX, cursorCanvasY);
                    ctx.setLineDash([4, 4]); ctx.strokeStyle = '#f39c12'; ctx.lineWidth = 1; ctx.stroke();
                    ctx.setLineDash([]);
                }
            }
        }
        ctx.restore();
    }
    function drawRuler(ctx) {
      if (!rulerMode || rulerPoints.length === 0) return;
      ctx.save(); ctx.setTransform(1, 0, 0, 1, 0, 0);
      ctx.strokeStyle = '#e74c3c'; ctx.fillStyle = '#e74c3c';
      ctx.lineWidth = 2; ctx.font = 'bold 12px Arial';
      const p1 = rulerPoints[0];
      if (p1 && isFinite(p1.x) && isFinite(p1.y)) {
        const [p1x, p1y] = transformCoord(p1.x, p1.y);
        if (isFinite(p1x) && isFinite(p1y)) {
          ctx.beginPath(); ctx.arc(p1x, p1y, 5, 0, Math.PI * 2); ctx.fill();
          if (rulerPoints.length === 2) {
            const p2 = rulerPoints[1];
            if (p2 && isFinite(p2.x) && isFinite(p2.y)) {
              const [p2x, p2y] = transformCoord(p2.x, p2.y);
              if (isFinite(p2x) && isFinite(p2y)) {
                ctx.beginPath(); ctx.arc(p2x, p2y, 5, 0, Math.PI * 2); ctx.fill();
                ctx.beginPath(); ctx.moveTo(p1x, p1y); ctx.lineTo(p2x, p2y); ctx.stroke();
                const distance = calculateDistance(p1, p2);
                if (isFinite(distance)) {
                  const midX = (p1x + p2x) / 2; const midY = (p1y + p2y) / 2;
                  const labelText = distance.toFixed(2) + ' м';
                  const textWidth = ctx.measureText(labelText).width;
                  ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                  ctx.fillRect(midX - textWidth / 2 - 4, midY - 8, textWidth + 8, 16);
                  ctx.fillStyle = '#e74c3c'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                  ctx.fillText(labelText, midX, midY);
                }
              }
            }
          }
        }
      }
      ctx.restore();
    }
    function drawSelectedCoordinateMarker(ctx) {
        if (!selectedCoordinate || !isFinite(selectedCoordinate.x) || !isFinite(selectedCoordinate.y)) return;
        const [selX, selY] = transformCoord(selectedCoordinate.x, selectedCoordinate.y);
        if (!isFinite(selX) || !isFinite(selY)) return;
        ctx.save(); ctx.setTransform(1, 0, 0, 1, 0, 0);
        ctx.fillStyle = 'rgba(255, 0, 0, 0.8)'; ctx.strokeStyle = 'white'; ctx.lineWidth = 2;
        ctx.beginPath(); ctx.arc(selX, selY, 6, 0, Math.PI * 2); ctx.fill(); ctx.stroke();
        ctx.restore();
    }
   
function drawSnapHighlight(ctx) {
    if (!snappedToPointVisual) return;
    const [snapX, snapY] = transformCoord(snappedToPointVisual.x, snappedToPointVisual.y);
    if (!isFinite(snapX) || !isFinite(snapY)) return;

    ctx.save();
    ctx.setTransform(1, 0, 0, 1, 0, 0);
    ctx.strokeStyle = '#FF0000';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(snapX, snapY, GRAB_POINT_RADIUS_SCREEN + 2, 0, Math.PI * 2);
    ctx.stroke();
    const crossSize = GRAB_POINT_RADIUS_SCREEN + 4;
    ctx.beginPath();
    ctx.moveTo(snapX - crossSize, snapY); ctx.lineTo(snapX + crossSize, snapY);
    ctx.moveTo(snapX, snapY - crossSize); ctx.lineTo(snapX, snapY + crossSize);
    ctx.stroke();
    ctx.restore();
}


    function determineGridStep() {
        const possibleSteps = [0.01, 0.05, 0.1, 0.5, 1, 5, 10, 50, 100, 200, 500, 1000, 5000, 10000, 50000];
        const targetPixelSize = 40;
        let bestStep = 100;
        if (!hasValidView() || scale <= 0) return bestStep;
        for (const step of possibleSteps) {
            const pixelSize = step * scale;
            if (pixelSize >= targetPixelSize) { bestStep = step; break; }
            bestStep = step;
        }
        if (bestStep * scale < 10 && possibleSteps.indexOf(bestStep) < possibleSteps.length - 1) {
            bestStep = possibleSteps[possibleSteps.indexOf(bestStep) + 1];
        }
        return bestStep;
    }
    function updateGridInfo(gridStep) {
        let stepText;
        if (!isFinite(gridStep) || gridStep <= 0) stepText = '-';
        else if (gridStep < 0.1) stepText = `${(gridStep * 100).toFixed(0)} см`;
        else if (gridStep < 1) stepText = `${gridStep.toFixed(1)} м`;
        else if (gridStep >= 1000) stepText = `${(gridStep / 1000).toFixed(1)} км`;
        else stepText = `${gridStep.toFixed(0)} м`;
        gridInfoText.textContent = ` ${stepText}`;
    }
    function drawGrid(ctx, gridStep) {
        if (!hasValidView() || !isFinite(gridStep) || gridStep <= 0) return;
        ctx.save(); ctx.setTransform(1, 0, 0, 1, 0, 0);
        ctx.strokeStyle = 'rgba(200, 200, 200, 0.6)'; ctx.lineWidth = 0.5;
        ctx.beginPath();
        const cW = canvas.width, cH = canvas.height, tol = 10;
        const tl = inverseTransformCoord(0, 0); const br = inverseTransformCoord(cW, cH);
        if (!isFinite(tl.x) || !isFinite(tl.y) || !isFinite(br.x) || !isFinite(br.y)) { ctx.restore(); return; }
        const minDX = Math.min(tl.x, br.x), maxDX = Math.max(tl.x, br.x);
        const minDY = Math.min(tl.y, br.y), maxDY = Math.max(tl.y, br.y);
        const startDX = Math.floor(minDX / gridStep) * gridStep;
        const endDX = Math.ceil(maxDX / gridStep) * gridStep;
        const startDY = Math.floor(minDY / gridStep) * gridStep;
        const endDY = Math.ceil(maxDY / gridStep) * gridStep;
        for (let dX = startDX; dX <= endDX; dX += gridStep) {
            const [, lCY] = transformCoord(dX, 0);
            if (isFinite(lCY) && lCY >= -tol && lCY <= cH + tol) { ctx.moveTo(0, lCY); ctx.lineTo(cW, lCY); }
        }
        for (let dY = startDY; dY <= endDY; dY += gridStep) {
            const [lCX, ] = transformCoord(0, dY);
            if (isFinite(lCX) && lCX >= -tol && lCX <= cW + tol) { ctx.moveTo(lCX, 0); ctx.lineTo(lCX, cH); }
        }
        ctx.stroke(); ctx.restore();
    }
    function countSharedVertices(poly1, poly2) {
        if (!poly1 || !poly2 || poly1.length === 0 || poly2.length === 0) return 0;
        let sharedCount = 0;
        const uniquePoly2Points = []; const addedCoords = new Set();
        for (const p2 of poly2) {
            if (!p2 || !isFinite(p2.x) || !isFinite(p2.y)) continue;
            const coordKey = `${p2.x}_${p2.y}`;
            if (!addedCoords.has(coordKey)) { uniquePoly2Points.push(p2); addedCoords.add(coordKey); }
        }
        for (const p1 of poly1) {
            if (!p1 || !isFinite(p1.x) || !isFinite(p1.y)) continue;
            for (const p2 of uniquePoly2Points) {
                if (p1.x === p2.x && p1.y === p2.y) {
                    sharedCount++; break;
                }
            }
        }
        return sharedCount;
    }
    function updateCursorInfo(x, y) {
        if (!isFinite(x) || !isFinite(y)) { cursorCoordinates.textContent = `X: -, Y: -`; }
        else { cursorCoordinates.textContent = `X: ${x.toFixed(2)}, Y: ${y.toFixed(2)}`; }
    }

 function handleMouseDown(e) {
        const rect = canvas.getBoundingClientRect();
        const canvasMouseX = e.clientX - rect.left;
        const canvasMouseY = e.clientY - rect.top;
        const clickDataPoint = inverseTransformCoord(canvasMouseX, canvasMouseY);

        if (isDrawingMode && isDrawingActive) return;
        if (rulerMode) return;

        if (isGeometryEditMode && editingObjectIndex !== -1) {
            const obj = userObjects[editingObjectIndex];
            if (!obj || !obj.contours) { deactivateGeometryEditMode(); return; }

            const grabRadiusDataSq = (GRAB_POINT_RADIUS_SCREEN / scale) ** 2;
            let foundPointToEdit = false;

            for (let cIdx = 0; cIdx < obj.contours.length; cIdx++) {
                const contour = obj.contours[cIdx];
                if (!contour) continue;
                for (let pIdx = 0; pIdx < contour.length; pIdx++) {
                    const point = contour[pIdx];
                    if (!point || !isFinite(point.x) || !isFinite(point.y)) continue;
                    const distSq = (clickDataPoint.x - point.x)**2 + (clickDataPoint.y - point.y)**2;
                    if (distSq < grabRadiusDataSq) {
                        isMovingPoint = true;
                        movedPointInfo = {
                            objectIndex: editingObjectIndex, contourIndex: cIdx, pointIndex: pIdx,
                            originalX: point.x, originalY: point.y
                        };
                        // --- НАЧАЛО ИЗМЕНЕНИЙ ---
                        const editingObj = userObjects[editingObjectIndex];
                        if (editingObj && editingObj.type === 'polygon') {
                            movedPointInfo.originalArea = editingObj.area;
                        }
                        // --- КОНЕЦ ИЗМЕНЕНИЙ ---
                        saveGeometryStateForUndo(editingObjectIndex);
                        canvas.classList.add('editing-point-mode');
                        isDragging = false;
                        foundPointToEdit = true;
                        redraw(true);
                        break;
                    }
                }
                if (foundPointToEdit) break;
            }
            if (foundPointToEdit) return;
            return;
        }

        isDragging = true;
        startX = e.clientX; startY = e.clientY;
        lastOffsetX = offsetX; lastOffsetY = offsetY;
        canvas.style.cursor = 'grabbing';
    }



function handleMouseMove(e) {
    const r = canvas.getBoundingClientRect();
    const cX = e.clientX - r.left;
    const cY = e.clientY - r.top;

    if (!hasValidView()) {
        updateCursorInfo(NaN, NaN);
        canvas.style.cursor = 'not-allowed';
        tooltip.style.display = 'none';
        return;
    }
    const dP = inverseTransformCoord(cX, cY);
    currentMousePos = { x: dP.x, y: dP.y };
    updateCursorInfo(dP.x, dP.y);

    if (!isMovingPoint) snappedToPointVisual = null;

    if (isMovingPoint || (isDrawingMode && isDrawingActive) || rulerMode) {
        let targetPoint = { x: currentMousePos.x, y: currentMousePos.y };
        const snapRadiusDataSq = (SNAP_RADIUS_SCREEN / scale) ** 2;
        let bestSnapDistSq = snapRadiusDataSq;
        let foundSnap = false;

        for (const snapObj of userObjects) {
            if (!snapObj.contours) continue;
            for (const snapContour of snapObj.contours) {
                if (!snapContour) continue;
                for (let i = 0; i < snapContour.length; i++) {
                    const snapCandidatePt = snapContour[i];
                    if (isMovingPoint && movedPointInfo &&
                        snapObj === userObjects[movedPointInfo.objectIndex] &&
                        snapContour === userObjects[movedPointInfo.objectIndex].contours[movedPointInfo.contourIndex] &&
                        i === movedPointInfo.pointIndex) {
                        continue;
                    }
                    const distSq = (dP.x - snapCandidatePt.x) ** 2 + (dP.y - snapCandidatePt.y) ** 2;
                    if (distSq < bestSnapDistSq) {
                        bestSnapDistSq = distSq;
                        targetPoint = { x: snapCandidatePt.x, y: snapCandidatePt.y };
                        snappedToPointVisual = { ...targetPoint };
                        foundSnap = true;
                    }
                }
            }
        }

        if (foundSnap) {
            currentMousePos = targetPoint;
        }

        if (isMovingPoint && movedPointInfo) {
            const objToUpdate = userObjects[movedPointInfo.objectIndex];
            const contourToUpdate = objToUpdate.contours[movedPointInfo.contourIndex];
            const pointToUpdate = contourToUpdate[movedPointInfo.pointIndex];

            pointToUpdate.x = targetPoint.x;
            pointToUpdate.y = targetPoint.y;

            if (objToUpdate.type === 'polygon' && contourToUpdate.length > 1) {
                const lastIndex = contourToUpdate.length - 1;
                if (movedPointInfo.pointIndex === 0) {
                    const lastPoint = contourToUpdate[lastIndex];
                    if (lastPoint) { lastPoint.x = targetPoint.x; lastPoint.y = targetPoint.y; }
                } else if (movedPointInfo.pointIndex === lastIndex) {
                    const firstPoint = contourToUpdate[0];
                    if (firstPoint) { firstPoint.x = targetPoint.x; firstPoint.y = targetPoint.y; }
                }
            }

            updateObjectMetrics(objToUpdate);
            if (movedPointInfo.objectIndex === selectedObjectIndex && objToUpdate.type === 'polygon' && movedPointInfo.originalArea !== undefined) {
                const areaSpan = document.querySelector('#selectedObjectInfo .info-item[data-label="Площадь (кв. м)"] span:last-child');
                if (areaSpan) {
                    const newArea = objToUpdate.area;
                    const originalArea = movedPointInfo.originalArea;
                    const diff = newArea - originalArea;
                    const diffSign = diff > 0 ? '+' : '';
                    const diffColor = diff > 0 ? '#27ae60' : (diff < 0 ? '#e74c3c' : '#7f8c8d');
                    areaSpan.innerHTML = `${originalArea.toFixed(2)} &rarr; <strong>${newArea.toFixed(2)}</strong> <span style="font-size: 0.9em; color: ${diffColor};">(${diffSign}${diff.toFixed(2)})</span>`;
                }
            }
            redraw(true);
            return;
        }
    }

    if (isDragging) {
        offsetX = lastOffsetX + (e.clientX - startX);
        offsetY = lastOffsetY - (e.clientY - startY);
        redraw(true);
        tooltip.style.display = 'none';
    } else {
        let hObjArea = false;
        let hPointInfo = null;
        let hSegment = false;

        const hoverPointRadiusDataSq = (GRAB_POINT_RADIUS_SCREEN / scale) ** 2;
        let minPtDistSq = hoverPointRadiusDataSq;

        if (!rulerMode && !isDrawingActive && !isGeometryEditMode && isFinite(dP.x) && isFinite(dP.y)) {
            for (let i = userObjects.length - 1; i >= 0; i--) {
                const o = userObjects[i];
                if (o?.type === 'polygon' && o.contours?.[0] && isPointInPolygon(dP, o.contours[0])) {
                    hObjArea = true; break;
                }
            }
        }
        if (showPoints && isFinite(dP.x) && isFinite(dP.y)) {
            for (let i = userObjects.length - 1; i >= 0; i--) {
                const o = userObjects[i];
                if (!o?.contours || o.type === 'point') continue;
                if (isGeometryEditMode && editingObjectIndex !== -1 && i !== editingObjectIndex) continue;

                for (let cIdx = 0; cIdx < o.contours.length; cIdx++) {
                    const c = o.contours[cIdx]; if (!c) continue;
                    for (let pIdx = 0; pIdx < c.length; pIdx++) {
                        const p = c[pIdx];
                        if (p && isFinite(p.x) && isFinite(p.y)) {
                            const dx = p.x - dP.x; const dy = p.y - dP.y;
                            const distanceSq = dx * dx + dy * dy;
                            if (distanceSq < minPtDistSq) {
                                minPtDistSq = distanceSq;
                                hPointInfo = { point: p, objectIndex: i, contourIndex: cIdx, pointInContourIndex: pIdx };
                            }
                        }
                    }
                }
            }
        }
        if (isGeometryEditMode && editingObjectIndex !== -1 && !hPointInfo) {
            const obj = userObjects[editingObjectIndex];
            if (obj && obj.contours) {
                const addPointThresholdDataSq = (ADD_POINT_THRESHOLD_SCREEN / scale) ** 2;
                obj.contours.forEach(contour => {
                    if (!contour || contour.length < (obj.type === 'line' ? 1 : 2)) return;
                    const numSegments = obj.type === 'polygon' ? contour.length : contour.length - 1;
                    if (numSegments < 1 && obj.type !== 'point') return;

                    for (let sIdx = 0; sIdx < numSegments; sIdx++) {
                        const p1 = contour[sIdx];
                        const p2 = contour[(sIdx + 1) % (obj.type === 'polygon' ? contour.length : Infinity)];
                        if (!p2 && obj.type === 'line' && sIdx === contour.length - 1) continue;
                        const closestPtOnSeg = getClosestPointOnSegment(dP, p1, p2);
                        const distSq = (dP.x - closestPtOnSeg.x) ** 2 + (dP.y - closestPtOnSeg.y) ** 2;
                        if (distSq < addPointThresholdDataSq) {
                            hSegment = true; break;
                        }
                    }
                    if (hSegment) return;
                });
            }
        }

        if (hPointInfo) {
            const hPt = hPointInfo.point; let tooltipText = ''; let sequentialIndex = -1;
            if (selectedObjectIndex !== -1 && hPointInfo.objectIndex === selectedObjectIndex) {
                const selObj = userObjects[selectedObjectIndex];
                if (selObj && selObj.contours) {
                    let counter = 1; let found = false;
                    for (let cIdx = 0; cIdx < selObj.contours.length; cIdx++) {
                        const contour = selObj.contours[cIdx]; if (!contour) continue;
                        for (let pIdx = 0; pIdx < contour.length; pIdx++) {
                            const pt = contour[pIdx]; if (!pt || !isFinite(pt.x) || !isFinite(pt.y)) continue;
                            if (cIdx === hPointInfo.contourIndex && pIdx === hPointInfo.pointInContourIndex) {
                                sequentialIndex = counter; found = true; break;
                            }
                            counter++;
                        }
                        if (found) break;
                    }
                }
            }
            tooltipText = sequentialIndex !== -1 ? `№: ${sequentialIndex}\nX: ${hPt.x.toFixed(2)}\nY: ${hPt.y.toFixed(2)}` : `X: ${hPt.x.toFixed(2)}\nY: ${hPt.y.toFixed(2)}`;
            if (isGeometryEditMode && hPointInfo.objectIndex === editingObjectIndex && hPointInfo.point) {
                tooltipText += "\n(ПКМ для удаления)";
            }
            const pointState = getPointState(hPt, hPointInfo.objectIndex);
            let tooltipColor = 'rgba(52, 152, 219, 0.85)';
            if (pointState.isCoincident) tooltipColor = 'rgba(46, 204, 113, 0.85)';
            else if (pointState.isInsideOther) tooltipColor = 'rgba(231, 76, 60, 0.85)';
            tooltip.style.backgroundColor = tooltipColor; tooltip.style.color = 'white';
            tooltip.style.display = 'block'; tooltip.textContent = tooltipText;
            tooltip.style.left = `${e.clientX + 10}px`; tooltip.style.top = `${e.clientY + 10}px`;
            tooltip.style.whiteSpace = 'pre';
        } else {
            tooltip.style.display = 'none';
        }

        canvas.classList.remove('geometry-edit-mode-hover-point', 'geometry-edit-mode-add');

        if (isDrawingActive) canvas.style.cursor = 'crosshair';
        else if (rulerMode) canvas.style.cursor = 'crosshair';
        else if (isGeometryEditMode && editingObjectIndex !== -1) {
            if (hPointInfo && hPointInfo.objectIndex === editingObjectIndex) {
                canvas.classList.add('geometry-edit-mode-hover-point');
                canvas.style.cursor = '';
            } else if (hSegment) {
                canvas.classList.add('geometry-edit-mode-add');
                canvas.style.cursor = '';
            }
            else canvas.style.cursor = 'default';
        }
        else if (hPointInfo || hObjArea) canvas.style.cursor = 'pointer';
        else canvas.style.cursor = 'grab';

        if (isDrawingActive || isGeometryEditMode || rulerMode) redraw(true);
    }
}

function handleMouseOut() {
    if (isDragging) {
        isDragging = false;
        if (!isDrawingMode && !isMovingPoint && !rulerMode && !isGeometryEditMode) canvas.style.cursor = 'grab';
        saveState();
    }
    tooltip.style.display = 'none';
    snappedToPointVisual = null;
    if (isDrawingActive && currentDrawingPoints.length > 0) {
        currentMousePos = currentDrawingPoints[currentDrawingPoints.length-1] || {x:NaN, y:NaN};
        redraw(true);
    }
    updateCursorInfo(NaN, NaN);
}
    
        function deleteAllObjects() {
        if (userObjects.length === 0) {
            showNotification("Список объектов уже пуст.", "info", "info-circle");
            return;
        }

        if (window.confirm(`Вы уверены, что хотите удалить ВСЕ объекты (${userObjects.length} шт.)? Это действие необратимо.`)) {
            // Сброс всех состояний, связанных с объектами
            userObjects = [];
            selectedObjectIndex = -1;
            if(isGeometryEditMode) {
                deactivateGeometryEditMode(false);
            }
            editingObjectIndex = -1;
            geometryHistory = [];
            nextObjectId = 1;
            nextColorIndex = 0;

            // Обновление UI
            displayObjectInfo(-1);
            updateObjectList();
            updateToggleButtonStates();
            
            // Сохранение и перерисовка
            saveState();
            redraw(false); // false, чтобы полностью сбросить вид
            showNotification("Все объекты удалены.", "success", "trash-alt");
        }
    }

 function handleMouseUp(e) {
        const wasMovingPoint = isMovingPoint;

        if (isMovingPoint) {
            isMovingPoint = false;
            snappedToPointVisual = null;
            canvas.classList.remove('editing-point-mode');
            updateObjectMetrics(userObjects[movedPointInfo.objectIndex]);
            if (movedPointInfo.objectIndex === selectedObjectIndex) {
                 displayObjectInfo(selectedObjectIndex); // <-- Эта строка восстановит нормальное отображение панели
            }
            movedPointInfo = null;
            saveState();
            redraw(true);
            window.lastPointMoveEndTime = Date.now();
        } else if (isDragging) {
            isDragging = false;
            saveState();
        }

        if (!rulerMode && !isDrawingMode && !isGeometryEditMode && !isMovingPoint) {
            canvas.style.cursor = 'grab';
        }
    }

    function handleWheel(e) {
        if ((isDrawingMode && isDrawingActive) || isMovingPoint) {
            e.preventDefault(); return;
        }
        e.preventDefault();
        if (!hasValidView()) { calculateBounds(); resetView(); if (!hasValidView()) return; }

        const zoomFactor = 1.1;
        const zoomDir = e.deltaY < 0 ? zoomFactor : 1 / zoomFactor;

        const rect = canvas.getBoundingClientRect();
        const mouseCX = e.clientX - rect.left; const mouseCY = e.clientY - rect.top;
        const dataMouseBefore = inverseTransformCoord(mouseCX, mouseCY);
        if (!isFinite(dataMouseBefore.x) || !isFinite(dataMouseBefore.y)) return;

        const newScale = scale * zoomDir;
        const minScale = 1e-9, maxScale = 10000;
        if (newScale < minScale || newScale > maxScale) return;
        scale = newScale;

        offsetX = mouseCX - (dataMouseBefore.y - cMinYGlob()) * scale;
        offsetY = canvas.height - mouseCY - (dataMouseBefore.x - cMinXGlob()) * scale;

        if (!hasValidView()) resetView();
        redraw(true); updateViewInfo(); saveState();
    }

    function getClosestPointOnSegment(p, a, b) {
        const abx = b.x - a.x;
        const aby = b.y - a.y;
        const apx = p.x - a.x;
        const apy = p.y - a.y;

        const ab_ab = abx * abx + aby * aby;
        if (ab_ab === 0) return { x: a.x, y: a.y };

        let t = (apx * abx + apy * aby) / ab_ab;
        t = Math.max(0, Math.min(1, t));

        return {
            x: roundCoord(a.x + t * abx),
            y: roundCoord(a.y + t * aby)
        };
    }


function handleClick(e) {
    if (e.button !== 0) return;

    const timeSinceLastPointMoveEnd = Date.now() - (window.lastPointMoveEndTime || 0);
    if (timeSinceLastPointMoveEnd < 50) {
        return;
    }

    if (e.detail > 1) return;
    if (!hasValidView()) return;

    const r = canvas.getBoundingClientRect();
    const cX = e.clientX - r.left;
    const cY = e.clientY - r.top;
    const dP = inverseTransformCoord(cX, cY);
    if (!isFinite(dP.x) || !isFinite(dP.y)) return;

    if (isDrawingMode && isDrawingActive) {
        const pointToAdd = snappedToPointVisual
            ? { x: snappedToPointVisual.x, y: snappedToPointVisual.y }
            : { x: dP.x, y: dP.y };
        currentDrawingPoints.push(pointToAdd);
        redraw(true);
    } else if (rulerMode) {
        if (rulerPoints.length < 2) {
            const pointToAdd = snappedToPointVisual
                ? { x: snappedToPointVisual.x, y: snappedToPointVisual.y }
                : { x: dP.x, y: dP.y };
            rulerPoints.push(pointToAdd);
            updateMeasurementPanel();
            redraw(true);
            if (rulerPoints.length === 2) {
                const dist = calculateDistance(rulerPoints[0], rulerPoints[1]);
                if (isFinite(dist)) showNotification(`Расстояние: ${dist.toFixed(2)} м`, "success", "ruler");
                else showNotification(`Не удалось измерить`, "error");
            }
        }
    } else if (isGeometryEditMode && editingObjectIndex !== -1 && !e.altKey) {
        const obj = userObjects[editingObjectIndex];
        if (!obj || !obj.contours) return;

        let bestMatch = { distSq: Infinity, contourIndex: -1, segmentIndex: -1, newPoint: null };
        const clickThresholdDataSq = (ADD_POINT_THRESHOLD_SCREEN / scale) ** 2;

        obj.contours.forEach((contour, cIdx) => {
            if (!contour || contour.length < (obj.type === 'line' ? 1 : 2)) return;
            const numSegments = obj.type === 'polygon' ? contour.length : contour.length - 1;
            if (numSegments < 1 && obj.type !== 'point') return;

            for (let sIdx = 0; sIdx < numSegments; sIdx++) {
                const p1 = contour[sIdx];
                const p2 = contour[(sIdx + 1) % (obj.type === 'polygon' ? contour.length : Infinity)];
                if (!p2 && obj.type === 'line' && sIdx === contour.length - 1) continue;

                const closestPtOnSeg = getClosestPointOnSegment(dP, p1, p2);
                const distSq = (dP.x - closestPtOnSeg.x) ** 2 + (dP.y - closestPtOnSeg.y) ** 2;

                if (distSq < bestMatch.distSq && distSq < clickThresholdDataSq) {
                    bestMatch = {
                        distSq, contourIndex: cIdx, segmentIndex: sIdx,
                        newPoint: closestPtOnSeg
                    };
                }
            }
        });

        if (bestMatch.newPoint) {
            saveGeometryStateForUndo(editingObjectIndex);
            const contourToModify = userObjects[editingObjectIndex].contours[bestMatch.contourIndex];
            contourToModify.splice(bestMatch.segmentIndex + 1, 0, bestMatch.newPoint);
            updateObjectMetrics(userObjects[editingObjectIndex]);
            displayObjectInfo(editingObjectIndex);
            showNotification("Точка добавлена на сегмент.", "success", "plus-circle");
            redraw(true);
            saveState();
            return;
        }
    }
}

    function handleContextMenu(e) {
        e.preventDefault();
        if (!isGeometryEditMode || editingObjectIndex === -1) return;

        const r = canvas.getBoundingClientRect();
        const cX = e.clientX - r.left; const cY = e.clientY - r.top;
        const clickDataPoint = inverseTransformCoord(cX, cY);

        const obj = userObjects[editingObjectIndex];
        if (!obj || !obj.contours) return;

        const grabRadiusDataSq = (GRAB_POINT_RADIUS_SCREEN / scale) ** 2;
        let pointToDeleteInfo = null;

        for (let cIdx = 0; cIdx < obj.contours.length; cIdx++) {
            const contour = obj.contours[cIdx];
            if (!contour) continue;
            const minPoints = obj.type === 'polygon' ? 3 : (obj.type === 'line' ? 2 : Infinity);

            for (let pIdx = 0; pIdx < contour.length; pIdx++) {
                const point = contour[pIdx];
                if (!point || !isFinite(point.x) || !isFinite(point.y)) continue;
                const distSq = (clickDataPoint.x - point.x)**2 + (clickDataPoint.y - point.y)**2;
                if (distSq < grabRadiusDataSq) {
                    if (contour.length > minPoints) {
                        pointToDeleteInfo = { contourIndex: cIdx, pointIndex: pIdx, object: obj };
                    } else {
                        showNotification(`Нельзя удалить вершину: у ${obj.type === 'polygon' ? 'полигона' : 'линии'} должно быть минимум ${minPoints} вершин${obj.type === 'polygon' ? 'ы' : ''}.`, "warning", "ban");
                        return;
                    }
                    break;
                }
            }
            if (pointToDeleteInfo) break;
        }

        if (pointToDeleteInfo) {
            if (window.confirm("Удалить выбранную вершину?")) {
                saveGeometryStateForUndo(editingObjectIndex);
                const contourToModify = pointToDeleteInfo.object.contours[pointToDeleteInfo.contourIndex];
                contourToModify.splice(pointToDeleteInfo.pointIndex, 1);
                updateObjectMetrics(pointToDeleteInfo.object);
                displayObjectInfo(editingObjectIndex);
                showNotification("Вершина удалена.", "info", "trash-alt");
                redraw(true);
                saveState();
            }
        }
    }


function handleDoubleClick(e) {
        e.preventDefault();
        if (!hasValidView()) return;
        const r = canvas.getBoundingClientRect();
        const cX = e.clientX - r.left; const cY = e.clientY - r.top;
        const dP = inverseTransformCoord(cX, cY);
        if (!isFinite(dP.x) || !isFinite(dP.y)) return;

        if (isDrawingMode && isDrawingActive) {
            finishDrawingAsPolygon();
        } 
        else if (isCutToolActive && isGeometryEditMode) {
            handleCutSelection(dP);
        }
        // --- НОВОЕ УСЛОВИЕ ---
        else if (isIntersectToolActive && isGeometryEditMode) {
            handleIntersectSelection(dP);
        }
        // ---------------------
        else if (!rulerMode && !isMovingPoint && !isGeometryEditMode) {
            selectObjectByPoint(dP);
        }
    }
    
      function handleCutSelection(point) {
        // Ищем объект под курсором
        let clickedIdx = -1;
        // Проходим в обратном порядке (сверху вниз)
        for (let i = userObjects.length - 1; i >= 0; i--) {
            const obj = userObjects[i];
            if (obj && obj.type === 'polygon' && obj.contours) {
                // Проверяем попадание в любой из контуров
                const hits = obj.contours.some(c => isPointInPolygon(point, c));
                if (hits) {
                    clickedIdx = i;
                    break;
                }
            }
        }

        if (clickedIdx === -1) return;

        if (cutTargetIndex === -1) {
            // ШАГ 1: Выбор Рассекаемого объекта
            cutTargetIndex = clickedIdx;
            const objName = userObjects[clickedIdx].name || `Объект ${userObjects[clickedIdx].id}`;
            showNotification(`Рассекаемый: "${objName}". Теперь двойной клик по РЕЗАКУ.`, "warning", "crosshairs");
            // Можно добавить визуальное выделение, но пока ограничимся перерисовкой (если добавите логику отрисовки)
        } else {
            // ШАГ 2: Выбор Резака
            if (clickedIdx === cutTargetIndex) {
                showNotification("Резак должен отличаться от рассекаемого объекта.", "error");
                return;
            }
            const cutterName = userObjects[clickedIdx].name || `Объект ${userObjects[clickedIdx].id}`;
            showNotification(`Резак: "${cutterName}". Выполняю разрез...`, "info", "cog");
            
            // Запуск операции
            executeCutOperation(cutTargetIndex, clickedIdx);
            
            // Сброс после операции
            toggleCutTool(); 
        }
    }
    
    

    
    
    
    
    
    
    
    
    

    function selectObjectByPoint(dataClickPoint) {
        let clickedIdx = -1; let minArea = Infinity;
        userObjects.forEach((obj, index) => {
            if (!obj || !obj.contours) return;
            let containsPoint = false;
            for (const contour of obj.contours) {
                if (obj.type === 'polygon' && contour && contour.length >= 3 && isPointInPolygon(dataClickPoint, contour)) {
                    containsPoint = true; break;
                }
            }
            if (containsPoint) {
                const area = (obj.area !== undefined && isFinite(obj.area)) ? obj.area : Infinity;
                if (area < minArea) { minArea = area; clickedIdx = index; }
            }
        });
        if (clickedIdx !== -1) {
            if (isGeometryEditMode && editingObjectIndex !== clickedIdx) {
                deactivateGeometryEditMode(false);
            }
            selectedObjectIndex = clickedIdx;
            displayObjectInfo(selectedObjectIndex); updateObjectListSelection();
        } else {
            if (!isGeometryEditMode) {
                selectedObjectIndex = -1;
                displayObjectInfo(-1); updateObjectListSelection();
            }
        }
        selectedCoordinate = null;
        redraw(true);
    }
    function centerOnObject(index, adjustZoom = false) {
        if (index < 0 || index >= userObjects.length || !userObjects[index]) return;
        const obj = userObjects[index];
        if (!obj.contours || obj.contours.length === 0 || !obj.contours[0] || obj.contours[0].length === 0) {
            showNotification("Невозможно центрировать: нет валидных координат.", "warning", "exclamation-triangle"); return;
        };
        let oMinX = Infinity, oMinY = Infinity, oMaxX = -Infinity, oMaxY = -Infinity, hasPts = false;
        obj.contours.forEach(c => {
            if (!c) return;
            c.forEach(p => {
                if (p && isFinite(p.x) && isFinite(p.y)) {
                    oMinX = Math.min(oMinX, p.x); oMinY = Math.min(oMinY, p.y);
                    oMaxX = Math.max(oMaxX, p.x); oMaxY = Math.max(oMaxY, p.y);
                    hasPts = true;
                }
            });
        });
        if (!hasPts) {
            showNotification("Невозможно центрировать: координаты объекта невалидны.", "error", "exclamation-circle"); return;
        }
        const oW = Math.max(1e-6, oMaxX - oMinX); const oH = Math.max(1e-6, oMaxY - oMinY);
        const oCX = oMinX + oW / 2; const oCY = oMinY + oH / 2;
        const cW = canvas.width || 100; const cH = canvas.height || 100;
        calculateBounds();
        if (adjustZoom) {
            const sX = cW / oW * 0.8; const sY = cH / oH * 0.8;
            let nS = Math.min(sX, sY);
            nS = Math.max(1e-9, Math.min(nS, 10000));
            if (!isFinite(nS) || nS <= 0) nS = scale; scale = nS;
        }
        offsetX = cW / 2 - (roundCoord(oCY) - cMinYGlob()) * scale;
        offsetY = cH / 2 - (roundCoord(oCX) - cMinXGlob()) * scale;
        if (!hasValidView()) resetView();
        updateViewInfo(); redraw(true); saveState();
        if (!adjustZoom) showNotification(`Центрировано на "${obj.name || `Объект ${obj.id}`}"`, "info", "crosshairs");
    }
   
     function addInfoItem(label, value, isCopyable = false, objectIndex = -1) {
        let displayValue = 'Н/Д';
        if (value !== undefined && value !== null) {
            if (typeof value === 'number' && isFinite(value)) {
                displayValue = value.toFixed(2);
            } else if (typeof value === 'string') {
                displayValue = value;
            } else if (typeof value === 'number') {
                 displayValue = 'Не число';
            }
        }
        const itemDiv = document.createElement('div');
        itemDiv.className = 'info-item';
        itemDiv.dataset.label = label; // <-- ДОБАВЛЕНО: Уникальный идентификатор для элемента
        const labelSpan = document.createElement('span');
        labelSpan.textContent = label;
        const valueSpan = document.createElement('span');
        valueSpan.textContent = displayValue;
        if (label === 'Цвет' && value !== 'Н/Д' && objectIndex !== -1) {
            valueSpan.classList.add('color-picker-trigger'); valueSpan.title = 'Кликните для выбора цвета';
            valueSpan.style.cursor = 'pointer'; valueSpan.style.fontWeight = 'bold';
            const colorSwatch = document.createElement('span');
            colorSwatch.style.display = 'inline-block'; colorSwatch.style.width = '12px'; colorSwatch.style.height = '12px';
            colorSwatch.style.backgroundColor = value; colorSwatch.style.border = '1px solid #ccc';
            colorSwatch.style.marginRight = '5px'; colorSwatch.style.verticalAlign = 'middle';
            valueSpan.prepend(colorSwatch);
        } else if (isCopyable && displayValue !== 'Н/Д' && displayValue !== 'Не число') {
            valueSpan.classList.add('copyable'); valueSpan.title = 'Двойной клик для копирования';
            valueSpan.ondblclick = (e) => {
                e.stopPropagation(); copyToClipboard(value.toString());
                valueSpan.classList.add('flash'); setTimeout(() => valueSpan.classList.remove('flash'), 500);
            };
        }
        itemDiv.appendChild(labelSpan); itemDiv.appendChild(valueSpan);
        selectedObjectInfoDiv.appendChild(itemDiv); return itemDiv;
    }
    
    
    function displayObjectInfo(index) {
        selectedObjectIndex = index;
        if (isGeometryEditMode && editingObjectIndex !== selectedObjectIndex) {
            deactivateGeometryEditMode(false);
        }

        selectedObjectInfoDiv.innerHTML = ''; coordinatesTableContainer.innerHTML = '';
        intersectionList.innerHTML = ''; intersectionsTitle.style.display = 'none';

        if (index < 0 || index >= userObjects.length || !userObjects[index]) {
            selectedObjectInfoDiv.innerHTML = '<p style="color: #777; font-style: italic; text-align: center;">Объект не выбран.</p>';
            updateObjectListSelection(); return;
        }
        const obj = userObjects[index];
        const nameContainer = document.createElement('div'); nameContainer.style.marginBottom = '10px';
        const nameLabel = document.createElement('h3'); nameLabel.textContent = obj.name || `Объект ${obj.id}`;
        nameLabel.title = "Кликните для переименования"; nameLabel.onclick = () => handleRenameRequest(index);
        nameContainer.appendChild(nameLabel); selectedObjectInfoDiv.appendChild(nameContainer);

        const pointCount = (obj.contours || []).reduce((sum, c) => sum + (c ? c.length : 0), 0);
        let typeDisplay = 'Н/Д';
        if (obj.type === 'polygon') typeDisplay = 'Полигон';
        else if (obj.type === 'line') typeDisplay = 'Линия';
        else if (obj.type === 'point') typeDisplay = 'Точка';

        addInfoItem('ID', obj.id); addInfoItem('Тип', typeDisplay);
        addInfoItem('Цвет', obj.color || 'Н/Д', false, index);
        addInfoItem(obj.type === 'line' ? 'Длина (м)' : 'Периметр (м)', obj.perimeter);
        addInfoItem('Площадь (кв. м)', obj.type === 'polygon' && obj.area > 1e-9 ? obj.area : 0);
        addInfoItem('Контуры', (obj.contours || []).length); addInfoItem('Точки', pointCount);

        const colorValueSpan = selectedObjectInfoDiv.querySelector('.color-picker-trigger');
        if (colorValueSpan) {
             colorValueSpan.onclick = (e) => {
                 e.stopPropagation();
                 if (index < 0 || index >= userObjects.length || !userObjects[index]) return;
                 const currentColor = userObjects[index].color || '#000000';
                 const colorInput = document.createElement('input');
                 colorInput.type = 'color'; colorInput.value = currentColor;
                 colorInput.style.position = 'absolute'; colorInput.style.left = '-9999px'; colorInput.style.top = '-9999px';
                 colorInput.onchange = (event) => {
                     const newColor = event.target.value; userObjects[index].color = newColor;
                     colorValueSpan.textContent = newColor;
                     const colorSwatch = colorValueSpan.querySelector('span');
                     if (colorSwatch) colorSwatch.style.backgroundColor = newColor;
                     else {
                           const newSwatch = document.createElement('span');
                           newSwatch.style.display = 'inline-block'; newSwatch.style.width = '12px'; newSwatch.style.height = '12px';
                           newSwatch.style.backgroundColor = newColor; newSwatch.style.border = '1px solid #ccc';
                           newSwatch.style.marginRight = '5px'; newSwatch.style.verticalAlign = 'middle';
                           colorValueSpan.prepend(newSwatch);
                     }
                     updateObjectListColorIndicator(index, newColor); redraw(true); saveState();
                     showNotification(`Цвет объекта "${obj.name || obj.id}" изменен на ${newColor}`, 'success', 'palette');
                     document.body.removeChild(colorInput);
                 };
                 document.body.appendChild(colorInput); colorInput.click();
                 colorInput.onblur = () => { setTimeout(() => { if (colorInput.parentNode === document.body) document.body.removeChild(colorInput); }, 100); };
            };
        }
        const btnContainer = document.createElement('div'); btnContainer.style.marginTop = '15px';
        const showCoordsBtn = document.createElement('button'); showCoordsBtn.id = 'showCoordinatesBtn'; showCoordsBtn.className = 'panel-button'; showCoordsBtn.innerHTML = '<i class="fas fa-list-ol"></i> Координаты'; showCoordsBtn.onclick = () => toggleCoordinatesTable(index); btnContainer.appendChild(showCoordsBtn);
        
              const schemaBtn = document.createElement('button'); 
        schemaBtn.id = 'openSchemaBtn'; 
        schemaBtn.className = 'panel-button'; 
        schemaBtn.innerHTML = '<i class="fas fa-map"></i> Схема'; 
        schemaBtn.title = 'Скопировать координаты и открыть схему';
        schemaBtn.onclick = () => {
            handleCopyAllCoordinates(index); 
            window.open('схема.html', '_blank'); 
        };
        btnContainer.appendChild(schemaBtn);
        
        const copyAllCoordsBtn = document.createElement('button'); copyAllCoordsBtn.id = 'copyAllCoordinatesBtn'; copyAllCoordsBtn.className = 'panel-button'; copyAllCoordsBtn.innerHTML = '<i class="fas fa-copy"></i> Копировать'; copyAllCoordsBtn.title = 'Скопировать все координаты объекта (X\tY)'; copyAllCoordsBtn.onclick = () => handleCopyAllCoordinates(index); btnContainer.appendChild(copyAllCoordsBtn);
        const centerBtn = document.createElement('button'); centerBtn.id = 'centerObjectBtn'; centerBtn.className = 'panel-button'; centerBtn.innerHTML = '<i class="fas fa-crosshairs"></i> Центрировать'; centerBtn.onclick = () => centerOnObject(index, false); btnContainer.appendChild(centerBtn);
        const renameBtn = document.createElement('button'); renameBtn.id = 'renameObjectBtn'; renameBtn.className = 'panel-button'; renameBtn.innerHTML = '<i class="fas fa-pencil-alt"></i> Переименовать'; renameBtn.onclick = () => handleRenameRequest(index); btnContainer.appendChild(renameBtn);
        const deleteBtn = document.createElement('button'); deleteBtn.id = 'deleteObjectBtn'; deleteBtn.className = 'panel-button'; deleteBtn.innerHTML = '<i class="fas fa-trash-alt"></i> Удалить'; deleteBtn.onclick = () => deleteObject(index); btnContainer.appendChild(deleteBtn);
        selectedObjectInfoDiv.appendChild(btnContainer);

        calculateAndDisplayIntersections(index); updateObjectListSelection();
    }
    function handleCopyAllCoordinates(objectIndex) {
        if (objectIndex < 0 || objectIndex >= userObjects.length || !userObjects[objectIndex]) {
            showNotification("Объект не выбран или невалиден.", "error", "exclamation-circle"); return;
        }
        const obj = userObjects[objectIndex];
        if (!obj.contours || obj.contours.length === 0) {
            showNotification("У объекта нет координат для копирования.", "warning", "exclamation-triangle"); return;
        }
        let allCoordsString = "";
        obj.contours.forEach((contour, cIdx) => {
            if (!contour) return;
            contour.forEach(point => {
                if (point && isFinite(point.x) && isFinite(point.y)) {
                    allCoordsString += `${point.x.toFixed(2)}\t${point.y.toFixed(2)}\n`;
                }
            });
            if (obj.contours.length > 1 && cIdx < obj.contours.length - 1 && contour.length > 0) {
                 allCoordsString += "\n"; // Add blank line between contours for multi-contour objects
            }
        });
        if (allCoordsString.trim() === "") {
            showNotification("Нет валидных координат для копирования.", "warning", "exclamation-triangle"); return;
        }
        copyToClipboard(allCoordsString.trim());
    }
    function toggleCoordinatesTable(index) {
        if (index < 0 || index >= userObjects.length || !userObjects[index]) return;
        const obj = userObjects[index];
        const btn = document.getElementById('showCoordinatesBtn');
        const isVisible = coordinatesTableContainer.querySelector('.coordinates-table') !== null;

        if (isVisible) {
            coordinatesTableContainer.innerHTML = '';
            if (btn) btn.innerHTML = '<i class="fas fa-list-ol"></i> Координаты';
            selectedCoordinate = null;
            redraw(true);
        } else {
            let selectedPointsForTable = [];
            let pointCounter = 1;

          (obj.contours || []).forEach((contour, contourIndex) => {
                if (!contour || contour.length === 0) return;

                let isClosingPointIdenticalToFirstForThisContour = false; // ADDED: Tracks if the current contour is closed by a duplicate point

                if (obj.contours.length > 1) { // Add contour header for multi-contour objects
                    selectedPointsForTable.push({isHeader: true, text: `Контур ${contourIndex + 1}`});
                }

                contour.forEach((point, pIdx) => {
                    if (point && isFinite(point.x) && isFinite(point.y)) {
                        let displayPointNumber;
                        let isThisSpecificPointADuplicateCloser = false; // MODIFIED: Renamed from isClosingPointIdenticalToFirst for clarity

                        if (obj.type === 'polygon' &&
                            pIdx === contour.length - 1 && // This condition ensures we only check the last point
                            contour.length > 1) {

                            const firstPt = contour[0];
                            const PRECISION_THRESHOLD = 0.001;
                            if (Math.abs(point.x - firstPt.x) < PRECISION_THRESHOLD &&
                                Math.abs(point.y - firstPt.y) < PRECISION_THRESHOLD) {
                                displayPointNumber = 1;
                                isThisSpecificPointADuplicateCloser = true;
                                isClosingPointIdenticalToFirstForThisContour = true; // MODIFIED: Set the contour-level flag
                            } else {
                                displayPointNumber = pointCounter;
                            }
                        } else {
                            displayPointNumber = pointCounter;
                        }

                        selectedPointsForTable.push({
                            contour: contourIndex + 1,
                            point: displayPointNumber,
                            x: point.x,
                            y: point.y,
                            isClosingDuplicate: isThisSpecificPointADuplicateCloser // MODIFIED: Use the point-specific flag
                        });

                        if (!isThisSpecificPointADuplicateCloser) { // MODIFIED: Use the point-specific flag
                            pointCounter++;
                        }
                    }
                });
                 // MODIFIED: Use the contour-level flag here
                 if (obj.type !== 'polygon' || contour.length === 0 || !isClosingPointIdenticalToFirstForThisContour) { 
                     pointCounter = 1; // Reset counter for each contour if not handling single sequence for multi-contour
                 }
            });

            displayCoordinatesTable(selectedPointsForTable);
            if (btn) btn.innerHTML = '<i class="fas fa-times"></i> Скрыть Координаты';
        }
    }
    function displayCoordinatesTable(points) {
        if (!points || points.length === 0) {
            coordinatesTableContainer.innerHTML = '<p style="color: #777; font-style: italic; text-align: center; margin-top: 10px;">Нет координат.</p>';
            return;
        }
        let tableHtml = `<table class="coordinates-table"><thead><tr><th>№ п/п</th><th>X</th><th>Y</th></tr></thead><tbody>`;
        points.forEach(point => {
            if (point.isHeader) {
                tableHtml += `<tr><th colspan="3" style="background-color: #e9ecef; text-align: center;">${point.text}</th></tr>`;
            } else {
                const rowClass = point.isClosingDuplicate ? 'coordinate-row closing-duplicate' : 'coordinate-row';
                tableHtml += `<tr class="${rowClass}" data-x="${point.x}" data-y="${point.y}"><td>${point.point}</td><td class="copyable">${point.x.toFixed(2)}</td><td class="copyable">${point.y.toFixed(2)}</td></tr>`;
            }
        });
        tableHtml += `</tbody></table>`;
        coordinatesTableContainer.innerHTML = tableHtml;
        coordinatesTableContainer.querySelectorAll('.coordinate-row:not(.closing-duplicate):not([data-is-header="true"])').forEach(row => { // Exclude headers and closing duplicates from full interactivity if needed
            row.querySelectorAll('.copyable').forEach(cell => {
                cell.ondblclick = function(e) {
                    e.stopPropagation();
                    copyToClipboard(this.textContent);
                    this.closest('tr')?.classList.add('flash');
                    setTimeout(() => this.closest('tr')?.classList.remove('flash'), 500);
                };
            });
            row.onclick = function() {
                document.querySelectorAll('.coordinate-row.selected-coordinate').forEach(r => r.classList.remove('selected-coordinate'));
                this.classList.add('selected-coordinate');
                const x = parseFloat(this.dataset.x);
                const y = parseFloat(this.dataset.y);
                if (isFinite(x) && isFinite(y)) {
                    selectedCoordinate = { x, y };
                    highlightPointOnMap(x, y);
                } else {
                    selectedCoordinate = null;
                }
            };
        });
    }
    function highlightPointOnMap(x, y) {
        if (!hasValidView() || !isFinite(x) || !isFinite(y)) return;
        let pulseSize = 8; let pulseOpacity = 1; let animationFrameId = null;
        const pulse = () => {
            redraw(true); if (pulseOpacity <= 0 || !hasValidView()) { window.currentPulseAnimation = null; redraw(true); return; }
            const [cx, cy] = transformCoord(x, y); if (!isFinite(cx) || !isFinite(cy)) { window.currentPulseAnimation = null; return; }
            ctx.save(); ctx.setTransform(1, 0, 0, 1, 0, 0);
            ctx.strokeStyle = `rgba(255, 0, 0, ${pulseOpacity})`; ctx.lineWidth = 2.5;
            ctx.beginPath(); ctx.arc(cx, cy, pulseSize, 0, Math.PI * 2); ctx.stroke();
            ctx.fillStyle = 'rgba(255, 0, 0, 0.8)'; ctx.strokeStyle = 'white'; ctx.lineWidth = 1;
            ctx.beginPath(); ctx.arc(cx, cy, 5, 0, Math.PI * 2); ctx.fill(); ctx.stroke();
            ctx.restore();
            pulseSize += 1.5; pulseOpacity -= 0.06;
            if (pulseOpacity > 0) animationFrameId = requestAnimationFrame(pulse);
            else { window.currentPulseAnimation = null; redraw(true); }
        };
        if (window.currentPulseAnimation) cancelAnimationFrame(window.currentPulseAnimation);
        window.currentPulseAnimation = requestAnimationFrame(pulse);
    }
    function calculateAndDisplayIntersections(selectedIndex) {
        intersectionList.innerHTML = '';
        if (selectedIndex < 0 || selectedIndex >= userObjects.length || !userObjects[selectedIndex]) {
            intersectionsTitle.style.display = 'none'; return;
        }
        const selectedObj = userObjects[selectedIndex];
        if (!selectedObj.contours || selectedObj.contours.length === 0 || selectedObj.type !== 'polygon') {
            intersectionList.innerHTML = '<li style="color: #777; font-style: italic;">Проверка пересечений доступна только для полигонов.</li>';
            intersectionsTitle.style.display = 'block'; return;
        }
        let hasRelations = false; const selPolygon = selectedObj.contours[0];
        if (!selPolygon || selPolygon.length < 3 || !selPolygon.every(p => p && isFinite(p.x) && isFinite(p.y))) {
            intersectionList.innerHTML = '<li style="color: #777; font-style: italic;">Выбранный объект не является валидным полигоном.</li>';
            intersectionsTitle.style.display = 'block'; return;
        }
        userObjects.forEach((otherObj, otherIndex) => {
            if (selectedIndex === otherIndex || !otherObj || !otherObj.contours || otherObj.contours.length === 0 || otherObj.type !== 'polygon') return;
            const otherPolygon = otherObj.contours[0];
            if (!otherPolygon || otherPolygon.length < 3 || !otherPolygon.every(p => p && isFinite(p.x) && isFinite(p.y))) return;
            const result = checkIntersection(selPolygon, otherPolygon);
            let message = ""; let liClass = ''; let relationFound = false;
            const otherName = otherObj.name || `Объект ${otherObj.id}`;
            if (result.contains) { message = `Полностью содержит <strong>${otherName}</strong>`; liClass = 'full-containment'; relationFound = true; }
            else if (result.containedBy) { message = `Полностью содержится в <strong>${otherName}</strong>`; liClass = 'contained-by'; relationFound = true; }
            else if (result.intersects) {
                let pointsPoly1InPoly2 = 0; selPolygon.forEach(p => { if (p && isFinite(p.x) && isFinite(p.y) && isPointInPolygon(p, otherPolygon)) pointsPoly1InPoly2++; });
                let pointsPoly2InPoly1 = 0; otherPolygon.forEach(p => { if (p && isFinite(p.x) && isFinite(p.y) && isPointInPolygon(p, selPolygon)) pointsPoly2InPoly1++; });
                if (pointsPoly1InPoly2 > result.sharedVertices || pointsPoly2InPoly1 > result.sharedVertices) {
                    message = `Имеет наложение на <strong>${otherName}</strong>`;
                                   if (result.sharedVertices > 0) {
                    const n = result.sharedVertices;
                    if (n === 1) {
                        message += ` (имеет 1 общую точку)`;
                    } else {
                        const pw = (n > 1 && n < 5) ? 'ки' : 'ек';
                        message += ` (имеет ${n} общих точ${pw})`;
                    }
                }
                    liClass = 'partial-overlap'; if (result.sharedVertices > 0) liClass += ' shared-vertices';
                } else {
                    if (result.sharedVertices > 0) { const pw = result.sharedVertices === 1 ? 'точку' : (result.sharedVertices <= 4 ? 'ки' : 'ек'); message = `Имеет общую границу с <strong>${otherName}</strong> (${result.sharedVertices} точ${pw})`; liClass = 'boundary-touch';}
                    else { message = `Имеет наложение на <strong>${otherName}</strong>`; liClass = 'partial-overlap';}
                }
                relationFound = true;
            } else if (result.sharedVertices > 0) {
                const n = result.sharedVertices;
                let pointsText;
                if (n === 1) {
                    pointsText = `1 общую точку`;
                } else {
                    const pw = (n > 1 && n < 5) ? 'ки' : 'ек';
                    pointsText = `${n} общих точ${pw}`;
                }
                message = `Имеет общую границу с <strong>${otherName}</strong> (${pointsText})`;
                liClass = 'boundary-touch';
                relationFound = true;
            }
            if (relationFound) { hasRelations = true; const li = document.createElement('li'); li.innerHTML = message; li.className = liClass; li.title = `Кликните для выбора объекта ${otherName}`; li.onclick = () => { displayObjectInfo(otherIndex); }; intersectionList.appendChild(li); }
        });
        intersectionsTitle.style.display = 'block';
        if (!hasRelations) intersectionList.innerHTML = '<li style="color: #777; font-style: italic;">Пересечений, наложений или общих границ не найдено.</li>';
    }
    function updateObjectList() {
        objectListUL.innerHTML = ''; const validObjects = userObjects.filter(o => o); objectCountSpan.textContent = validObjects.length;
        if (validObjects.length === 0) { objectListUL.innerHTML = '<li style="color: #777; font-style: italic; padding: 5px 0;">Нет объектов</li>'; return; }
        const sortedObjects = [...validObjects].sort((a, b) => (a.id || 0) - (b.id || 0));
        sortedObjects.forEach((obj) => {
            const originalIndex = userObjects.findIndex(o => o && o.id === obj.id); if (originalIndex === -1) return;
            const li = document.createElement('li'); li.dataset.originalIndex = originalIndex;
            const colorIndicator = document.createElement('span'); colorIndicator.className = 'color-indicator'; colorIndicator.style.backgroundColor = obj.color || '#ccc';
            const nameSpan = document.createElement('span'); nameSpan.className = 'name-span';
            const objName = obj.name || `Объект ${obj.id}`; nameSpan.textContent = objName; nameSpan.title = objName;
            li.appendChild(colorIndicator); li.appendChild(nameSpan);
            if (originalIndex === selectedObjectIndex) li.classList.add('selected');

            li.onclick = () => {
                const idx = parseInt(li.dataset.originalIndex);
                if (!isNaN(idx) && selectedObjectIndex !== idx) {
                    if (isDrawingMode && isDrawingActive) cancelDrawing();
                    if (isGeometryEditMode) deactivateGeometryEditMode(false);
                    displayObjectInfo(idx);
                    redraw(true);
                } else if (!isNaN(idx) && selectedObjectIndex === idx) {
                    if (isGeometryEditMode && editingObjectIndex !== idx) {
                        deactivateGeometryEditMode(false);
                        activateGeometryEditMode();
                    }
                }
            };
            objectListUL.appendChild(li);
        });
        updateObjectListSelection();
    }
    function updateObjectListSelection() {
        const items = objectListUL.querySelectorAll('li'); items.forEach(li => { if (!li.dataset.originalIndex) return; const idx = parseInt(li.dataset.originalIndex); if (isNaN(idx)) return; if (idx === selectedObjectIndex) { li.classList.add('selected'); requestAnimationFrame(() => { try { li.scrollIntoView({ behavior: 'smooth', block: 'nearest' }); } catch(e) { li.scrollIntoView(false); } }); } else { li.classList.remove('selected'); } });
    }
    function updateObjectListColorIndicator(objectIndex, newColor) {
        if (!objectListUL) return; const items = objectListUL.querySelectorAll('li'); items.forEach(li => { if (li.dataset.originalIndex === String(objectIndex)) { const colorIndicator = li.querySelector('.color-indicator'); if (colorIndicator) colorIndicator.style.backgroundColor = newColor || '#ccc'; } });
    }
    function showNotification(message, type = 'info', icon = 'info-circle') {
        const n = document.createElement('div'); n.className = `notification ${type}`; n.innerHTML = `<i class="fas fa-${icon}"></i> ${message}`; document.body.appendChild(n); requestAnimationFrame(() => { n.classList.add('show'); setTimeout(() => { n.classList.remove('show'); setTimeout(() => n.remove(), 500); }, 3000); });
    }
    function copyToClipboard(text) {
        if (text === undefined || text === null) text = ''; navigator.clipboard.writeText(text.toString()).then(() => { const sT = text.toString().substring(0, 30); showNotification(`Скопировано: "${sT}${text.toString().length > 30 ? '...' : ''}"`, 'success', 'check-circle'); }).catch(err => { showNotification('Ошибка копирования в буфер', 'error', 'exclamation-circle'); });
    }
    function hexToRgba(hex, alpha) {
        if (typeof alpha !== 'number' || !isFinite(alpha)) alpha = 1.0; alpha = Math.max(0, Math.min(1, alpha)); if (!hex || typeof hex !== 'string') hex = '#000000'; hex = hex.replace('#', ''); if (hex.length === 3) hex = hex[0]+hex[0]+hex[1]+hex[1]+hex[2]+hex[2]; if (hex.length !== 6) hex = '000000'; const r = parseInt(hex.substring(0, 2), 16); const g = parseInt(hex.substring(2, 4), 16); const b = parseInt(hex.substring(4, 6), 16); if (isNaN(r) || isNaN(g) || isNaN(b)) return `rgba(0, 0, 0, ${alpha})`; return `rgba(${r}, ${g}, ${b}, ${alpha})`;
    }
    function resetMeasurement() { rulerPoints = []; updateMeasurementPanel(); redraw(true); }
    function updateMeasurementPanel() { if (!rulerMode) return; let coordText = 'Точка 1: -<br>Точка 2: -'; let distText = 'Расстояние: -'; if (rulerPoints.length >= 1) { const p1 = rulerPoints[0]; const p1x = (p1 && isFinite(p1.x)) ? p1.x.toFixed(2) : '-'; const p1y = (p1 && isFinite(p1.y)) ? p1.y.toFixed(2) : '-'; coordText = `Точка 1: X=${p1x}, Y=${p1y}<br>Точка 2: Выберите...`; } if (rulerPoints.length === 2) { const p1 = rulerPoints[0]; const p2 = rulerPoints[1]; if (p1 && p2 && isFinite(p1.x) && isFinite(p1.y) && isFinite(p2.x) && isFinite(p2.y)) { const dist = calculateDistance(p1, p2); coordText = `Точка 1: X=${p1.x.toFixed(2)}, Y=${p1.y.toFixed(2)}<br>Точка 2: X=${p2.x.toFixed(2)}, Y=${p2.y.toFixed(2)}`; distText = `Расстояние: ${isFinite(dist) ? dist.toFixed(2) + ' м' : '-'}`; } else { coordText = `Точка 1: ${isFinite(p1?.x) ? p1.x.toFixed(2) : '-'}, Y=${isFinite(p1?.y) ? p1.y.toFixed(2) : '-'}<br>Точка 2: Ошибка`; distText = 'Расстояние: -'; } } measurementCoordinates.innerHTML = coordText; measurementDistance.textContent = distText; }
    function calculateDistance(p1, p2) { if (!p1 || !p2 || !isFinite(p1.x) || !isFinite(p1.y) || !isFinite(p2.x) || !isFinite(p2.y)) return NaN; const dx = p2.x - p1.x; const dy = p2.y - p1.y; return Math.sqrt(dx * dx + dy * dy); }
    function togglePointsVisibility() { showPoints = !showPoints; redraw(true); showNotification(showPoints ? 'Точки включены' : 'Точки отключены', 'info', showPoints ? 'eye' : 'eye-slash'); updateToggleButtonStates(); saveState(); }

    function activateDrawingMode() { isDrawingMode = true; isDrawingActive = true; currentDrawingPoints = []; showNotification('Режим рисования. Клик: точка. Двойной клик: полигон. ✓: линия/точка.', 'info', 'pencil-alt'); selectedObjectIndex = -1; displayObjectInfo(-1); updateObjectListSelection(); redraw(true); }
    function cancelDrawing() { if (isDrawingActive) { showNotification('Рисование отменено.', 'info', 'times-circle'); } finalizeDrawingState(); }

 function finalizeDrawingState() {
    isDrawingMode = false;
    isDrawingActive = false;
    currentDrawingPoints = [];
    snappedToPointVisual = null;
    redraw(true);
    if (!rulerMode && !isGeometryEditMode && !isMovingPoint) canvas.style.cursor = 'grab';
    updateToggleButtonStates();
}
    
    async function finishDrawingAsPolygon() {
         if (!isDrawingActive) return;
         const validPointsRaw = currentDrawingPoints.filter(p => p && isFinite(p.x) && isFinite(p.y));
         if (validPointsRaw.length < 3) {
             showNotification("Нужно минимум 3 точки для полигона.", "warning", "exclamation-triangle");
             return;
         }
         let finalPolygonPoints = [...validPointsRaw];
         const firstPoint = finalPolygonPoints[0];
         const lastPoint = finalPolygonPoints[finalPolygonPoints.length - 1];
         const PRECISION_THRESHOLD = 0.001;
         const isAlreadyClosed = Math.abs(firstPoint.x - lastPoint.x) < PRECISION_THRESHOLD &&
                                 Math.abs(firstPoint.y - lastPoint.y) < PRECISION_THRESHOLD;
         if (!isAlreadyClosed) {
             finalPolygonPoints.push({ x: firstPoint.x, y: firstPoint.y });
         }
         if (finalPolygonPoints.length < 3) {
            showNotification("Недостаточно уникальных точек для полигона после замыкания.", "warning", "exclamation-triangle");
            return;
         }
         showLoader(false);
         const name = await showNamePrompt("Имя нового полигона:", `Нарисованный ${nextObjectId}`);
         if (name !== null) {
            const newObj = addObjectInternal([finalPolygonPoints], name, 'polygon', true); // Pass as array of contours
            if (newObj) {
                 finalizeBatchAdd([newObj]);
            }
         } else {
            showNotification('Создание полигона отменено.', 'warning', 'times-circle');
         }
         finalizeDrawingState();
    }
    async function finishDrawingAsLineOrPoint() {
        if (!isDrawingActive) return;
        const validPoints = currentDrawingPoints.filter(p => p && isFinite(p.x) && isFinite(p.y));
        if (validPoints.length < 1) { showNotification("Нет точек для создания объекта.", "warning", "exclamation-triangle"); cancelDrawing(); return; }
        const objectType = validPoints.length >= 2 ? 'line' : 'point';
        const typeDesc = objectType === 'line' ? 'линии' : 'точки';
        showLoader(false);
        const name = await showNamePrompt(`Имя новой ${typeDesc}:`, `Нарисованный ${nextObjectId}`);
        if (name !== null) {
            const newObj = addObjectInternal([validPoints], name, objectType, true); // Pass as array of contours
             if (newObj) {
                 finalizeBatchAdd([newObj]);
            }
        } else {
            showNotification(`Создание ${typeDesc} отменено.`, 'warning', 'times-circle');
        }
        finalizeDrawingState();
    }
    async function handleRenameRequest(index) {
        if (index < 0 || index >= userObjects.length || !userObjects[index]) return;
        const currentName = userObjects[index].name || `Объект ${userObjects[index].id}`;
        const newName = await showNamePrompt(`Переименовать объект:`, currentName);
        if (newName !== null) await renameObject(index, newName);
    }

async function fetchNspd(url) {
        // Заголовки, которые мы будем использовать, включая обязательный Referer
        const requestHeaders = {
            'Referer': 'https://nspd.gov.ru/'
        };

        // Попытка прямого запроса
        try {
            const directResponse = await fetch(url, { headers: requestHeaders });
            if (!directResponse.ok) {
                throw new Error(`Прямой запрос не удался: ${directResponse.status}`);
            }
            return await directResponse.json();
        } catch (error) {
            console.warn(`Прямой запрос не удался: ${error.message}. Переключаюсь на прокси.`);
            
            // Запасной вариант: запрос через прокси
            const vercelProxyUrl = 'https://nsp-two.vercel.app/';
            const urlObject = new URL(url);
            const targetPath = `${urlObject.pathname}${urlObject.search}`;
            const proxyRequestUrl = `${vercelProxyUrl}?target=${encodeURIComponent(targetPath)}`;

            const proxyResponse = await fetch(proxyRequestUrl, { headers: requestHeaders });
            if (!proxyResponse.ok) {
                const errorText = await proxyResponse.text();
                throw new Error(`Запрос через прокси также не удался: ${proxyResponse.statusText}. Ответ: ${errorText}`);
            }
            return await proxyResponse.json();
        }
    }

    async function fetchCadastralData(cadastralNumber) {
        const url = `https://nspd.gov.ru/api/geoportal/v2/search/geoportal?thematicSearchId=1&query=${cadastralNumber}`;
        const data = await fetchNspd(url);

        if (!data.data || !data.data.features || data.data.features.length === 0) {
            throw new Error(`Объект с КН ${cadastralNumber} не найден в ЕГРН.`);
        }
        return data.data.features[0];
    }

    // --- Supabase specific functions ---
    function isValidCadastralNumberFormat(text) {
        if (!text) return false;
        const pattern = new RegExp(`^\\d{2}:\\d{2}:\\d{6,7}:\\d+$`);
        return pattern.test(text);
    }

    function getElementValueFromNode(element, tagName) {
        if (!element) return '';
        const parts = tagName.split('>');
        let currentElement = element;
        for (let part of parts) {
            currentElement = currentElement.querySelector(part);
            if (!currentElement) return '';
        }
        return currentElement.textContent.trim();
    }


function extractCoordinatesFromXMLNode(recordNode) {
    const allContoursData = [];

    // Вспомогательная функция для извлечения точек из контейнера (entity_spatial или spatials_elements)
    const processSpatialNode = (container) => {
        if (!container) return;
        
        // В KPT координаты лежат в spatial_element.
        // querySelectorAll найдет их даже если они вложены в spatials_elements
        const spatialElements = container.querySelectorAll("spatial_element");
        
        spatialElements.forEach(spEl => {
            const ordinates = spEl.querySelectorAll("ordinates > ordinate");
            const currentContourPoints = [];
            
            ordinates.forEach(ord => {
                // Используем простые селекторы для скорости и надежности
                const xNode = ord.querySelector("x");
                const yNode = ord.querySelector("y");
                
                if (xNode && yNode) {
                    const x = parseFloat(xNode.textContent);
                    const y = parseFloat(yNode.textContent);
                    
                    if (isFinite(x) && isFinite(y)) {
                        currentContourPoints.push({ x: roundCoord(x), y: roundCoord(y) });
                    }
                }
            });

            if (currentContourPoints.length > 0) {
                allContoursData.push(currentContourPoints);
            }
        });
    };

    // 1. Сценарий для Земельных участков (land_record) в КПТ: ищем contours_location
    const contoursLocation = recordNode.querySelector("contours_location");
    
    if (contoursLocation) {
        // Внутри могут быть contours -> contour
        const contours = contoursLocation.querySelectorAll("contours > contour");
        
        if (contours.length > 0) {
            contours.forEach(c => {
                // Ищем entity_spatial внутри контура
                processSpatialNode(c.querySelector("entity_spatial"));
            });
        } else {
            // Иногда entity_spatial лежит сразу в contours_location (без contour)
            processSpatialNode(contoursLocation.querySelector("entity_spatial"));
        }
    } 
    // 2. Сценарий для ОКС (build_record), Сооружений и выписок КВЗУ: ищем entity_spatial напрямую в корне объекта
    else {
        const entitySpatial = recordNode.querySelector("entity_spatial");
        if (entitySpatial) {
            processSpatialNode(entitySpatial);
        } else {
            // Фолбэк: пробуем найти contours напрямую, если это старый формат или специфическая выписка
            const directContours = recordNode.querySelectorAll("contours > contour");
            directContours.forEach(c => processSpatialNode(c.querySelector("entity_spatial")));
        }
    }

    if (allContoursData.length === 0) {
        const cadNumberElem = recordNode.querySelector('common_data > cad_number');
        const cadNumber = cadNumberElem ? cadNumberElem.textContent.trim() : 'Неизвестный';
        // console.warn(`[CoordExtractor] Не удалось извлечь координаты для ${cadNumber}. Проверьте структуру XML.`);
    }

    return allContoursData;
}


async function fetchParcelCoordinatesFromStorage(cadNumber) {
    console.log(`[StorageAPI] Запрос для КН: ${cadNumber}`);
    const parts = cadNumber.split(':');
    if (parts.length < 3) {
        const errorMsg = `Неверный формат КН для извлечения квартала: ${cadNumber}`;
        showNotification(errorMsg, "error", "hashtag");
        console.error(`[StorageAPI] ${errorMsg}`);
        return null;
    }
    const quarterNumber = parts.slice(0, 3).join(':');
    const serverQuarterPrefix = quarterNumber.replace(/:/g, '_');
    console.log(`[StorageAPI] Поиск файлов для квартала: ${serverQuarterPrefix}`);

    try {
        const responseList = await fetch(`${STORAGE_API_URL}/${BUCKET_NAME}?search=${serverQuarterPrefix}`);
        if (!responseList.ok) throw new Error(`Ошибка получения списка файлов: ${responseList.statusText}`);
        
        const fileList = await responseList.json();
        if (!fileList || fileList.length === 0) throw new Error(`КПТ для квартала ${quarterNumber} не найдены на сервере.`);

        const matchingFiles = fileList.filter(f => f.name.startsWith(serverQuarterPrefix) && f.name.toLowerCase().endsWith('.zip'));
        if (matchingFiles.length === 0) throw new Error(`Архивы КПТ для квартала ${quarterNumber} не найдены.`);

        const latestFile = matchingFiles.sort((a, b) => b.name.localeCompare(a.name))[0];
        console.log(`[StorageAPI] Выбран файл КПТ: ${latestFile.name}`);

        const responseDownload = await fetch(`${STORAGE_API_URL}/${BUCKET_NAME}/${latestFile.name}`);
        if (!responseDownload.ok) throw new Error(`Ошибка загрузки файла: ${responseDownload.statusText}`);
        
        const blob = await responseDownload.blob();
        const zip = await JSZip.loadAsync(blob);
        
        let xmlFileEntry = null;
        for (const fileNameInZip in zip.files) {
            if (fileNameInZip.toLowerCase().endsWith('.xml') && !zip.files[fileNameInZip].dir) {
                xmlFileEntry = zip.files[fileNameInZip];
                break;
            }
        }
        if (!xmlFileEntry) throw new Error("XML-файл не найден в архиве КПТ.");

        const xmlContent = await xmlFileEntry.async('string');
        const parser = new DOMParser();
        const xmlDoc = parser.parseFromString(xmlContent, "text/xml");
        
        let foundRecordNode = null;

        const allRecords = xmlDoc.querySelectorAll('land_record, build_record, construction_record');
        
        for (const record of allRecords) {
            const cnElem = record.querySelector('object > common_data > cad_number');
            if (cnElem && cnElem.textContent.trim() === cadNumber) {
                foundRecordNode = record;
                break; 
            }
        }

        if (!foundRecordNode) {
            throw new Error(`Объект ${cadNumber} не найден в XML файле ${latestFile.name}.`);
        }
        
        const extractedContours = extractCoordinatesFromXMLNode(foundRecordNode);
        const objectType = foundRecordNode.tagName.toLowerCase(); // 'land_record', 'build_record', 'construction_record'
        
        console.log(`[StorageAPI] Извлечено контуров для ${cadNumber}: ${extractedContours.length}, тип: ${objectType}`);
        return { contours: extractedContours, type: objectType }; // Возвращаем объект с контурами и типом

    } catch (error) {
        console.error(`[StorageAPI] Общая ошибка для КН ${cadNumber}:`, error);
        showNotification(`Ошибка для ${cadNumber}: ${error.message}`, "error", "times-circle");
        return null;
    }
}


function showLoader(show, text = "Загрузка...") {
    const btn = document.getElementById('cancelLoadBtn');
    if (show) {
        loaderTextElement.textContent = text;
        loaderContainer.style.display = 'flex';
        // Показываем кнопку отмены
        if (btn) btn.style.display = 'block';
    } else {
        loaderContainer.style.display = 'none';
        if (btn) btn.style.display = 'none';
    }
}

async function handleImportFromCadNumbers(cadNumbers) {
    if (!STORAGE_API_URL) {
        showNotification("URL хранилища не задан.", "error", "server");
        return;
    }
    closeCoordsDialog();

    let addedObjects = [];
    let errors = 0;
    
    // Сбрасываем флаг отмены перед началом
    isNspdLoadCancelled = false;

    // 1. Группируем кадастровые номера по кварталам
    const tasksByQuarter = {};
    
    cadNumbers.forEach(cn => {
        const parts = cn.split(':');
        if (parts.length >= 3) {
            // Получаем квартал (например, 16:56:010130)
            const quarter = parts.slice(0, 3).join(':');
            if (!tasksByQuarter[quarter]) {
                tasksByQuarter[quarter] = [];
            }
            tasksByQuarter[quarter].push(cn);
        } else {
            console.warn(`Неверный формат КН: ${cn}`);
            errors++;
        }
    });

    const quartersToProcess = Object.keys(tasksByQuarter);
    showLoader(true, `Обработка ${quartersToProcess.length} кварталов...`);

    // 2. Проходим по каждому кварталу
    for (let i = 0; i < quartersToProcess.length; i++) {
        if (isNspdLoadCancelled) {
            console.log("Загрузка прервана пользователем.");
            break;
        }

        const quarter = quartersToProcess[i];
        const cnsInQuarter = tasksByQuarter[quarter];
        
        showLoader(true, `Загрузка квартала ${quarter} (${i + 1}/${quartersToProcess.length})...`);

        try {
            // Скачиваем XML один раз для всего квартала
            const xmlContent = await fetchKptXmlContent(quarter);
            
            if (!xmlContent) {
                throw new Error("Файл пуст или не найден");
            }

            // Парсим XML один раз
            const parser = new DOMParser();
            const xmlDoc = parser.parseFromString(xmlContent, "text/xml");

            // Создаем карту (Map) всех объектов в XML для быстрого поиска
            // Ключ: Кадастровый номер, Значение: XML-узел
            const recordsMap = new Map();
            const allRecords = xmlDoc.querySelectorAll('land_record, build_record, construction_record');
            
            allRecords.forEach(record => {
                const cnNode = record.querySelector('common_data > cad_number');
                if (cnNode) {
                    recordsMap.set(cnNode.textContent.trim(), record);
                }
            });

            // 3. Извлекаем нужные объекты из этого XML
            cnsInQuarter.forEach(cn => {
                const recordNode = recordsMap.get(cn);
                
                if (recordNode) {
                    const contours = extractCoordinatesFromXMLNode(recordNode);
                    const objectType = recordNode.tagName.toLowerCase(); // 'land_record' и т.д.
                    
                    if (contours && contours.length > 0) {
                        const newObj = addObjectInternal(contours, cn, "polygon", true, objectType);
                        if (newObj) {
                            addedObjects.push(newObj);
                        } else {
                            errors++;
                        }
                    } else {
                        console.warn(`Контуры не найдены для ${cn}`);
                        errors++;
                    }
                } else {
                    console.warn(`Объект ${cn} не найден в файле квартала.`);
                    errors++;
                }
            });

        } catch (err) {
            console.error(`Ошибка обработки квартала ${quarter}:`, err);
            // Если ошибка загрузки квартала, помечаем все КН в нем как ошибочные
            errors += cnsInQuarter.length;
            showNotification(`Ошибка загрузки квартала ${quarter}: ${err.message}`, "error");
        }
    }

    showLoader(false);

    // Добавляем на карту то, что успели загрузить
    if (addedObjects.length > 0) {
        finalizeBatchAdd(addedObjects);
        const msg = isNspdLoadCancelled 
            ? `Загрузка прервана. Успешно загружено: ${addedObjects.length}.`
            : `Загружено ${addedObjects.length} объектов.`;
        
        showNotification(msg, isNspdLoadCancelled ? "warning" : "success");
    } else {
        if (isNspdLoadCancelled) {
            showNotification("Загрузка отменена. Объектов не добавлено.", "info");
        } else if (errors > 0) {
            showNotification(`Не удалось загрузить объекты. Ошибок: ${errors}.`, "error");
        } else {
            showNotification("Объекты не найдены.", "warning");
        }
    }
}

    function finalizeBatchAdd(addedObjectsArray) {
        if (addedObjectsArray.length === 0) return;
        updateObjectList();
        selectedObjectIndex = userObjects.indexOf(addedObjectsArray[addedObjectsArray.length - 1]);
        calculateBounds();
        displayObjectInfo(selectedObjectIndex);
        setTimeout(() => {
            if (selectedObjectIndex !== -1) centerOnObject(selectedObjectIndex, true);
            else resetView();
        }, 100);
        saveState();
        redraw(true);
    }
    
    
    
    
    
    
    
    
    // --- ИНСТРУМЕНТ: ТОЧКИ ПЕРЕСЕЧЕНИЯ ---

    function toggleIntersectTool() {
        if (!isGeometryEditMode) return;
        
        // Выключаем другие инструменты если активны
        if (isCutToolActive) toggleCutTool();

        isIntersectToolActive = !isIntersectToolActive;
        const btn = document.getElementById('intersectPointsBtn');
        
        if (isIntersectToolActive) {
            btn.classList.add('active');
            intersectTargetIndex = -1;
            showNotification("Инструмент «Пересечения»: Выберите ПЕРВЫЙ объект (двойной клик).", "info", "project-diagram");
            canvas.style.cursor = 'crosshair';
        } else {
            btn.classList.remove('active');
            intersectTargetIndex = -1;
            showNotification("Инструмент «Пересечения» выключен.", "info", "times");
            canvas.style.cursor = 'default';
        }
        redraw(true);
    }


    function handleIntersectSelection(point) {
        let clickedIdx = -1;
        // Ищем объект под курсором
        for (let i = userObjects.length - 1; i >= 0; i--) {
            const obj = userObjects[i];
            if (obj && obj.contours) {
                if (obj.type === 'polygon' && obj.contours.some(c => isPointInPolygonRobust(point, c))) {
                    clickedIdx = i; break;
                }
            }
        }

        if (clickedIdx === -1) return;

        if (intersectTargetIndex === -1) {
            intersectTargetIndex = clickedIdx;
            const objName = userObjects[clickedIdx].name || `Объект ${userObjects[clickedIdx].id}`;
            showNotification(`Выбран №1: "${objName}". Выберите ВТОРОЙ объект.`, "warning", "hand-pointer");
        } else {
            if (clickedIdx === intersectTargetIndex) {
                 showNotification("Выберите другой объект.", "error");
                 return; 
            }

            const obj2Name = userObjects[clickedIdx].name || `Объект ${userObjects[clickedIdx].id}`;
            showNotification(`Второй: "${obj2Name}". Расчет пересечений...`, "info", "cog");
            
            // Вместо создания сразу, запускаем расчет и открываем диалог
            prepareIntersectionOptions(intersectTargetIndex, clickedIdx);
        }
    }

    // НОВАЯ ФУНКЦИЯ: Расчет точек и открытие диалога
    function prepareIntersectionOptions(idx1, idx2) {
        const points = calculateIntersectionCoordinates(idx1, idx2);
        
        if (points.length === 0) {
            showNotification("Пересечений не найдено.", "warning");
            intersectTargetIndex = -1; // Сброс
            return;
        }

        // Сохраняем данные для выбора пользователя
        pendingIntersectionData = {
            points: points,
            idx1: idx1,
            idx2: idx2
        };

        // Открываем диалог
        const dialog = document.getElementById('intersectionOptionsDialog');
        const overlay = document.getElementById('dialogOverlay');
        document.getElementById('intersectionCountText').textContent = `Найдено точек пересечения: ${points.length}`;
        
        dialog.style.display = 'block';
        overlay.classList.add('show');
        overlay.style.display = 'block';
    }

    // НОВАЯ ФУНКЦИЯ: Расчет координат (вынесена из старой createIntersectionPoints)
    function calculateIntersectionCoordinates(idx1, idx2) {
        const obj1 = userObjects[idx1];
        const obj2 = userObjects[idx2];
        if (!obj1 || !obj2) return [];

        const segs1 = getAllSegments(obj1);
        const segs2 = getAllSegments(obj2);
        let foundPoints = [];

        for (let s1 of segs1) {
            for (let s2 of segs2) {
                const pt = getSegmentIntersection(s1.p1, s1.p2, s2.p1, s2.p2);
                if (pt) {
                    const roundedX = Math.round(pt.x * 100) / 100;
                    const roundedY = Math.round(pt.y * 100) / 100;
                    
                    const exists = foundPoints.some(fp => 
                        Math.abs(fp.x - roundedX) < 1e-4 && Math.abs(fp.y - roundedY) < 1e-4
                    );

                    if (!exists) {
                        foundPoints.push({ x: roundedX, y: roundedY });
                    }
                }
            }
        }
        return foundPoints;
    }

    // НОВАЯ ФУНКЦИЯ: Закрытие диалога
    function closeIntersectionDialog() {
        const dialog = document.getElementById('intersectionOptionsDialog');
        const overlay = document.getElementById('dialogOverlay');
        dialog.style.display = 'none';
        overlay.classList.remove('show');
        setTimeout(() => { overlay.style.display = 'none'; }, 300);
        
        // Сбрасываем выбор инструмента
        intersectTargetIndex = -1;
        pendingIntersectionData = null;
        redraw(true);
    }

    // НОВАЯ ФУНКЦИЯ: Применение выбора пользователя
    function applyIntersectionChoice(mode) {
        if (!pendingIntersectionData) return;

        const { points, idx1, idx2 } = pendingIntersectionData;
        let msg = "";

        // 1. Просто создать новые точки (как раньше)
        if (mode === 'create_only') {
            createIndependentPoints(points);
            msg = "Созданы новые объекты-точки.";
        }
        
        // 2. Внедрить в оба объекта
        else if (mode === 'modify_both') {
            let count1 = insertPointsIntoObjectGeometry(idx1, points);
            let count2 = insertPointsIntoObjectGeometry(idx2, points);
            msg = `Точки добавлены: в Объект 1 (${count1}), в Объект 2 (${count2}).`;
            // Также обновляем метрики, так как геометрия изменилась
            updateObjectMetrics(userObjects[idx1]);
            updateObjectMetrics(userObjects[idx2]);
        }

        // 3. Внедрить только в первый
        else if (mode === 'modify_first') {
            let count = insertPointsIntoObjectGeometry(idx1, points);
            msg = `Точки добавлены в Объект 1 (${count} шт).`;
            updateObjectMetrics(userObjects[idx1]);
        }

        // 4. Внедрить только во второй
        else if (mode === 'modify_second') {
            let count = insertPointsIntoObjectGeometry(idx2, points);
            msg = `Точки добавлены в Объект 2 (${count} шт).`;
            updateObjectMetrics(userObjects[idx2]);
        }

        showNotification(msg, "success", "check-circle");
        
        // Если меняли геометрию, нужно сохранить историю для Undo (если бы мы были в режиме редактирования конкретного объекта, но тут глобальная операция)
        saveState();
        closeIntersectionDialog();
    }

    // Вспомогательная: Создать независимые точки
    function createIndependentPoints(points) {
        points.forEach(pt => {
            const name = `Точка ${nextObjectId}`;
            addObjectInternal([[{ x: pt.x, y: pt.y }]], name, 'point', true);
        });
        updateObjectList();
    }

    // Вспомогательная: Внедрение массива точек в геометрию объекта
   function insertPointsIntoObjectGeometry(objIndex, points) {
        const obj = userObjects[objIndex];
        if (!obj || !obj.contours) return 0;

        let totalInserted = 0;
        const tolerance = 0.01; // Допуск расстояния (в единицах карты)

        // Проходим по каждому контуру объекта
        for (let cIdx = 0; cIdx < obj.contours.length; cIdx++) {
            const oldContour = obj.contours[cIdx];
            if (!oldContour || oldContour.length < 2) continue;

            const newContour = [];
            const len = oldContour.length;
            // Определяем количество сегментов (для полигона замыкаем, для линии нет)
            const segmentCount = (obj.type === 'polygon') ? len : len - 1;

            for (let i = 0; i < segmentCount; i++) {
                const p1 = oldContour[i];
                const p2 = oldContour[(i + 1) % len]; // Следующая точка (с замыканием)

                // 1. Добавляем начало сегмента в новый контур
                newContour.push({ x: p1.x, y: p1.y });

                // 2. Ищем все точки пересечения, которые лежат на этом сегменте
                const pointsOnSegment = [];

                points.forEach(pt => {
                    // Проверка: лежит ли точка на отрезке p1-p2
                    if (isPointOnSegmentRobust(pt, p1, p2, tolerance)) {
                        // Проверка: не является ли точка дубликатом p1 или p2
                        const distToP1 = (pt.x - p1.x)**2 + (pt.y - p1.y)**2;
                        const distToP2 = (pt.x - p2.x)**2 + (pt.y - p2.y)**2;
                        
                        // Если точка достаточно далеко от краев, считаем её новой
                        if (distToP1 > tolerance && distToP2 > tolerance) {
                             // Проверяем, не добавили ли мы её уже в этот список (защита от дублей)
                            const alreadyAdded = pointsOnSegment.some(existing => 
                                (existing.x - pt.x)**2 + (existing.y - pt.y)**2 < 0.000001
                            );
                            if (!alreadyAdded) {
                                pointsOnSegment.push({ x: pt.x, y: pt.y });
                            }
                        }
                    }
                });

                // 3. Если нашли точки, их нужно отсортировать по удаленности от p1,
                // чтобы вставить в правильном порядке
                if (pointsOnSegment.length > 0) {
                    pointsOnSegment.sort((a, b) => {
                        const distA = (a.x - p1.x)**2 + (a.y - p1.y)**2;
                        const distB = (b.x - p1.x)**2 + (b.y - p1.y)**2;
                        return distA - distB;
                    });

                    // Добавляем отсортированные точки в новый контур
                    pointsOnSegment.forEach(pt => {
                        newContour.push(pt);
                        totalInserted++;
                    });
                }
            }

            // Для линии нужно добавить самую последнюю точку, так как цикл шел до len-1
            if (obj.type !== 'polygon') {
                const lastPt = oldContour[len - 1];
                newContour.push({ x: lastPt.x, y: lastPt.y });
            }

            // Заменяем старый контур на новый, обогащенный точками
            obj.contours[cIdx] = newContour;
        }

        return totalInserted;
    }

    // Вспомогательная: Надежная проверка попадания точки на отрезок
    function isPointOnSegmentRobust(p, a, b, tolerance) {
        // 1. Проверка по Bounding Box (грубая отсечка)
        const minX = Math.min(a.x, b.x) - tolerance;
        const maxX = Math.max(a.x, b.x) + tolerance;
        const minY = Math.min(a.y, b.y) - tolerance;
        const maxY = Math.max(a.y, b.y) + tolerance;

        if (p.x < minX || p.x > maxX || p.y < minY || p.y > maxY) {
            return false;
        }

        // 2. Расстояние от точки до прямой
        const distSq = pointLineDistSq(p.x, p.y, a.x, a.y, b.x, b.y);
        
        // Если расстояние меньше квадрата допуска, считаем, что попали
        return distSq < (tolerance * tolerance);
    }

    // Вспомогательная: лежит ли точка на сегменте (с допуском)
    function isPointOnSegment(p, a, b) {
        const crossProduct = (p.y - a.y) * (b.x - a.x) - (p.x - a.x) * (b.y - a.y);
        if (Math.abs(crossProduct) > 0.01) return false; // Не на одной прямой

        const dotProduct = (p.x - a.x) * (b.x - a.x) + (p.y - a.y) * (b.y - a.y);
        if (dotProduct < 0) return false; // За точкой a

        const squaredLengthBA = (b.x - a.x)*(b.x - a.x) + (b.y - a.y)*(b.y - a.y);
        if (dotProduct > squaredLengthBA) return false; // За точкой b

        return true;
    }

    // Получить плоский список сегментов для объекта
    function getAllSegments(obj) {
        const segments = [];
        if (!obj.contours) return segments;

        obj.contours.forEach(contour => {
            if (!contour || contour.length < 2) return;
            
            // Если полигон, замыкаем (проверяем последний с первым)
            // Если линия - нет.
            const len = contour.length;
            const loop = (obj.type === 'polygon');
            const limit = loop ? len : len - 1;

            for (let i = 0; i < limit; i++) {
                const p1 = contour[i];
                const p2 = contour[(i + 1) % len];
                segments.push({ p1: p1, p2: p2 });
            }
        });
        return segments;
    }
    
    
    //Split
    
function executeCutOperation(targetIdx, cutterIdx) {
        console.log(`[CUT-OP] Начинаем операцию Weiler-Atherton.`);
        const targetObj = userObjects[targetIdx];
        const cutterObj = userObjects[cutterIdx];

        if (!targetObj || !cutterObj) return;

        if (editingObjectIndex !== targetIdx) editingObjectIndex = targetIdx;
        saveGeometryStateForUndo(targetIdx);

        try {
            // 1. Предварительная очистка
            ensureClosed(targetObj.contours);
            ensureClosed(cutterObj.contours);

            // Работаем с копиями
            const subjectPolys = deepCloneContours(targetObj.contours);
            const clipperPolys = deepCloneContours(cutterObj.contours);

            let currentSubjectList = subjectPolys;

            clipperPolys.forEach(clipperRing => {
                if (clipperRing.length < 3) return;
                const nextPassList = [];
                currentSubjectList.forEach(subjectRing => {
                    const diff = computeDifference(subjectRing, clipperRing);
                    if (diff && diff.length > 0) {
                        nextPassList.push(...diff);
                    }
                });
                currentSubjectList = nextPassList;
            });

            // Присваиваем результат
            targetObj.contours = currentSubjectList;

            // 2. ФИНАЛЬНАЯ ЧИСТКА (Удаление дублей и микро-полигонов)
            console.log("[DEBUG-CLEAN] Запуск финальной очистки...");
            cleanObjectContours(targetObj);
            
            if (targetObj.contours.length === 0) {
                showNotification("Объект исчез в результате резки.", "warning");
            } else {
                updateObjectMetrics(targetObj);
                showNotification("Рассечение выполнено.", "success", "cut");
            }
            
            // ЛОГ РЕЗУЛЬТАТА
            targetObj.contours.forEach((c, i) => {
                console.log(`[DEBUG-RESULT] Контур #${i}: ${c.length} точек.`);
            });

            displayObjectInfo(targetIdx);
            redraw(true);

        } catch (e) {
            console.error("CUT ERROR:", e);
            showNotification("Ошибка: " + e.message, "error");
        }
    }

    // --- УЛУЧШЕННАЯ ФУНКЦИЯ ОЧИСТКИ ---

    function cleanObjectContours(obj) {
        if (!obj.contours) return;
        
        const validContours = [];
        
        obj.contours.forEach((contour, cIdx) => {
            if (!contour || contour.length === 0) return;
            
            // Шаг 1: Удаляем соседние дубликаты
            const unique = [];
            unique.push(contour[0]);
            
            for (let i = 1; i < contour.length; i++) {
                const prev = unique[unique.length - 1];
                const curr = contour[i];
                // Дистанция > 1мм
                if ((prev.x - curr.x)**2 + (prev.y - curr.y)**2 > 0.000001) {
                    unique.push(curr);
                }
            }

            // Шаг 2: Проверка на вырожденность (минимум 3 уникальные точки для полигона)
            let checkPoly = [...unique];
            if (checkPoly.length > 1) {
                const f = checkPoly[0];
                const l = checkPoly[checkPoly.length - 1];
                if ((f.x - l.x)**2 + (f.y - l.y)**2 < 0.000001) {
                    checkPoly.pop();
                }
            }

            if (checkPoly.length < 3) {
                console.log(`[DEBUG-CLEAN] Контур #${cIdx} удален: мало точек.`);
                return; 
            }

            // Шаг 3: Проверка ПЛОЩАДИ
            let area = 0;
            for (let i = 0; i < checkPoly.length; i++) {
                const p1 = checkPoly[i];
                const p2 = checkPoly[(i + 1) % checkPoly.length];
                area += (p1.x * p2.y - p2.x * p1.y);
            }
            area = Math.abs(area / 2.0);

            if (area < 0.0001) { 
                console.log(`[DEBUG-CLEAN] Контур #${cIdx} удален: микро-площадь.`);
                return; 
            }

            // Замыкаем корректно
            const first = unique[0];
            const last = unique[unique.length - 1];
            if ((first.x - last.x)**2 + (first.y - last.y)**2 > 0.000001) {
                unique.push({ x: first.x, y: first.y });
            }
            
            validContours.push(unique);
        });

        obj.contours = validContours;
    }

    function ensureClosed(contours) {
        contours.forEach(c => {
            if (c.length > 2) {
                const first = c[0];
                const last = c[c.length - 1];
                if ((first.x - last.x)**2 + (first.y - last.y)**2 > 0.000001) {
                    c.push({ x: first.x, y: first.y });
                }
            }
        });
    }

    function deepCloneContours(contours) {
        if (!contours) return [];
        return contours.map(contour => {
            if (!contour) return null;
            return contour.map(p => (p ? { ...p } : null));
        });
    }

    // --- АЛГОРИТМ РАЗНОСТИ ---

    function computeDifference(subject, clipper) {
        const intersections = findIntersectionsRobust(subject, clipper);
        
        if (intersections.length === 0) {
            // Используем восстановленное имя isPointInPolygonRobust
            if (isPointInPolygonRobust(subject[0], clipper)) return [];
            return [subject];
        }

        const subjWithInt = insertPointsAndMark(subject, intersections, true);
        const clipWithInt = insertPointsAndMark(clipper, intersections, false);

        const subjArcs = splitByIntersections(subjWithInt);
        const clipArcs = splitByIntersections(clipWithInt);

        const finalArcs = [];

        // Дуги цели (снаружи резака)
        subjArcs.forEach(arc => {
            const mid = getArcMidpoint(arc);
            if (!isPointInPolygonRobust(mid, clipper, false)) { 
                finalArcs.push(arc);
            }
        });

        // Дуги резака (внутри цели) - РАЗВОРОТ
        clipArcs.forEach(arc => {
            const mid = getArcMidpoint(arc);
            if (isPointInPolygonRobust(mid, subject, true)) {
                finalArcs.push(arc.reverse());
            }
        });

        return stitchArcs(finalArcs);
    }

    function findIntersectionsRobust(poly1, poly2) {
        const intersects = [];
        for (let i = 0; i < poly1.length - 1; i++) {
            for (let j = 0; j < poly2.length - 1; j++) {
                const p1 = poly1[i]; const p2 = poly1[i + 1];
                const q1 = poly2[j]; const q2 = poly2[j + 1];
                
                // Используем восстановленное имя getSegmentIntersection
                const pt = getSegmentIntersection(p1, p2, q1, q2);
                if (pt) {
                    intersects.push({
                        p: pt,
                        sIdx: i,
                        cIdx: j
                    });
                }
            }
        }
        return intersects;
    }

    // --- ВОССТАНОВЛЕНО ИМЯ getSegmentIntersection ---
    function getSegmentIntersection(p1, p2, q1, q2) {
        const d1x = p2.x - p1.x; const d1y = p2.y - p1.y;
        const d2x = q2.x - q1.x; const d2y = q2.y - q1.y;
        const det = d1x * d2y - d1y * d2x;
        if (Math.abs(det) < 1e-9) return null;

        const rX = q1.x - p1.x; const rY = q1.y - p1.y;
        const t = (rX * d2y - rY * d2x) / det;
        const u = (rX * d1y - rY * d1x) / det;

        const EPS = 1e-5;
        if (t >= -EPS && t <= 1 + EPS && u >= -EPS && u <= 1 + EPS) {
            return { x: p1.x + t * d1x, y: p1.y + t * d1y };
        }
        return null;
    }

    function insertPointsAndMark(poly, intersections, isSubject) {
        const result = [];
        for (let i = 0; i < poly.length - 1; i++) {
            const p1 = poly[i];
            result.push({ x: p1.x, y: p1.y, isIntersection: false });

            const hits = intersections.filter(it => (isSubject ? it.sIdx : it.cIdx) === i);
            hits.sort((a,b) => ((a.p.x - p1.x)**2 + (a.p.y - p1.y)**2) - ((b.p.x - p1.x)**2 + (b.p.y - p1.y)**2));

            hits.forEach(hit => {
                const last = result[result.length - 1];
                if ((hit.p.x - last.x)**2 + (hit.p.y - last.y)**2 > 0.000001) {
                    result.push({ x: hit.p.x, y: hit.p.y, isIntersection: true });
                }
            });
        }
        const first = poly[0];
        result.push({ x: first.x, y: first.y, isIntersection: false });
        return result;
    }

    function splitByIntersections(pointsWithFlags) {
        const arcs = [];
        let startIndex = pointsWithFlags.findIndex(p => p.isIntersection);
        
        if (startIndex === -1) return [pointsWithFlags.map(p => ({x:p.x, y:p.y}))];

        const uniquePoints = pointsWithFlags.slice(0, pointsWithFlags.length - 1);
        const rotated = [
            ...uniquePoints.slice(startIndex),
            ...uniquePoints.slice(0, startIndex),
            uniquePoints[startIndex]
        ];
        
        let currentArc = [{x: rotated[0].x, y: rotated[0].y}];
        
        for (let i = 1; i < rotated.length; i++) {
            const p = rotated[i];
            currentArc.push({x: p.x, y: p.y});
            
            if (p.isIntersection && i < rotated.length) {
                arcs.push(currentArc);
                currentArc = [{x: p.x, y: p.y}];
            }
        }
        return arcs;
    }

    function getArcMidpoint(arc) {
        const midIdx = Math.floor(arc.length / 2);
        if (arc.length === 2) {
             return { x: (arc[0].x + arc[1].x)/2, y: (arc[0].y + arc[1].y)/2 };
        }
        const p1 = arc[midIdx-1] || arc[0];
        const p2 = arc[midIdx];
        return { x: (p1.x + p2.x)/2, y: (p1.y + p2.y)/2 };
    }

    function stitchArcs(arcs) {
        if (arcs.length === 0) return [];
        
        const polygons = [];
        const used = new Array(arcs.length).fill(false);
        const tolerance = 0.0001; 

        while(true) {
            const startIdx = used.findIndex(u => !u);
            if (startIdx === -1) break;

            const poly = [];
            let currIdx = startIdx;
            let watchdog = 0;
            
            while (currIdx !== -1 && !used[currIdx] && watchdog < arcs.length * 2) {
                used[currIdx] = true;
                const arc = arcs[currIdx];
                watchdog++;
                
                poly.push(...arc.slice(0, arc.length - 1));
                
                const tail = arc[arc.length - 1];
                
                let nextIdx = -1;
                for (let i = 0; i < arcs.length; i++) {
                    if (!used[i]) {
                        const head = arcs[i][0];
                        if ((head.x - tail.x)**2 + (head.y - tail.y)**2 < tolerance) {
                            nextIdx = i;
                            break;
                        }
                    }
                }
                
                if (nextIdx !== -1) {
                    currIdx = nextIdx;
                } else {
                    poly.push(tail);
                    const first = poly[0];
                    if ((first.x - tail.x)**2 + (first.y - tail.y)**2 > tolerance) {
                        poly.push({x: first.x, y: first.y});
                    }
                    currIdx = -1;
                }
            }
            if (poly.length >= 3) polygons.push(poly);
        }
        return polygons;
    }

    // --- ВОССТАНОВЛЕНО ИМЯ isPointInPolygonRobust ---
    function isPointInPolygonRobust(pt, poly, boundaryResult = false) {
        let inside = false;
        const rx = pt.x; const ry = pt.y;
        
        for (let i = 0, j = poly.length - 1; i < poly.length; j = i++) {
            const xi = poly[i].x; const yi = poly[i].y;
            const xj = poly[j].x; const yj = poly[j].y;

            // Проверка на попадание точно в ребро
            const dist = pointLineDistSq(rx, ry, xi, yi, xj, yj);
            if (dist < 1e-10) return boundaryResult;
            
            const intersect = ((yi > ry) !== (yj > ry)) &&
                (rx < (xj - xi) * (ry - yi) / (yj - yi) + xi);
            if (intersect) inside = !inside;
        }
        return inside;
    }

    function pointLineDistSq(px, py, x1, y1, x2, y2) {
        const A = px - x1; const B = py - y1;
        const C = x2 - x1; const D = y2 - y1;
        const dot = A * C + B * D;
        const lenSq = C * C + D * D;
        let param = -1;
        if (lenSq !== 0) param = dot / lenSq;
        let xx, yy;
        if (param < 0) { xx = x1; yy = y1; }
        else if (param > 1) { xx = x2; yy = y2; }
        else { xx = x1 + param * C; yy = y1 + param * D; }
        const dx = px - xx; const dy = py - yy;
        return dx * dx + dy * dy;
    }
    


    document.addEventListener('DOMContentLoaded', initializeApp);

</script>
</body>
</html>