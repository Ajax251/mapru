<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Наложение на PDF v2</title>
<link rel="icon" href="img/foto2.png" type="image/png">
    <link rel="stylesheet" href="webfonts/all.min.css">
    <style>
      body, html {
    margin: 0;
    padding: 0;
    height: 100%;
    font-family: 'Arial', sans-serif;
    background-color: #f4f7fa;
    color: #333;
}

.container {
    background: #f5f7fa;
    min-height: 100vh;
    display: flex;
    transition: all 0.3s ease;
}

/* Sidebar стилизация */
.sidebar {
    width: 80px;
    background: linear-gradient(135deg, #1a237e, #0d47a1);
    padding: 20px 10px;
    box-sizing: border-box;
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 20px;
    transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    box-shadow: 4px 0 15px rgba(0, 0, 0, 0.2);
    position: relative;
    overflow: hidden;
}

.sidebar::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: linear-gradient(45deg, 
        rgba(255, 255, 255, 0.1) 0%, 
        rgba(255, 255, 255, 0) 100%);
    pointer-events: none;
}

.sidebar button {
    width: 50px;
    height: 50px;
    background: rgba(255, 255, 255, 0.1);
    border: 2px solid rgba(255, 255, 255, 0.2);
    border-radius: 15px;
    cursor: pointer;
    color: white;
    font-size: 20px;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    position: relative;
    overflow: hidden;
}

.sidebar button:hover {
    background: rgba(255, 255, 255, 0.2);
    transform: translateY(-2px);
    box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
}

.sidebar button:active {
    transform: translateY(1px);
    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
}

.sidebar button i {
    transition: all 0.3s ease;
}

.sidebar button:hover i {
    transform: scale(1.1);
}

/* Viewer container */
.viewer {
    flex: 1;
    padding: 20px;
    display: flex;
    flex-direction: column;
    align-items: center;
    height: 100vh;
    box-sizing: border-box;
    position: relative;
}

/* PDF Viewer */
.pdf-viewer {
    flex: 1;
    width: 95%;
    background: white;
    border-radius: 20px;
    box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
    transition: all 0.3s ease;
    margin-bottom: 20px;
    position: relative;
    min-height: calc(100vh - 140px);
    overflow: auto;
    padding: 20px;
    display: flex;
    justify-content: center;
    align-items: flex-start; /* Изменено с center на flex-start */
}

.pdf-viewer:hover {
    box-shadow: 0 15px 40px rgba(0, 0, 0, 0.15);
}

/* Стиль для контейнера PDF страницы */
.pdf-canvas-container {
    border: 2px solid #e0e0e0; /* Добавлена более заметная граница */
    box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
    transition: all 0.3s ease-in-out;
    margin: 20px;
    position: relative;
    background: white; /* Добавлен белый фон */
    display: inline-block; /* Добавлено для правильного отображения размеров */
    min-height: 100%; /* Добавлено для обеспечения полной высоты */
}

.pdf-canvas-container canvas {
    display: block; /* Убирает лишние отступы */
    max-width: 100%;
    height: auto;
}
/* Навигация по страницам */
.page-navigation {
    background: linear-gradient(135deg, #1a237e, #0d47a1);
    padding: 12px 25px;
    border-radius: 20px;
    display: flex;
    align-items: center;
    gap: 15px;
    box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
    position: fixed;
    bottom: 20px;
    left: 50%;
    transform: translateX(-50%);
    z-index: 1000;
    transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
}

.page-navigation button {
    width: 40px;
    height: 40px;
    background: rgba(255, 255, 255, 0.1);
    border: 2px solid rgba(255, 255, 255, 0.2);
    border-radius: 12px;
    cursor: pointer;
    color: white;
    font-size: 16px;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
}

.page-navigation button:hover {
    background: rgba(255, 255, 255, 0.2);
    transform: translateY(-2px);
    box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
}

.page-navigation button:active {
    transform: translateY(1px);
    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
}

.page-navigation .page-info {
    color: white;
    font-size: 16px;
    font-weight: 500;
    padding: 8px 15px;
    background: rgba(255, 255, 255, 0.1);
    border-radius: 10px;
    min-width: 60px;
    text-align: center;
    transition: all 0.3s ease;
}

/* Контекстное меню */
.context-menu {
    position: absolute;
    background-color: white;
    border: none;
    border-radius: 12px;
    box-shadow: 0 5px 20px rgba(0, 0, 0, 0.15);
    padding: 8px 0;
    z-index: 1000;
    transition: all 0.2s ease-in-out;
    min-width: 180px;
}

.context-menu ul {
    list-style: none;
    padding: 0;
    margin: 0;
}

.context-menu li {
    padding: 10px 20px;
    cursor: pointer;
    color: #333;
    font-size: 14px;
    transition: all 0.2s ease-in-out;
    display: flex;
    align-items: center;
}

.context-menu li:hover {
    background-color: rgba(26, 35, 126, 0.1);
    color: #1a237e;
}

/* Диалоговое окно */
.dialog-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.5);
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 1000;
    backdrop-filter: blur(5px);
}

.dialog {
    background: white;
    padding: 25px;
    border-radius: 20px;
    box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
    width: 90%;
    max-width: 400px;
    text-align: center;
}

.dialog input {
    width: 100%;
    padding: 12px;
    margin: 15px 0;
    border: 2px solid #e0e0e0;
    border-radius: 10px;
    font-size: 16px;
    transition: all 0.3s ease;
    box-sizing: border-box;
}

.dialog input:focus {
    border-color: #1a237e;
    outline: none;
    box-shadow: 0 0 0 3px rgba(26, 35, 126, 0.1);
}

.dialog button {
    padding: 12px 25px;
    border: none;
    border-radius: 10px;
    cursor: pointer;
    font-size: 16px;
    font-weight: 500;
    margin: 0 10px;
    transition: all 0.3s ease;
}

.dialog button.primary {
    background: #1a237e;
    color: white;
}

.dialog button.secondary {
    background: #e0e0e0;
    color: #333;
}

.dialog button:hover {
    transform: translateY(-2px);
    box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
}

.dialog button:active {
    transform: translateY(1px);
}

/* Draggable image */
.draggable-image {
    position: absolute;
    cursor: grab;
    border: 2px dashed #1a237e;
    resize: both;
    overflow: auto;
    transition: all 0.2s ease-in-out;
    border-radius: 4px;
    top: 100px; /* Начальная позиция сверху */
    left: 50%; /* Центрирование по горизонтали */
    transform: translateX(-50%); /* Компенсация для точного центрирования */
    z-index: 1000;
}

.draggable-image:active {
    cursor: grabbing;
}

.signature-dialog {
    width: 850px;
    max-width: 90vw;
    padding: 25px;
}

#signatureCanvas {
    cursor: crosshair;
    border-radius: 8px;
    box-shadow: 0 2px 10px rgba(0,0,0,0.1);
    margin-bottom: 15px;
    max-width: 100%;
}

.signature-controls {
    display: flex;
    justify-content: space-between;
    margin-bottom: 20px;
    flex-wrap: wrap;
}

.color-picker {
    display: flex;
    align-items: center;
    flex-wrap: wrap;
    gap: 10px;
}

.preset-colors {
    display: flex;
    gap: 8px;
}

.color-preset {
    width: 25px;
    height: 25px;
    border-radius: 50%;
    cursor: pointer;
    border: 2px solid #e0e0e0;
    transition: all 0.2s ease;
}

.color-preset:hover, .color-preset.active {
    transform: scale(1.1);
    border-color: #1a237e;
}

.line-width {
    display: flex;
    align-items: center;
    gap: 10px;
}

.signature-buttons {
    display: flex;
    justify-content: center;
    gap: 15px;
}

/* Общие стили для кнопок */
.dialog button {
    padding: 12px 25px;
    border: none;
    border-radius: 10px;
    cursor: pointer;
    font-size: 16px;
    font-weight: 500;
    margin: 0 10px;
    transition: all 0.3s ease;
}

/* Сохранить (синий) */
.dialog button.save-btn {
    background: #4166F5;
    color: white;
}

.dialog button.save-btn:hover {
    background: #4166F5;
    transform: translateY(-2px);
    box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
}

/* Сохранить в файл (зеленый) */
.dialog button.save-file-btn {
    background: #28A745;
    color: white;
}

.dialog button.save-file-btn:hover {
    background: #218838;
    transform: translateY(-2px);
    box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
}

/* Очистить (серый) */
.dialog button.clear-btn {
    background: #7F00FF;
    color: white;
}

.dialog button.clear-btn:hover {
    background: #7F00FF;
    transform: translateY(-2px);
    box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
}

/* Отмена (красный) */
.dialog button.cancel-btn {
    background: #FF2C2C;
    color: white;
}

.dialog button.cancel-btn:hover {
    background: #FF2C2C;
    transform: translateY(-2px);
    box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
}

/* Активное состояние для всех кнопок */
.dialog button:active {
    transform: translateY(1px);
}


    </style>

</head>
<body>
    <div class="container">
        <div class="sidebar">
           <button id="openButton" title="Открыть"><i class="fas fa-folder-open"></i></button>
           <button id="insertButton" title="Вставить"><i class="fas fa-image"></i></button>
            <button id="saveButton" title="Сохранить"><i class="fas fa-save"></i></button>
            <button id="signatureButton" title="Подпись"><i class="fas fa-signature"></i></button>
        </div>
        <div class="viewer">
            <div class="pdf-viewer" id="pdfViewer">
                <div class="pdf-canvas-container" id="pdfCanvasContainer"></div>  <!-- Canvas Container moved here -->
            </div>
             <div class="page-navigation">
              <button id="prevPage" title="Предыдущая страница"><i class="fas fa-chevron-left"></i></button>
                 <span class="page-info">1/1</span>
              <button id="nextPage" title="Следующая страница"><i class="fas fa-chevron-right"></i></button>
             </div>
        </div>
    </div>
    
<div id="signatureDialog" class="dialog-overlay" style="display: none;">
    <div class="dialog signature-dialog">
        <h2>Нарисуйте свою подпись</h2>
        <canvas id="signatureCanvas" width="800" height="300" style="border: 1px solid #e0e0e0; background: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAMUlEQVQ4T2NkYGAQYcAP3uCTZhw1gGGYhAGBZIA/nYDCgBDAm9BGDWAAJyRCgLaBCAAgXwixzAS0pgAAAABJRU5ErkJggg==') repeat;"></canvas>
        <div class="signature-controls">
            <div class="color-picker">
                <label for="signatureColor">Цвет подписи:</label>
                <input type="color" id="signatureColor" value="#0047AB">
                <div class="preset-colors">
                    <div class="color-preset" data-color="#0047AB" style="background-color: #0047AB;"></div>
                    <div class="color-preset" data-color="#000000" style="background-color: #000000;"></div>
                    <div class="color-preset" data-color="#1a237e" style="background-color: #1a237e;"></div>
                    <div class="color-preset" data-color="#006400" style="background-color: #006400;"></div>
                    <div class="color-preset" data-color="#8B0000" style="background-color: #8B0000;"></div>
                </div>
            </div>
            <div class="line-width">
                <label for="signatureWidth">Толщина линии:</label>
                <input type="range" id="signatureWidth" min="1" max="10" value="4">
            </div>
        </div>
        <div class="signature-buttons">
            <button class="primary save-btn" id="saveSignature">Сохранить</button>
            <button class="primary save-file-btn" id="saveToFile">Сохранить в файл</button>
            <button class="secondary clear-btn" id="clearSignature">Очистить</button>
            <button class="secondary cancel-btn" id="cancelSignature">Отмена</button>
        </div>
    </div>
</div>

    <div id="imageContextMenu" class="context-menu">
        <ul>
            <li data-action="copy">Копировать</li>
           <li data-action="delete">Удалить</li>
           <li data-action="apply-to-pages">Применить к страницам</li>
        </ul>
    </div>
    
    

    <script src="webfonts/pdf.min.js"></script>
     <script src="webfonts/jszip.min.js"></script>
    <script src="webfonts/interact.min.js"></script>
    <script>
        let pdfDoc = null;
        let pageNum = 1;
        let pageRendering = false;
        let pageNumPending = null;
        const scale = 1.5; // Масштаб просмотра - keep for display
        let currentImage = null;
        let canvasWidth = 0; // Variables to store canvas dimensions
        let canvasHeight = 0;

        const pdfViewer = document.getElementById('pdfViewer');
        const openButton = document.getElementById('openButton');
        const insertButton = document.getElementById('insertButton');
        const saveButton = document.getElementById('saveButton');
        const prevPageButton = document.getElementById('prevPage');
        const nextPageButton = document.getElementById('nextPage');
        const contextMenu = document.getElementById('imageContextMenu');
        const pageInfo = document.querySelector('.page-info');
        const pdfCanvasContainer = document.getElementById('pdfCanvasContainer'); // Get Canvas Container here


        const pageImages = {};
        const imagePositions = {}; // Store image positions here
        
// Обновите JavaScript код для работы с цветом
const signatureButton = document.getElementById('signatureButton');
const signatureDialog = document.getElementById('signatureDialog');
const signatureCanvas = document.getElementById('signatureCanvas');
const signatureColorInput = document.getElementById('signatureColor');
const signatureWidthInput = document.getElementById('signatureWidth');
const saveSignatureButton = document.getElementById('saveSignature');
const clearSignatureButton = document.getElementById('clearSignature');
const cancelSignatureButton = document.getElementById('cancelSignature');
const colorPresets = document.querySelectorAll('.color-preset');
let signatureCtx = signatureCanvas.getContext('2d');
let isDrawing = false;
let lastX = 0;
let lastY = 0;

// Инициализация canvas для подписи
function setupSignatureCanvas() {
    signatureCtx.strokeStyle = signatureColorInput.value;
    signatureCtx.lineWidth = signatureWidthInput.value; // Используется значение 4 по умолчанию
    signatureCtx.lineCap = 'round';
    signatureCtx.lineJoin = 'round';
    signatureCtx.globalAlpha = 1.0; // Устанавливаем полную непрозрачность для яркости
    
    clearSignatureCanvas();
    drawSignatureGuide();
    
    colorPresets.forEach(preset => {
        if (preset.dataset.color === signatureColorInput.value) {
            preset.classList.add('active');
        } else {
            preset.classList.remove('active');
        }
    });
}

// Новая функция для сохранения подписи в PNG
function saveSignatureToFile() {
    // Проверяем, есть ли подпись
    const imageData = signatureCtx.getImageData(0, 0, signatureCanvas.width, signatureCanvas.height);
    const data = imageData.data;
    let hasSignature = false;
    for (let i = 0; i < data.length; i += 4) {
        if (data[i + 3] > 0) {
            hasSignature = true;
            break;
        }
    }
    
    if (!hasSignature) {
        alert('Пожалуйста, нарисуйте подпись перед сохранением');
        return;
    }

    // Создаем временный canvas для чистой подписи
    const tempCanvas = document.createElement('canvas');
    tempCanvas.width = signatureCanvas.width;
    tempCanvas.height = signatureCanvas.height;
    const tempCtx = tempCanvas.getContext('2d');
    
    // Устанавливаем прозрачный фон
    tempCtx.clearRect(0, 0, tempCanvas.width, tempCanvas.height);
    
    // Копируем только подпись
    tempCtx.drawImage(signatureCanvas, 0, 0);
    
    // Сохраняем как PNG
    const dataURL = tempCanvas.toDataURL('image/png');
    const link = document.createElement('a');
    link.href = dataURL;
    link.download = `signature_${new Date().toISOString().slice(0,10)}.png`;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
}

// Добавляем обработчик для новой кнопки
document.getElementById('saveToFile').addEventListener('click', () => {
    saveSignatureToFile();
    console.log('Подпись сохранена в файл PNG');
});


function drawSignatureGuide() {
    // Сохраняем текущие настройки контекста
    signatureCtx.save();
    
    // Устанавливаем стиль для направляющей линии
    signatureCtx.strokeStyle = '#e0e0e0';
    signatureCtx.lineWidth = 1;
    signatureCtx.setLineDash([5, 5]); // Пунктирная линия
    
    // Рисуем горизонтальную направляющую
    signatureCtx.beginPath();
    signatureCtx.moveTo(0, signatureCanvas.height / 2);
    signatureCtx.lineTo(signatureCanvas.width, signatureCanvas.height / 2);
    signatureCtx.stroke();
    
    // Восстанавливаем настройки контекста
    signatureCtx.restore();
}


// Очистить canvas подписи
function clearSignatureCanvas() {
    // Очищаем canvas полностью (делаем его прозрачным)
    signatureCtx.clearRect(0, 0, signatureCanvas.width, signatureCanvas.height);
    signatureCtx.beginPath();
}


// Начало рисования
function startDrawing(e) {
    isDrawing = true;
    const rect = signatureCanvas.getBoundingClientRect();
    lastX = e.clientX - rect.left;
    lastY = e.clientY - rect.top;
}

// Процесс рисования
function draw(e) {
    if (!isDrawing) return;
    
    const rect = signatureCanvas.getBoundingClientRect();
    const currentX = e.clientX - rect.left;
    const currentY = e.clientY - rect.top;
    
    signatureCtx.beginPath();
    signatureCtx.moveTo(lastX, lastY);
    signatureCtx.lineTo(currentX, currentY);
    signatureCtx.stroke();
    
    lastX = currentX;
    lastY = currentY;
}

// Конец рисования
function stopDrawing() {
    isDrawing = false;
}

// Обработка сенсорных событий
function handleTouchStart(e) {
    e.preventDefault();
    const touch = e.touches[0];
    const mouseEvent = new MouseEvent('mousedown', {
        clientX: touch.clientX,
        clientY: touch.clientY
    });
    signatureCanvas.dispatchEvent(mouseEvent);
}

function handleTouchMove(e) {
    e.preventDefault();
    const touch = e.touches[0];
    const mouseEvent = new MouseEvent('mousemove', {
        clientX: touch.clientX,
        clientY: touch.clientY
    });
    signatureCanvas.dispatchEvent(mouseEvent);
}

function handleTouchEnd(e) {
    e.preventDefault();
    const mouseEvent = new MouseEvent('mouseup', {});
    signatureCanvas.dispatchEvent(mouseEvent);
}


signatureColorInput.addEventListener('input', function() {
    signatureCtx.strokeStyle = this.value;
    // Обновляем активный пресет
    colorPresets.forEach(preset => {
        preset.classList.remove('active');
        if (preset.dataset.color === this.value) {
            preset.classList.add('active');
        }
    });
});

signatureWidthInput.addEventListener('input', function() {
    signatureCtx.lineWidth = this.value;
});

// Обработчики для цветовых пресетов
colorPresets.forEach(preset => {
    preset.addEventListener('click', function() {
        const color = this.dataset.color;
        signatureColorInput.value = color;
        signatureCtx.strokeStyle = color;
        
        // Обновляем активный класс
        colorPresets.forEach(p => p.classList.remove('active'));
        this.classList.add('active');
    });
});

// Добавляем обработчики событий для рисования
signatureCanvas.addEventListener('mousedown', startDrawing);
signatureCanvas.addEventListener('mousemove', draw);
signatureCanvas.addEventListener('mouseup', stopDrawing);
signatureCanvas.addEventListener('mouseout', stopDrawing);

// Добавляем обработчики для сенсорных устройств
signatureCanvas.addEventListener('touchstart', handleTouchStart);
signatureCanvas.addEventListener('touchmove', handleTouchMove);
signatureCanvas.addEventListener('touchend', handleTouchEnd);

// Показать диалог подписи
signatureButton.addEventListener('click', () => {
    signatureDialog.style.display = 'flex';
    setupSignatureCanvas();
});

// Очистить подпись
clearSignatureButton.addEventListener('click', clearSignatureCanvas);

// Отмена действия
cancelSignatureButton.addEventListener('click', () => {
    signatureDialog.style.display = 'none';
});

saveSignatureButton.addEventListener('click', () => {
    const imageData = signatureCtx.getImageData(0, 0, signatureCanvas.width, signatureCanvas.height);
    const data = imageData.data;
    let hasSignature = false;
    
    for (let i = 0; i < data.length; i += 4) {
        if (data[i + 3] > 0) {
            hasSignature = true;
            break;
        }
    }
    
    if (!hasSignature) {
        alert('Пожалуйста, нарисуйте подпись перед сохранением');
        return;
    }
    
    const tempCanvas = document.createElement('canvas');
    tempCanvas.width = signatureCanvas.width;
    tempCanvas.height = signatureCanvas.height;
    const tempCtx = tempCanvas.getContext('2d');
    
    // Устанавливаем полную непрозрачность и копируем подпись
    tempCtx.globalAlpha = 1.0;
    tempCtx.drawImage(signatureCanvas, 0, 0);
    
    const signatureURL = tempCanvas.toDataURL('image/png');
    const img = new Image();
    img.src = signatureURL;
    img.classList.add('draggable-image');
    img.style.width = '250px';
    img.style.border = 'none';
    img.setAttribute('data-type', 'signature');
    
    img.onload = () => {
        if (!pageImages[pageNum]) {
            pageImages[pageNum] = [];
        }
        const imgId = Date.now() + Math.random();
        img.setAttribute('data-image-id', imgId);
        
        const pdfCanvas = document.querySelector('.pdf-canvas-container');
        if (pdfCanvas) {
            const canvasRect = pdfCanvas.getBoundingClientRect();
            const x = canvasRect.left + (canvasRect.width / 2);
            const y = canvasRect.top + (canvasRect.height * 0.7);
            
            img.style.transform = `translate(${x - canvasRect.left}px, ${y - canvasRect.top}px)`;
            img.setAttribute('data-x', x - canvasRect.left);
            img.setAttribute('data-y', y - canvasRect.top);
            
            if (!imagePositions[pageNum]) {
                imagePositions[pageNum] = {};
            }
            imagePositions[pageNum][imgId] = {
                x: x - canvasRect.left,
                y: y - canvasRect.top,
                width: img.getBoundingClientRect().width,
                height: img.getBoundingClientRect().height
            };
        }
        
        pageImages[pageNum].push(img);
        pdfViewer.appendChild(img);
        makeDraggableAndResizable(img, imgId);
        setupImageContextMenu(img);
        signatureDialog.style.display = 'none';
        console.log(`Подпись добавлена на страницу ${pageNum}. Позиция: `, 
            imagePositions[pageNum][imgId]);
    };
});


         function loadPdf(url) {
            console.log("Загрузка PDF...");
            pdfjsLib.getDocument(url).promise.then(pdfDoc_ => {
                pdfDoc = pdfDoc_;
                pageImages[pageNum] = [];
                updatePageInfo();
                renderPage(pageNum);
                 console.log("PDF загружен успешно.");
            }).catch(error => {
                console.error("Ошибка при загрузке PDF:", error);
            });
        }

        function renderPage(num) {
             console.log(`Рендеринг страницы ${num}...`);
            pageRendering = true;
            // Clear existing content
            pdfViewer.querySelectorAll('.draggable-image').forEach(img => img.remove());


            pdfDoc.getPage(num).then(page => {
                const viewport = page.getViewport({ scale });
                const canvas = document.createElement('canvas');
                const context = canvas.getContext('2d');
                canvas.height = viewport.height;
                canvas.width = viewport.width;

                pdfCanvasContainer.innerHTML = '';
                pdfCanvasContainer.appendChild(canvas);

                const renderContext = {
                    canvasContext: context,
                    viewport: viewport
                };
                page.render(renderContext).promise.then(() => {
                    pageRendering = false;
                    if (pageNumPending !== null) {
                        renderPage(pageNumPending);
                        pageNumPending = null;
                    }

                    // Store canvas dimensions after rendering
                    const canvasRect = canvas.getBoundingClientRect();
                    canvasWidth = canvasRect.width;
                    canvasHeight = canvasRect.height;
                    console.log(`Сохраненные размеры canvas после рендеринга: width=${canvasWidth}px, height=${canvasHeight}px`);

                      if (pageImages[num]) {
                        pageImages[num].forEach(img => {
                             pdfViewer.appendChild(img);
                             setupImageContextMenu(img);
                        });
                    }
                    console.log(`Страница ${num} отрендерена.`);
                });
            }).catch(error => {
                console.error(`Ошибка при рендеринге страницы ${num}:`, error);
            });
        }
        function updatePageInfo() {
            if (pdfDoc) {
                pageInfo.textContent = `${pageNum}/${pdfDoc.numPages}`;
            } else {
                pageInfo.textContent = '0/0';
            }
             console.log(`Обновлена информация о странице: ${pageInfo.textContent}`);
        }

        openButton.addEventListener('click', () => {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = 'application/pdf';
            input.onchange = e => {
                const file = e.target.files[0];
                if (file) {
                    const fileURL = URL.createObjectURL(file);
                    loadPdf(fileURL);
                }
            };
            input.click();
        });

    insertButton.addEventListener('click', () => {
    const input = document.createElement('input');
    input.type = 'file';
    input.accept = 'image/*';
    input.onchange = e => {
        const file = e.target.files[0];
        if (file) {
            const img = new Image();
            img.src = URL.createObjectURL(file);
            img.classList.add('draggable-image');
            img.style.width = '5cm';
            img.onload = () => {
                if (!pageImages[pageNum]) {
                    pageImages[pageNum] = [];
                }
                const imgId = Date.now() + Math.random();
                img.setAttribute('data-image-id', imgId);
                
                // Устанавливаем начальную позицию изображения
                const pdfViewer = document.querySelector('.pdf-viewer');
                const pdfCanvas = document.querySelector('.pdf-canvas-container');
                if (pdfCanvas) {
                    const canvasRect = pdfCanvas.getBoundingClientRect();
                    img.style.top = `${canvasRect.top + 100}px`;
                    img.style.left = `${canvasRect.left + (canvasRect.width / 2)}px`;
                }
                
                pageImages[pageNum].push(img);
                pdfViewer.appendChild(img);
                makeDraggableAndResizable(img, imgId);
                setupImageContextMenu(img);
                console.log(`Изображение добавлено на страницу ${pageNum}.`);
            };
        }
    };
    input.click();
});


    function makeDraggableAndResizable(element, imgId) {
    interact(element)
        .draggable({
            inertia: true,
            modifiers: [
                interact.modifiers.restrictRect({
                    restriction: 'parent',
                    endOnly: true
                })
            ],
            autoScroll: true,
            listeners: {
                move(event) {
                    const target = event.target;
                    const x = (parseFloat(target.getAttribute('data-x')) || 0) + event.dx;
                    const y = (parseFloat(target.getAttribute('data-y')) || 0) + event.dy;
                    target.style.transform = `translate(${x}px, ${y}px)`;
                    target.setAttribute('data-x', x);
                    target.setAttribute('data-y', y);
                    updateImagePosition(target, imgId);
                }
            }
        })
        .resizable({
            edges: { left: true, right: true, bottom: true, top: true },
            listeners: {
                move: function(event) {
                    const target = event.target;
                    let x = (parseFloat(target.getAttribute('data-x')) || 0);
                    let y = (parseFloat(target.getAttribute('data-y')) || 0);
                    
                    // Get the element type
                    const isSignature = target.getAttribute('data-type') === 'signature';
                    
                    // For signatures, maintain aspect ratio
                    if (isSignature) {
                        const aspectRatio = target.naturalWidth / target.naturalHeight;
                        
                        // If resizing width, adjust height accordingly
                        if (event.edges.left || event.edges.right) {
                            event.rect.height = event.rect.width / aspectRatio;
                        }
                        // If resizing height, adjust width accordingly
                        else if (event.edges.top || event.edges.bottom) {
                            event.rect.width = event.rect.height * aspectRatio;
                        }
                    }
                    
                    // Update element dimensions
                    target.style.width = `${event.rect.width}px`;
                    target.style.height = `${event.rect.height}px`;
                    
                    // Update position if edges are being dragged
                    x += event.deltaRect.left;
                    y += event.deltaRect.top;
                    
                    target.style.transform = `translate(${x}px, ${y}px)`;
                    target.setAttribute('data-x', x);
                    target.setAttribute('data-y', y);
                    
                    // Add resize handles to make it more obvious that the signature can be resized
                    if (isSignature && !target.classList.contains('with-handles')) {
                        addResizeHandles(target);
                        target.classList.add('with-handles');
                    }
                    
                    updateImagePosition(target, imgId);
                }
            }
        });
}


function addResizeHandles(element) {
    // Only add handles if they don't already exist
    if (element.querySelector('.resize-handle')) return;
    
    const corners = ['top-left', 'top-right', 'bottom-left', 'bottom-right'];
    
    corners.forEach(corner => {
        const handle = document.createElement('div');
        handle.classList.add('resize-handle', corner);
        handle.style.position = 'absolute';
        handle.style.width = '12px';
        handle.style.height = '12px';
        handle.style.background = 'rgba(0, 71, 171, 0.7)';
        handle.style.borderRadius = '50%';
        handle.style.zIndex = '1000';
        
        // Position the handle
        if (corner.includes('top')) handle.style.top = '-6px';
        if (corner.includes('bottom')) handle.style.bottom = '-6px';
        if (corner.includes('left')) handle.style.left = '-6px';
        if (corner.includes('right')) handle.style.right = '-6px';
        
        // Change cursor based on corner
        if (corner === 'top-left' || corner === 'bottom-right') {
            handle.style.cursor = 'nwse-resize';
        } else {
            handle.style.cursor = 'nesw-resize';
        }
        
        element.appendChild(handle);
    });
}

function updateImagePosition(element, imgId) {
    if (!element || !imgId) {
        console.warn('updateImagePosition: элемент или imgId не определены');
        return;
    }
    
    const imgRect = element.getBoundingClientRect();
    const canvasRect = pdfCanvasContainer.getBoundingClientRect();
    
    if (!canvasRect.width || !canvasRect.height) {
        console.warn('updateImagePosition: canvas имеет нулевые размеры');
        return;
    }
    
    const xCanvasPx = imgRect.left - canvasRect.left;
    const yCanvasPx = imgRect.top - canvasRect.top;
    const width = imgRect.width;
    const height = imgRect.height;
    
    if (!imagePositions[pageNum]) {
        imagePositions[pageNum] = {};
    }
    
    imagePositions[pageNum][imgId] = {
        x: xCanvasPx,
        y: yCanvasPx,
        width: width,
        height: height
    };
}

        function setupImageContextMenu(img) {
            img.addEventListener('contextmenu', (e) => {
                e.preventDefault();
                currentImage = img;
                contextMenu.style.display = 'block';
                contextMenu.style.left = `${e.pageX}px`;
                contextMenu.style.top = `${e.pageY}px`;
            });
        }

        document.addEventListener('keydown', function(event) {
            if (event.key === 'Delete' && currentImage) {
                const imgId = currentImage.getAttribute('data-image-id');
                currentImage.remove();
                const index = pageImages[pageNum].findIndex(img => img.getAttribute('data-image-id') === imgId);
                 if (index > -1) {
                    pageImages[pageNum].splice(index, 1);
                 }
                  delete imagePositions[pageNum][imgId];
                currentImage = null;
                 console.log(`Изображение удалено со страницы ${pageNum}.`);
            }
        });

      contextMenu.addEventListener('click', (e) => {
    const action = e.target.dataset.action;
    if (currentImage) {
        switch (action) {
     case 'copy':
                const newImg = currentImage.cloneNode(true);
                const imgId = Date.now() + Math.random();
                newImg.setAttribute('data-image-id', imgId);
                
                // Получаем исходные координаты
                const originalX = parseFloat(currentImage.getAttribute('data-x')) || 0;
                const originalY = parseFloat(currentImage.getAttribute('data-y')) || 0;
                
                // Добавляем минимальный сдвиг + визуальное смещение
                const newX = originalX + 20 + 0.1; // 20px для видимости + 0.1px для фиксации
                const newY = originalY + 20 + 0.1;
                
                newImg.style.transform = `translate(${newX}px, ${newY}px)`;
                newImg.setAttribute('data-x', newX);
                newImg.setAttribute('data-y', newY);
                
                pdfViewer.appendChild(newImg);
                makeDraggableAndResizable(newImg, imgId);
                setupImageContextMenu(newImg);
                
                if (!pageImages[pageNum]) {
                    pageImages[pageNum] = [];
                }
                pageImages[pageNum].push(newImg);
                
                if (!imagePositions[pageNum]) {
                    imagePositions[pageNum] = {};
                }
                
                const imgRect = newImg.getBoundingClientRect();
                const canvasRect = pdfCanvasContainer.getBoundingClientRect();
                
                imagePositions[pageNum][imgId] = {
                    x: imgRect.left - canvasRect.left,
                    y: imgRect.top - canvasRect.top,
                    width: imgRect.width,
                    height: imgRect.height
                };
                
                // Симулируем событие перемещения
                updateImagePosition(newImg, imgId);
                console.log(`Изображение скопировано на страницу ${pageNum} с минимальным сдвигом`);
                break;
                
            case 'delete':
                const imgIdToDelete = currentImage.getAttribute('data-image-id');
                currentImage.remove();
                const index = pageImages[pageNum].findIndex(img => 
                    img.getAttribute('data-image-id') === imgIdToDelete);
                if (index > -1) {
                    pageImages[pageNum].splice(index, 1);
                }
                delete imagePositions[pageNum][imgIdToDelete];
                currentImage = null;
                console.log(`Изображение удалено со страницы ${pageNum}.`);
                break;
                
            case 'apply-to-pages':
                showPageRangeDialog(currentImage);
                break;
        }
        contextMenu.style.display = 'none';
        currentImage = null;
    }
});

        document.addEventListener('click', (e) => {
            if (!contextMenu.contains(e.target)) {
                contextMenu.style.display = 'none';
            }
        });

    function showPageRangeDialog(img) {
    const overlay = document.createElement('div');
    overlay.classList.add('dialog-overlay');

    const dialog = document.createElement('div');
    dialog.classList.add('dialog');

    const input = document.createElement('input');
    input.type = 'text';
    input.placeholder = 'Введите диапазон страниц (например, "2-4 7")';

    const buttonContainer = document.createElement('div');
    buttonContainer.style.display = 'flex';
    buttonContainer.style.justifyContent = 'space-between';
    buttonContainer.style.gap = '10px';

    const applyButton = document.createElement('button');
    applyButton.textContent = 'Применить';
    applyButton.style.backgroundColor = '#6395ee';
    applyButton.style.color = 'white';
    applyButton.style.border = 'none';
    applyButton.style.padding = '10px 20px';
    applyButton.style.borderRadius = '5px';
    applyButton.style.cursor = 'pointer';
    applyButton.style.fontSize = '16px';
    applyButton.style.flex = '1';

    const cancelButton = document.createElement('button');
    cancelButton.textContent = 'Отмена';
    cancelButton.style.backgroundColor = '#ff2c2c';
    cancelButton.style.color = 'white';
    cancelButton.style.border = 'none';
    cancelButton.style.padding = '10px 20px';
    cancelButton.style.borderRadius = '5px';
    cancelButton.style.cursor = 'pointer';
    cancelButton.style.fontSize = '16px';
    cancelButton.style.flex = '1';

    applyButton.onclick = () => {
        const pages = parsePageRange(input.value) || [];
        const originalX = parseFloat(img.getAttribute('data-x')) || 0;
        const originalY = parseFloat(img.getAttribute('data-y')) || 0;

        const targetPages = pages.length > 0 ? pages : Array.from({ length: pdfDoc.numPages }, (_, i) => i + 1);
        
        targetPages.forEach(page => {
            if (!pageImages[page]) {
                pageImages[page] = [];
            }
            const newImg = img.cloneNode(true);
            const imgId = Date.now() + Math.random();
            newImg.setAttribute('data-image-id', imgId);
            
            // Добавляем минимальный сдвиг
            const newX = originalX + 0.1;
            const newY = originalY + 0.1;
            newImg.style.transform = `translate(${newX}px, ${newY}px)`;
            newImg.setAttribute('data-x', newX);
            newImg.setAttribute('data-y', newY);
            
            pdfViewer.appendChild(newImg);
            makeDraggableAndResizable(newImg, imgId);
            setupImageContextMenu(newImg);
            pageImages[page].push(newImg);
            
            if (!imagePositions[page]) {
                imagePositions[page] = {};
            }
            
            const imgRect = newImg.getBoundingClientRect();
            const canvasRect = pdfCanvasContainer.getBoundingClientRect();
            
            imagePositions[page][imgId] = {
                x: imgRect.left - canvasRect.left,
                y: imgRect.top - canvasRect.top,
                width: imgRect.width,
                height: imgRect.height
            };
            
            // Симулируем перемещение
            updateImagePosition(newImg, imgId);
            console.log(`Изображение применено к странице ${page} с минимальным сдвигом`);
        });
        
        overlay.remove();
    };

    cancelButton.onclick = () => overlay.remove();

    buttonContainer.appendChild(applyButton);
    buttonContainer.appendChild(cancelButton);
    dialog.appendChild(input);
    dialog.appendChild(buttonContainer);
    overlay.appendChild(dialog);
    document.body.appendChild(overlay);
}

        function parsePageRange(range) {
            const pages = new Set();
            if(!range) return [];
            const parts = range.split(' ');
            parts.forEach(part => {
                if (part.includes('-')) {
                    const [start, end] = part.split('-').map(Number);
                    for (let i = start; i <= end; i++) {
                        pages.add(i);
                    }
                } else {
                    pages.add(Number(part));
                }
            });
            return Array.from(pages);
        }

 saveButton.addEventListener('click', async () => {
    if (!pdfDoc) {
        alert('Пожалуйста, сначала загрузите PDF файл');
        return;
    }

    console.log("Начало сохранения всех страниц в JPG...");
    const zip = new JSZip();
    const logData = [];
    
    // Константы для A4 при 300dpi
    const DPI = 300;
    const MM_TO_INCH = 1 / 25.4;
    const A4_WIDTH_MM = 210;
    const A4_HEIGHT_MM = 297;
    const A4_WIDTH_PX = Math.round(A4_WIDTH_MM * MM_TO_INCH * DPI);
    const A4_HEIGHT_PX = Math.round(A4_HEIGHT_MM * MM_TO_INCH * DPI);

    try {
        // Последовательная обработка всех страниц
        for (let i = 1; i <= pdfDoc.numPages; i++) {
            console.log(`Обработка страницы ${i} из ${pdfDoc.numPages}`);
            
            const page = await pdfDoc.getPage(i);
            const viewport = page.getViewport({ scale: 1 });
            
            // Вычисление масштаба для A4 300dpi
            const scale = Math.min(
                A4_WIDTH_PX / viewport.width,
                A4_HEIGHT_PX / viewport.height
            );
            const scaledViewport = page.getViewport({ scale });

            // Создание canvas с размерами A4
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.width = A4_WIDTH_PX;
            canvas.height = A4_HEIGHT_PX;

            // Центрирование содержимого
            const offsetX = (A4_WIDTH_PX - scaledViewport.width) / 2;
            const offsetY = (A4_HEIGHT_PX - scaledViewport.height) / 2;

            // Рендеринг страницы PDF
            await page.render({
                canvasContext: context,
                viewport: scaledViewport,
                transform: [1, 0, 0, 1, offsetX, offsetY]
            }).promise;

            // Объект для логирования
            const pageLog = {
                pageNumber: i,
                canvasWidth: canvas.width,
                canvasHeight: canvas.height,
                images: []
            };

            // Добавление наложений, если они есть
            if (pageImages[i] && pageImages[i].length > 0) {
                console.log(`Найдено ${pageImages[i].length} наложений для страницы ${i}`);
                
                // Ожидание загрузки всех изображений
                await Promise.all(pageImages[i].map(img => 
                    new Promise(resolve => {
                        if (img.complete) resolve();
                        else img.onload = resolve;
                    })
                ));

                for (const img of pageImages[i]) {
                    const imgId = img.getAttribute('data-image-id');
                    if (!imagePositions[i]?.[imgId]) {
                        console.warn(`Отсутствует позиция для изображения ${imgId} на странице ${i}`);
                        continue;
                    }

                    const pos = imagePositions[i][imgId];
                    const aspectRatio = img.naturalWidth / img.naturalHeight;
                    
                    // Масштабирование относительно размеров viewer'а
                    const viewerScale = Math.min(
                        A4_WIDTH_PX / pdfCanvasContainer.offsetWidth,
                        A4_HEIGHT_PX / pdfCanvasContainer.offsetHeight
                    );

                    const scaledWidth = pos.width * viewerScale;
                    const scaledHeight = scaledWidth / aspectRatio;
                    const x = pos.x * viewerScale + offsetX;
                    const y = pos.y * viewerScale + offsetY;

                    context.drawImage(img, x, y, scaledWidth, scaledHeight);

                    pageLog.images.push({
                        id: imgId,
                        type: img.getAttribute('data-type') || 'image',
                        position: { x, y },
                        size: { width: scaledWidth, height: scaledHeight },
                        originalPosition: { 
                            x: pos.x, 
                            y: pos.y, 
                            width: pos.width, 
                            height: pos.height 
                        }
                    });
                }
            }

            // Добавление страницы в ZIP
            const pageBlob = await new Promise(resolve => 
                canvas.toBlob(resolve, 'image/jpeg', 0.95)
            );
            zip.file(`page_${String(i).padStart(3, '0')}.jpg`, pageBlob);
            logData.push(pageLog);
        }

        // Добавление лога в ZIP
        zip.file('log.json', JSON.stringify(logData, null, 2));

        // Генерация и скачивание ZIP
        const zipBlob = await zip.generateAsync({ 
            type: 'blob',
            compression: 'DEFLATE',
            compressionOptions: { level: 6 }
        });

        const url = URL.createObjectURL(zipBlob);
        const link = document.createElement('a');
        link.href = url;
        link.download = `document_${new Date().toISOString().slice(0,10)}.zip`;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(url);

        console.log("Все страницы успешно сохранены в ZIP файл");
    } catch (error) {
        console.error("Ошибка при сохранении страниц:", error);
        alert('Произошла ошибка при сохранении документа');
    }
});

        prevPageButton.addEventListener('click', () => {
            if (pageNum <= 1) return;
            pageNum--;
            updatePageInfo();
            if (!pageRendering) {
                renderPage(pageNum);
            } else {
                pageNumPending = pageNum;
            }
        });

        nextPageButton.addEventListener('click', () => {
            if (pageNum >= pdfDoc.numPages) return;
            pageNum++;
            updatePageInfo();
            if (!pageRendering) {
                renderPage(pageNum);
            } else {
                pageNumPending = pageNum;
            }
        });
    </script>
</body>
</html>