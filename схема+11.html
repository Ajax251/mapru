<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Схема по координатам</title>
    <link href="webfonts/all.min.css" rel="stylesheet">
    <link rel="stylesheet" href="webfonts/all.min.css">
<link rel="icon" href="img/xy.png" type="image/png">
    <script src="sk.js"></script>
    <script src="msk.js"></script>
<script src="webfonts/proj4.js"></script>

<script src="webfonts/jszip.min.js"></script>
<script src="webfonts/xlsx.full.min.js"></script>
<style>
   :root {
    --bg-main: #f0f2f5;
    --text-main: #2c3e50;
    --text-label: #34495e;
    --border-strong: #4facfe;
    --shadow-glow: rgba(79, 172, 254, 0.2);
    --shadow-deep: rgba(0,0,0,0.1);
    --panel-bg: rgba(255, 255, 255, 0.6);
    --panel-border: rgba(255, 255, 255, 0.3);
    --input-bg: rgba(255, 255, 255, 0.8);
    --input-border: rgba(52, 73, 94, 0.15);
    --input-shadow: rgba(0,0,0,0.05);
}

* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

html, body {
    height: 100%;
    overflow: hidden; /* Скрываем прокрутку для больших экранов */
}

body {
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
    line-height: 1.6;
    color: var(--text-main);
    background-color: var(--bg-main);
}

.container {
    width: 100vw;
    height: 100vh;
    padding: 25px;
    display: flex;
    flex-direction: column;
    position: relative;
    transition: background 0.8s ease-in-out;
}

.container::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><defs><pattern id="grain" width="100" height="100" patternUnits="userSpaceOnUse"><circle cx="20" cy="20" r="1" fill="%23000" opacity="0.03"/><circle cx="80" cy="40" r="1" fill="%23000" opacity="0.03"/><circle cx="40" cy="80" r="1" fill="%23000" opacity="0.03"/></pattern></defs><rect width="100%" height="100%" fill="url(%23grain)"/></svg>');
    pointer-events: none;
    z-index: 0;
}

.main-layout {
    display: grid;
    grid-template-columns: 450px 1fr; /* Две колонки по умолчанию */
    gap: 25px;
    flex: 1;
    min-height: 0;
    z-index: 1;
}

.column {
    background: var(--panel-bg);
    border-radius: 20px;
    box-shadow: 0 10px 30px var(--shadow-deep);
    border: 1px solid var(--panel-border);
    backdrop-filter: blur(15px);
    position: relative;
    overflow: hidden;
    display: flex;
    flex-direction: column;
    min-height: 0;
}

h1 {
    color: var(--text-label);
    font-weight: 600;
    margin-top: 0;
    margin-bottom: 25px;
    letter-spacing: 1px;
}

.column-controls {
    padding: 25px;
    gap: 20px;
    text-align: center;
}

.column-canvas {
    padding: 0;
}

.control-group {
    display: flex;
    flex-direction: column;
}

.control-group.scrollable {
    flex: 1;
    min-height: 0;
    overflow-y: auto;
    padding-right: 10px;
    margin-right: -10px;
}

.control-group.scrollable::-webkit-scrollbar {
    width: 8px;
}

.control-group.scrollable::-webkit-scrollbar-track {
    background: rgba(0,0,0,0.05);
    border-radius: 10px;
}

.control-group.scrollable::-webkit-scrollbar-thumb {
    background: linear-gradient(135deg, #89f7fe 0%, #66a6ff 100%);
    border-radius: 10px;
}

label {
    display: block;
    margin-bottom: 12px;
    font-weight: 600;
    color: var(--text-label);
    font-size: 0.95rem;
    letter-spacing: 0.5px;
    text-align: center;
}

.textarea-wrapper {
    position: relative;
    flex: 1;
    display: flex;
    flex-direction: column;
    min-height: 200px;
}

textarea, select {
    width: 100%;
    padding: 16px 20px;
    border: 1px solid var(--input-border);
    border-radius: 15px;
    font-size: 0.95rem;
    transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    background: var(--input-bg);
    box-shadow: 0 4px 15px var(--input-shadow);
}

textarea:focus, select:focus {
    outline: none;
    border-color: var(--border-strong);
    box-shadow: 0 0 0 4px var(--shadow-glow), 0 8px 25px rgba(0,0,0,0.1);
    transform: translateY(-2px);
}

textarea {
    flex: 1;
    resize: none;
    font-family: 'SF Mono', 'Monaco', 'Inconsolata', 'Roboto Mono', monospace;
    font-size: 0.9rem;
    line-height: 1.5;
    text-align: center;
    background: #ffffff;
}

select {
    cursor: pointer;
    appearance: none;
    background-image: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="%234facfe" stroke-width="2"><polyline points="6,9 12,15 18,9"/></svg>');
    background-repeat: no-repeat;
    background-position: right 15px center;
    background-size: 18px;
    padding-right: 45px;
    text-align: center;
    text-align-last: center;
}

.textarea-controls {
    position: absolute;
    top: 12px;
    right: 12px;
    z-index: 10;
    display: flex;
    flex-direction: column;
    gap: 8px;
    align-items: center;
}

.textarea-control-btn {
    width: 32px;
    height: 32px;
    border: none;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    color: white;
    transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
    background: linear-gradient(135deg, #6a82fb 0%, #fc5c7d 100%); /* Этот фон будет заменен JS */
    font-size: 14px;
}
.textarea-control-btn:hover {
    box-shadow: 0 6px 25px rgba(0, 0, 0, 0.3);
    transform: scale(1.1);
}
.textarea-control-btn i {
    transition: transform 0.3s ease;
}
.textarea-control-btn:hover i {
    transform: scale(1.2);
}

.button-container {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(80px, 1fr));
    gap: 15px;
}

.action-btn {
    padding: 15px;
    border: none;
    border-radius: 15px;
    cursor: pointer;
    font-size: 16px;
    color: white;
    transition: all 0.3s ease;
    box-shadow: 0 8px 20px rgba(0,0,0,0.15);
    display: flex;
    align-items: center;
    justify-content: center;
}

.action-btn:hover {
    transform: translateY(-3px) scale(1.05);
    box-shadow: 0 12px 25px rgba(0,0,0,0.25);
    filter: brightness(1.1);
}

.action-btn i {
    font-size: 20px;
    transition: transform 0.3s ease;
}

.action-btn:hover i {
    transform: scale(1.2) rotate(5deg);
}

.dxf-button { background: linear-gradient(135deg, #4285F4, #357ABD); }
.mif-button { background: linear-gradient(135deg, #FF4444, #CC0000); }
.csv-button { background: linear-gradient(135deg, #4CAF50, #45a049); }
.json-button { background: linear-gradient(135deg, #f39c12, #e67e22); }
.xml-button { background: linear-gradient(135deg, #8e44ad, #9b59b6); }
.map-button { background: linear-gradient(135deg, #4facfe, #4facfe); }
.editor-button { background: linear-gradient(135deg, #ff7f50, #ff6347); }
.converter-button { background: linear-gradient(135deg, #20c997, #17a2b8); }

#log, #distanceLog, #pointsList {
    background-color: hsla(220, 30%, 97%, 0.8);
    border: 1px solid hsla(220, 20%, 90%, 0.9);
    border-radius: 15px;
    padding: 15px;
    font-size: 0.9rem;
    text-align: center;
}

.combo-box-container {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 15px;
    margin-bottom: 15px;
}

.combo-box-wrapper {
    display: flex;
    flex-direction: column;
}

.combo-box-actions {
    display: flex;
    justify-content: center;
    gap: 15px;
    margin-top: -5px;
    margin-bottom: 15px;
}
.combo-box-actions .action-btn {
    width: 50px;
    height: 50px;
    border-radius: 50%;
}

.canvas-wrapper {
    position: relative;
    width: 100%;
    height: 100%;
}

#canvas {
    width: 100%;
    height: 100%;
    display: block;
    border-radius: 20px;
    cursor: grab;
    touch-action: none;
}
#canvas:active { cursor: grabbing; }

#eyeButton {
    position: absolute;
    top: 20px;
    right: 20px;
    width: 48px;
    height: 48px;
    background: var(--panel-bg);
    border: 1px solid var(--panel-border);
    backdrop-filter: blur(10px);
    border-radius: 50%;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    box-shadow: 0 4px 15px rgba(0,0,0,0.15);
    z-index: 10;
    transition: all 0.3s ease;
}
#eyeButton:hover {
    transform: scale(1.1);
    box-shadow: 0 6px 20px rgba(0,0,0,0.2);
}
#eyeButton::before {
    content: '';
    width: 20px;
    height: 20px;
    background-image: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="%2334495e"><path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5C21.27 7.61 17 4.5 12 4.5zm0 12c-2.48 0-4.5-2.02-4.5-4.5S9.52 7.5 12 7.5s4.5 2.02 4.5 4.5-2.02 4.5-4.5 4.5zm0-7c-1.38 0-2.5 1.12-2.5 2.5s1.12 2.5 2.5 2.5 2.5-1.12 2.5-2.5-1.12-2.5-2.5-2.5z"/></svg>');
    background-size: contain;
    background-repeat: no-repeat;
    opacity: 0.8;
}
#eyeButton.no-labels::after, #eyeButton.no-points::after, #eyeButton.only-drawing::after, #eyeButton.no-distances::after, #eyeButton.points-distances-only::after {
    content: ''; position: absolute; width: 80%; height: 2px; background: #e74c3c; border-radius: 1px;
}
#eyeButton.no-labels::after { transform: rotate(0deg); }
#eyeButton.no-points::after { transform: rotate(45deg); }
#eyeButton.no-distances::after { transform: rotate(90deg); }
#eyeButton.only-drawing::after { transform: rotate(135deg); }
#eyeButton.points-distances-only::after { transform: rotate(180deg); }

.floating-btn {
    position: fixed; /* ИСПРАВЛЕНО: Кнопки должны быть привязаны к экрану */
    width: 60px;
    height: 60px;
    border-radius: 50%;
    border: none;
    color: white;
    display: flex;
    align-items: center;
    justify-content: center;
    box-shadow: 0 8px 25px rgba(0,0,0,0.2);
    cursor: pointer;
    z-index: 1000;
    transition: all 0.3s ease;
}
.floating-btn:hover {
    transform: translateY(-3px) scale(1.08);
    box-shadow: 0 12px 30px rgba(0,0,0,0.3);
    filter: brightness(1.1);
}
.floating-btn i { font-size: 22px; }

#importButton {
    /* position: absolute; <-- УДАЛЕНО: наследовалось position: fixed */
    bottom: 25px;
    right: 25px;
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
}

#schemeButton {
    bottom: 25px;
    left: 25px;
    background: linear-gradient(135deg, #38f9d7 0%, #43e97b 100%);
}
#schemeButton span {
    display: none;
}

#schemeMenu {
    display: none;
    position: fixed;
    bottom: 95px; /* 25px отступ + 60px кнопка + 10px зазор */
    left: 25px;
    background: var(--panel-bg);
    border: 1px solid var(--panel-border);
    backdrop-filter: blur(15px);
    border-radius: 15px;
    padding: 10px;
    z-index: 1000;
    box-shadow: 0 10px 30px var(--shadow-deep);
}
#schemeMenu div {
    cursor: pointer;
    padding: 10px 15px;
    display: flex;
    align-items: center;
    gap: 12px;
    border-radius: 10px;
    transition: background-color 0.2s ease;
}
#schemeMenu div:hover {
    background-color: rgba(0,0,0,0.05);
}
#schemeMenu div i {
    width: 1.5em;
    text-align: center;
    color: var(--border-strong);
    font-size: 1rem;
}

#notification, #aiLoader {
    position: fixed;
    bottom: 25px;
    right: 25px;
    background: linear-gradient(135deg, #2af598 0%, #009efd 100%);
    color: white;
    padding: 12px 25px;
    border-radius: 15px;
    box-shadow: 0 8px 20px rgba(0,0,0,0.2);
    display: none;
    z-index: 10001;
    font-weight: 600;
}
#aiLoader {
    display: none;
    align-items: center;
    gap: 10px;
    background: linear-gradient(135deg, #f6d365 0%, #fda085 100%);
    color: var(--text-main);
}
#aiLoader i { animation: spin 1s linear infinite; }
@keyframes spin { 100% { transform: rotate(360deg); } }


#custom-tooltip {
    position: fixed;
    color: white;
    padding: 8px 14px;
    border-radius: 8px;
    font-size: 14px;
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
    z-index: 10002;
    opacity: 0;
    visibility: hidden;
    pointer-events: none;
    transition: opacity 0.2s ease, transform 0.2s ease, background 0.2s ease;
    white-space: nowrap;
    transform: translate(-50%, 0);
    box-shadow: 0 4px 12px rgba(0,0,0,0.15);
}

#custom-tooltip.show {
    opacity: 1;
    visibility: visible;
}

#custom-tooltip.tooltip-above.show {
    transform: translate(-50%, calc(-100% - 12px));
}

#custom-tooltip.tooltip-below.show {
    transform: translate(-50%, 12px);
}

#custom-tooltip::after {
    content: '';
    position: absolute;
    left: 50%;
    transform: translateX(-50%);
    border-width: 6px;
    border-style: solid;
    transition: border-color 0.2s ease;
}

#custom-tooltip.tooltip-above::after {
    top: 100%;
    border-color: var(--tooltip-bg, #2c3e50) transparent transparent transparent;
}

#custom-tooltip.tooltip-below::after {
    bottom: 100%;
    border-color: transparent transparent var(--tooltip-bg, #2c3e50) transparent;
}

.flex-grow {
    flex: 1;
    display: flex;
    flex-direction: column;
    min-height: 0;
}

.crop-modal-content-wrapper-scheme {
    background: var(--panel-bg);
    border-radius: 20px;
    box-shadow: 0 10px 30px var(--shadow-deep);
    border: 1px solid var(--panel-border);
    backdrop-filter: blur(15px);
    padding: 25px;
    max-width: 90vw;
    max-height: 90vh;
    overflow: auto;
    text-align: center;
    display: flex;
    flex-direction: column;
    gap: 15px;
}

.crop-modal-content-wrapper-scheme h3 {
    color: var(--text-label);
    font-weight: 600;
    margin: 0;
}

#crop-image-container-scheme {
    position: relative;
    display: inline-block;
    border: 2px dashed var(--input-border);
    border-radius: 15px;
    overflow: hidden;
    cursor: crosshair;
    user-select: none;
    touch-action: none;
    line-height: 0;
}

#crop-image-preview-scheme {
    display: block;
    max-width: 100%;
    max-height: calc(80vh - 150px);
    user-select: none;
    -webkit-user-drag: none;
}

#crop-selection-rectangle-scheme {
    position: absolute;
    border: 2px solid var(--border-strong);
    background-color: var(--shadow-glow);
    display: none;
    pointer-events: none;
}

.crop-modal-buttons-scheme {
    display: flex;
    justify-content: center;
    gap: 15px;
}

.crop-modal-buttons-scheme .action-btn {
     min-width: 180px;
     gap: 10px;
}
#schemeMenu.is-active {
    display: block;
}

#eyeButton.with-names::after {
    content: ''; 
    position: absolute; 
    width: 2px;
    height: 80%; 
    background: #2980b9; 
    border-radius: 1px;
    transform: rotate(0deg); 
}

/* --- НАЧАЛО: АДАПТИВНЫЕ СТИЛИ ДЛЯ РАЗНЫХ ЭКРАНОВ --- */

@media (max-width: 1024px) {
    /* Разрешаем прокрутку всей страницы */
    html, body { 
        overflow: auto; 
    }
    
    /* Делаем контейнер гибким по высоте и уменьшаем отступы */
    .container { 
        height: auto; 
        padding: 15px; 
    }
    
    /* Переключаем макет на одну колонку */
    .main-layout { 
        grid-template-columns: 1fr; 
        gap: 20px; 
    }
    
    /* Задаем минимальную высоту для холста, чтобы он был виден */
    .column-canvas { 
        min-height: 50vh; 
    }
    
    /* Перемещаем кнопку импорта в левый верхний угол, чтобы она не мешала */
    #importButton {
        top: 15px;
        left: 15px;
        bottom: auto; /* Сбрасываем нижнее позиционирование */
        right: auto;  /* Сбрасываем правое позиционирование */
        width: 50px;
        height: 50px;
    }
    
    /* Уменьшаем и сдвигаем кнопку схемы и ее меню */
    #schemeButton { 
        bottom: 15px; 
        left: 15px; 
        width: 50px; 
        height: 50px; 
    }
    
    #schemeMenu { 
        bottom: 75px; /* 15px отступ + 50px кнопка + 10px зазор */
        left: 15px; 
    }
}
/* --- КОНЕЦ: АДАПТИВНЫЕ СТИЛИ --- */
</style>
<body>
    <div class="container">
        <div class="main-layout">
            <!-- Левая колонка с элементами управления -->
          <div class="column column-controls">
    <!-- Мы полностью УДАЛИЛИ верхний блок с иконкой -->

    <!-- Блок ввода координат с классом flex-grow -->
    <div class="control-group flex-grow">
        <label for="coordsInput">Схема по координатам</label>
        <div class="textarea-wrapper">
            <textarea id="coordsInput" placeholder="Вставьте координаты или изображение..."></textarea>
            <div class="textarea-controls">
                <button class="textarea-control-btn" id="swapSourceBtn" title="Поменять X и Y"><i class="fas fa-exchange-alt"></i></button>
                <button class="textarea-control-btn" id="copySourceBtn" title="Копировать"><i class="fas fa-copy"></i></button>
                <button class="textarea-control-btn" id="makeFirstBtn" title="Сделать строку первой"><i class="fas fa-anchor"></i></button>
                <button class="textarea-control-btn" id="vSwapSourceBtn" title="Обратный порядок строк"><i class="fas fa-sort-amount-down-alt"></i></button>
                    <button class="textarea-control-btn" id="separateContoursBtn" title="Разделить на контуры"><i class="fas fa-object-group"></i></button>
                <button class="textarea-control-btn" id="pasteFromClipboardBtn" title="Вставить из буфера обмена"><i class="fas fa-paste"></i></button>
            </div>
        </div>
    </div>

                <!-- Блок кнопок действий -->
         <div class="control-group">
    <label></label>
    <div class="button-container">
        <button class="action-btn dxf-button" onclick="generateAndDownloadDXF()" title="Экспорт в DXF"><i class="fas fa-drafting-compass"></i></button>
        <button class="action-btn mif-button" onclick="generateAndDownloadMIF()" title="Экспорт в MIF"><i class="fas fa-map"></i></button>
        <button class="action-btn csv-button" onclick="generateAndDownloadCSV()" title="CSV (Технокад)"><i class="fas fa-file-csv"></i></button>
        <button class="action-btn json-button" onclick="generateAndDownloadJSON()" title="GeoJSON и CSV (НСПД)"><i class="fas fa-file-code"></i></button>
        <button class="action-btn xml-button" onclick="generateAndDownloadXML()" title="Схема XML"><i class="fas fa-code"></i></button>
        <button class="action-btn map-button" onclick="copyCoordinatesAndOpenMap()" title="Показать на карте"><i class="fas fa-globe-americas"></i></button>
        <button class="action-btn editor-button" onclick="openEditor()" title="Открыть в редакторе"><i class="fas fa-edit"></i></button>
        <button class="action-btn converter-button" onclick="openCoordConverter()" title="Конвертер координат"><i class="fas fa-retweet"></i></button>
    </div>
</div>
                
                <!-- Блок с логами и выбором точек (с возможностью прокрутки) -->
                <div class="control-group scrollable">
                    <div id="log" style="margin-bottom: 20px;"></div>
                    <div class="combo-box-container">
                        <div class="combo-box-wrapper" id="start-point-wrapper"></div>
                        <div class="combo-box-wrapper" id="end-point-wrapper"></div>
                    </div>
                    <div class="combo-box-actions"></div>
                    <div id="distanceLog" style="margin-bottom: 20px;"></div>
                    <div id="pointsList"></div>
                </div>
            </div>

            <!-- Правая колонка с холстом -->
            <div class="column column-canvas">
                <div class="canvas-wrapper">
                    <canvas id="canvas"></canvas>
                    <div id="eyeButton" title="Режим отображения"></div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Плавающие кнопки и меню -->
    <button class="floating-btn" id="importButton" onclick="importFile()" title="Импорт из файла">
        <i class="fas fa-file-import"></i>
    </button>
<button class="floating-btn" id="schemeButton" title="Дополнительные действия">
    <i class="fas fa-vector-square"></i>
    <span></span>
</button>
    <div id="schemeMenu" class="scheme-menu">
      <div id="addToDrawing"><i class="fas fa-plus-square"></i><span>Добавить из файла</span></div>
        <div id="addCoordinatesFromClipboard"><i class="fas fa-paste"></i><span>Добавить из буфера</span></div>
           <div id="addByCadastralNumber"><i class="fas fa-search-location"></i><span>Добавить по КН</span></div>
        <div id="addImageAndRecognize"><i class="fas fa-image"></i><span>Добавить из изображения</span></div>

        <div id="calculateDistances" onclick="checkDistances(); return false;"><i class="fas fa-ruler-horizontal"></i><span>Расстояние между точками</span></div>
        <div id="expandLinearObject"><i class="fas fa-arrows-alt-h"></i><span>Расширить линейный объект</span></div>
            <div id="linearFromArea"><i class="fas fa-compress-arrows-alt"></i><span>Линейный из площадного</span></div>
  
        <div id="openDXFButton" onclick="window.open('dxf.html', '_blank');"><i class="fas fa-pencil-ruler"></i><span>DXF редактор</span></div>
        <div id="generateTXT" onclick="generateTXTFile()"><i class="fas fa-file-alt"></i><span>Экспорт в TXT с номерами</span></div>
           <div id="exportDxfMin"><i class="fas fa-file-export"></i><span>Экспорт в DXF (мин.)</span></div>
           <div id="exportDxfAC1009"><i class="fas fa-file-archive"></i><span>Экспорт в DXF AC1009</span></div>
        <div id="adjacentParcel" onclick="copyCoordsAndOpenAdjacentSchema()"><i class="fas fa-object-group"></i><span>Смежный ЗУ</span></div>
    </div>

    <!-- Модальные окна и уведомления (структура осталась прежней, стили применятся автоматически) -->
    <div id="notification"></div>
    <div id="aiLoader">
        <i class="fas fa-spinner"></i>
        <span>Распознавание...</span>
    </div>
 
<div id="widthDialog" class="width-dialog" style="display:none; position:fixed; top:50%; left:50%; transform:translate(-50%,-50%); background:white; padding:20px; border-radius:15px; box-shadow:0 10px 30px rgba(0,0,0,0.2); z-index:1001; text-align:center;">
    <h3 style="margin-top:0; margin-bottom:15px; color:#34495e;">Укажите ширину в метрах:</h3>
    <input type="number" id="widthInput" min="0" step="0.01" style="width:100%; padding:10px; border-radius:10px; border:1px solid #ccc; margin-bottom:15px; text-align:center;">
    <div style="display:flex; justify-content:center; gap:10px;">
        <button id="applyWidth" style="padding:10px 20px; border:none; border-radius:8px; background-color:#2ecc71; color:white; cursor:pointer;">Применить</button>
        <button id="cancelWidth" style="padding:10px 20px; border:none; border-radius:8px; background-color:#95a5a6; color:white; cursor:pointer;">Отмена</button>
    </div>
</div>
    

<div id="crop-image-modal-scheme" style="display: none; position:fixed; top:0; left:0; width:100%; height:100%; background-color:rgba(0,0,0,0.6); z-index:10001; justify-content:center; align-items:center; backdrop-filter:blur(5px);">
    <div class="crop-modal-content-wrapper-scheme">
        <h3>Обрезать изображение</h3>
        <p style="color: var(--text-main); font-size: 0.9rem; margin: 0;">Нажмите и перетащите на изображении, чтобы выбрать нужную область.</p>
        <div id="crop-image-container-scheme">
            <img id="crop-image-preview-scheme" src="#" alt="Preview" />
            <div id="crop-selection-rectangle-scheme"></div>
        </div>
        <div class="crop-modal-buttons-scheme">
            <button id="crop-image-button-confirm-scheme" class="action-btn" style="background: linear-gradient(135deg, #4CAF50, #45a049);">
                <i class="fas fa-check"></i>Применить
            </button>
            <button id="crop-image-button-cancel-scheme" class="action-btn" style="background: linear-gradient(135deg, #95a5a6, #7f8c8d);">
                <i class="fas fa-expand-arrows-alt"></i>Использовать всё
            </button>
        </div>
    </div>
</div>
 
    
    <div class="modal-backdrop" id="cadastralModal" style="display: none; position:fixed; top:0; left:0; width:100%; height:100%; background-color:rgba(0,0,0,0.6); z-index:10001; justify-content:center; align-items:center; backdrop-filter:blur(5px);">
    <div class="modal-content" id="cadastralModalContent" style="background: white; padding: 30px; border-radius: 16px; box-shadow: 0 10px 30px rgba(0,0,0,0.2); width: 90%; max-width: 420px; text-align: left;">
        <h3 style="font-size: 1.5em; font-weight: 600; margin-bottom: 8px; color: var(--text-main);">Ввод данных</h3>
        <p class="modal-description" style="color: var(--text-secondary); margin-bottom: 20px;">Введите кадастровый номер объекта:</p>
        <input type="text" id="cadastralInputModal" placeholder="XX:XX:XXXXXXX:XX" autocomplete="off" style="width: 100%; padding: 14px; text-align: left; font-size: 1.1em; font-family: monospace; letter-spacing: 1.5px; background-color: #f1f3f5; border: 1px solid #e9ecef; border-radius: 10px; transition: all 0.2s ease-in-out;">
        <div class="modal-buttons" style="display: flex; justify-content: flex-end; gap: 10px; margin-top: 25px;">
            <button class="modal-btn" id="cadastralCancelBtn" style="background-color: #f1f3f5; color: #495057; font-weight: 500; border-radius: 10px; padding: 12px 22px; border: none; cursor:pointer;">Отмена</button>
            <button class="modal-btn" id="cadastralOkBtn" style="background-color: #343a40; color: white; font-weight: 500; border-radius: 10px; padding: 12px 22px; border: none; cursor:pointer;">Продолжить</button>
        </div>
    </div>
</div>
    
   
  <script>
    
 
let zoomLevel = 1;
let panX = 0;
let panY = 0;
let isDragging = false;
let lastX = 0;
let lastY = 0;

let showLabels = true;
let showPoints = true;
let eyeState = 0; 

let showRulers = true;

let showDistances = true;

let savedContourNames = []; // Массив для хранения названий контуров
let showContourNames = false; // Флаг для управления отображением названий

let cropSelectionScheme = { startX: 0, startY: 0, endX: 0, endY: 0, isDrawing: false };
let imageNaturalSizeScheme = { width: 0, height: 0 };
let imageDisplaySizeScheme = { width: 0, height: 0 };
let cropModalResolveScheme = null;

const VERCEL_PROXY_BASE_URL = "https://ver-olive-delta.vercel.app";

const sevenDigitsRegions = ['06', '07', '09', '10', '11', '12', '13', '14', '17', '23','24', '27', '31', '32', '35', '36', '41', '42', '47', '48','50', '52', '53', '56', '57', '58', '59', '60', '61', '62','63', '64', '65', '66', '67', '69', '70', '71', '72', '74','77', '78', '79', '91'];


        const MAPRUAPP_PROXY_BASE_URL = "https://mapruapp.ru"; // Ваш прокси
        
        // --- ПЕРЕКЛЮЧАТЕЛЬ ПРОКСИ ---
        // 1 = Использовать прокси mapruapp (по умолчанию)
        // 0 = Использовать прокси vercel
        const PROXY_MODE = 1;

async function getCoordinatesFromImageAI(base64ImageData) {
    const aiLoader = document.getElementById('aiLoader');
    if (aiLoader) {
        aiLoader.querySelector('span').textContent = 'Распознавание координат из изображения...';
        aiLoader.style.display = 'flex';
    }

    const prompt = `Extract all numerical coordinates from this image.
Present them as two columns separated by a tab character (\\t).
The first coordinate in a pair (X) must always be less than the second coordinate (Y). If the original X > Y, swap them.
Each coordinate pair (X\\tY) should be on a new line.

Important: Regarding the number of digits before the decimal point:
1. Typically, one coordinate in a pair has 6 digits before the decimal point (e.g., "123456.78") and the other has 7 digits (e.g., "1234567.89").
2. If you identify a pair where one coordinate has 7 digits before the decimal point (like Y in "123.45\\t1234567.89"), and the other coordinate (X) has significantly fewer than 6 digits (e.g., only 3 digits as in "123.45"), please carefully re-examine the image. Look for any potentially obscured or missed leading digits in the shorter coordinate. Your goal is to extract a 6-digit number for X if it is visually supported by the image context. The aim is to accurately represent what is present or very strongly implied.

Do not include any headers, descriptions, comments, markdown formatting (e.g., \`\`\`), or any characters other than the coordinates themselves and the delimiters (tab and newline).
Numbers should have no more than two decimal places. Round mathematically.
If there are no coordinates in the image or you cannot recognize them, return an empty response. If for some reason you must write an explanatory message, it MUST be in Russian (for example: "Координаты на изображении не найдены"). Do not respond in English.
Example of correct output:
123456.78\\t1234567.89
654321.00\\t7654321.00
100000.10\\t2000000.20`;

    let apiUrl, requestBody;
    const modelId = "gemini-2.5-flash-lite";

    if (PROXY_MODE === 1) {
        apiUrl = `${MAPRUAPP_PROXY_BASE_URL}/ai/api/v1/chat/completions`;
        requestBody = {
            model: modelId,
            messages: [{
                role: "user",
                content: [
                    { type: "text", text: prompt },
                    { type: "image_url", image_url: { url: `data:image/jpeg;base64,${base64ImageData}` } }
                ]
            }],
            max_tokens: 4096
        };
    } else {
        apiUrl = `${VERCEL_PROXY_BASE_URL}/v1beta/models/${modelId}:generateContent`;
        requestBody = {
            contents: [{
                role: "user",
                parts: [
                    { text: prompt },
                    { inlineData: { mimeType: "image/jpeg", data: base64ImageData } }
                ]
            }]
        };
    }

    try {
        const response = await fetch(apiUrl, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(requestBody)
        });
        
        const data = await response.json();
        console.log("Raw AI JSON response (Image):", JSON.stringify(data, null, 2));

        if (!response.ok) {
            const errorDetail = data?.error?.message || `Статус ${response.status}`;
            throw new Error(`Ошибка AI прокси: ${errorDetail}`);
        }

        let aiResponseText;
        if (PROXY_MODE === 1) {
            aiResponseText = data.choices?.[0]?.message?.content;
        } else {
            aiResponseText = data.candidates?.[0]?.content?.parts?.[0]?.text;
        }

        if (aiResponseText) {
             console.log("Returning extracted text from AI (Image):", aiResponseText);
             return aiResponseText;
        } else if (data.candidates?.[0]?.finishReason === 'SAFETY') {
            throw new Error("Ответ заблокирован моделью по соображениям безопасности.");
        } else {
            console.warn("Proxy response structure not as expected (Image):", data);
            return "";
        }
    } catch (error) {
        console.error("Error calling AI Proxy API (Image):", error);
        throw error;
    } finally {
        if (aiLoader) aiLoader.style.display = 'none';
    }
}


        async function getCoordinatesFromTextAI(textData) {
            const aiLoader = document.getElementById('aiLoader');
            if (aiLoader) {
                aiLoader.querySelector('span').textContent = 'Распознавание координат из текста...';
                aiLoader.style.display = 'flex';
            }

            const prompt = `Extract all numerical X and Y coordinates from the provided text.
The input text might be a JSON-like structure where coordinate data is organized into "contours". Each contour is an array of point objects (e.g., \`[ { "x": XVAL, "y": YVAL, ... }, ... ]\`). Sometimes these contour arrays are nested within a larger "contours" key, like \`"contours": [ [ {point1}, {point2} ], [ {point3}, {point4} ] ] \`.
Your task is to process these points sequentially as they appear in the input:
1.  For each point object, extract the "x" and "y" values.
2.  Ensure that the first coordinate (X) is always numerically less than the second coordinate (Y). If you find a pair where X > Y, swap them. Example: if input is {"x": 2222222.22, "y": 111111.11}, the pair to format is 111111.11 and 2222222.22.
3.  Format the extracted coordinates as two columns separated by a tab character (\`\\t\`): \`X_value\\tY_value\`.
4.  Each formatted coordinate pair should be on a new line.
5.  Numbers should have no more than two decimal places (round mathematically).
6.  **Crucially: Preserve all points as they appear in each contour. If a contour's first and last point objects are identical (based on their "x" and "y" values, indicating a closed loop), you MUST output both the first occurrence and the last occurrence of this point for that contour.**

Do not include any headers, explanations, comments, or markdown formatting (like \`\`\`) in your response. Only output the formatted coordinates.
If you cannot find any coordinates in the text, you must return an empty response. If for some reason you must write an explanatory message, it MUST be in Russian (for example: "Координаты в тексте не найдены"). Do not use English for explanations like "The provided text does not contain...".
The following is the text to process:
---
${textData}
---
`;
            
            let apiUrl, requestBody;
            const modelId = "gemini-2.5-flash-lite"; // Модель не меняем

            if (PROXY_MODE === 1) {
                // Логика для прокси mapruapp
                apiUrl = `${MAPRUAPP_PROXY_BASE_URL}/ai/api/v1/chat/completions`;
                requestBody = {
                    model: modelId,
                    messages: [{ role: "user", content: prompt }],
                    max_tokens: 4096
                };
            } else {
                // Логика для прокси vercel
                apiUrl = `${VERCEL_PROXY_BASE_URL}/v1beta/models/${modelId}:generateContent`;
                requestBody = {
                    contents: [{ role: "user", parts: [{ text: prompt }] }]
                };
            }

            try {
                const response = await fetch(apiUrl, {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify(requestBody)
                });

                const data = await response.json();

                if (!response.ok) {
                    const errorDetail = data?.error?.message || `Статус ${response.status}`;
                    console.error("AI Proxy Error (Text):", data);
                    throw new Error(`Ошибка AI прокси: ${errorDetail}`);
                }
                
                let aiResponseText;
                if (PROXY_MODE === 1) {
                    aiResponseText = data.choices?.[0]?.message?.content;
                } else {
                    aiResponseText = data.candidates?.[0]?.content?.parts?.[0]?.text;
                }

                if (aiResponseText) {
                    const rawContent = aiResponseText.trim();
                    if (rawContent.includes("Координаты") && rawContent.includes("не найдены")) {
                        console.warn("AI returned a 'not found' message in Russian:", rawContent);
                        return "";
                    }
                    console.log("Raw AI response (Text):", rawContent);
                    const processedContent = addContourSeparators(rawContent);
                    console.log("Processed content (Text, after addContourSeparators):", processedContent);
                    return processedContent;
                } else if (data.candidates?.[0]?.finishReason === 'SAFETY') {
                    throw new Error("Ответ заблокирован моделью по соображениям безопасности.");
                } else {
                    console.warn("Proxy response structure not as expected (Text):", data);
                    return "";
                }
            } catch (error) {
                console.error("Error calling AI Proxy API (Text):", error);
                throw error;
            } finally {
                if (aiLoader) aiLoader.style.display = 'none';
            }
        }

// Define MSK projections (copied from your example)
if (typeof proj4 !== 'undefined') {
    proj4.defs("EPSG:3857", "+proj=merc +a=6378137 +b=6378137 +lat_ts=0.0 +lon_0=0.0 +x_0=0.0 +y_0=0 +k=1.0 +units=m +nadgrids=@null +wktext +no_defs");
    proj4.defs("EPSG:4326", "+proj=longlat +datum=WGS84 +no_defs");
    proj4.defs("MSK16_ZONE2",
        "+proj=tmerc +lat_0=0 +lon_0=52.033333333333 +k=1 +x_0=2300000 +y_0=-5709414.70 +ellps=krass +towgs84=23.57,-140.95,-79.8,0,-0.35,-0.79,-0.22 +units=m +no_defs +axis=enu"
    );
    proj4.defs("MSK16_ZONE1",
        "+proj=tmerc +lat_0=0 +lon_0=49.033333333333 +k=1 +x_0=1300000 +y_0=-5709414.70 +ellps=krass +towgs84=23.57,-140.95,-79.8,0,-0.35,-0.79,-0.22 +units=m +no_defs +axis=enu"
    );
} else {
    console.warn("Proj4 library is not defined. XML quarter determination might fail.");
}



// ЗАМЕНИТЕ СТАРУЮ ФУНКЦИЮ ЭТОЙ
function setRandomTextareaControlColors() {
    const buttons = document.querySelectorAll('.textarea-control-btn');
    if (buttons.length === 0) return;

    // Генерируем два цвета для градиента ОДИН РАЗ
    const color1 = getRandomColor();
    const color2 = getRandomColor();
    const gradient = `linear-gradient(135deg, ${color1} 0%, ${color2} 100%)`;
    
    // Вычисляем контрастный цвет для иконок ОДИН РАЗ
    const iconColor = getContrastYIQ(color1);

    // Применяем ОДИНАКОВЫЕ цвета ко всем кнопкам
    buttons.forEach(button => {
        button.style.background = gradient;
        button.style.color = iconColor;
    });
}


async function handlePasteBtnClick(buttonElement) {
    // 1. Анимация "дрожания"
    buttonElement.style.transition = 'transform 0.4s cubic-bezier(.17,.67,.53,1.34)';
    buttonElement.style.transform = 'scale(1.2) rotate(10deg)';
    setTimeout(() => {
        buttonElement.style.transform = 'scale(1) rotate(0deg)';
    }, 400);

    // 2. Логика вставки из буфера обмена (осталась прежней)
    try {
        const clipboardText = await navigator.clipboard.readText();
        if (!clipboardText || clipboardText.trim() === '') {
            showNotification('Буфер обмена пуст');
            return;
        }
        const lines = clipboardText.trim().split('\n');
        const hasCoords = lines.some(line => /^\s*[\d.,-]+\s+[\d.,-]+\s*$/.test(line));
        if (hasCoords) {
            const coordsInput = document.getElementById('coordsInput');
            if (coordsInput) {
                coordsInput.value = clipboardText.replace(/,/g, '.');
                showNotification('Координаты вставлены из буфера обмена');
                handleInput(true); 
            }
        } else {
            showNotification('Координаты в буфере обмена не найдены');
        }
    } catch (err) {
        console.error('Ошибка при чтении буфера обмена:', err);
        showNotification('Не удалось получить доступ к буферу обмена');
    }
}


function parseMskCoordinatesForQuarter(text) {
    if (!text || typeof text !== 'string') return [];
    // Split by one or more empty lines to get groups/contours
    const groups = text.split(/\n\s*\n+/).map(group => group.trim()).filter(group => group !== '');
    
    return groups.map(group => {
        const lines = group.split('\n').map(line => line.trim()).filter(line => line !== '');
        return lines.map(line => {
            // Regex to match two numbers, potentially with decimals, separated by whitespace or tab
            // Handles numbers with comma or period as decimal separator
            const match = line.match(/^\s*([+-]?\d+([.,]\d+)?)\s+([+-]?\d+([.,]\d+)?)\s*$/);
            if (!match) return null;

            const val1Str = match[1].replace(',', '.');
            const val2Str = match[3].replace(',', '.');

            const val1 = parseFloat(val1Str);
            const val2 = parseFloat(val2Str);

            if (!isFinite(val1) || !isFinite(val2)) return null;
            return [val1, val2]; // Keep original order for now
        }).filter(coord => coord !== null);
    }).filter(group => group.length > 0);
}


function convertMSKToWGS84(mskCoords, mskZoneName) {
    if (typeof proj4 === 'undefined') {
        console.error("Proj4 is not defined. Cannot convert coordinates.");
        return null;
    }
    const [x, y] = mskCoords;
    // These specific corrections were in your example
    const correctedX = x + 14.745;
    const correctedY = y - 14.038;
    try {
        let wgs84 = proj4(mskZoneName, "EPSG:4326", [correctedX, correctedY]);
        // These specific corrections were in your example
        wgs84[0] -= 0.00000152; // Longitude adjustment
        wgs84[1] += 0.00000118; // Latitude adjustment
        return [wgs84[1], wgs84[0]]; // Return as [latitude, longitude]
    } catch (e) {
        console.error(`Error converting MSK to WGS84 using proj4 for zone ${mskZoneName}:`, e);
        showNotification(`Ошибка конвертации MSK в WGS84: ${e.message}`);
        return null;
    }
}

function convertWGS84toEPSG3857(latitude, longitude) {
    if (typeof proj4 === 'undefined') {
        console.error("Proj4 is not defined. Cannot convert coordinates.");
        return null;
    }
    try {
        const epsg3857Coords = proj4("EPSG:4326", "EPSG:3857", [longitude, latitude]);
        return { x: epsg3857Coords[0], y: epsg3857Coords[1] };
    } catch (e) {
        console.error("Error converting WGS84 to EPSG:3857 using proj4:", e);
        showNotification(`Ошибка конвертации WGS84 в EPSG:3857: ${e.message}`);
        return null;
    }
}

async function appendCoordinatesFromClipboard() {
    try {
        const clipboardText = await navigator.clipboard.readText();
        if (!clipboardText.trim()) {
            showNotification('Буфер обмена пуст');
            return;
        }

        const coordsInput = document.getElementById('coordsInput');
        let currentValue = coordsInput.value.trim();
        let separator = '';
        if (currentValue) {
            if (!currentValue.endsWith('\n\n')) {
                 if (currentValue.endsWith('\n')) {
                     separator = '\n';
                 } else {
                     separator = '\n\n';
                 }
            }
        }
        
        coordsInput.value = currentValue + separator + clipboardText;
        handleInput(true);
        showNotification('Координаты из буфера обмена добавлены');

    } catch (err) {
        console.error('Не удалось прочитать из буфера обмена: ', err);
        showNotification('Ошибка при чтении из буфера обмена');
    } finally {
        document.getElementById('schemeMenu').style.display = 'none';
    }
}


function formatCadastralNumberInput(input) {
    let value = input.value.replace(/[^\d]/g, '');
    let formatted = '';
    if (value.length > 0) {
        const region = value.substring(0, 2);
        formatted += region;
        if (value.length > 2) {
            formatted += ':' + value.substring(2, 4);
        }
        if (value.length > 4) {
            const quarterMaxLength = sevenDigitsRegions.includes(region) ? 7 : 6;
            const quarterEndIndex = 4 + quarterMaxLength;
            formatted += ':' + value.substring(4, quarterEndIndex);
            if (value.length > quarterEndIndex) {
                formatted += ':' + value.substring(quarterEndIndex);
            }
        }
    }
    input.value = formatted;
}

function isValidCadastralNumber(text) {
    if (!text) return false;
    const firstTwoDigits = text.slice(0, 2);
    const digitsAfterSecondColon = sevenDigitsRegions.includes(firstTwoDigits) ? 7 : 6;
    const pattern = new RegExp(`^\\d{2}:\\d{2}:\\d{${digitsAfterSecondColon}}:\\d+$`);
    return pattern.test(text);
}

function handleAddByCadastralNumber() {
    const modal = document.getElementById('cadastralModal');
    const input = document.getElementById('cadastralInputModal');
    input.value = '';
    modal.style.display = 'flex';
    input.focus();
    // Закрываем основное меню
    document.getElementById('schemeMenu').classList.remove('is-active');
}

async function processAddByCadastralNumber() {
    const modal = document.getElementById('cadastralModal');
    const input = document.getElementById('cadastralInputModal');
    const coordsTextarea = document.getElementById('coordsInput');
    const cadNumber = input.value.trim();

    modal.style.display = 'none';
    if (!cadNumber) return;

    if (!isValidCadastralNumber(cadNumber)) {
        showNotification("Неверный формат кадастрового номера.");
        return;
    }
    
    showNotification(`Загрузка данных для ${cadNumber}...`);
    try {
        // fetchEgrnCoordinates теперь возвращает массив контуров (массив массивов)
        const contoursArray = await fetchEgrnCoordinates(cadNumber);
        
        if (contoursArray && contoursArray.length > 0) {
            // Форматируем массив контуров в единую строку:
            // - точки внутри контура соединяются переносом строки "\n"
            // - сами контуры соединяются двойным переносом строки "\n\n"
            const newCoordsText = contoursArray.map(contourPoints => 
                contourPoints.map(c => `${c.x.toFixed(2)}\t${c.y.toFixed(2)}`).join('\n')
            ).join('\n\n');

            // Добавляем в textarea
            let currentValue = coordsTextarea.value.trim();
            let separator = (currentValue === '') ? '' : '\n\n';
            coordsTextarea.value = currentValue + separator + newCoordsText;
            
            handleInput(true); // Перерисовываем чертеж
            showNotification(`Участок ${cadNumber} успешно добавлен.`);
        } else {
             showNotification(`Не удалось получить координаты для ${cadNumber}.`);
        }
    } catch (error) {
        showNotification(`Ошибка: ${error.message}`);
        console.error("Ошибка при добавлении по КН:", error);
    }
}

async function fetchEgrnCoordinates(cadNumber) {
    
    const url = `https://nspd.gov.ru/api/geoportal/v2/search/geoportal?thematicSearchId=1&query=${encodeURIComponent(cadNumber)}`;
    
    try {
       
        const response = await fetch(url);

        
        if (!response.ok) {
           
            throw new Error(`Ошибка сети при запросе: ${response.status}`);
        }
        

        const data = await response.json();
        
        if (data.data?.features?.length > 0) {
            const feature = data.data.features[0];
            if (feature.geometry) {
               
                return autoDetectAndConvertEgrnCoords(feature.geometry, cadNumber);
            } else {
                throw new Error('Для данного участка геометрия в ЕГРН не найдена.');
            }
        } else {
            throw new Error('Участок не найден в ЕГРН.');
        }
    } catch (error) {
       
   
      
        throw error;
    }
}

function autoDetectAndConvertEgrnCoords(geometry, cadNumber) {
    if (typeof proj4 === 'undefined' || typeof COORDINATE_SYSTEMS === 'undefined' || typeof MskFinder === 'undefined') {
        throw new Error("Библиотеки для конвертации координат (proj4, sk, msk) не загружены.");
    }
    const mskCode = MskFinder.findMskCode(cadNumber); 
    if (!mskCode) throw new Error("Не удалось автоматически определить МСК для данного региона.");

  
    const searchString = "МСК " + mskCode;


    const targetSystem = COORDINATE_SYSTEMS.find(s => s.text.startsWith(searchString));
    

    if (!targetSystem) {
     
        throw new Error(`Не удалось найти систему координат. Искали строку "${searchString}" в свойстве 'text' файла sk.js.`);
    }

    proj4.defs(targetSystem.value, targetSystem.def);
    
    const { offsetX = 0, offsetY = 0 } = targetSystem;
    // Будем возвращать массив контуров (массив массивов точек)
    const convertedContours = [];

    const convertRing = ring => ring.map(coord => {
        const [lon, lat] = proj4('EPSG:3857', targetSystem.value, coord);
        const val1 = lat + offsetX;
        const val2 = lon + offsetY;
        return { x: Math.min(val1, val2), y: Math.max(val1, val2) };
    });

    const processGeom = (geom) => {
        if (!geom) return;
        
        if (geom.type === 'Polygon') {
            // Обрабатываем каждый "ринг" (внешний и внутренние контуры).
            // Первый элемент в geom.coordinates - внешний контур, остальные - внутренние.
            geom.coordinates.forEach(ring => {
                if (ring.length > 0) {
                    convertedContours.push(convertRing(ring));
                }
            });
        } else if (geom.type === 'MultiPolygon') {
            // Обрабатываем каждый полигон в мультиполигоне,
            // а внутри каждого полигона - каждый его "ринг".
            geom.coordinates.forEach(polygon => {
                polygon.forEach(ring => {
                    if (ring.length > 0) {
                        convertedContours.push(convertRing(ring));
                    }
                });
            });
        }
    };
    
    processGeom(geometry);
    // Возвращаем массив контуров
    return convertedContours;
}

function makeCurrentLineFirst() {
    const textarea = document.getElementById('coordsInput');
    const text = textarea.value;
    const cursorPos = textarea.selectionStart;

    if (!text.trim()) return;

    // Находим границы контура, в котором находится курсор
    let contourStart = text.lastIndexOf('\n\n', cursorPos - 1);
    contourStart = (contourStart === -1) ? 0 : contourStart + 2;

    let contourEnd = text.indexOf('\n\n', cursorPos);
    if (contourEnd === -1) {
        contourEnd = text.length;
    }

    const contourText = text.substring(contourStart, contourEnd);
    const contourLines = contourText.split('\n').filter(line => line.trim() !== '');

    if (contourLines.length <= 1) return; // Нечего переупорядочивать

    // Находим индекс строки, на которой стоит курсор
    const textBeforeCursorInContour = text.substring(contourStart, cursorPos);
    const selectedLineIndex = textBeforeCursorInContour.split('\n').length - 1;

    if (selectedLineIndex < 0 || selectedLineIndex >= contourLines.length) return;

    // Проверяем, замкнут ли контур
    const isClosed = contourLines.length > 2 && contourLines[0].trim() === contourLines[contourLines.length - 1].trim();
    
    let pointsToReorder = [...contourLines];
    
    // Если замкнут, удаляем последнюю дублирующую точку для переупорядочивания
    if (isClosed) {
        pointsToReorder.pop();
    }
    
    // Если курсор был на последней (замыкающей) точке, ничего не делаем
    if (selectedLineIndex >= pointsToReorder.length) {
         return;
    }

    // "Вращаем" массив точек, чтобы выбранная стала первой
    const reorderedPoints = pointsToReorder.slice(selectedLineIndex).concat(pointsToReorder.slice(0, selectedLineIndex));
    
    // Если контур был замкнутым, замыкаем его снова
    if (isClosed) {
        reorderedPoints.push(reorderedPoints[0]);
    }
    
    const newContourText = reorderedPoints.join('\n');
    
    // Заменяем старый контур на новый в общем тексте
    const newText = text.substring(0, contourStart) + newContourText + text.substring(contourEnd);
    
    textarea.value = newText;
    handleInput(true); // Обновляем чертеж
    showNotification('Начальная точка контура изменена');
}


async function appendImageFromClipboard() {
    const aiLoader = document.getElementById('aiLoader');
    const schemeMenu = document.getElementById('schemeMenu');
    
    try {
        // Проверяем разрешение на чтение из буфера обмена
        const permission = await navigator.permissions.query({ name: 'clipboard-read' });
        if (permission.state === 'denied') {
            throw new Error('Доступ к буферу обмена запрещен.');
        }

        const clipboardItems = await navigator.clipboard.read();
        let imageBlob = null;

        for (const item of clipboardItems) {
            const imageType = item.types.find(type => type.startsWith('image/'));
            if (imageType) {
                imageBlob = await item.getType(imageType);
                break; // Нашли первое изображение, выходим из цикла
            }
        }

        if (!imageBlob) {
            showNotification('Изображение в буфере обмена не найдено');
            return;
        }

        // --- Дальше используется логика, аналогичная вставке из буфера обмена ---
        if (aiLoader) aiLoader.style.display = 'flex';

        const tempImg = new Image();
        const objectURL = URL.createObjectURL(imageBlob);
        let imageDataToSendToAI;

        await new Promise((resolve, reject) => {
            tempImg.onload = async () => {
                URL.revokeObjectURL(objectURL);
                // Для Blob создаем временный File-подобный объект для модального окна
                const imageFileForCrop = new File([imageBlob], "clipboard_image.png", { type: imageBlob.type });
                
                if (tempImg.width > 800 || tempImg.height > 800) {
                    const cropResult = await showCropModalScheme(imageFileForCrop);
                    imageDataToSendToAI = cropResult.data;
                } else {
                    imageDataToSendToAI = (await fileToBase64(imageFileForCrop)).split(',')[1];
                }
                resolve();
            };
            tempImg.onerror = () => {
                URL.revokeObjectURL(objectURL);
                reject(new Error('Не удалось загрузить изображение из буфера обмена.'));
            };
            tempImg.src = objectURL;
        });

        const extractedCoordsText = await getCoordinatesFromImageAI(imageDataToSendToAI);

        if (extractedCoordsText && extractedCoordsText.trim() !== "") {
            const cleanedCoords = cleanAndFormatAICoordinates(extractedCoordsText);

            if (cleanedCoords.trim() !== "") {
                const coordsInput = document.getElementById('coordsInput');
                let currentValue = coordsInput.value.trim();
                let separator = '';
                if (currentValue) {
                    if (!currentValue.endsWith('\n\n')) {
                        separator = currentValue.endsWith('\n') ? '\n' : '\n\n';
                    }
                }
                coordsInput.value = currentValue + separator + cleanedCoords;
                handleInput(true);
                showNotification('Координаты из изображения добавлены!');
            } else {
                showNotification('Не удалось извлечь валидные координаты из изображения');
            }
        } else {
            showNotification('Не удалось извлечь координаты из изображения');
        }

    } catch (error) {
        console.error('Ошибка при добавлении изображения из буфера обмена:', error);
        showNotification('Ошибка: ' + error.message);
    } finally {
        if (aiLoader) aiLoader.style.display = 'none';
        if (schemeMenu) schemeMenu.style.display = 'none';
    }
}



function calculateCentroidWGS84(coordsArrayWGS84) {
    if (!coordsArrayWGS84 || coordsArrayWGS84.length === 0) return null;
    let sumLat = 0;
    let sumLon = 0;
    coordsArrayWGS84.forEach(coord => {
        if (coord && typeof coord[0] === 'number' && typeof coord[1] === 'number') {
            sumLat += coord[0]; // latitude
            sumLon += coord[1]; // longitude
        }
    });
    return [sumLat / coordsArrayWGS84.length, sumLon / coordsArrayWGS84.length];
}

async function queryNSPDForQuarter(originalLatitudeWGS, originalLongitudeWGS) {
    const MAX_RETRIES = 10; // Увеличено до 10 попыток
    const RETRY_DELAY_MS = 200; // Пауза в 200 мс
    const OFFSET_DEGREES = 0.0001; // Примерный эквивалент 10-11 метров для широты/долготы

    for (let attempt = 0; attempt < MAX_RETRIES; attempt++) {
        if (attempt > 0) {
            // Пауза перед повторной попыткой
            await new Promise(resolve => setTimeout(resolve, RETRY_DELAY_MS));
        }

        let currentLat = originalLatitudeWGS;
        let currentLon = originalLongitudeWGS;

        if (attempt > 0) {
            // Применяем случайное смещение для повторных попыток
            const latOffset = (Math.random() * 2 - 1) * OFFSET_DEGREES;
            const lonOffset = (Math.random() * 2 - 1) * OFFSET_DEGREES;
            currentLat += latOffset;
            currentLon += lonOffset;
            console.log(`NSPD Попытка ${attempt + 1}/${MAX_RETRIES}: Смещенные координаты lat=${currentLat.toFixed(6)}, lon=${currentLon.toFixed(6)}`);
        }

        const centerPointEPSG3857 = convertWGS84toEPSG3857(currentLat, currentLon);
        if (!centerPointEPSG3857) {
            console.warn(`NSPD Попытка ${attempt + 1}: Не удалось конвертировать смещенные WGS84 в EPSG:3857.`);
            if (attempt === MAX_RETRIES - 1) {
                return null;
            }
            continue;
        }

        const centerX = centerPointEPSG3857.x;
        const centerY = centerPointEPSG3857.y;
        const halfSize = 10.0;
        const minX = centerX - halfSize;
        const minY = centerY - halfSize;
        const maxX = centerX + halfSize;
        const maxY = centerY + halfSize;
        const bbox = `${minX},${minY},${maxX},${maxY}`;

        const queryI = 256, queryJ = 256, queryWidth = 512, queryHeight = 512, featureCount = 10;
        const layerIdsToTry = ["36048"];
        
        for (const layerId of layerIdsToTry) {
            const url = `https://nspd.gov.ru/api/aeggis/v4/${layerId}/wms?REQUEST=GetFeatureInfo&QUERY_LAYERS=${layerId}&SERVICE=WMS&VERSION=1.3.0&FORMAT=image%2Fpng%2F&STYLES=&TRANSPARENT=true&LAYERS=${layerId}&RANDOM=${Math.random()}&INFO_FORMAT=application%2Fjson&FEATURE_COUNT=${featureCount}&I=${queryI}&J=${queryJ}&WIDTH=${queryWidth}&HEIGHT=${queryHeight}&CRS=EPSG%3A3857&BBOX=${bbox}`;
            
            try {
                console.log(`Querying NSPD Layer ${layerId} (Попытка ${attempt + 1}/${MAX_RETRIES}) with BBOX: ${bbox} for coords: lat=${currentLat.toFixed(6)}, lon=${currentLon.toFixed(6)}`);
                const response = await fetch(url);
                if (!response.ok) {
                    const errorText = await response.text();
                    console.error(`NSPD GetFeatureInfo Error ${response.status} for layer ${layerId} (Попытка ${attempt + 1}). URL: ${url}. BBOX: ${bbox}. Response: ${errorText}`);
                    continue;
                }
                const data = await response.json();
                console.log(`NSPD GetFeatureInfo Response (layer ${layerId}, Попытка ${attempt + 1}):`, data);
                if (data && data.features && data.features.length > 0 && data.features[0].properties && data.features[0].properties.descr) {
                    const fullCadastralNumber = data.features[0].properties.descr;
                    const cnParts = fullCadastralNumber.split(':');
                    if (cnParts.length >= 3) {
                        console.log(`NSPD Успех на попытке ${attempt + 1} со слоем ${layerId}.`);
                        return cnParts.slice(0, 3).join(':'); 
                    } else {
                        console.warn("NSPD вернул кадастровый номер в неожиданном формате:", fullCadastralNumber);
                    }
                }
            } catch (error) {
                console.error(`Ошибка при запросе NSPD GetFeatureInfo для слоя ${layerId} (Попытка ${attempt + 1}):`, error, `BBOX: ${bbox}`);
            }
        }
        
        if (attempt < MAX_RETRIES - 1) {
            console.log(`NSPD Попытка ${attempt + 1} не удалась для всех слоев. Повторяем...`);
        }
    }

    console.warn("Квартал не найден после всех попыток  для исходного центроида:", originalLatitudeWGS, originalLongitudeWGS);
    return null; 
}


async function generateAndDownloadXML() {
    const coordsInputElement = document.getElementById('coordsInput');
    const inputText = coordsInputElement.value.trim();

    if (!inputText) {
        showNotification('Нет координат для определения квартала.');
        return;
    }
    
    if (typeof proj4 === 'undefined') {
        showNotification('Библиотека Proj4.js не загружена. Определение квартала невозможно.');
        console.error("Proj4 is not available.");
        return;
    }

    const aiLoader = document.getElementById('aiLoader');
    if (aiLoader) {
        aiLoader.querySelector('span').textContent = 'Определение кадастрового квартала...';
        aiLoader.style.display = 'flex';
    }

    const parsedGroups = parseMskCoordinatesForQuarter(inputText);

    if (parsedGroups.length === 0 || parsedGroups[0].length === 0) {
        showNotification("Не удалось распознать координаты МСК-16 из ввода.");
        if (aiLoader) aiLoader.style.display = 'none';
        return;
    }

    const firstGroupMSK = parsedGroups[0];
    let mskZoneToUse;
    let allWGS84CoordsInFirstGroup = [];

    const sampleMskPair = firstGroupMSK[0];
    const val1_sample = sampleMskPair[0];
    const val2_sample = sampleMskPair[1];

    if (val1_sample >= 2000000 && val1_sample < 3000000) { 
        mskZoneToUse = "MSK16_ZONE2";
    } else if (val1_sample >= 1000000 && val1_sample < 2000000) { 
        mskZoneToUse = "MSK16_ZONE1";
    } else if (val2_sample >= 2000000 && val2_sample < 3000000) { 
        mskZoneToUse = "MSK16_ZONE2";
    } else if (val2_sample >= 1000000 && val2_sample < 2000000) { 
        mskZoneToUse = "MSK16_ZONE1";
    } else {
        showNotification("Не удалось определить зону МСК-16. X должен быть 1xxxxxx или 2xxxxxx.");
        if (aiLoader) aiLoader.style.display = 'none';
        return;
    }
    console.log(`Determined MSK Zone for XML: ${mskZoneToUse}`);

    for (const mskPair of firstGroupMSK) {
        let currentMskX, currentMskY;
        if (mskZoneToUse === "MSK16_ZONE2") {
            currentMskX = (mskPair[0] >= 2000000 && mskPair[0] < 3000000) ? mskPair[0] : mskPair[1];
            currentMskY = (mskPair[0] >= 2000000 && mskPair[0] < 3000000) ? mskPair[1] : mskPair[0];
        } else { 
            currentMskX = (mskPair[0] >= 1000000 && mskPair[0] < 2000000) ? mskPair[0] : mskPair[1];
            currentMskY = (mskPair[0] >= 1000000 && mskPair[0] < 2000000) ? mskPair[1] : mskPair[0];
        }
        const wgs84Point = convertMSKToWGS84([currentMskX, currentMskY], mskZoneToUse);
        if (wgs84Point) {
            allWGS84CoordsInFirstGroup.push(wgs84Point);
        } else {
            if (aiLoader) aiLoader.style.display = 'none';
            return; 
        }
    }
    
    if (allWGS84CoordsInFirstGroup.length === 0) {
        showNotification("Ошибка конвертации координат МСК в WGS84.");
        if (aiLoader) aiLoader.style.display = 'none';
        return;
    }

    const centroidWGS84 = calculateCentroidWGS84(allWGS84CoordsInFirstGroup);
    if (!centroidWGS84) {
        showNotification("Не удалось рассчитать центроид для определения квартала.");
        if (aiLoader) aiLoader.style.display = 'none';
        return;
    }

    const quarterNumber = await queryNSPDForQuarter(centroidWGS84[0], centroidWGS84[1]);

    if (aiLoader) aiLoader.style.display = 'none';

    if (quarterNumber) {
        const textToCopy = `${quarterNumber}\n${inputText}`;
        try {
            await navigator.clipboard.writeText(textToCopy);
            showNotification(`Квартал ${quarterNumber} и координаты скопированы.`);
            window.open('схема_xml.html', '_blank');
        } catch (err) {
            console.error('Ошибка копирования в буфер обмена:', err);
            showNotification('Ошибка копирования. Квартал: ' + quarterNumber);
        }
    } else {
        // Измененное сообщение
        showNotification('Не удалось определить кадастровый квартал. Попробуйте другие координаты или проверьте их корректность.');
    }
}


   function getRandomColor() {
    // ИСПРАВЛЕНО: Добавлены недостающие цифры '2' и '3' и убран дубликат '1'
    const letters = '0123456789ABCDEF'; 
    let color = '#';
    for (let i = 0; i < 6; i++) {
        color += letters[Math.floor(Math.random() * 16)];
    }
    return color;
}

        function setRandomButtonColors() {
            const buttons = document.querySelectorAll('button');
            buttons.forEach(button => {
                const randomColor = getRandomColor();
                button.style.backgroundColor = randomColor;
                button.style.color = getContrastYIQ(randomColor);
            });
        }

        function getContrastYIQ(hexcolor) {
            hexcolor = hexcolor.replace('#', '');
            const r = parseInt(hexcolor.substr(0, 2), 16);
            const g = parseInt(hexcolor.substr(2, 2), 16);
            const b = parseInt(hexcolor.substr(4, 4), 16);
            const yiq = ((r * 299) + (g * 587) + (b * 114)) / 1000;
            return (yiq >= 128) ? 'black' : 'white';
        }

        function addIconsToButtons() {
            const buttons = document.querySelectorAll('button');
            buttons.forEach(button => {
                const icon = document.createElement('i');
                icon.className = 'icon';
    
                button.insertBefore(icon, button.firstChild);
            });
        }
        
        function showCropModalScheme(imageFile) {
    return new Promise((resolve) => {
        cropModalResolveScheme = resolve;
        const modal = document.getElementById('crop-image-modal-scheme');
        const imgPreview = document.getElementById('crop-image-preview-scheme');
        const cropContainer = document.getElementById('crop-image-container-scheme');
        const selectionRectDiv = document.getElementById('crop-selection-rectangle-scheme');
        const confirmButton = document.getElementById('crop-image-button-confirm-scheme');
        const cancelButton = document.getElementById('crop-image-button-cancel-scheme');

        selectionRectDiv.style.display = 'none';
        cropSelectionScheme.isDrawing = false;

        const reader = new FileReader();
        reader.onload = function(e) {
            imgPreview.src = e.target.result;
            modal.style.display = 'flex';

            imgPreview.onload = () => {
                imageNaturalSizeScheme.width = imgPreview.naturalWidth;
                imageNaturalSizeScheme.height = imgPreview.naturalHeight;

                const modalContentWrapper = modal.querySelector('.crop-modal-content-wrapper-scheme');
                const containerPadding = 40;
                const buttonsAndTextHeight = 120;

                imgPreview.style.maxWidth = `calc(${modalContentWrapper.clientWidth - containerPadding}px - 2px)`;
                imgPreview.style.maxHeight = `calc(${modalContentWrapper.clientHeight - containerPadding - buttonsAndTextHeight}px - 2px)`;

                requestAnimationFrame(() => {
                    imageDisplaySizeScheme.width = imgPreview.offsetWidth;
                    imageDisplaySizeScheme.height = imgPreview.offsetHeight;
                });
            };
        };
        reader.readAsDataURL(imageFile);

        function updateSelectionRectScheme() {
            const x = Math.min(cropSelectionScheme.startX, cropSelectionScheme.endX);
            const y = Math.min(cropSelectionScheme.startY, cropSelectionScheme.endY);
            const width = Math.abs(cropSelectionScheme.endX - cropSelectionScheme.startX);
            const height = Math.abs(cropSelectionScheme.endY - cropSelectionScheme.startY);
            selectionRectDiv.style.left = `${x}px`;
            selectionRectDiv.style.top = `${y}px`;
            selectionRectDiv.style.width = `${width}px`;
            selectionRectDiv.style.height = `${height}px`;
        }

        function getMousePosScheme(event) {
            const rect = cropContainer.getBoundingClientRect();
            let x = event.clientX - rect.left;
            let y = event.clientY - rect.top;
            x = Math.max(0, Math.min(x, imageDisplaySizeScheme.width));
            y = Math.max(0, Math.min(y, imageDisplaySizeScheme.height));
            return { x, y };
        }

        const onMouseDownScheme = (e) => {
            e.preventDefault();
            if (e.button !== 0 && e.type === 'mousedown') return;
            cropSelectionScheme.isDrawing = true;
            const pos = getMousePosScheme(e.touches ? e.touches[0] : e);
            cropSelectionScheme.startX = pos.x;
            cropSelectionScheme.startY = pos.y;
            cropSelectionScheme.endX = pos.x;
            cropSelectionScheme.endY = pos.y;
            selectionRectDiv.style.width = '0px';
            selectionRectDiv.style.height = '0px';
            selectionRectDiv.style.left = `${pos.x}px`;
            selectionRectDiv.style.top = `${pos.y}px`;
            selectionRectDiv.style.display = 'block';
            cropContainer.addEventListener('mousemove', onMouseMoveScheme);
            cropContainer.addEventListener('touchmove', onMouseMoveScheme, { passive: false });
            window.addEventListener('mouseup', onMouseUpScheme);
            window.addEventListener('touchend', onMouseUpScheme);
        };

        const onMouseMoveScheme = (e) => {
            if (!cropSelectionScheme.isDrawing) return;
            e.preventDefault();
            const pos = getMousePosScheme(e.touches ? e.touches[0] : e);
            cropSelectionScheme.endX = pos.x;
            cropSelectionScheme.endY = pos.y;
            updateSelectionRectScheme();
        };

        const onMouseUpScheme = () => {
            if (!cropSelectionScheme.isDrawing) return;
            cropSelectionScheme.isDrawing = false;
            cropContainer.removeEventListener('mousemove', onMouseMoveScheme);
            cropContainer.removeEventListener('touchmove', onMouseMoveScheme);
            window.removeEventListener('mouseup', onMouseUpScheme);
            window.removeEventListener('touchend', onMouseUpScheme);
            const width = Math.abs(cropSelectionScheme.endX - cropSelectionScheme.startX);
            const height = Math.abs(cropSelectionScheme.endY - cropSelectionScheme.startY);
            if (width < 5 || height < 5) {
                selectionRectDiv.style.display = 'none';
            }
        };

        cropContainer.addEventListener('mousedown', onMouseDownScheme);
        cropContainer.addEventListener('touchstart', onMouseDownScheme, { passive: false });

        const handleConfirmScheme = () => {
            const selWidth = Math.abs(cropSelectionScheme.endX - cropSelectionScheme.startX);
            const selHeight = Math.abs(cropSelectionScheme.endY - cropSelectionScheme.startY);
            if (selWidth < 5 || selHeight < 5 || selectionRectDiv.style.display === 'none') {
                fileToBase64(imageFile).then(base64 => cropModalResolveScheme({
                    cropped: false, data: base64.split(',')[1]
                }));
                cleanupModalScheme();
                return;
            }
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            const scaleX = imageNaturalSizeScheme.width / imageDisplaySizeScheme.width;
            const scaleY = imageNaturalSizeScheme.height / imageDisplaySizeScheme.height;
            const sX = Math.min(cropSelectionScheme.startX, cropSelectionScheme.endX) * scaleX;
            const sY = Math.min(cropSelectionScheme.startY, cropSelectionScheme.endY) * scaleY;
            const sWidth = selWidth * scaleX;
            const sHeight = selHeight * scaleY;
            canvas.width = sWidth;
            canvas.height = sHeight;
            ctx.drawImage(imgPreview, sX, sY, sWidth, sHeight, 0, 0, sWidth, sHeight);
            const croppedImageDataUrl = canvas.toDataURL(imageFile.type);
            cropModalResolveScheme({ cropped: true, data: croppedImageDataUrl.split(',')[1] });
            cleanupModalScheme();
        };

        const handleCancelScheme = () => {
            fileToBase64(imageFile).then(base64 => cropModalResolveScheme({
                cropped: false, data: base64.split(',')[1]
            }));
            cleanupModalScheme();
        };

        confirmButton.removeEventListener('click', handleConfirmScheme);
        confirmButton.addEventListener('click', handleConfirmScheme);
        cancelButton.removeEventListener('click', handleCancelScheme);
        cancelButton.addEventListener('click', handleCancelScheme);

        function cleanupModalScheme() {
            modal.style.display = 'none';
            imgPreview.src = '#';
            imgPreview.onload = null;
            cropContainer.removeEventListener('mousedown', onMouseDownScheme);
            cropContainer.removeEventListener('touchstart', onMouseDownScheme);
            // ... (удаление остальных обработчиков, как в вашем предыдущем коде, но с суффиксом Scheme)
            cropContainer.removeEventListener('mousemove', onMouseMoveScheme);
            cropContainer.removeEventListener('touchmove', onMouseMoveScheme);
            window.removeEventListener('mouseup', onMouseUpScheme);
            window.removeEventListener('touchend', onMouseUpScheme);
            confirmButton.onclick = null;
            cancelButton.onclick = null;
            cropModalResolveScheme = null;
        }
    });
}

        
        
        
        async function checkClipboardOnLoad() {
    try {
        // Пытаемся прочитать текст из буфера обмена
        // Важно: Это может потребовать разрешения пользователя или не сработать
        // в некоторых браузерах/контекстах без явного действия пользователя.
        let clipboardText = await navigator.clipboard.readText(); // Changed to let

        if (!clipboardText) {
            console.log("Буфер обмена пуст.");
            return;
        }

        // START OF CHANGE
        // Заменяем все запятые на точки в тексте из буфера обмена
        clipboardText = clipboardText.replace(/,/g, '.');
        // END OF CHANGE

        const lines = clipboardText.trim().split('\n');
        if (lines.length === 0) {
            console.log("Содержимое буфера обмена не содержит строк после очистки.");
            return;
        }

        const firstLine = lines[0].trim();

        // Регулярное выражение для поиска двух чисел (возможно, с десятичной точкой),
        // разделенных одним или несколькими пробелами или табуляцией.
        // Учитывает возможные пробелы в начале/конце строки.
        const coordRegex = /^\s*(\d+(?:\.\d+)?)\s+(\d+(?:\.\d+)?)\s*$/; // Already handles periods
        const match = firstLine.match(coordRegex);

        if (match) {
            // Извлекаем числа и проверяем, похожи ли они на координаты
            const num1 = parseFloat(match[1]); // No need to replace comma here anymore
            const num2 = parseFloat(match[2]); // No need to replace comma here anymore

            // Используем порог, аналогичный логике handleInput
            // (числа должны быть достаточно большими)
            const isLikelyCoords = !isNaN(num1) && !isNaN(num2) &&
                                   Math.abs(num1) >= 10000 && Math.abs(num2) >= 10000;

            if (isLikelyCoords) {
                console.log("Содержимое буфера обмена похоже на координаты, выполняется вставка.");
                const coordsInput = document.getElementById('coordsInput');

                // Вставляем только если поле ввода пустое, чтобы не перезаписать введенные вручную данные
                if (coordsInput.value.trim() === '') {
                     coordsInput.value = clipboardText; // clipboardText now has periods instead of commas
                     handleInput(true); // Обрабатываем вставленное содержимое
                     showNotification('Координаты вставлены из буфера обмена');
                } else {
                     console.log("Поле ввода не пустое, вставка из буфера обмена пропущена.");
                }
            } else {
                console.log("Первая строка совпала с шаблоном чисел, но числа не похожи на типовые координаты:", num1, num2);
            }
        } else {
            console.log("Первая строка буфера обмена не соответствует шаблону координат:", firstLine);
        }

    } catch (err) {
        console.error('Не удалось прочитать содержимое буфера обмена: ', err);
        // Можно уведомить пользователя, но лучше не назойливо, если проблема в разрешениях
        // showNotification('Не удалось прочитать буфер обмена. Возможно, требуется разрешение.');
    }
}





   document.addEventListener('DOMContentLoaded', () => {
    // 1. Кэшируем основные DOM-элементы по их новым и старым ID
    const coordsInput = document.getElementById('coordsInput');
    const swapSourceBtn = document.getElementById('swapSourceBtn');
    const copySourceBtn = document.getElementById('copySourceBtn');
    const makeFirstBtn = document.getElementById('makeFirstBtn');
    const vSwapSourceBtn = document.getElementById('vSwapSourceBtn');
    const pasteBtn = document.getElementById('pasteFromClipboardBtn'); // Новая кнопка
    const importButton = document.getElementById('importButton');
    const schemeButton = document.getElementById('schemeButton');
    const schemeMenu = document.getElementById('schemeMenu');
    const expandMenuItem = document.getElementById('expandLinearObject');
       const linearFromAreaItem = document.getElementById('linearFromArea');
    const widthDialogElement = document.getElementById('widthDialog');
    const applyWidthBtn = document.getElementById('applyWidth');
    const cancelWidthBtn = document.getElementById('cancelWidth');
    const addCoordsButton = document.getElementById('addCoordinatesFromClipboard');
    const addImageButton = document.getElementById('addImageAndRecognize');
    const addToDrawingElement = document.getElementById('addToDrawing');
       const addByCadastralNumberBtn = document.getElementById('addByCadastralNumber');
    const cadastralModal = document.getElementById('cadastralModal');
    const cadastralInput = document.getElementById('cadastralInputModal');
    const cadastralOkBtn = document.getElementById('cadastralOkBtn');
    const cadastralCancelBtn = document.getElementById('cadastralCancelBtn');
       const separateContoursBtn = document.getElementById('separateContoursBtn'); // Находим новую кнопку
       
        if (separateContoursBtn) separateContoursBtn.addEventListener('click', separateContoursByClosingPoints); 
        
    const canvasEl = document.getElementById('canvas');
    
       const exportDxfMinButton = document.getElementById('exportDxfMin');
    if (exportDxfMinButton) {
        exportDxfMinButton.addEventListener('click', generateAndDownloadDXFmin);
    }
    
      const exportDxfAC1009Button = document.getElementById('exportDxfAC1009');
    if (exportDxfAC1009Button) {
        exportDxfAC1009Button.addEventListener('click', generateAndDownloadDxfAC1009);
    }

    // 2. Назначаем обработчики событий для элементов управления textarea
    if (coordsInput) {
        if (swapSourceBtn) swapSourceBtn.addEventListener('click', () => swapTextareaColumns(coordsInput));
        if (copySourceBtn) copySourceBtn.addEventListener('click', () => copyTextarea(coordsInput));
        if (makeFirstBtn) makeFirstBtn.addEventListener('click', makeCurrentLineFirst);
        if (vSwapSourceBtn) vSwapSourceBtn.addEventListener('click', () => vSwapTextarea(coordsInput));
        if (pasteBtn) pasteBtn.addEventListener('click', () => handlePasteBtnClick(pasteBtn)); // Обработчик для новой кнопки
        
        coordsInput.addEventListener('click', handleTextareaClick);
        coordsInput.addEventListener('paste', handleTextareaPaste); // Ваш оригинальный обработчик paste
    }

    // 3. Назначаем обработчики для плавающих кнопок и меню (ИСПРАВЛЕННАЯ ЛОГИКА)

 coordsInput.addEventListener('keyup', (event) => {
        if (event.key === 'Enter') {
            // Задержка в 1 миллисекунду, чтобы браузер успел обработать
            // перенос строки перед перерисовкой. Это решает возможные
            // проблемы с гонкой состояний.
            setTimeout(() => {
                handleInput(true);
            }, 1);
        }
    });


if (schemeButton && schemeMenu) {
    // --- Обработчик для клика по самой кнопке ---
    schemeButton.addEventListener('click', (event) => {
        // Останавливаем "всплытие" клика, чтобы он не попал в обработчик документа
        event.stopPropagation();
        // Переключаем CSS-класс 'is-active', который отвечает за видимость меню
        schemeMenu.classList.toggle('is-active');
    });

    // --- Обработчик для клика в любом месте страницы (чтобы закрыть меню) ---
    document.addEventListener('click', (event) => {
        // Проверяем, активно ли меню, по наличию класса
        if (schemeMenu.classList.contains('is-active')) {
            // Прячем меню, только если клик был НЕ по самой кнопке И НЕ внутри меню
            if (!schemeButton.contains(event.target) && !schemeMenu.contains(event.target)) {
                schemeMenu.classList.remove('is-active');
            }
        }
    });
}


 if (linearFromAreaItem) {
        linearFromAreaItem.addEventListener('click', convertAreaToLinear);
    }
    

    // 4. Назначаем обработчики для пунктов меню и диалоговых окон
    if (expandMenuItem && widthDialogElement) {
        expandMenuItem.addEventListener('click', () => {
            const widthInput = document.getElementById('widthInput');
            if (widthInput) widthInput.value = "0.05";
            widthDialogElement.style.display = 'block';
            if (schemeMenu) schemeMenu.style.display = 'none';
        });
    }
    if (applyWidthBtn) {
        applyWidthBtn.addEventListener('click', () => {
            const widthInput = document.getElementById('widthInput');
            const width = parseFloat(widthInput.value);
            if (isNaN(width) || width <= 0) {
                alert('Пожалуйста, введите положительное число для ширины.');
                return;
            }
            expandLinearObjectToArea(width);
            if (widthDialogElement) widthDialogElement.style.display = 'none';
        });
    }
    
   
    if (cancelWidthBtn && widthDialogElement) {
        cancelWidthBtn.addEventListener('click', () => {
            widthDialogElement.style.display = 'none';
        });
    }
    if (addCoordsButton) addCoordsButton.addEventListener('click', appendCoordinatesFromClipboard);
    if (addImageButton) addImageButton.addEventListener('click', appendImageFromClipboard);
    if (addToDrawingElement) {
        addToDrawingElement.addEventListener('click', () => {
            importFile(true); // true = добавлять к существующим
            if (schemeMenu) schemeMenu.style.display = 'none';
        });
    }

 if (addByCadastralNumberBtn) {
        addByCadastralNumberBtn.addEventListener('click', handleAddByCadastralNumber);
    }

    if (cadastralModal && cadastralInput && cadastralOkBtn && cadastralCancelBtn) {
        cadastralInput.addEventListener('input', () => formatCadastralNumberInput(cadastralInput));
        cadastralInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') cadastralOkBtn.click();
        });
        cadastralOkBtn.addEventListener('click', processAddByCadastralNumber);
        cadastralCancelBtn.addEventListener('click', () => {
            cadastralModal.style.display = 'none';
        });
    }

  // --- НАЧАЛО: ИСПРАВЛЕННЫЙ обработчик двойного клика на canvas ---
if (canvasEl) {
       canvasEl.addEventListener('click', handleCanvasClick);
    canvasEl.addEventListener('dblclick', () => {
        const input = document.getElementById('coordsInput').value.trim();
        const contoursData = input.split('\n\n').filter(contour => contour.trim() !== '');

        if (contoursData.length === 0) {
            showNotification('Нет данных для отображения в новом окне.');
            return;
        }

        const contoursJSON = JSON.stringify(contoursData);
        
        const displayConfig = {
            showLabels: showLabels,
            showPoints: showPoints,
            showDistances: showDistances
        };
        const configJSON = JSON.stringify(displayConfig);

        // Самодостаточная функция отрисовки
        const drawingFunctionString = `
            function drawInNewWindow(canvasId, contours, config) {
                const canvas = document.getElementById(canvasId);
                const ctx = canvas.getContext('2d');

                function draw() {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    ctx.fillStyle = "white";
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    
                    if (!contours || contours.length === 0) return;

                    const allPoints = contours.flatMap(contour => 
                        contour.split('\\n').map(coord => {
                            const parts = coord.split(/\\s+|\\t/);
                            if (parts.length < 2) return null;
                            return [parseFloat(String(parts[0]).replace(",", ".")), parseFloat(String(parts[1]).replace(",", "."))];
                        }).filter(p => p !== null && !isNaN(p[0]) && !isNaN(p[1]))
                    );

                    if (allPoints.length === 0) return;

                    const minX = Math.min(...allPoints.map(p => p[0]));
                    const minY = Math.min(...allPoints.map(p => p[1]));
                    const maxX = Math.max(...allPoints.map(p => p[0]));
                    const maxY = Math.max(...allPoints.map(p => p[1]));
                    
                    const padding = 50;
                    const scaleX = (canvas.width - padding * 2) / (maxY - minY);
                    const scaleY = (canvas.height - padding * 2) / (maxX - minX);
                    const scale = Math.min(scaleX, scaleY) * 0.9;
                    const offsetX = (canvas.width - (maxY - minY) * scale) / 2;
                    const offsetY = (canvas.height - (maxX - minX) * scale) / 2;

                    contours.forEach((contour, contourIndex) => {
                        const points = contour.split('\\n').map(coord => {
                             const parts = coord.split(/\\s+|\\t/);
                             if (parts.length < 2) return null;
                             return [parseFloat(String(parts[0]).replace(",", ".")), parseFloat(String(parts[1]).replace(",", "."))];
                        }).filter(p => p !== null && !isNaN(p[0]) && !isNaN(p[1]));

                        if (points.length === 0) return;

                        const isClosed = points.length > 2 && Math.abs(points[0][0] - points[points.length - 1][0]) < 0.01 && Math.abs(points[0][1] - points[points.length - 1][1]) < 0.01;
                        
                        ctx.beginPath();
                        ctx.strokeStyle = "black";
                        ctx.lineWidth = 1.5;
                        points.forEach(([x, y], index) => {
                            const canvasX = offsetX + (y - minY) * scale;
                            const canvasY = canvas.height - (offsetY + (x - minX) * scale);
                            if (index === 0) ctx.moveTo(canvasX, canvasY);
                            else ctx.lineTo(canvasX, canvasY);
                        });
                        if (isClosed) ctx.closePath();
                        ctx.stroke();

                        points.forEach(([x, y], index) => {
                            const canvasX = offsetX + (y - minY) * scale;
                            const canvasY = canvas.height - (offsetY + (x - minX) * scale);
                            
                            if (config.showPoints) {
                                ctx.beginPath();
                                ctx.fillStyle = "red";
                                ctx.arc(canvasX, canvasY, 3, 0, 2 * Math.PI);
                                ctx.fill();
                            }
                            
                            if (config.showLabels) {
                                ctx.fillStyle = "black";
                                ctx.font = "14px Arial";
                                
                                // --- НАЧАЛО ИЗМЕНЕНИЯ ---
                                // Добавляем проверку для последней точки замкнутого контура
                                if (isClosed && index === points.length - 1) {
                                    // Если это последняя точка замкнутого контура, рисуем для нее номер первой точки
                                    ctx.fillText(\`\${contourIndex + 1}.1\`, canvasX + 5, canvasY - 5);
                                } else {
                                    // В противном случае рисуем обычный номер
                                    ctx.fillText(\`\${contourIndex + 1}.\${index + 1}\`, canvasX + 5, canvasY - 5);
                                }
                                // --- КОНЕЦ ИЗМЕНЕНИЯ ---
                            }
                        });

                        if (config.showDistances && points.length < 50) { 
                            ctx.font = "12px Arial";
                            ctx.fillStyle = "darkblue";
                            const segmentsToDraw = isClosed ? points.length : points.length - 1;
                            for (let i = 0; i < segmentsToDraw; i++) {
                                const [x1, y1] = points[i];
                                const [x2, y2] = points[(i + 1) % points.length];
                                const distance = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
                                if (distance > 0.01) {
                                    const canvasX1 = offsetX + (y1 - minY) * scale;
                                    const canvasY1 = canvas.height - (offsetY + (x1 - minX) * scale);
                                    const canvasX2 = offsetX + (y2 - minY) * scale;
                                    const canvasY2 = canvas.height - (offsetY + (x2 - minX) * scale);
                                    const midX = (canvasX1 + canvasX2) / 2;
                                    const midY = (canvasY1 + canvasY2) / 2;
                                    ctx.save();
                                    ctx.translate(midX, midY);
                                    let angle = Math.atan2(canvasY2 - canvasY1, canvasX2 - canvasX1);
                                    if (angle < -Math.PI / 2 || angle > Math.PI / 2) angle += Math.PI;
                                    ctx.rotate(angle);
                                    ctx.textAlign = "center";
                                    ctx.fillText(\`\${distance.toFixed(2)}\`, 0, -5);
                                    ctx.restore();
                                }
                            }
                        }
                    });
                }

                function resizeAndDraw() {
                    canvas.width = window.innerWidth;
                    canvas.height = window.innerHeight;
                    draw();
                }
                
                window.addEventListener('resize', resizeAndDraw);
                resizeAndDraw();
            }
        `;

        const newWindowHTML = `
            <!DOCTYPE html>
            <html>
            <head>
                <title>Чертеж</title>
                <style>
                    body, html { margin: 0; padding: 0; overflow: hidden; }
                    canvas { display: block; }
                </style>
            </head>
            <body>
                <canvas id="newCanvas"></canvas>
                <script>
                    ${drawingFunctionString}
                    const contours = ${contoursJSON};
                    const config = ${configJSON};
                    drawInNewWindow('newCanvas', contours, config);
                <\/script>
            </body>
            </html>
        `;

        const newWindow = window.open('', '_blank');
        newWindow.document.open();
        newWindow.document.write(newWindowHTML);
        newWindow.document.close();
    });
}
// --- КОНЕЦ: ИСПРАВЛЕННЫЙ обработчик двойного клика на canvas ---


    // 6. Инициализация всех систем при загрузке
    const gradients = ['linear-gradient(135deg, #a1c4fd 0%, #c2e9fb 100%)', 'linear-gradient(135deg, #fbc2eb 0%, #a6c1ee 100%)', 'linear-gradient(135deg, #84fab0 0%, #8fd3f4 100%)', 'linear-gradient(135deg, #f6d365 0%, #fda085 100%)'];
    const container = document.querySelector('.container');
    if(container) container.style.background = gradients[Math.floor(Math.random() * gradients.length)];

    // Важно: Вызываем все функции инициализации в конце
    initializeTooltips();
    initializeZoom();
    initializeTouchZoom();
    initializeEyeButton();
    checkClipboardOnLoad();
    handleInput();
     setRandomTextareaControlColors();
});

function cleanAndFormatAICoordinates(aiText) {
    if (!aiText || aiText.trim() === "") {
        return "";
    }

    const lines = aiText.trim().split('\n');
    const formattedCoords = [];

    for (const line of lines) {
        // ИЗМЕНЕНИЕ: Сделаем разделение более надежным.
        // Иногда ИИ может вернуть строку с литералами "\\t" вместо реального символа табуляции.
        // Новый регекс /\s+|\\t/ разделяет либо по одному или более пробельным символам (включая таб),
        // либо по последовательности символов обратный слеш + 't'.
        const parts = line.trim().split(/\s+|\\t/);
        
        if (parts.length === 2) {
            let x = parseFloat(parts[0].replace(',', '.'));
            let y = parseFloat(parts[1].replace(',', '.'));

            if (!isNaN(x) && !isNaN(y)) {
                if (x > y) {
                    [x, y] = [y, x];
                }
                formattedCoords.push(`${x.toFixed(2)}\t${y.toFixed(2)}`);
            }
        }
    }
    // ЛОГ для отладки, чтобы убедиться, что функция теперь работает.
    console.log("cleanAndFormatAICoordinates returning:", formattedCoords.join('\n'));
    return formattedCoords.join('\n');
}


function initializeEyeButton() {
    const eyeButton = document.getElementById('eyeButton');
    
    eyeButton.addEventListener('click', () => {
        eyeState = (eyeState + 1) % 7; // Изменяем на 7 состояний
        
        // Сбрасываем все флаги перед установкой нового состояния
        showLabels = true;
        showPoints = true;
        showRulers = true;
        showDistances = true;
        showContourNames = false; // Важно сбрасывать по умолчанию
        eyeButton.className = ''; // Сбрасываем классы

        switch(eyeState) {
            case 0: // Показать все (кроме названий контуров)
                // Все уже true, класс не нужен
                break;
            case 1: // Без номеров точек
                showLabels = false;
                eyeButton.className = 'no-labels';
                break;
            case 2: // Без красных точек
                showPoints = false;
                eyeButton.className = 'no-points';
                break;
            case 3: // Без расстояний
                showDistances = false;
                eyeButton.className = 'no-distances';
                break;
            case 4: // Только чертеж
                showLabels = false;
                showPoints = false;
                showRulers = false;
                showDistances = false;
                eyeButton.className = 'only-drawing';
                break;
            case 5: // Точки, чертеж, расстояния (без номеров)
                showLabels = false;
                eyeButton.className = 'points-distances-only';
                break;
            case 6: // Показать ВСЁ, включая НАЗВАНИЯ КОНТУРОВ
                showContourNames = true;
                eyeButton.className = 'with-names'; // Добавим новый класс для стилизации
                break;
        }

        drawContour(savedContours);
    });
}


function openEditor() {
    const coordsInput = document.getElementById('coordsInput');
    const coordinatesText = coordsInput.value;

    if (!coordinatesText.trim()) {
        showNotification('Нет координат для копирования в редактор.');
        return;
    }

    navigator.clipboard.writeText(coordinatesText).then(() => {
        showNotification('Координаты скопированы. Открываю редактор...');
        window.open('editor.html', '_blank');
    }).catch(err => {
        console.error('Не удалось скопировать координаты: ', err);
        showNotification('Ошибка при копировании координат для редактора.');
    });
}


function copyCoordsAndOpenAdjacentSchema() {
    const coordsInput = document.getElementById('coordsInput');
    const coordinatesText = coordsInput.value;

    if (!coordinatesText.trim()) {
        showNotification('Нет координат для копирования.');
        // Optionally, still open the link if that's desired behavior even without coords
        // window.open('схема_смежного_зу.html', '_blank');
        // document.getElementById('schemeMenu').style.display = 'none'; // Hide menu
        return;
    }

    navigator.clipboard.writeText(coordinatesText).then(() => {
        showNotification('Координаты скопированы. Открываю схему смежного ЗУ...');
        window.open('схема_смежного_зу.html', '_blank');
    }).catch(err => {
        console.error('Не удалось скопировать координаты: ', err);
        showNotification('Ошибка при копировании координат. Открываю схему...');
        window.open('схема_смежного_зу.html', '_blank'); // Open even if copy fails
    }).finally(() => {
        document.getElementById('schemeMenu').style.display = 'none'; // Hide menu
    });
}


function generateDXFmin(coords) {
    let dxfContent = `0\nSECTION\n2\nENTITIES\n`; // Минимальный заголовок

    let contours = [[]];
    let currentContourIndex = 0;
    coords.forEach(coord => {
        if (coord.trim() === '') {
            if (contours[currentContourIndex].length > 0) {
                currentContourIndex++;
                contours.push([]);
            }
        } else {
            const parts = coord.split(/\s+|\t/).map(Number);
            if (parts.length === 2 && !isNaN(parts[0]) && !isNaN(parts[1])) {
                contours[currentContourIndex].push(parts);
            }
        }
    });
    contours = contours.filter(contour => contour.length > 0);

    contours.forEach((contour) => {
        if (contour.length === 0) return;

        const isClosed = contour.length > 2 &&
            Math.abs(contour[0][0] - contour[contour.length - 1][0]) < 0.01 &&
            Math.abs(contour[0][1] - contour[contour.length - 1][1]) < 0.01;

        dxfContent += `0\nLWPOLYLINE\n`;
        dxfContent += `8\n0\n`; // Слой 0
        dxfContent += `100\nAcDbEntity\n`;
        dxfContent += `100\nAcDbPolyline\n`;
        dxfContent += `90\n${contour.length}\n`;
        dxfContent += `70\n${isClosed ? 1 : 0}\n`;

        contour.forEach(([x, y]) => {
            dxfContent += `10\n${y.toFixed(6)}\n`; // Y
            dxfContent += `20\n${x.toFixed(6)}\n`; // X
        });
    });

    dxfContent += `0\nENDSEC\n0\nEOF\n`;
    return dxfContent;
}

function generateAndDownloadDXFmin() {
    const input = document.getElementById('coordsInput').value;
    if (!input.trim()) {
        showNotification('Нет координат для экспорта');
        return;
    }
    const coords = input.split('\n');
    const dxfContent = generateDXFmin(coords);
    const blob = new Blob([dxfContent], { type: 'application/dxf' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'output_min.dxf';
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
    
    // Скрываем меню после действия
    const schemeMenu = document.getElementById('schemeMenu');
    if (schemeMenu) schemeMenu.classList.remove('is-active');
}



// --- НАЧАЛО: КОД ДЛЯ ГЕНЕРАЦИИ DXF AC1009 (ТОЛЬКО ГЕОМЕТРИЯ) ---

/**
 * Главная функция-обработчик для экспорта в DXF AC1009.
 */
function generateAndDownloadDxfAC1009() {
    const coordsInput = document.getElementById('coordsInput');
    const inputText = coordsInput.value.trim();

    if (!inputText) {
        showNotification('Нет координат для экспорта в DXF AC1009');
        return;
    }

    try {
        // 1. Парсим текст из textarea в массив контуров
        const contours = inputText.split('\n\n').map(contourStr =>
            contourStr.trim().split('\n').map(line => {
                const parts = line.split(/\s+|\t/);
                // Проверяем, что есть две части и они являются числами
                if (parts.length >= 2 && !isNaN(parseFloat(parts[0])) && !isNaN(parseFloat(parts[1]))) {
                    return {
                        x: parseFloat(parts[0]),
                        y: parseFloat(parts[1])
                    };
                }
                return null; // Возвращаем null для некорректных строк
            }).filter(p => p !== null) // Отфильтровываем некорректные
        ).filter(c => c.length > 0);

        if (contours.length === 0) {
            showNotification('Не удалось найти валидные контуры для экспорта.');
            return;
        }

        // 2. Генерируем DXF контент
        const dxfContent = generateDxfAC1009_GeometryOnly(contours);

        // 3. Скачиваем файл
        const blob = new Blob([dxfContent], { type: 'application/dxf' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'geometry_ac1009.dxf';
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);

    } catch (error) {
        console.error("Ошибка при экспорте в DXF AC1009:", error);
        showNotification(`Ошибка экспорта: ${error.message}`);
    } finally {
         // Скрываем меню после действия
        const schemeMenu = document.getElementById('schemeMenu');
        if (schemeMenu) schemeMenu.classList.remove('is-active');
    }
}


/**
 * Собирает DXF AC1009 из всех секций, содержащий только геометрию.
 * @param {Array<Array<{x: number, y: number}>>} contours - Массив контуров.
 * @returns {string} Готовый контент DXF файла.
 */
function generateDxfAC1009_GeometryOnly(contours) {
    const allPoints = contours.flat();
    const bbox = calculateBoundingBoxAC1009(allPoints);

    const header = generateHeaderSectionAC1009_GeomOnly(bbox);
    const tables = generateTablesSectionAC1009_GeomOnly();
    const blocks = `  0\nSECTION\n  2\nBLOCKS\n  0\nENDSEC`;
    const entities = generateEntitiesSectionAC1009_GeomOnly(contours);
    const eof = `  0\nEOF`;

    return [header, tables, blocks, entities, eof].join('\n');
}

/**
 * Вспомогательные функции для генерации каждой секции DXF AC1009.
 */
function calculateBoundingBoxAC1009(points) {
    if (!points || points.length === 0) {
        return { minX: 0, minY: 0, maxX: 0, maxY: 0 };
    }
    let minX = points[0].x, maxX = points[0].x;
    let minY = points[0].y, maxY = points[0].y;

    for (let i = 1; i < points.length; i++) {
        minX = Math.min(minX, points[i].x);
        maxX = Math.max(maxX, points[i].x);
        minY = Math.min(minY, points[i].y);
        maxY = Math.max(maxY, points[i].y);
    }
    return { minX, minY, maxX, maxY };
}

function generateHeaderSectionAC1009_GeomOnly(bbox) {
    return `  0
SECTION
  2
HEADER
  9
$ACADVER
  1
AC1009
  9
$EXTMIN
 10
${bbox.minX.toFixed(2)}
 20
${bbox.minY.toFixed(2)}
 30
0.0
  9
$EXTMAX
 10
${bbox.maxX.toFixed(2)}
 20
${bbox.maxY.toFixed(2)}
 30
0.0
  9
$LIMMIN
 10
${bbox.minX.toFixed(2)}
 20
${bbox.minY.toFixed(2)}
  9
$LIMMAX
 10
${bbox.maxX.toFixed(2)}
 20
${bbox.maxY.toFixed(2)}
  0
ENDSEC`;
}

function generateTablesSectionAC1009_GeomOnly() {
    return `  0
SECTION
  2
TABLES
  0
TABLE
  2
LTYPE
 70
     1
  0
LTYPE
  2
CONTINUOUS
 70
     0
  3
Solid line
 72
    65
 73
     0
 40
0.0
  0
ENDTAB
  0
TABLE
  2
LAYER
 70
     2
  0
LAYER
  2
0
 70
     0
 62
     7
  6
CONTINUOUS
  0
LAYER
  2
t
 70
     0
 62
     1
  6
CONTINUOUS
  0
ENDTAB
  0
ENDSEC`;
}

function generateEntitiesSectionAC1009_GeomOnly(contours) {
    let entities = `  0\nSECTION\n  2\nENTITIES`;

    contours.forEach(points => {
        // Проверяем, является ли контур замкнутым (площадным)
        const isClosed = points.length > 2 &&
                         Math.abs(points[0].x - points[points.length - 1].x) < 0.01 &&
                         Math.abs(points[0].y - points[points.length - 1].y) < 0.01;

        entities += `\n  0\nPOLYLINE\n  8\nt\n  6\nCONTINUOUS\n 62\n   256`;
        entities += `\n 70\n     ${isClosed ? 1 : 0}`;
        entities += `\n 75\n     5\n 66\n     1`;

        points.forEach(p => {
            // ИСПРАВЛЕНО: Код 10 = X, Код 20 = Y (БЕЗ ПЕРЕСТАНОВКИ!)
            entities += `\n  0\nVERTEX\n  8\nt\n 10\n${p.x.toFixed(2)}\n 20\n${p.y.toFixed(2)}\n 30\n0.0`;
        });
        
        entities += `\n  0\nSEQEND`;
    });
    
    entities += `\n  0\nENDSEC`;
    return entities;
}

// --- КОНЕЦ: КОД ДЛЯ ГЕНЕРАЦИИ DXF AC1009 (ТОЛЬКО ГЕОМЕТРИЯ) ---


function generateDXF(coords) {
    let dxfContent = '';
    
    // HEADER секция с полными настройками для AutoCAD 2000
    dxfContent += `0\nSECTION\n2\nHEADER\n`;
    dxfContent += `9\n$ACADVER\n1\nAC1015\n`; // AutoCAD 2000
    dxfContent += `9\n$HANDSEED\n5\nFFFF\n`;   // Начальное значение для handle
    dxfContent += `9\n$MEASUREMENT\n70\n1\n`;  // Метрическая система
    dxfContent += `0\nENDSEC\n`;

    // TABLES секция с обязательными таблицами
    dxfContent += `0\nSECTION\n2\nTABLES\n`;
    
    // Таблица VPORT (обязательная)
    dxfContent += `0\nTABLE\n2\nVPORT\n5\n8\n330\n0\n100\nAcDbSymbolTable\n70\n1\n`;
    dxfContent += `0\nVPORT\n5\n29\n330\n8\n100\nAcDbSymbolTableRecord\n100\nAcDbViewportTableRecord\n`;
    dxfContent += `2\n*ACTIVE\n70\n0\n10\n0.0\n20\n0.0\n11\n1.0\n21\n1.0\n12\n286.0\n22\n148.5\n`;
    dxfContent += `13\n0.0\n23\n0.0\n14\n10.0\n24\n10.0\n15\n10.0\n25\n10.0\n16\n0.0\n26\n0.0\n36\n1.0\n`;
    dxfContent += `17\n0.0\n27\n0.0\n37\n0.0\n40\n297.0\n41\n1.92798353909465\n42\n50.0\n43\n0.0\n44\n0.0\n`;
    dxfContent += `50\n0.0\n51\n0.0\n71\n0\n72\n100\n73\n1\n74\n3\n75\n0\n76\n1\n77\n0\n78\n0\n281\n0\n65\n1\n`;
    dxfContent += `110\n0.0\n120\n0.0\n130\n0.0\n111\n1.0\n121\n0.0\n131\n0.0\n112\n0.0\n122\n1.0\n132\n0.0\n`;
    dxfContent += `79\n0\n146\n0.0\n0\nENDTAB\n`;
    
    // Таблица LTYPE (типы линий)
    dxfContent += `0\nTABLE\n2\nLTYPE\n5\n5\n330\n0\n100\nAcDbSymbolTable\n70\n1\n`;
    dxfContent += `0\nLTYPE\n5\n14\n330\n5\n100\nAcDbSymbolTableRecord\n100\nAcDbLinetypeTableRecord\n`;
    dxfContent += `2\nBYLAYER\n70\n0\n3\n\n72\n65\n73\n0\n40\n0.0\n`;
    dxfContent += `0\nLTYPE\n5\n15\n330\n5\n100\nAcDbSymbolTableRecord\n100\nAcDbLinetypeTableRecord\n`;
    dxfContent += `2\nBYBLOCK\n70\n0\n3\n\n72\n65\n73\n0\n40\n0.0\n`;
    dxfContent += `0\nLTYPE\n5\n16\n330\n5\n100\nAcDbSymbolTableRecord\n100\nAcDbLinetypeTableRecord\n`;
    dxfContent += `2\nCONTINUOUS\n70\n0\n3\nSolid line\n72\n65\n73\n0\n40\n0.0\n`;
    dxfContent += `0\nENDTAB\n`;
    
    // Таблица LAYER (слои)
    dxfContent += `0\nTABLE\n2\nLAYER\n5\n2\n330\n0\n100\nAcDbSymbolTable\n70\n1\n`;
    dxfContent += `0\nLAYER\n5\n10\n330\n2\n100\nAcDbSymbolTableRecord\n100\nAcDbLayerTableRecord\n`;
    dxfContent += `2\n0\n70\n0\n62\n7\n6\nCONTINUOUS\n370\n0\n390\nF\n`;
    dxfContent += `0\nENDTAB\n`;
    
    // Таблица STYLE (стили текста)
    dxfContent += `0\nTABLE\n2\nSTYLE\n5\n3\n330\n0\n100\nAcDbSymbolTable\n70\n1\n`;
    dxfContent += `0\nSTYLE\n5\n11\n330\n3\n100\nAcDbSymbolTableRecord\n100\nAcDbTextStyleTableRecord\n`;
    dxfContent += `2\nSTANDARD\n70\n0\n40\n0.0\n41\n1.0\n50\n0.0\n71\n0\n42\n0.2\n3\ntxt\n4\n\n`;
    dxfContent += `0\nENDTAB\n`;
    
    // Таблица UCS
    dxfContent += `0\nTABLE\n2\nUCS\n5\n7\n330\n0\n100\nAcDbSymbolTable\n70\n0\n0\nENDTAB\n`;
    
    // Таблица APPID
    dxfContent += `0\nTABLE\n2\nAPPID\n5\n9\n330\n0\n100\nAcDbSymbolTable\n70\n1\n`;
    dxfContent += `0\nAPPID\n5\n12\n330\n9\n100\nAcDbSymbolTableRecord\n100\nAcDbRegAppTableRecord\n2\nACAD\n70\n0\n`;
    dxfContent += `0\nENDTAB\n`;
    
    // Таблица DIMSTYLE
    dxfContent += `0\nTABLE\n2\nDIMSTYLE\n5\nA\n330\n0\n100\nAcDbSymbolTable\n70\n1\n`;
    dxfContent += `0\nDIMSTYLE\n105\n27\n330\nA\n100\nAcDbSymbolTableRecord\n100\nAcDbDimStyleTableRecord\n`;
    dxfContent += `2\nSTANDARD\n70\n0\n41\n2.5\n42\n0.625\n43\n3.75\n44\n1.25\n73\n0\n74\n0\n77\n1\n78\n8\n`;
    dxfContent += `140\n2.5\n141\n2.5\n143\n0.04\n147\n0.625\n171\n3\n172\n1\n271\n2\n272\n2\n274\n3\n278\n44\n283\n0\n284\n8\n`;
    dxfContent += `0\nENDTAB\n`;
    
    // Таблица BLOCK_RECORD
    dxfContent += `0\nTABLE\n2\nBLOCK_RECORD\n5\n1\n330\n0\n100\nAcDbSymbolTable\n70\n1\n`;
    dxfContent += `0\nBLOCK_RECORD\n5\n1F\n330\n1\n100\nAcDbSymbolTableRecord\n100\nAcDbBlockTableRecord\n2\n*MODEL_SPACE\n370\n0\n`;
    dxfContent += `0\nBLOCK_RECORD\n5\n1B\n330\n1\n100\nAcDbSymbolTableRecord\n100\nAcDbBlockTableRecord\n2\n*PAPER_SPACE\n370\n0\n`;
    dxfContent += `0\nENDTAB\n`;
    
    dxfContent += `0\nENDSEC\n`;

    // BLOCKS секция
    dxfContent += `0\nSECTION\n2\nBLOCKS\n`;
    dxfContent += `0\nBLOCK\n5\n20\n330\n1F\n100\nAcDbEntity\n8\n0\n100\nAcDbBlockBegin\n2\n*MODEL_SPACE\n70\n0\n10\n0.0\n20\n0.0\n30\n0.0\n3\n*MODEL_SPACE\n1\n\n`;
    dxfContent += `0\nENDBLK\n5\n21\n330\n1F\n100\nAcDbEntity\n8\n0\n100\nAcDbBlockEnd\n`;
    dxfContent += `0\nBLOCK\n5\n1C\n330\n1B\n100\nAcDbEntity\n67\n1\n8\n0\n100\nAcDbBlockBegin\n2\n*PAPER_SPACE\n70\n0\n10\n0.0\n20\n0.0\n30\n0.0\n3\n*PAPER_SPACE\n1\n\n`;
    dxfContent += `0\nENDBLK\n5\n1D\n330\n1B\n100\nAcDbEntity\n67\n1\n8\n0\n100\nAcDbBlockEnd\n`;
    dxfContent += `0\nENDSEC\n`;

    // ENTITIES секция
    dxfContent += `0\nSECTION\n2\nENTITIES\n`;

    // Обработка координат
    let contours = [[]];
    let currentContourIndex = 0;
    let handleCounter = 100; // Начинаем с handle 100 для entity

    coords.forEach(coord => {
        if (coord.trim() === '') {
            if (contours[currentContourIndex].length > 0) {
                currentContourIndex++;
                contours.push([]);
            }
        } else {
            const parts = coord.split('\t').map(Number);
            if (parts.length === 2 && !isNaN(parts[0]) && !isNaN(parts[1])) {
                contours[currentContourIndex].push(parts);
            }
        }
    });

    // Удаляем пустые контуры
    contours = contours.filter(contour => contour.length > 0);

    // Создание полилиний
    contours.forEach((contour) => {
        if (contour.length < 2) return; // Пропускаем контуры с менее чем 2 точками
        
        const isClosed = contour.length > 2 && 
                        contour[0][0] === contour[contour.length - 1][0] && 
                        contour[0][1] === contour[contour.length - 1][1];

        dxfContent += `0\nLWPOLYLINE\n`;
        dxfContent += `5\n${handleCounter.toString(16).toUpperCase()}\n`; // Handle в hex
        dxfContent += `330\n1F\n`; // Владелец (MODEL_SPACE)
        dxfContent += `100\nAcDbEntity\n`;
        dxfContent += `8\n0\n`; // Слой
        dxfContent += `100\nAcDbPolyline\n`;
        dxfContent += `90\n${contour.length}\n`; // Количество вершин
        dxfContent += `70\n${isClosed ? 1 : 0}\n`; // Флаг замкнутости
        dxfContent += `43\n0.0\n`; // Постоянная ширина

        contour.forEach(([x, y]) => {
            dxfContent += `10\n${y.toFixed(6)}\n`; // Y координата с точностью
            dxfContent += `20\n${x.toFixed(6)}\n`; // X координата с точностью
        });

        handleCounter++;
    });

    dxfContent += `0\nENDSEC\n`;

    // OBJECTS секция (обязательная для AutoCAD 2000+)
    dxfContent += `0\nSECTION\n2\nOBJECTS\n`;
    dxfContent += `0\nDICTIONARY\n5\nC\n330\n0\n100\nAcDbDictionary\n281\n1\n3\nACAD_GROUP\n350\nD\n3\nACAD_MLINESTYLE\n350\n17\n`;
    dxfContent += `0\nDICTIONARY\n5\nD\n330\nC\n100\nAcDbDictionary\n281\n1\n`;
    dxfContent += `0\nDICTIONARY\n5\n17\n330\nC\n100\nAcDbDictionary\n281\n1\n3\nSTANDARD\n350\n18\n`;
    dxfContent += `0\nMLINESTYLE\n5\n18\n330\n17\n100\nAcDbMlineStyle\n2\nSTANDARD\n70\n0\n3\n\n62\n256\n51\n90.0\n52\n90.0\n71\n2\n49\n0.5\n62\n256\n6\nBYLAYER\n49\n-0.5\n62\n256\n6\nBYLAYER\n`;
    dxfContent += `0\nENDSEC\n`;

    dxfContent += `0\nEOF\n`;
    
    return dxfContent;
}


function separateContoursByClosingPoints() {
    const textarea = document.getElementById('coordsInput');
    const text = textarea.value;
    if (text.trim().length === 0) {
        showNotification('Поле ввода пустое');
        return;
    }

    const lines = text.split('\n');
    const processedLines = [];

    // Проходим по всем строкам
    for (let i = 0; i < lines.length; i++) {
        // Добавляем текущую строку в результат
        processedLines.push(lines[i]);

        const currentLine = lines[i].trim();
        
        // Пропускаем пустые строки
        if (currentLine === '') {
            continue;
        }

        // Ищем первое вхождение этой строки
        const firstOccurrenceIndex = lines.findIndex(line => line.trim() === currentLine);

        // Условия для добавления разделителя (пустой строки):
        // 1. Это не первое вхождение данной строки (firstOccurrenceIndex < i), что означает, что это замыкающая точка.
        // 2. Это не самая последняя строка в файле (i < lines.length - 1).
        if (firstOccurrenceIndex < i && i < lines.length - 1) {
            processedLines.push(''); // Добавляем пустую строку как разделитель
        }
    }

    // Обновляем текстовое поле и перерисовываем схему
    textarea.value = processedLines.join('\n');
    handleInput(true);
    showNotification('Координаты разделены на контуры');
}



function copyCoordinatesAndOpenMap() {
    const input = document.getElementById('coordsInput').value.trim();
    if (!input) {
        showNotification('Нет координат для копирования');
        return;
    }

    // Убираем .filter(), чтобы сохранить пустые строки
    const coords = input.split('\n');

    if (coords.length === 0) {
        showNotification('Не удалось извлечь координаты');
        return;
    }

    // Преобразуем координаты, СОХРАНЯЯ ПОРЯДОК X Y
    const formattedCoords = coords.map(coord => {
        const [x, y] = coord.split(/\s+/).map(Number);
        // Если x или y не являются числами (из-за пустой строки),
        // вернем пустую строку.  Это сохранит разделители контуров.
        if (isNaN(x) || isNaN(y)) {
          return '';  // Пустая строка вместо координат
        }
        // ИЗМЕНЕНИЕ: Порядок X Y сохранен
        return `${x}\t${y}`;
    }).join('\n');

    navigator.clipboard.writeText(formattedCoords).then(() => {
        showNotification('Координаты скопированы в буфер обмена');
        window.open('map.html', '_blank');
    }).catch(err => {
        console.error('Не удалось скопировать координаты: ', err);
        showNotification('Ошибка при копировании координат');
    });
}

function generateMIF(coords) {
    let mifContent = `Version 300\nCharset "WindowsCyrillic"\nDelimiter ","\nCoordSys NonEarth Units "m" Bounds (0, 0) (10000000, 10000000)\nColumns 2\n  X Decimal(15, 2)\n  Y Decimal(15, 2)\nData\n\n`;

    let contours = [[]];
    let currentContourIndex = 0;

    coords.forEach(coord => {
        if (coord.trim() === '') {
            if (contours[currentContourIndex].length > 0) {
                currentContourIndex++;
                contours.push([]);
            }
        } else {
            contours[currentContourIndex].push(coord.split('\t').map(Number));
        }
    });

    // Удаляем пустые контуры
    contours = contours.filter(contour => contour.length > 0);

    if (contours.length === 1) {
        // Один контур
        mifContent += `Region 1\n${contours[0].length}\n`;
        contours[0].forEach(([x, y]) => {
            mifContent += `${y} ${x}\n`;
        });
    } else {
        // Множество контуров
        mifContent += `Region ${contours.length}\n`;
        contours.forEach(contour => {
            mifContent += `${contour.length}\n`;
            contour.forEach(([x, y]) => {
                mifContent += `${y} ${x}\n`;
            });
        });
    }

    return mifContent;
}

function generateCSV(coords) {
    let csvContent = "Контур;Префикс номера;Номер;Старый X;Старый Y;Новый X;Новый Y;Метод определения;Формула;Радиус;Погрешность;Описание закрепления\n";
    csvContent += ";;;;;;;;;;;\n";

    let contourNumber = 1;
    let pointNumber = 1;
    let contour = [];

    coords.forEach((coord, index) => {
        if (coord.trim() === '') {
            // Завершаем текущий контур
            if (contour.length > 0) {
                csvContent += processContour(contour, contourNumber, pointNumber);
                contourNumber++;
                pointNumber = 1;
                contour = [];
                csvContent += ";;;;;;;;;;;\n"; // Пустая строка между контурами
            }
        } else {
            const [x, y] = coord.split(/\s+|\t/).map(Number);
            if (!isNaN(x) && !isNaN(y)) {
                contour.push([x, y]);
            } else {
                console.warn('Некорректные координаты:', coord);
            }
        }
    });

    // Обрабатываем последний контур, если он есть
    if (contour.length > 0) {
        csvContent += processContour(contour, contourNumber, pointNumber);
    }

    return csvContent;
}



function initializeZoom() {
    const canvas = document.getElementById('canvas');

    // Обработка колесика мыши для масштабирования
      canvas.addEventListener('wheel', function(e) {
        e.preventDefault();
        const rect = canvas.getBoundingClientRect();
        const mouseX = e.clientX - rect.left;
        const mouseY = e.clientY - rect.top;

        // Определяем направление прокрутки
        const delta = Math.sign(e.deltaY);
        const zoomFactor = delta > 0 ? 0.9 : 1.1;

        // Обновляем уровень масштабирования
        const oldZoom = zoomLevel;
        zoomLevel *= zoomFactor;
        zoomLevel = Math.min(Math.max(zoomLevel, 0.1), 10); // Ограничиваем масштаб

        // Корректируем позицию панорамирования для зума в точку мыши
        panX += (mouseX / oldZoom - mouseX / zoomLevel);
        panY += (mouseY / oldZoom - mouseY / zoomLevel);

        // Перерисовываем canvas
         drawContour(savedContours); // Перерисовываем с savedContours
    });
    
     // Обработка перетаскивания
    canvas.addEventListener('mousedown', function(e) {
        isDragging = true;
        lastX = e.clientX;
        lastY = e.clientY;
        canvas.style.cursor = 'grabbing';
    });

    canvas.addEventListener('mousemove', function(e) {
        if (isDragging) {
            const dx = e.clientX - lastX;
            const dy = e.clientY - lastY;
            
            panX += dx / zoomLevel;
            panY += dy / zoomLevel;

            lastX = e.clientX;
            lastY = e.clientY;

            drawContour(savedContours); // Перерисовываем с savedContours
        }
    });

    canvas.addEventListener('mouseup', function() {
        isDragging = false;
        canvas.style.cursor = 'grab';
    });

    canvas.addEventListener('mouseleave', function() {
        isDragging = false;
        canvas.style.cursor = 'grab';
    });
}

// Функции для кнопок масштабирования
// Функция для плавного масштабирования
function smoothZoom(targetZoom, duration = 300) {
    const startZoom = zoomLevel;
    const startTime = Date.now();
    
    function update() {
        const currentTime = Date.now();
        const elapsed = currentTime - startTime;
        const progress = Math.min(elapsed / duration, 1);
        
        // Функция плавности
        const easeOutCubic = progress => (1 - Math.pow(1 - progress, 3));
        
        zoomLevel = startZoom + (targetZoom - startZoom) * easeOutCubic(progress);
        drawContour(getCurrentCoordinates());
        
        if (progress < 1) {
            requestAnimationFrame(update);
        }
    }
    
    update();
}


function resetZoom() {
    smoothZoom(1, 300); // Сброс к исходному масштабу
    panX = 0;
    panY = 0;
    drawContour(getCurrentCoordinates());
}

// Добавьте обработку тачскрина для мобильных устройств
function initializeTouchZoom() {
    const canvas = document.getElementById('canvas');
    let initialDistance = 0;
    let initialZoom = 1;
    
    canvas.addEventListener('touchstart', function(e) {
        if (e.touches.length === 2) {
            initialDistance = Math.hypot(
                e.touches[0].clientX - e.touches[1].clientX,
                e.touches[0].clientY - e.touches[1].clientY
            );
            initialZoom = zoomLevel;
        }
    });

    canvas.addEventListener('touchmove', function(e) {
        if (e.touches.length === 2) {
            e.preventDefault();
            const currentDistance = Math.hypot(
                e.touches[0].clientX - e.touches[1].clientX,
                e.touches[0].clientY - e.touches[1].clientY
            );
            
            const scale = currentDistance / initialDistance;
            zoomLevel = Math.min(Math.max(initialZoom * scale, 0.1), 10);
            drawContour(savedContours);
        }
    });
}


// Обновленные функции зума
function zoomIn() {
    const targetZoom = Math.min(zoomLevel * 1.2, 10);
    smoothZoom(targetZoom);
}

function zoomOut() {
    const targetZoom = Math.max(zoomLevel * 0.8, 0.1);
    smoothZoom(targetZoom);
}


let savedContours = []; // Добавляем переменную для сохранения контуров


    function swapTextareaColumns(textarea) {
            const text = textarea.value;
            if (!text) return;
            const lines = text.split('\n');
            const swappedLines = lines.map(line => {
                const parts = line.trim().split(/\s+|\t/);
                if (parts.length === 2 && !isNaN(parseFloat(parts[0].replace(',', '.'))) && !isNaN(parseFloat(parts[1].replace(',', '.')))) {
                    return `${parts[1]}\t${parts[0]}`;
                }
                return line;
            });
            textarea.value = swappedLines.join('\n');
            handleInput(true); // Обновить чертеж
        }

        function vSwapTextarea(textarea) {
            const text = textarea.value;
            if (!text) return;
            const lines = text.split('\n');
            textarea.value = lines.reverse().join('\n');
            handleInput(true); // Обновить чертеж
        }

        function copyTextarea(textarea) {
            navigator.clipboard.writeText(textarea.value).then(() => {
                showNotification('Координаты скопированы');
            }).catch(err => {
                console.error('Ошибка копирования:', err);
                showNotification('Ошибка при копировании');
            });
        }
        

async function handleInput(showNotifications = false, isAIRetry = false) {
      savedContourNames = []; // Очищаем названия, т.к. источник - текст
    const inputElement = document.getElementById('coordsInput');
    let inputText = inputElement.value;
    console.log("--- Starting handleInput ---");
    console.log("handleInput: isAIRetry =", isAIRetry);

    if (inputText.trim() === '') {
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        canvas.style.display = 'none';
        document.getElementById('log').innerHTML = '';
      const startWrapper = document.getElementById('start-point-wrapper');
const endWrapper = document.getElementById('end-point-wrapper');
const actionsWrapper = document.querySelector('.combo-box-actions');
if(startWrapper) startWrapper.innerHTML = '';
if(endWrapper) endWrapper.innerHTML = '';
if(actionsWrapper) actionsWrapper.innerHTML = '';
        savedContours = [];
        console.log("handleInput: Input is empty, clearing.");
        console.log("--- Ending handleInput ---");
        return;
    }

    let coordinates = [];
    let extractionMethod = "None";
    let localParsingSucceeded = false;

    if (!isAIRetry) { // Локальный парсинг только если это не повторный вызов после AI
        console.log("handleInput: Trying extractCoordinatesEntitySpatial...");
        coordinates = extractCoordinatesEntitySpatial(inputText);
        if (coordinates.length > 0) {
            extractionMethod = "EntitySpatial";
        } else {
            console.log("handleInput: Trying extractCoordinatesNewContour...");
            coordinates = extractCoordinatesNewContour(inputText);
            if (coordinates.length > 0) {
                extractionMethod = "NewContour";
            } else {
                console.log("handleInput: Trying searchInTabs...");
                coordinates = searchInTabs(inputText);
                if (coordinates.length > 0) {
                    extractionMethod = "SearchInTabs";
                } else {
                    console.log("handleInput: Trying standard split (X Y format)...");
                    coordinates = inputText.split('\n').map(line => {
                        line = line.trim();
                        if (line === '') return '';
                        const parts = line.split(/\s+|\t/);
                        if (parts.length >= 2) {
                            const xStr = parts[0].replace(',', '.');
                            const yStr = parts[1].replace(',', '.');
                            const x = parseFloat(xStr);
                            const y = parseFloat(yStr);
                            if (!isNaN(x) && !isNaN(y) && Math.abs(x) >= 10000 && Math.abs(y) >= 10000) {
                                return `${x.toFixed(2)}\t${y.toFixed(2)}`;
                            }
                        }
                        return null;
                    }).filter(coord => coord !== null);

                    if (coordinates.length > 0) {
                        extractionMethod = "StandardSplit";
                    } else {
                        console.log("handleInput: Trying importGeo...");
                        coordinates = importGeo(inputText);
                        if (coordinates.length > 0) {
                            extractionMethod = "ImportGeo";
                        } else {
                            console.log("handleInput: Trying extractCoordinatesFromTextWithDescription...");
                            coordinates = extractCoordinatesFromTextWithDescription(inputText);
                            if (coordinates.length > 0) {
                                extractionMethod = "TextWithDescription";
                            } else {
                                console.log("handleInput: Trying extractCoordinatesFromSpelementUnit...");
                                coordinates = extractCoordinatesFromSpelementUnit(inputText);
                                if (coordinates.length > 0) {
                                    extractionMethod = "SpelementUnit";
                                } else {
                                    console.log("handleInput: Trying extractSingleNumberPerLine...");
                                    coordinates = extractSingleNumberPerLine(inputText);
                                    if (coordinates.length > 0) {
                                        extractionMethod = "SingleNumberPerLine";
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        
        localParsingSucceeded = coordinates.some(c => typeof c === 'string' && c.trim() !== '');
    }


    if (localParsingSucceeded) {
        console.log(`handleInput: Coordinates found using local method: ${extractionMethod}. Total items (coords + separators): ${coordinates.length}`);
        let cleanedCoordinates = [];
        let lastWasEmpty = true;
        for (const coord of coordinates) {
            const isEmpty = typeof coord === 'string' && coord.trim() === '';
            if (!isEmpty) {
                cleanedCoordinates.push(coord);
                lastWasEmpty = false;
            } else if (!lastWasEmpty) {
                cleanedCoordinates.push('');
                lastWasEmpty = true;
            }
        }
        if (cleanedCoordinates.length > 0 && typeof cleanedCoordinates[cleanedCoordinates.length - 1] === 'string' && cleanedCoordinates[cleanedCoordinates.length - 1].trim() === '') {
            cleanedCoordinates.pop();
        }
        
        // *** MODIFICATION START ***
        // Update the input field with only the cleaned coordinates
        inputElement.value = cleanedCoordinates.join('\n');
        // *** MODIFICATION END ***

        savedContours = [];
        let currentContour = [];
        cleanedCoordinates.forEach(coord => {
            if (typeof coord === 'string' && coord.trim() === '') {
                if (currentContour.length > 0) {
                    savedContours.push(currentContour);
                    currentContour = [];
                }
            } else {
                if (typeof coord === 'string') {
                    currentContour.push(coord);
                } else {
                    console.warn("handleInput (local): Encountered non-string coordinate:", coord);
                }
            }
        });
        if (currentContour.length > 0) {
            savedContours.push(currentContour);
        }
        console.log("handleInput: Populated savedContours from local parsing:", savedContours);
        drawContour(savedContours);
        if (showNotifications) {
            showNotification('Координаты обработаны локально');
        }
    } else if (inputText.trim() !== '' && !isAIRetry) { // AI вызывается только если локальный парсинг не удался и это не AI-retry
        console.log("handleInput: No local coordinates found. Attempting AI extraction for text.");
        try {
            const aiMultiContourText = await getCoordinatesFromTextAI(inputText);

            if (aiMultiContourText && aiMultiContourText.trim() !== "") {
                console.log("handleInput: AI extracted text. Processing for multiple contours directly.");
                
                inputElement.value = aiMultiContourText; // Обновляем поле ввода текстом от AI

                const contourBlocksText = aiMultiContourText.split(/\n\s*\n/);
                const newSavedContours = [];

                for (const blockText of contourBlocksText) {
                    const trimmedBlock = blockText.trim();
                    if (trimmedBlock.length === 0) continue;

                    const pointsInCurrentContour = [];
                    const linesInBlock = trimmedBlock.split('\n');

                    for (const line of linesInBlock) {
                        const trimmedLine = line.trim();
                        if (trimmedLine === '') continue;

                        const parts = trimmedLine.split('\t');
                        if (parts.length === 2) {
                            pointsInCurrentContour.push(trimmedLine);
                        } else {
                            console.warn("handleInput (AI): Line in AI-processed block does not have 2 parts after tab split:", trimmedLine);
                        }
                    }
                    if (pointsInCurrentContour.length > 0) {
                        newSavedContours.push(pointsInCurrentContour);
                    }
                }

                if (newSavedContours.length > 0) {
                    savedContours = newSavedContours;
                    showNotification('Координаты извлечены из текста с помощью ИИ!');
                    console.log("handleInput: Populated savedContours from AI processing:", savedContours);
                    drawContour(savedContours);
                    console.log("--- Ending handleInput after AI success (direct processing) ---");
                    return; 
                } else {
                    showNotification('ИИ вернул текст, но не удалось извлечь валидные контуры.');
                    console.log("handleInput (AI): AI returned text, but no valid contours extracted from blocks.");
                }
            } else {
                showNotification('Не удалось извлечь координаты из текста с помощью ИИ.');
                console.log("handleInput (AI): AI did not return useful coordinate text.");
            }
        } catch (error) {
            console.error('Ошибка при обработке текста AI:', error);
            showNotification('Ошибка ИИ (текст): ' + error.message);
        }
    }


    const finalHasDrawableCoords = savedContours.some(contour => contour.length > 0);

    if (!finalHasDrawableCoords) {
        console.log("handleInput: No valid coordinates found after all attempts.");
        if (inputText.trim() === '') {
            const canvas = document.getElementById('canvas');
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            canvas.style.display = 'none';
            document.getElementById('log').innerHTML = '';
            document.getElementById('comboBoxContainer').innerHTML = '';
            savedContours = [];
            console.log("handleInput: Input is empty, cleared canvas/logs.");
        } else {
             if (showNotifications && !isAIRetry) { 
                 showNotification('Не удалось распознать координаты из текста');
             }
             console.log("handleInput: Input has text but no drawable coords found. Keeping previous drawing if any.");
        }
    }
    console.log("--- Ending handleInput ---");
}



function drawContour(coords) {
    const canvas = document.getElementById('canvas');
    const container = canvas.parentElement;

    // --- НАЧАЛО ИСПРАВЛЕНИЯ ---
    // Принудительно синхронизируем размер холста с его CSS-размером перед каждой отрисовкой.
    // Это ключевое исправление, которое убирает искажение.
    if (canvas.width !== container.offsetWidth || canvas.height !== container.offsetHeight) {
        canvas.width = container.offsetWidth;
        canvas.height = container.offsetHeight;
    }
    // --- КОНЕЦ ИСПРАВЛЕНИЯ ---

    const ctx = canvas.getContext('2d');
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
       ctx.fillStyle = '#FFFFFF';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    if (!coords || coords.length === 0 || coords.every(obj => obj.length === 0)) {
        canvas.style.display = 'none';
        document.getElementById('log').innerHTML = '';
        document.getElementById('comboBoxContainer').innerHTML = '';
        return;
    }
    
    ctx.save();
    ctx.translate(canvas.width / 2, canvas.height / 2);
    ctx.scale(zoomLevel, zoomLevel);
    ctx.translate(-canvas.width / 2 + panX, -canvas.height / 2 + panY);

    let allPoints = coords.flat().map(coord => coord.split('\t').map(Number));
    const minX = Math.min(...allPoints.map(p => p[0]));
    const minY = Math.min(...allPoints.map(p => p[1]));
    const maxX = Math.max(...allPoints.map(p => p[0]));
    const maxY = Math.max(...allPoints.map(p => p[1]));

    const padding = 60;
    const scaleX = (canvas.width - padding * 2) / (maxY - minY);
    const scaleY = (canvas.height - padding * 2) / (maxX - minX);
    const scale = Math.min(scaleX, scaleY) * 0.9;

    const offsetX = padding + (canvas.width - padding * 2 - (maxY - minY) * scale) / 2;
    const offsetY = padding + (canvas.height - padding * 2 - (maxX - minX) * scale) / 2;

    const pointRadius = 3 / zoomLevel;
    const fontSize = 12 / zoomLevel;
    const textOffset = 5 / zoomLevel;

    if (showRulers) {
        drawRulers(ctx, minX, minY, maxX, maxY, offsetX, offsetY, scale, canvas.width, canvas.height);
    }

    const isPointVisible = (x, y) => {
        return x >= 0 && x <= canvas.width && y >= 0 && y <= canvas.height;
    };

    coords.forEach((points, objectIndex) => {
        ctx.beginPath();
        ctx.strokeStyle = getRandomColor();

        const isClosedContour = isContourClosed(points);

        let firstCanvasX, firstCanvasY;

        points.forEach((coord, index) => {
            const [x, y] = coord.split('\t').map(Number);
            const canvasX = offsetX + (y - minY) * scale;
            const canvasY = canvas.height - (offsetY + (x - minX) * scale);

            if (index === 0) {
                ctx.moveTo(canvasX, canvasY);
                firstCanvasX = canvasX;
                firstCanvasY = canvasY;
            } else {
                ctx.lineTo(canvasX, canvasY);
            }
        });

        if (isClosedContour) {
            ctx.closePath();
        }
        ctx.stroke();
        
            // Отрисовка названия контура, если опция включена
        if (showContourNames && savedContourNames[objectIndex]) {
            const name = savedContourNames[objectIndex];
            const centroid = calculateCentroid(points); // Используем новую функцию

            if (centroid) {
                // Преобразуем мировые координаты центра в координаты на холсте
                const canvasX = offsetX + (centroid.y - minY) * scale;
                const canvasY = canvas.height - (offsetY + (centroid.x - minX) * scale);
                
                // Настройки текста
                ctx.font = `bold ${fontSize * 1.1}px Arial`; // Чуть крупнее номеров
                ctx.fillStyle = 'darkmagenta';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';

                // Добавим простую тень/обводку для читаемости
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)';
                ctx.lineWidth = 3 / zoomLevel;
                ctx.strokeText(name, canvasX, canvasY);

                ctx.fillText(name, canvasX, canvasY);
            }
        }
        

        if (showPoints) {
            ctx.fillStyle = 'red';
            points.forEach((coord, index) => {
                const [x, y] = coord.split('\t').map(Number);
                const canvasX = offsetX + (y - minY) * scale;
                const canvasY = canvas.height - (offsetY + (x - minX) * scale);
                if (isPointVisible(canvasX, canvasY)) {
                     ctx.beginPath();
                    ctx.arc(canvasX, canvasY, pointRadius, 0, 2 * Math.PI);
                    ctx.fill();
               }
            });
        }

        if (showLabels) {
            ctx.font = `${fontSize}px Arial`;
            ctx.fillStyle = 'red';
            points.forEach((coord, index) => {
                const [x, y] = coord.split('\t').map(Number);
                const canvasX = offsetX + (y - minY) * scale;
                const canvasY = canvas.height - (offsetY + (x - minX) * scale);
                if (isPointVisible(canvasX, canvasY)) {
                    if (isClosedContour && index === points.length - 1) {
                        ctx.fillText(`${objectIndex + 1}.1`, canvasX + textOffset, canvasY - textOffset);
                    } else {
                        ctx.fillText(`${objectIndex + 1}.${index + 1}`, canvasX + textOffset, canvasY - textOffset);
                     }
                }
            });
        }
        
        if (showDistances && points.length < 30) {
            ctx.font = `${fontSize}px Arial`;
            ctx.fillStyle = 'black';
            for (let i = 0; i < points.length - 1; i++) {
                const [x1, y1] = points[i].split('\t').map(Number);
                const [x2, y2] = points[i + 1].split('\t').map(Number);
                const canvasX1 = offsetX + (y1 - minY) * scale;
                const canvasY1 = canvas.height - (offsetY + (x1 - minX) * scale);
                const canvasX2 = offsetX + (y2 - minY) * scale;
                const canvasY2 = canvas.height - (offsetY + (x2 - minX) * scale);
                const midX = (canvasX1 + canvasX2) / 2;
                const midY = (canvasY1 + canvasY2) / 2;
               if (isPointVisible(midX, midY)) {
                   const distance = Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);
                   if (distance > 0.01) {
                      ctx.fillText(`${distance.toFixed(2)} м`, midX, midY);
                  }
              }
            }

            if (isClosedContour) {
                const [x1, y1] = points[points.length - 1].split('\t').map(Number);
                const [x2, y2] = points[0].split('\t').map(Number);
                const canvasX1 = offsetX + (y1 - minY) * scale;
                const canvasY1 = canvas.height - (offsetY + (x1 - minX) * scale);
                const canvasX2 = offsetX + (y2 - minY) * scale;
                const canvasY2 = canvas.height - (offsetY + (x2 - minX) * scale);
                const midX = (canvasX1 + canvasX2) / 2;
                const midY = (canvasY1 + canvasY2) / 2;
               
                if (isPointVisible(midX, midY)) {
                     const distance = Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);
                    if (distance > 0.01) {
                       ctx.fillText(`${distance.toFixed(2)} м`, midX, midY);
                   }
                }
            }
        }
    });

    ctx.restore();

    canvas.style.display = 'block';
    displayLog(coords);
    createComboBoxes(coords);
}

function isContourClosed(contour) {
    // Need at least 3 points for a polygon, and first must match last
    if (!contour || contour.length < 3) return false;
    const firstPointStr = contour[0];
    const lastPointStr = contour[contour.length - 1];

    // Parse coordinates to compare numerically, handling potential floating point issues
    try {
        const [x1, y1] = firstPointStr.split('\t').map(Number);
        const [x2, y2] = lastPointStr.split('\t').map(Number);

        // Use a small tolerance for floating point comparison (e.g., 1 mm)
        const tolerance = 0.001;
        return Math.abs(x1 - x2) < tolerance && Math.abs(y1 - y2) < tolerance;
    } catch (e) {
        console.error("Error parsing points in isContourClosed:", firstPointStr, lastPointStr, e);
        return false; // Treat parse errors as not closed
    }
}



function initializeZoom() {
    const canvas = document.getElementById('canvas');

    // Обработка колесика мыши для масштабирования
      canvas.addEventListener('wheel', function(e) {
        e.preventDefault();
        const rect = canvas.getBoundingClientRect();
        const mouseX = e.clientX - rect.left;
        const mouseY = e.clientY - rect.top;

        // Определяем направление прокрутки
        const delta = Math.sign(e.deltaY);
        const zoomFactor = delta > 0 ? 0.9 : 1.1;

        // Обновляем уровень масштабирования
        const oldZoom = zoomLevel;
        zoomLevel *= zoomFactor;
        zoomLevel = Math.min(Math.max(zoomLevel, 0.1), 10); // Ограничиваем масштаб

        // Корректируем позицию панорамирования для зума в точку мыши
        panX += (mouseX / oldZoom - mouseX / zoomLevel);
        panY += (mouseY / oldZoom - mouseY / zoomLevel);

        // Перерисовываем canvas
         drawContour(savedContours); // Перерисовываем с savedContours
    });
    
     // Обработка перетаскивания
    canvas.addEventListener('mousedown', function(e) {
        isDragging = true;
        lastX = e.clientX;
        lastY = e.clientY;
        canvas.style.cursor = 'grabbing';
    });

    canvas.addEventListener('mousemove', function(e) {
        if (isDragging) {
            const dx = e.clientX - lastX;
            const dy = e.clientY - lastY;
            
            panX += dx / zoomLevel;
            panY += dy / zoomLevel;

            lastX = e.clientX;
            lastY = e.clientY;

            drawContour(savedContours); // Перерисовываем с savedContours
        }
    });

    canvas.addEventListener('mouseup', function() {
        isDragging = false;
        canvas.style.cursor = 'grab';
    });

    canvas.addEventListener('mouseleave', function() {
        isDragging = false;
        canvas.style.cursor = 'grab';
    });
}

// Добавьте обработку тачскрина для мобильных устройств
function initializeTouchZoom() {
    const canvas = document.getElementById('canvas');
    let initialDistance = 0;
    let initialZoom = 1;
    
    canvas.addEventListener('touchstart', function(e) {
        if (e.touches.length === 2) {
            initialDistance = Math.hypot(
                e.touches[0].clientX - e.touches[1].clientX,
                e.touches[0].clientY - e.touches[1].clientY
            );
            initialZoom = zoomLevel;
        }
    });

    canvas.addEventListener('touchmove', function(e) {
        if (e.touches.length === 2) {
            e.preventDefault();
            const currentDistance = Math.hypot(
                e.touches[0].clientX - e.touches[1].clientX,
                e.touches[0].clientY - e.touches[1].clientY
            );
            
            const scale = currentDistance / initialDistance;
            zoomLevel = Math.min(Math.max(initialZoom * scale, 0.1), 10);
            drawContour(savedContours);
        }
    });
}

function getCurrentCoordinates() {
    // This function is now deprecated as we use savedContours
    // However, it's still used by copyCoordinatesAndOpenMap
    const input = document.getElementById('coordsInput').value;
    return input.split('\n'); // Return raw lines including empty ones
}




function drawRulers(ctx, minX, minY, maxX, maxY, offsetX, offsetY, scale, canvasWidth, canvasHeight) {
    ctx.strokeStyle = 'royalblue';
    ctx.fillStyle = 'royalblue';
    ctx.font = '12px Arial';
    ctx.textAlign = 'center';

    const steps = [1, 2, 5, 10, 20, 50, 100, 200, 500, 1000, 2000, 5000, 10000];

    function getOptimalStep(range) {
        return steps.find(step => range / step <= 5) || steps[steps.length - 1];
    }

    const bottomY = canvasHeight - 20;
    ctx.beginPath();
    ctx.moveTo(offsetX, bottomY);
    ctx.lineTo(canvasWidth - offsetX, bottomY);
    ctx.stroke();

    const horizontalRange = maxY - minY;
    const horizontalStep = getOptimalStep(horizontalRange);
    for (let i = 0; i <= Math.floor(horizontalRange / horizontalStep); i++) {
        const y = minY + i * horizontalStep;
        const canvasX = offsetX + (y - minY) * scale;
        ctx.beginPath();
        ctx.moveTo(canvasX, bottomY);
        ctx.lineTo(canvasX, bottomY + 5);
        ctx.stroke();
        ctx.fillText(`${(i * horizontalStep).toFixed(0)} м`, canvasX, bottomY + 15);
    }

    const rightX = canvasWidth - 20;
    ctx.beginPath();
    ctx.moveTo(rightX, offsetY);
    ctx.lineTo(rightX, canvasHeight - offsetY - 30);
    ctx.stroke();

    ctx.textAlign = 'right';
    const verticalRange = maxX - minX;
    const verticalStep = getOptimalStep(verticalRange);
    for (let i = 0; i <= Math.floor(verticalRange / verticalStep); i++) {
        const x = minX + i * verticalStep;
        const canvasY = canvasHeight - (offsetY + (x - minX) * scale);
        ctx.beginPath();
        ctx.moveTo(rightX, canvasY);
        ctx.lineTo(rightX + 5, canvasY);
        ctx.stroke();
        ctx.fillText(`${(i * verticalStep).toFixed(0)} м`, rightX - 5, canvasY + 4);
    }
}

function calculateArea(points) {
    let area = 0;
    const n = points.length;
    // Ensure it's treated as closed for calculation, even if last point isn't explicitly repeated in input sometimes
    for (let i = 0; i < n; i++) {
        try {
            const [x1, y1] = points[i].split('\t').map(Number);
            // Use modulo operator to wrap around for the last point connecting to the first
            const [x2, y2] = points[(i + 1) % n].split('\t').map(Number);
            area += x1 * y2 - y1 * x2;
        } catch (e) {
            console.error("Error parsing points in calculateArea:", points[i], points[(i + 1) % n], e);
            return 0; // Return 0 on error
        }
    }
    return Math.abs(area) / 2;
}


function handleTextareaClick(event) {
    const textarea = event.target;
    const text = textarea.value;
    const cursorPosition = textarea.selectionStart;

    // Determine the line number that was clicked
    const textBeforeCursor = text.substring(0, cursorPosition);
    const lineIndex = textBeforeCursor.split('\n').length - 1;

    // Get the content of the clicked line
    const lines = text.split('\n');
    const clickedLine = lines[lineIndex];

    if (!clickedLine || clickedLine.trim() === '') return;

    // Parse coordinates from the clicked line
    const parts = clickedLine.trim().split(/\s+|\t/);
    if (parts.length >= 2) {
        const x = parseFloat(parts[0].replace(',', '.'));
        const y = parseFloat(parts[1].replace(',', '.'));

        if (!isNaN(x) && !isNaN(y)) {
            // If coordinates are valid, start the animation
            flashPointAnimation(x, y);
        }
    }
}

function handleCanvasClick(event) {
    const canvas = event.target;
    if (!savedContours || savedContours.length === 0 || savedContours.every(c => c.length === 0)) {
        return;
    }

    const rect = canvas.getBoundingClientRect();
    const mouseX = event.clientX - rect.left;
    const mouseY = event.clientY - rect.top;

    const allPoints = savedContours.flat().map(coord => coord.split('\t').map(Number));
    if (allPoints.length === 0) return;
    const minX = Math.min(...allPoints.map(p => p[0]));
    const minY = Math.min(...allPoints.map(p => p[1]));
    const maxX = Math.max(...allPoints.map(p => p[0]));
    const maxY = Math.max(...allPoints.map(p => p[1]));
    const padding = 60;
    const scaleX = (canvas.width - padding * 2) / (maxY - minY);
    const scaleY = (canvas.height - padding * 2) / (maxX - minX);
    const scale = Math.min(scaleX, scaleY) * 0.9;
    const offsetX = padding + (canvas.width - padding * 2 - (maxY - minY) * scale) / 2;
    const offsetY = padding + (canvas.height - padding * 2 - (maxX - minX) * scale) / 2;
    
    let minDistSq = Infinity;
    let nearestPointInfo = null;

    savedContours.forEach((contour, contourIndex) => {
        contour.forEach((pointStr, pointIndex) => {
            const [x, y] = pointStr.split('\t').map(Number);
            const initialCanvasX = offsetX + (y - minY) * scale;
            const initialCanvasY = canvas.height - (offsetY + (x - minX) * scale);
            const screenX = (initialCanvasX - canvas.width / 2 + panX) * zoomLevel + canvas.width / 2;
            const screenY = (initialCanvasY - canvas.height / 2 + panY) * zoomLevel + canvas.height / 2;
            const distSq = (screenX - mouseX) ** 2 + (screenY - mouseY) ** 2;
            
            if (distSq < minDistSq) {
                minDistSq = distSq;
                nearestPointInfo = { x, y, contourIndex, pointIndex };
            }
        });
    });
    
    if (!nearestPointInfo) return;

    document.title = `${nearestPointInfo.x.toFixed(2)}\t${nearestPointInfo.y.toFixed(2)}`;
    flashPointAnimation(nearestPointInfo.x, nearestPointInfo.y);

    const textarea = document.getElementById('coordsInput');
    const lines = textarea.value.split('\n');
    let targetLineIndex = -1;
    
    const targetSmaller = Math.min(nearestPointInfo.x, nearestPointInfo.y).toFixed(2);
    const targetLarger = Math.max(nearestPointInfo.x, nearestPointInfo.y).toFixed(2);

    // Логирование можно оставить для отладки или убрать
    // console.clear(); 
    // console.log(`ИЩЕМ НОРМАЛИЗОВАННУЮ ПАРУ: [${targetSmaller}, ${targetLarger}]`);

    for (let i = 0; i < lines.length; i++) {
        const line = lines[i].trim();
        const parts = line.split(/\t|\s{2,}/); 
        if (parts.length < 2) continue;

        const lineVal1 = parseFloat(parts[0].replace(',', '.'));
        const lineVal2 = parseFloat(parts[1].replace(',', '.'));

        if (isNaN(lineVal1) || isNaN(lineVal2)) continue;

        const lineSmaller = Math.min(lineVal1, lineVal2).toFixed(2);
        const lineLarger = Math.max(lineVal1, lineVal2).toFixed(2);

        // console.log(`Строка ${i}: -> Нормализованная пара: [${lineSmaller}, ${lineLarger}]`);

        if (lineSmaller === targetSmaller && lineLarger === targetLarger) {
            targetLineIndex = i;
            // console.log(`✅ СОВПАДЕНИЕ НАЙДЕНО на строке ${i}!`);
            break; 
        }
    }

    if (targetLineIndex === -1) {
        // console.error("❌ СОВПАДЕНИЕ НЕ НАЙДЕНО.");
        return; 
    }

    // --- НАЧАЛО ИСПРАВЛЕННОГО БЛОКА ВЫДЕЛЕНИЯ ---
    // Этот метод намного стабильнее, чем ручной подсчет символов.

    const textContent = textarea.value;
    // Находим позицию начала n-ной строки
    const nth_occurrence = (string, char, n) => {
        let index = string.indexOf(char);
        for (let i = 1; i < n && index !== -1; i++) {
            index = string.indexOf(char, index + 1);
        }
        return index;
    };
    
    // Позиция начала строки - это позиция после (targetLineIndex)-го символа '\n'
    const startPos = targetLineIndex === 0 ? 0 : nth_occurrence(textContent, '\n', targetLineIndex) + 1;
    const endPos = startPos + lines[targetLineIndex].length;

    // Сначала фокусируемся на элементе
    textarea.focus();

    // Затем устанавливаем выделение
    // Важно: нужно обернуть в setTimeout с нулевой задержкой. 
    // Это позволяет браузеру сначала обработать фокус, а потом уже выделение,
    // что решает проблему "не работает со второго раза".
    setTimeout(() => {
        textarea.setSelectionRange(startPos, endPos);
        // Дополнительно можно прокрутить к выделенному
        textarea.scrollTop = textarea.scrollHeight * (startPos / textContent.length) - textarea.clientHeight / 2;
    }, 0);
    // --- КОНЕЦ ИСПРАВЛЕННОГО БЛОКА ВЫДЕЛЕНИЯ ---
}



function flashPointAnimation(worldX, worldY) {
    const canvas = document.getElementById('canvas');
    if (!canvas || !savedContours || savedContours.length === 0) return;
    const ctx = canvas.getContext('2d');

    // This logic must exactly match the transformation in your drawContour function
    // to correctly map world coordinates to the initial canvas position (before pan/zoom).
    let allPoints = savedContours.flat().map(coord => coord.split('\t').map(Number));
    const minX = Math.min(...allPoints.map(p => p[0]));
    const minY = Math.min(...allPoints.map(p => p[1]));
    const maxX = Math.max(...allPoints.map(p => p[0]));
    const maxY = Math.max(...allPoints.map(p => p[1]));
    const padding = 60;
    const scaleX = (canvas.width - padding * 2) / (maxY - minY);
    const scaleY = (canvas.height - padding * 2) / (maxX - minX);
    const scale = Math.min(scaleX, scaleY) * 0.9;
    const offsetX = padding + (canvas.width - padding * 2 - (maxY - minY) * scale) / 2;
    const offsetY = padding + (canvas.height - padding * 2 - (maxX - minX) * scale) / 2;

    // Calculate the point's position on the canvas, respecting the current pan and zoom
    const initialCanvasX = offsetX + (worldY - minY) * scale;
    const initialCanvasY = canvas.height - (offsetY + (worldX - minX) * scale);
    
    // Apply pan and zoom to find the final screen position
    const screenX = (initialCanvasX - canvas.width / 2 + panX) * zoomLevel + canvas.width / 2;
    const screenY = (initialCanvasY - canvas.height / 2 + panY) * zoomLevel + canvas.height / 2;
    
    // Animation variables
    let size = 4 / zoomLevel; // Start small, adjust for zoom
    let opacity = 0.8;
    const animationDuration = 300; // 300ms for a quick flash
    const startTime = performance.now();

    function animateFlash(currentTime) {
        const elapsedTime = currentTime - startTime;
        const progress = elapsedTime / animationDuration;

        if (progress >= 1) {
            // Animation finished, redraw one last time to be clean
            drawContour(savedContours);
            return;
        }

        // Redraw the base scheme on each frame
        drawContour(savedContours);

        // Calculate current state of the flash
        const currentSize = size + (20 / zoomLevel) * progress; // Expands
        const currentOpacity = opacity * (1 - progress);      // Fades out

        // Use setTransform to draw in absolute screen coordinates, ignoring canvas pan/zoom
        ctx.save();
        ctx.setTransform(1, 0, 0, 1, 0, 0);

        // Draw the flashing circle
        ctx.beginPath();
        ctx.arc(screenX, screenY, currentSize, 0, Math.PI * 2);
        ctx.fillStyle = `rgba(255, 0, 0, ${currentOpacity})`;
        ctx.fill();
        
        ctx.restore();

        // Continue the animation
        requestAnimationFrame(animateFlash);
    }
    
    // Start the animation
    requestAnimationFrame(animateFlash);
}

function calculatePerimeter(points) {
    let perimeter = 0;
    const n = points.length;
    // Check if the shape is closed based on coordinate match
    const closedByCoords = isContourClosed(points);
    // Determine the number of segments to calculate
    
     if (n < 2) return 0; // No perimeter for single point or empty array

    // Simpler approach: Sum distances between p[i] and p[i+1] for i from 0 to n-2.
    // If closed, add distance between p[n-1] and p[0].

    perimeter = 0;
    for (let i = 0; i < n - 1; i++) { // Sum segments p[i] to p[i+1]
        try {
            const [x1, y1] = points[i].split('\t').map(Number);
            const [x2, y2] = points[i + 1].split('\t').map(Number);
            perimeter += Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);
        } catch (e) {
             console.error("Error parsing points in calculatePerimeter (segment):", points[i], points[i+1], e);
             return NaN; // Return NaN on error
        }
    }
    
    // If the contour is closed and has more than 2 points, add the segment from the last point back to the first.
    // Note: isContourClosed checks if the *last coordinate value* matches the *first coordinate value*.
    // If the input explicitly repeats the first point at the end, the loop above already calculated the segment from n-2 to n-1.
    // We only need to add the closing segment if the last point in the array is *not* the same as the first point in the array structure.
    // However, the `isContourClosed` function checks if the *values* match.
    // Let's rely on `isContourClosed`. If it's closed, the last point is logically the same as the first.
    // The loop from 0 to n-2 calculates distances for segments (0,1), (1,2), ..., (n-2, n-1).
    // If closed, we need the segment (n-1, 0).
    if (closedByCoords) {
         try {
             const [x1, y1] = points[n - 1].split('\t').map(Number);
             const [x2, y2] = points[0].split('\t').map(Number);
             perimeter += Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);
         } catch (e) {
             console.error("Error parsing points in calculatePerimeter (closing segment):", points[n - 1], points[0], e);
             return NaN;
         }
    }


    return perimeter;
}
        

function generateAndDownloadMIF() {
    const input = document.getElementById('coordsInput').value;
    const coords = input.split('\n');
    const mifContent = generateMIF(coords);
    const blob = new Blob([mifContent], { type: 'text/plain' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'output.mif';
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
}

function generateAndDownloadDXF() {
    const input = document.getElementById('coordsInput').value;
    const coords = input.split('\n');
    const dxfContent = generateDXF(coords);
    const blob = new Blob([dxfContent], { type: 'application/dxf' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'output.dxf';
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
}

function generateAndDownloadCSV() {
    const input = document.getElementById('coordsInput').value;
    const coords = input.split('\n');
    const csvContent = generateCSV(coords);
    
    // Добавляем BOM для правильного распознавания UTF-8
    const bom = '\uFEFF';
    const csvWithBom = bom + csvContent;
    
    const blob = new Blob([csvWithBom], { type: 'text/csv;charset=utf-8;' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'технокад.csv';
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
}




function extractCoordinatesEntitySpatial(text) {
    const allCoordinates = [];
    // Файл может содержать несколько блоков <entity_spatial>, поэтому обрабатываем каждый.
    const entitySpatialBlocks = text.split('</entity_spatial>');

    entitySpatialBlocks.forEach(block => {
        if (block.trim() === '') return;

        // Проверяем, содержит ли этот блок теги <spatial_element>, которые определяют вложенные контуры.
        if (block.includes('<spatial_element>')) {
            // Случай 1: Блок содержит вложенные контуры. Разделяем блок по тегу конца вложенного контура.
            const subContours = block.split('</spatial_element>');

            subContours.forEach(subContourBlock => {
                if (subContourBlock.trim() === '') return;
                
                const regex = /<x>(\d+(?:\.\d+)?)<\/x>\s*<y>(\d+(?:\.\d+)?)<\/y>/g;
                let matches;
                let currentContourPoints = [];

                while ((matches = regex.exec(subContourBlock)) !== null) {
                    const x = parseFloat(matches[1]).toFixed(2);
                    const y = parseFloat(matches[2]).toFixed(2);
                    currentContourPoints.push(`${x}\t${y}`);
                }

                if (currentContourPoints.length > 0) {
                    // Если в общем списке `allCoordinates` уже есть точки,
                    // значит, мы добавляем следующий контур, и нужно сначала вставить разделитель.
                    if (allCoordinates.length > 0) {
                       allCoordinates.push('');
                    }
                    allCoordinates.push(...currentContourPoints);
                }
            });

        } else {
            // Случай 2: Тегов <spatial_element> нет. Обрабатываем все координаты в блоке как один контур (старое поведение).
            const regex = /<x>(\d+(?:\.\d+)?)<\/x>\s*<y>(\d+(?:\.\d+)?)<\/y>/g;
            let matches;
            let singleContourPoints = [];

            while ((matches = regex.exec(block)) !== null) {
                const x = parseFloat(matches[1]).toFixed(2);
                const y = parseFloat(matches[2]).toFixed(2);
                singleContourPoints.push(`${x}\t${y}`);
            }

            if (singleContourPoints.length > 0) {
                if (allCoordinates.length > 0) {
                   allCoordinates.push('');
                }
                allCoordinates.push(...singleContourPoints);
            }
        }
    });
    
    return allCoordinates;
}

function extractCoordinatesNewContour(text) {
    const coordinates = [];
    const contours = text.split('</NewContour>');

    contours.forEach((contour, index) => {
        const regex = /X="(\d+(?:\.\d+)?)"[^>]+Y="(\d+(?:\.\d+))"/g;
        let matches;
        let currentContour = [];

        while ((matches = regex.exec(contour)) !== null) {
            const x = parseFloat(matches[1]).toFixed(2);
            const y = parseFloat(matches[2]).toFixed(2);
            currentContour.push(`${x}\t${y}`);
        }

        if (currentContour.length > 0) {
            if (coordinates.length > 0) coordinates.push('');
            coordinates.push(...currentContour);
        }
    });

    return coordinates;
}

function extractCoordinatesPlainText(text) {
    const contours = text.split('\n\n');
    return contours.flatMap((contour, index) => {
        const coords = contour.trim().split('\n').map(line => {
            const [x, y] = line.trim().split(/\s+|\t/);
            return `${parseFloat(x).toFixed(2)}\t${parseFloat(y).toFixed(2)}`;
        });
        return index > 0 ? ['', ...coords] : coords;
    });
}

function searchInTabs(text) {
    console.log("=== Starting searchInTabs ===");
    const coordinates = [];
    const lines = text.split('\n');
    let currentContour = [];
    let previousLineHadCoords = false;

    for (let i = 0; i < lines.length; i++) {
        const line = lines[i].trim();
        if (!line) {
             // If current line is empty and the previous one had coordinates,
             // it signifies the end of a contour.
            if (previousLineHadCoords && currentContour.length > 0) {
                coordinates.push(...currentContour);
                coordinates.push(''); // Add contour separator
                currentContour = [];
            }
            previousLineHadCoords = false; // Reset flag for empty line
            continue; // Skip empty lines
        }

        // Разбиваем строку на части по табуляции или пробелам
        const parts = line.split(/[\t\s]+/);
        
        // Ищем числа с 5+ цифрами среди частей
        let possibleNumbers = parts.map(part => {
            const num = parseFloat(part.replace(',', '.'));
            return !isNaN(num) && Math.abs(num) >= 10000 ? num : null;
        }).filter(num => num !== null);

        if (possibleNumbers.length >= 2) {
            currentContour.push(`${possibleNumbers[0].toFixed(2)}\t${possibleNumbers[1].toFixed(2)}`);
            previousLineHadCoords = true;
        } else {
             // If current line has text but no coordinates, and previous had coords,
             // it also signifies the end of a contour (text as description).
            if (previousLineHadCoords && currentContour.length > 0) {
                coordinates.push(...currentContour);
                coordinates.push(''); // Add contour separator
                currentContour = [];
            }
            previousLineHadCoords = false; // Reset flag as this line didn't have coords
        }
    }

    // Добавляем последний контур, если он не был добавлен
    if (currentContour.length > 0) {
        coordinates.push(...currentContour);
    }

    // Удаляем пустую строку в конце, если она есть
    while (coordinates.length > 0 && coordinates[coordinates.length - 1] === '') {
        coordinates.pop();
    }

    console.log("=== Ending searchInTabs ===");
    return coordinates;
}

function importGeo(text) {
    const lines = text.split('\n');
    const coordinates = [];
    const separators = /[,;\t]/;  // разделители: запятая, точка с запятой, табуляция
    
    let currentContour = [];
    let previousLineHadCoords = false;
    
    for (let line of lines) {
        line = line.trim();
        if (!line) {
             if (previousLineHadCoords && currentContour.length > 0) {
                coordinates.push(...currentContour, '');
                currentContour = [];
            }
            previousLineHadCoords = false;
            continue;
        }
        
        // Разбиваем строку по разделителям
        const parts = line.split(separators);
        
        // Ищем два числа больше 10000
        let foundCoords = [];
        for (let part of parts) {
            const num = parseFloat(part.replace(',', '.'));
            if (!isNaN(num) && Math.abs(num) >= 10000) {
                foundCoords.push(num);
                if (foundCoords.length === 2) break;
            }
        }
        
        // Если нашли две координаты
        if (foundCoords.length === 2) {
            // Сортируем координаты (X всегда меньше Y)
            const [x, y] = foundCoords[0] < foundCoords[1] ? 
                [foundCoords[0], foundCoords[1]] : 
                [foundCoords[1], foundCoords[0]];
            currentContour.push(`${x.toFixed(2)}\t${y.toFixed(2)}`);
            previousLineHadCoords = true;
        } else {
             if (previousLineHadCoords && currentContour.length > 0) {
                coordinates.push(...currentContour, '');
                currentContour = [];
            }
            previousLineHadCoords = false;
        }
    }
    
    // Добавляем последний контур, если есть
    if (currentContour.length > 0) {
        coordinates.push(...currentContour);
    }

     while (coordinates.length > 0 && coordinates[coordinates.length - 1] === '') {
        coordinates.pop();
    }
    
    return coordinates;
}

 function extractCoordinatesFromTextWithDescription(text) {
    const lines = text.split('\n');
    const coordinates = [];
    let currentContour = [];
    let previousLineHadCoords = false;
    const numberRegex = /[-+]?[0-9]*[.,]?[0-9]+/g;

    for (let line of lines) {
        line = line.trim();
        if (!line) {
          if (previousLineHadCoords && currentContour.length > 0) {
            coordinates.push(...currentContour);
            coordinates.push('');
            currentContour = [];
          }
          previousLineHadCoords = false;
          continue;
        }

         const numbers = line.match(numberRegex);
       const potentialCoords = numbers ? numbers.map(n => parseFloat(n.replace(',', '.')))
                                                 .filter(n => Math.abs(n) >= 10000)
                                        : [];
       if (potentialCoords.length >= 2) {
          const [x, y] = potentialCoords[0] < potentialCoords[1]
            ? [potentialCoords[0], potentialCoords[1]]
            : [potentialCoords[1], potentialCoords[0]];
           currentContour.push(`${x.toFixed(2)}\t${y.toFixed(2)}`);
           previousLineHadCoords = true;
        } else {
            if (previousLineHadCoords && currentContour.length > 0) {
                coordinates.push(...currentContour);
                coordinates.push(''); // Добавляем разделитель контуров
                currentContour = [];
            }
          previousLineHadCoords = false;
        }
    }

  if (currentContour.length > 0) {
       coordinates.push(...currentContour);
  }


     if (coordinates.length > 0 && coordinates[coordinates.length - 1] === '') {
        coordinates.pop();
    }
      return coordinates;
}



     function addToList() {
   const startComboBox = document.getElementById('start-point');
    const endComboBox = document.getElementById('end-point');
    const pointsList = document.getElementById('pointsList');

    if (!pointsList.querySelector('textarea')) {
        const textarea = document.createElement('textarea');
        textarea.rows = 5;
        textarea.style.width = '100%';
        textarea.readOnly = true;
        textarea.style.textAlign = 'center'; // Добавлено центрирование текста
        textarea.style.border = '2px solid #007bff';
        textarea.style.borderRadius = '10px';
        textarea.style.padding = '10px';
        textarea.style.boxShadow = '0 4px 8px rgba(0, 0, 0, 0.1)';
        textarea.style.transition = 'border-color 0.3s ease';
        textarea.style.boxSizing = 'border-box';
        textarea.style.resize = 'vertical';
        pointsList.appendChild(textarea);
    }

    const textarea = pointsList.querySelector('textarea');

    let newLine = '';
    if (startComboBox.value === '' || endComboBox.value === '' || startComboBox.value === endComboBox.value) {
        // Если точки не выбраны или выбрана одна и та же точка
        // Find the first area or perimeter element in the log
        const logElement = document.getElementById('log');
        const firstAreaSpan = logElement.querySelector('.clickable-area');
        const firstPerimeterSpan = logElement.querySelector('.clickable-perimeter');

        if (firstAreaSpan) {
             const areaValue = firstAreaSpan.dataset.area;
             newLine = `н1\tн1\t${parseFloat(areaValue).toFixed(2)}`; // Use area for closed contours
        } else if (firstPerimeterSpan) {
             const perimeterValue = firstPerimeterSpan.dataset.perimeter;
             newLine = `н1\tн1\t${parseFloat(perimeterValue).toFixed(2)}`; // Use perimeter for open contours
        }


    } else {
        // Если выбраны разные точки
        const startPointIndex = parseInt(startComboBox.value) + 1;
        const endPointIndex = parseInt(endComboBox.value) + 1;
        if (typeof window.lastCalculatedDistance !== 'undefined') {
            newLine = `н${startPointIndex}\tн${endPointIndex}\t${window.lastCalculatedDistance.toFixed(2)}`;
        }
    }

    if (newLine) {
        textarea.value += (textarea.value ? '\n' : '') + newLine;
    }
}

function copyPointsList() {
    const textarea = document.querySelector('#pointsList textarea');
    if (textarea) {
        textarea.select();
        document.execCommand('copy');
        showNotification('Список скопирован в буфер обмена');
    }
}
        
   
   
   function openCoordConverter() {
    const coordsInput = document.getElementById('coordsInput');
    const coordinatesText = coordsInput.value;

    if (!coordinatesText.trim()) {
        showNotification('Нет координат для копирования в конвертер.');
        window.open('cv.html', '_blank'); // Все равно открываем, даже если поле пустое
        return;
    }

    navigator.clipboard.writeText(coordinatesText).then(() => {
        showNotification('Координаты скопированы. Открываю конвертер...');
        window.open('cv.html', '_blank');
    }).catch(err => {
        console.error('Не удалось скопировать координаты: ', err);
        showNotification('Ошибка при копировании. Открываю конвертер...');
        window.open('cv.html', '_blank'); // Открываем, даже если копирование не удалось
    });
}     
        
        
function displayLog(objects) {
    const logElement = document.getElementById('log');
    logElement.innerHTML = ''; // Clear previous log entries

    objects.forEach((points, index) => {
        // Ensure points is an array and has enough elements
        if (!Array.isArray(points) || points.length === 0) {
             console.warn(`displayLog: Skipping empty or invalid object at index ${index}`);
             return;
         }

        let logMessage = '';
        const numPoints = points.length;

        // Use the dedicated function to check if the contour is closed
        // Note: A closed contour for area calculation typically needs at least 3 *distinct* vertices,
        // and the first and last coordinates must match.
        const isClosed = numPoints >= 3 && isContourClosed(points);

        if (isClosed) { // Check if it's a closed contour suitable for area calculation
            const area = calculateArea(points); // Calculate the precise area
            const perimeter = calculatePerimeter(points); // Calculate perimeter

            // Construct the message with both rounded and precise area (with 2 decimals)
            logMessage = `Контур ${index + 1}: Площадной объект, <span class="clickable-area" data-area="${area.toFixed(2)}">Площадь</span> = ${Math.round(area)} (${area.toFixed(2)}) кв. м, <span class="clickable-perimeter" data-perimeter="${perimeter.toFixed(2)}">Периметр</span> = ${perimeter.toFixed(2)} м`;

        } else if (numPoints >= 2) { // If not closed, but at least 2 points, it's a linear object
            const length = calculatePerimeter(points); // calculatePerimeter works for lines too
            logMessage = `Контур ${index + 1}: Линейный объект, <span class="clickable-perimeter" data-perimeter="${length.toFixed(2)}">Протяженность</span> = ${length.toFixed(2)} м`;
        } else if (numPoints === 1) { // Handle single point case
             logMessage = `Контур ${index + 1}: Точка`;
        } else {
             // Should not happen if initial check is done, but good for robustness
             logMessage = `Контур ${index + 1}: Неверный объект (мало точек)`;
        }


        const logEntry = document.createElement('p');
        logEntry.innerHTML = logMessage;
        logElement.appendChild(logEntry);
    });

    // Re-attach event listeners for clickable elements
    const clickableAreas = logElement.querySelectorAll('.clickable-area');
    clickableAreas.forEach(element => {
        element.removeEventListener('click', handleAreaClick); // Remove old listener if any
        element.addEventListener('click', handleAreaClick);
    });

    const clickablePerimeters = logElement.querySelectorAll('.clickable-perimeter');
    clickablePerimeters.forEach(element => {
        element.removeEventListener('click', handlePerimeterClick); // Remove old listener if any
        element.addEventListener('click', handlePerimeterClick);
    });
}

function handleAreaClick(event) {
    const area = parseFloat(event.target.dataset.area);
    const accuracyOptions = [0.1, 0.2, 0.5, 2.5, 5];
    
    const dialog = document.createElement('div');
    dialog.style.position = 'fixed';
    dialog.style.left = '50%';
    dialog.style.top = '50%';
    dialog.style.transform = 'translate(-50%, -50%)';
    dialog.style.backgroundColor = 'white';
    dialog.style.padding = '20px';
    dialog.style.border = '1px solid black';
    dialog.style.zIndex = '1000';

    dialog.innerHTML = '<p>Выберите погрешность (Mt):</p>';

    accuracyOptions.forEach(accuracy => {
        const button = document.createElement('button');
        button.textContent = accuracy;
        button.style.margin = '5px';
        button.addEventListener('click', () => {
            const deltaP = calculateDeltaP(area, accuracy);
            const resultString = `∆P=3.5*Mt*√P=3.5*${accuracy}*√${Math.round(area)}=${deltaP}`;

            navigator.clipboard.writeText(resultString).then(() => {
                flashElement(event.target);
                document.body.removeChild(dialog);
            }).catch(err => {
                console.error('Не удалось скопировать текст: ', err);
            });
        });
        dialog.appendChild(button);
    });

    document.body.appendChild(dialog);
}

function handlePerimeterClick(event) {
    const perimeter = event.target.dataset.perimeter;
    navigator.clipboard.writeText(perimeter).then(() => {
        flashElement(event.target);
    }).catch(err => {
        console.error('Не удалось скопировать текст: ', err);
    });
}

function calculateDeltaP(area, accuracy) {
    const result = 3.5 * accuracy * Math.sqrt(Math.round(area));
    return Math.round(result);
}

function flashElement(element) {
    element.style.transition = 'background-color 0.3s';
    element.style.backgroundColor = 'lime';
    setTimeout(() => {
        element.style.backgroundColor = 'transparent';
    }, 300);
}




function copyPerimeter() {
    const perimeterSpan = document.getElementById('perimeterSpan');
    const perimeterText = perimeterSpan.textContent;
    const perimeterValue = perimeterText.replace(/[^\d.]/g, '');
    
    navigator.clipboard.writeText(perimeterValue).then(() => {
        showNotification('Периметр скопирован в буфер обмена');
    }).catch(err => {
        console.error('Не удалось скопировать текст: ', err);
    });
}


function extractSingleNumberPerLine(text) {
    const lines = text.split('\n');
    // Filter out empty lines and trim whitespace
    const numbers = lines.filter(line => line.trim() !== '')
                         .map(line => line.trim());
    
    // Check if we have more than 3 lines
    if (numbers.length <= 3) {
        return [];
    }
    
    // Check if each line contains a single number (no spaces or tabs)
    const allSingleNumbers = numbers.every(line => {
        // Remove commas in numbers like "1234,56" -> "1234.56"
        const normalized = line.replace(',', '.');
        // Check if this is a valid number and doesn't contain spaces or tabs
        return !isNaN(parseFloat(normalized)) && 
               normalized.trim() === normalized &&
               !normalized.includes(' ') && 
               !normalized.includes('\t');
    });
    
    if (!allSingleNumbers) {
        return [];
    }
    
    // Group numbers in pairs (X, Y)
    const coordinates = [];
    for (let i = 0; i < numbers.length; i += 2) {
        if (i + 1 < numbers.length) {
            const x = parseFloat(numbers[i].replace(',', '.'));
            const y = parseFloat(numbers[i + 1].replace(',', '.'));
            coordinates.push(`${x.toFixed(2)}\t${y.toFixed(2)}`);
        }
    }
    
    return coordinates;
}


function showNotification(message) {
    const notification = document.getElementById('notification');
    notification.textContent = message;
    notification.style.display = 'block';
    
    setTimeout(() => {
        notification.style.display = 'none';
    }, 2000);
}

function createComboBoxes(objects) {
    const startPointWrapper = document.getElementById('start-point-wrapper');
    const endPointWrapper = document.getElementById('end-point-wrapper');
    const actionsContainer = document.querySelector('.combo-box-actions');

    if (!startPointWrapper || !endPointWrapper || !actionsContainer) {
        return;
    }

    startPointWrapper.innerHTML = '';
    endPointWrapper.innerHTML = '';
    actionsContainer.innerHTML = '';

    const createComboBox = (labelText, comboBoxId, wrapper) => {
        const label = document.createElement('label');
        label.textContent = labelText;
        wrapper.appendChild(label);

        const comboBox = document.createElement('select');
        comboBox.id = comboBoxId;
        
        const defaultOption = document.createElement('option');
        defaultOption.value = '';
        defaultOption.text = 'Выберите точку';
        comboBox.appendChild(defaultOption);

        let totalPoints = 0;
        objects.forEach((contour, contourIndex) => {
            const isClosedContour = isContourClosed(contour);
            const pointsCount = contour.length;
            for (let pointIndex = 0; pointIndex < pointsCount; pointIndex++) {
                const option = document.createElement('option');
                option.value = totalPoints + pointIndex;
                if (isClosedContour && pointIndex === pointsCount - 1) {
                     option.text = `Контур ${contourIndex + 1}, Точка 1 (замык.)`;
                } else {
                    option.text = `Контур ${contourIndex + 1}, Точка ${pointIndex + 1}`;
                }
                comboBox.appendChild(option);
            }
            totalPoints += pointsCount;
        });

        comboBox.addEventListener('change', calculateSelectedDistance);
        wrapper.appendChild(comboBox);
    };

    createComboBox('Начальная точка:', 'start-point', startPointWrapper);
    createComboBox('Конечная точка:', 'end-point', endPointWrapper);

    const copyButton = document.createElement('button');
    copyButton.innerHTML = '<i class="fas fa-copy"></i>';
    copyButton.className = 'action-btn';
    copyButton.title = 'Копировать с точками';
    copyButton.addEventListener('click', copyWithPoints);
    actionsContainer.appendChild(copyButton);

    const addToListButton = document.createElement('button');
    addToListButton.innerHTML = '<i class="fas fa-list-ul"></i>';
    addToListButton.className = 'action-btn';
    addToListButton.title = 'Добавить в список';
    addToListButton.onclick = addToList;
    actionsContainer.appendChild(addToListButton);
}




function initializeTooltips() {
    let tooltip = document.getElementById('custom-tooltip');
    if (!tooltip) {
        tooltip = document.createElement('div');
        tooltip.id = 'custom-tooltip';
        document.body.appendChild(tooltip);
    }
    
    const elementsWithTooltip = document.querySelectorAll('.container [title]');
    
    elementsWithTooltip.forEach(element => {
        const titleText = element.getAttribute('title');
        if (!titleText) return;

        element.removeAttribute('title'); 
        element.setAttribute('data-tooltip', titleText);

        element.addEventListener('mouseenter', (e) => {
            const targetElement = e.currentTarget;
            const tooltipText = targetElement.getAttribute('data-tooltip');

            tooltip.textContent = tooltipText;
            
            const computedStyle = window.getComputedStyle(targetElement);
            tooltip.style.background = computedStyle.background;
            tooltip.style.setProperty('--tooltip-bg', computedStyle.backgroundColor || '#2c3e50');

            const elemRect = targetElement.getBoundingClientRect();
            
            tooltip.style.left = `${elemRect.left + elemRect.width / 2}px`;
            
            // --- НОВАЯ ИСПРАВЛЕННАЯ ЛОГИКА НАПРАВЛЕНИЯ ПОДСКАЗКИ ---
            
            // 1. Сначала проверяем особые случаи (кнопки в самом низу страницы)
            const isPageBottomButton = targetElement.closest('.combo-box-actions') || targetElement.closest('#schemeMenu') || targetElement.id === 'schemeButton';

            // 2. Затем проверяем, находится ли кнопка в главном контейнере с кнопками экспорта
            const buttonContainer = targetElement.closest('.button-container');

            if (isPageBottomButton) {
                // Если это кнопка в самом низу страницы -> подсказка всегда ВНИЗ
                tooltip.classList.add('tooltip-below');
                tooltip.classList.remove('tooltip-above');
                tooltip.style.top = `${elemRect.bottom}px`;

            } else if (buttonContainer) {
                // Если это кнопка из блока "Экспорт и утилиты"
                // Находим самую первую кнопку в этом блоке
                const firstButtonInContainer = buttonContainer.querySelector('.action-btn');
                if (firstButtonInContainer) {
                    const firstButtonTop = firstButtonInContainer.getBoundingClientRect().top;
                    
                    // Сравниваем вертикальное положение текущей кнопки с первой.
                    // Если текущая кнопка расположена ниже первой, значит, она в нижнем ряду.
                    if (elemRect.top > firstButtonTop + 5) { // +5px для погрешности
                        // Кнопка в нижнем ряду -> подсказка ВНИЗ
                        tooltip.classList.add('tooltip-below');
                        tooltip.classList.remove('tooltip-above');
                        tooltip.style.top = `${elemRect.bottom}px`;
                    } else {
                        // Кнопка в верхнем ряду -> подсказка ВВЕРХ
                        tooltip.classList.add('tooltip-above');
                        tooltip.classList.remove('tooltip-below');
                        tooltip.style.top = `${elemRect.top}px`;
                    }
                }
            } else {
                // Для всех остальных случаев (например, кнопки у поля textarea) -> подсказка ВВЕРХ
                tooltip.classList.add('tooltip-above');
                tooltip.classList.remove('tooltip-below');
                tooltip.style.top = `${elemRect.top}px`;
            }

            // --- КОНЕЦ НОВОЙ ЛОГИКИ ---

            tooltip.classList.add('show');
        });

        element.addEventListener('mouseleave', () => {
            tooltip.classList.remove('show', 'tooltip-above', 'tooltip-below');
        });
    });
}


function calculateSelectedDistance() {
    const startComboBox = document.getElementById('start-point');
    const endComboBox = document.getElementById('end-point');

    const startPointGlobalIndex = parseInt(startComboBox.value);
    const endPointGlobalIndex = parseInt(endComboBox.value);

    if (!isNaN(startPointGlobalIndex) && !isNaN(endPointGlobalIndex)) {
        // Flatten savedContours to get a single array of all points
        const allPointsFlat = savedContours.flat();

        if (startPointGlobalIndex < 0 || startPointGlobalIndex >= allPointsFlat.length ||
            endPointGlobalIndex < 0 || endPointGlobalIndex >= allPointsFlat.length) {
            console.error("Invalid point index selected.");
            return;
        }

        const [x1, y1] = allPointsFlat[startPointGlobalIndex].split('\t').map(Number);
        const [x2, y2] = allPointsFlat[endPointGlobalIndex].split('\t').map(Number);
        
        const directDistance = Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);

        let distanceText = `Расстояние между точкой ${startPointGlobalIndex + 1} и точкой ${endPointGlobalIndex + 1} = ${directDistance.toFixed(2)} м`;

        // Check if points are in the same contour
        let sameContour = false;
        let startContourIndex = -1;
        let endContourIndex = -1;
        let startIdxInContour = -1;
        let endIdxInContour = -1;
        
        let currentGlobalIndex = 0;
        for(let i = 0; i < savedContours.length; i++) {
            const contour = savedContours[i];
            for(let j = 0; j < contour.length; j++) {
                if (currentGlobalIndex === startPointGlobalIndex) {
                    startContourIndex = i;
                    startIdxInContour = j;
                }
                if (currentGlobalIndex === endPointGlobalIndex) {
                    endContourIndex = i;
                    endIdxInContour = j;
                }
                currentGlobalIndex++;
            }
        }

        if (startContourIndex !== -1 && startContourIndex === endContourIndex) {
             sameContour = true;
             const contour = savedContours[startContourIndex];
             const isClosedContour = isContourClosed(contour);
             const numPointsInContour = contour.length;
             let boundaryDistance = 0;

             // Calculate forward boundary distance
             let distForward = 0;
             if (startIdxInContour !== endIdxInContour) { // Only calculate if points are different
                 let tempIdxForward = startIdxInContour;
                 while (tempIdxForward !== endIdxInContour) {
                     const nextIdx = (tempIdxForward + 1) % numPointsInContour;
                     distForward += calculatePointDistance(contour[tempIdxForward].split('\t').map(Number), contour[nextIdx].split('\t').map(Number));
                     tempIdxForward = nextIdx;
                     // Safety break for very large or problematic contours
                     if (distForward > 1e9 || (tempIdxForward === startIdxInContour && distForward > 0) ) {
                         console.warn("Boundary distance calculation (forward) seems to be in an infinite loop or too large. Breaking.");
                         distForward = Infinity; // Mark as problematic
                         break;
                     }
                 }
             }


             if (isClosedContour) {
                 boundaryDistance = distForward; // Use the 'forward' path calculation
             } else {
                 // For an open contour, sum segments *between* the selected points in their linear order
                 boundaryDistance = 0; // Initialize
                 if (startIdxInContour !== endIdxInContour) {
                    const pathStartIdx = Math.min(startIdxInContour, endIdxInContour);
                    const pathEndIdx = Math.max(startIdxInContour, endIdxInContour);
                    for(let k = pathStartIdx; k < pathEndIdx; k++) {
                        boundaryDistance += calculatePointDistance(contour[k].split('\t').map(Number), contour[k+1].split('\t').map(Number));
                    }
                 }
             }

            if (boundaryDistance === Infinity) { // Check if calculation was problematic
                distanceText += `, не удалось рассчитать протяженность частей границы (слишком сложный путь).`;
                 window.lastCalculatedDistance = directDistance; // Fallback to direct distance
                 navigator.clipboard.writeText(directDistance.toFixed(2));
            } else {
                distanceText += `, протяженность частей границы = ${boundaryDistance.toFixed(2)} м`;
                navigator.clipboard.writeText(boundaryDistance.toFixed(2));
                window.lastCalculatedDistance = boundaryDistance; // Save boundary distance
            }

        } else {
             // If points are in different contours or one is not found, use direct distance
             navigator.clipboard.writeText(directDistance.toFixed(2));
             window.lastCalculatedDistance = directDistance; // Save direct distance
        }
                const distanceLog = document.getElementById('distanceLog');
        distanceLog.innerHTML = distanceText;

        distanceLog.style.transition = 'background-color 0.3s';
        distanceLog.style.backgroundColor = 'lime';
        setTimeout(() => {
            distanceLog.style.backgroundColor = 'transparent';
        }, 300);

        
        window.lastStartPointIndex = startPointGlobalIndex;
        window.lastEndPointIndex = endPointGlobalIndex;
    }
}

// Вспомогательная функция для проверки равенства точек
function isPointsEqual(point1, point2) {
    return Math.abs(point1[0] - point2[0]) < 0.000001 && 
           Math.abs(point1[1] - point2[1]) < 0.000001;
}

// Вспомогательная функция для расчета расстояния между точками
function calculatePointDistance(point1, point2) {
    const dx = point2[0] - point1[0];
    const dy = point2[1] - point1[1];
    return Math.sqrt(dx * dx + dy * dy);
}
        
        
        




function updateImportButtonText(fileName) {
    // ИСПРАВЛЕНО: Используем правильный селектор по ID
    const importButtonElement = document.getElementById('importButton');
    
    // ДОБАВЛЕНО: Проверяем, найден ли элемент, прежде чем его использовать
    if (importButtonElement) {
        importButtonElement.title = `Импортирован файл: ${fileName}`;
    } else {
        console.warn("Элемент #importButton не найден. Не удалось обновить title.");
    }
}

function copyWithPoints() {
    if (typeof window.lastCalculatedDistance !== 'undefined' && 
        typeof window.lastStartPointIndex !== 'undefined' && 
        typeof window.lastEndPointIndex !== 'undefined') {
        
        const startPointText = document.getElementById('start-point').options[window.lastStartPointIndex + 1].text;
        const endPointText = document.getElementById('end-point').options[window.lastEndPointIndex + 1].text;

        // Extract contour and point numbers from the text
        const startMatch = startPointText.match(/Контур (\d+), Точка (\d+)/);
        const endMatch = endPointText.match(/Контур (\d+), Точка (\d+)/);

        let startLabel = `н${window.lastStartPointIndex + 1}`;
        let endLabel = `н${window.lastEndPointIndex + 1}`;

        if (startMatch && endMatch && startMatch[1] === endMatch[1]) {
             // If in the same contour, use contour.point format
             startLabel = `${startMatch[1]}.${startMatch[2]}`;
             endLabel = `${endMatch[1]}.${endMatch[2]}`;
        } else if (startMatch) {
             // If only start is in a contour, use its contour.point format
             startLabel = `${startMatch[1]}.${startMatch[2]}`;
             endLabel = `н${window.lastEndPointIndex + 1}`; // Keep global index for end
        } else if (endMatch) {
             // If only end is in a contour, use its contour.point format
             startLabel = `н${window.lastStartPointIndex + 1}`; // Keep global index for start
             endLabel = `${endMatch[1]}.${endMatch[2]}`;
        }
        // If neither is in a contour (shouldn't happen with current logic but for safety),
        // keep the global index format.

        const copyText = `${startLabel}\t${endLabel}\t${window.lastCalculatedDistance.toFixed(2)}`;

        navigator.clipboard.writeText(copyText).then(() => {
            showNotification('Расстояние с точками скопировано в буфер обмена');
        });
    } else {
        showNotification('Сначала выберите две точки');
    }
}

function showNotification(message) {
    const notification = document.getElementById('notification');
    notification.textContent = message;
    notification.style.display = 'block';
    
    setTimeout(() => {
        notification.style.display = 'none';
    }, 2000);
}


function toggleDropdown() {
    document.getElementById("importDropdown").classList.toggle("show");
}

// Закрытие выпадающего списка при клике вне его
window.onclick = function(event) {
    if (!event.target.matches('.import-button') && !event.target.closest('.import-button')) {
        var dropdowns = document.getElementsByClassName("dropdown-content");
        for (var i = 0; i < dropdowns.length; i++) {
            var openDropdown = dropdowns[i];
            if (openDropdown.classList.contains('show')) {
                openDropdown.classList.remove('show');
            }
        }
    }
}




function extractCoordinatesFromSpelementUnit(text) {
    // **** ADD THIS LOG ****
    console.log(">>> Executing extractCoordinatesFromSpelementUnit");
    // *********************
    const coordinates = [];
    // Regex needs to be less strict about surrounding tags and leading characters
    const regex = /<NewOrdinate[^>]*?Num_Geopoint\s*=\s*["'](\d+)["'][^>]*?X\s*=\s*["'](\d+(?:\.\d+)?)["'][^>]*?Y\s*=\s*["'](\d+(?:\.\d+)?)["'][^>]*?\/>/gi;
    let match;
    let lastPointNum = -1;
    let currentContourPoints = 0;
    let matchesFound = 0; // Counter for debugging

    while ((match = regex.exec(text)) !== null) {
        matchesFound++; // Increment match counter
        // ... (rest of the function logic remains the same) ...
        try {
            const pointNum = parseInt(match[1]);
            const xStr = match[2].replace(',', '.');
            const yStr = match[3].replace(',', '.');
            const x = parseFloat(xStr);
            const y = parseFloat(yStr);

            if (!isNaN(pointNum) && !isNaN(x) && !isNaN(y)) {
                // Add separator if point number resets to 1 and we already have points in the current contour
                // This logic assumes point numbers reset to 1 for each new contour.
                if (pointNum === 1 && currentContourPoints > 0) {
                     coordinates.push('');
                     currentContourPoints = 0; // Reset point count for the new contour
                }
                coordinates.push(`${x.toFixed(2)}\t${y.toFixed(2)}`);
                lastPointNum = pointNum; // Keep track of the last point number (not strictly needed with the pointNum === 1 check)
                currentContourPoints++;

            } else {
                console.warn("Spelement_Unit: Failed to parse coordinates/point number from match:", match[0]);
            }
        } catch (e) {
            console.error("Spelement_Unit: Error processing match:", match[0], e);
        }
    }

    // **** ADD DEBUG LOGS AT THE END ****
    console.log(`<<< extractCoordinatesFromSpelementUnit: Regex found ${matchesFound} potential matches.`);
    if (coordinates.length > 0) {
        console.log(`<<< extractCoordinatesFromSpelementUnit: Successfully extracted ${coordinates.filter(c => c !== '').length} coordinate pairs.`);
    } else {
         console.log("<<< extractCoordinatesFromSpelementUnit: Failed to extract coordinates.");
    }
    // **********************************

    // ... (rest of the cleanup logic) ...
     while (coordinates.length > 0 && coordinates[coordinates.length - 1] === '') {
        coordinates.pop();
    }

    return coordinates;
}



function extractCoordinatesFromXMLType1(text) {
    const allCoordinates = [];
    
    // Эта логика для поиска начала координат остается, на случай нестандартных файлов
    const startMarker = "<contours_location>";
    let textToProcess = text;
    if (text.includes(startMarker)) {
        const startIndex = text.indexOf(startMarker);
        textToProcess = text.substring(startIndex + startMarker.length);
    }
    
    // 1. Сначала разделяем текст на основные блоки <entity_spatial> (может быть несколько)
    const entitySpatialBlocks = textToProcess.split('</entity_spatial>');

    entitySpatialBlocks.forEach(block => {
        if (block.trim() === '') return;

        // 2. Внутри каждого блока ищем и разделяем на отдельные контуры по <spatial_element>
        const subContourBlocks = block.split('</spatial_element>');

        subContourBlocks.forEach(subContour => {
            if (subContour.trim() === '') return;

            const regex = /<x>(\d+(?:\.\d+)?)<\/x>\s*<y>(\d+(?:\.\d+)?)<\/y>/g;
            let matches;
            let currentContourPoints = [];

            while ((matches = regex.exec(subContour)) !== null) {
                const x = parseFloat(matches[1]).toFixed(2);
                const y = parseFloat(matches[2]).toFixed(2);
                currentContourPoints.push(`${x}\t${y}`);
            }

            if (currentContourPoints.length > 0) {
                // Добавляем пустую строку-разделитель, если это не самый первый контур
                if (allCoordinates.length > 0) {
                   allCoordinates.push('');
                }
                allCoordinates.push(...currentContourPoints);
            }
        });
    });
    
    return allCoordinates;
}

function extractCoordinatesFromXMLType2(text) {
    const coordinates = [];
    
    // Удаляем все содержимое между тегами SpecifyRelatedParcel
    text = text.replace(/<SpecifyRelatedParcel[\s\S]*?<\/SpecifyRelatedParcel>/g, '');
    
    // Ищем координаты во втором формате
    const regex2 = /X="(\d+(?:\.\d+)?)"[^>]+Y="(\d+(?:\.\d+)?)"[^>]+/g;
    let matches2 = Array.from(text.matchAll(regex2));
    
    if (matches2.length > 0) {
        // Разделяем на контуры по тегу SpatialElement
        const contours = text.split('</SpatialElement>');
        
        contours.forEach((contour, index) => {
            const contourMatches = Array.from(contour.matchAll(regex2));
            let currentContour = [];

            contourMatches.forEach(match => {
                const x = parseFloat(match[1]).toFixed(2);
                const y = parseFloat(match[2]).toFixed(2);
                currentContour.push(`${x}\t${y}`);
            });

            if (currentContour.length > 0) {
                if (coordinates.length > 0) coordinates.push('');
                coordinates.push(...currentContour);
            }
        });
    }

    return coordinates;
}

function extractCoordinatesFromXML(text) {
    // Сначала пробуем первый тип
    const coordinates1 = extractCoordinatesFromXMLType1(text);
    
    // Если первый тип не дал результатов, пробуем второй
    if (coordinates1.length === 0) {
        return extractCoordinatesFromXMLType2(text);
    }
    
    return coordinates1;
}


function appendCoordinates(coordinates) {
    const coordsInput = document.getElementById('coordsInput');
    let currentValue = coordsInput.value.trim();
    
    // If there are coordinates in the current value
    if (currentValue) {
        // Ensure there's a double newline separator
        if (!currentValue.endsWith('\n\n')) {
            currentValue += '\n\n';
        } else if (currentValue.endsWith('\n')) {
             currentValue += '\n'; // Ensure it's double newline
        }
        coordsInput.value = currentValue + coordinates.join('\n');
    } else {
        // If the input is empty, just set the value
        coordsInput.value = coordinates.join('\n');
    }
    // Trigger handleInput to process the updated text
    handleInput(true);
}



function extractCoordinatesFromInteractEntryBoundaries(text) {
    const coordinates = [];
    const contours = text.split('</EnSpa2:entity_spatial>');

    contours.forEach((contour, index) => {
        const regex = /<EnSpa2:x>(\d+(?:\.\d+)?)<\/EnSpa2:x>\s*<EnSpa2:y>(\d+(?:\.\d+)?)<\/EnSpa2:y>/g;
        let matches;
        let currentContour = [];

        while ((matches = regex.exec(contour)) !== null) {
            const x = parseFloat(matches[1]).toFixed(2);
            const y = parseFloat(matches[2]).toFixed(2);
            currentContour.push(`${x}\t${y}`);
        }

        if (currentContour.length > 0) {
            if (coordinates.length > 0) coordinates.push(''); // Добавляем пустую строку между контурами
            coordinates.push(...currentContour);
        }
    });

    return coordinates;
}




function extractCoordinatesFromGeoJSON(content) {
    try {
        const geojsonData = JSON.parse(content);
        // Будем возвращать массив объектов, где каждый объект - это контур с именем
        const contoursWithMeta = [];

        if (!geojsonData || !Array.isArray(geojsonData.features)) {
            console.error("GeoJSON is invalid or has no features array.");
            return [];
        }

        geojsonData.features.forEach(feature => {
            if (!feature.geometry || !feature.geometry.coordinates) return;
            
            const comment = feature?.properties?.name || null; // Получаем имя или null
            const type = feature.geometry.type;
            const coords = feature.geometry.coordinates;
            let currentContourPoints = [];

            const processRing = (ring) => {
                ring.forEach(point => {
                    if (Array.isArray(point) && point.length >= 2) {
                        const x = Math.min(point[0], point[1]);
                        const y = Math.max(point[0], point[1]);
                        if (!isNaN(x) && !isNaN(y)) {
                            currentContourPoints.push(`${x.toFixed(2)}\t${y.toFixed(2)}`);
                        }
                    }
                });
            };

            switch (type) {
                case 'MultiPolygon':
                    coords.forEach(polygon => polygon.forEach(ring => processRing(ring)));
                    break;
                case 'Polygon':
                    coords.forEach(ring => processRing(ring));
                    break;
                case 'LineString':
                    processRing(coords);
                    break;
            }
            
            if (currentContourPoints.length > 0) {
                // Добавляем объект с точками и именем в результат
                contoursWithMeta.push({
                    points: currentContourPoints,
                    name: comment
                });
            }
        });

        return contoursWithMeta;

    } catch (e) {
        console.error("Error parsing GeoJSON file:", e);
        showNotification("Ошибка при чтении GeoJSON файла. Неверный формат.");
        return [];
    }
}

function displayGeoJSONComments(comments) {
    const pointsList = document.getElementById('pointsList');
    if (!pointsList) return;

    // Очищаем предыдущее содержимое и создаем обертку
    pointsList.innerHTML = '';
    const wrapper = document.createElement('div');
    wrapper.style.textAlign = 'left';
    wrapper.style.padding = '10px';
    
    const title = document.createElement('h4');
    title.textContent = 'Названия объектов из файла:';
    title.style.marginTop = '0';
    title.style.marginBottom = '8px';
    title.style.textAlign = 'center';
    wrapper.appendChild(title);

    const list = document.createElement('ul');
    list.style.listStyleType = 'disc';
    list.style.paddingLeft = '20px';
    list.style.margin = '0';
    
    comments.forEach(comment => {
        const listItem = document.createElement('li');
        listItem.textContent = comment;
        list.appendChild(listItem);
    });

    wrapper.appendChild(list);
    pointsList.appendChild(wrapper);
}



    
// Модифицированная версия importFile()
function importFile(isAppend = false) {
     if (!isAppend) {
        savedContourNames = []; // Очищаем старые названия при новой загрузке
    }
    const fileInput = document.createElement('input');
    fileInput.type = 'file';
    fileInput.accept = '.xml,.zip,.dxf,.mif,.csv,.txt,.geojson';
    
    fileInput.onchange = function(e) {
        const file = e.target.files[0];
        if (!file) return;

        const extension = file.name.split('.').pop().toLowerCase();
        const reader = new FileReader();

        reader.onload = function(event) {
            let content = event.target.result;
            let coordinates;

            switch (extension) {
                case 'xml':
                case 'zip':
                    if (extension === 'zip') {
                        handleZipFile(file, isAppend);
                        return;
                    }
                    // Проверяем, содержит ли файл interact_entry_boundaries
                    if (content.includes('interact_entry_boundaries')) {
                        coordinates = extractCoordinatesFromInteractEntryBoundaries(content);
                    } else {
                        coordinates = extractCoordinatesFromXML(content);
                    }
                    break;
                    
case 'geojson':
                    // 1. Извлекаем структурированные данные
                    const contoursData = extractCoordinatesFromGeoJSON(content);
                    if (!contoursData || contoursData.length === 0) {
                        showNotification('Не удалось найти геометрию в GeoJSON файле');
                        return; // Выходим, если ничего не найдено
                    }
                    
                    // 2. Разделяем данные на контуры и названия
                    const newContours = contoursData.map(c => c.points);
                    const newNames = contoursData.map(c => c.name);

                    // 3. Обновляем глобальные переменные состояния
                    if (isAppend) {
                        savedContours.push(...newContours);
                        savedContourNames.push(...newNames);
                    } else {
                        savedContours = newContours;
                        savedContourNames = newNames;
                    }

                    // 4. Обновляем текстовое поле для консистентности
                    const textContent = savedContours.map(contour => contour.join('\n')).join('\n\n');
                    document.getElementById('coordsInput').value = textContent;

                    // 5. Обновляем боковой список с названиями
                    displayGeoJSONComments(savedContourNames.filter(name => name));

                    // 6. Вызываем отрисовку с обновленными данными
                    drawContour(savedContours);
                    
                    // Мы обработали все сами, поэтому прерываем switch, чтобы не попасть в общую логику ниже
                    return; // ВАЖНО: используем return, чтобы выйти из функции
                    
                case 'dxf':
                    coordinates = extractCoordinatesFromDXF(content);
                    break;
                case 'mif':
                    coordinates = extractCoordinatesFromMIF(content);
                    break;
                case 'csv':
                case 'txt':
                    coordinates = extractCoordinatesFromText(content);
                    break;
                default:
                    showNotification('Неподдерживаемый формат файла');
                    return;
            }

            if (coordinates && coordinates.length > 0) {
                if (isAppend) {
                    appendCoordinates(coordinates);
                } else {
                    document.getElementById('coordsInput').value = coordinates.join('\n');
                    handleInput(true);
                }
                updateImportButtonText(file.name);
            } else {
                showNotification('Не удалось найти координаты в файле');
            }
        };

        reader.onerror = function() {
            showNotification('Ошибка при чтении файла');
        };

        if (extension === 'zip') {
            reader.readAsArrayBuffer(file);
        } else {
            reader.readAsText(file, 'UTF-8');
        }
    };

    fileInput.click();
}

function generateAndDownloadJSON() {
    const input = document.getElementById('coordsInput').value.trim();
    const contours = input.split('\n\n').filter(contour => contour.trim() !== '');

    // Корректируем координаты: X всегда меньше Y
    const correctedContours = contours.map(contour => {
        return contour.split('\n').map(line => {
            let [x, y] = line.split(/\s+/).map(Number);
            if (x > y) {
                [x, y] = [y, x]; // Меняем местами, если X > Y
            }
            return [x, y];
        });
    });

    // Формируем GeoJSON
    const geoJSON = {
        type: "FeatureCollection",
        features: [
            {
                type: "Feature",
                geometry: {
                    type: "MultiPolygon",
                    coordinates: correctedContours.map(contour => [
                        contour.map(([x, y]) => [y, x]) // Формат GeoJSON: [Y, X]
                    ])
                }
            }
        ]
    };

    // Преобразуем в строку и скачиваем файл
    const jsonContent = JSON.stringify(geoJSON, null, 2);
    const jsonBlob = new Blob([jsonContent], { type: 'application/json;charset=utf-8;' });
    const jsonUrl = URL.createObjectURL(jsonBlob);
    const jsonLink = document.createElement('a');
    jsonLink.href = jsonUrl;
    jsonLink.download = 'nspd.geojson';
    document.body.appendChild(jsonLink);
    jsonLink.click();
    document.body.removeChild(jsonLink);
    URL.revokeObjectURL(jsonUrl);

    // Скачиваем CSV
    nspdcsv(correctedContours);
}

function nspdcsv(correctedContours) {
    let csvContent = ""; // Без заголовка
    correctedContours.forEach(contour => {
        contour.forEach(([x, y]) => {
            csvContent += `${y} ${x}\n`; // Формат: Y X
        });
        csvContent += '\n'; // Пустая строка между контур
    });

    // Создаем и скачиваем файл
    const csvBlob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
    const csvUrl = URL.createObjectURL(csvBlob);
    const csvLink = document.createElement('a');
    csvLink.href = csvUrl;
    csvLink.download = 'nspd.csv';
    document.body.appendChild(csvLink);
    csvLink.click();
    document.body.removeChild(csvLink);
    URL.revokeObjectURL(csvUrl);
}



function handleZipFile(file, isAppend = false) {
    const reader = new FileReader();
    
    reader.onload = function(event) {
        const zipData = event.target.result;
        JSZip.loadAsync(zipData).then(function(zip) {
            let xmlFile = null;
            
            zip.forEach(function(relativePath, zipEntry) {
                if (relativePath.toLowerCase().endsWith('.xml')) {
                    xmlFile = zipEntry;
                }
            });
            
            if (xmlFile) {
                xmlFile.async("string").then(function(xmlContent) {
                    let coordinates;
                    if (xmlContent.includes('interact_entry_boundaries')) {
                        coordinates = extractCoordinatesFromInteractEntryBoundaries(xmlContent);
                    } else {
                        coordinates = extractCoordinatesFromXML(xmlContent);
                    }
                    
                    if (coordinates && coordinates.length > 0) {
                        if (isAppend) {
                            appendCoordinates(coordinates);
                        } else {
                            document.getElementById('coordsInput').value = coordinates.join('\n');
                            handleInput(true);
                        }
                        updateImportButtonText(file.name);
                    } else {
                        showNotification('Не удалось найти координаты в XML файле внутри архива');
                    }
                });
            } else {
                showNotification('XML файл не найден в архиве');
            }
        }).catch(function(err) {
            showNotification('Ошибка при разархивации ZIP файла');
            console.error('Ошибка разархивации:', err);
        });
    };
    
    reader.onerror = function() {
        showNotification('Ошибка при чтении ZIP файла');
    };
    
    reader.readAsArrayBuffer(file);
}



function handleXmlFile(file) {
    const reader = new FileReader();
    
    reader.onload = function(event) {
        const xmlContent = event.target.result;
        processXmlContent(xmlContent);
    };
    
    reader.onerror = function() {
        showNotification('Ошибка при чтении XML файла');
    };
    
    reader.readAsText(file, 'UTF-8');
}

function processXmlContent(xmlContent) {
    const coordinates = extractCoordinatesFromXML(xmlContent);
    
    if (coordinates.length > 0) {
        document.getElementById('coordsInput').value = coordinates.join('\n');
        handleInput(true); // true означает показывать уведомления
    } else {
        showNotification('Не удалось найти координаты в XML файле');
    }
}




function extractCoordinatesFromDXF(dxfContent) {
    const lines = dxfContent.split('\n');
    const coordinates = [];
    let currentContour = [];
    let isReadingCoords = false;
    let isPolyline = false;
    let isClosed = false;
    let x, y;

    for (let i = 0; i < lines.length; i++) {
        const line = lines[i].trim();

        if (line === 'POLYLINE') {
            isReadingCoords = true;
            isPolyline = true;
            isClosed = false;
            if (currentContour.length > 0) {
                processDXFContour(currentContour, coordinates, isClosed);
                currentContour = [];
            }
        } else if (line === 'LWPOLYLINE') {
            isReadingCoords = true;
            isPolyline = false;
            isClosed = false;
            if (currentContour.length > 0) {
                processDXFContour(currentContour, coordinates, isClosed);
                currentContour = [];
            }
        } else if (line === 'SEQEND') {
            isReadingCoords = false;
            if (currentContour.length > 0) {
                processDXFContour(currentContour, coordinates, isClosed);
                currentContour = [];
            }
        } else if (isReadingCoords) {
            if (line === '70') {
                isClosed = parseInt(lines[++i].trim()) === 1;
            } else if (isPolyline) { // Handling for POLYLINE -> VERTEX
                if (line === 'VERTEX') {
                    x = y = undefined;
                } else if (line === '10') {
                    x = parseFloat(lines[++i].trim());
                } else if (line === '20') {
                    y = parseFloat(lines[++i].trim());
                    if (x !== undefined && y !== undefined) {
                        // START OF CHANGE 1
                        if (x !== 0 && y !== 0) { // Ignore if x or y is 0
                            currentContour.push([Math.min(x, y), Math.max(x, y)]);
                        }
                        // END OF CHANGE 1
                        x = y = undefined;
                    }
                }
            } else { // Handling for LWPOLYLINE
                if (line === '10') {
                    x = parseFloat(lines[++i].trim());
                } else if (line === '20') {
                    y = parseFloat(lines[++i].trim());
                    if (x !== undefined && y !== undefined) {
                        // START OF CHANGE 2
                        if (x !== 0 && y !== 0) { // Ignore if x or y is 0
                           currentContour.push([Math.min(x, y), Math.max(x, y)]);
                        }
                        // END OF CHANGE 2
                        x = y = undefined;
                    }
                }
            }
        }
    }

    // Обработка последнего контура, если он есть
    if (currentContour.length > 0) {
        processDXFContour(currentContour, coordinates, isClosed);
    }

    return coordinates;
}

function processDXFContour(contour, coordinates, isClosed) {
    // Добавляем пустую строку перед новым контуром, если это не первый контур
    if (coordinates.length > 0) {
        coordinates.push('');
    }

    // Добавляем координаты контура
    contour.forEach(([x, y]) => {
        coordinates.push(`${x.toFixed(2)}\t${y.toFixed(2)}`);
    });

    // Если контур замкнут и первая точка не совпадает с последней, добавляем первую точку в конец
    if (isClosed && contour.length > 1) {
        const [firstX, firstY] = contour[0];
        const [lastX, lastY] = contour[contour.length - 1];
        if (firstX !== lastX || firstY !== lastY) {
            coordinates.push(`${firstX.toFixed(2)}\t${firstY.toFixed(2)}`);
        }
    }
}


function generateCSV(coords) {
    let csvContent = "Контур;Префикс номера;Номер;Старый X;Старый Y;Новый X;Новый Y;Метод определения;Формула;Радиус;Погрешность;Описание закрепления\n";
    csvContent += ";;;;;;;;;;;\n";

    let contourNumber = 1;
    let pointNumber = 1;
    let contour = [];

    coords.forEach((coord, index) => {
        if (coord.trim() === '') {
            // Завершаем текущий контур
            if (contour.length > 0) {
                csvContent += processContour(contour, contourNumber, pointNumber);
                contourNumber++;
                pointNumber = 1;
                contour = [];
                csvContent += ";;;;;;;;;;;\n"; // Пустая строка между контурами
            }
        } else {
            const [x, y] = coord.split(/\s+|\t/).map(Number);
            if (!isNaN(x) && !isNaN(y)) {
                contour.push([x, y]);
            } else {
                console.warn('Некорректные координаты:', coord);
            }
        }
    });

    // Обрабатываем последний контур, если он есть
    if (contour.length > 0) {
        csvContent += processContour(contour, contourNumber, pointNumber);
    }

    return csvContent;
}

function processContour(contour, contourNumber, startPointNumber) {
    let csvContent = '';
    const isClosed = (contour.length > 1 && contour[0][0] === contour[contour.length - 1][0] &&
                      contour[0][1] === contour[contour.length - 1][1]);
    
    contour.forEach(([x, y], index) => {
        if (index === contour.length - 1 && isClosed) {
            return; // Пропускаем последнюю точку, если она совпадает с первой
        }
        
        csvContent += `[${contourNumber}];н;${startPointNumber + index};;;${x.toFixed(2)};${y.toFixed(2)};;;;0,1;Долговременный межевой знак\n`;
    });

    // Добавляем первую точку в конец для замкнутого контура
    if (isClosed) {
        const [x, y] = contour[0];
        csvContent += `[${contourNumber}];н;${startPointNumber};;;${x.toFixed(2)};${y.toFixed(2)};;;;0,1;Долговременный межевой знак\n`;
    }

    return csvContent;
}


function extractCoordinatesFromMIF(mifContent) {
    const lines = mifContent.split('\n');
    const coordinates = [];
    let isDataSection = false;
    let currentContour = [];
    let pointsInContour = 0;
    let isRegionType = false;

    for (let i = 0; i < lines.length; i++) {
        const line = lines[i].trim();

        if (line === 'Data') {
            isDataSection = true;
            continue;
        }

        if (!isDataSection) continue;

        if (line.startsWith('Region')) {
            isRegionType = true;
            if (currentContour.length > 0) {
                coordinates.push(...currentContour, '');
                currentContour = [];
            }
            // Read the number of points for the region
            const numPointsMatch = line.match(/Region\s+\d+\s*(\d+)/);
            if (numPointsMatch && numPointsMatch[1]) {
                 pointsInContour = parseInt(numPointsMatch[1]);
            } else {
                 // If number of points is not on the same line, assume it's on the next line
                 if (i + 1 < lines.length) {
                     pointsInContour = parseInt(lines[i+1].trim());
                     if (!isNaN(pointsInContour)) {
                         i++; // Skip the next line as it was the point count
                     } else {
                         pointsInContour = 0; // Reset if parsing fails
                     }
                 } else {
                     pointsInContour = 0; // Reset if no next line
                 }
            }
            continue;
        }

        if (line.startsWith('PLINE')) {
            isRegionType = false;
            if (currentContour.length > 0) {
                coordinates.push(...currentContour, '');
                currentContour = [];
            }
            pointsInContour = parseInt(line.split(' ')[1]);
            continue;
        }

        // Check if the line contains coordinates (two numbers separated by space/tab/comma)
        const coordMatch = line.match(/^(\d+(?:[.,]\d+)?)\s*[,;\t]?\s*(\d+(?:[.,]\d+)?)$/);
        if (coordMatch) {
             const x = parseFloat(coordMatch[1].replace(',', '.'));
             const y = parseFloat(coordMatch[2].replace(',', '.'));

             if (!isNaN(x) && !isNaN(y)) {
                 currentContour.push(`${Math.min(x, y).toFixed(2)}\t${Math.max(x, y).toFixed(2)}`);

                 // For PLINE, we know the total points beforehand
                 if (!isRegionType && currentContour.length === pointsInContour) {
                     coordinates.push(...currentContour, '');
                     currentContour = [];
                     pointsInContour = 0; // Reset for next PLINE
                 }
                 // For Region, we don't know total points until we've read them all,
                 // or if they are specified on the Region line.
                 // The logic below handles the case where points are listed after the Region line.
             }
        } else if (line.startsWith('Pen') || line.startsWith('PEN') || line.startsWith('Point')) {
            // Ignore lines with pen settings or single points
            continue;
        } else if (isDataSection && line.trim() !== '') {
             // If we are in the Data section and the line is not empty,
             // but it's not a coordinate line or a known object type (Region/PLINE),
             // it might be a point count line for a Region object.
             const potentialPointCount = parseInt(line.trim());
             if (!isNaN(potentialPointCount) && isRegionType && pointsInContour === 0) {
                 pointsInContour = potentialPointCount;
             } else {
                 // If it's not a point count or coordinate, and we have a current contour,
                 // it might be the end of a contour followed by non-coordinate data.
                 if (currentContour.length > 0) {
                     coordinates.push(...currentContour, '');
                     currentContour = [];
                     pointsInContour = 0; // Reset
                 }
             }
        }
    }

    // Add the last contour if it exists and wasn't followed by a separator
    if (currentContour.length > 0) {
        coordinates.push(...currentContour);
    }

    // Remove trailing empty lines
    while (coordinates.length > 0 && coordinates[coordinates.length - 1] === '') {
        coordinates.pop();
    }

    return coordinates;
}

function processMIFContour(contour, coordinates) {
    // This function seems redundant now that MIF parsing is done in extractCoordinatesFromMIF
    // Keeping it for reference or if needed elsewhere, but it's not called by extractCoordinatesFromMIF
    console.warn("processMIFContour called - this might be unexpected.");
    // Add empty line before new contour if not the first
    if (coordinates.length > 0) {
        coordinates.push('');
    }

    // Check if contour is closed
    const isClosed = (contour.length > 1 && contour[0][0] === contour[contour.length - 1][0] &&
                      contour[0][1] === contour[contour.length - 1][1]);

    // Add contour coordinates
    contour.forEach(([x, y], index) => {
        if (index === contour.length - 1 && isClosed) {
            return; // Skip last point if it's a duplicate of the first in a closed contour
        }
        coordinates.push(`${x.toFixed(2)}\t${y.toFixed(2)}`);
    });

    // If closed, add the first point again to explicitly close it in the output format
    if (isClosed) {
        const [x, y] = contour[0];
        coordinates.push(`${x.toFixed(2)}\t${y.toFixed(2)}`);
    }
}



function extractCoordinatesFromText(content) {
    const lines = content.split('\n');
    const coordinates = [];
    const numberRegex = /[-+]?[0-9]*[.,]?[0-9]+/g;
    let lastLineHadCoordinates = false;

    for (let i = 0; i < lines.length; i++) {
        const line = lines[i].trim();
        
        if (line === '') {
             // If current line is empty and the previous one had coordinates,
             // it signifies the end of a contour.
            if (lastLineHadCoordinates && coordinates.length > 0 && coordinates[coordinates.length - 1] !== '') {
                coordinates.push('');
            }
            lastLineHadCoordinates = false; // Reset flag for empty line
            continue; // Skip empty lines
        }

        const numbers = line.match(numberRegex);
        const potentialCoords = numbers ? numbers.map(n => parseFloat(n.replace(',', '.')))
                                                 .filter(n => Math.abs(n) >= 10000)
                                        : [];

        if (potentialCoords.length >= 2) {
            const [x, y] = potentialCoords[0] < potentialCoords[1] 
                ? [potentialCoords[0], potentialCoords[1]]
                : [potentialCoords[1], potentialCoords[0]];

            coordinates.push(`${x.toFixed(2)}\t${y.toFixed(2)}`);
            lastLineHadCoordinates = true;
        } else {
            // If current line has text but no coordinates, and previous had coords,
            // it also signifies the end of a contour (text as description).
            if (lastLineHadCoordinates && coordinates.length > 0 && coordinates[coordinates.length - 1] !== '') {
                coordinates.push(''); // Add contour separator
            }
            lastLineHadCoordinates = false; // Reset flag as this line didn't have coords
        }
    }

    // Remove trailing empty lines
    while (coordinates.length > 0 && coordinates[coordinates.length - 1] === '') {
        coordinates.pop();
    }

    // If coordinates were found using the text parsing logic, return them.
    // Otherwise, try the importGeo logic as a fallback.
    // Note: This might be problematic if text contains both formats.
    // A better approach might be to try all parsers and merge results,
    // but that's more complex. For now, prioritize text/tab/description parsing,
    // then fall back to importGeo if nothing was found.
     const hasTextCoords = coordinates.some(c => c.trim() !== '');
     if (hasTextCoords) {
         return coordinates;
     } else {
         console.log("extractCoordinatesFromText: No text/tab/description coords found, trying importGeo.");
         return importGeo(content);
     }
}


    const expandLinearObject = document.getElementById('expandLinearObject');
    const widthDialog = document.getElementById('widthDialog');
    const widthInput = document.getElementById('widthInput');
    const applyWidth = document.getElementById('applyWidth');
    const cancelWidth = document.getElementById('cancelWidth');

    schemeButton.addEventListener('click', () => {
        schemeMenu.style.display = schemeMenu.style.display === 'none' ? 'block' : 'none';
    });

    expandLinearObject.addEventListener('click', () => {
        widthDialog.style.display = 'block';
    });

    cancelWidth.addEventListener('click', () => {
        widthDialog.style.display = 'none';
    });

    applyWidth.addEventListener('click', () => {
        const width = parseFloat(widthInput.value);
        if (isNaN(width) || width <= 0) {
            alert('Пожалуйста, введите положительное число для ширины.');
            return;
        }
        expandLinearObjectToArea(width);
        widthDialog.style.display = 'none';
    });




function generateDistancesCSV() {
    const input = document.getElementById('coordsInput').value.trim();
    const contours = input.split('\n\n').filter(contour => contour.trim() !== '');

    // Подготовка данных для Excel
    let data = [
        ['от точки', 'до точки', 'Горизонтальное проложение (S), м']
    ];
    let shortDistances = [];

    // Keep track of global point index
    let globalPointIndex = 0;

    contours.forEach((contour, contourIndex) => {
        const points = contour.split('\n').map(line => {
            const [x, y] = line.split(/\s+|\t/).map(Number);
            return { x, y };
        });

        // Skip empty contours
        if (points.length === 0) {
             return;
        }

        // Convert points array of objects back to string format for isContourClosed
        const pointsStringFormat = points.map(p => `${p.x}\t${p.y}`);

        // Проверяем, является ли контур замкнутым (первая и последняя точки совпадают с учетом погрешности)
        const isClosedContour = isContourClosed(pointsStringFormat);


        // Расчёт расстояний между последовательными точками
        // Iterate through all points. The segment is from points[i] to the next point.
        // The 'next point' wraps around for the last point if it's a closed contour.
        for (let i = 0; i < points.length; i++) {
            let next_i = (i + 1) % points.length; // Index of the next point (0 for the point after the last)

            // If it's a closed contour AND we are processing the segment from the last point (index points.length - 1)
            // back to the first point (index 0), skip this segment as per user request.
            // This check now correctly uses the tolerance-based isClosedContour
            if (isClosedContour && i === points.length - 1) {
                 continue;
            }

            const p1 = points[i];
            const p2 = points[next_i];

            const distance = calculateDistance(p1, p2);

            // Determine point numbers for the output (global index + 1)
            let pointNumber1 = globalPointIndex + i + 1;
            let pointNumber2;
            // If next_i is 0 (meaning we wrapped around from the last point to the first)
            // and the contour is closed, the second point is the *first* point of the contour.
            if (isClosedContour && next_i === 0) {
                 pointNumber2 = globalPointIndex + 1; // Global index of the first point
            } else {
                 // Otherwise, the second point is simply the next point in the sequence
                 pointNumber2 = globalPointIndex + next_i + 1;
            }


            data.push([{v: pointNumber1, t: 's'}, {v: pointNumber2, t: 's'}, Number(distance.toFixed(2))]);

            if (distance < 0.1) {
                shortDistances.push({
                    point1: pointNumber1,
                    point2: pointNumber2,
                    distance: Number(distance.toFixed(2)),
                    x1: p1.x,
                    y1: p1.y,
                    x2: p2.x,
                    y2: p2.y
                });
            }
        }

        // Update global point index for the next contour
        globalPointIndex += points.length;


        // Добавляем пустую строку между контурами (только если это не последний контур)
        if (contourIndex < contours.length - 1) {
            data.push([]);
        }
    });

    // Добавляем три пустые строки
    data.push([]);
    data.push([]);
    data.push([]);

    // Добавляем информацию о коротких расстояниях
    if (shortDistances.length > 0) {
        data.push(['Расстояние менее 10 см:']);
        data.push([]); // Пустая строка

        shortDistances.forEach(dist => {
            data.push([
                {v: dist.point1, t: 's'},
                {v: dist.point2, t: 's'},
                dist.distance,
                '',  // Пустая колонка для разделения
                dist.x1.toFixed(2),
                dist.y1.toFixed(2),
                dist.x2.toFixed(2),
                dist.y2.toFixed(2)
            ]);
        });
    } else {
        data.push(['Расстояний между точками менее 10 см не обнаружено']);
    }

    // Создаем рабочую книгу
    const wb = XLSX.utils.book_new();
    const ws = XLSX.utils.aoa_to_sheet(data);

    // Настройка стилей и форматирования
    ws['!cols'] = [
        { wch: 10 }, // от точки
        { wch: 10 }, // до точки
        { wch: 30 }, // расстояние
        { wch: 5 },  // пустой разделитель
        { wch: 15 }, // x1
        { wch: 15 }, // y1
        { wch: 15 }, // x2
        { wch: 15 }  // y2
    ];

    // Добавляем заголовки для координат в секции коротких расстояний
    if (shortDistances.length > 0) {
        // Find the row index where short distances start
        let shortDistancesStartRow = -1;
        for(let i = 0; i < data.length; i++) {
                if (data[i] && data[i][0] === 'Расстояние менее 10 см:') {
                shortDistancesStartRow = i + 2; // Header is 2 rows below the title
                break;
            }
        }

        if (shortDistancesStartRow !== -1) {
            const headerCell1 = XLSX.utils.encode_cell({ r: shortDistancesStartRow -1 , c: 4 }); // Row above first data row
            const headerCell2 = XLSX.utils.encode_cell({ r: shortDistancesStartRow -1, c: 5 });
            const headerCell3 = XLSX.utils.encode_cell({ r: shortDistancesStartRow -1, c: 6 });
            const headerCell4 = XLSX.utils.encode_cell({ r: shortDistancesStartRow -1, c: 7 });

            ws[headerCell1] = { v: 'X1', t: 's' };
            ws[headerCell2] = { v: 'Y1', t: 's' };
            ws[headerCell3] = { v: 'X2', t: 's' };
            ws[headerCell4] = { v: 'Y2', t: 's' };
        }
    }

    // Применяем числовой формат для колонок с числами
    for (let i = 1; i < data.length; i++) {
        const row = data[i];
        if (row && row.length > 0) {
            // Format distance column (column index 2)
            const distCellRef = XLSX.utils.encode_cell({ r: i, c: 2 });
            if (ws[distCellRef] && typeof ws[distCellRef].v === 'number') {
                ws[distCellRef].z = '0.00';
            }

            // Format coordinate columns (indices 4 to 7) in the short distances section
            // Check if this row is part of the short distances section
             let isShortDistanceRow = false;
             if (shortDistances.length > 0) {
                 const shortDistancesDataStartRow = data.findIndex(row => row && row[0] === 'Расстояние менее 10 см:') + 2; // Ensure row is not null/undefined
                 if (i >= shortDistancesDataStartRow && i < shortDistancesDataStartRow + shortDistances.length) {
                     isShortDistanceRow = true;
                 }
             }

             if (isShortDistanceRow) {
                 for (let j = 4; j <= 7; j++) {
                     const coordCellRef = XLSX.utils.encode_cell({ r: i, c: j });
                     // Check if the cell exists and contains a number before formatting
                     if (ws[coordCellRef] && typeof ws[coordCellRef].v === 'number') {
                         ws[coordCellRef].z = '0.00';
                     }
                 }
             }
        }
    }


    // Add sheet to workbook and save file
    XLSX.utils.book_append_sheet(wb, ws, 'Расстояния');
    XLSX.writeFile(wb, 'distances.xlsx');
}

function downloadCSV(content, fileName) {
    const bom = '\uFEFF'; // BOM для корректного отображения кириллицы
    const blob = new Blob([bom + content], { type: 'text/plain;charset=utf-8;' });
    const link = document.createElement('a');
    link.href = URL.createObjectURL(blob);
    link.download = fileName;
    link.style.display = 'none';
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
}

function calculateDistance(point1, point2) {
    const dx = point2.x - point1.x;
    const dy = point2.y - point1.y;
    return Math.sqrt(dx * dx + dy * dy);
}



function convertAreaToLinear() {
    const coordsInput = document.getElementById('coordsInput');
    const inputText = coordsInput.value.trim();
    const schemeMenu = document.getElementById('schemeMenu');

    // 1. Получаем первый контур из поля ввода
    const contours = inputText.split('\n\n');
    if (!contours || contours.length === 0 || !contours[0].trim()) {
        alert('Нет координат для обработки. Вставьте координаты площадного объекта.');
        if(schemeMenu) schemeMenu.style.display = 'none';
        return;
    }
    const firstContourStr = contours[0].trim();
    const firstContourLines = firstContourStr.split('\n');

    // 2. Проверяем, является ли он замкнутым
    if (!isContourClosed(firstContourLines)) {
        alert('Первый объект не является площадным (замкнутым). Эта функция работает только с замкнутыми контурами.');
        if(schemeMenu) schemeMenu.style.display = 'none';
        return;
    }

    // 3. Парсим точки и убираем последнюю (замыкающую) точку для расчетов
    const points = firstContourLines.map(coord => {
        const parts = coord.split(/\s+|\t/);
        return { x: parseFloat(parts[0].replace(',', '.')), y: parseFloat(parts[1].replace(',', '.')) };
    });

    const uniquePoints = points.slice(0, -1);

    // 4. Проверяем, что количество вершин четное (обязательно для нахождения парных точек)
    if (uniquePoints.length % 2 !== 0) {
        alert('Не удалось определить парные точки. Количество вершин в полигоне (без замыкающей) должно быть четным.');
        if(schemeMenu) schemeMenu.style.display = 'none';
        return;
    }

    // 5. Вычисляем центральную линию
    const n = uniquePoints.length / 2;
    const centerlinePoints = [];
    for (let i = 0; i < n; i++) {
        const p1 = uniquePoints[i];
        // Находим симметричную точку с другого конца массива
        const p2 = uniquePoints[uniquePoints.length - 1 - i];
        
        const midPoint = {
            x: (p1.x + p2.x) / 2,
            y: (p1.y + p2.y) / 2
        };
        centerlinePoints.push(midPoint);
    }

    // 6. Форматируем результат и добавляем в поле ввода
    const newCoordsString = centerlinePoints.map(p => `${p.x.toFixed(2)}\t${p.y.toFixed(2)}`).join('\n');
    
    const separator = coordsInput.value.trim() ? '\n\n' : '';
    coordsInput.value += separator + newCoordsString;

    // 7. Обновляем чертеж и выводим уведомление
    handleInput(true);
    showNotification('Создан линейный объект из первого площадного.');
    
    if(schemeMenu) schemeMenu.style.display = 'none';
}


function expandLinearObjectToArea(width) {
    const coordsInput = document.getElementById('coordsInput');
    const inputText = coordsInput.value.trim();
    const halfWidth = width / 2.0; // Смещение в каждую сторону

    // Векторные операции
    const vecSubtract = (a, b) => ({ x: a.x - b.x, y: a.y - b.y });
    const vecAdd = (a, b) => ({ x: a.x + b.x, y: a.y + b.y });
    const vecScale = (v, s) => ({ x: v.x * s, y: v.y * s });
    const vecLength = (v) => Math.sqrt(v.x * v.x + v.y * v.y);
    const vecNormalize = (v) => {
        const len = vecLength(v);
        return len > 0.00001 ? vecScale(v, 1 / len) : { x: 0, y: 0 };
    };
    // Перпендикулярный вектор (поворот на 90 градусов против часовой стрелки)
    const vecPerpendicular = (v) => ({ x: -v.y, y: v.x });

    // --- Получение и проверка точек первого контура ---
    const contours = inputText.split('\n\n');
    if (!contours || contours.length === 0) {
         alert('Нет координат для обработки.');
         return;
    }
    const firstContourStr = contours[0].trim();
     if (!firstContourStr) {
        alert('Первый контур пуст.');
        return;
    }
    const coords = firstContourStr.split('\n');
    if (coords.length < 2) {
        alert('Недостаточно точек (минимум 2) в первом контуре для создания утолщения.');
        return;
    }

    // Парсинг точек
    const points = coords.map(coord => {
        const parts = coord.split(/\s+|\t/);
        if (parts.length >= 2) {
            const xStr = parts[0].replace(',', '.');
            const yStr = parts[1].replace(',', '.');
            const x = parseFloat(xStr);
            const y = parseFloat(yStr);
            if (!isNaN(x) && !isNaN(y)) return { x, y };
        }
        return null;
    }).filter(p => p !== null);

    if (points.length < 2) {
        alert('Недостаточно валидных точек (минимум 2) в первом контуре.');
        return;
    }

    // Проверка, не замкнут ли уже контур
    const firstP = points[0];
    const lastP = points[points.length - 1];
    const tolerance = 0.001;
    if (Math.abs(firstP.x - lastP.x) < tolerance && Math.abs(firstP.y - lastP.y) < tolerance) {
         alert('Первый объект уже является замкнутым (площадным). Утолщение применяется к линейным объектам.');
         return;
    }

    // --- Вычисление точек смещения ---
    const leftPoints = [];
    const rightPoints = [];

    for (let i = 0; i < points.length; i++) {
        const p_curr = points[i];
        let normal;

        if (i === 0) {
            // Начальная точка: используем нормаль первого сегмента
            const p_next = points[i + 1];
            const segmentVec = vecSubtract(p_next, p_curr);
            normal = vecNormalize(vecPerpendicular(segmentVec));
        } else if (i === points.length - 1) {
            // Конечная точка: используем нормаль последнего сегмента
            const p_prev = points[i - 1];
            const segmentVec = vecSubtract(p_curr, p_prev); // Направление то же
            normal = vecNormalize(vecPerpendicular(segmentVec));
        } else {
            // Внутренняя точка (угол): усредняем нормали соседних сегментов
            const p_prev = points[i - 1];
            const p_next = points[i + 1];

            const vecIn = vecNormalize(vecSubtract(p_curr, p_prev));
            const vecOut = vecNormalize(vecSubtract(p_next, p_curr));

            const normalIn = vecPerpendicular(vecIn);
            const normalOut = vecPerpendicular(vecOut);

            // Усредненная нормаль (направление биссектрисы угла между нормалями)
            // Суммируем и нормализуем
            normal = vecNormalize(vecAdd(normalIn, normalOut));

             // Коррекция длины для острых углов (Miter join adjustment)
            // Вычисляем косинус половины угла между сегментами (через скалярное произведение нормалей)
            // dot product = cos(angle between normals)
            let dot = normalIn.x * normalOut.x + normalIn.y * normalOut.y;
            // Ограничиваем dot product в диапазоне [-1, 1] для избежания ошибок acos
             dot = Math.max(-1.0, Math.min(1.0, dot));
             // Угол между нормалями = угол между сегментами
             // Половина угла для miter join: angle/2
             // cos(angle/2) = sqrt((1 + cos(angle))/2)
             let cosHalfAngle = Math.sqrt((1.0 + dot) / 2.0);

             // Если угол очень маленький (почти прямая линия) или развернутый, используем простую нормаль
             // и избегаем деления на ноль или очень маленькое число
             if (cosHalfAngle < 0.1) {
                 // Если угол почти 180 градусов, нормали почти противоположны, их сумма ~0.
                 // В этом случае просто используем нормаль одного из сегментов.
                 normal = normalIn; // или normalOut
             }
             // else { // Эта коррекция длины может давать слишком большие выступы на острых углах
                 // miterScale = 1.0 / cosHalfAngle; // Масштаб для смещения вдоль биссектрисы
             // }
             // Пока оставим без коррекции масштаба для простоты, можно добавить позже если нужно
        }

        // Добавляем смещенные точки
        leftPoints.push(vecAdd(p_curr, vecScale(normal, halfWidth)));
        rightPoints.push(vecAdd(p_curr, vecScale(normal, -halfWidth))); // или vecSubtract
    }

    // --- Формирование полигона ---
    // Идем по левым точкам вперед, затем по правым точкам назад
    const polygonPoints = [
        ...leftPoints,          // L1, L2, ..., Ln
        ...rightPoints.reverse() // Rn, Rn-1, ..., R1
    ];

    // Замыкаем полигон, добавляя первую левую точку в конец
    polygonPoints.push(leftPoints[0]);

    // --- Форматирование и добавление в поле ввода ---
    const newCoordsArray = polygonPoints.map(p => `${p.x.toFixed(2)}\t${p.y.toFixed(2)}`);
    const newCoordsString = newCoordsArray.join('\n');

    const separator = coordsInput.value.trim() ? '\n\n' : '';
    coordsInput.value += separator + newCoordsString;

    // Обновляем отображение
    handleInput(true);
    showNotification(`Создан площадной объект толщиной ${width}м из первого линейного.`);
}



function checkDistances() {
    const input = document.getElementById('coordsInput').value.trim();
    if (!input) {
        showNotification('Нет координат для проверки расстояний.');
        return;
    }

    const contours = input.split('\n\n').filter(contour => contour.trim() !== '');
    let shortDistances = [];
    
    contours.forEach((contour) => {
        const points = contour.split('\n').map(line => {
            const [x, y] = line.split(/\s+|\t/).map(Number);
            return { x, y };
        });

        // Convert points array of objects back to string format for isContourClosed
        const pointsStringFormat = points.map(p => `${p.x}\t${p.y}`);

        const isClosedContour = isContourClosed(pointsStringFormat);

        const segmentsToProcess = isClosedContour ? points.length : points.length - 1;

        for (let i = 0; i < segmentsToProcess; i++) {
            const p1 = points[i];
            const p2 = points[(i + 1) % points.length]; // Use modulo for closed contours

             // Skip the last segment if it's a duplicate closing segment in a closed contour
             // This check now correctly uses the tolerance-based isClosedContour
            if (isClosedContour && i === points.length - 1) {
                 continue;
            }

            const distance = calculateDistance(p1, p2);
            if (distance < 0.1) {
                shortDistances.push({
                    point1: i + 1, // Point number within the contour
                    point2: (i + 1) % points.length + 1, // Next point number within the contour
                    distance: distance
                });
            }
        }
    });

    // Remove existing notification if any
    const existingNotification = document.getElementById('distanceNotification');
    if (existingNotification) {
        document.body.removeChild(existingNotification);
    }

    const notification = document.createElement('div');
    notification.id = 'distanceNotification';
    notification.style.position = 'fixed';
    notification.style.top = '20px';
    notification.style.left = '50%';
    notification.style.transform = 'translateX(-50%)';
    notification.style.padding = '15px';
    notification.style.borderRadius = '5px';
    notification.style.cursor = 'pointer';
    notification.style.zIndex = '1000';
    notification.style.boxShadow = '0 2px 5px rgba(0,0,0,0.2)';

    if (shortDistances.length === 0) {
        notification.style.backgroundColor = '#4CAF50'; // Green
        notification.style.color = 'white';
        notification.textContent = 'Расстояний между точками менее 10 см нет';

        // Add click handler to generate CSV even if no short distances
        notification.addEventListener('click', () => {
            generateDistancesCSV();
            document.body.removeChild(notification);
        });

    } else {
         notification.style.backgroundColor = '#ff9800'; // Orange
         notification.style.color = 'white';
         notification.textContent = `Обнаружено ${shortDistances.length} расстояний менее 10 см. Нажмите для создания отчета.`;

         // Add click handler to generate CSV
         notification.addEventListener('click', () => {
             generateDistancesCSV();
             document.body.removeChild(notification);
         });
    }

    // Add notification to the page
    document.body.appendChild(notification);

    // Remove notification after 10 seconds
    setTimeout(() => {
        if (document.body.contains(notification)) {
            document.body.removeChild(notification);
        }
    }, 10000);

     // Hide scheme menu
     document.getElementById('schemeMenu').style.display = 'none';
}


function generateTXTFile() {
    const startNumberInput = prompt("Укажите первый номер для точки (например, 501):");
    if (startNumberInput === null) { // Handle Cancel button
        document.getElementById('schemeMenu').style.display = 'none'; // Hide menu
        return;
    }
    const startNumber = parseInt(startNumberInput);

    if (isNaN(startNumber) || startNumber <= 0) {
        alert("Пожалуйста, введите корректный положительный номер.");
        document.getElementById('schemeMenu').style.display = 'none'; // Hide menu
        return;
    }

    const input = document.getElementById('coordsInput').value.trim();
    if (!input) {
        alert("Нет координат для обработки.");
        document.getElementById('schemeMenu').style.display = 'none'; // Hide menu
        return;
    }

    const coords = input.split('\n').filter(line => line.trim() !== '');
    let currentNumber = startNumber;
    let txtContent = "";

    coords.forEach(coord => {
        const [x, y] = coord.split(/\s+|\t/).map(Number);
        if (!isNaN(x) && !isNaN(y)) {
            txtContent += `${currentNumber},${x.toFixed(2)},${y.toFixed(2)}\n`;
            currentNumber++;
        }
    });

    if (txtContent) {
        const blob = new Blob([txtContent], { type: 'text/plain;charset=utf-8' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `points_from_${startNumber}.txt`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
        
        showNotification(`Файл TXT с номерами от ${startNumber} создан и загружен`);
    } else {
        showNotification("Не удалось создать TXT файл: нет валидных координат");
    }

    // Скрываем меню после выполнения
    document.getElementById('schemeMenu').style.display = 'none';
}




async function handleTextareaPaste(event) {
    const items = (event.clipboardData || window.clipboardData).items;
    let imageFile = null;
    const aiLoader = document.getElementById('aiLoader');
    const inputElement = this;

    for (let i = 0; i < items.length; i++) {
        if (items[i].type.indexOf("image") !== -1) {
            imageFile = items[i].getAsFile();
            break;
        }
    }
    if (imageFile) {
        event.preventDefault();
        if (aiLoader) aiLoader.style.display = 'flex';
        const tempImg = new Image();
        const objectURL = URL.createObjectURL(imageFile);
        let imageDataToSendToAI;
        tempImg.onload = async () => {
            URL.revokeObjectURL(objectURL);
            if (tempImg.width > 800 || tempImg.height > 800) {
                try {
                    const cropResult = await showCropModalScheme(imageFile);
                    imageDataToSendToAI = cropResult.data;
                } catch (cropError) {
                    imageDataToSendToAI = (await fileToBase64(imageFile)).split(',')[1];
                }
            } else {
                imageDataToSendToAI = (await fileToBase64(imageFile)).split(',')[1];
            }
            try {
                const extractedCoordsText = await getCoordinatesFromImageAI(imageDataToSendToAI);
                if (extractedCoordsText && extractedCoordsText.trim() !== "") {
                    const cleanedCoords = cleanAndFormatAICoordinates(extractedCoordsText);
                    if (cleanedCoords.trim() !== "") {
                        inputElement.value = cleanedCoords;
                        handleInput(true);
                        showNotification('Координаты извлечены из изображения!');
                    } else {
                        showNotification('Не удалось извлечь валидные координаты');
                    }
                } else {
                    showNotification('Не удалось извлечь координаты из изображения');
                }
            } catch (error) {
                showNotification('Ошибка AI: ' + error.message);
            } finally {
                if (aiLoader) aiLoader.style.display = 'none';
            }
        };
        tempImg.src = objectURL;
    } else {
        event.preventDefault();
        let pastedText = (event.clipboardData || window.clipboardData).getData('text');
        const modifiedText = pastedText.replace(/,/g, '.');
        const start = inputElement.selectionStart;
        const end = inputElement.selectionEnd;
        inputElement.value = inputElement.value.substring(0, start) + modifiedText + inputElement.value.substring(end);
        inputElement.selectionStart = inputElement.selectionEnd = start + modifiedText.length;
        handleInput(true, false);
    }
}
    


// Функция для автоматического добавления разделителей между контурами
function addContourSeparators(coordinatesText) {
    console.log("=== Starting addContourSeparators ===");
    console.log("Input text:", coordinatesText);
    
    if (!coordinatesText || coordinatesText.trim() === '') {
        console.log("Empty input, returning as is");
        return coordinatesText;
    }
    
    const lines = coordinatesText.split('\n').filter(line => line.trim() !== '');
    console.log("Lines after filtering:", lines);
    console.log("Total lines count:", lines.length);
    
    if (lines.length <= 1) {
        console.log("Only 1 or fewer lines, returning as is");
        return coordinatesText;
    }
    
    const result = [];
    
    for (let i = 0; i < lines.length; i++) {
        const currentLine = lines[i].trim();
        console.log(`\n--- Processing line ${i}: "${currentLine}"`);
        
        result.push(currentLine);
        
        // Ищем замыкание контура: текущая координата повторяется в предыдущих строках
        // и после неё идет следующая координата (т.е. это не последняя строка)
        if (i < lines.length - 1) {
            console.log(`Not last line (${i} < ${lines.length - 1}), checking for duplicates`);
            
            // Ищем первое вхождение текущей координаты
            const firstOccurrenceIndex = lines.findIndex(line => line.trim() === currentLine);
            console.log(`First occurrence of "${currentLine}" at index: ${firstOccurrenceIndex}`);
            console.log(`Current index: ${i}`);
            
            // Если текущая координата уже встречалась ранее (не первое вхождение)
            // и между первым и текущим вхождением есть другие координаты
            if (firstOccurrenceIndex >= 0 && firstOccurrenceIndex < i && i - firstOccurrenceIndex >= 2) {
                console.log(`✓ Adding separator! Conditions met:`);
                console.log(`  - firstOccurrenceIndex >= 0: ${firstOccurrenceIndex >= 0}`);
                console.log(`  - firstOccurrenceIndex < i: ${firstOccurrenceIndex} < ${i} = ${firstOccurrenceIndex < i}`);
                console.log(`  - i - firstOccurrenceIndex >= 2: ${i} - ${firstOccurrenceIndex} = ${i - firstOccurrenceIndex} >= 2 = ${i - firstOccurrenceIndex >= 2}`);
                
                // Добавляем пустую строку как разделитель контуров
                result.push('');
            } else {
                console.log(`✗ No separator added. Conditions:`);
                console.log(`  - firstOccurrenceIndex >= 0: ${firstOccurrenceIndex >= 0}`);
                console.log(`  - firstOccurrenceIndex < i: ${firstOccurrenceIndex} < ${i} = ${firstOccurrenceIndex < i}`);
                console.log(`  - i - firstOccurrenceIndex >= 2: ${i} - ${firstOccurrenceIndex} = ${i - firstOccurrenceIndex} >= 2 = ${i - firstOccurrenceIndex >= 2}`);
            }
        } else {
            console.log(`Last line (${i} >= ${lines.length - 1}), skipping duplicate check`);
        }
        
        console.log(`Result so far (length ${result.length}):`, result);
    }
    
    const finalResult = result.join('\n');
    console.log("=== Final result ===");
    console.log(finalResult);
    console.log("=== End addContourSeparators ===");
    
    return finalResult;
}




    </script>
</body>