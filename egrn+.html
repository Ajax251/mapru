<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ЕГРН</title>
    <link rel="icon" href="img/savannah.png" type="image/png">
    <link rel="stylesheet" href="webfonts/all.min.css">
     <script src="webfonts/proj4.js"></script>
<script src="webfonts/jspdf.umd.min.js"></script>
<script src="webfonts/jszip.min.js"></script>
<script src="webfonts/html2canvas.min.js"></script>
<script src="webfonts/xlsx.full.min.js"></script>

    <style>
   
   :root {
        --primary-color: #2196F3;
        --secondary-color: #f5f5f5;
        --border-color: #e0e0e0;
        --text-color: #333;
        --spacing: 20px;
    }

    /* Анимации */
    @keyframes fadeIn {
        from { opacity: 0; transform: translateY(-20px); }
        to { opacity: 1; transform: translateY(0); }
    }

    @keyframes slideIn {
        from { transform: translateX(-100%); opacity: 0; }
        to { transform: translateX(0); opacity: 1; }
    }

    body {
        font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        margin: 0;
        padding: var(--spacing);
        background-color: #fafafa;
        color: var(--text-color);
        animation: fadeIn 0.8s ease-out;
    }

    .search-container {
        background: linear-gradient(145deg, #ffffff, #f0f0f0);
        padding: var(--spacing);
        border-radius: 8px;
        box-shadow: 0 8px 15px rgba(0,0,0,0.1);
        margin-bottom: var(--spacing);
        animation: slideIn 0.8s ease-out;
    }

    .search-box {
        display: flex;
        gap: 15px;
        align-items: center;
        position: relative;
        padding: 5px;
    }

    input[type="text"] {
        flex: 1;
        font-size: 18px;
        padding: 15px 20px;
        border: 2px solid var(--border-color);
        border-radius: 25px;
        transition: all 0.3s ease;
        text-align: center;
        box-shadow: inset 0 1px 3px rgba(0,0,0,0.1);
        margin-right: 10px;
        min-width: 0;
    }

    input[type="text"]:focus {
        outline: none;
        border-color: var(--primary-color);
        box-shadow: 0 0 0 3px rgba(33, 150, 243, 0.2);
        transform: scale(1.02);
    }

  button {
    flex-shrink: 0;
    border-radius: 50%;
    width: 50px;
    height: 50px;
    color: white;
    border: none;
    cursor: pointer;
    transition: all 0.3s ease;
    display: flex;
    align-items: center;
    justify-content: center;
    box-shadow: 0 4px 6px rgba(0, 0, 0, 0.2);
    position: relative;
    overflow: hidden;
}

button i {
    font-size: 18px;
    transition: transform 0.3s ease;
}

button:hover {
    transform: translateY(-2px);
    box-shadow: 0 6px 10px rgba(0, 0, 0, 0.3);
}

button:hover i {
    transform: scale(1.2);
}

button:active {
    transform: translateY(0);
    box-shadow: 0 3px 6px rgba(0, 0, 0, 0.2);
}

/* Эффект "нажатия" (ripple) */
button:active::after {
    content: '';
    position: absolute;
    top: 50%;
    left: 50%;
    width: 300%;
    height: 300%;
    background: rgba(255, 255, 255, 0.4);
    transform: translate(-50%, -50%) scale(0);
    border-radius: 50%;
    animation: ripple 0.6s ease;
}

@keyframes ripple {
    to {
        transform: translate(-50%, -50%) scale(1);
        opacity: 0;
    }
}

/* Цвета кнопок из варианта 2 */
button.search-button {
    background: linear-gradient(145deg, #4CAF50, #45a049);
}

button.map-button {
  background: linear-gradient(145deg, #9C27B0, #7B1FA2);

}

button.coordinates-button {
     background: linear-gradient(145deg, #FF9800, #F57C00); 
}

button.keyboard-button {
    background: linear-gradient(145deg, #6395ee, #6395ee);
}

button.yandex-map-button {
    background: linear-gradient(145deg, #FF4444, #CC0000); /* Градиентный красный цвет */
}

button.yandex-map-button:hover {
    background: linear-gradient(145deg, #CC0000, #FF4444); /* Инвертированный градиент при наведении */
}

button.yandex-map-button:active {
    background: linear-gradient(145deg, #CC0000, #FF4444); /* Градиент при нажатии */
}


    .content-container {
        display: none;
        grid-template-columns: 1fr 1fr;
        gap: var(--spacing);
        height: calc(100vh - 150px);
    }

    .data-container {
        background: white;
        padding: var(--spacing);
        border-radius: 8px;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        overflow-y: auto;
    }

    .scheme-container {
        background: white;
        padding: var(--spacing);
        border-radius: 8px;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        position: relative; /* Добавляем для позиционирования "глаза" */
    }

    #schemeCanvas {
        width: 100%;
        height: 100%;
        border: 1px solid var(--border-color);
        border-radius: 4px;
    }
    
/* Стили для toggle */
.toggle-container {
    position: absolute;
    top: 20px;
    right: 20px;
    z-index: 10;
}

.toggle {
    display: none;
}

.toggle + label {
    display: inline-block;
    width: 55px;
    height: 28px;
    background-color: #fff;
    border-radius: 30px;
    position: relative;
    cursor: pointer;
    transition: background-color 0.3s ease;
}

.toggle + label:after {
    content: '';
    display: inline-block;
    position: absolute;
    width: 24px;
    height: 24px;
    background-color: #fff;
    top: 2px;
    left: 2px;
    border-radius: 50%;
    transition: all 0.3s ease;
}

.toggle:checked + label {
    background-color: #2196F3;
}

.toggle:checked + label:after {
    left: 29px;
}
    
    
    
    /* Toggle Specific styles */
input[type='checkbox'].toggle {
    display: inline-block;
    -webkit-appearance: none;
    -moz-appearance: none;
    appearance: none;
    width: 55px;
    height: 28px;
    background-color: #fafafa;
    position: relative;
    border-radius: 30px;
    box-shadow: none;
    transition: all 0.2s ease-in-out;
}

input[type='checkbox'].toggle:hover:after {
    background-color: #d1d1d1;
}

input[type='checkbox'].toggle:after {
    content: '';
    display: inline-block;
    position: absolute;
    width: 24px;
    height: 24px;
    background-color: #ccc;
    top: 2px;
    left: 2px;
    border-radius: 50%;
    transition: all 0.2s ease-in-out;
}

input[type='checkbox'].toggle:checked {
    box-shadow: inset 0 0 0 15px #158EC6;
}

input[type='checkbox'].toggle:checked:after {
    left: 29px;
    background-color: #fff;
}



    /* Стили для таблиц */
    table {
        width: 100%;
        border-collapse: collapse;
        margin-top: 10px;
        border-radius: 8px;
        overflow: hidden;
        box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        animation: fadeIn 0.8s ease-out;
    }

    th, td {
        padding: 15px;
        text-align: left;
        border-bottom: 1px solid var(--border-color);
        transition: background-color 0.3s ease;
    }

    th {
        background-color: var(--secondary-color);
        font-weight: 600;
    }

    tr:hover td {
        background-color: #f5f5f5;
    }

    /* Модальное окно */
    .modal {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0,0,0,0.5);
        z-index: 1000;
        animation: fadeIn 0.3s ease-out;
    }

    .modal-content {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: white;
        padding: 30px;
        border-radius: 15px;
        box-shadow: 0 10px 25px rgba(0,0,0,0.2);
        max-width: 600px;
        width: 90%;
        max-height: 80vh;
        overflow-y: auto;
        text-align: center;
    }

    #modalCoordinatesTable {
        width: 100%;
        border-collapse: collapse;
        margin-top: 20px;
    }

    #modalCoordinatesTable th,
    #modalCoordinatesTable td {
        text-align: center;
        padding: 12px;
        border: 1px solid var(--border-color);
    }

    #modalCoordinatesTable th {
        background-color: var(--secondary-color);
        font-weight: 600;
        text-align: center;
    }

    #modalCoordinatesTable tr:hover td {
        background-color: #f5f5f5;
    }

    .close-modal {
        position: absolute;
        top: 15px;
        right: 15px;
        font-size: 24px;
        cursor: pointer;
        color: #666;
        transition: color 0.3s ease;
    }

    .close-modal:hover {
        color: #333;
    }

    /* Уведомления */
    #notification-container {
        position: fixed;
        bottom: 20px;
        right: 20px;
        z-index: 1000;
        display: flex;
        flex-direction: column;
        gap: 10px;
    }

    .notification {
        background-color: #333;
        color: white;
        padding: 15px 20px;
        border-radius: 5px;
        box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        opacity: 0;
        transform: translateX(100%);
        transition: opacity 0.3s ease, transform 0.3s ease;
    }

    .notification.show {
        opacity: 1;
        transform: translateX(0);
    }

    .notification.success {
        background-color: #4CAF50;
    }

    .notification.error {
        background-color: #F44336;
    }

    .notification.info {
        background-color: #2196F3;
    }
    
     .notification.warning {
        background-color: #FF9800; /* Оранжевый цвет */
    }

    /* Стили для виртуальной клавиатуры */
    .virtual-keyboard {
        display: none;
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: #f5f5f5;
        padding: 20px;
        border-radius: 12px;
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        z-index: 1000;
    }

    .virtual-keyboard.active {
        display: block;
    }

    .keyboard-row {
        display: flex;
        justify-content: center;
        gap: 10px;
        margin-bottom: 10px;
    }

    .keyboard-key {
        width: 60px;
        height: 60px;
        display: flex;
        align-items: center;
        justify-content: center;
        background: #ffffff;
        border: 1px solid #ccc;
        border-radius: 8px;
        cursor: pointer;
        font-size: 20px;
        transition: background 0.3s ease, transform 0.1s ease;
    }

    .keyboard-key:hover {
        background: #e0e0e0;
    }

    .keyboard-key:active {
        background: #d0d0d0;
        transform: scale(0.95);
    }

    .keyboard-key.clear {
        background: #ff4444;
        color: white;
    }

    .keyboard-key.clear:hover {
        background: #cc0000;
    }

    .keyboard-key.enter {
        background: #4CAF50;
        color: white;
        flex-grow: 1;
    }

    .keyboard-key.enter:hover {
        background: #45a049;
    }

    .keyboard-key.enter:active {
        background: #3d8b40;
    }

    /* Стили для мобильной версии */
    @media (max-width: 768px) {
        .search-box {
            flex-direction: column;
            gap: 10px;
        }

        .search-box input[type="text"] {
            width: 100%;
            margin-right: 0;
        }

        .button-row {
            display: flex;
            gap: 10px;
            width: 100%;
        }

        .button-row button {
            flex: 1;
            border-radius: 8px;
        }

        .mobile-only {
            display: block;
        }

        .scheme-container {
            display: none;
        }

        .content-container {
            display: block !important;
            height: auto;
        }

        .data-container {
            width: 100%;
            margin-bottom: var(--spacing);
        }

        #resultTable {
            margin: 0;
        }
    }
    
@media (max-width: 768px) {
    .scheme-container {
        display: block; /* Показываем canvas по умолчанию */
        width: 100%; /* Занимает всю ширину */
        height: 300px; /* Фиксированная высота для мобильной версии */
        margin-bottom: var(--spacing); /* Добавляем отступ снизу */
    }

    .content-container {
        display: block !important;
        height: auto;
    }

    .data-container {
        width: 100%;
        margin-bottom: var(--spacing);
    }

    #resultTable {
        margin: 0;
    }
}
    /* Стили для десктопной версии */
    @media (min-width: 769px) {
        .search-box {
            flex-direction: row;
        }

        .button-row {
            display: flex;
            gap: 10px;
        }

        .mobile-only {
            display: none;
        }
    }
    
.convert-button {
    background: linear-gradient(145deg, #4CAF50, #45a049);
    color: white;
    border: none;
    padding: 15px 20px;
    border-radius: 5px;
    cursor: pointer;
    font-size: 16px;
    margin-bottom: 15px;
    transition: background 0.3s ease, transform 0.2s ease;
    width: 100%; /* Кнопка на всю ширину */
    box-sizing: border-box; /* Учитываем padding в ширине */
}

.convert-button:hover {
    background: linear-gradient(145deg, #45a049, #4CAF50);
    transform: translateY(-2px);
}

.convert-button:active {
    transform: translateY(0);
}

/* Стили для таблицы */
#resultTable {
    width: 100%;
    border-collapse: separate;
    border-spacing: 0;
    margin-top: 10px;
    border-radius: 12px;
    overflow: hidden;
    box-shadow: 0 6px 16px rgba(0,0,0,0.1);
    animation: tableAppear 0.6s ease-out;
    background: white;
}

@keyframes tableAppear {
    from {
        opacity: 0;
        transform: translateY(20px);
    }
    to {
        opacity: 1;
        transform: translateY(0);
    }
}

#resultTable tr {
    animation: rowFadeIn 0.5s ease-out;
    animation-fill-mode: both;
}

@keyframes rowFadeIn {
    from {
        opacity: 0;
        transform: translateX(-20px);
    }
    to {
        opacity: 1;
        transform: translateX(0);
    }
}

#resultTable tr:nth-child(even) {
    background-color: #f8f9fa;
}

#resultTable td {
    padding: 14px 18px;
    border-bottom: 1px solid rgba(0,0,0,0.05);
    transition: all 0.3s ease;
    line-height: 1.4;
}

#resultTable td:first-child {
    font-weight: 500;
    color: #2c3e50;
    width: 30%;
    position: relative;
}

#resultTable td:first-child::after {
    content: '';
    position: absolute;
    right: 0;
    top: 50%;
    transform: translateY(-50%);
    height: 70%;
    width: 1px;
    background: rgba(0,0,0,0.05);
}

#resultTable td:last-child {
    color: #34495e;
}

/* --- Стили для кнопки копирования в таблице --- */

#resultTable td:last-child {
    position: relative;
    /* Добавляем отступ справа, чтобы текст не заезжал под кнопку */
    padding-right: 40px; 
}

/* Стили самой кнопки-иконки */
.copy-icon-button {
    display: none; /* Скрыта по умолчанию */
    position: absolute;
    top: 50%;
    right: 8px; /* Немного ближе к краю */
    transform: translateY(-50%);
    /* --- ИЗМЕНЕНИЕ: Зеленый градиент --- */
    background: linear-gradient(145deg, #4CAF50, #45a049);
    color: white;
    border: none;
    /* --- ИЗМЕНЕНИЕ: Уменьшенный размер --- */
    width: 24px;
    height: 24px;
    border-radius: 50%;
    cursor: pointer;
    /* --- ИЗМЕНЕНИЕ: Уменьшенный размер иконки --- */
    font-size: 12px;
    transition: all 0.2s ease;
    align-items: center;
    justify-content: center;
    box-shadow: 0 1px 3px rgba(0,0,0,0.15);
    z-index: 5; /* Чтобы кнопка была поверх содержимого */
}

/* Показываем кнопку при наведении на любую строку таблицы */
#resultTable tr:hover .copy-icon-button {
    display: flex; 
}

.copy-icon-button:hover {
    /* --- ИЗМЕНЕНИЕ: Зеленый градиент при наведении --- */
    background: linear-gradient(145deg, #45a049, #4CAF50);
    transform: translateY(-50%) scale(1.1);
    box-shadow: 0 3px 6px rgba(0,0,0,0.2);
}

.copy-icon-button:active {
    transform: translateY(-50%) scale(1);
}

#resultTable tr:hover {
    background-color: #f1f4f6 !important;
    transform: translateX(5px);
    transition: all 0.3s ease;
}

/* Стили для значений в таблице */
#resultTable td strong {
    font-weight: 500;
    color: #2c3e50;
    display: inline-block;
    transition: all 0.3s ease;
}



/* Стили для мобильной версии */
@media (max-width: 768px) {
    #resultTable td {
        padding: 12px 15px;
    }

    #resultTable td:first-child {
        width: 40%;
    }

    #resultTable {
        font-size: 14px;
    }
}

/* Эффект появления для всей таблицы */
.data-container {
    perspective: 1000px;
}

#resultTable {
    transform-origin: top center;
    animation: tableReveal 0.6s ease-out;
}

@keyframes tableReveal {
    from {
        opacity: 0;
        transform: rotateX(-10deg);
    }
    to {
        opacity: 1;
        transform: rotateX(0);
    }
}

   .map-buttons {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }

        .map-buttons button {
            display: flex;
            align-items: center;
            gap: 5px;
            padding: 10px 15px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            transition: background 0.3s ease, transform 0.2s ease;
        }

        .map-buttons button:hover {
            transform: translateY(-2px);
        }

        .map-buttons button:active {
            transform: translateY(0);
        }

        .map-buttons .yandex-map-button {
            background: linear-gradient(145deg, #FF4444, #CC0000);
            color: white;
        }

        .map-buttons .google-map-button {
            background: linear-gradient(145deg, #4285F4, #357ABD);
            color: white;
        }
        
            /* Стили для контейнера кнопок */
        .button-container {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }

        .button-container button {
            flex: 1; /* Равная ширина для всех кнопок */
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 5px;
            padding: 10px 15px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            transition: background 0.3s ease, transform 0.2s ease;
        }

        .button-container button:hover {
            transform: translateY(-2px);
        }

        .button-container button:active {
            transform: translateY(0);
        }

        .button-container .convert-button {
            background: linear-gradient(145deg, #4CAF50, #45a049);
            color: white;
        }

        .button-container .yandex-map-button {
            background: linear-gradient(145deg, #FF4444, #CC0000);
            color: white;
        }

        .button-container .google-map-button {
            background: linear-gradient(145deg, #4285F4, #357ABD);
            color: white;
        }
        
          #modalCoordinatesTable th:first-child,
        #modalCoordinatesTable td:first-child {
            width: 50px; /* Ширина колонки с номером */
            text-align: center; /* Выравнивание по центру */
        }
        
        /* Стили для модального окна поиска */
/* Стили для модального окна поиска */
.search-modal-container {
    display: flex;
    flex-direction: column;
    gap: 20px;
    padding: 20px;
    width: 400px; /* Фиксированная ширина контейнера */
    margin: 0 auto; /* Центрирование */
}

#rightNumberInput {
    width: 100%; /* Поле ввода занимает всю ширину контейнера */
    font-size: 18px;
    padding: 15px 20px;
    border: 2px solid var(--border-color);
    border-radius: 25px;
    transition: all 0.3s ease;
    text-align: center;
    box-shadow: inset 0 1px 3px rgba(0,0,0,0.1);
    box-sizing: border-box; /* Учитываем padding в общей ширине */
}

.search-right-button {
    width: 100%; /* Кнопка занимает всю ширину контейнера */
    padding: 15px 20px;
    border-radius: 25px;
    background: linear-gradient(145deg, #4CAF50, #45a049);
    color: white;
    border: none;
    font-size: 16px;
    cursor: pointer;
    transition: all 0.3s ease;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 10px;
    box-sizing: border-box; /* Учитываем padding в общей ширине */
}

#rightNumberInput:focus {
    outline: none;
    border-color: var(--primary-color);
    box-shadow: 0 0 0 3px rgba(33, 150, 243, 0.2);
    transform: scale(1.02);
}


.search-right-button:hover {
    transform: translateY(-2px);
    box-shadow: 0 6px 10px rgba(0, 0, 0, 0.3);
}

.search-right-button:active {
    transform: translateY(0);
    box-shadow: 0 3px 6px rgba(0, 0, 0, 0.2);
}

#rightSearchTable {
    width: 100%;
    margin-top: 20px;
    border-collapse: collapse;
    background: white;
    border-radius: 8px;
    overflow: hidden;
    box-shadow: 0 4px 6px rgba(0,0,0,0.1);
}

#rightSearchTable td {
    padding: 12px 15px;
    border-bottom: 1px solid #e0e0e0;
}

#rightSearchTable td:first-child {
    font-weight: 500;
    width: 30%;
    color: #2c3e50;
}

#rightSearchTable td:last-child {
    color: #34495e;
}


/* Стили для кнопки "Единое землепользование" */
.ez-button {
    background: linear-gradient(145deg, #4CAF50, #45a049);
    color: white;
    border: none;
    padding: 10px 20px; /* Уменьшим отступы для компактности */
    border-radius: 8px; /* Закругленные углы */
    cursor: pointer;
    font-size: 16px;
    transition: background 0.3s ease, transform 0.2s ease;
    display: inline-flex; /* Используем inline-flex для компактного размера */
    align-items: center;
    justify-content: center;
    gap: 8px; /* Расстояние между иконкой и текстом */
    box-shadow: 0 4px 6px rgba(0, 0, 0, 0.2);
        width: 300px; /* Фиксированная ширина */
}

.ez-button:hover {
    background: linear-gradient(145deg, #45a049, #4CAF50);
    transform: translateY(-2px);
    box-shadow: 0 6px 10px rgba(0, 0, 0, 0.3);
}

.ez-button:active {
    transform: translateY(0);
    box-shadow: 0 3px 6px rgba(0, 0, 0, 0.2);
}

.ez-button i {
    font-size: 16px; /* Уменьшим размер иконки для пропорциональности */
}

.scheme-button {
    background: linear-gradient(145deg, #3F51B5, #303F9F);
    color: white;
    border: none;
    padding: 15px 20px;
    border-radius: 5px;
    cursor: pointer;
    font-size: 16px;
    transition: background 0.3s ease, transform 0.2s ease;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 8px;
}

.scheme-button:hover {
    background: linear-gradient(145deg, #303F9F, #3F51B5);
    transform: translateY(-2px);
}

.scheme-button:active {
    transform: translateY(0);
}

.copy-coordinates-button {
    background: linear-gradient(145deg, #2196F3, #1976D2);
    color: white;
    border: none;
    width: 36px;
    height: 36px;
    border-radius: 50%;
    cursor: pointer;
    font-size: 16px;
    transition: background 0.3s ease, transform 0.2s ease;
    display: flex;
    align-items: center;
    justify-content: center;
    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
    margin: 0   auto; /* Центрируем кнопку в ячейке */
}

.copy-coordinates-button:hover {
    background: linear-gradient(145deg, #1976D2, #2196F3);
    transform: translateY(-2px);
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
}

.copy-coordinates-button:active {
    transform: translateY(0);
    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
}

/* Стили для заголовка таблицы */
#modalCoordinatesTable th {
    padding: 12px 15px;
    text-align: center;
    background-color: var(--secondary-color);
    font-weight: 600;
}

/* Убираем стандартные отступы и рамки у кнопки в заголовке */
#modalCoordinatesTable th button {
    margin: 0;
    padding: 0;
    border: none;
    outline: none;
}


/* Контейнер для поля ввода и иконки */
.input-container {
    position: relative;
    flex: 1; /* Занимает всё доступное пространство */
    margin-right: 10px; /* Отступ от кнопок */
}

/* Поле ввода */
#cadastralNumber {
    width: 100%; /* Занимает всю ширину контейнера */
    font-size: 18px;
    padding: 15px 40px 15px 20px; /* Добавляем отступ справа для иконки */
    border: 2px solid var(--border-color);
    border-radius: 25px;
          transition: all 0.3s ease;
    text-align: center;
    box-shadow: inset 0 1px 3px rgba(0,0,0,0.1);
    box-sizing: border-box; /* Учитываем padding в ширине */
}

/* Контейнер для иконки */
.icon-container {
    position: absolute;
    top: 50%;
    right: 10px; /* Отступ от правого края */
    transform: translateY(-50%); /* Центрируем по вертикали */
    cursor: pointer;
    padding: 8px;
    border-radius: 50%;
    transition: background 0.3s ease;
}

.icon-container:hover {
    background: rgba(0, 0, 0, 0.1); /* Легкий эффект при наведении */
}

/* Стили для иконки */
.site-icon {
    width: 24px; /* Размер иконки */
    height: 24px;
    transition: filter 0.3s ease;
}

.icon-container:hover .site-icon {
    filter: grayscale(0%); /* Цветная иконка при наведении */
}

.keyboard-key.insert {
    background: linear-gradient(145deg, #BF00FF, #BF00FF);
    color: white;
}

.keyboard-key.insert:hover {
    background: linear-gradient(145deg, #BF00FF, #BF00FF);
}

.keyboard-key.insert:active {
    background: linear-gradient(145deg, #E64A19, #FF9800);
}

/* --- Styling for Batch Cadastral Modal --- */
#batchCadastralModal .modal-content {
    max-width: 500px; /* Slightly wider for the textarea */
    text-align: left; /* Align text left for better readability */
    padding: 25px; /* More padding */
}

#batchCadastralModal h4 {
    margin-top: 0;
    margin-bottom: 10px;
    color: var(--primary-color);
    text-align: center;
    font-size: 20px;
}

#batchCadastralModal p {
    text-align: center;
    color: #666;
    font-size: 14px;
    margin-bottom: 20px;
}

#cadastralListInput {
    width: 100%; /* Take full width */
    box-sizing: border-box; /* Include padding/border in width */
    min-height: 150px; /* Minimum height */
    font-size: 15px;
    padding: 12px;
    border: 1px solid var(--border-color);
    border-radius: 8px;
    margin-bottom: 20px;
    resize: vertical; /* Allow vertical resizing */
    line-height: 1.5;
    font-family: Consolas, monospace; /* Monospace font for better alignment */
    background-color: #fdfdfd;
    box-shadow: inset 0 1px 3px rgba(0,0,0,0.05);
}

#cadastralListInput:focus {
    outline: none;
    border-color: var(--primary-color);
    box-shadow: inset 0 1px 3px rgba(0,0,0,0.05), 0 0 0 2px rgba(33, 150, 243, 0.2);
}

#batchCadastralModal .button-container-modal {
     display: flex;
     justify-content: center; /* Center the button */
     width: 100%;
     gap: 15px; /* Add gap between buttons */
}

/* Style for both export buttons */
#exportCsvButton, #exportExcelButton {
    background: linear-gradient(145deg, #4CAF50, #45a049); /* Default green */
    color: white;
    border: none;
    padding: 12px 14px;
    border-radius: 8px;
    cursor: pointer;
    font-size: 18px;
    font-weight: 500;
    transition: background 0.3s ease, transform 0.2s ease, box-shadow 0.3s ease;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    gap: 8px;
    box-shadow: 0 4px 8px rgba(0,0,0,0.1);
    line-height: 1;
    flex-grow: 0; /* Prevent buttons from growing */
    flex-shrink: 0; /* Prevent buttons from shrinking */
}

/* Specific style for Excel button */
#exportExcelButton {
    background: linear-gradient(145deg, #2196F3, #1976D2); /* Blue for Excel */
}


#exportCsvButton:hover {
    background: linear-gradient(145deg, #45a049, #4CAF50);
    transform: translateY(-2px);
    box-shadow: 0 6px 12px rgba(0,0,0,0.15);
}

#exportExcelButton:hover {
    background: linear-gradient(145deg, #1976D2, #2196F3);
    transform: translateY(-2px);
    box-shadow: 0 6px 12px rgba(0,0,0,0.15);
}


#exportCsvButton:active, #exportExcelButton:active {
    transform: translateY(0);
    box-shadow: 0 3px 6px rgba(0,0,0,0.1);
}

#exportCsvButton:disabled, #exportExcelButton:disabled {
    background: #ccc;
    cursor: not-allowed;
    transform: none;
    box-shadow: none;
}

/* Explicitly style the icons if needed */
#exportCsvButton i, #exportExcelButton i {
    font-size: 20px; /* Control icon size directly */
    margin: 0; /* Remove any potential default margins */
    line-height: 1; /* Ensure consistent line height */
}


.progress-bar {
    width: 100%;
    height: 10px; /* Height of the progress bar line */
    background-color: #e0e0e0; /* Background track color */
    border-radius: 5px; /* Rounded corners for the track */
    overflow: hidden; /* Keep the fill inside */
    box-shadow: inset 0 1px 2px rgba(0,0,0,0.1);
}

.progress-bar-fill {
    height: 100%;
    width: 0%; /* Start with 0% width */
    background-color: #2196F3; /* Progress fill color (adjust as needed) */
    /* Optional: Nice gradient */
    background-image: linear-gradient(45deg, rgba(255,255,255,.15) 25%, transparent 25%, transparent 50%, rgba(255,255,255,.15) 50%, rgba(255,255,255,.15) 75%, transparent 75%, transparent);
    background-size: 40px 40px;
    border-radius: 5px; /* Match parent's rounding */
    transition: width 0.4s ease-in-out; /* Smooth width transition */
    animation: progress-bar-stripes 1s linear infinite; /* Animated stripes */
}

/* Animation for the stripes */
@keyframes progress-bar-stripes {
  from { background-position: 40px 0; }
  to { background-position: 0 0; }
}

/* Optional: Style for the text above the bar */
#progressBarContainer span {
    font-weight: 500;
}


</style>

</head>
<body>
     <div class="search-container">

<div class="search-box">
    <div class="input-container">
        <input type="text" id="cadastralNumber" placeholder="Кадастровый номер">
        <!-- Иконка внутри поля ввода -->
        <div class="icon-container" onclick="fetchDataFromArchive()">
            <img src="https://img.icons8.com/?size=100&id=107436&format=png&color=000000" alt="Open Site" class="site-icon">
        </div>
    </div>
    <div class="button-row">
        <button class="search-button" onclick="fetchData()">
            <i class="fas fa-search"></i>
        </button>
        <button class="coordinates-button" onclick="showCoordinates()">
            <i class="fas fa-compass"></i>
        </button>
        <button class="map-button" onclick="openMap()">
            <i class="fas fa-map"></i>
        </button>
        <button class="yandex-map-button" onclick="searchOnYandexMap()">
            <i class="fas fa-map-marked-alt"></i>
        </button>
        <button id="mobileKeyboardButton" class="keyboard-button mobile-only">
            <i class="fas fa-keyboard"></i>
        </button>
    </div>
</div>

<div class="virtual-keyboard" id="virtualKeyboard">
    <div class="keyboard-row">
        <div class="keyboard-key" data-key="1">1</div>
        <div class="keyboard-key" data-key="2">2</div>
        <div class="keyboard-key" data-key="3">3</div>
    </div>
    <div class="keyboard-row">
        <div class="keyboard-key" data-key="4">4</div>
        <div class="keyboard-key" data-key="5">5</div>
        <div class="keyboard-key" data-key="6">6</div>
    </div>
    <div class="keyboard-row">
        <div class="keyboard-key" data-key="7">7</div>
        <div class="keyboard-key" data-key="8">8</div>
        <div class="keyboard-key" data-key="9">9</div>
    </div>
    <div class="keyboard-row">
        <div class="keyboard-key" data-key="0">0</div>
          <div class="keyboard-key insert">Ins</div> 
        <div class="keyboard-key clear">C</div>
        <div class="keyboard-key enter" onclick="handleEnter()">Enter</div>

    </div>
</div>
<div class="content-container">
    <div class="data-container">
        <table id="resultTable" style="display:none;">
            <tbody></tbody>
        </table>
        <div id="ezLinkContainer" style="display: none; margin-top: 20px;">
            <button id="ezLink" class="ez-button" type="button">
                <i class="fas fa-link"></i> Единое землепользование
            </button>
        </div>
    </div>
   <div class="scheme-container">
 <div class="toggle-container">
    <input type="checkbox" id="distanceToggle" class="toggle" onclick="toggleDistanceLabels()">

</div>

    <canvas id="schemeCanvas"></canvas>
</div>
</div>


<!-- Модальное окно для координат -->
<div id="coordinatesModal" class="modal">
    <div class="modal-content">
        <!-- ВСТАВЬТЕ ЭТУ СТРОКУ ПРЯМО СЮДА -->
        <span class="close-modal">×</span>

        <!-- Контейнер для кнопок -->
        <div class="button-container">
            <button class="yandex-map-button" onclick="openYandexMaps()">
                <i class="fas fa-map-marked-alt"></i> Yandex
            </button>
            <button class="google-map-button" onclick="openGoogleMaps()">
                <i class="fab fa-google"></i> Google
            </button>
            <button class="convert-button" onclick="convertCoordinates()">
                <i class="fas fa-exchange-alt"></i> EPSG:3857
            </button>
            <button class="scheme-button" onclick="openSchemeMap()">
                <i class="fas fa-globe"></i> Карта
            </button>
        </div>

        <!-- Таблица с координатами -->
        <table id="modalCoordinatesTable">
            <thead>
                <tr>
                    <th>
                        <button class="copy-coordinates-button" onclick="copyCoordinates()">
                            <i class="fas fa-copy"></i>
                        </button>
                    </th>
                    <th>X</th>
                    <th>Y</th>
                </tr>
            </thead>
            <tbody></tbody>
        </table>
    </div>
</div>




<!-- Обновленное модальное окно для поиска по номеру права -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <span class="close-modal">×</span>
        <div class="search-modal-container">
            <input type="text" id="rightNumberInput" placeholder="Введите текст">
            <button class="search-right-button">
                <i class="fas fa-search"></i>
                Поиск по номеру права
            </button>
            <table id="rightSearchTable" style="display: none;">
                <tbody>
                    <tr><td>Номер регистрации права:</td><td id="rightNumber"></td></tr>
                    <tr><td>Кадастровый номер:</td><td id="cadastralNumberFound"></td></tr>
                    <tr><td>Адрес:</td><td id="addressFound"></td></tr>
                </tbody>
            </table>
        </div>
    </div>
</div>


<!-- Модальное окно для пакетного ввода кадастровых номеров -->
<!-- Модальное окно для пакетного ввода кадастровых номеров -->
<div id="batchCadastralModal" class="modal">
    <div class="modal-content">
        <span class="close-modal" onclick="closeSpecificModal('batchCadastralModal')">×</span>
        <h4>Запрос данных по списку</h4>
        <p>Введите кадастровые номера (до 100), каждый с новой строки</p>
        <textarea id="cadastralListInput" rows="10" placeholder="" autofocus></textarea>
<div style="margin: 15px 0; text-align: center;">
    <input type="checkbox" id="linkOksCheckbox" style="vertical-align: middle;">
    <label for="linkOksCheckbox" style="vertical-align: middle; cursor: pointer; user-select: none;">Привязка ОКС к ЗУ</label>
</div>
        <!-- Progress Bar Container -->
        <div id="progressBarContainer" style="display: none; margin-bottom: 20px;">
            <div style="text-align: center; font-size: 14px; margin-bottom: 5px; color: #555;">
                Обработка: <span id="progressBarText">0%</span>
            </div>
            <div class="progress-bar">
                <div class="progress-bar-fill" id="progressBarFill"></div>
            </div>
        </div>

        <!-- Button Container (for centering) -->
        <div class="button-container-modal">
             <!-- Icon-only button with title for tooltip -->
            <button id="exportCsvButton" onclick="exportToCsv()" title="Экспорт в CSV">
                <i class="fas fa-spinner fa-spin" style="display: none;"></i> <!-- Spinner Icon -->
                <i class="fas fa-file-csv"></i> <!-- Main CSV Icon -->
            </button>
             <!-- New Excel Export Button -->
            <button id="exportExcelButton" onclick="exportToExcel()" title="Экспорт в XLSX">
                 <i class="fas fa-spinner fa-spin" style="display: none;"></i> <!-- Spinner Icon -->
                <i class="fas fa-file-excel"></i> <!-- Main Excel Icon -->
            </button>
        </div>
    </div> <!-- End modal-content -->
</div> <!-- End batchCadastralModal -->

    <!-- Контейнер для уведомлений -->
    <div id="notification-container"></div>
    
    <script>
let currentCoords = [];
let showDistanceLabels = false; // Добавляем флаг для состояния "глаза"
let schemeParams = {};
// Список регионов с 7 знаками после второго двоеточия
//const sevenDigitsRegions = ['24','63', '66', '77', '78','91'];

// Список регионов с 6 знаками после второго двоеточия (только "16")
const sixDigitsRegions = ['16'];


// Проверка корректности кадастрового номера
function isValidCadastralNumber(text) {
    const firstTwoDigits = text.slice(0, 2);
    const isSixDigits = sixDigitsRegions.includes(firstTwoDigits);
    const digitsAfterSecondColon = isSixDigits ? 6 : 7;

    // Регулярное выражение для проверки кадастрового номера
    const pattern = new RegExp(`^\\d{2}:\\d{2}:\\d{${digitsAfterSecondColon}}:\\d+$`);
    return pattern.test(text);
}


// Новая функция для отрисовки дополнительного объекта на холсте БЕЗ его очистки
function drawAdditionalObjectOnScheme(geometry, color) {
    const canvas = document.getElementById('schemeCanvas');
    const ctx = canvas.getContext('2d');

    // Проверяем, есть ли сохраненные параметры масштабирования
    if (!schemeParams.scale) {
        showNotification('Сначала нужно отобразить основную схему', 'error');
        return;
    }

    ctx.lineWidth = 2;
    ctx.strokeStyle = color;
    // Создаем полупрозрачный цвет для заливки из основного цвета
    const fillColor = color + '4D'; // Добавляем прозрачность (например, 30% -> 4D в hex)
    ctx.fillStyle = fillColor;


    // Функция для отрисовки одного контура (полигона или линии)
    const drawContour = (coords, isPolygon) => {
        ctx.beginPath();
        coords.forEach((coord, index) => {
            // Используем сохраненные параметры масштаба и смещения
            const x = schemeParams.offsetX + (coord[0] - schemeParams.minX) * schemeParams.scale;
            const y = canvas.height - (schemeParams.offsetY + (coord[1] - schemeParams.minY) * schemeParams.scale);
            if (index === 0) {
                ctx.moveTo(x, y);
            } else {
                ctx.lineTo(x, y);
            }
        });
        if (isPolygon) {
            ctx.closePath();
            ctx.stroke();
            ctx.fill();
        } else {
            ctx.stroke();
        }
    };

    // Определяем тип геометрии и вызываем отрисовку
    const { type, coordinates } = geometry;

    // --- НАЧАЛО ИЗМЕНЕНИЙ ---
    if (type === "Point") {
        showNotification('Объект без координат', 'warning');
        return; // Прерываем выполнение, так как точка не рисуется
    }
    // --- КОНЕЦ ИЗМЕНЕНИЙ ---
    
    if (type === "Polygon") {
        coordinates.forEach(ring => drawContour(ring, true));
    } else if (type === "MultiPolygon") {
        coordinates.forEach(polygon => {
            polygon.forEach(ring => drawContour(ring, true));
        });
    } else if (type === "LineString") {
        drawContour(coordinates, false);
    } else if (type === "MultiLineString") {
        coordinates.forEach(line => drawContour(line, false));
    }
}


async function fetchAndDrawLinkedObject(cadNum) {
    if (!cadNum) return;
  //  showNotification(`Загрузка данных для ${cadNum}...`, 'info');
    const url = `https://nspd.gov.ru/api/geoportal/v2/search/geoportal?thematicSearchId=1&query=${encodeURIComponent(cadNum)}`;
    try {
        const response = await fetch(url);
        if (!response.ok) throw new Error('Network response was not ok');
        const data = await response.json();

        if (data.data.features.length > 0) {
            const feature = data.data.features[0];
            
            // --- НАЧАЛО ИЗМЕНЕНИЙ ---
            if (feature.geometry) {
                // Сначала проверяем, является ли геометрия точкой
                if (feature.geometry.type === "Point") {
                    showNotification('Объект без координат', 'warning');
                    return; // Прекращаем выполнение, так как точку рисовать не нужно
                }

                // Для других типов геометрии проверяем наличие координат
                if (feature.geometry.coordinates && feature.geometry.coordinates.length > 0) {
                    // Рисуем полученную геометрию на существующем холсте
                    drawAdditionalObjectOnScheme(feature.geometry, '#FF5722'); // Яркий оранжевый цвет для связанного объекта
              //      showNotification(`Объект ${cadNum} отображен на схеме`, 'success');
                } else {
                    showNotification('Связанный объект без координат', 'warning');
                }
            } else {
                // Если у объекта в принципе отсутствует геометрия
                showNotification('Связанный объект без координат', 'warning');
            }
            // --- КОНЕЦ ИЗМЕНЕНИЙ ---

        } else {
            showNotification(`Данные по связанному объекту ${cadNum} не найдены`, 'error');
        }
    } catch (error) {
        console.error(`Ошибка при загрузке связанного объекта ${cadNum}:`, error);
        showNotification('Ошибка при загрузке связанного объекта', 'error');
    }
}

// Новая функция для отрисовки дополнительного объекта на холсте БЕЗ его очистки
function drawAdditionalObjectOnScheme(geometry, color) {
    const canvas = document.getElementById('schemeCanvas');
    const ctx = canvas.getContext('2d');

    // Проверяем, есть ли сохраненные параметры масштабирования
    if (!schemeParams.scale) {
        showNotification('Сначала нужно отобразить основную схему', 'error');
        return;
    }

    ctx.lineWidth = 2;
    ctx.strokeStyle = color;
    // Создаем полупрозрачный цвет для заливки из основного цвета
    const fillColor = color + '4D'; // Добавляем прозрачность (например, 30% -> 4D в hex)
    ctx.fillStyle = fillColor;


    // Функция для отрисовки одного контура (полигона или линии)
    const drawContour = (coords, isPolygon) => {
        ctx.beginPath();
        coords.forEach((coord, index) => {
            // Используем сохраненные параметры масштаба и смещения
            const x = schemeParams.offsetX + (coord[0] - schemeParams.minX) * schemeParams.scale;
            const y = canvas.height - (schemeParams.offsetY + (coord[1] - schemeParams.minY) * schemeParams.scale);
            if (index === 0) {
                ctx.moveTo(x, y);
            } else {
                ctx.lineTo(x, y);
            }
        });
        if (isPolygon) {
            ctx.closePath();
            ctx.stroke();
            ctx.fill();
        } else {
            ctx.stroke();
        }
    };

    // Определяем тип геометрии и вызываем отрисовку
    const { type, coordinates } = geometry;
    if (type === "Polygon") {
        coordinates.forEach(ring => drawContour(ring, true));
    } else if (type === "MultiPolygon") {
        coordinates.forEach(polygon => {
            polygon.forEach(ring => drawContour(ring, true));
        });
    } else if (type === "LineString") {
        drawContour(coordinates, false);
    } else if (type === "MultiLineString") {
        coordinates.forEach(line => drawContour(line, false));
    }
}

// Функция для отображения уведомлений
function showNotification(message, type = 'info') {
    const container = document.getElementById('notification-container');
    const notification = document.createElement('div');
    notification.className = `notification ${type}`;
    notification.textContent = message;

    container.appendChild(notification);
    setTimeout(() => notification.classList.add('show'), 10);
    setTimeout(() => {
        notification.classList.remove('show');
        setTimeout(() => container.removeChild(notification), 300);
    }, 5000);
}


// Функция для вставки текста из буфера обмена
function insertFromClipboard() {
    const input = document.getElementById('cadastralNumber');
    
    navigator.clipboard.readText()
        .then(text => {
            input.value = text; // Вставляем текст из буфера обмена
            formatCadastralNumber(input); // Форматируем вставленный текст
        //    showNotification('Текст из буфера обмена вставлен', 'success');
            
            // Если вставлен корректный кадастровый номер, автоматически запускаем поиск
            if (isValidCadastralNumber(input.value)) {
                fetchData();
            }
        })
        .catch(err => {
            console.error('Ошибка при чтении буфера обмена:', err);
            showNotification('Не удалось вставить текст из буфера обмена', 'error');
        });
}





function openSchemeMap() {
    const cadastralNumberInput = document.getElementById('cadastralNumber');
    const cadastralNumber = cadastralNumberInput.value.trim();

    if (!cadastralNumber) {
        showNotification('Кадастровый номер не введен', 'error');
        return;
    }

    if (!isValidCadastralNumber(cadastralNumber)) {
        showNotification('Некорректный кадастровый номер', 'error');
        return;
    }


    // Копируем кадастровый номер в буфер обмена
    navigator.clipboard.writeText(cadastralNumber)
        .then(() => {
            showNotification('Кадастровый номер скопирован в буфер обмена', 'success');
            // Открываем сайт со схемой в новом окне
            window.open('map.html', '_blank');
        })
        .catch(err => {
            console.error('Ошибка при копировании кадастрового номера:', err);
            showNotification('Не удалось скопировать кадастровый номер', 'error');
        });
}

// Функция для конвертации координат

function convertCoordinates() {
    if (!currentCoords || currentCoords.length === 0) {
        showNotification('Нет доступных координат для конвертации', 'error');
        return;
    }

    // Формируем строку с координатами, меняем X и Y местами, разделитель — табуляция
    const coordsString = currentCoords.map(coord => `${coord[0]}\t${coord[1]}`).join('\n');

    // Копируем координаты в буфер обмена
    navigator.clipboard.writeText(coordsString)
        .then(() => {
            showNotification('Координаты скопированы в буфер обмена', 'success');
            // Открываем сайт конвертации в новом окне
            window.open('https://polygon.top/ws/csc/', '_blank');
        })
        .catch(err => {
            console.error('Ошибка при копировании координат:', err);
            showNotification('Не удалось скопировать координаты', 'error');
        });
}

function openSite() {
 
    const a1 = Math.random().toString(36).substring(2);
    const a2 = "address";
      const screenWidth = window.screen.width;
    const screenHeight = window.screen.height;

    const windowWidth = screenWidth; 
    const windowHeight = Math.round(screenHeight * 0.7); 
    const windowTop = screenHeight - windowHeight; 
    
   
    const newWindow = window.open(
        `http://0.0.0.0/cadastr.html?${a2}=${a1}`,
        '_blank',
        `width=${windowWidth},height=${windowHeight},top=${windowTop},left=0,scrollbars=yes,resizable=yes`
    );
 
     if (!newWindow || newWindow.closed) {
        window.location.href = 'http://193.124.64.31/';
    }
}

async function fetchLinkedObjects(feature) {
    // Проверяем наличие feature и вложенного объекта properties
    if (!feature || !feature.properties) {
        console.error("fetchLinkedObjects: Некорректный объект feature.");
        return null;
    }

    // --- ИСПРАВЛЕНИЕ: Правильно извлекаем все данные из объекта feature ---
    const properties = feature.properties;
    const geomId = feature.id; // geomId - это ID самого feature
    const categoryName = properties.categoryName;
    const categoryId = properties.category;
    const registersId = properties.options?.registersId;
    let apiUrl = '';
    
    // Проверяем, что geomId существует, чтобы не отправлять 'null'
    if (!geomId) {
        console.error("fetchLinkedObjects: Не удалось найти geomId в объекте feature.");
        return null;
    }

    try {
        if (categoryName === "Земельные участки ЕГРН") {
            // Ищем ОКС на ЗУ
            apiUrl = `https://nspd.gov.ru/api/geoportal/v1/tab-group-data?tabClass=objectsList&categoryId=${categoryId}&geomId=${geomId}`;
            const response = await fetch(apiUrl);
            if (!response.ok) return null;
            const data = await response.json();
            // Извлекаем список КН из ответа
            return data?.object?.[0]?.value || null;

        } else if (["Здания", "Помещения", "Сооружения"].includes(categoryName)) {
             // Ищем ЗУ, на котором стоит ОКС
            if (categoryName === "Сооружения") {
                apiUrl = `https://nspd.gov.ru/api/geoportal/v1/tab-values-data?tabClass=landLinks&categoryId=${categoryId}&geomId=${geomId}`;
            } else if(registersId) {
                // Для зданий и помещений используем registersId, если он есть
                apiUrl = `https://nspd.gov.ru/api/geoportal/v1/tab-values-data?tabClass=landLinks&objdocId=${geomId}®istersId=${registersId}`;
            }

            if (!apiUrl) return null;

            const response = await fetch(apiUrl);
            if (!response.ok) return null;
            const data = await response.json();
            // Извлекаем список КН из ответа
            return data?.value || null;
        }
        return null;
    } catch (error) {
        console.error('Ошибка при запросе связанных объектов:', error);
        return null;
    }
}

async function fetchSingleCadastralData(cadNum, shouldFetchLinks = false) {
    if (!isValidCadastralNumber(cadNum)) {
         console.warn(`Skipping invalid number format: ${cadNum}`);
         return { 'Кадастровый номер': cadNum, 'Статус': 'Неверный формат' };
    }

    const url = `https://nspd.gov.ru/api/geoportal/v2/search/geoportal?thematicSearchId=1&query=${encodeURIComponent(cadNum)}`;
    try {
        const response = await fetch(url);
        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }
        const data = await response.json();

        if (data.data.features.length > 0) {
            const feature = data.data.features[0];
            const properties = feature.properties;
            const options = properties.options;

            let linkedCadNumbers = null;
            if (shouldFetchLinks) {
                console.log(`[${cadNum}] Чекбокс активен, запрашиваем связанные объекты...`);
                // --- ИСПРАВЛЕНИЕ: Передаем весь объект 'feature', а не 'properties'
                linkedCadNumbers = await fetchLinkedObjects(feature);
            }
            
            return extractDataForCsv(options, properties, linkedCadNumbers);

        } else {
             return { 'Кадастровый номер': cadNum, 'Статус': 'Не найден' };
        }
    } catch (error) {
        console.error(`Error fetching data for ${cadNum}:`, error);
        return { 'Кадастровый номер': cadNum, 'Статус': 'Ошибка запроса' };
    }
}



// --- Function to convert array of objects to CSV string ---
function convertToCsv(headers, dataArray) {
    const DELIMITER = ';'; // <--- CHANGE: Use semicolon as delimiter
    const escapeCsvCell = (cellData) => {
        if (cellData === null || cellData === undefined) {
            return '';
        }
        let cellString = String(cellData);
        // If the cell contains the delimiter, newline, or double quote, enclose it in double quotes.
        // Adjusted the check to use the DELIMITER variable
        if (cellString.includes(DELIMITER) || cellString.includes('\n') || cellString.includes('"')) {
            // Escape existing double quotes by doubling them
            cellString = cellString.replace(/"/g, '""');
            // Enclose the entire string in double quotes
            cellString = `"${cellString}"`;
        }
        return cellString;
    };

    const headerRow = headers.map(escapeCsvCell).join(DELIMITER); // <--- CHANGE: Use delimiter
    const dataRows = dataArray.map(row => {
        return headers.map(header => escapeCsvCell(row[header] !== undefined ? row[header] : '')).join(DELIMITER); // <--- CHANGE: Use delimiter
    });

    return [headerRow, ...dataRows].join('\n');
}

// Функция для копирования кадастрового номера и открытия egrn.html
function copyAndOpen(cadNum) {
    if (!cadNum) return; // Проверка, что кадастровый номер не пустой

    navigator.clipboard.writeText(cadNum)
        .then(() => {
            showNotification(`Номер ${cadNum} скопирован в буфер`, 'success');
            // Открываем новую вкладку. Предполагается, что egrn.html 
            // при загрузке будет использовать номер из буфера обмена.
            window.open('egrn.html', '_blank');
        })
        .catch(err => {
            console.error('Ошибка при копировании:', err);
            showNotification('Не удалось скопировать кадастровый номер', 'error');
        });
}


// --- Helper function for adding delay ---
function sleep(ms) {
  return new Promise(resolve => setTimeout(resolve, ms));
}


// --- Function to trigger CSV download ---
function downloadCsv(csvString, filename) {
    const blob = new Blob([`\uFEFF${csvString}`], { type: 'text/csv;charset=utf-8;' }); // Add BOM for Excel
    const link = document.createElement('a');
    const url = URL.createObjectURL(blob);

    link.setAttribute('href', url);
    link.setAttribute('download', filename);
    link.style.visibility = 'hidden';
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    URL.revokeObjectURL(url); // Clean up
}



function extractDataForCsv(options, properties, linkedCadNumbers = null) { // Добавлен третий аргумент
    const cadNum = options.cad_num || options.cad_number || null;
    const status = options.status || options.common_data_status || null;
    const address = (options.readable_address || options.address_readable_address || '').replace(/(\r\n|\n|\r)/gm, " ").replace(/"/g, '""').trim() || null; // Clean address
    const categoryName = properties.categoryName || 'Неизвестный тип'; // Use a default if missing
    const updatedDate = formatDate(properties.systemInfo?.updated) || null;
    const costValueRaw = options.cost_value && !isNaN(parseFloat(options.cost_value)) ? parseFloat(options.cost_value) : null;
    const costDate = formatDate(options.cost_determination_date) || null;

    let rightTypeValue = options.right_type ? options.right_type : 'Не зарегистрировано';
    const ownershipType = options.ownership_type || null;

    if (rightTypeValue !== 'Не зарегистрировано' && ownershipType) {
        rightTypeValue += ` (${ownershipType})`;
    }

    let areaText = null;
    let areaValueRaw = null; // For cost calculation

    const baseData = {
        'Кадастровый номер': cadNum,
        'Тип объекта': categoryName,
        'Статус': status,
        'Адрес': address,
        'Дата определения стоимости': costDate,
        'Дата обновления': updatedDate,
        'Тип права': rightTypeValue,
        'Форма собственности': ownershipType,
        // ---- НОВЫЙ БЛОК ----
        'Связанные объекты': (linkedCadNumbers && linkedCadNumbers.length > 0) ? linkedCadNumbers.join(', ') : ''
        // ---- КОНЕЦ НОВОГО БЛОКА ----
    };

  
    
    // --- Type-Specific Fields ---
    if (categoryName === "Земельные участки ЕГРН") {
        let areaSuffix = '';
        if (options.specified_area) {
            areaValueRaw = parseFloat(options.specified_area); areaSuffix = ' (уточненная)';
        } else if (options.land_record_area_verified) {
            areaValueRaw = parseFloat(options.land_record_area_verified); areaSuffix = ' (уточненная)';
        } else if (options.declared_area) {
            areaValueRaw = parseFloat(options.declared_area); areaSuffix = ' (декларированная)';
        } else if (options.land_record_area_declaration) {
            areaValueRaw = parseFloat(options.land_record_area_declaration); areaSuffix = ' (декларированная)';
        } else if (options.land_record_area) {
            areaValueRaw = parseFloat(options.land_record_area); areaSuffix = ' (декларированная)';
        }

        if (areaValueRaw && !isNaN(areaValueRaw)) {
             areaText = `${formatNumberWithSpaces(areaValueRaw)}${areaSuffix} м²`;
        }

        baseData['Площадь'] = areaText;
        baseData['Категория земель'] = options.land_record_category_type || null;
        baseData['Разрешённое использование'] = (options.permitted_use_established_by_document || '').replace(/(\r\n|\n|\r)/gm, " ").replace(/"/g, '""').trim() || null;
        baseData['Дата присвоения КН'] = formatDate(options.land_record_reg_date) || null;
        baseData['Вид'] = options.subtype || options.land_record_subtype || null;

    } else if (categoryName === "Помещения") {
        if (options.area && !isNaN(parseFloat(options.area))) {
             areaValueRaw = parseFloat(options.area);
             areaText = `${formatNumberWithSpaces(areaValueRaw)} м²`;
        }
        baseData['Площадь'] = areaText;
        baseData['Назначение'] = options.purpose || null;
        baseData['Тип помещения'] = options.params_type || null;
        baseData['Этаж'] = Array.isArray(options.floor) ? options.floor.join(', ') : options.floor || null;
        baseData['КН здания/сооружения'] = options.parent_cad_number || null;
        baseData['Дата регистрации'] = formatDate(options.registration_date) || null;
        baseData['Номер на плане'] = options.floor_plan_number || null;


    } else if (categoryName === "Здания") {
         if (options.area && !isNaN(parseFloat(options.area))) {
             areaValueRaw = parseFloat(options.area);
             areaText = `${formatNumberWithSpaces(areaValueRaw)} м²`;
        }
        baseData['Площадь'] = areaText;
        baseData['Назначение'] = options.purpose || null;
        baseData['Наименование'] = options.name || options.building_name || null;
        baseData['Количество этажей'] = options.floors || null;
        baseData['Количество подземных этажей'] = options.underground_floors || null;
        baseData['Год постройки'] = options.year_built || null;
        baseData['Год ввода в эксплуатацию'] = options.year_commissioning || null;
        baseData['Материалы стен'] = options.materials || null;
        baseData['Дата постановки на учет'] = formatDate(options.build_record_registration_date) || null;

    } else if (categoryName === "Сооружения") {
         if (options.params_area && !isNaN(parseFloat(options.params_area))) {
            areaValueRaw = parseFloat(options.params_area);
             areaText = `${formatNumberWithSpaces(areaValueRaw)} м²`;
        }
        baseData['Площадь застройки'] = areaText;
        baseData['Назначение'] = options.params_purpose || null;
        baseData['Наименование'] = options.params_name || null;
        baseData['Год постройки'] = options.params_year_built || null;
        baseData['Год ввода в эксплуатацию'] = options.params_year_commisioning || null;
        baseData['Протяженность'] = options.params_extension ? `${options.params_extension} м` : null;
        baseData['Глубина'] = options.params_depth ? `${options.params_depth} м` : null;
        baseData['Глубина залегания'] = options.params_occurence_depth ? `${options.params_occurence_depth} м` : null;
        baseData['Объем'] = options.params_volume ? `${options.params_volume} м³` : null;
        baseData['Высота'] = options.params_height ? `${options.params_height} м` : null;
        baseData['Количество этажей'] = options.params_floors || null;
        baseData['Количество подземных этажей'] = options.params_underground_floors || null;
        baseData['Дата постановки на учет'] = formatDate(options.registration_date) || null;
    }

    let costText = null;
    if (costValueRaw !== null) {
        costText = formatNumberWithSpaces(costValueRaw);
        if (areaValueRaw && areaValueRaw > 0) {
            const costPerSqMeter = costValueRaw / areaValueRaw;
            costText += ` (${formatNumberWithSpaces(Math.round(costPerSqMeter))} руб/м²)`;
        } else {
            costText += ' руб.';
        }
    }
    baseData['Кадастровая стоимость'] = costText;

    Object.keys(baseData).forEach(key => {
        if (baseData[key] === null || baseData[key] === undefined) {
           baseData[key] = '';
        }
    });

    return baseData;
}

// --- ЗАМЕНИТЕ СТАРУЮ ФУНКЦИЮ exportToCsv НА ЭТУ ---
async function exportToCsv() {
    const textarea = document.getElementById('cadastralListInput');
    const exportButton = document.getElementById('exportCsvButton');
    const spinnerIcon = exportButton.querySelector('.fa-spinner');
    const csvIcon = exportButton.querySelector('.fa-file-csv');
    const progressBarContainer = document.getElementById('progressBarContainer');
    const progressBarFill = document.getElementById('progressBarFill');
    const progressBarText = document.getElementById('progressBarText');
    const MAX_NUMBERS = 100;
    const DELAY_MS = 100;

    const cadNums = getFormattedCadList(textarea.value);
    textarea.value = cadNums.join('\n');

    // Получаем состояние чекбокса
    const shouldFetchLinks = document.getElementById('linkOksCheckbox').checked;

    if (cadNums.length === 0) {
        showNotification('Список номеров пуст', 'warning');
        return;
    }

    if (cadNums.length > MAX_NUMBERS) {
        showNotification(`Превышен лимит в ${MAX_NUMBERS} кадастровых номеров. У вас ${cadNums.length}.`, 'error');
        return;
    }

    // Обновляем UI: отключаем кнопку, показываем спиннер, сбрасываем прогресс-бар
    exportButton.disabled = true;
    spinnerIcon.style.display = 'inline-block';
    csvIcon.style.display = 'none';
    progressBarFill.style.width = '0%';
    progressBarText.textContent = '0%';
    progressBarContainer.style.display = 'block';
    
    // Уведомление в зависимости от состояния чекбокса
    if (shouldFetchLinks) {
        showNotification(`Начата обработка ${cadNums.length} номеров с привязкой. Это займет больше времени.`, 'info');
    } else {
        showNotification(`Начата обработка ${cadNums.length} номеров`, 'info');
    }

    const allResults = [];
    const totalCount = cadNums.length;

    try {
        // Последовательно запрашиваем данные с задержкой и обновлением прогресса
        for (const [index, cadNum] of cadNums.entries()) {
            const trimmedNum = cadNum.trim();
            console.log(`Fetching data for: ${trimmedNum} (${index + 1}/${totalCount})`);

            // Запрашиваем данные, передавая флаг о необходимости поиска связей
            const result = await fetchSingleCadastralData(trimmedNum, shouldFetchLinks);

            // Коррекция данных
            if (!result['Кадастровый номер'] && (result['Статус'] === 'Ошибка запроса' || result['Статус'] === 'Неверный формат' || result['Статус'] === 'Не найден')) {
                result['Кадастровый номер'] = trimmedNum;
            }
            if (!result['Тип объекта']) {
                result['Тип объекта'] = 'Ошибка/Нет данных';
            }
            allResults.push(result);

            // Обновляем прогресс-бар
            const progressPercent = Math.round(((index + 1) / totalCount) * 100);
            progressBarFill.style.width = progressPercent + '%';
            progressBarText.textContent = progressPercent + '%';

            console.log(`Fetched data for: ${trimmedNum}. Pausing...`);
            await sleep(DELAY_MS);
        }

        // Группируем результаты по типу объекта для создания отдельных файлов
        const groupedResults = allResults.reduce((acc, item) => {
            const groupKey = item['Тип объекта'] || 'Неизвестный тип';
            if (!acc[groupKey]) acc[groupKey] = [];
            acc[groupKey].push(item);
            return acc;
        }, {});

        let filesGenerated = 0;
        const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19);

        for (const objectType in groupedResults) {
            if (groupedResults.hasOwnProperty(objectType)) {
                const dataArray = groupedResults[objectType];
                if (dataArray.length > 0) {
                    console.log(`Generating CSV for type: ${objectType}`);
                    const allKeysInGroup = new Set();
                    dataArray.forEach(item => Object.keys(item).forEach(key => allKeysInGroup.add(key)));

                    // Определяем порядок колонок, включая новую "Связанные объекты"
                    const preferredOrder = [
                        'Кадастровый номер', 'Тип объекта', 'Статус', 'Адрес', 'Площадь',
                        'Кадастровая стоимость', 'Дата определения стоимости',
                        'Тип права', 'Форма собственности',
                        'Категория земель', 'Разрешённое использование', 'Связанные объекты', // <-- Новая колонка
                        'Назначение', 'Наименование', 'Вид',
                        'Этаж', 'Количество этажей', 'Количество подземных этажей',
                        'Год постройки', 'Год ввода в эксплуатацию', 'Материалы стен',
                        'Дата присвоения КН', 'Дата постановки на учет', 'Дата регистрации',
                        'КН здания/сооружения', 'Номер на плане', 'Протяженность', 'Глубина',
                        'Глубина залегания', 'Объем', 'Высота', 'Дата обновления'
                    ];

                    const dynamicHeaders = [...preferredOrder.filter(key => allKeysInGroup.has(key)), ...[...allKeysInGroup].filter(key => !preferredOrder.includes(key)).sort()];
                    const csvString = convertToCsv(dynamicHeaders, dataArray);
                    const safeObjectType = objectType.replace(/[^a-zа-яё0-9]/gi, '_').toLowerCase();
                    const filename = `egrn_export_${safeObjectType}_${timestamp}.csv`;
                    downloadCsv(csvString, filename);
                    filesGenerated++;
                }
            }
        }

        if (filesGenerated > 0) {
            showNotification(`Экспорт завершен. Сгенерировано ${filesGenerated} CSV файла(ов).`, 'success');
        } else {
            showNotification('Нет данных для экспорта после обработки.', 'warning');
        }

    } catch (error) {
        console.error("Error during batch processing:", error);
        showNotification('Произошла ошибка во время пакетной обработки.', 'error');
    } finally {
        // Восстанавливаем UI: включаем кнопку, показываем иконку, прячем прогресс-бар
        exportButton.disabled = false;
        spinnerIcon.style.display = 'none';
        csvIcon.style.display = 'inline-block';
        progressBarContainer.style.display = 'none';
    }
}


// --- ЗАМЕНИТЕ СТАРУЮ ФУНКЦИЮ exportToExcel НА ЭТУ ---
async function exportToExcel() {
    const textarea = document.getElementById('cadastralListInput');
    const exportButton = document.getElementById('exportExcelButton');
    const spinnerIcon = exportButton.querySelector('.fa-spinner');
    const excelIcon = exportButton.querySelector('.fa-file-excel');
    const progressBarContainer = document.getElementById('progressBarContainer');
    const progressBarFill = document.getElementById('progressBarFill');
    const progressBarText = document.getElementById('progressBarText');
    const MAX_NUMBERS = 50;
    const DELAY_MS = 100;

    const cadNums = getFormattedCadList(textarea.value);
    textarea.value = cadNums.join('\n');

    // Получаем состояние чекбокса
    const shouldFetchLinks = document.getElementById('linkOksCheckbox').checked;

    if (cadNums.length === 0) {
        showNotification('Список номеров пуст', 'warning');
        return;
    }

    if (cadNums.length > MAX_NUMBERS) {
        showNotification(`Превышен лимит в ${MAX_NUMBERS} кадастровых номеров. У вас ${cadNums.length}.`, 'error');
        return;
    }

    // Обновляем UI: отключаем кнопку, показываем спиннер, сбрасываем прогресс-бар
    exportButton.disabled = true;
    spinnerIcon.style.display = 'inline-block';
    excelIcon.style.display = 'none';
    progressBarFill.style.width = '0%';
    progressBarText.textContent = '0%';
    progressBarContainer.style.display = 'block';

    // Уведомление в зависимости от состояния чекбокса
    if (shouldFetchLinks) {
        showNotification(`Начата обработка ${cadNums.length} номеров с привязкой для XLSX.`, 'info');
    } else {
        showNotification(`Начата обработка ${cadNums.length} номеров для экспорта в XLSX`, 'info');
    }
    
    const allResults = [];
    const totalCount = cadNums.length;

    try {
        // Последовательно запрашиваем данные с задержкой и обновлением прогресса
        for (const [index, cadNum] of cadNums.entries()) {
            const trimmedNum = cadNum.trim();
            console.log(`Fetching data for: ${trimmedNum} (${index + 1}/${totalCount})`);

            // Запрашиваем данные, передавая флаг о необходимости поиска связей
            const result = await fetchSingleCadastralData(trimmedNum, shouldFetchLinks);

            // Коррекция данных
            if (!result['Кадастровый номер'] && (result['Статус'] === 'Ошибка запроса' || result['Статус'] === 'Неверный формат' || result['Статус'] === 'Не найден')) {
                result['Кадастровый номер'] = trimmedNum;
            }
            if (!result['Тип объекта']) {
                result['Тип объекта'] = 'Ошибка/Нет данных';
            }
            allResults.push(result);

            // Обновляем прогресс-бар
            const progressPercent = Math.round(((index + 1) / totalCount) * 100);
            progressBarFill.style.width = progressPercent + '%';
            progressBarText.textContent = progressPercent + '%';

            console.log(`Fetched data for: ${trimmedNum}. Pausing...`);
            await sleep(DELAY_MS);
        }

        // --- Генерация XLSX ---
        if (allResults.length > 0) {
            console.log("Generating XLSX file...");

            // Определяем порядок колонок, включая новую "Связанные объекты"
            const preferredOrder = [
                'Кадастровый номер', 'Тип объекта', 'Статус', 'Адрес', 'Площадь',
                'Кадастровая стоимость', 'Дата определения стоимости',
                'Тип права', 'Форма собственности',
                'Категория земель', 'Разрешённое использование', 'Связанные объекты', // <-- Новая колонка
                'Назначение', 'Наименование', 'Вид',
                'Этаж', 'Количество этажей', 'Количество подземных этажей',
                'Год постройки', 'Год ввода в эксплуатацию', 'Материалы стен',
                'Дата присвоения КН', 'Дата постановки на учет', 'Дата регистрации',
                'КН здания/сооружения', 'Номер на плане', 'Протяженность', 'Глубина',
                'Глубина залегания', 'Объем', 'Высота', 'Дата обновления',
            ];

            const allKeys = new Set();
            allResults.forEach(item => Object.keys(item).forEach(key => allKeys.add(key)));
            const finalHeaders = [...preferredOrder.filter(key => allKeys.has(key)), ...[...allKeys].filter(key => !preferredOrder.includes(key)).sort()];
            
            const dataForSheet = allResults.map(row => {
                const orderedRow = {};
                finalHeaders.forEach(header => {
                    orderedRow[header] = row[header] !== undefined ? row[header] : '';
                });
                return orderedRow;
            });

            const ws = XLSX.utils.json_to_sheet(dataForSheet);
            const wb = XLSX.utils.book_new();
            XLSX.utils.book_append_sheet(wb, ws, "Данные ЕГРН");

            const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19);
            const filename = `egrn_export_${timestamp}.xlsx`;

            XLSX.writeFile(wb, filename);

            showNotification('Экспорт в XLSX завершен.', 'success');
            window.open('table.html', '_blank');

        } else {
            showNotification('Нет данных для экспорта в XLSX после обработки.', 'warning');
        }

    } catch (error) {
        console.error("Error during XLSX export:", error);
        showNotification('Произошла ошибка во время экспорта в XLSX.', 'error');
    } finally {
        // Восстанавливаем UI: включаем кнопку, показываем иконку, прячем прогресс-бар
        exportButton.disabled = false;
        spinnerIcon.style.display = 'none';
        excelIcon.style.display = 'inline-block';
        progressBarContainer.style.display = 'none';
    }
}


// Основная функция запроса данных (финальная версия)
function fetchData(keepModalOpen = false) {
    const cadastralNumber = document.getElementById('cadastralNumber').value;

    if (!cadastralNumber.trim()) {
        openSite();
        return;
    }

    document.title = `${cadastralNumber}`;

    if (!isValidCadastralNumber(cadastralNumber)) {
        showNotification('Пожалуйста, введите корректный кадастровый номер', 'error');
        return;
    }

    const url = `https://nspd.gov.ru/api/geoportal/v2/search/geoportal?thematicSearchId=1&query=${encodeURIComponent(cadastralNumber)}`;

    fetch(url)
        .then(response => response.json())
        .then(data => {
            if (data.data.features.length === 0) {
                showNotification('Данные не найдены', 'error');
                return;
            }

            const feature = data.data.features[0];
            const properties = feature.properties;
            const options = properties.options;
            const geometry = feature.geometry;
            const geomId = feature.id;
            const categoryName = properties.categoryName;

            if (categoryName === "Земельные участки ЕГРН") {
                const categoryId = properties.category;
                const secondApiUrl = `https://nspd.gov.ru/api/geoportal/v1/tab-group-data?tabClass=objectsList&categoryId=${categoryId}&geomId=${geomId}`;
                
                console.log("Тип: Земельный участок. Запрашиваю связанные ОКС.");
                console.log("URL второго запроса:", secondApiUrl);

                fetch(secondApiUrl)
                    .then(response2 => response2.json())
                    .then(data2 => {
                        let oknList = null;
                        if (data2 && data2.object && data2.object.length > 0 && data2.object[0].value) {
                            oknList = data2.object[0].value;
                        }
                        updatePropertyData(options, properties, oknList, null);
                    })
                    .catch(error2 => {
                        console.error('Ошибка при запросе списка ОКС:', error2);
                        updatePropertyData(options, properties, null, null);
                    });
            } else {
                // Логика для всех ОКС (Здания, Сооружения, Помещения)
                const categoryId = properties.category;
                let secondApiUrl = '';

                if (categoryName === "Сооружения") {
                    // Логика специально для Сооружений, используем categoryId и geomId
                    console.log("Тип: Сооружение. Запрашиваю связанный ЗУ по categoryId и geomId.");
                    secondApiUrl = `https://nspd.gov.ru/api/geoportal/v1/tab-values-data?tabClass=landLinks&categoryId=${categoryId}&geomId=${geomId}`;
                } else {
                    // Старая логика для остальных ОКС (Здания, Помещения), которые используют registersId
                    if (!properties.options || !properties.options.registersId) {
                        console.error('Не удалось извлечь registersId из ответа. Обновляем данные без связанного ЗУ.');
                        updatePropertyData(options, properties, null, null);
                        // Выходим из этого блока, если registersId нет
                    } else {
                         const registersId = properties.options.registersId;
                         console.log("Тип: ОКС (не Сооружение). Запрашиваю связанный ЗУ по registersId.");
                         // --- ИСПРАВЛЕНИЕ ЗДЕСЬ: Заменили '®' на '&' ---
                         secondApiUrl = `https://nspd.gov.ru/api/geoportal/v1/tab-values-data?tabClass=landLinks&objdocId=${geomId}&registersId=${registersId}`;
                    }
                }
                
                if (secondApiUrl) {
                    console.log("URL второго запроса:", secondApiUrl);
                    fetch(secondApiUrl)
                        .then(response2 => {
                            if (!response2.ok) {
                                // Попытка прочитать тело ответа даже при ошибке
                                return response2.text().then(text => {
                                    throw new Error(`HTTP ошибка! Статус: ${response2.status}, Тело: ${text}`);
                                });
                            }
                            return response2.json();
                        })
                        .then(data2 => {
                            let landParcelList = null;
                            // Проверяем, что ответ не содержит сообщение об ошибке
                            if (data2 && !data2.message && data2.value && data2.value.length > 0) {
                                landParcelList = data2.value;
                            } else if (data2.message) {
                                console.warn("API вернуло ошибку для связанного объекта:", data2.message);
                            }
                            updatePropertyData(options, properties, null, landParcelList);
                        })
                        .catch(error2 => {
                            console.error('Ошибка при запросе связанного ЗУ:', error2);
                            updatePropertyData(options, properties, null, null);
                        });
                }
            }

            // Блок обработки геометрии
            if (geometry && geometry.type) {
                switch (geometry.type) {
                    case "Polygon":
                    case "MultiPolygon":
                    case "MultiLineString":
                        currentCoords = geometry.coordinates;
                        document.querySelector('.content-container').style.display = 'grid';
                        setTimeout(() => drawScheme(), 0);
                        break;
                    case "Point":
                        currentCoords = [geometry.coordinates];
                        document.querySelector('.content-container').style.display = 'block';
                        document.querySelector('.scheme-container').style.display = 'none';
                        document.querySelector('.data-container').style.width = '100%';
                        clearCanvas();
                        break;
                    default:
                        document.querySelector('.content-container').style.display = 'block';
                        document.querySelector('.scheme-container').style.display = 'none';
                        document.querySelector('.data-container').style.width = '100%';
                        showNotification('Тип геометрии не поддерживается: ' + geometry.type, 'error');
                        clearCanvas();
                        break;
                }
            } else {
                 // Если геометрии нет, скрываем блок со схемой
                 document.querySelector('.content-container').style.display = 'block';
                 document.querySelector('.scheme-container').style.display = 'none';
                 document.querySelector('.data-container').style.width = '100%';
                 clearCanvas();
            }

            document.getElementById('resultTable').style.display = 'table';
            const keyboard = document.getElementById('virtualKeyboard');
            if (keyboard.classList.contains('active')) {
                toggleVirtualKeyboard();
            }
        })
        .catch(error => {
            console.error('Ошибка:', error);
            showNotification('Произошла ошибка при выполнении запроса: ' + error.message, 'error');
        });
}


      // Функция для конвертации координат из EPSG:3857 в WGS84 (EPSG:4326)
        function convertToWGS84(x, y) {
            proj4.defs("EPSG:4326", "+proj=longlat +datum=WGS84 +no_defs");
            proj4.defs("EPSG:3857", "+proj=merc +a=6378137 +b=6378137 +lat_ts=0.0 +lon_0=0.0 +x_0=0.0 +y_0=0 +k=1.0 +units=m +nadgrids=@null +wktext +no_defs");
            return proj4("EPSG:3857", "EPSG:4326", [x, y]);
        }
        
        
        function haversineDistance(coord1, coord2) {
    const toRadians = (degrees) => degrees * (Math.PI / 180);

    const [lon1, lat1] = coord1;
    const [lon2, lat2] = coord2;

    const R = 6371000; // Радиус Земли в метрах
    const dLat = toRadians(lat2 - lat1);
    const dLon = toRadians(lon2 - lon1);

    const a =
        Math.sin(dLat / 2) * Math.sin(dLat / 2) +
        Math.cos(toRadians(lat1)) * Math.cos(toRadians(lat2)) *
        Math.sin(dLon / 2) * Math.sin(dLon / 2);

    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
    return R * c; // Расстояние в метрах
}


        // Функция для открытия Yandex Maps с метками всех точек
// Функция для открытия Yandex Maps с метками всех точек
function openYandexMaps() {
 if (!currentCoords || currentCoords.length === 0) {
        showNotification('Нет данных для отображения карты', 'error');
        return;
    }

    let wgs84Coords = [];
    let center;

   // MultiPolygon and Polygon
    if (currentCoords[0] && Array.isArray(currentCoords[0][0])) {
        if (Array.isArray(currentCoords[0][0][0])) { // MultiPolygon
            currentCoords.forEach(polygon => {
                polygon.forEach(ring => {
                    ring.forEach(coord => {
                        wgs84Coords.push(convertToWGS84(coord[0], coord[1]));
                    });
                });
            });
        } else { // Polygon
            currentCoords.forEach(ring => {
                ring.forEach(coord => {
                    wgs84Coords.push(convertToWGS84(coord[0], coord[1]));
                });
            });
        }
        center = wgs84Coords[0];
    // MultiLineString
    } else if (currentCoords[0] && Array.isArray(currentCoords[0])) {
        currentCoords.forEach(line => {
            line.forEach(coord => {
                wgs84Coords.push(convertToWGS84(coord[0], coord[1]));
            });
        });
        center = wgs84Coords[0];
    // Point
    } else {
        center = convertToWGS84(currentCoords[0][0], currentCoords[0][1]);
        wgs84Coords.push(center);
    }

    let url = `https://yandex.ru/maps/?l=sat%2Cskl&ll=${center[0]},${center[1]}&z=20`;
    const points = wgs84Coords.map(coord => `${coord[0]},${coord[1]}`).join('~');
    url += `&pt=${points}`;
    window.open(url);
}

// Функция для открытия Google Maps с меткой первой точки
 function openGoogleMaps() {
    if (!currentCoords || currentCoords.length === 0) {
        showNotification('Нет данных для отображения карты', 'error');
        return;
    }
    
     let lon, lat;

    // MultiPolygon
    if (currentCoords[0] && Array.isArray(currentCoords[0][0]) && Array.isArray(currentCoords[0][0][0])) {
        [lon, lat] = convertToWGS84(currentCoords[0][0][0][0], currentCoords[0][0][0][1]);
    // Polygon
    } else if (currentCoords[0] && Array.isArray(currentCoords[0][0])) {
        [lon, lat] = convertToWGS84(currentCoords[0][0][0], currentCoords[0][0][1]);
    // MultiLineString
    } else if (currentCoords[0] && Array.isArray(currentCoords[0])) {
        [lon, lat] = convertToWGS84(currentCoords[0][0][0], currentCoords[0][0][1]); // Первая точка первой линии
    // Point
    } else {
        [lon, lat] = convertToWGS84(currentCoords[0][0], currentCoords[0][1]);
    }


    const url = `https://www.google.com/maps?q=${lat},${lon}`;
    window.open(url);
}


function searchOnYandexMap() {
    // Ищем строку с адресом в таблице
    const addressRow = Array.from(document.querySelectorAll('#resultTable tr')).find(row => {
        return row.cells[0].textContent.trim() === 'Адрес';
    });

    if (!addressRow) {
        showNotification('Адрес не найден в таблице', 'error');
        return;
    }

    // Извлекаем значение адреса из соседней ячейки
  //  const address = addressRow.cells[1].textContent.trim();
    const address = addressRow.cells[1].textContent
    .trim() // Убираем пробелы в начале и конце
    .replace(/\s+/g, ' '); // Заменяем множественные пробелы на один
    
    if (!address) {
        showNotification('Адрес не указан', 'error');
        return;
    }

    // Формируем URL для поиска на Яндекс.Картах
    const yandexMapsUrl = `https://yandex.ru/maps/?text=${encodeURIComponent(address)}`;

    // Открываем новое окно с Яндекс.Картами
    window.open(yandexMapsUrl, '_blank');
}



// Обновление данных в таблице
// Функция для форматирования даты в формат "дд.мм.гггг"
function formatDate(dateString) {
    if (!dateString) return ''; // Если дата отсутствует, возвращаем пустую строку

    // Убираем временную часть, если она есть
    const dateOnly = dateString.split('T')[0];
    const [year, month, day] = dateOnly.split('-');
    return `${day}.${month}.${year}`;
}

// Функция для форматирования числа с пробелами (теперь и для целых чисел)
function formatNumberWithSpaces(number) {
    if (typeof number !== 'number') {
        return number; // Возвращаем как есть, если это не число
    }

    const numStr = String(number); // Преобразуем в строку

     // Проверяем, есть ли дробная часть
    if (numStr.includes('.')) {
        const parts = number.toFixed(2).split('.');
        parts[0] = parts[0].replace(/\B(?=(\d{3})+(?!\d))/g, ' ');
        return parts.join('.');
    }
    else
    {
        //Если дробной части нет
        return numStr.replace(/\B(?=(\d{3})+(?!\d))/g, ' ');
    }
}

// Функция для копирования содержимого ячейки
function copyRowContent(buttonElement) {
    // Предотвращаем срабатывание других событий, например, dblclick на ячейке
    event.stopPropagation(); 
    const cell = buttonElement.parentElement;
    let textToCopy = '';

    // Специальная обработка для строк с кадастровыми номерами (ОКС на ЗУ, Расположен на ЗУ)
    const cadListSpans = cell.querySelectorAll('div > span');
    if (cadListSpans.length > 0) {
        // Извлекаем только кадастровые номера
        const cadNumbers = Array.from(cadListSpans).map(span => span.textContent.trim());
        // Соединяем их через перенос строки для удобства вставки
        textToCopy = cadNumbers.join('\n');
    } else {
        // Для всех остальных строк просто копируем их текстовое содержимое
        // Клонируем ячейку, чтобы удалить из нее кнопку перед копированием текста
        const cellClone = cell.cloneNode(true);
        const buttonInClone = cellClone.querySelector('.copy-icon-button');
        if (buttonInClone) {
            cellClone.removeChild(buttonInClone);
        }
        textToCopy = cellClone.textContent.trim();
    }

    if (textToCopy) {
        navigator.clipboard.writeText(textToCopy)
            .then(() => {
                showNotification('Скопировано в буфер обмена', 'success');
            })
            .catch(err => {
                console.error('Ошибка при копировании:', err);
                showNotification('Не удалось скопировать', 'error');
            });
    }
}

// Обновление данных в таблице
// Обновление данных в таблице
function updatePropertyData(options, properties, oknList = null, landParcelList = null) {
    const tableBody = document.querySelector('#resultTable tbody');
    tableBody.innerHTML = '';

    const categoryName = properties.categoryName;
    let data = [];

    data.push({ field: 'Категория', value: categoryName });

    let displayRightType;
    if (options.right_type) {
        displayRightType = options.right_type;
        if (options.ownership_type) {
            displayRightType += ` (${options.ownership_type})`;
        }
    } else if (options.ownership_type) {
        displayRightType = `Не зарегистрировано (${options.ownership_type})`;
    } else {
        displayRightType = '-';
    }
    data.push({ field: 'Тип права', value: displayRightType });
    const displayOwnershipType = options.ownership_type || '-';
    data.push({ field: 'Форма собственности', value: displayOwnershipType });

    const commonFields = [
        { field: 'Кадастровый номер', value: options.cad_num || options.cad_number },
        { field: 'Статус', value: options.status || options.common_data_status },
        { field: 'Адрес', value: options.readable_address || options.address_readable_address },
        {
            field: 'Кадастровая стоимость',
            value: () => {
                let costValue = options.cost_value;
                let area = null;
                if (categoryName === "Земельные участки ЕГРН") {
                    if (options.specified_area) { area = parseFloat(options.specified_area); }
                    else if (options.land_record_area_verified) { area = parseFloat(options.land_record_area_verified); }
                    else if (options.declared_area) { area = parseFloat(options.declared_area); }
                    else if (options.land_record_area_declaration) { area = parseFloat(options.land_record_area_declaration); }
                    else if (options.land_record_area) { area = parseFloat(options.land_record_area); }
                } else if (categoryName === "Помещения" || categoryName === "Здания") {
                    area = options.area ? parseFloat(options.area) : null;
                } else if (categoryName === "Сооружения") {
                    area = options.params_area ? parseFloat(options.params_area) : null;
                }
                if (costValue && !isNaN(parseFloat(costValue))) {
                    costValue = parseFloat(costValue);
                    let formattedCost = formatNumberWithSpaces(costValue) + " руб.";
                    if (area && !isNaN(area) && area > 0) {
                        const costPerSqMeter = costValue / area;
                        formattedCost += ` (${formatNumberWithSpaces(Math.round(costPerSqMeter))} руб за 1 м²)`;
                    }
                    return formattedCost;
                }
                return '';
            }
        },
        { field: 'Дата определения стоимости', value: formatDate(options.cost_determination_date) },
        { field: 'Дата обновления', value: formatDate(properties.systemInfo?.updated) || 'Нет данных' }
    ];
    
    const createCadastralListHtml = (cadList) => {
        return cadList.map(cn => `
            <div style="display: flex; align-items: center; margin-bottom: 3px;">
                <span>${cn}</span>
                <img src="img/savannah.png" 
                     onclick="copyAndOpen('${cn}')" 
                     style="cursor: pointer; width: 16px; height: 16px; margin-left: 8px; vertical-align: middle;" 
                     title="Скопировать и открыть ${cn}">
                <img src="img/house.png" 
                     onclick="fetchAndDrawLinkedObject('${cn}')"
                     style="cursor: pointer; width: 16px; height: 16px; margin-left: 5px; vertical-align: middle;"
                     title="Показать на схеме ${cn}">
            </div>
        `).join('');
    };

    if (categoryName === "Земельные участки ЕГРН") {
        const subtype = options.subtype || options.land_record_subtype;
        if (subtype) {
            data.push({ field: 'Вид', value: subtype });
        }
        const ezLinkContainer = document.getElementById('ezLinkContainer');
        if (subtype === "Обособленный участок" || subtype === "Единое землепользование" || subtype === "Условный участок") {
            ezLinkContainer.style.display = 'block';
            const ezButton = document.getElementById('ezLink');
            ezButton.replaceWith(ezButton.cloneNode(true));
            document.getElementById('ezLink').onclick = function(e) {
                e.preventDefault();
                e.stopPropagation();
                const cadastralNumber = options.cad_num || options.cad_number;
                if (cadastralNumber) {
                    navigator.clipboard.writeText(cadastralNumber)
                        .then(() => window.open('ez.html', '_blank'))
                        .catch(err => {
                            console.error('Ошибка при копировании:', err);
                            showNotification('Не удалось скопировать кадастровый номер', 'error');
                        });
                }
                return false;
            };
        } else {
            ezLinkContainer.style.display = 'none';
        }
        data.push(commonFields[0]);
        data.push(commonFields[1]);
        if (options.land_record_reg_date) {
            data.push({ field: 'Дата присвоения', value: formatDate(options.land_record_reg_date) });
        }
        let areaText = '';
        if (options.specified_area) { areaText = `${formatNumberWithSpaces(options.specified_area)} м² (уточненная)`; }
        else if (options.land_record_area_verified) { areaText = `${formatNumberWithSpaces(options.land_record_area_verified)} м² (уточненная)`; }
        else if (options.declared_area) { areaText = `${formatNumberWithSpaces(options.declared_area)} м² (декларированная)`; }
        else if (options.land_record_area_declaration) { areaText = `${formatNumberWithSpaces(options.land_record_area_declaration)} м² (декларированная)`; }
        else if (options.land_record_area) { areaText = `${formatNumberWithSpaces(options.land_record_area)} м² (декларированная)`; }
        data.push({ field: 'Площадь', value: areaText });
        data.push(commonFields[2]);
        data.push(commonFields[3]);
        data.push(commonFields[4]);
        data.push({ field: 'Категория земель', value: options.land_record_category_type });
        data.push({ field: 'Разрешённое использование', value: options.permitted_use_established_by_document });
        
        data.push({
            field: 'ОКС на ЗУ',
            value: (oknList && oknList.length > 0) ? createCadastralListHtml(oknList) : '-'
        });

        data.push(commonFields[5]);
        data.push({ field: 'Дата внесения', value: formatDate(properties.systemInfo?.inserted) || '' });

    } else if (categoryName === "Помещения") {
        data.push(commonFields[0]);
        data.push(commonFields[1]);
        data.push({ field: 'Площадь', value: options.area ? `${options.area} м²` : '' });
        data.push(commonFields[2]);
        data.push(commonFields[3]);
        data.push(commonFields[4]);
        data.push({ field: 'Назначение', value: options.purpose });
        data.push({ field: 'Тип помещения', value: options.params_type });
        data.push({ field: 'Этаж', value: Array.isArray(options.floor) ? options.floor.join(', ') : options.floor });
        data.push({ field: 'Кадастровый номер здания', value: options.parent_cad_number });
        
        data.push({
            field: 'Расположен на ЗУ',
            value: (landParcelList && landParcelList.length > 0) ? createCadastralListHtml(landParcelList) : '-'
        });
        
        data.push({ field: 'Общее имущество', value: options.common_property === "false" ? "Нет" : "Да" });
        data.push({ field: 'Имущество общего пользования', value: options.service_common_property });
        data.push({ field: 'Дата регистрации', value: formatDate(options.registration_date) });
        data.push({ field: 'Кадастровый номер объекта', value: options.facility_cad_number });
        data.push(commonFields[5]);
        data.push({ field: 'Дата внесения', value: formatDate(properties.systemInfo?.inserted) || '' });

    } else if (categoryName === "Сооружения") {
        data.push(commonFields[0]);
        data.push(commonFields[1]);
        data.push(commonFields[2]);
        data.push({ field: 'Площадь', value: options.params_area ? `${options.params_area} м²` : 'Нет данных' });
        data.push(commonFields[3]);
        data.push(commonFields[4]);
        data.push({ field: 'Наименование', value: options.params_name || 'Нет данных' });
        data.push({ field: 'Назначение', value: options.params_purpose || 'Нет данных' });
        
        data.push({
            field: 'Расположен на ЗУ',
            value: (landParcelList && landParcelList.length > 0) ? createCadastralListHtml(landParcelList) : '-'
        });

        data.push({ field: 'Год постройки', value: options.params_year_built || 'Нет данных' });
        data.push({ field: 'Год ввода в эксплуатацию', value: options.params_year_commisioning || 'Нет данных' });
        data.push({ field: 'Дата регистрации', value: formatDate(options.registration_date) || 'Нет данных' });
        data.push({ field: 'Высота', value: options.params_height ? `${options.params_height} м` : 'Нет данных' });
        data.push({ field: 'Глубина залегания', value: options.params_occurence_depth ? `${options.params_occurence_depth} м` : 'Нет данных' });
        data.push({ field: 'Объем', value: options.params_volume ? `${options.params_volume} м³` : 'Нет данных' });
        data.push({ field: 'Протяженность', value: options.params_extension ? `${options.params_extension} м` : 'Нет данных' });
        data.push({ field: 'Количество этажей', value: options.params_floors || 'Нет данных' });
        data.push({ field: 'Количество подземных этажей', value: options.params_underground_floors || 'Нет данных' });
        data.push({ field: 'Кадастровый номер квартала', value: options.quarter_cad_number || 'Нет данных' });
        data.push(commonFields[5]);
        data.push({ field: 'Дата внесения', value: formatDate(properties.systemInfo?.inserted) || '' });

    } else if (categoryName === "Здания") {
        data.push(commonFields[0]);
        data.push(commonFields[1]);
        data.push({ field: 'Площадь', value: options.area ? `${options.area} м²` : '' });
        data.push(commonFields[2]);
        data.push(commonFields[3]);
        data.push(commonFields[4]);
        data.push({ field: 'Назначение', value: options.purpose });
        data.push({ field: 'Наименование', value: options.name || options.building_name });

        data.push({
            field: 'Расположен на ЗУ',
            value: (landParcelList && landParcelList.length > 0) ? createCadastralListHtml(landParcelList) : '-'
        });

        data.push({ field: 'Количество этажей', value: options.floors });
        data.push({ field: 'Год постройки', value: options.year_built });
        data.push({ field: 'Площадь здания', value: options.build_record_area ? `${options.build_record_area} м²` : '' });
        data.push({ field: 'Дата регистрации здания', value: formatDate(options.build_record_registration_date) });
        data.push({ field: 'Материалы здания', value: options.materials });
        data.push({ field: 'Разрешенное использование', value: options.permitted_use_name });
        data.push({ field: 'Кадастровый номер квартала', value: options.quarter_cad_number });
        data.push({ field: 'Количество подземных этажей', value: options.underground_floors });
        data.push({ field: 'Объединенные кадастровые номера', value: options.united_cad_numbers });
        data.push(commonFields[5]);
        data.push({ field: 'Дата внесения', value: formatDate(properties.systemInfo?.inserted) || '' });
    }

    data = data.filter(item => {
        const value = typeof item.value === 'function' ? item.value() : item.value;
        return value !== null && value !== undefined && value !== '';
    });

    tableBody.innerHTML = '';

    data.forEach(row => {
        const tr = document.createElement('tr');
        const value = typeof row.value === 'function' ? row.value() : row.value;

        const isHtml = /<[a-z][\s\S]*>/i.test(value);
        
        const valueCellContent = isHtml ? value : `<strong>${value}</strong>`;
        
        tr.innerHTML = `<td>${row.field}</td>
                        <td>
                            ${valueCellContent}
                            <button class="copy-icon-button" onclick="copyRowContent(this)">
                                <i class="fas fa-copy"></i>
                            </button>
                        </td>`;

        tableBody.appendChild(tr);
    });
}


function calculateDistance(coord1, coord2) {
    const dx = coord2[0] - coord1[0];
    const dy = coord2[1] - coord1[1];
    return Math.sqrt(dx * dx + dy * dy);
}


function drawScheme() {
    const canvas = document.getElementById('schemeCanvas');
    const ctx = canvas.getContext('2d');
    schemeParams = {};

    const container = document.querySelector('.scheme-container');
    if (container.style.display === 'none') {
        container.style.display = 'block';
    }

    canvas.width = container.offsetWidth;
    canvas.height = container.offsetHeight;

    ctx.clearRect(0, 0, canvas.width, canvas.height);

    if (!currentCoords || currentCoords.length === 0) {
        console.error('Нет координат для отрисовки');
        return;
    }

    let allCoords = [];

    if (currentCoords[0] && Array.isArray(currentCoords[0][0])) {
        if (Array.isArray(currentCoords[0][0][0])) {
            currentCoords.forEach(polygon => {
                polygon.forEach(ring => {
                    allCoords = allCoords.concat(ring.map(coord => [coord[0], coord[1]]));
                });
            });
        } else {
            currentCoords.forEach(ring => {
                allCoords = allCoords.concat(ring.map(coord => [coord[0], coord[1]]));
            });
        }
    } else if (currentCoords[0] && Array.isArray(currentCoords[0])) {
        currentCoords.forEach(line => {
            allCoords = allCoords.concat(line.map(coord => [coord[0], coord[1]]));
        });
    } else {
        console.error('Отрисовка Point в drawScheme не поддерживается');
        return;
    }

    const minX = Math.min(...allCoords.map(p => p[0]));
    const maxX = Math.max(...allCoords.map(p => p[0]));
    const minY = Math.min(...allCoords.map(p => p[1]));
    const maxY = Math.max(...allCoords.map(p => p[1]));

    const width = maxX - minX;
    const height = maxY - minY;
    const padding = 40;

    const scaleX = (canvas.width - padding * 2) / width;
    const scaleY = (canvas.height - padding * 2) / height;
    const scale = Math.min(scaleX, scaleY);

    const offsetX = (canvas.width - width * scale) / 2;
    const offsetY = (canvas.height - height * scale) / 2;

    schemeParams = { minX, minY, scale, offsetX, offsetY };

    function calculateSphericalPolygonArea(coords) {
        if (coords.length < 3) return 0;
        const R = 6371000;
        let area = 0;
        const latLonCoords = coords.map(coord => {
            const [lon, lat] = convertToWGS84(coord[0], coord[1]);
            return [lon * Math.PI / 180, lat * Math.PI / 180];
        });
        for (let i = 0; i < latLonCoords.length; i++) {
            const j = (i + 1) % latLonCoords.length;
            area += (latLonCoords[j][0] - latLonCoords[i][0]) *
                (2 + Math.sin(latLonCoords[i][1]) + Math.sin(latLonCoords[j][1]));
        }
        area = area * (R * R) / 2;
        return area;
    }

    function calculateTotalArea(rings) {
        if (!rings || rings.length === 0) return 0;
        let totalArea = 0;
        const outerArea = calculateSphericalPolygonArea(rings[0]);
        totalArea = Math.abs(outerArea);
        if (rings.length > 1) {
            for (let i = 1; i < rings.length; i++) {
                const innerArea = calculateSphericalPolygonArea(rings[i]);
                totalArea -= Math.abs(innerArea);
            }
        }
        return totalArea;
    }

    function calculatePerimeter(ring) {
        if (ring.length < 2) return 0;
        let perimeter = 0;
        const latLonCoords = ring.map(coord => convertToWGS84(coord[0], coord[1]));
        for (let i = 0; i < latLonCoords.length - 1; i++) {
            perimeter += haversineDistance(latLonCoords[i], latLonCoords[i + 1]);
        }
        perimeter += haversineDistance(latLonCoords[latLonCoords.length - 1], latLonCoords[0]);
        return perimeter;
    }

    const drawSinglePolygon = (polygonCoords) => {
        ctx.beginPath();
        polygonCoords.forEach((coord, index) => {
            const x = offsetX + (coord[0] - minX) * scale;
            const y = canvas.height - (offsetY + (coord[1] - minY) * scale);
            if (index === 0) ctx.moveTo(x, y);
            else ctx.lineTo(x, y);
        });
        ctx.closePath();
        ctx.strokeStyle = '#2196F3';
        ctx.lineWidth = 2;
        ctx.stroke();
        ctx.fillStyle = 'rgba(33, 150, 243, 0.1)';
        ctx.fill();
    };

    const drawSingleLine = (lineCoords) => {
        ctx.beginPath();
        lineCoords.forEach((coord, index) => {
            const x = offsetX + (coord[0] - minX) * scale;
            const y = canvas.height - (offsetY + (coord[1] - minY) * scale);
            if (index === 0) ctx.moveTo(x, y);
            else ctx.lineTo(x, y);
        });
        ctx.strokeStyle = '#2196F3';
        ctx.lineWidth = 2;
        ctx.stroke();
    };

    if (currentCoords[0] && Array.isArray(currentCoords[0][0])) {
        if (Array.isArray(currentCoords[0][0][0])) {
            currentCoords.forEach(polygon => {
                polygon.forEach(ring => drawSinglePolygon(ring));
            });
        } else {
            currentCoords.forEach(ring => drawSinglePolygon(ring));
        }
    } else if (currentCoords[0] && Array.isArray(currentCoords[0])) {
        currentCoords.forEach(line => drawSingleLine(line));
    }

    const drawPointsAndLabels = (polygonCoords) => {
        const labelOffset = 12;
        const minDistance = 20;
        let previousLabelX = null;
        let previousLabelY = null;
        polygonCoords.forEach((coord, index) => {
            const x = offsetX + (coord[0] - minX) * scale;
            const y = canvas.height - (offsetY + (coord[1] - minY) * scale);
            ctx.beginPath();
            ctx.arc(x, y, 4, 0, Math.PI * 2);
            ctx.fillStyle = '#FF4081';
            ctx.fill();
            if (index === polygonCoords.length - 1) {
                const firstX = offsetX + (polygonCoords[0][0] - minX) * scale;
                const firstY = canvas.height - (offsetY + (polygonCoords[0][1] - minY) * scale);
                if (Math.abs(x - firstX) < 1 && Math.abs(y - firstY) < 1) {
                    return;
                }
            }
            if (previousLabelX !== null && previousLabelY !== null) {
                const distance = Math.sqrt((x - previousLabelX) ** 2 + (y - previousLabelY) ** 2);
                if (distance < minDistance) {
                    return;
                }
            }
            ctx.fillStyle = '#333';
            ctx.font = '10px Arial';
            ctx.fillText(index + 1, x + labelOffset, y - labelOffset);
            previousLabelX = x + labelOffset;
            previousLabelY = y - labelOffset;
        });
    };

    if (currentCoords[0] && Array.isArray(currentCoords[0][0])) {
        if (Array.isArray(currentCoords[0][0][0])) {
            currentCoords.forEach(polygon => {
                polygon.forEach(ring => drawPointsAndLabels(ring));
            });
        } else {
            currentCoords.forEach(ring => drawPointsAndLabels(ring));
        }
    } else if (currentCoords[0] && Array.isArray(currentCoords[0])) {
        currentCoords.forEach(line => drawPointsAndLabels(line));
    }

    const drawDistances = (coords) => {
        ctx.fillStyle = '#000';
        ctx.font = '12px Arial';
        const isPointVisible = (x, y) => x >= 0 && x <= canvas.width && y >= 0 && y <= canvas.height;
        for (let i = 0; i < coords.length - 1; i++) {
            const [x1, y1] = coords[i];
            const [x2, y2] = coords[i + 1];
            const [lon1, lat1] = convertToWGS84(x1, y1);
            const [lon2, lat2] = convertToWGS84(x2, y2);
            const distance = haversineDistance([lon1, lat1], [lon2, lat2]);
            if (distance === 0) continue;
            const canvasX1 = offsetX + (x1 - minX) * scale;
            const canvasY1 = canvas.height - (offsetY + (y1 - minY) * scale);
            const canvasX2 = offsetX + (x2 - minX) * scale;
            const canvasY2 = canvas.height - (offsetY + (y2 - minY) * scale);
            const midX = (canvasX1 + canvasX2) / 2;
            const midY = (canvasY1 + canvasY2) / 2;
            if (isPointVisible(midX, midY)) {
                ctx.fillText(`${distance.toFixed(1)} м`, midX, midY);
            }
        }
        if (currentCoords[0] && Array.isArray(currentCoords[0][0]) && Array.isArray(currentCoords[0][0][0])) {
            const [x1, y1] = coords[coords.length - 1];
            const [x2, y2] = coords[0];
            const [lon1, lat1] = convertToWGS84(x1, y1);
            const [lon2, lat2] = convertToWGS84(x2, y2);
            const distance = haversineDistance([lon1, lat1], [lon2, lat2]);
            if (distance !== 0) {
                const canvasX1 = offsetX + (x1 - minX) * scale;
                const canvasY1 = canvas.height - (offsetY + (y1 - minY) * scale);
                const canvasX2 = offsetX + (x2 - minX) * scale;
                const canvasY2 = canvas.height - (offsetY + (y2 - minY) * scale);
                const midX = (canvasX1 + canvasX2) / 2;
                const midY = (canvasY1 + canvasY2) / 2;
                if (isPointVisible(midX, midY)) {
                    ctx.fillText(`${distance.toFixed(1)} м`, midX, midY);
                }
            }
        }
    };

    if (showDistanceLabels) {
        if (currentCoords[0] && Array.isArray(currentCoords[0][0])) {
            if (Array.isArray(currentCoords[0][0][0])) {
                currentCoords.forEach(polygon => {
                    polygon.forEach(ring => drawDistances(ring));
                });
            } else {
                currentCoords.forEach(ring => drawDistances(ring));
            }
        } else if (currentCoords[0] && Array.isArray(currentCoords[0])) {
            currentCoords.forEach(line => drawDistances(line));
        }
        let objectTypeInfo = "";
        let objectCount = 0;
        let areas = [];
        let perimeters = [];
        if (currentCoords[0] && Array.isArray(currentCoords[0][0]) && Array.isArray(currentCoords[0][0][0])) {
            objectTypeInfo = "Контур: ";
            objectCount = currentCoords.length;
            currentCoords.forEach((polygon, index) => {
                const area = calculateTotalArea(polygon);
                areas.push({ index: index + 1, value: Math.round(area * 1.0046705998033432) });
                const perimeter = calculatePerimeter(polygon[0]);
                perimeters.push({ index: index + 1, value: Math.round(perimeter) });
            });
        } else if (currentCoords[0] && Array.isArray(currentCoords[0][0])) {
            objectTypeInfo = "Контур: ";
            objectCount = 1;
            const area = calculateTotalArea(currentCoords);
            areas.push({ index: 1, value: Math.round(area * 1.0046705998033432) });
            const perimeter = calculatePerimeter(currentCoords[0]);
            perimeters.push({ index: 1, value: Math.round(perimeter) });
        } else if (currentCoords[0] && Array.isArray(currentCoords[0])) {
            objectTypeInfo = "Контуров: ";
            objectCount = currentCoords.length;
        }
        ctx.fillStyle = '#333';
        ctx.font = '14px Arial';
        const lineHeight = 20;
        let yOffset = canvas.height - 10;
        const countText = objectCount > 0 ? `${objectCount}` : "0";
        ctx.fillText(`${objectTypeInfo}${countText}`, 10, yOffset);
        yOffset -= lineHeight;
        if (areas.length > 0) {
            areas.forEach((areaObj, idx) => {
                const formattedArea = formatNumberWithSpaces(areaObj.value);
                ctx.fillText(`Площадь (${areaObj.index}): ${formattedArea} м²`, 10, yOffset);
                yOffset -= lineHeight;
                const perimeterObj = perimeters[idx];
                const formattedPerimeter = formatNumberWithSpaces(perimeterObj.value);
                ctx.fillText(`Периметр (${perimeterObj.index}): ${formattedPerimeter} м`, 10, yOffset);
                yOffset -= lineHeight;
            });
        }
    }
}



// Функция для проверки пересечения подписи с линией
function isLabelOverLine(ctx, x1, y1, x2, y2, textX, textY, textWidth, padding) {
    const textHeight = parseInt(ctx.font);
    const rectLeft = textX - padding;
    const rectRight = textX + textWidth + padding;
    const rectTop = textY - textHeight - padding;
    const rectBottom = textY + padding;
    
    // Проверка, если линия горизонтальна
    if (Math.abs(y1 - y2) < 1) {
      // Проверяем, что линия находится внутри прямоугольника
     if (y1 > rectTop && y1 < rectBottom && 
            ((x1 > rectLeft && x1 < rectRight) || (x2 > rectLeft && x2 < rectRight))) {
        return true;
    }

     }

      // Проверка, если линия вертикальна
    if (Math.abs(x1 - x2) < 1) {
        // Проверяем, что линия находится внутри прямоугольника
     if (x1 > rectLeft && x1 < rectRight && 
            ((y1 > rectTop && y1 < rectBottom) || (y2 > rectTop && y2 < rectBottom))) {
       return true;
      }
    }

    // Общая проверка для наклонных линий
    const lineStart = {x: x1, y: y1};
    const lineEnd = {x: x2, y: y2};
    const lineRect = {x: rectLeft, y: rectTop, w: rectRight - rectLeft, h: rectBottom - rectTop};
    
     if (intersectsLineRectangle(lineStart, lineEnd, lineRect)) {
        return true;
    }

    return false;
}

function intersectsLineRectangle(lineStart, lineEnd, rect) {
    // Функция для проверки пересечения линии с отрезком
    const lineToSegment = (p1, p2, p3, p4) => {
        const det = (p2.x - p1.x) * (p4.y - p3.y) - (p2.y - p1.y) * (p4.x - p3.x);
        if (det === 0) return false;

        const lambda = ((p3.x - p1.x) * (p4.y - p3.y) - (p3.y - p1.y) * (p4.x - p3.x)) / det;
        const mu = ((p1.x - p3.x) * (p2.y - p1.y) - (p1.y - p3.y) * (p2.x - p1.x)) / -det;

        return lambda >= 0 && lambda <= 1 && mu >= 0 && mu <= 1;
    };
   
    // Проверяем пересечение с каждой стороной прямоугольника
    return (
        lineToSegment(lineStart, lineEnd, {x: rect.x, y: rect.y}, {x: rect.x + rect.w, y: rect.y}) || //top
        lineToSegment(lineStart, lineEnd, {x: rect.x + rect.w, y: rect.y}, {x: rect.x + rect.w, y: rect.y + rect.h}) || //right
        lineToSegment(lineStart, lineEnd, {x: rect.x + rect.w, y: rect.y + rect.h}, {x: rect.x, y: rect.y + rect.h}) || //bottom
        lineToSegment(lineStart, lineEnd, {x: rect.x, y: rect.y + rect.h}, {x: rect.x, y: rect.y})   //left

    );
}


// Функция очистки canvas
function clearCanvas() {
    const canvas = document.getElementById('schemeCanvas');
    const ctx = canvas.getContext('2d');
    ctx.clearRect(0, 0, canvas.width, canvas.height);
}



// Функция для форматирования кадастрового номера с учетом настройки
function formatCadastralNumber(input) {
    let value = input.value.replace(/\D/g, ''); // Убираем все нецифровые символы
    let formatted = '';

    if (value.length > 0) formatted += value.slice(0, 2); // Первые 2 цифры
    if (value.length > 2) formatted += ':' + value.slice(2, 4); // Следующие 2 цифры

    // Определяем количество знаков после второго двоеточия
    const firstTwoDigits = value.slice(0, 2);
    const isSixDigits = sixDigitsRegions.includes(firstTwoDigits);
    const digitsAfterSecondColon = isSixDigits ? 6 : 7;

    if (value.length > 4) {
        formatted += ':' + value.slice(4, 4 + digitsAfterSecondColon); // Следующие 6 или 7 цифр
    }
    if (value.length > (isSixDigits ? 10 : 11)) {
        formatted += ':' + value.slice(isSixDigits ? 10 : 11); // Остальные цифры
    }

    input.value = formatted; // Обновляем значение поля ввода
}

function showCoordinates() {
    // --- ИЗМЕНЕНИЕ: Условие открытия окна стало более строгим,
    // чтобы избежать показа координат от предыдущего запроса.

    // 1. Получаем номер из поля ввода.
    const cadNumFromInput = document.getElementById('cadastralNumber').value;

    // 2. Получаем номер из уже отображенной таблицы результатов.
    let cadNumFromTable = null;
    const tableRows = document.querySelectorAll('#resultTable tbody tr');
    for (let row of tableRows) {
        if (row.cells && row.cells.length > 1 && row.cells[0].textContent.trim() === 'Кадастровый номер') {
            const valueCell = row.cells[1];
            const strongTag = valueCell.querySelector('strong');
            cadNumFromTable = strongTag ? strongTag.textContent.trim() : valueCell.textContent.trim();
            break;
        }
    }

    // 3. Проверяем, что данные загружены и соответствуют тому, что введено в поле.
    const dataIsReadyAndMatches =
        currentCoords &&
        currentCoords.length > 0 &&
        isValidCadastralNumber(cadNumFromInput) &&
        cadNumFromInput === cadNumFromTable;

    if (dataIsReadyAndMatches) {
        // --- Показываем окно с координатами ---
        const modal = document.getElementById('coordinatesModal');
        const tbody = document.querySelector('#modalCoordinatesTable tbody');
        tbody.innerHTML = ''; // Очищаем предыдущие строки

        let pointIndex = 1;

        // MultiPolygon
        if (currentCoords[0] && Array.isArray(currentCoords[0][0]) && Array.isArray(currentCoords[0][0][0])) {
            currentCoords.forEach(polygon => {
                polygon.forEach(ring => {
                    ring.forEach(coord => {
                        const tr = document.createElement('tr');
                        tr.innerHTML = `<td>${pointIndex++}</td><td>${coord[0]}</td><td>${coord[1]}</td>`;
                        tbody.appendChild(tr);
                    });
                });
            });
        // Polygon
        } else if (currentCoords[0] && Array.isArray(currentCoords[0][0])) {
            currentCoords.forEach(ring => {
                ring.forEach(coord => {
                    const tr = document.createElement('tr');
                    tr.innerHTML = `<td>${pointIndex++}</td><td>${coord[0]}</td><td>${coord[1]}</td>`;
                    tbody.appendChild(tr);
                });
            });
        // MultiLineString
        } else if (currentCoords[0] && Array.isArray(currentCoords[0])) {
            currentCoords.forEach(line => {
                line.forEach(coord => {
                    const tr = document.createElement('tr');
                    tr.innerHTML = `<td>${pointIndex++}</td><td>${coord[0]}</td><td>${coord[1]}</td>`;
                    tbody.appendChild(tr);
                });
            });
        // Point
        } else {
            const tr = document.createElement('tr');
            tr.innerHTML = `<td>${pointIndex++}</td><td>${currentCoords[0][0]}</td><td>${currentCoords[0][1]}</td>`;
            tbody.appendChild(tr);
        }

        modal.style.display = 'block'; // Показываем модальное окно с координатами
    } else {
        // --- Во всех остальных случаях (нет данных, неверный номер, несоответствие) открываем окно "Запрос данных по списку" ---
        const batchModal = document.getElementById('batchCadastralModal');
        batchModal.style.display = 'block';
    }
}

// Функция для копирования всех координат в буфер обмена
function copyCoordinates() {
   if (!currentCoords || currentCoords.length === 0) {
        showNotification('Нет данных для копирования', 'error');
        return;
    }

    let coordsString = '';

    // Формируем строку в зависимости от типа геометрии
   // MultiPolygon
    if (currentCoords[0] && Array.isArray(currentCoords[0][0]) && Array.isArray(currentCoords[0][0][0])) {
        currentCoords.forEach(polygon => {
            polygon.forEach(ring => {
                ring.forEach(coord => {
                    coordsString += `${coord[0]}\t${coord[1]}\n`;
                });
            });
        });
    // Polygon
    } else if (currentCoords[0] && Array.isArray(currentCoords[0][0])) {
        currentCoords.forEach(ring => {
            ring.forEach(coord => {
                coordsString += `${coord[0]}\t${coord[1]}\n`;
            });
        });
    // MultiLineString
    } else if (currentCoords[0] && Array.isArray(currentCoords[0])) {
        currentCoords.forEach(line => {
            line.forEach(coord => {
                coordsString += `${coord[0]}\t${coord[1]}\n`;
            });
        });
    // Point
    } else {
        coordsString = `${currentCoords[0][0]}\t${currentCoords[0][1]}`;
    }


    // Копируем в буфер обмена
    navigator.clipboard.writeText(coordsString)
        .then(() => {
            showNotification('Координаты скопированы в буфер обмена', 'success');
        })
        .catch(err => {
            console.error('Ошибка при копировании координат:', err);
            showNotification('Не удалось скопировать координаты', 'error');
        });
}



function checkClipboardForCadastralNumber() {
    navigator.clipboard.readText()
        .then(text => {
            const input = document.getElementById('cadastralNumber');

            // Функция для форматирования и вставки
            const tryInsertAndFormat = (isSixDigits) => {
                let value = text.replace(/\D/g, '');
                let formatted = '';

                if (value.length > 0) formatted += value.slice(0, 2);
                if (value.length > 2) formatted += ':' + value.slice(2, 4);

                const digitsAfterSecondColon = isSixDigits ? 6 : 7;
                if (value.length > 4) {
                    formatted += ':' + value.slice(4, 4 + digitsAfterSecondColon);
                }
                if (value.length > (isSixDigits ? 10 : 11)) {
                    formatted += ':' + value.slice(isSixDigits ? 10 : 11);
                }

                if (isValidCadastralNumber(formatted)) {
                    input.value = formatted;
                    return true; // Успешная вставка
                }
                return false;
            };

            // Пытаемся определить, сколько цифр нужно (6 или 7)
            let inserted = false;
            // Сначала проверяем с 7 знаками (по умолчанию)
            if (tryInsertAndFormat(false)) {
                inserted = true;
            }
            // Если не получилось, проверяем с 6 знаками (для региона "16")
            else if (tryInsertAndFormat(true)) {
                inserted = true;
            }

            if (!inserted) {
                // Если формат не распознан, вставляем как есть
                input.value = text;
            }

            // Форматируем ввод ещё раз
            formatCadastralNumber(input);

            // Если вставился корректный номер, делаем поиск
            if (isValidCadastralNumber(input.value)) {
                document.querySelector('.search-button').click();
            }
        })
        .catch(err => {
            console.error('Ошибка при чтении буфера обмена:', err);
        });
}



// Обработчик закрытия модального окна
document.querySelector('.close-modal').addEventListener('click', function() {
    document.getElementById('coordinatesModal').style.display = 'none';
});


// Функция для форматирования списка кадастровых номеров в textarea
// Функция для форматирования списка кадастровых номеров в textarea
function formatCadastralList() {
    const textarea = document.getElementById('cadastralListInput');
    let value = textarea.value;

    // --- CHANGE: Revised Logic ---
    // 1. Replace known separators (comma, semicolon) with newline globally
    value = value.replace(/[,;]/g, '\n');

    // 2. Split by newline, trim each line, filter empty lines, rejoin.
    // This preserves intended newlines while cleaning up lines
    // and removing blank lines created by separators.
    const lines = value.split('\n')
                       .map(line => line.trim()) // Trim whitespace from start/end of each line
                       .filter(line => line.length > 0); // Remove empty lines

    // 3. Join back with single newline. Store cursor position.
    const currentCursorPos = textarea.selectionStart;
    const originalLength = textarea.value.length;
    textarea.value = lines.join('\n');
    const newLength = textarea.value.length;

    // 4. Try to restore cursor position (might be slightly off after filtering)
    // This helps prevent the cursor from jumping unexpectedly
    const diff = newLength - originalLength;
    textarea.selectionStart = textarea.selectionEnd = Math.max(0, currentCursorPos + diff);
    // --- End Revised Logic ---
}



// Функция для закрытия конкретного модального окна по ID
function closeSpecificModal(modalId) {
    const modal = document.getElementById(modalId);
    if (modal) {
        modal.style.display = 'none';
    }
}


// Добавляем слушатель события 'input' для автоматического форматирования
const cadastralListTextArea = document.getElementById('cadastralListInput');
if (cadastralListTextArea) {
  //  cadastralListTextArea.addEventListener('input', formatCadastralList);
}

// --- NEW Function to clean and format the list from textarea ---
function getFormattedCadList(rawText) {
    let value = rawText;

    // 1. Replace known separators (comma, semicolon) with newline globally
    value = value.replace(/[,;]/g, '\n');

    // 2. Split by newline, trim each line, filter empty lines.
    const lines = value.split('\n')
                       .map(line => line.trim()) // Trim whitespace
                       .filter(line => line.length > 0); // Remove empty lines

    // Return the array of cleaned numbers
    return lines;
}



// Функция для обработки поиска по номеру права
document.querySelector('.search-right-button').addEventListener('click', function() {
    const rightNumber = document.getElementById('rightNumberInput').value.trim();
    if (!rightNumber) {
        showNotification('Введите номер права', 'error');
        return;
        
    }

    // Заменяем / на %2F в номере права
    const formattedRightNumber = rightNumber.replace(/\//g, '%2F');
    
    // Выполняем запрос
    fetch(`https://rosreestr.gov.ru/api/online/right/16/${formattedRightNumber}`)
        .then(response => response.json())
        .then(data => {
            if (data && data.length > 0) {
                const result = data[0];
                
                // Обновляем таблицу результатов
                document.getElementById('rightNumber').textContent = rightNumber;
                document.getElementById('cadastralNumberFound').textContent = result.objectCn;
                document.getElementById('addressFound').textContent = result.addressNotes;
                
                // Показываем таблицу
                document.getElementById('rightSearchTable').style.display = 'table';
                
                // Вставляем кадастровый номер в основное поле поиска и запускаем поиск
                document.getElementById('cadastralNumber').value = result.objectCn;
                fetchData(); // Запускаем поиск по кадастровому номеру
            } else {
                showNotification('Данные не найдены', 'error');
            }
        })
        .catch(error => {
            console.error('Ошибка:', error);
            showNotification('Произошла ошибка при поиске', 'error');
        });
    fetchData(true);
});

// Обработчик для клавиши Enter в поле ввода номера права
document.getElementById('rightNumberInput').addEventListener('keydown', function(event) {
    if (event.key === 'Enter') {
        document.querySelector('.search-right-button').click();
    }
});

// Функция открытия карты
function openMap() {
    if (!currentCoords || currentCoords.length === 0) {
        showNotification('Нет данных для отображения карты', 'error');
        return;
    }

    let x, y;

    // MultiPolygon
    if (currentCoords[0] && Array.isArray(currentCoords[0][0]) && Array.isArray(currentCoords[0][0][0])) {
        x = parseFloat(currentCoords[0][0][0][0]); // Преобразуем строку в число
        y = parseFloat(currentCoords[0][0][0][1]);
    // Polygon
    } else if (currentCoords[0] && Array.isArray(currentCoords[0][0])) {
        x = parseFloat(currentCoords[0][0][0]); // Преобразуем строку в число
        y = parseFloat(currentCoords[0][0][1]);
    // MultiLineString
    } else if (currentCoords[0] && Array.isArray(currentCoords[0])) {
        x = parseFloat(currentCoords[0][0][0]); // Преобразуем строку в число
        y = parseFloat(currentCoords[0][0][1]);
    // Point
    } else {
        x = parseFloat(currentCoords[0][0]); // Преобразуем строку в число
        y = parseFloat(currentCoords[0][1]);
    }

    // Проверяем, что x и y успешно преобразованы в числа
    if (isNaN(x) || isNaN(y)) {
        showNotification('Некорректные координаты', 'error');
        return;
    }

    const formattedX = x.toFixed(3);
    const formattedY = y.toFixed(3);
    const mapUrl = `https://nspd.gov.ru/map?zoom=20&coordinate_x=${formattedX}&coordinate_y=${formattedY}&theme_id=1&is_copy_url=true&active_layers=36329%2C36328%2C36049%2C36048`;
    window.open(mapUrl, '_blank');
}

// Обработчики событий

document.getElementById('cadastralNumber').addEventListener('input', function(e) {
    formatCadastralNumber(e.target);

    // Если поле ввода пустое, возвращаем заголовок по умолчанию
    if (e.target.value.trim() === '') {
        document.title = 'ЕГРН';
    }
});

document.getElementById('cadastralNumber').addEventListener('keydown', function(event) {
    if (event.key === 'Enter') {
        fetchData();
    }
});



     // Функция для добавления цифры в поле ввода
        function addDigitToInput(digit) {
            const input = document.getElementById('cadastralNumber');
            input.value += digit;
            formatCadastralNumber(input); // Форматируем ввод
        }


 
        // Функция для показа/скрытия виртуальной клавиатуры
        function toggleVirtualKeyboard() {
            const keyboard = document.getElementById('virtualKeyboard');
            keyboard.classList.toggle('active');
        }

        // Функция для закрытия клавиатуры при клике вне её
        function closeVirtualKeyboard(event) {
            const keyboard = document.getElementById('virtualKeyboard');
            const mobileButton = document.getElementById('mobileKeyboardButton');
            if (
                !keyboard.contains(event.target) &&
                !mobileButton.contains(event.target)
            ) {
                keyboard.classList.remove('active');
            }
        }

        // Обработчик нажатия клавиш
        document.addEventListener('keydown', function(event) {
            if (event.key === 'F9') {
                toggleVirtualKeyboard();
            }
        });

        // Обработчик кликов по клавишам виртуальной клавиатуры
   // Функция для обработки нажатия Enter
function handleEnter() {
    fetchData(); // Вызываем функцию fetchData (аналог нажатия Enter)
       
}

// Функция для удаления последнего символа в поле ввода
function clearLastCharacter() {
    const input = document.getElementById('cadastralNumber');
    input.value = input.value.slice(0, -1); // Удаляем последний символ
    formatCadastralNumber(input); // Форматируем ввод
}

// Функция для очистки всего поля ввода
function clearInput() {
    const input = document.getElementById('cadastralNumber');
    input.value = ''; // Очищаем всё поле
}

document.querySelectorAll('.keyboard-key').forEach(key => {
    if (key.classList.contains('clear')) {
        key.addEventListener('click', clearLastCharacter);
    } else if (key.classList.contains('enter')) {
        key.addEventListener('click', handleEnter);
    } else if (key.classList.contains('insert')) {
        // Только один обработчик для кнопки Insert
        key.addEventListener('click', insertFromClipboard);
    } else {
        key.addEventListener('click', function() {
            addDigitToInput(this.getAttribute('data-key'));
        });
    }
});
        // Обработчик для мобильной кнопки клавиатуры
        document.getElementById('mobileKeyboardButton').addEventListener('click', function(event) {
            event.stopPropagation();
            toggleVirtualKeyboard();
        });

        // Обработчик кликов по документу для закрытия клавиатуры
        document.addEventListener('click', closeVirtualKeyboard);

    
    
    // Обработчик закрытия модального окна
document.querySelectorAll('.close-modal').forEach(button => {
    button.addEventListener('click', function() {
        const modal = this.closest('.modal');
        modal.style.display = 'none';
    });
});

 

// Обработчик двойного клика для закрытия модального окна
document.querySelector('.modal-content').addEventListener('dblclick', function(event) {
    // Проверяем, что двойной клик был не по кнопке convertButton
    if (event.target.id !== 'convertButton') {
        closeModal(); // Закрываем модальное окно
    }
});

// Функция для закрытия модального окна
function closeModal() {
    const modal = document.getElementById('coordinatesModal');
    modal.style.display = 'none';
}


// Function to save the toggle state to local storage
function saveToggleState(state) {
    localStorage.setItem('distanceToggleState', state);
}

// Function to load the toggle state from local storage
function loadToggleState() {
    const savedState = localStorage.getItem('distanceToggleState');
    return savedState === 'true';
}

// Function to toggle the distance labels
function toggleDistanceLabels() {
    showDistanceLabels = !showDistanceLabels;
    saveToggleState(showDistanceLabels); // Save the state to local storage
    drawScheme(); // Redraw the scheme with/without labels
}


    // Обработчик двойного клика на координату в таблице
    document.getElementById('modalCoordinatesTable').addEventListener('dblclick', function(event) {
    const target = event.target;
    if (target.tagName === 'TD' && target.cellIndex !== 0) { // Проверяем, что это не первая ячейка (с номером)
        event.stopPropagation();
        const row = target.parentElement;
        const x = parseFloat(row.cells[1].textContent);
        const y = parseFloat(row.cells[2].textContent);
        const [lon, lat] = convertToWGS84(x, y);
        const url = `https://yandex.ru/maps/?l=sat%2Cskl&ll=${lon},${lat}&z=21&pt=${lon},${lat}`;
        window.open(url);
    }
});


document.getElementById('schemeCanvas').addEventListener('dblclick', function(event) {
    const canvas = document.getElementById('schemeCanvas');
    const rect = canvas.getBoundingClientRect();
    const clickY = event.clientY - rect.top; // Позиция клика относительно верха canvas

    // Проверяем, что клик произошел в верхних 2 см (примерно 75 пикселей при стандартном DPI)
    const topThreshold = 75; // 2 см ≈ 75 пикселей
    if (clickY <= topThreshold) {
        // Получаем элементы, которые нужно сохранить
        const table = document.getElementById('resultTable');
        const schemeCanvas = document.getElementById('schemeCanvas');

        if (!table || !schemeCanvas) {
            showNotification('Таблица или чертеж не найдены', 'error');
            return;
        }

        // Извлекаем чистый текст из таблицы (plain текст без форматирования)
        const rows = table.querySelectorAll('tr');
        let plainTextRows = [];
        rows.forEach(row => {
            const cells = row.querySelectorAll('td, th');
            let rowText = [];
            cells.forEach(cell => {
                rowText.push(cell.textContent.trim()); // Извлекаем только текст
            });
            if (rowText.length > 0) {
                plainTextRows.push(rowText);
            }
        });

        // Создаем новую таблицу с чистым текстом, делая левую колонку шире
        const newTable = document.createElement('table');
        newTable.style.width = 'auto'; // Автоматическая ширина, подстраивающаяся под содержимое
        newTable.style.maxWidth = '600px'; // Ограничение ширины таблицы для компактности
        newTable.style.backgroundColor = '#ffffff'; // Яркий белый фон
        newTable.style.color = '#000000'; // Полностью черный текст
        newTable.style.fontSize = '14px'; // Уменьшенный размер текста для компактности
        newTable.style.fontWeight = 'bold'; // Жирный текст для контраста
        newTable.style.fontFamily = 'Arial, sans-serif'; // Надежный шрифт
        newTable.style.borderCollapse = 'collapse';
        newTable.style.border = '1px solid #000000'; // Тонкие черные границы

        plainTextRows.forEach(rowText => {
            const tr = document.createElement('tr');
            rowText.forEach((text, index) => {
                const td = document.createElement('td');
                td.textContent = text; // Вставляем чистый текст
                td.style.color = '#000000'; // Черный текст
                td.style.backgroundColor = '#ffffff'; // Белый фон
                td.style.border = '1px solid #000000'; // Тонкие черные границы
                td.style.padding = '6px'; // Уменьшенные отступы для компактности
                td.style.textAlign = 'left'; // Выравнивание
                td.style.whiteSpace = 'normal'; // Перенос текста
                td.style.wordBreak = 'break-word'; // Перенос слов
                td.style.lineHeight = '1.1'; // Минимальная высота строки для компактности

                // Делаем первую колонку (индекс 0) шире
                if (index === 0) {
                    td.style.width = '200px'; // Фиксированная ширина для левой колонки
                    td.style.minWidth = '200px'; // Минимальная ширина, чтобы текст не сжимался
                } else {
                    td.style.width = 'auto'; // Остальные колонки автоматически подстраиваются
                }
                tr.appendChild(td);
            });
            newTable.appendChild(tr);
        });

        // Определяем высоту таблицы после добавления содержимого в DOM
        document.body.appendChild(newTable); // Добавляем таблицу в DOM, чтобы вычислить высоту
        const tableHeight = newTable.offsetHeight;
        document.body.removeChild(newTable); // Сразу же убираем обратно

        // Клонируем и подстраиваем чертеж (canvas) под высоту таблицы, сохраняя пропорции
        const canvasClone = document.createElement('canvas');
        const canvasWidth = schemeCanvas.width; // Сохраняем исходную ширину
        const canvasAspectRatio = schemeCanvas.width / schemeCanvas.height; // Соотношение сторон оригинального canvas
        canvasClone.height = tableHeight; // Точная высота таблицы для согласованности
        canvasClone.width = canvasClone.height * canvasAspectRatio; // Вычисляем ширину, сохраняя пропорции
        const ctxClone = canvasClone.getContext('2d');
        ctxClone.fillStyle = '#ffffff'; // Яркий белый фон для canvas
        ctxClone.fillRect(0, 0, canvasClone.width, canvasClone.height); // Заливка белым фоном

        // Масштабируем содержимое оригинального canvas, чтобы оно точно поместилось, сохраняя пропорции
        const scale = canvasClone.height / schemeCanvas.height; // Масштаб по высоте
        ctxClone.scale(scale, scale); // Масштабируем пропорционально по обоим осям
        ctxClone.drawImage(schemeCanvas, 0, 0, schemeCanvas.width, schemeCanvas.height); // Копируем содержимое

        // Создаем временный контейнер с таблицей слева и чертежом справа
        const tempContainer = document.createElement('div');
        tempContainer.style.position = 'absolute';
        tempContainer.style.left = '-9999px'; // Убираем из видимой области
        tempContainer.style.background = '#fff'; // Яркий белый фон
        tempContainer.style.padding = '5px'; // Минимальный отступ
        tempContainer.style.display = 'flex'; // Горизонтальная ориентация
        tempContainer.style.flexDirection = 'row'; // Таблица слева, чертеж справа
        tempContainer.style.gap = '5px'; // Минимальное расстояние между таблицей и чертежом
        tempContainer.style.alignItems = 'flex-start'; // Выравнивание по верху
        tempContainer.style.maxWidth = '1200px'; // Ограничение общей ширины для компактности

        // Добавляем новую таблицу слева
        tempContainer.appendChild(newTable);

        // Добавляем чертеж (canvas) справа
        tempContainer.appendChild(canvasClone);

        // Добавляем временный контейнер в DOM
        document.body.appendChild(tempContainer);

        // Используем html2canvas для захвата контейнера с масштабом 2 (увеличение разрешения)
        html2canvas(tempContainer, {
            scale: 2, // Увеличили масштаб для улучшения качества (примерно 200 DPI)
            backgroundColor: '#ffffff', // Яркий белый фон
            useCORS: true, // Попытка загрузки внешних ресурсов с CORS
            allowTaint: true, // Разрешаем обработку потенциально "загрязненных" ресурсов
            logging: false,
            ignoreElements: (element) => element.tagName === 'SCRIPT' || element.tagName === 'STYLE' // Игнорируем скрипты и стили
        }).then(canvas => {
            // Преобразуем в JPG
            const imgData = canvas.toDataURL('image/jpeg', 0.95); // Высокое качество

            // Создаем ссылку для скачивания
            const link = document.createElement('a');
            link.href = imgData;

            // Генерируем имя файла с текущей датой и временем
            const now = new Date();
            const dateStr = now.toISOString().replace(/[:.]/g, '-').slice(0, 19);
            link.download = `egrn-${dateStr}.jpg`;

            // Скачиваем файл
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);

            // Удаляем временный контейнер
            document.body.removeChild(tempContainer);

            showNotification('Таблица и чертеж сохранены как JPG', 'success');
        }).catch(error => {
            console.error('Ошибка при сохранении с html2canvas:', error);
            showNotification('Ошибка при сохранении, проверьте консоль', 'error');

            // Удаляем временный контейнер в случае ошибки
            if (document.body.contains(tempContainer)) {
                document.body.removeChild(tempContainer);
            }
        });
    }
});



//=======================================================================//
//========== НАЧАЛО БЛОКА ИЗМЕНЕНИЙ ДЛЯ ЗАГРУЗКИ ИЗ АРХИВА ==============//
//=======================================================================//

// Добавьте эту константу в начало вашего скрипта
const STORAGE_API_URL = 'https://mapruapp.ru/storage';

/**
 * Главная функция, запускающая процесс загрузки данных из архива КПТ.
 */
async function fetchDataFromArchive() {
    const cadastralNumberInput = document.getElementById('cadastralNumber');
    const targetCadastralNumber = cadastralNumberInput.value.trim();

    // 1. Проверяем, введен ли корректный номер участка
    if (!isValidCadastralNumber(targetCadastralNumber)) {
        showNotification('Введите корректный кадастровый номер участка', 'error');
        return;
    }

    showNotification(`Поиск ${targetCadastralNumber} в архиве КПТ...`, 'info');

    try {
        // 2. Определяем номер квартала и формируем имя файла
        const quarterNumber = targetCadastralNumber.split(':').slice(0, 3).join(':');
        const filename = quarterNumber.replace(/:/g, '_') + '.nspd';

        // 3. Загружаем ZIP-архив с сервера
        const zipBlob = await fetchZipFromLocalServer('nspd', filename);
        if (!zipBlob) {
            showNotification(`Архив для квартала ${quarterNumber} не найден. Попробуйте обычный поиск.`, 'warning');
            return;
        }

        // 4. Распаковываем архив и получаем все участки квартала
        const { features } = await loadAndParseZipBlob(zipBlob);

        // 5. Ищем нужный нам участок в данных квартала
        const targetFeature = features.find(f => f.properties && f.properties.descr === targetCadastralNumber);

        if (!targetFeature) {
            showNotification(`Участок ${targetCadastralNumber} не найден в архиве квартала.`, 'error');
            return;
        }

        console.log("Найден участок в архиве:", targetFeature);

        // 6. Отображаем данные и схему найденного участка, используя существующие функции
        
        // --- ИСПРАВЛЕНИЕ ЗДЕСЬ ---
        // Правильно извлекаем вложенный объект options
        const properties = targetFeature.properties;
        const options = targetFeature.properties ? targetFeature.properties.options : {}; // Безопасное извлечение
        const geometry = targetFeature.geometry;
        // --- КОНЕЦ ИСПРАВЛЕНИЯ ---
        
        // Обновляем заголовок страницы
        document.title = `${targetCadastralNumber}`;

        // Обновляем таблицу с данными
        // Передаем корректно извлеченные 'options' и 'properties'
        updatePropertyData(options, properties, null, null);

        // Обновляем схему на canvas
        if (geometry && geometry.coordinates && geometry.type !== "Point") {
            currentCoords = geometry.coordinates; // Сохраняем координаты в глобальную переменную
            document.querySelector('.content-container').style.display = 'grid';
            document.querySelector('.scheme-container').style.display = 'block';
            drawScheme();
        } else {
            // Если у найденного объекта нет геометрии или это точка
            document.querySelector('.content-container').style.display = 'block';
            document.querySelector('.scheme-container').style.display = 'none';
            clearCanvas();
             if (geometry && geometry.type === "Point") {
                showNotification('Участок найден, но не имеет координат для отрисовки (геометрия-точка).', 'warning');
            } else {
                showNotification('Участок найден, но не имеет координат для отрисовки.', 'warning');
            }
        }

        document.getElementById('resultTable').style.display = 'table';
        showNotification('Данные из архива КПТ успешно загружены!', 'success');

    } catch (error) {
        console.error("Ошибка при работе с архивом:", error);
        showNotification(`Ошибка: ${error.message}`, 'error');
    }
}

/**
 * Загружает ZIP-файл с вашего сервера.
 * @param {string} bucketName - Имя "папки" на сервере ('nspd').
 * @param {string} filePathInBucket - Имя файла (например, '16_56_010130.nspd').
 * @returns {Promise<Blob|null>} - Blob-объект файла или null в случае ошибки.
 */
async function fetchZipFromLocalServer(bucketName, filePathInBucket) {
    try {
        const response = await fetch(`${STORAGE_API_URL}/${bucketName}/${filePathInBucket}`);
        if (!response.ok) {
            if (response.status === 404) {
                console.log(`Файл "${filePathInBucket}" не найден.`);
            } else {
                console.error(`Ошибка сервера ${response.status} для файла "${filePathInBucket}".`);
            }
            return null;
        }
        return await response.blob();
    } catch (error) {
        console.error(`Ошибка сети при запросе файла "${filePathInBucket}":`, error);
        return null;
    }
}

/**
 * Распаковывает ZIP-архив и парсит JSON-файл внутри него.
 * @param {Blob} zipBlob - Blob-объект ZIP-архива.
 * @returns {Promise<{features: any[], date: string|null, quarter: string|null}>} - Объект с данными.
 */
async function loadAndParseZipBlob(zipBlob) {
    if (!zipBlob) throw new Error("ZIP-файл для загрузки не предоставлен.");

    const zip = await JSZip.loadAsync(zipBlob);

    let jsonFile = null;
    let loadedDate = null;
    let inferredQuarter = null;
    const jsonFilenamePattern = /^(\d{2}_\d{2}_\d{6,7}(?:_\d+)?)\s(\d{4}-\d{2}-\d{2})\.json$/;

    for (const filename in zip.files) {
        const match = filename.match(jsonFilenamePattern);
        if (match) {
            jsonFile = zip.files[filename];
            inferredQuarter = match[1].replace(/_/g, ':');
            loadedDate = match[2];
            break;
        }
    }

    if (!jsonFile) {
        throw new Error("Файл данных (*.json) не найден в архиве.");
    }

    const jsonText = await jsonFile.async("text");
    const loadedFeatures = JSON.parse(jsonText);

    if (!Array.isArray(loadedFeatures)) {
        throw new Error("Файл содержит некорректные данные.");
    }

    return { features: loadedFeatures, date: loadedDate, quarter: inferredQuarter };
}

//=======================================================================//
//=========== КОНЕЦ БЛОКА ИЗМЕНЕНИЙ ДЛЯ ЗАГРУЗКИ ИЗ АРХИВА ==============//
//=======================================================================//



// Инициализация при загрузке страницы
window.onload = function() {
    showDistanceLabels = loadToggleState(); // Load the state from local storage
    document.getElementById('distanceToggle').checked = showDistanceLabels;
    document.getElementById('cadastralNumber').focus();

    // Check the clipboard for a cadastral number and insert it if available
    checkClipboardForCadastralNumber();

    // Check if the device is mobile
    if (window.innerWidth < 768) {
        const canvasContainer = document.querySelector('.scheme-container');
        canvasContainer.style.display = 'block';
        drawScheme();
        toggleVirtualKeyboard();
    }
};
</script>
    
</body>
</html>