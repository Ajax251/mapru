<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PDF</title>
    <script src="webfonts/pdf.min.js"></script>
    <script src="webfonts/pdf-lib.min.js"></script>
    <script src="webfonts/jszip.min.js"></script>
    <link rel="stylesheet" href="webfonts/all.min.css">
<link rel="icon" href="img/pdf.png" type="image/png">
<link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&display=swap" rel="stylesheet">
    
<style>

:root {
  --primary: #2c7be5; 
  --primary-light: #5a9cf8;
  --primary-dark: #0c63e4;
  --secondary: #87CEEB;
  --accent: #34ace0;
  --warning: #ffda79;
  --danger: #e84118;
  --green: #7cb518;
  --pink: #ff6b81;
  --light: #f9feff;
  --dark: #1e2430;
  --gray: #718096;
  --gray-light: #dfe6e9;
  --shadow-sm: 0 1px 3px rgba(0,0,0,0.12), 0 1px 2px rgba(0,0,0,0.08);
  --shadow-md: 0 4px 6px rgba(0,0,0,0.08), 0 1px 3px rgba(0,0,0,0.06);
  --shadow-lg: 0 10px 20px rgba(0,0,0,0.08), 0 6px 6px rgba(0,0,0,0.06);
  --radius: 10px;
}

/* Loader */
#loader {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background-color: rgba(0, 0, 0, 0.7);
  z-index: 9999;
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
}

.loader-spinner {
  border: 8px solid #f3f3f3;
  border-top: 8px solid var(--primary);
  border-radius: 50%;
  width: 60px;
  height: 60px;
  animation: spin 1s linear infinite;
}

.loader-text {
  color: white;
  font-size: 18px;
  font-weight: 600;
  margin-top: 20px;
}

@keyframes spin {
  0% { transform: rotate(0deg); }
  100% { transform: rotate(360deg); }
}

/* Base Styles */
body {
  font-family: 'Roboto', sans-serif;
  margin: 0;
  padding: 0;
  display: flex;
  flex-direction: column;
  height: 100vh;
  overflow: hidden;
  background-color: #f0f8ff;
  color: var(--dark);
  background-image: linear-gradient(to bottom right, #e6f7ff, #f5f7fa);
}

/* Layout */
.container {
  display: grid;
  grid-template-columns: 30% 55% 15%;
  grid-gap: 15px;
  flex-grow: 1;
  padding: 15px;
  height: 100%;
  min-height: 0;
}

/* Panels */
.left-panel {
  display: flex;
  flex-direction: column;
  height: 100%;
  gap: 15px;
  min-height: 0;
}

/* Common Panel Styles */
#pdf-list, #combined-files, #selected-pages-panel, #pdf-viewer {
  border-radius: var(--radius);
  background-color: white;
  box-shadow: var(--shadow-md);
  overflow: hidden;
  border: 1px solid rgba(116, 185, 255, 0.2);
}

#pdf-list {
  flex: 3;
  display: flex;
  flex-direction: column;
  padding: 15px;
  position: relative;
  background-color: rgba(255, 255, 255, 0.9);
  backdrop-filter: blur(5px);
  overflow: hidden;
  height: 100%;
}

#pdf-files-container {
  flex: 1;
  overflow-y: auto;
  margin-bottom: 15px;
  padding-right: 5px;
  height: calc(100% - 120px);
}

#combined-files {
  flex: 1;
  padding: 15px;
  position: relative;
  background-color: rgba(255, 255, 255, 0.9);
  backdrop-filter: blur(5px);
  height: 200px;
  min-height: 200px;
  max-height: 200px;
  overflow-y: auto;
}

/* Scrollbar */
#pdf-files-container::-webkit-scrollbar,
#combined-files::-webkit-scrollbar {
  width: 8px;
  height: 8px;
}

#pdf-files-container::-webkit-scrollbar-track,
#combined-files::-webkit-scrollbar-track {
  background: rgba(240, 240, 240, 0.5);
  border-radius: 4px;
}

#pdf-files-container::-webkit-scrollbar-thumb,
#combined-files::-webkit-scrollbar-thumb {
  background: rgba(44, 123, 229, 0.5);
  border-radius: 4px;
}

#pdf-files-container::-webkit-scrollbar-thumb:hover,
#combined-files::-webkit-scrollbar-thumb:hover {
  background: rgba(44, 123, 229, 0.8);
}

#pdf-files-container,
#combined-files {
  scrollbar-width: thin;
  scrollbar-color: rgba(44, 123, 229, 0.5) rgba(240, 240, 240, 0.5);
}

#pdf-viewer {
  display: flex;
  justify-content: center;
  align-items: center;
  position: relative;
  background: white;
  width: 100%;
  height: 100%;
  overflow: hidden;
  padding: 20px;
  box-sizing: border-box;
}

#pdf-viewer.has-pdf {
  overflow: auto;
}

#pdf-canvas {
  display: block;
  margin: auto;
  max-width: 100%;
  max-height: 100%;
  box-shadow: 0 5px 15px rgba(0,0,0,0.1);
  border-radius: 3px;
  background-color: white;
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  display: none;
}

#selected-pages-panel {
  padding: 15px;
  display: flex;
  flex-direction: column;
  height: 100%;
  background-color: rgba(255, 255, 255, 0.9);
  backdrop-filter: blur(5px);
}

/* Hover effects */
#pdf-list:hover, #combined-files:hover, #selected-pages-panel:hover {
  box-shadow: var(--shadow-lg);
}

/* PDF Items */
.pdf-item {
  margin: 10px 0;
  padding: 12px;
  border-radius: var(--radius);
  background-color: var(--light);
  display: flex;
  align-items: center;
  box-shadow: var(--shadow-sm);
  cursor: pointer;
  border-left: 3px solid transparent;
}

.pdf-item:hover {
  background-color: #f0f8ff;
  border-left: 3px solid var(--primary-light);
}

.pdf-item.selected {
  background-color: #e3f2fd;
  border-left: 4px solid var(--primary);
}

.pdf-icon {
  background-image: url('data:image/svg+xml; utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 384 512"><path fill="%23e74c3c" d="M181.9 256.1c-5-16-4.9-46.9-2-46.9 8.4 0 7.6 36.9 2 46.9zm-1.7 47.2c-7.7 20.2-17.3 43.3-28.4 62.7 18.3-7 39-17.2 62.9-21.9-12.7-9.6-24.9-23.4-34.5-40.8zM86.1 428.1c0 .8 13.2-5.4 34.9-40.2-6.7 6.3-29.1 24.5-34.9 40.2zM248 160h136v328c0 13.3-10.7 24-24 24H24c-13.3 0-24-10.7-24-24V24C0 10.7 10.7 0 24 0h200v136c0 13.2 10.8 24 24 24zm-8 171.8c-20-12.2-33.3-29-42.7-53.8 4.5-18.5 11.6-46.6 6.2-64.2-4.7-29.4-42.4-26.5-47.8-6.8-5 18.3-.4 44.1 8.1 77-11.6 27.6-28.7 64.6-40.8 85.8-.1 0-.1.1-.2.1-27.1 13.9-73.6 44.5-54.5 68 5.6 6.9 16 10 21.5 10 17.9 0 35.7-18 61.1-61.8 25.8-8.5 54.1-19.1 79-23.2 21.7 11.8 47.1 19.5 64 19.5 29.2 0 31.2-32 19.7-43.4-13.9-13.6-54.3-9.7-73.6-7.2zM377 105L279 7c-4.5-4.5-10.6-7-17-7h-6v128h128v-6.1c0-6.3-2.5-12.4-7-16.9zm-74.1 255.3c4.1-2.7-2.5-11.9-42.8-9 37.1 15.8 42.8 9 42.8 9z"/></svg>');
  width: 28px;
  height: 28px;
  margin-right: 12px;
  opacity: 0.8;
}

.pdf-name {
  flex-grow: 1;
  font-weight: 500;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  color: var(--dark);
}

/* Buttons */
button {
  padding: 10px 15px;
  border: none;
  border-radius: var(--radius);
  font-weight: 600;
  cursor: pointer;
  font-family: 'Roboto', sans-serif;
  display: flex;
  align-items: center;
  justify-content: center;
  box-shadow: var(--shadow-sm);
  letter-spacing: 0.3px;
}

button:hover {
  opacity: 0.9;
}

button:active {
  opacity: 0.95;
}

/* Button styles */
#combine-button, #combine-selected-pages {
  background: linear-gradient(45deg, #2ecc71, #4cd137);
  color: white;
  margin-top: 15px;
  font-size: 16px;
  padding: 12px 20px;
  position: relative;
  overflow: hidden;
  box-shadow: 0 4px 6px rgba(46, 204, 113, 0.2);
}

#combine-button {
  width: 100%;
  display: block;
  margin-top: 15px;
  font-size: 16px;
  padding: 12px 20px;
}

#buttonRow {
  display: flex;
  width: 100%;
  gap: 10px;
  margin-top: 10px;
}

#combine-button:hover, #combine-selected-pages:hover {
  background: linear-gradient(45deg, #27ae60, #44bd32);
}

#combine-selected-pages {
  display: none;
}

#rotate-button {
  background: linear-gradient(45deg, var(--accent), #56ccf2);
  color: white;
}

#extract-jpg-button {
  background: linear-gradient(45deg, var(--pink), #ff9eb5);
  color: white;
}

#download-rotated-button {
  background: linear-gradient(45deg, var(--primary), #56ccf2);
  color: white;
}

.move-buttons {
  display: flex;
  flex-direction: column;
  margin-right: 10px;
}

.move-button {
  padding: 3px 6px;
  margin: 2px 0;
  font-size: 12px;
  background-color: var(--gray-light);
  color: var(--dark);
  font-weight: bold;
}

.file-actions {
  display: none;
  gap: 5px;
}

.copy-btn, .delete-btn {
  padding: 6px 10px;
  font-size: 12px;
}

.copy-btn {
  background-color: var(--accent);
  color: white;
}

.delete-btn {
  background-color: var(--danger);
  color: white;
}

/* Input styles */
input[type="text"], input[type="number"] {
  padding: 8px 12px;
  border: 1px solid var(--gray-light);
  border-radius: var(--radius);
  font-family: 'Roboto', sans-serif;
  color: var(--dark);
  font-weight: 500;
}

input[type="text"]:focus, input[type="number"]:focus {
  outline: none;
  border-color: var(--primary-light);
  box-shadow: 0 0 0 3px rgba(116, 185, 255, 0.2);
}

/* Thumbnails */
#thumbnails-container {
  display: flex;
  flex-wrap: wrap;
  gap: 15px;
  padding: 20px;
  justify-content: center;
  align-items: flex-start;
  overflow: auto;
  width: 100%;
  height: 100%;
  background-color: #f0f8ff;
}

.thumbnail {
  min-width: 120px;
  min-height: 160px;
  border-radius: 8px;
  box-shadow: 0 2px 8px rgba(0,0,0,0.1);
  cursor: pointer;
  position: relative;
  margin: 5px;
  background-color: white;
  border: 1px solid rgba(116, 185, 255, 0.3);
}

.thumbnail:hover {
  z-index: 10;
  border-color: var(--primary-light);
}

.thumbnail.selected {
  box-shadow: 0 0 0 3px var(--primary), 0 5px 15px rgba(0,0,0,0.15);
}

.thumbnail.selected::after {
  content: '✓';
  position: absolute;
  top: 5px;
  right: 5px;
  background-color: var(--primary);
  color: white;
  width: 24px;
  height: 24px;
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 14px;
  font-weight: bold;
}

.thumbnail-container {
  position: relative;
  margin: 5px;
  line-height: 0;
}

.thumbnail-label {
  position: absolute;
  bottom: 5px;
  left: 0;
  right: 0;
  text-align: center;
  background-color: rgba(64, 149, 255, 0.8);
  color: white;
  padding: 3px;
  font-size: 12px;
  border-radius: 0 0 8px 8px;
}

/* Controls */
#page-controls {
  position: absolute;
  bottom: 15px;
  left: 50%;
  transform: translateX(-50%);
  background: rgba(44, 123, 229, 0.8);
  padding: 8px 15px;
  border-radius: 30px;
  display: flex;
  align-items: center;
  backdrop-filter: blur(5px);
  box-shadow: var(--shadow-md);
  border: 1px solid rgba(255, 255, 255, 0.3);
}

#page-controls button {
  background: transparent;
  color: white;
  box-shadow: none;
}

#page-controls button:hover {
  color: var(--light);
  text-shadow: 0 0 5px rgba(255, 255, 255, 0.5);
}

#page-controls span {
  color: white;
  margin: 0 10px;
  font-weight: 500;
}

#show-thumbnails-button {
  position: absolute;
  bottom: 20px;
  right: 20px;
  background: rgba(44, 123, 229, 0.8);
  color: white;
  width: 50px;
  height: 50px;
  border-radius: 50%;
  display: flex;
  justify-content: center;
  align-items: center;
  box-shadow: var(--shadow-md);
  backdrop-filter: blur(3px);
  border: 1px solid rgba(255, 255, 255, 0.3);
}

/* Modal */
.modal {
  display: none;
  position: fixed;
  z-index: 1000;
  left: 0;
  top: 0;
  width: 100%;
  height: 100%;
  background-color: rgba(0, 0, 0, 0.5);
  backdrop-filter: blur(5px);
}

.modal-content {
  background-color: white;
  margin: 15% auto;
  padding: 30px;
  border-radius: 12px;
  box-shadow: 0 10px 20px rgba(0,0,0,0.15);
  max-width: 500px;
  width: 90%;
  border: 1px solid rgba(116, 185, 255, 0.3);
}

.modal h3 {
  margin-top: 0;
  margin-bottom: 20px;
  color: var(--primary-dark);
  text-align: center;
  font-weight: bold;
  font-size: 24px;
}

#filename-input {
  width: 100%;
  padding: 12px 15px;
  margin: 10px 0 25px 0;
  font-size: 16px;
  border: 2px solid var(--gray-light);
  border-radius: 8px;
  box-sizing: border-box;
  font-family: 'Roboto', sans-serif;
  color: var(--dark);
  box-shadow: 0 2px 4px rgba(0,0,0,0.05);
}

#filename-input:focus {
  border-color: var(--primary);
  box-shadow: 0 0 0 3px rgba(44, 123, 229, 0.2);
  outline: none;
}

.modal-buttons {
  display: flex;
  justify-content: center;
  gap: 20px;
  margin-top: 20px;
}

#confirm-combine, #cancel-combine {
  padding: 12px 25px;
  min-width: 120px;
  font-size: 16px;
  font-weight: 600;
  border-radius: 8px;
  cursor: pointer;
}

#confirm-combine {
  background: linear-gradient(45deg, #2ecc71, #4cd137);
  color: white;
  box-shadow: 0 4px 6px rgba(46, 204, 113, 0.2);
}

#cancel-combine {
  background: #f5f5f5;
  color: #555;
  border: 1px solid #ddd;
}

/* Empty state */
.empty-list-message {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  color: #454d5d;
  font-size: 18px;
  font-weight: 500;
  text-align: center;
  white-space: nowrap;
  border: 2px dashed var(--gray-light);
  padding: 15px 25px;
  border-radius: 10px;
  background-color: rgba(255, 255, 255, 0.7);
}

/* ToolTips */
[data-tooltip] {
  position: relative;
}

[data-tooltip]::after {
  content: attr(data-tooltip);
  position: absolute;
  bottom: 125%;
  left: 50%;
  transform: translateX(-50%);
  background-color: rgba(30, 36, 48, 0.9);
  color: white;
  padding: 5px 10px;
  border-radius: 4px;
  font-size: 12px;
  white-space: nowrap;
  opacity: 0;
  visibility: hidden;
  box-shadow: var(--shadow-sm);
  font-weight: 500;
}

[data-tooltip]:hover::after {
  opacity: 1;
  visibility: visible;
}

/* Selected pages list */
#selected-pages-list {
  list-style: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  flex-grow: 1;
}

#selected-pages-list li {
  padding: 8px 12px;
  margin-bottom: 5px;
  background: var(--light);
  border-radius: var(--radius);
  border-left: 3px solid var(--primary);
  font-size: 14px;
  font-weight: 500;
  color: var(--dark);
}

/* Responsive adjustments */
@media (max-width: 1200px) {
  .container {
    grid-template-columns: 40% 60%;
  }
  
  #selected-pages-panel {
    grid-column: 1 / 3;
    height: auto;
  }
}

@media (max-width: 768px) {
  .container {
    grid-template-columns: 1fr;
    grid-template-rows: auto;
  }
  
  #pdf-viewer, .left-panel, #selected-pages-panel {
    grid-column: 1;
  }
}

/* Drop zone empty */
.drop-zone-empty {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  height: 100%;
  min-height: 200px;
  border: 3px dashed var(--secondary);
  border-radius: var(--radius);
  background-color: rgba(255, 255, 255, 0.7);
  padding: 20px;
  text-align: center;
  cursor: pointer;
}

.drop-zone-empty:hover {
  background-color: rgba(230, 247, 255, 0.9);
  border-color: var(--primary);
}

.drop-zone-icon {
  margin-bottom: 15px;
  position: relative;
  color: var(--primary);
}

.drop-zone-icon .fa-file-pdf {
  color: #e74c3c;
  filter: drop-shadow(0 0 3px rgba(231, 76, 60, 0.3));
}

.drop-zone-text h3 {
  color: var(--primary-dark);
  margin-bottom: 5px;
  font-size: 18px;
}

.drop-zone-text p {
  color: var(--gray);
  font-size: 14px;
}

/* Extract JPG Modal */
#extract-jpg-modal .modal-content {
  background: linear-gradient(to bottom right, #ffffff, #f8f9fa);
  padding: 30px;
  border-radius: 16px;
  box-shadow: 0 15px 30px rgba(0,0,0,0.15), 0 5px 15px rgba(0,0,0,0.05);
  max-width: 450px;
  width: 90%;
  border: none;
}

#extract-jpg-modal h2 {
  color: #2c3e50;
  font-size: 24px;
  margin-bottom: 25px;
  text-align: center;
  font-weight: 700;
  letter-spacing: -0.5px;
}

#extract-jpg-modal label {
  display: block;
  font-size: 14px;
  font-weight: 600;
  color: #4a5568;
  margin-bottom: 6px;
  margin-top: 16px;
}

#extract-jpg-modal input[type="text"],
#extract-jpg-modal input[type="number"] {
  width: 90%;
  padding: 12px 15px;
  border-radius: 10px;
  border: 2px solid #e2e8f0;
  background-color: #f8fafc;
  font-size: 15px;
  color: #2d3748;
  box-shadow: inset 0 1px 2px rgba(0,0,0,0.05);
}

#extract-jpg-modal input[type="text"]:focus,
#extract-jpg-modal input[type="number"]:focus {
  border-color: #3b82f6;
  box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.2);
  outline: none;
}

#extract-jpg-modal .modal-buttons {
  display: flex;
  justify-content: center;
  gap: 12px;
  margin-top: 30px;
}

#extract-jpg-modal button {
  padding: 12px 22px;
  border-radius: 12px;
  font-size: 15px;
  font-weight: 600;
  cursor: pointer;
  border: none;
  box-shadow: 0 4px 6px rgba(0,0,0,0.08);
}

#confirm-extract {
  background: linear-gradient(45deg, #4776E6, #8E54E9);
  color: white;
}

#cancel-extract {
  background-color: #FF2C2C;
  color: white;
}

#zip-extract {
  background: linear-gradient(45deg, #ff8c00, #ffa500);
  color: white;
}

@media (max-width: 500px) {
  #extract-jpg-modal .modal-content {
    padding: 20px;
  }
  
  #extract-jpg-modal .modal-buttons {
    flex-direction: column;
  }
  
  #extract-jpg-modal button {
    width: 100%;
    margin-bottom: 8px;
  }
}

/* Drag and drop styles */
.pdf-item.dragging {
  opacity: 0.5;
}

#pdf-list.drag-over {
  background-color: rgba(44, 123, 229, 0.1);
  border: 2px dashed var(--primary);
}

.combined-file-actions {
    display: flex;
    gap: 5px;
    margin-left: auto;
}

.download-btn, .combined-download-btn {
    background: transparent;
    color: var(--primary);
    padding: 6px;
    border-radius: 50%;
    min-width: 28px;
    height: 28px;
    display: flex;
    align-items: center;
    justify-content: center;
    border: none;
    cursor: pointer;
}

.combined-download-btn {
    border: 1px solid var(--primary);
}

.download-btn:hover, .combined-download-btn:hover {
    background-color: var(--primary);
    color: white;
}

.download-btn i, .combined-download-btn i {
    font-size: 14px;
}

#combined-files .pdf-item {
    display: flex;
    align-items: center;
    padding: 8px 12px;
    margin: 5px 0;
    border-radius: var(--radius);
    background-color: var(--light);
    width: 100%;
    box-sizing: border-box;
}

#combined-files .pdf-item:hover {
    background-color: #f0f8ff;
}

#combined-files .pdf-name {
    flex: 1;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    cursor: pointer;
}

#combined-files .file-container {
    display: flex;
    align-items: center;
    width: 100%;
    gap: 10px;
}

/* Reorder Modal Styles */
.reorder-modal-content {
    background-color: white;
    margin: auto;
    padding: 20px;
    border-radius: 10px;
    box-shadow: 0 5px 15px rgba(0,0,0,0.3);
    width: 80vw;
    max-width: 1000px; 
    height: 80vh;
    display: flex;
    flex-direction: column;
}

#reorder-modal h3 {
    margin-top: 0;
    margin-bottom: 15px;
    text-align: center;
    color: var(--primary-dark);
}

#reorder-list-container {
    flex-grow: 1; 
    overflow-y: auto;
    border: 1px solid var(--gray-light);
    border-radius: var(--radius);
    padding: 10px;
    background-color: #f9f9f9;
}

.reorder-item {
    padding: 8px 12px;
    margin-bottom: 4px;
    background-color: white;
    border: 1px solid #ddd;
    border-radius: 4px;
    cursor: grab;
    display: flex;
    align-items: center;
    font-size: 14px;
    user-select: none;
}

.reorder-item:last-child {
    margin-bottom: 0;
}

.reorder-item .pdf-icon {
    width: 20px;
    height: 20px;
    margin-right: 8px;
    background-image: url('data:image/svg+xml; utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 384 512"><path fill="%23e74c3c" d="M181.9 256.1c-5-16-4.9-46.9-2-46.9 8.4 0 7.6 36.9 2 46.9zm-1.7 47.2c-7.7 20.2-17.3 43.3-28.4 62.7 18.3-7 39-17.2 62.9-21.9-12.7-9.6-24.9-23.4-34.5-40.8zM86.1 428.1c0 .8 13.2-5.4 34.9-40.2-6.7 6.3-29.1 24.5-34.9 40.2zM248 160h136v328c0 13.3-10.7 24-24 24H24c-13.3 0-24-10.7-24-24V24C0 10.7 10.7 0 24 0h200v136c0 13.2 10.8 24 24 24zm-8 171.8c-20-12.2-33.3-29-42.7-53.8 4.5-18.5 11.6-46.6 6.2-64.2-4.7-29.4-42.4-26.5-47.8-6.8-5 18.3-.4 44.1 8.1 77-11.6 27.6-28.7 64.6-40.8 85.8-.1 0-.1.1-.2.1-27.1 13.9-73.6 44.5-54.5 68 5.6 6.9 16 10 21.5 10 17.9 0 35.7-18 61.1-61.8 25.8-8.5 54.1-19.1 79-23.2 21.7 11.8 47.1 19.5 64 19.5 29.2 0 31.2-32 19.7-43.4-13.9-13.6-54.3-9.7-73.6-7.2zM377 105L279 7c-4.5-4.5-10.6-7-17-7h-6v128h128v-6.1c0-6.3-2.5-12.4-7-16.9zm-74.1 255.3c4.1-2.7-2.5-11.9-42.8-9 37.1 15.8 42.8 9 42.8 9z"/></svg>');
    background-size: contain;
    background-repeat: no-repeat;
    background-position: center;
}

.reorder-item .pdf-name {
    flex-grow: 1;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}

.reorder-item.dragging {
    opacity: 0.4;
    background-color: #d0e7ff;
}

.reorder-drag-over-placeholder {
    height: 2px;
    background-color: var(--primary);
    margin: 2px 0;
    border-radius: 1px;
}

.reorder-modal-buttons {
    display: flex;
    justify-content: flex-end;
    gap: 10px;
    margin-top: 20px;
    padding-top: 15px;
    border-top: 1px solid var(--gray-light);
}

#apply-reorder, #cancel-reorder {
    padding: 10px 20px;
    border-radius: var(--radius);
    font-weight: 600;
    cursor: pointer;
    border: none;
    box-shadow: var(--shadow-sm);
}

#apply-reorder {
    background-color: var(--primary);
    color: white;
}

#cancel-reorder {
    background-color: #e0e0e0;
    color: var(--dark);
}

.rotate-thumbnail-btn {
    position: absolute;
    top: 5px;
    right: 5px;
    z-index: 15;
    background-color: rgba(0, 0, 0, 0.5);
    color: white;
    border: none;
    border-radius: 50%;
    width: 28px;
    height: 28px;
    padding: 0;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 14px;
    opacity: 0;
}

.thumbnail-container:hover .rotate-thumbnail-btn {
    opacity: 1;
}

.rotate-thumbnail-btn:hover {
    background-color: rgba(0, 0, 0, 0.8);
}

/* Compress PDF Modal */
#compress-modal .modal-content {
    max-width: 500px;
    margin: 10% auto;
}

#compress-modal h3 {
    margin-top: 0;
    margin-bottom: 20px;
    color: var(--primary-dark);
    text-align: center;
    font-weight: bold;
    font-size: 22px;
}

.compress-tabs {
    display: flex;
    border-bottom: 2px solid var(--gray-light);
    margin-bottom: 20px;
}

.compress-tab {
    flex: 1;
    padding: 10px 15px;
    text-align: center;
    cursor: pointer;
    font-weight: 600;
    color: var(--gray);
    border-bottom: 3px solid transparent;
    background: none;
    box-shadow: none;
    border-radius: 0;
}

.compress-tab:hover {
    color: var(--primary);
}

.compress-tab.active {
    color: var(--primary);
    border-bottom-color: var(--primary);
}

.compress-tab-content {
    display: none;
}

.compress-tab-content.active {
    display: block;
}

.compress-slider-container {
    padding: 10px 0 20px;
}

.compress-slider-labels {
    display: flex;
    justify-content: space-between;
    font-size: 12px;
    color: var(--gray);
    margin-bottom: 8px;
}

.compress-slider-value {
    text-align: center;
    font-size: 28px;
    font-weight: 700;
    color: var(--primary);
    margin-bottom: 10px;
}

.compress-slider-desc {
    text-align: center;
    font-size: 14px;
    color: var(--gray);
    margin-top: 10px;
    min-height: 40px;
}

#compress-level {
    -webkit-appearance: none;
    appearance: none;
    width: 100%;
    height: 8px;
    border-radius: 4px;
    background: linear-gradient(to right, #e74c3c, #f39c12, #2ecc71);
    outline: none;
    cursor: pointer;
}

#compress-level::-webkit-slider-thumb {
    -webkit-appearance: none;
    appearance: none;
    width: 24px;
    height: 24px;
    border-radius: 50%;
    background: white;
    border: 3px solid var(--primary);
    box-shadow: var(--shadow-md);
    cursor: pointer;
}

#compress-level::-moz-range-thumb {
    width: 24px;
    height: 24px;
    border-radius: 50%;
    background: white;
    border: 3px solid var(--primary);
    box-shadow: var(--shadow-md);
    cursor: pointer;
}

.compress-custom-row {
    display: flex;
    align-items: center;
    margin-bottom: 15px;
    gap: 10px;
}

.compress-custom-row label {
    flex: 0 0 140px;
    font-size: 14px;
    font-weight: 600;
    color: #4a5568;
}

.compress-custom-row input[type="number"] {
    flex: 1;
    padding: 10px 12px;
    border: 2px solid #e2e8f0;
    border-radius: 8px;
    font-size: 14px;
    background-color: #f8fafc;
}

.compress-custom-row input[type="number"]:focus {
    border-color: var(--primary);
    box-shadow: 0 0 0 3px rgba(44, 123, 229, 0.15);
}

.compress-custom-row .unit {
    flex: 0 0 30px;
    font-size: 13px;
    color: var(--gray);
    font-weight: 500;
}

.compress-warning {
    background: #fff3cd;
    border: 1px solid #ffc107;
    border-radius: 8px;
    padding: 10px 14px;
    font-size: 13px;
    color: #856404;
    margin-top: 15px;
    text-align: center;
}

.compress-progress {
    display: none;
    text-align: center;
    padding: 20px 0;
}

.compress-progress-bar {
    width: 100%;
    height: 6px;
    background: var(--gray-light);
    border-radius: 3px;
    overflow: hidden;
    margin-bottom: 10px;
}

.compress-progress-fill {
    height: 100%;
    background: linear-gradient(45deg, var(--primary), var(--primary-light));
    border-radius: 3px;
    width: 0%;
}

#compress-button {
    background: linear-gradient(45deg, #8E54E9, #4776E6);
    color: white;
    flex: 1;
    margin: 0;
}

#compress-button:hover {
    background: linear-gradient(45deg, #7c3aed, #3b5fe0);
}

</style>

</head>
<body>
    <div id="loader" style="display: none;">
    <div class="loader-spinner"></div>
    <div class="loader-text">Загрузка PDF...</div>
</div>

<input type="file" id="file-input" style="display: none;" multiple accept=".pdf">



   <div class="container">
        <div class="left-panel">
           <div id="pdf-list" ondrop="dropHandler(event);" ondragover="dragOverHandler(event);">
    <div id="empty-state" class="drop-zone-empty">
        <div class="drop-zone-icon">
            <i class="fas fa-file-pdf fa-3x"></i>
            <i class="fas fa-arrow-down fa-2x bounce"></i>
        </div>
        <div class="drop-zone-text">
            <h3></h3>
            <p></p>
        </div>
    </div>
</div>



<div id="combined-files"></div>
        </div>
        <div id="pdf-viewer">
            <div id="thumbnails-container"></div>
            <canvas id="pdf-canvas"></canvas>
            <div id="page-controls" style="display: none;">
                <button id="prev-page">←</button>
                <span id="page-num"></span> / <span id="page-count"></span>
                <button id="next-page">→</button>
                <button id="thumbnails-toggle"><i class="fas fa-th"></i></button>
            </div>
            <button id="show-thumbnails-button" style="display: none;">
                <i class="fas fa-th"></i>
            </button>
        </div>
        <div id="selected-pages-panel">
            <ul id="selected-pages-list"></ul>
            <button id="combine-selected-pages">Объединить выбранные страницы</button>
        </div>
    </div>

<div id="combine-modal" class="modal">
    <div class="modal-content">
        <h3>Имя файла</h3>
        <input type="text" id="filename-input" placeholder="">
        <div class="modal-buttons">
            <button id="confirm-combine">Сохранить</button>
            <button id="cancel-combine">Отмена</button>
        </div>
    </div>
</div>
    

<div id="extract-jpg-modal" class="modal">
    <div class="modal-content">
        <h2>Извлечь JPG</h2>
        <label for="page-range">Номера страниц:</label>
        <input type="text" id="page-range" placeholder="например, 1-2 5 7" value="Все">
        <label for="dpi">Разрешение (DPI):</label>
        <input type="number" id="dpi" min="10" max="1200" step="10" value="300">
        <label for="quality">Качество JPG (%):</label>
        <input type="number" id="quality" min="10" max="100" step="10" value="80">
        <div class="modal-buttons">
            <button id="confirm-extract">OK</button>
            <button id="cancel-extract">Отмена</button>
            <button id="zip-extract">Zip</button>
        </div>
    </div>
</div>

<div id="pages-per-sheet-modal" class="modal">
    <div class="modal-content">
        <h3>Настройки размещения страниц</h3>
        <div class="layout-options">
            <div class="radio-group">
                <label>
                    <input type="radio" name="pagesPerSheet" value="2" checked>
                    2 страницы на лист
                </label>
                <label>
                    <input type="radio" name="pagesPerSheet" value="4">
                    4 страницы на лист
                </label>
            </div>
            <div class="checkbox-group">
                <label>
                    <input type="checkbox" id="showBorders">
                    Показывать рамки
                </label>
            </div>
        </div>
        <div class="modal-buttons">
            <button id="confirm-layout">Применить</button>
            <button id="cancel-layout">Отмена</button>
        </div>
    </div>
</div>

<div id="reorder-modal" class="modal" style="display: none;">
    <div class="reorder-modal-content">
        <h3>Упорядочить файлы</h3>
        <div id="reorder-list-container">
            <!-- Files will be listed here -->
        </div>
        <div class="reorder-modal-buttons">
            <button id="apply-reorder">Применить</button>
            <button id="cancel-reorder">Отмена</button>
        </div>
    </div>
</div>


<div id="compress-modal" class="modal">
    <div class="modal-content">
        <h3>Сжатие PDF</h3>
        
        <div class="compress-tabs">
            <button class="compress-tab active" data-tab="simple" onclick="switchCompressTab('simple')">Простое</button>
            <button class="compress-tab" data-tab="custom" onclick="switchCompressTab('custom')">Кастомное</button>
        </div>

        <div id="compress-simple" class="compress-tab-content active">
            <div class="compress-slider-container">
                <div class="compress-slider-value" id="compress-level-display">5</div>
                <input type="range" id="compress-level" min="1" max="10" value="5">
                <div class="compress-slider-labels">
                    <span>1 — макс. сжатие</span>
                    <span>10 — макс. качество</span>
                </div>
                <div class="compress-slider-desc" id="compress-level-desc">Среднее качество • ~150 DPI</div>
            </div>
        </div>

        <div id="compress-custom" class="compress-tab-content">
            <div class="compress-custom-row">
                <label for="compress-dpi">DPI:</label>
                <input type="number" id="compress-dpi" min="36" max="600" step="1" value="150">
                <span class="unit"></span>
            </div>
            <div class="compress-custom-row">
                <label for="compress-jpeg-quality">Качество JPEG:</label>
                <input type="number" id="compress-jpeg-quality" min="5" max="100" step="5" value="60">
                <span class="unit">%</span>
            </div>
            <div class="compress-custom-row">
                <label for="compress-resize">Масштаб:</label>
                <input type="number" id="compress-resize" min="10" max="200" step="5" value="100">
                <span class="unit">%</span>
            </div>
        </div>

        <div class="compress-warning">
            ⚠ Текст станет нередактируемым (растеризация)
        </div>

        <div class="compress-progress" id="compress-progress">
            <div class="compress-progress-bar">
                <div class="compress-progress-fill" id="compress-progress-fill"></div>
            </div>
            <div class="compress-progress-text" id="compress-progress-text">Обработка...</div>
        </div>

        <div class="modal-buttons">
            <button id="confirm-compress" onclick="executeCompress()">Сжать</button>
            <button id="cancel-compress" onclick="closeCompressModal()">Отмена</button>
        </div>
    </div>
</div>

      <script>
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'webfonts/pdf.worker.min2023.js';

        let pdfFiles = [];
        let combinedFiles = [];
        let currentPdfDoc = null;
        let pageNum = 1;
        let selectedFileIndex = -1;
        let isThumbnailView = false;
        let selectedPages = [];
        let totalPages = 0;
        let currentRotation = 0;
        let rotatedPdfBytes = null;
        let pageRotations = {}; 
            let currentRenderTask = null; 

        let tempPdfFilesOrder = [];
        let reorderModalDraggedElement = null;
        let reorderModalPlaceholder = null;
        
        let originalFileSize = 0;
let compressRatios = {};

        const canvas = document.getElementById('pdf-canvas');
        const ctx = canvas.getContext('2d');
        const thumbnailsContainer = document.getElementById('thumbnails-container');
        const selectedPagesPanel = document.getElementById('selected-pages-panel');
        const selectedPagesList = document.getElementById('selected-pages-list');
        const showThumbnailsButton = document.getElementById('show-thumbnails-button');

        function dragOverHandler(ev) {
            ev.preventDefault();
            
        }

        async function dropHandler(ev) {
            ev.preventDefault();
            showLoader('Загрузка PDF файлов...');
            if (ev.dataTransfer.items) {
                const items = Array.from(ev.dataTransfer.items);
                const promises = items.map(async (item) => {
                    if (item.kind === 'file') {
                        const file = item.getAsFile();
                        if (file.type === 'application/pdf') {
                            await addPDFToList(file);
                        } else if (file.type === 'application/zip' || file.name.endsWith('.zip')) {
                            await handleZipFile(file);
                        }
                    }
                });

                await Promise.all(promises);
                pdfFiles.sort((a, b) => a.file.name.localeCompare(b.file.name));
                updatePDFList();
                updateThumbnailsView();
                hideLoader();
                highlightSortedFiles();
            }
        }


        async function handleZipFile(file) {
            try {
                const zip = new JSZip();
                const zipContents = await zip.loadAsync(file);

                for (let filename in zipContents.files) {
                    if (filename.toLowerCase().endsWith('.pdf')) {
                        const pdfFile = await zipContents.file(filename).async('blob');
                        await addPDFToList(new File([pdfFile], filename, {
                            type: 'application/pdf'
                        }));
                    }
                }
                pdfFiles.sort((a, b) => a.file.name.localeCompare(b.file.name));
            } catch (error) {
                console.error('Error processing ZIP file:', error);
                alert('Ошибка при обработке ZIP-файла. Пожалуйста, убедитесь, что файл не поврежден.');
            }
        }


function showLoader(text = 'Загрузка PDF...') {
    const loader = document.getElementById('loader');
    const loaderText = document.querySelector('.loader-text');
    if (loaderText) loaderText.textContent = text;
    if (loader) loader.style.display = 'flex';
}

function hideLoader() {
    const loader = document.getElementById('loader');
    if (loader) loader.style.display = 'none';
}

        async function addPDFToList(file) {
            try {
                const arrayBuffer = await file.arrayBuffer();
                const pdf = await pdfjsLib.getDocument(arrayBuffer).promise;
                pdfFiles.push({
                    file: file,
                    range: '',
                    pageCount: pdf.numPages
                });
                totalPages += pdf.numPages;

                pdfFiles.sort((a, b) => a.file.name.localeCompare(b.file.name));
            } catch (error) {
                console.error('Error adding PDF to list:', error);
            }
        }

        function updatePDFList() {
            let list = document.getElementById('pdf-list');

            list.innerHTML = '';

            const emptyState = document.getElementById('empty-state');
            if (emptyState) {
                emptyState.style.display = pdfFiles.length === 0 ? 'flex' : 'none';
            }

            let filesContainer = document.createElement('div');
            filesContainer.id = 'pdf-files-container';

            if (pdfFiles.length === 0) {
                const dropZone = document.createElement('div');
                dropZone.className = 'drop-zone-empty';
                dropZone.innerHTML = `
                <div class="drop-zone-icon">
                    <i class="fas fa-file-pdf fa-3x"></i>
                    <i class="fas fa-arrow-down fa-2x bounce"></i>
                </div>
                <div class="drop-zone-text">
                    <h3></h3>
                    <p></p>
                </div>
            `;
                filesContainer.appendChild(dropZone);
            } else {
                for (let i = 0; i < pdfFiles.length; i++) {
                    let div = document.createElement('div');
                    div.className = 'pdf-item';
                    div.setAttribute('data-id', i);
                    div.innerHTML = `
                    <div class="move-buttons">
                        <button class="move-button" onclick="moveFile(${i}, 'up')">▲</button>
                        <button class="move-button" onclick="moveFile(${i}, 'down')">▼</button>
                    </div>
                    <div class="pdf-icon"></div>
                    <span class="pdf-name">${pdfFiles[i].file.name}</span>
                    <small style="margin-left: 5px; color: #888;">(${pdfFiles[i].pageCount} стр.)</small>
                    <input type="text" placeholder="1-2 5 7" 
                        onchange="updateRange(${i}, this.value)" 
                        value="${pdfFiles[i].range}">
                    <div class="file-actions">
                        <button class="copy-btn" onclick="copyFile(${i})">Копировать</button>
                        <button class="delete-btn" onclick="deleteFile(${i})">Удалить</button>
                    </div>
                `;

                    div.ondblclick = function(event) {
                        loadPDF(pdfFiles[i].file, i);
                    };

                    div.onclick = function(event) {
                        if (event.target !== this && event.target.tagName !== 'SPAN') return;
                        selectFile(i, 'pdf-list');
                    };

                    filesContainer.appendChild(div);
                }
            }
            
            let buttonsContainer = document.createElement('div');
            buttonsContainer.id = 'pdf-buttons-container';
            
            let combineButton = document.createElement('button');
            combineButton.id = 'combine-button';
            combineButton.textContent = 'Объединить';
            combineButton.onclick = showCombineModal;
            buttonsContainer.appendChild(combineButton);

            let buttonRow = document.createElement('div');
            buttonRow.style.display = 'flex';
            buttonRow.style.width = '100%';
            buttonRow.style.gap = '10px';
            buttonRow.style.marginTop = '10px';

            let rotateButton = document.createElement('button');
            rotateButton.id = 'rotate-button';
            rotateButton.textContent = 'Повернуть';
            rotateButton.onclick = rotatePDF;
            rotateButton.style.flex = '1';
            rotateButton.style.margin = '0';

            let extractJpgButton = document.createElement('button');
            extractJpgButton.id = 'extract-jpg-button';
            extractJpgButton.textContent = 'Извлечь JPG';
            extractJpgButton.onclick = showExtractJpgModal;
            extractJpgButton.style.flex = '1';
            extractJpgButton.style.margin = '0';
            
            buttonRow.appendChild(rotateButton);
            buttonRow.appendChild(extractJpgButton);
            
            let compressButton = document.createElement('button');
compressButton.id = 'compress-button';
compressButton.textContent = 'Сжать PDF';
compressButton.onclick = showCompressModal;
compressButton.style.flex = '1';
compressButton.style.margin = '0';
buttonRow.appendChild(compressButton);
            
            buttonsContainer.appendChild(buttonRow);

            list.appendChild(filesContainer);
            list.appendChild(buttonsContainer);

            updateCombinedFilesList();
        }

       async function rotatePDF() {
            if (selectedFileIndex === -1) {
                if (pdfFiles.length > 0) {
                    selectedFileIndex = 0;
                    selectFile(0, 'pdf-list');
                } else if (combinedFiles.length > 0) {
                    selectedFileIndex = 0;
                    selectFile(0, 'combined-files');
                } else {
                    alert('Нет доступных PDF файлов для поворота');
                    return;
                }
            }

            currentRotation = (currentRotation + 90) % 360;

            let pdfFile;
            let originalFileName;
            if (selectedFileIndex < pdfFiles.length) {
                pdfFile = pdfFiles[selectedFileIndex].file;
                originalFileName = pdfFile.name;
            } else {
                pdfFile = combinedFiles[selectedFileIndex - pdfFiles.length];
                originalFileName = pdfFile.name;
            }

            const pdfBytes = await pdfFile.arrayBuffer();
            const pdfDoc = await PDFLib.PDFDocument.load(pdfBytes);

            const pages = pdfDoc.getPages();
            pages.forEach(page => {
                // --- НАЧАЛО ИСПРАВЛЕНИЯ ---
                const originalAngle = page.getRotation().angle;
                const newAngle = (originalAngle + currentRotation) % 360;
                page.setRotation(PDFLib.degrees(newAngle));
                // --- КОНЕЦ ИСПРАВЛЕНИЯ ---
            });

            rotatedPdfBytes = await pdfDoc.save();

            loadPDF(new Blob([rotatedPdfBytes], {
                type: 'application/pdf'
            }), selectedFileIndex);

            const rotatedFileName = `Rotated_${currentRotation}°_${originalFileName}`;
            const rotatedFile = new File([rotatedPdfBytes], rotatedFileName, {
                type: 'application/pdf'
            });

            if (selectedFileIndex < pdfFiles.length) {
                const originalFileNameWithoutExt = originalFileName.replace('.pdf', '');
                const lastIndex = combinedFiles.findIndex((file, index) => {
                    const fileName = file.name;
                    return fileName.includes(originalFileNameWithoutExt) &&
                        fileName.includes('Rotated_') &&
                        index === combinedFiles.length - 1;
                });

                if (lastIndex !== -1) {
                    combinedFiles.splice(lastIndex, 1);
                }
            }

            combinedFiles.push(rotatedFile);
            updateCombinedFilesList();

            console.log(`Документ повернут на ${currentRotation}° по часовой стрелке`);
        }
        
        function moveFile(index, direction) {
            if (direction === 'up' && index > 0) {
                [pdfFiles[index], pdfFiles[index - 1]] = [pdfFiles[index - 1], pdfFiles[index]];
            } else if (direction === 'down' && index < pdfFiles.length - 1) {
                [pdfFiles[index], pdfFiles[index + 1]] = [pdfFiles[index + 1], pdfFiles[index]];
            }
            updatePDFList();
            updateThumbnailsView();
        }
        
        function hideThumbnails() {
            thumbnailsContainer.style.display = 'none';
            canvas.style.display = 'block';
            showThumbnailsButton.style.display = 'block';
        }

        showThumbnailsButton.addEventListener('click', renderThumbnails);

        function updateCombinedFilesList() {
            const combinedList = document.getElementById('combined-files');
            combinedList.innerHTML = '';

            if (combinedFiles.length === 0) {
                const emptyMessage = document.createElement('div');
                emptyMessage.className = 'empty-list-message';
                emptyMessage.textContent = 'Нет объединенных файлов';
                combinedList.appendChild(emptyMessage);
                return;
            }

            for (let i = 0; i < combinedFiles.length; i++) {
                const fileItem = document.createElement('div');
                fileItem.className = 'pdf-item';
                fileItem.setAttribute('data-id', i);
                fileItem.setAttribute('draggable', 'true');

                fileItem.innerHTML = `
                    <div class="file-container">
                        <div class="pdf-icon"></div>
                        <span class="pdf-name">${combinedFiles[i].name}</span>
                        <div class="combined-file-actions">
                            <button class="combined-download-btn" title="Скачать файл" onclick="downloadCombinedFile(${i})">
                                <i class="fas fa-download"></i>
                            </button>
                        </div>
                    </div>
                `;

                fileItem.addEventListener('click', function(e) {
                    if (!e.target.closest('.combined-download-btn')) {
                        selectFile(i + pdfFiles.length, 'combined-files');
                    }
                });

                fileItem.addEventListener('dragstart', function(e) {
                    e.dataTransfer.setData('application/json', JSON.stringify({
                        source: 'combined-files',
                        index: i
                    }));
                    e.dataTransfer.effectAllowed = 'move';
                    this.classList.add('dragging');
                });

                fileItem.addEventListener('dragend', function() {
                    this.classList.remove('dragging');
                });

                combinedList.appendChild(fileItem);
            }
        }
        
        function downloadCombinedFile(index) {
            const file = combinedFiles[index];
            const link = document.createElement('a');
            link.href = URL.createObjectURL(file);
            link.download = file.name;
            document.body.appendChild(link);
            link.click();
            setTimeout(() => {
                document.body.removeChild(link);
                URL.revokeObjectURL(link.href);
            }, 100);
        }

        function updateThumbnailsView() {
            if (totalPages > 20) {
                showThumbnailsButton.style.display = 'block';
                thumbnailsContainer.style.display = 'none';
            } else {
                showThumbnailsButton.style.display = 'none';
                renderThumbnails();
            }
        }
        
        function selectFile(index, listId) {
            selectedFileIndex = index;
            currentRotation = 0;
            rotatedPdfBytes = null;


            if (listId === 'pdf-list') {
                document.querySelectorAll('#pdf-list .pdf-item').forEach((item, i) => {
                    if (i === index) {
                        item.classList.add('selected');
                        item.querySelector('.file-actions').style.display = 'flex';
                    } else {
                        item.classList.remove('selected');
                        item.querySelector('.file-actions').style.display = 'none';
                    }
                });

                document.querySelectorAll('#combined-files .pdf-item').forEach((item) => {
                    item.classList.remove('selected');
                });

                document.getElementById('rotate-button').style.display = 'block';
                loadPDF(pdfFiles[index].file, index);
            } else if (listId === 'combined-files') {
                document.querySelectorAll('#combined-files .pdf-item').forEach((item, i) => {
                    item.classList.toggle('selected', i === index);
                });

                document.querySelectorAll('#pdf-list .pdf-item').forEach((item) => {
                    item.classList.remove('selected');
                    item.querySelector('.file-actions').style.display = 'none';
                });

                document.getElementById('rotate-button').style.display = 'none';
                loadPDF(combinedFiles[index], index);
            }
        }

        function copyFile(index) {
            let newFile = { ...pdfFiles[index]
            };
            pdfFiles.push(newFile);
            updatePDFList();
        }

        function deleteFile(index) {
            pdfFiles.splice(index, 1);
            updatePDFList();
            if (selectedFileIndex === index) {
                selectedFileIndex = -1;
                currentPdfDoc = null;
                canvas.getContext('2d').clearRect(0, 0, canvas.width, canvas.height);
                document.getElementById('page-controls').style.display = 'none';
            }
        }

        function updateRange(index, value) {
            pdfFiles[index].range = value;
        }

function renderPage(num) {
            if (currentRenderTask) {
                currentRenderTask.cancel();
                currentRenderTask = null;
            }

            currentPdfDoc.getPage(num).then(function(page) {
                const pageKey = `${selectedFileIndex}-${num}`;
                const manualRotation = pageRotations[pageKey] || 0;
                const totalRotation = (page.rotate + manualRotation) % 360;

                const viewport = page.getViewport({ scale: 1.5, rotation: totalRotation });
                
                canvas.height = viewport.height;
                canvas.width = viewport.width;
                canvas.style.display = 'block';
                canvas.style.position = 'static';
                canvas.style.transform = 'none';

                const renderContext = {
                    canvasContext: ctx,
                    viewport: viewport
                };
                
                currentRenderTask = page.render(renderContext);
                currentRenderTask.promise
                    .then(() => {
                        currentRenderTask = null;
                    })
                    .catch(error => {
                        // Игнорируем ошибку отмены, но выводим в консоль другие
                        if (error.name !== 'RenderingCancelledException') {
                            console.error("Ошибка рендеринга:", error);
                        }
                        currentRenderTask = null;
                    });

                document.getElementById('page-num').textContent = num;
            });
        }

async function renderThumbnails() {
    updateSelectedPagesList();
    thumbnailsContainer.innerHTML = '';
    canvas.style.display = 'none';
    thumbnailsContainer.style.display = 'flex';
    showThumbnailsButton.style.display = 'none';
    selectedPagesPanel.style.display = 'block';

    const containerWidth = thumbnailsContainer.offsetWidth;
    const containerHeight = thumbnailsContainer.offsetHeight;
    const aspectRatio = containerWidth / containerHeight;

    // Избегаем деления на ноль, если контейнер или страницы отсутствуют
    if (totalPages === 0 || containerWidth === 0) return;

    const optimalColumns = Math.ceil(Math.sqrt(totalPages * aspectRatio));
    
    // --- ВОТ ИСПРАВЛЕНИЕ: ВОЗВРАЩАЕМ ЭТУ СТРОКУ ---
    const thumbnailWidth = containerWidth / optimalColumns;

    for (let fileIndex = 0; fileIndex < pdfFiles.length; fileIndex++) {
        const file = pdfFiles[fileIndex];
        const arrayBuffer = await file.file.arrayBuffer();
        const pdf = await pdfjsLib.getDocument(arrayBuffer).promise;

        for (let i = 1; i <= pdf.numPages; i++) {
            const page = await pdf.getPage(i);
            const pageKey = `${fileIndex}-${i}`;
            
            const manualRotation = pageRotations[pageKey] || 0;
            const totalRotation = (page.rotate + manualRotation) % 360; 
            
            const viewport = page.getViewport({ scale: 1, rotation: totalRotation });
            
            const scale = thumbnailWidth / viewport.width;
            const scaledViewport = page.getViewport({ scale: scale, rotation: totalRotation });

            const thumbnailContainerDiv = document.createElement('div');
            thumbnailContainerDiv.className = 'thumbnail-container';

            const canvas = document.createElement('canvas');
            canvas.width = scaledViewport.width;
            canvas.height = scaledViewport.height;
            canvas.className = 'thumbnail';
            canvas.setAttribute('data-file', fileIndex);
            canvas.setAttribute('data-page', i);
            
            if (selectedPages.some(p => p.fileIndex === fileIndex && p.pageNum === i)) {
                 canvas.classList.add('selected');
            }

            const renderContext = {
                canvasContext: canvas.getContext('2d'),
                viewport: scaledViewport
            };

            await page.render(renderContext).promise;

            const rotateBtn = document.createElement('button');
            rotateBtn.className = 'rotate-thumbnail-btn';
            rotateBtn.innerHTML = '<i class="fas fa-sync-alt"></i>';
            rotateBtn.title = 'Повернуть страницу';
            
            rotateBtn.onclick = function(event) {
                event.stopPropagation();
                rotateThumbnail(fileIndex, i, canvas);
            };

            thumbnailContainerDiv.appendChild(rotateBtn);
            thumbnailContainerDiv.appendChild(canvas);
            thumbnailsContainer.appendChild(thumbnailContainerDiv);

            thumbnailContainerDiv.addEventListener('click', function(e) {
                if (e.ctrlKey) {
                    canvas.classList.toggle('selected');
                    updateSelectedPagesList(fileIndex, i, false);
                } else if (e.shiftKey) {
                    canvas.classList.add('selected');
                    updateSelectedPagesList(fileIndex, i, true);
                } else {
                    isThumbnailView = false;
                    thumbnailsContainer.style.display = 'none';
                    document.getElementById('pdf-canvas').style.display = 'block';
                    loadPDF(file.file, fileIndex, i);
                }
            });
        }
    }
    isThumbnailView = true;
    if (currentPdfDoc) {  
        showViewerAndPanel(); 
    }
}

async function rotateThumbnail(fileIndex, pageNum, canvasElement) {
    const key = `${fileIndex}-${pageNum}`;
    // pageRotations по-прежнему хранит ТОЛЬКО ручной поворот
    const currentManualRotation = pageRotations[key] || 0;
    const newManualRotation = (currentManualRotation + 90) % 360;
    pageRotations[key] = newManualRotation;

    const file = pdfFiles[fileIndex];
    const arrayBuffer = await file.file.arrayBuffer();
    const pdf = await pdfjsLib.getDocument(arrayBuffer).promise;
    const page = await pdf.getPage(pageNum);

    // --- НАЧАЛО ИЗМЕНЕНИЙ ---
    const totalRotation = (page.rotate + newManualRotation) % 360; // Снова суммируем
    // --- КОНЕЦ ИЗМЕНЕНИЙ ---

    const containerWidth = thumbnailsContainer.offsetWidth;
    const containerHeight = thumbnailsContainer.offsetHeight;
    if (containerWidth === 0 || totalPages === 0) return; 

    const aspectRatio = containerWidth / containerHeight;
    const optimalColumns = Math.ceil(Math.sqrt(totalPages * aspectRatio));
    const gap = 15;
    const targetWidth = (containerWidth - ((optimalColumns - 1) * gap)) / optimalColumns;

    // Используем totalRotation для получения правильного viewport
    const viewport = page.getViewport({ scale: 1, rotation: totalRotation });
    const scale = targetWidth / viewport.width;
    const scaledViewport = page.getViewport({ scale: scale, rotation: totalRotation });

    canvasElement.width = scaledViewport.width;
    canvasElement.height = scaledViewport.height;

    const renderContext = {
        canvasContext: canvasElement.getContext('2d'),
        viewport: scaledViewport
    };

    await page.render(renderContext).promise;
}

        function loadPDF(file, index, pageNumber = 1) {
            if (!(file instanceof Blob)) {
                console.error('Invalid file type');
                return;
            }

            const fileReader = new FileReader();

            fileReader.onload = function() {
                showLoader('Рендеринг PDF...');
                const typedarray = new Uint8Array(this.result);

                pdfjsLib.getDocument(typedarray).promise.then(function(pdf) {
                    currentPdfDoc = pdf;
                    pageNum = pageNumber;
                    document.getElementById('page-count').textContent = pdf.numPages;
                    document.getElementById('page-controls').style.display = pdf.numPages > 1 ? 'flex' : 'none';
                    thumbnailsContainer.style.display = 'none';
                    isThumbnailView = false;

                    if (totalPages > 20) {
                        showThumbnailsButton.style.display = 'block';
                    } else {
                        showThumbnailsButton.style.display = 'none';
                    }

                    document.getElementById('pdf-viewer').classList.add('has-pdf');

                    showViewerAndPanel();
                    
                    requestAnimationFrame(() => {
                        updateSelectedPagesPanel();
                    });

                    renderPage(pageNum);
                    hideLoader();
                });
            };

            fileReader.readAsArrayBuffer(file);
        }

        async function combineAllPDFs() {
            if (pdfFiles.length === 0) {
                alert('Добавьте хотя бы один PDF файл');
                return;
            }

            const mergedPdf = await PDFLib.PDFDocument.create();

            for (let pdfFile of pdfFiles) {
                const pdfBytes = await pdfFile.file.arrayBuffer();
                const pdf = await PDFLib.PDFDocument.load(pdfBytes);
                const totalPages = pdf.getPageCount();

                for (let i = 0; i < totalPages; i++) {
                    const [copiedPage] = await mergedPdf.copyPages(pdf, [i]);
                    mergedPdf.addPage(copiedPage);
                }
            }

            const pdfBytes = await mergedPdf.save();
            const blob = new Blob([pdfBytes], {
                type: 'application/pdf'
            });

            const now = new Date();
            const fileName = `Combined_PDF_${now.getFullYear()}${String(now.getMonth() + 1).padStart(2, '0')}${String(now.getDate()).padStart(2, '0')}-${String(now.getHours()).padStart(2, '0')}${String(now.getMinutes()).padStart(2, '0')}${String(now.getSeconds()).padStart(2, '0')}.pdf`;

            const combinedFile = new File([blob], fileName, {
                type: 'application/pdf'
            });

            combinedFiles.push(combinedFile);
            updateCombinedFilesList();

            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            link.download = combinedFile.name;
            link.click();
        }

        document.addEventListener('keydown', function(event) {
            if (event.key === 'F8') {
                event.preventDefault();
                combineAllPDFs();
            }
        });

        function updateSelectedPagesList(fileIndex, pageNum, isShiftKey) {
            if (fileIndex !== undefined && pageNum !== undefined) {
                const pageInfo = {
                    fileIndex,
                    pageNum
                };
                if (isShiftKey) {
                    selectedPages.push(pageInfo);
                } else {
                    const existingIndex = selectedPages.findIndex(p => p.fileIndex === fileIndex && p.pageNum === pageNum);
                    if (existingIndex === -1) {
                        selectedPages.push(pageInfo);
                    } else {
                        selectedPages.splice(existingIndex, 1);
                    }
                }
            }
            
            const combineButton = document.getElementById('combine-selected-pages');
            combineButton.style.display = selectedPages.length > 0 ? 'block' : 'none';

            selectedPagesList.innerHTML = '';
            if (selectedPages.length === 0) {
                const li = document.createElement('li');
                li.innerHTML = 'Страницы не выбраны<br><br>' +
                    'Ctrl+левая мышка - для выбора/отмены<br><br>' +
                    'Shift+левая мышка - для выбора (в том числе повторного)<br><br>' +
                    'F1 - извлечь каждую страницу в отдельный PDF<br><br>' +
                    'F2 - объединение чередующихся страниц<br><br>' +
                    'F3 - склеить слева направо<br><br>' +
                    'F4 - объединение файлов парами (1+2, 3+4, ...)<br><br>' +
                    'F6 - несколько страниц на листе<br><br>' +
                    'F8 - объединение всех страниц<br><br>' +
                    'F10 - соединить верхние половинки<br><br>' +
                    'F11 - упорядочить файлы<br><br>' +
                    'F9 - для сброса';
                selectedPagesList.appendChild(li);
            } else {
                selectedPages.forEach((page, index) => {
                    const li = document.createElement('li');
                    li.textContent = `Файл ${page.fileIndex + 1}, страница ${page.pageNum}`;
                    selectedPagesList.appendChild(li);
                });
            }
        }

        document.getElementById('prev-page').addEventListener('click', () => {
            if (pageNum <= 1) return;
            pageNum--;
            renderPage(pageNum);
        });

        document.getElementById('next-page').addEventListener('click', () => {
            if (pageNum >= currentPdfDoc.numPages) return;
            pageNum++;
            renderPage(pageNum);
        });

        document.getElementById('thumbnails-toggle').addEventListener('click', async () => {
            if (pdfFiles.length > 0) {
                isThumbnailView = !isThumbnailView;
                if (isThumbnailView) {
                    await renderThumbnails();
                } else {
                    thumbnailsContainer.style.display = 'none';
                    selectedPagesPanel.style.display = 'none';
                    canvas.style.display = 'block';
                    renderPage(pageNum);
                }
            }
        });

        document.getElementById('combine-selected-pages').addEventListener('click', combineSelectedPages);

        function showCombineModal() {
            const modal = document.getElementById('combine-modal');
            const input = document.getElementById('filename-input');
            const confirmButton = document.getElementById('confirm-combine');
            const cancelButton = document.getElementById('cancel-combine');

            const now = new Date();
            const defaultFileName = `PDF-${now.getFullYear()}${String(now.getMonth() + 1).padStart(2, '0')}${String(now.getDate()).padStart(2, '0')}-${String(now.getHours()).padStart(2, '0')}${String(now.getMinutes()).padStart(2, '0')}${String(now.getSeconds()).padStart(2, '0')}`;
            input.value = defaultFileName;

            modal.style.display = 'block';
            input.focus();
            
            confirmButton.onclick = function() {
                if (input.value.trim() === '') {
                    alert('Пожалуйста, введите имя файла');
                    return;
                }
                combinePDFs(input.value);
                modal.style.display = 'none';
            }
            
            cancelButton.onclick = function() {
                modal.style.display = 'none';
            }
            
            window.onclick = function(event) {
                if (event.target == modal) {
                    return false;
                }
            }
            
            input.addEventListener('keypress', function(event) {
                if (event.key === 'Enter') {
                    confirmButton.click();
                }
            });
            
            document.addEventListener('keydown', function(event) {
                if (event.key === 'Escape') {
                    cancelButton.click();
                }
            });
        }
        
        function getReorderModalPlaceholder() {
            if (!reorderModalPlaceholder) {
                reorderModalPlaceholder = document.createElement('div');
                reorderModalPlaceholder.className = 'reorder-drag-over-placeholder';
            }
            return reorderModalPlaceholder;
        }

        function showReorderModal() {
            const modal = document.getElementById('reorder-modal');
            if (!modal) {
                console.error("Reorder modal not found!");
                return;
            }

            if (pdfFiles.length === 0) {
                alert("Нет файлов для переупорядочивания.");
                return;
            }
            
            tempPdfFilesOrder = [...pdfFiles];

            populateReorderModalList();
            modal.style.display = 'flex';
        }

        function populateReorderModalList() {
            const listContainer = document.getElementById('reorder-list-container');
            if (!listContainer) return;
            listContainer.innerHTML = '';

            tempPdfFilesOrder.forEach((pdfEntry, index) => {
                const item = document.createElement('div');
                item.className = 'reorder-item';
                item.setAttribute('draggable', 'true');
                item.setAttribute('data-index', index.toString());

                const icon = document.createElement('div');
                icon.className = 'pdf-icon';

                const nameSpan = document.createElement('span');
                nameSpan.className = 'pdf-name';
                nameSpan.textContent = pdfEntry.file.name;

                item.appendChild(icon);
                item.appendChild(nameSpan);

                item.addEventListener('dragstart', handleReorderDragStart);
                item.addEventListener('dragend', handleReorderDragEnd);

                listContainer.appendChild(item);
            });
        }
        
        function handleReorderDragStart(e) {
            reorderModalDraggedElement = this;
            this.classList.add('dragging');
            e.dataTransfer.effectAllowed = 'move';
            e.dataTransfer.setData('text/plain', this.getAttribute('data-index'));
        }

        function handleReorderDragEnd() {
            if (reorderModalDraggedElement) {
                reorderModalDraggedElement.classList.remove('dragging');
            }
            reorderModalDraggedElement = null;

            const placeholder = getReorderModalPlaceholder();
            if (placeholder.parentNode) {
                placeholder.remove();
            }
        }

        function handleReorderDragOverContainer(e) {
            e.preventDefault();
            e.dataTransfer.dropEffect = 'move';

            if (!reorderModalDraggedElement) return;

            const listContainer = document.getElementById('reorder-list-container');
            const placeholder = getReorderModalPlaceholder();

            const targetItem = e.target.closest('.reorder-item');

            if (targetItem && targetItem !== reorderModalDraggedElement) {
                const rect = targetItem.getBoundingClientRect();
                const isAfter = e.clientY > rect.top + rect.height / 2;

                if (isAfter) {
                    listContainer.insertBefore(placeholder, targetItem.nextSibling);
                } else {
                    listContainer.insertBefore(placeholder, targetItem);
                }
            } else if (!targetItem && listContainer.children.length > 0) {
                const children = Array.from(listContainer.children);
                const lastNonPlaceholderChild = children.filter(c => c !== placeholder && c !== reorderModalDraggedElement).pop();

                if (lastNonPlaceholderChild) {
                    const lastRect = lastNonPlaceholderChild.getBoundingClientRect();
                    if (e.clientY > lastRect.bottom) {
                        listContainer.appendChild(placeholder);
                    }
                } else if (children.length === 0 || (children.length === 1 && children[0] === reorderModalDraggedElement)) {
                    listContainer.appendChild(placeholder);
                }
            } else if (listContainer.children.length === 0 || (listContainer.children.length === 1 && listContainer.firstChild === reorderModalDraggedElement)) {
                listContainer.appendChild(placeholder);
            }
        }

        function handleReorderDragLeaveContainer(e) {
            const listContainer = document.getElementById('reorder-list-container');
            if (!listContainer.contains(e.relatedTarget) && e.relatedTarget !== null) {
                const placeholder = getReorderModalPlaceholder();
                if (placeholder.parentNode) {
                    placeholder.remove();
                }
            }
        }

        function handleReorderDropContainer(e) {
            e.preventDefault();
            const placeholder = getReorderModalPlaceholder();

            if (!reorderModalDraggedElement || !placeholder.parentNode) {
                if (placeholder.parentNode) placeholder.remove();
                if (reorderModalDraggedElement) reorderModalDraggedElement.classList.remove('dragging');
                reorderModalDraggedElement = null;
                return;
            }

            const listContainer = document.getElementById('reorder-list-container');
            const originalDraggedItemIndex = parseInt(reorderModalDraggedElement.getAttribute('data-index'), 10);

            const domChildren = Array.from(listContainer.children);
            let newVisualIndex = domChildren.indexOf(placeholder);

            if (newVisualIndex === -1) {
                placeholder.remove();
                return;
            }
            
            const itemToMove = tempPdfFilesOrder.splice(originalDraggedItemIndex, 1)[0];
            
            tempPdfFilesOrder.splice(newVisualIndex, 0, itemToMove);

            placeholder.remove();
            
            populateReorderModalList();
        }

        function parsePageRange(range, totalPages) {
            if (!range || range.toLowerCase() === 'все') {
                return Array.from({
                    length: totalPages
                }, (_, i) => i + 1);
            }

            const pages = [];
            const parts = range.split(/[\s,]+/);

            for (let part of parts) {
                if (part.includes('-')) {
                    const [start, end] = part.split('-').map(num => parseInt(num, 10));
                    for (let i = start; i <= Math.min(end, totalPages); i++) {
                        pages.push(i);
                    }
                } else {
                    const pageNum = parseInt(part, 10);
                    if (pageNum > 0 && pageNum <= totalPages) {
                        pages.push(pageNum);
                    }
                }
            }

            return pages;
        }

        function showViewerAndPanel() {
            document.getElementById('pdf-viewer').style.display = 'block';
            document.getElementById('selected-pages-panel').style.display = 'block';
        }

        async function combinePDFs(fileName) {
            if (pdfFiles.length === 0) {
                alert('Добавьте хотя бы один PDF файл');
                return;
            }

            const mergedPdf = await PDFLib.PDFDocument.create();

            for (let pdfFile of pdfFiles) {
                const pdfBytes = await pdfFile.file.arrayBuffer();
                const pdf = await PDFLib.PDFDocument.load(pdfBytes);
                const totalPages = pdf.getPageCount();
                const pageIndices = parsePageRange(pdfFile.range, totalPages);

                for (let pageNum of pageIndices) {
                    try {
                        const [copiedPage] = await mergedPdf.copyPages(pdf, [pageNum - 1]);
                        mergedPdf.addPage(copiedPage);
                    } catch (error) {
                        console.error(`Ошибка при копировании страницы ${pageNum} из файла ${pdfFile.file.name}:`, error);
                    }
                }
            }

            const pdfBytes = await mergedPdf.save();
            const blob = new Blob([pdfBytes], {
                type: 'application/pdf'
            });
            const combinedFile = new File([blob], `${fileName}.pdf`, {
                type: 'application/pdf'
            });

            combinedFiles.push(combinedFile);
            updateCombinedFilesList();

            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            link.download = combinedFile.name;
            link.click();
        }

function resetSelectedPages() {
    selectedPages = [];
   
    document.querySelectorAll('.thumbnail.selected').forEach(thumbnail => {
        thumbnail.classList.remove('selected');
    });
    updateSelectedPagesList(); 
    // Меняем текст сообщения, чтобы он соответствовал действительности
    //alert('Выбор страниц сброшен. Повороты сохранены.'); 
}

async function combineSelectedPages() {
    if (selectedPages.length === 0) {
        alert('Выберите хотя бы одну страницу');
        return;
    }

    const mergedPdf = await PDFLib.PDFDocument.create();

    for (let pageInfo of selectedPages) {
        const pdfFile = pdfFiles[pageInfo.fileIndex];
        const pdfBytes = await pdfFile.file.arrayBuffer();
        const pdf = await PDFLib.PDFDocument.load(pdfBytes);
        const [copiedPage] = await mergedPdf.copyPages(pdf, [pageInfo.pageNum - 1]);
        
        // --- НАЧАЛО ИСПРАВЛЕНИЙ ---

        // 1. Получаем ИСХОДНЫЙ угол поворота скопированной страницы
        const originalRotation = copiedPage.getRotation().angle;

        // 2. Получаем РУЧНОЙ поворот, добавленный пользователем
        const pageKey = `${pageInfo.fileIndex}-${pageInfo.pageNum}`;
        const manualRotation = pageRotations[pageKey] || 0;

        // 3. СУММИРУЕМ оба поворота для получения итогового угла
        const totalRotation = (originalRotation + manualRotation) % 360;

        // 4. Устанавливаем итоговый поворот на страницу
        copiedPage.setRotation(PDFLib.degrees(totalRotation));

        // --- КОНЕЦ ИСПРАВЛЕНИЙ ---
        
        mergedPdf.addPage(copiedPage);
    }

    const pdfBytes = await mergedPdf.save();
    const blob = new Blob([pdfBytes], { type: 'application/pdf' });
    const combinedFile = new File([blob], 'Выбранные_страницы.pdf', { type: 'application/pdf' });

    const link = document.createElement('a');
    link.href = URL.createObjectURL(blob);
    link.download = combinedFile.name;
    link.click();
    
    // Этот вызов, как мы и исправили ранее, сбрасывает только выделение
    resetSelectedPages(); 
}

        document.addEventListener('keydown', function(event) {
            if (event.key === 'F9') {
                resetSelectedPages();
            }

            if (event.key === 'F11') {
                event.preventDefault();
                showReorderModal();
            }
        });

        function showExtractJpgModal() {
            if (selectedFileIndex === -1) {
                if (pdfFiles.length > 0) {
                    selectedFileIndex = 0;
                    selectFile(0, 'pdf-list');
                } else if (combinedFiles.length > 0) {
                    selectedFileIndex = 0;
                    selectFile(0, 'combined-files');
                } else {
                    alert('Нет доступных PDF файлов для извлечения JPG');
                    return;
                }
            }

            const modal = document.getElementById('extract-jpg-modal');
            const confirmButton = document.getElementById('confirm-extract');
            const cancelButton = document.getElementById('cancel-extract');
            const zipButton = document.getElementById('zip-extract');

            modal.style.display = 'block';

            confirmButton.onclick = function() {
                extractJpg(false);
                modal.style.display = 'none';
            }

            cancelButton.onclick = function() {
                modal.style.display = 'none';
            }

            zipButton.onclick = function() {
                extractJpg(true);
                modal.style.display = 'none';
            }

            window.onclick = function(event) {
                if (event.target == modal) {
                    modal.style.display = 'none';
                }
            }
        }

        async function extractJpg(createZip = false) {
            if (selectedFileIndex === -1) {
                if (pdfFiles.length > 0) {
                    selectedFileIndex = 0;
                    selectFile(0, 'pdf-list');
                } else if (combinedFiles.length > 0) {
                    selectedFileIndex = 0;
                    selectFile(0, 'combined-files');
                } else {
                    alert('Нет доступных PDF файлов для извлечения JPG');
                    return;
                }
            }

            const pageRange = document.getElementById('page-range').value;
            const dpi = parseInt(document.getElementById('dpi').value, 10);
            const quality = parseInt(document.getElementById('quality').value, 10) / 100;

            let pdfFile;
            if (selectedFileIndex < pdfFiles.length) {
                pdfFile = pdfFiles[selectedFileIndex].file;
            } else {
                pdfFile = combinedFiles[selectedFileIndex - pdfFiles.length];
            }

            const pdfBytes = await pdfFile.arrayBuffer();
            const pdfDoc = await pdfjsLib.getDocument({
                data: pdfBytes
            }).promise;

            const totalPages = pdfDoc.numPages;
            const pagesToExtract = parsePageRange(pageRange, totalPages);

            let zip;
            if (createZip) {
                zip = new JSZip();
            }

            for (let pageNum of pagesToExtract) {
                try {
                    const page = await pdfDoc.getPage(pageNum);
                    const viewport = page.getViewport({
                        scale: dpi / 72
                    });

                    const canvas = document.createElement('canvas');
                    const context = canvas.getContext('2d');
                    canvas.height = viewport.height;
                    canvas.width = viewport.width;

                    await page.render({
                        canvasContext: context,
                        viewport: viewport
                    }).promise;

                    const jpgData = canvas.toDataURL('image/jpeg', quality).split(',')[1];

                    if (createZip) {
                        const fileName = `Страница${pageNum.toString().padStart(3, '0')}.jpg`;
                        zip.file(fileName, jpgData, {
                            base64: true
                        });
                    } else {
                        const link = document.createElement('a');
                        link.href = `data:image/jpeg;base64,${jpgData}`;
                        link.download = `page_${pageNum}.jpg`;
                        link.click();
                    }
                } catch (error) {
                    console.error(`Ошибка при извлечении страницы ${pageNum}:`, error);
                }
            }

            if (createZip) {
                zip.generateAsync({
                        type: "blob"
                    })
                    .then(function(content) {
                        const link = document.createElement('a');
                        link.href = URL.createObjectURL(content);
                        link.download = "extracted_pages.zip";
                        link.click();
                    });
            }
        }

        function updateSelectedPagesPanel() {
            updateSelectedPagesList();
        }

        async function combineAlternatingPages() {
            if (pdfFiles.length !== 2) {
                alert('Необходимо ровно два PDF файла');
                return;
            }

            const file1Bytes = await pdfFiles[0].file.arrayBuffer();
            const file2Bytes = await pdfFiles[1].file.arrayBuffer();

            const pdf1 = await PDFLib.PDFDocument.load(file1Bytes);
            const pdf2 = await PDFLib.PDFDocument.load(file2Bytes);

            const pages1 = pdf1.getPageCount();
            const pages2 = pdf2.getPageCount();

            if (!(pages1 === 1 || pages2 === 1)) {
                alert('Для соединения чередующихся страниц один из файлов должен содержать только одну страницу');
                return;
            }
            
            let singlePagePdf, multiPagePdf, singlePageCount, multiPageCount;
            if (pages1 === 1) {
                singlePagePdf = pdf1;
                multiPagePdf = pdf2;
                singlePageCount = pages1;
                multiPageCount = pages2;
            } else {
                singlePagePdf = pdf2;
                multiPagePdf = pdf1;
                singlePageCount = pages2;
                multiPageCount = pages1;
            }
            
            const mergedPdf = await PDFLib.PDFDocument.create();

            for (let i = 0; i < multiPageCount; i++) {
                const [singlePage] = await mergedPdf.copyPages(singlePagePdf, [0]);
                mergedPdf.addPage(singlePage);

                const [multiPage] = await mergedPdf.copyPages(multiPagePdf, [i]);
                mergedPdf.addPage(multiPage);
            }
            
            const pdfBytes = await mergedPdf.save();
            const blob = new Blob([pdfBytes], {
                type: 'application/pdf'
            });

            const now = new Date();
            const fileName = `Alternating_PDF_${now.getFullYear()}${String(now.getMonth() + 1).padStart(2, '0')}${String(now.getDate()).padStart(2, '0')}-${String(now.getHours()).padStart(2, '0')}${String(now.getMinutes()).padStart(2, '0')}${String(now.getSeconds()).padStart(2, '0')}.pdf`;

            const combinedFile = new File([blob], fileName, {
                type: 'application/pdf'
            });
            combinedFiles.push(combinedFile);
            updateCombinedFilesList();

            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            link.download = combinedFile.name;
            link.click();
        }
        
   async function combineSideBySide() {
            if (pdfFiles.length === 0) {
                alert('Добавьте хотя бы один PDF файл для склейки.');
                return;
            }

            try {
                const mergedPdf = await PDFLib.PDFDocument.create();
                let allPagesData = [];
                let totalWidth = 0;
                let maxHeight = 0;

                // Сначала соберем информацию о всех страницах
                for (const pdfFile of pdfFiles) {
                    const pdfBytes = await pdfFile.file.arrayBuffer();
                    const pdfDoc = await PDFLib.PDFDocument.load(pdfBytes);
                    
                    if (pdfDoc.getPageCount() > 0) {
                        const page = pdfDoc.getPage(0);
                        const { width, height } = page.getSize();
                        
                        allPagesData.push({ pdfDoc, pageIndex: 0, width, height });
                        totalWidth += width;
                        if (height > maxHeight) {
                            maxHeight = height;
                        }
                    }
                }
                
                if (allPagesData.length === 0) {
                    alert('Не найдено страниц для объединения.');
                    return;
                }

                // Создаем новую страницу с суммарной шириной и максимальной высотой
                const newPage = mergedPdf.addPage([totalWidth, maxHeight]);
                let currentX = 0;

                // Вставляем каждую страницу на новый большой лист
                for (const pageData of allPagesData) {
                    // --- НАЧАЛО ИСПРАВЛЕНИЯ ---
                    // 1. Получаем исходную страницу
                    const sourcePage = pageData.pdfDoc.getPage(pageData.pageIndex);
                    // 2. Встраиваем ее в наш итоговый документ, чтобы получить PDFEmbeddedPage
                    const embeddedPage = await mergedPdf.embedPage(sourcePage);
                    // --- КОНЕЦ ИСПРАВЛЕНИЯ ---

                    // 3. Теперь рисуем правильный объект embeddedPage
                    newPage.drawPage(embeddedPage, {
                        x: currentX,
                        y: 0, 
                        width: pageData.width,
                        height: pageData.height,
                    });
                    
                    currentX += pageData.width;
                }

                const pdfFinalBytes = await mergedPdf.save();
                const blob = new Blob([pdfFinalBytes], { type: 'application/pdf' });
                const now = new Date();
                const fileName = `SideBySide_PDF_${now.getFullYear()}${String(now.getMonth() + 1).padStart(2, '0')}${String(now.getDate()).padStart(2, '0')}.pdf`;

                const combinedFile = new File([blob], fileName, { type: 'application/pdf' });
                combinedFiles.push(combinedFile);
                updateCombinedFilesList();

                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = combinedFile.name;
                link.click();

            } catch (error) {
                console.error('Ошибка при склейке файлов слева направо:', error);
                alert('Произошла ошибка при склейке файлов: ' + error.message);
            }
        }

        // Добавляем новый обработчик для F3
        document.addEventListener('keydown', function(event) {
            if (event.key === 'F3') {
                event.preventDefault();
                combineSideBySide();
            }
        });
        

        async function combinePairedPages() {
            if (pdfFiles.length < 2) {
                alert('Необходимо хотя бы два PDF файла');
                return;
            }
            
            pdfFiles.sort((a, b) => a.file.name.localeCompare(b.file.name));
            
            updatePDFList();

            await new Promise(resolve => setTimeout(resolve, 500));
            
            for (let i = 0; i < pdfFiles.length; i += 2) {
                if (i + 1 < pdfFiles.length) {
                    await combineTwoFiles(pdfFiles[i].file, pdfFiles[i + 1].file, i);
                } else {
                    const lastFile = new File([pdfFiles[i].file],
                        `Single_${pdfFiles[i].file.name}`, {
                            type: 'application/pdf'
                        });
                    combinedFiles.push(lastFile);
                }
            }

            updateCombinedFilesList();
        }

        async function combineTwoFiles(file1, file2, index) {
            try {
                const file1Bytes = await file1.arrayBuffer();
                const file2Bytes = await file2.arrayBuffer();

                const pdf1 = await PDFLib.PDFDocument.load(file1Bytes);
                const pdf2 = await PDFLib.PDFDocument.load(file2Bytes);
                
                const mergedPdf = await PDFLib.PDFDocument.create();
                
                for (let i = 0; i < pdf1.getPageCount(); i++) {
                    const [page] = await mergedPdf.copyPages(pdf1, [i]);
                    mergedPdf.addPage(page);
                }
                
                for (let i = 0; i < pdf2.getPageCount(); i++) {
                    const [page] = await mergedPdf.copyPages(pdf2, [i]);
                    mergedPdf.addPage(page);
                }
                
                const pdfBytes = await mergedPdf.save();
                const blob = new Blob([pdfBytes], {
                    type: 'application/pdf'
                });

                const now = new Date();
                const fileName = `Paired_PDF_${now.getFullYear()}${String(now.getMonth() + 1).padStart(2, '0')}${String(now.getDate()).padStart(2, '0')}-${String(now.getHours()).padStart(2, '0')}${String(now.getMinutes()).padStart(2, '0')}${String(now.getSeconds()).padStart(2, '0')}_pair${Math.floor(index/2)+1}.pdf`;

                const combinedFile = new File([blob], fileName, {
                    type: 'application/pdf'
                });
                combinedFiles.push(combinedFile);

                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = fileName;
                link.click();

            } catch (error) {
                console.error('Ошибка при объединении файлов:', error);
                alert(`Ошибка при объединении файлов ${file1.name} и ${file2.name}`);
            }
        }
        
        function highlightSortedFiles() {
            const items = document.querySelectorAll('#pdf-list .pdf-item');
            items.forEach((item) => {
                item.style.transition = 'background-color 0.3s';
                item.style.backgroundColor = '#e6ffe6';
                setTimeout(() => {
                    item.style.backgroundColor = '';
                }, 1000);
            });
        }

        document.addEventListener('keydown', async function(event) {
            if (event.key === 'F4') {
                event.preventDefault();
                await combinePairedPages();
                highlightSortedFiles();
            }
        });

        document.addEventListener('keydown', function(event) {
            if (event.key === 'F2') {
                event.preventDefault();
                combineAlternatingPages();
            }
        });

        function showPagesPerSheetModal() {
            const modal = document.getElementById('pages-per-sheet-modal');
            modal.style.display = 'block';

            return new Promise((resolve, reject) => {
                const confirmButton = document.getElementById('confirm-layout');
                const cancelButton = document.getElementById('cancel-layout');

                confirmButton.onclick = function() {
                    const pagesPerSheet = document.querySelector('input[name="pagesPerSheet"]:checked').value;
                    const showBorders = document.getElementById('showBorders').checked;
                    modal.style.display = 'none';
                    resolve({
                        pagesPerSheet: parseInt(pagesPerSheet),
                        showBorders
                    });
                };

                cancelButton.onclick = function() {
                    modal.style.display = 'none';
                    reject('Cancelled');
                };

                window.onclick = function(event) {
                    if (event.target == modal) {
                        modal.style.display = 'none';
                        reject('Cancelled');
                    }
                };
            });
        }

        async function combineToTwoPerPage() {
            if (pdfFiles.length === 0) {
                alert('Добавьте хотя бы один PDF файл');
                return;
            }

            try {
                const options = await showPagesPerSheetModal();
                const mergedPdf = await PDFLib.PDFDocument.create();

                const allPages = [];
                for (const pdfFile of pdfFiles) {
                    const pdfBytes = await pdfFile.file.arrayBuffer();
                    const pdfDoc = await PDFLib.PDFDocument.load(pdfBytes);
                    const totalPages = pdfDoc.getPageCount();

                    for (let i = 0; i < totalPages; i++) {
                        allPages.push({
                            pdfDoc,
                            pageIndex: i
                        });
                    }
                }

                const firstPageRef = await allPages[0].pdfDoc.getPage(allPages[0].pageIndex);
                const pageWidth = firstPageRef.getWidth();
                const pageHeight = firstPageRef.getHeight();

                if (options.pagesPerSheet === 2) {
                    for (let i = 0; i < allPages.length; i += 2) {
                        const newPage = mergedPdf.addPage([pageWidth * 2, pageHeight]);

                        const page1Pdf = await PDFLib.PDFDocument.create();
                        const [copiedPage1] = await page1Pdf.copyPages(allPages[i].pdfDoc, [allPages[i].pageIndex]);
                        page1Pdf.addPage(copiedPage1);
                        const page1Embeded = await mergedPdf.embedPdf(await page1Pdf.save());

                        newPage.drawPage(page1Embeded[0], {
                            x: 0,
                            y: 0,
                            width: pageWidth,
                            height: pageHeight
                        });

                        if (i + 1 < allPages.length) {
                            const page2Pdf = await PDFLib.PDFDocument.create();
                            const [copiedPage2] = await page2Pdf.copyPages(allPages[i + 1].pdfDoc, [allPages[i + 1].pageIndex]);
                            page2Pdf.addPage(copiedPage2);
                            const page2Embeded = await mergedPdf.embedPdf(await page2Pdf.save());

                            newPage.drawPage(page2Embeded[0], {
                                x: pageWidth,
                                y: 0,
                                width: pageWidth,
                                height: pageHeight
                            });
                        }
                        
                        if (options.showBorders) {
                            newPage.drawLine({
                                start: {
                                    x: pageWidth,
                                    y: 0
                                },
                                end: {
                                    x: pageWidth,
                                    y: pageHeight
                                },
                                thickness: 1,
                                color: PDFLib.rgb(0.7, 0.7, 0.7)
                            });
                        }
                    }
                } else {
                    for (let i = 0; i < allPages.length; i += 4) {
                        const newPage = mergedPdf.addPage([pageWidth * 2, pageHeight * 2]);
                        
                        const positions = [{
                            x: 0,
                            y: pageHeight
                        }, {
                            x: pageWidth,
                            y: pageHeight
                        }, {
                            x: 0,
                            y: 0
                        }, {
                            x: pageWidth,
                            y: 0
                        }];

                        for (let j = 0; j < 4; j++) {
                            if (i + j < allPages.length) {
                                const pagePdf = await PDFLib.PDFDocument.create();
                                const [copiedPage] = await pagePdf.copyPages(allPages[i + j].pdfDoc, [allPages[i + j].pageIndex]);
                                pagePdf.addPage(copiedPage);
                                const pageEmbeded = await mergedPdf.embedPdf(await pagePdf.save());

                                newPage.drawPage(pageEmbeded[0], {
                                    x: positions[j].x,
                                    y: positions[j].y,
                                    width: pageWidth,
                                    height: pageHeight
                                });
                            }
                        }
                        
                        if (options.showBorders) {
                            newPage.drawLine({
                                start: {
                                    x: pageWidth,
                                    y: 0
                                },
                                end: {
                                    x: pageWidth,
                                    y: pageHeight * 2
                                },
                                thickness: 1,
                                color: PDFLib.rgb(0.7, 0.7, 0.7)
                            });
                            newPage.drawLine({
                                start: {
                                    x: 0,
                                    y: pageHeight
                                },
                                end: {
                                    x: pageWidth * 2,
                                    y: pageHeight
                                },
                                thickness: 1,
                                color: PDFLib.rgb(0.7, 0.7, 0.7)
                            });
                        }
                    }
                }
                
                const pdfFinalBytes = await mergedPdf.save();
                const blob = new Blob([pdfFinalBytes], {
                    type: 'application/pdf'
                });
                const now = new Date();
                const fileName = `${options.pagesPerSheet}pages_per_sheet_${now.getFullYear()}${String(now.getMonth() + 1).padStart(2, '0')}${String(now.getDate()).padStart(2, '0')}-${String(now.getHours()).padStart(2, '0')}${String(now.getMinutes()).padStart(2, '0')}${String(now.getSeconds()).padStart(2, '0')}.pdf`;

                const combinedFile = new File([blob], fileName, {
                    type: 'application/pdf'
                });
                combinedFiles.push(combinedFile);
                updateCombinedFilesList();

                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = combinedFile.name;
                link.click();
            } catch (error) {
                if (error !== 'Cancelled') {
                    console.error('Error combining pages:', error);
                    alert('Произошла ошибка при объединении страниц');
                }
            }
        }

        document.addEventListener('keydown', async function(event) {
            if (event.key === 'F1') {
                event.preventDefault();
                await extractPagesToSeparatePDFs();
            }
        });

        async function extractPagesToSeparatePDFs() {
            if (pdfFiles.length === 0) {
                alert('Добавьте хотя бы один PDF файл.');
                return;
            }

            const zip = new JSZip();
            const pdfPages = [];

            for (const pdfFile of pdfFiles) {
                const pdfBytes = await pdfFile.file.arrayBuffer();
                const pdfDoc = await PDFLib.PDFDocument.load(pdfBytes);
                const pageCount = pdfDoc.getPageCount();

                for (let i = 0; i < pageCount; i++) {
                    const newPdf = await PDFLib.PDFDocument.create();
                    const [page] = await newPdf.copyPages(pdfDoc, [i]);
                    newPdf.addPage(page);

                    const pdfPageBytes = await newPdf.save();
                    const fileName = `${pdfFile.file.name.replace('.pdf', '')}_page${i + 1}.pdf`;

                    pdfPages.push({
                        fileName,
                        pdfBytes: pdfPageBytes
                    });
                }
            }

            if (pdfPages.length > 3) {
                for (const {
                        fileName,
                        pdfBytes
                    } of pdfPages) {
                    zip.file(fileName, pdfBytes);
                }

                const zipBlob = await zip.generateAsync({
                    type: 'blob'
                });
                const zipLink = document.createElement('a');
                zipLink.href = URL.createObjectURL(zipBlob);
                zipLink.download = 'Extracted_Pages.zip';
                zipLink.click();
            } else {
                for (const {
                        fileName,
                        pdfBytes
                    } of pdfPages) {
                    const pdfBlob = new Blob([pdfBytes], {
                        type: 'application/pdf'
                    });
                    const pdfLink = document.createElement('a');
                    pdfLink.href = URL.createObjectURL(pdfBlob);
                    pdfLink.download = fileName;
                    pdfLink.click();
                }
            }
        }
        
        document.addEventListener('keydown', function(event) {
            if (event.key === 'F6') {
                event.preventDefault();
                combineToTwoPerPage();
            }
        });

        document.addEventListener('DOMContentLoaded', function() {
            const container = document.querySelector('.container');
            const fileInput = document.getElementById('file-input');

            container.addEventListener('dblclick', function(event) {
                if (pdfFiles.length === 0 && combinedFiles.length === 0) {
                    fileInput.click();
                }
            });

            fileInput.addEventListener('change', async function(event) {
                const files = event.target.files;
                for (let file of files) {
                    if (file.type === 'application/pdf') {
                        await addPDFToList(file);
                    }
                }

                updatePDFList();
                pdfFiles.sort((a, b) => a.file.name.localeCompare(b.file.name));
                updatePDFList();
                updateThumbnailsView();
                highlightSortedFiles();
                event.target.value = '';
            });
            
            const pdfList = document.getElementById('pdf-list');
            const observer = new MutationObserver(function(mutations) {
                for (let mutation of mutations) {
                    if (mutation.type === 'childList') {
                        const filesContainer = document.getElementById('pdf-files-container');
                        if (filesContainer && filesContainer.children.length === 0) {
                            const emptyMessage = document.createElement('div');
                            emptyMessage.className = 'empty-list-message';
                            emptyMessage.innerHTML = 'Перетащите PDF файлы сюда...';
                            filesContainer.appendChild(emptyMessage);
                        }
                    }
                }
            });

            observer.observe(pdfList, {
                childList: true,
                subtree: true
            });

            const reorderModal = document.getElementById('reorder-modal');
            if (reorderModal) {
                const applyBtn = document.getElementById('apply-reorder');
                const cancelBtn = document.getElementById('cancel-reorder');
                const reorderListContainer = document.getElementById('reorder-list-container');

                if (applyBtn) {
                    applyBtn.addEventListener('click', () => {
                        pdfFiles = [...tempPdfFilesOrder];
                        updatePDFList();
                        reorderModal.style.display = 'none';
                    });
                }

                if (cancelBtn) {
                    cancelBtn.addEventListener('click', () => {
                        reorderModal.style.display = 'none';
                    });
                }

                if (reorderListContainer) {
                    reorderListContainer.addEventListener('dragover', handleReorderDragOverContainer);
                    reorderListContainer.addEventListener('dragleave', handleReorderDragLeaveContainer);
                    reorderListContainer.addEventListener('drop', handleReorderDropContainer);
                }

                document.addEventListener('keydown', function(event) {
                    if (event.key === 'Escape' && reorderModal.style.display !== 'none') {
                        cancelBtn.click();
                    }
                });
            }

            initializeDragAndDrop();
        });

        async function combineTopHalvesJpg300dpi() {
            if (pdfFiles.length !== 2) {
                alert('Необходимо ровно два PDF файла');
                return;
            }

            try {
                const file1Bytes = await pdfFiles[0].file.arrayBuffer();
                const file2Bytes = await pdfFiles[1].file.arrayBuffer();

                const pdf1 = await pdfjsLib.getDocument({
                    data: file1Bytes
                }).promise;
                const pdf2 = await pdfjsLib.getDocument({
                    data: file2Bytes
                }).promise;
                
                const page1 = await pdf1.getPage(1);
                const page2 = await pdf2.getPage(1);
                
                const dpi = 300;
                const scale = dpi / 72;
                
                const viewport1 = page1.getViewport({
                    scale
                });
                const viewport2 = page2.getViewport({
                    scale
                });
                
                const canvas1 = document.createElement('canvas');
                canvas1.width = viewport1.width;
                canvas1.height = viewport1.height;
                const ctx1 = canvas1.getContext('2d');

                const canvas2 = document.createElement('canvas');
                canvas2.width = viewport2.width;
                canvas2.height = viewport2.height;
                const ctx2 = canvas2.getContext('2d');
                
                await page1.render({
                    canvasContext: ctx1,
                    viewport: viewport1
                }).promise;
                await page2.render({
                    canvasContext: ctx2,
                    viewport: viewport2
                }).promise;
                
                const resultWidth = Math.max(viewport1.width, viewport2.width);
                const resultHeight = viewport1.height / 2 + viewport2.height / 2;

                const resultCanvas = document.createElement('canvas');
                resultCanvas.width = resultWidth;
                resultCanvas.height = resultHeight;
                const resultCtx = resultCanvas.getContext('2d');
                
                resultCtx.fillStyle = 'white';
                resultCtx.fillRect(0, 0, resultWidth, resultHeight);
                
                resultCtx.drawImage(
                    canvas1,
                    0, 0, viewport1.width, viewport1.height / 2,
                    0, 0, viewport1.width, viewport1.height / 2
                );
                
                resultCtx.drawImage(
                    canvas2,
                    0, 0, viewport2.width, viewport2.height / 2,
                    0, viewport1.height / 2, viewport2.width, viewport2.height / 2
                );
                
                const jpgData = resultCanvas.toDataURL('image/jpeg', 1.0);
                
                const now = new Date();
                const fileName = `Combined_300dpi_${now.getFullYear()}${String(now.getMonth() + 1).padStart(2, '0')}${String(now.getDate()).padStart(2, '0')}-${String(now.getHours()).padStart(2, '0')}${String(now.getMinutes()).padStart(2, '0')}.jpg`;

                const link = document.createElement('a');
                link.href = jpgData;
                link.download = fileName;
                link.click();
            } catch (error) {
                console.error('Ошибка при создании JPG:', error);
                alert('Произошла ошибка при создании JPG: ' + error.message);
            }
        }
        
        document.addEventListener('keydown', function(event) {
            if (event.key === 'F10') {
                event.preventDefault();
                combineTopHalvesJpg300dpi();
            }
        });
        
        function initializeDragAndDrop() {
            const pdfList = document.getElementById('pdf-list');

            pdfList.addEventListener('dragover', function(e) {
                e.preventDefault();
                e.dataTransfer.dropEffect = 'move';
                this.classList.add('drag-over');
            });

            pdfList.addEventListener('dragleave', function() {
                this.classList.remove('drag-over');
            });

            pdfList.addEventListener('drop', function(e) {
                e.preventDefault();
                this.classList.remove('drag-over');

                const jsonData = e.dataTransfer.getData('application/json');

                if (jsonData) {
                    try {
                        const data = JSON.parse(jsonData);

                        if (data.source === 'combined-files') {
                            const fileIndex = data.index;
                            const file = combinedFiles[fileIndex];
                            
                            addPDFFromCombined(file).then(() => {
                                updatePDFList();
                            });
                        }
                    } catch (error) {
                        console.error('Ошибка при парсинге JSON:', error);
                    }
                }
            });
        }
        
        async function addPDFFromCombined(file) {
            try {
                const arrayBuffer = await file.arrayBuffer();
                const pdf = await pdfjsLib.getDocument(arrayBuffer).promise;

                pdfFiles.push({
                    file: file,
                    range: '',
                    pageCount: pdf.numPages
                });

                totalPages += pdf.numPages;
            } catch (error) {
                console.error('Ошибка при добавлении PDF из объединенных файлов:', error);
                alert('Ошибка при добавлении файла в список');
            }
        }
        
        
        // ===================== COMPRESS PDF =====================

const COMPRESS_STORAGE_KEY = 'pdfCompressSettings';

const compressPresets = {
    1:  { dpi: 72,  quality: 15, resize: 50,  desc: 'Минимальное качество • 72 DPI • 50%' },
    2:  { dpi: 72,  quality: 25, resize: 60,  desc: 'Очень низкое • 72 DPI • 60%' },
    3:  { dpi: 96,  quality: 35, resize: 70,  desc: 'Низкое качество • 96 DPI • 70%' },
    4:  { dpi: 120, quality: 45, resize: 80,  desc: 'Ниже среднего • 120 DPI • 80%' },
    5:  { dpi: 150, quality: 55, resize: 100, desc: 'Среднее качество • 150 DPI' },
    6:  { dpi: 150, quality: 65, resize: 100, desc: 'Выше среднего • 150 DPI' },
    7:  { dpi: 200, quality: 75, resize: 100, desc: 'Хорошее качество • 200 DPI' },
    8:  { dpi: 250, quality: 82, resize: 100, desc: 'Высокое качество • 250 DPI' },
    9:  { dpi: 300, quality: 90, resize: 100, desc: 'Отличное качество • 300 DPI' },
    10: { dpi: 300, quality: 95, resize: 100, desc: 'Максимальное качество • 300 DPI' },
};

function loadCompressSettings() {
    try {
        const saved = localStorage.getItem(COMPRESS_STORAGE_KEY);
        if (saved) {
            const data = JSON.parse(saved);
            if (data.compressRatios) {
                compressRatios = data.compressRatios;
            }
            return data;
        }
    } catch (e) {}
    return {
        tab: 'simple',
        level: 5,
        dpi: 150,
        jpegQuality: 60,
        resize: 100,
        compressRatios: {}
    };
}


function saveCompressSettings() {
    const settings = {
        tab: document.querySelector('.compress-tab.active').dataset.tab,
        level: parseInt(document.getElementById('compress-level').value),
        dpi: parseInt(document.getElementById('compress-dpi').value),
        jpegQuality: parseInt(document.getElementById('compress-jpeg-quality').value),
        resize: parseInt(document.getElementById('compress-resize').value),
        compressRatios: compressRatios
    };
    try {
        localStorage.setItem(COMPRESS_STORAGE_KEY, JSON.stringify(settings));
    } catch (e) {}
}


function getEstimatedSize(level) {
    if (!originalFileSize || originalFileSize === 0) return '';
    
    if (compressRatios[level]) {
        // Используем реальный коэффициент
        const sizeMB = (originalFileSize * compressRatios[level] / (1024 * 1024)).toFixed(2);
        return ` • ~${sizeMB} МБ`;
    } else if (Object.keys(compressRatios).length > 0) {
        // Интерполяция на основе известных данных
        const knownLevels = Object.keys(compressRatios).map(Number).sort((a, b) => a - b);
        let ratio = 0;
        
        if (level < knownLevels[0]) {
            ratio = compressRatios[knownLevels[0]] * (level / knownLevels[0]);
        } else if (level > knownLevels[knownLevels.length - 1]) {
            ratio = compressRatios[knownLevels[knownLevels.length - 1]] * (level / knownLevels[knownLevels.length - 1]);
        } else {
            // Линейная интерполяция между двумя известными точками
            for (let i = 0; i < knownLevels.length - 1; i++) {
                if (level >= knownLevels[i] && level <= knownLevels[i + 1]) {
                    const t = (level - knownLevels[i]) / (knownLevels[i + 1] - knownLevels[i]);
                    ratio = compressRatios[knownLevels[i]] * (1 - t) + compressRatios[knownLevels[i + 1]] * t;
                    break;
                }
            }
        }
        
        const sizeMB = (originalFileSize * ratio / (1024 * 1024)).toFixed(2);
        return ` • ~${sizeMB} МБ`;
    }
    
    return '';
}

function applyCompressSettings(settings) {
    document.getElementById('compress-level').value = settings.level;
    document.getElementById('compress-level-display').textContent = settings.level;
    document.getElementById('compress-level-desc').textContent = compressPresets[settings.level].desc;
    document.getElementById('compress-dpi').value = settings.dpi;
    document.getElementById('compress-jpeg-quality').value = settings.jpegQuality;
    document.getElementById('compress-resize').value = settings.resize;
    switchCompressTab(settings.tab);
}

function switchCompressTab(tabName) {
    document.querySelectorAll('.compress-tab').forEach(t => {
        t.classList.toggle('active', t.dataset.tab === tabName);
    });
    document.getElementById('compress-simple').classList.toggle('active', tabName === 'simple');
    document.getElementById('compress-custom').classList.toggle('active', tabName === 'custom');
}

function showCompressModal() {
    if (selectedFileIndex === -1) {
        if (pdfFiles.length > 0) {
            selectedFileIndex = 0;
            selectFile(0, 'pdf-list');
        } else if (combinedFiles.length > 0) {
            selectedFileIndex = 0;
            selectFile(0, 'combined-files');
        } else {
            alert('Нет доступных PDF файлов для сжатия');
            return;
        }
    }

    // Получить размер текущего файла
    let pdfFile;
    if (selectedFileIndex < pdfFiles.length) {
        pdfFile = pdfFiles[selectedFileIndex].file;
    } else {
        pdfFile = combinedFiles[selectedFileIndex - pdfFiles.length];
    }
    originalFileSize = pdfFile.size;

    const settings = loadCompressSettings();
    if (settings.compressRatios) {
        compressRatios = settings.compressRatios;
    }
    applyCompressSettings(settings);

    document.getElementById('compress-progress').style.display = 'none';
    document.getElementById('confirm-compress').disabled = false;
    document.getElementById('compress-modal').style.display = 'block';
}



function closeCompressModal() {
    document.getElementById('compress-modal').style.display = 'none';
}

function getCompressParams() {
    const activeTab = document.querySelector('.compress-tab.active').dataset.tab;

    if (activeTab === 'simple') {
        const level = parseInt(document.getElementById('compress-level').value);
        const preset = compressPresets[level];
        return {
            dpi: preset.dpi,
            quality: preset.quality / 100,
            resize: preset.resize / 100
        };
    } else {
        return {
            dpi: parseInt(document.getElementById('compress-dpi').value),
            quality: parseInt(document.getElementById('compress-jpeg-quality').value) / 100,
            resize: parseInt(document.getElementById('compress-resize').value) / 100
        };
    }
}

async function executeCompress() {
    saveCompressSettings();

    const params = getCompressParams();
    const progressDiv = document.getElementById('compress-progress');
    const progressFill = document.getElementById('compress-progress-fill');
    const progressText = document.getElementById('compress-progress-text');
    const confirmBtn = document.getElementById('confirm-compress');

    confirmBtn.disabled = true;
    progressDiv.style.display = 'block';
    progressFill.style.width = '0%';
    progressText.textContent = 'Подготовка...';

    let pdfFile;
    let originalFileName;
    if (selectedFileIndex < pdfFiles.length) {
        pdfFile = pdfFiles[selectedFileIndex].file;
        originalFileName = pdfFile.name;
    } else {
        pdfFile = combinedFiles[selectedFileIndex - pdfFiles.length];
        originalFileName = pdfFile.name;
    }

    try {
        const pdfBytes = await pdfFile.arrayBuffer();
        const originalSize = pdfBytes.byteLength;
        
        const pdfDoc = await pdfjsLib.getDocument({ data: new Uint8Array(pdfBytes) }).promise;
        const numPages = pdfDoc.numPages;

        const newPdf = await PDFLib.PDFDocument.create();

        for (let i = 1; i <= numPages; i++) {
            const percent = Math.round((i / numPages) * 100);
            progressFill.style.width = percent + '%';
            progressText.textContent = `Страница ${i} из ${numPages}...`;

            const page = await pdfDoc.getPage(i);
            const viewport = page.getViewport({ scale: 1 });

            const renderScale = (params.dpi / 72) * params.resize;
            const renderViewport = page.getViewport({ scale: renderScale });

            const cvs = document.createElement('canvas');
            cvs.width = Math.floor(renderViewport.width);
            cvs.height = Math.floor(renderViewport.height);
            const cvsCtx = cvs.getContext('2d');

            cvsCtx.fillStyle = '#ffffff';
            cvsCtx.fillRect(0, 0, cvs.width, cvs.height);

            await page.render({ canvasContext: cvsCtx, viewport: renderViewport }).promise;

            const jpegBlob = await new Promise((resolve, reject) => {
                cvs.toBlob(function(blob) {
                    if (!blob) {
                        reject(new Error('toBlob вернул null'));
                        return;
                    }
                    resolve(blob);
                }, 'image/jpeg', params.quality);
            });

            const jpgImage = await newPdf.embedJpg(await jpegBlob.arrayBuffer());

            const pageWidth = viewport.width;
            const pageHeight = viewport.height;
            const newPage = newPdf.addPage([pageWidth, pageHeight]);
            newPage.drawImage(jpgImage, {
                x: 0,
                y: 0,
                width: pageWidth,
                height: pageHeight,
            });

            cvs.width = 0;
            cvs.height = 0;

            await new Promise(r => setTimeout(r, 10));
        }

        progressText.textContent = 'Сохранение...';
        const compressedBytes = await newPdf.save();
        const compressedSize = compressedBytes.byteLength;

        const originalSizeMB = (originalSize / (1024 * 1024)).toFixed(2);
        const compressedSizeMB = (compressedSize / (1024 * 1024)).toFixed(2);
        const percentOfOriginal = ((compressedSize / originalSize) * 100).toFixed(1);

        // Сохраняем реальный коэффициент сжатия
        const compressRatio = compressedSize / originalSize;
        const activeTab = document.querySelector('.compress-tab.active').dataset.tab;
        if (activeTab === 'simple') {
            const usedLevel = parseInt(document.getElementById('compress-level').value);
            compressRatios[usedLevel] = compressRatio;
            saveCompressSettings();
            // Обновить описание слайдера с актуальным размером
            const sizeInfo = getEstimatedSize(usedLevel);
            document.getElementById('compress-level-desc').textContent = compressPresets[usedLevel].desc + sizeInfo;
        }

        const now = new Date();
        const ts = `${now.getFullYear()}${String(now.getMonth()+1).padStart(2,'0')}${String(now.getDate()).padStart(2,'0')}-${String(now.getHours()).padStart(2,'0')}${String(now.getMinutes()).padStart(2,'0')}${String(now.getSeconds()).padStart(2,'0')}`;
        const compressedName = `Compressed_${ts}_${originalFileName}`;

        const blob = new Blob([compressedBytes], { type: 'application/pdf' });
        const compressedFile = new File([blob], compressedName, { type: 'application/pdf' });

        combinedFiles.push(compressedFile);
        updateCombinedFilesList();

        const link = document.createElement('a');
        link.href = URL.createObjectURL(blob);
        link.download = compressedName;
        link.click();
        setTimeout(() => URL.revokeObjectURL(link.href), 1000);

        progressText.textContent = `Готово! ${compressedSizeMB} МБ / ${originalSizeMB} МБ (${percentOfOriginal}% от оригинала)`;

        setTimeout(() => closeCompressModal(), 2500);

    } catch (error) {
        console.error('Ошибка сжатия PDF:', error);
        progressText.textContent = 'Ошибка: ' + error.message;
        confirmBtn.disabled = false;
    }
}

// Slider live update
document.addEventListener('DOMContentLoaded', function() {
    const slider = document.getElementById('compress-level');
    if (slider) {
        slider.addEventListener('input', function() {
            const val = parseInt(this.value);
            const sizeInfo = getEstimatedSize(val);
            document.getElementById('compress-level-display').textContent = val;
            document.getElementById('compress-level-desc').textContent = compressPresets[val].desc + sizeInfo;
        });
    }
});


    </script>
</body>
</html>