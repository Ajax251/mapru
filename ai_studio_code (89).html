<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Профессиональный Grid-график</title>
    <!-- Подключаем Lightweight Charts™ -->
    <script src="https://unpkg.com/lightweight-charts/dist/lightweight-charts.standalone.production.js"></script>
    <!-- Подключаем PapaParse для удобной работы с CSV -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.2/papaparse.min.js"></script>
    
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;700&display=swap');
        :root {
            --dark-bg: #1e222d; --dark-text: #d1d4dc; --dark-panel: #2a2e39; --dark-border: #444;
            --light-bg: #ffffff; --light-text: #333; --light-panel: #f8f9fa; --light-border: #dee2e6;
            --accent-color: #2962ff; --accent-hover: #1e4bd8;
        }
        body {
            font-family: 'Roboto', sans-serif;
            margin: 0; padding: 0; display: flex; flex-direction: column;
            height: 100vh; overflow: hidden; transition: background-color 0.3s, color 0.3s;
        }
        body.dark-theme { background-color: var(--dark-bg); color: var(--dark-text); }
        body.light-theme { background-color: var(--light-bg); color: var(--light-text); }
        .controls {
            padding: 15px 20px; display: flex; flex-wrap: wrap; justify-content: space-between; align-items: center;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1); flex-shrink: 0;
            background-color: var(--light-panel);
        }
        body.dark-theme .controls { background-color: var(--dark-panel); }
        .chart-container { flex-grow: 1; position: relative; }
        h1 { margin: 0 10px 0 0; font-size: 20px; font-weight: 700; white-space: nowrap; }
        input[type="file"] { display: none; }
        .btn {
            display: inline-block; padding: 8px 16px; background-color: var(--accent-color);
            color: white; border: none; border-radius: 5px; cursor: pointer;
            transition: all 0.3s ease; margin: 5px; font-size: 13px; font-weight: 500;
            text-transform: uppercase; letter-spacing: 1px;
        }
        .btn:hover { background-color: var(--accent-hover); transform: translateY(-2px); box-shadow: 0 4px 6px rgba(0,0,0,0.1); }
        select, input[type="number"] {
            margin: 5px; padding: 8px; border: 1px solid var(--light-border); border-radius: 5px;
            font-size: 13px; cursor: pointer;
            background-color: #fff; color: #333;
        }
        body.dark-theme select, body.dark-theme input[type="number"] {
            background-color: #40434f; color: var(--dark-text); border-color: var(--dark-border);
        }
    </style>
</head>
<body class="dark-theme">
    <div class="controls">
        <h1>Grid-график</h1>
        <div>
            <label for="file-input" class="btn">Загрузить CSV</label>
            <input type="file" id="file-input" accept=".csv,.txt">
            <input type="number" id="gridStepPips" value="50" title="Шаг сетки в пунктах">
            <select id="theme">
                <option value="dark">Темная тема</option>
                <option value="light">Светлая тема</option>
            </select>
        </div>
    </div>
    <div id="chart-container"></div>

    <script>
        const chartContainer = document.getElementById('chart-container');
        const themeSelect = document.getElementById('theme');
        const fileInput = document.getElementById('file-input');
        const gridStepInput = document.getElementById('gridStepPips');

        let chart = null;
        let series = null;
        let g_parsedData = null; // Глобальный кеш для данных

        // --- Инициализация графика ---
        function createChart() {
            if (chart) chart.remove();
            
            const currentTheme = themeSelect.value;
            chart = LightweightCharts.createChart(chartContainer, {
                width: chartContainer.clientWidth,
                height: chartContainer.clientHeight,
                layout: {
                    background: { type: 'solid', color: currentTheme === 'dark' ? '#1e222d' : '#ffffff' },
                    textColor: currentTheme === 'dark' ? '#d1d4dc' : '#333333',
                },
                grid: {
                    vertLines: { color: currentTheme === 'dark' ? '#2b2b43' : '#e0e0e0' },
                    horzLines: { color: currentTheme === 'dark' ? '#2b2b43' : '#e0e0e0' },
                },
                crosshair: { mode: LightweightCharts.CrosshairMode.Normal },
                timeScale: { timeVisible: true, secondsVisible: false, borderColor: currentTheme === 'dark' ? '#444' : '#ccc' },
            });
            series = chart.addLineSeries({
                color: '#2962ff',
                lineWidth: 2,
            });
        }

        // --- Главный обработчик ---
        function buildChart() {
            if (!g_parsedData) {
                alert('Сначала загрузите или вставьте данные.');
                return;
            }
            const gridStepPips = parseInt(gridStepInput.value);
            if (!gridStepPips || gridStepPips <= 0) { alert('Введите корректный шаг сетки.'); return; }

            const gridChartResult = generateGridData(g_parsedData, gridStepPips);
            logSummary(g_parsedData, gridChartResult, gridStepPips);
            
            if (!chart || !series) createChart();
            
            series.setData(gridChartResult);
            chart.timeScale().fitContent();
        }

        // --- Загрузка и парсинг данных ---
        fileInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                Papa.parse(file, {
                    complete: (results) => {
                        g_parsedData = parseRawData(results.data);
                        if (g_parsedData && g_parsedData.length > 0) buildChart();
                        else alert('Не удалось обработать данные из файла. Проверьте формат.');
                    }
                });
            }
        });
        
        // Позволяет вставлять данные прямо в окно
        document.addEventListener('paste', (e) => {
            const pastedText = (e.clipboardData || window.clipboardData).getData('text');
            const parsedRows = Papa.parse(pastedText, { skipEmptyLines: true }).data;
            g_parsedData = parseRawData(parsedRows);
            if (g_parsedData && g_parsedData.length > 0) {
                 alert(`${g_parsedData.length} строк успешно вставлено. Строим график.`);
                 buildChart();
            } else {
                 alert('Не удалось обработать вставленные данные. Проверьте формат.');
            }
        });

        function parseRawData(dataRows) {
            const firstRow = dataRows[0];
            if (!firstRow) return null;
            
            if (firstRow.length >= 6) { // OHLCV
                return dataRows.map(row => {
                    const price = (v) => parseFloat(String(v).replace(',', '.'));
                    return { date: row[0], timeStr: row[1], open: price(row[2]), high: price(row[3]), low: price(row[4]), close: price(row[5]) };
                }).filter(i => i && !isNaN(i.close));
            } else { // Простой
                return dataRows.map(row => {
                    const price = parseFloat(String(row[1]).replace(',', '.'));
                    if (isNaN(price)) return null;
                    return { date: row[0], timeStr: "00:00", open: price, high: price, low: price, close: price };
                }).filter(Boolean);
            }
        }

        // --- Генератор Grid-данных ---
        function generateGridData(priceData, gridStepPips) {
            const firstPrice = priceData[0].close;
            const decimals = Math.max(...priceData.map(p => (p.close.toString().split('.')[1] || '').length));
            const pointMultiplier = (decimals === 5 || decimals === 3) ? 10 : 1;
            const gridStepPrice = gridStepPips * pointMultiplier * (1 / Math.pow(10, decimals));

            const dataPoints = [];
            let currentLevel = Math.round(firstPrice / gridStepPrice) * gridStepPrice;
            
            const parseDate = (d, t) => {
                const [year, month, day] = d.split('.').map(Number);
                const [hours, minutes] = t.split(':').map(Number);
                return new Date(Date.UTC(year, month - 1, day, hours, minutes)).getTime() / 1000;
            }

            dataPoints.push({ time: parseDate(priceData[0].date, priceData[0].timeStr), value: currentLevel });

            for (const candle of priceData) {
                const candleDirection = candle.close >= candle.open ? 'up' : 'down';
                const processMoves = (primaryMove, secondaryMove) => {
                    while (primaryMove(candle, currentLevel, gridStepPrice)) {
                        currentLevel = primaryMove === checkUp ? currentLevel + gridStepPrice : currentLevel - gridStepPrice;
                        dataPoints.push({ time: parseDate(candle.date, candle.timeStr), value: currentLevel });
                    }
                    while (secondaryMove(candle, currentLevel, gridStepPrice)) {
                        currentLevel = secondaryMove === checkUp ? currentLevel + gridStepPrice : currentLevel - gridStepPrice;
                        dataPoints.push({ time: parseDate(candle.date, candle.timeStr), value: currentLevel });
                    }
                };
                const checkUp = (c, level, step) => c.high >= level + step;
                const checkDown = (c, level, step) => c.low <= level - step;
                if (candleDirection === 'up') processMoves(checkUp, checkDown);
                else processMoves(checkDown, checkUp);
            }
            return dataPoints;
        }
        
        // --- Вспомогательные функции ---
        function logSummary(parsedData, gridResult, gridStepPips) {
             console.clear();
             console.log("--- Сводка по обработке данных ---");
             console.log(`Шаг сетки: ${gridStepPips} пипсов.`);
             console.log(`Всего входных строк: ${parsedData.length}`);
             console.log(`Первая запись:`, parsedData[0]);
             console.log(`Последняя запись:`, parsedData[parsedData.length - 1]);
             console.log(`Сгенерировано событий: ${gridResult.length}`);
             console.log("------------------------------------");
        }
        
        themeSelect.addEventListener('change', () => {
            document.body.className = themeSelect.value + '-theme';
            if (chart) {
                const currentTheme = themeSelect.value;
                chart.applyOptions({
                    layout: { background: { color: currentTheme === 'dark' ? '#1e222d' : '#ffffff' }, textColor: currentTheme === 'dark' ? '#d1d4dc' : '#333' },
                    grid: { vertLines: { color: currentTheme === 'dark' ? '#2b2b43' : '#e0e0e0' }, horzLines: { color: currentTheme === 'dark' ? '#2b2b43' : '#e0e0e0' } }
                });
            }
        });
        
        gridStepInput.addEventListener('change', buildChart);
        
        window.addEventListener('resize', () => {
            if (chart) chart.resize(chartContainer.clientWidth, chartContainer.clientHeight);
        });

        // --- Навигация с клавиатуры ---
        window.addEventListener('keydown', (e) => {
            if (!chart) return;
            const timeScale = chart.timeScale();
            
            switch(e.key) {
                case 'ArrowLeft':
                    timeScale.scrollBy(-10); // Прокрутка на 10 баров влево
                    break;
                case 'ArrowRight':
                    timeScale.scrollBy(10); // Прокрутка на 10 баров вправо
                    break;
                case '+':
                case '=':
                    timeScale.zoomIn();
                    break;
                case '-':
                    timeScale.zoomOut();
                    break;
            }
        });
        
        // Первоначальное создание пустого графика
        createChart();

    </script>
</body>
</html>