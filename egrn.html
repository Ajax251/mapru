<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ЕГРН</title>
    <link rel="icon" href="img/savannah.png" type="image/png">
    <link rel="stylesheet" href="webfonts/all.min.css">
     <script src="webfonts/proj4.js"></script>
<script src="webfonts/jspdf.umd.min.js"></script>
<script src="webfonts/jszip.min.js"></script>
<script src="webfonts/html2canvas.min.js"></script>
<script src="webfonts/xlsx.full.min.js"></script>
<script src="webfonts/supabase-js@2.js"></script> 
  <script src="sk.js"></script>
<script src="msk.js"></script>


    <style>
   
   :root {
        --primary-color: #2196F3;
        --secondary-color: #f5f5f5;
        --border-color: #e0e0e0;
        --text-color: #333;
        --spacing: 20px;
    }

    /* Анимации */
    @keyframes fadeIn {
        from { opacity: 0; transform: translateY(-20px); }
        to { opacity: 1; transform: translateY(0); }
    }

    @keyframes slideIn {
        from { transform: translateX(-100%); opacity: 0; }
        to { transform: translateX(0); opacity: 1; }
    }

    body {
        font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        margin: 0;
        padding: var(--spacing);
        background-color: #fafafa;
        color: var(--text-color);
        animation: fadeIn 0.8s ease-out;
    }

    .search-container {
        background: linear-gradient(145deg, #ffffff, #f0f0f0);
        padding: var(--spacing);
        border-radius: 8px;
        box-shadow: 0 8px 15px rgba(0,0,0,0.1);
        margin-bottom: var(--spacing);
        animation: slideIn 0.8s ease-out;
    }

    .search-box {
        display: flex;
        gap: 15px;
        align-items: center;
        position: relative;
        padding: 5px;
    }

    input[type="text"] {
        flex: 1;
        font-size: 18px;
        padding: 15px 20px;
        border: 2px solid var(--border-color);
        border-radius: 25px;
        transition: all 0.3s ease;
        text-align: center;
        box-shadow: inset 0 1px 3px rgba(0,0,0,0.1);
        margin-right: 10px;
        min-width: 0;
    }

    input[type="text"]:focus {
        outline: none;
        border-color: var(--primary-color);
        box-shadow: 0 0 0 3px rgba(33, 150, 243, 0.2);
        transform: scale(1.02);
    }

  button {
    flex-shrink: 0;
    border-radius: 50%;
    width: 50px;
    height: 50px;
    color: white;
    border: none;
    cursor: pointer;
    transition: all 0.3s ease;
    display: flex;
    align-items: center;
    justify-content: center;
    box-shadow: 0 4px 6px rgba(0, 0, 0, 0.2);
    position: relative;
    overflow: hidden;
}

button i {
    font-size: 18px;
    transition: transform 0.3s ease;
}

button:hover {
    transform: translateY(-2px);
    box-shadow: 0 6px 10px rgba(0, 0, 0, 0.3);
}

button:hover i {
    transform: scale(1.2);
}

button:active {
    transform: translateY(0);
    box-shadow: 0 3px 6px rgba(0, 0, 0, 0.2);
}

/* Эффект "нажатия" (ripple) */
button:active::after {
    content: '';
    position: absolute;
    top: 50%;
    left: 50%;
    width: 300%;
    height: 300%;
    background: rgba(255, 255, 255, 0.4);
    transform: translate(-50%, -50%) scale(0);
    border-radius: 50%;
    animation: ripple 0.6s ease;
}

@keyframes ripple {
    to {
        transform: translate(-50%, -50%) scale(1);
        opacity: 0;
    }
}

/* Цвета кнопок из варианта 2 */
button.search-button {
    background: linear-gradient(145deg, #4CAF50, #45a049);
}

button.map-button {
  background: linear-gradient(145deg, #9C27B0, #7B1FA2);

}

button.coordinates-button {
     background: linear-gradient(145deg, #FF9800, #F57C00); 
}

button.keyboard-button {
    background: linear-gradient(145deg, #6395ee, #6395ee);
}

button.yandex-map-button {
    background: linear-gradient(145deg, #FF4444, #CC0000); /* Градиентный красный цвет */
}

button.yandex-map-button:hover {
    background: linear-gradient(145deg, #CC0000, #FF4444); /* Инвертированный градиент при наведении */
}

button.yandex-map-button:active {
    background: linear-gradient(145deg, #CC0000, #FF4444); /* Градиент при нажатии */
}


    .content-container {
        display: none;
        grid-template-columns: 1fr 1fr;
        gap: var(--spacing);
        height: calc(100vh - 150px);
    }

    .data-container {
        background: white;
        padding: var(--spacing);
        border-radius: 8px;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        overflow-y: auto;
    }

    .scheme-container {
        background: white;
        padding: var(--spacing);
        border-radius: 8px;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        position: relative; /* Добавляем для позиционирования "глаза" */
    }

    #schemeCanvas {
        width: 100%;
        height: 100%;
        border: 1px solid var(--border-color);
        border-radius: 4px;
    }
    
/* Стили для toggle */
.toggle-container {
    position: absolute;
    top: 20px;
    right: 20px;
    z-index: 10;
}

.toggle {
    display: none;
}

.toggle + label {
    display: inline-block;
    width: 55px;
    height: 28px;
    background-color: #fff;
    border-radius: 30px;
    position: relative;
    cursor: pointer;
    transition: background-color 0.3s ease;
}

.toggle + label:after {
    content: '';
    display: inline-block;
    position: absolute;
    width: 24px;
    height: 24px;
    background-color: #fff;
    top: 2px;
    left: 2px;
    border-radius: 50%;
    transition: all 0.3s ease;
}

.toggle:checked + label {
    background-color: #2196F3;
}

.toggle:checked + label:after {
    left: 29px;
}
    
    
    
    /* Toggle Specific styles */
input[type='checkbox'].toggle {
    display: inline-block;
    -webkit-appearance: none;
    -moz-appearance: none;
    appearance: none;
    width: 55px;
    height: 28px;
    background-color: #fafafa;
    position: relative;
    border-radius: 30px;
    box-shadow: none;
    transition: all 0.2s ease-in-out;
}

input[type='checkbox'].toggle:hover:after {
    background-color: #d1d1d1;
}

input[type='checkbox'].toggle:after {
    content: '';
    display: inline-block;
    position: absolute;
    width: 24px;
    height: 24px;
    background-color: #ccc;
    top: 2px;
    left: 2px;
    border-radius: 50%;
    transition: all 0.2s ease-in-out;
}

input[type='checkbox'].toggle:checked {
    box-shadow: inset 0 0 0 15px #158EC6;
}

input[type='checkbox'].toggle:checked:after {
    left: 29px;
    background-color: #fff;
}



    /* Стили для таблиц */
    table {
        width: 100%;
        border-collapse: collapse;
        margin-top: 10px;
        border-radius: 8px;
        overflow: hidden;
        box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        animation: fadeIn 0.8s ease-out;
    }

    th, td {
        padding: 15px;
        text-align: left;
        border-bottom: 1px solid var(--border-color);
        transition: background-color 0.3s ease;
    }

    th {
        background-color: var(--secondary-color);
        font-weight: 600;
    }

    tr:hover td {
        background-color: #f5f5f5;
    }

    /* Модальное окно */
    .modal {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0,0,0,0.5);
        z-index: 1000;
        animation: fadeIn 0.3s ease-out;
    }

    .modal-content {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: white;
        padding: 30px;
        border-radius: 15px;
        box-shadow: 0 10px 25px rgba(0,0,0,0.2);
        max-width: 600px;
        width: 90%;
        max-height: 80vh;
        overflow-y: auto;
        text-align: center;
    }

    #modalCoordinatesTable {
        width: 100%;
        border-collapse: collapse;
        margin-top: 20px;
    }

    #modalCoordinatesTable th,
    #modalCoordinatesTable td {
        text-align: center;
        padding: 12px;
        border: 1px solid var(--border-color);
    }

    #modalCoordinatesTable th {
        background-color: var(--secondary-color);
        font-weight: 600;
        text-align: center;
    }

    #modalCoordinatesTable tr:hover td {
        background-color: #f5f5f5;
    }

    .close-modal {
        position: absolute;
        top: 15px;
        right: 15px;
        font-size: 24px;
        cursor: pointer;
        color: #666;
        transition: color 0.3s ease;
    }

    .close-modal:hover {
        color: #333;
    }

    /* Уведомления */
    #notification-container {
        position: fixed;
        bottom: 20px;
        right: 20px;
        z-index: 1000;
        display: flex;
        flex-direction: column;
        gap: 10px;
    }

    .notification {
        background-color: #333;
        color: white;
        padding: 15px 20px;
        border-radius: 5px;
        box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        opacity: 0;
        transform: translateX(100%);
        transition: opacity 0.3s ease, transform 0.3s ease;
    }

    .notification.show {
        opacity: 1;
        transform: translateX(0);
    }

    .notification.success {
        background-color: #4CAF50;
    }

    .notification.error {
        background-color: #F44336;
    }

    .notification.info {
        background-color: #2196F3;
    }
    
     .notification.warning {
        background-color: #FF9800; /* Оранжевый цвет */
    }

    /* Стили для виртуальной клавиатуры */
    .virtual-keyboard {
        display: none;
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: #f5f5f5;
        padding: 20px;
        border-radius: 12px;
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        z-index: 1000;
    }

    .virtual-keyboard.active {
        display: block;
    }

    .keyboard-row {
        display: flex;
        justify-content: center;
        gap: 10px;
        margin-bottom: 10px;
    }

    .keyboard-key {
        width: 60px;
        height: 60px;
        display: flex;
        align-items: center;
        justify-content: center;
        background: #ffffff;
        border: 1px solid #ccc;
        border-radius: 8px;
        cursor: pointer;
        font-size: 20px;
        transition: background 0.3s ease, transform 0.1s ease;
    }

    .keyboard-key:hover {
        background: #e0e0e0;
    }

    .keyboard-key:active {
        background: #d0d0d0;
        transform: scale(0.95);
    }

    .keyboard-key.clear {
        background: #ff4444;
        color: white;
    }

    .keyboard-key.clear:hover {
        background: #cc0000;
    }

    .keyboard-key.enter {
        background: #4CAF50;
        color: white;
        flex-grow: 1;
    }

    .keyboard-key.enter:hover {
        background: #45a049;
    }

    .keyboard-key.enter:active {
        background: #3d8b40;
    }

    /* Стили для мобильной версии */
    @media (max-width: 768px) {
        .search-box {
            flex-direction: column;
            gap: 10px;
        }

        .search-box input[type="text"] {
            width: 100%;
            margin-right: 0;
        }

        .button-row {
            display: flex;
            gap: 10px;
            width: 100%;
        }

        .button-row button {
            flex: 1;
            border-radius: 8px;
        }

        .mobile-only {
            display: block;
        }

        .scheme-container {
            display: none;
        }

        .content-container {
            display: block !important;
            height: auto;
        }

        .data-container {
            width: 100%;
            margin-bottom: var(--spacing);
        }

        #resultTable {
            margin: 0;
        }
    }
    
@media (max-width: 768px) {
    .scheme-container {
        display: block; /* Показываем canvas по умолчанию */
        width: 100%; /* Занимает всю ширину */
        height: 300px; /* Фиксированная высота для мобильной версии */
        margin-bottom: var(--spacing); /* Добавляем отступ снизу */
    }

    .content-container {
        display: block !important;
        height: auto;
    }

    .data-container {
        width: 100%;
        margin-bottom: var(--spacing);
    }

    #resultTable {
        margin: 0;
    }
}
    /* Стили для десктопной версии */
    @media (min-width: 769px) {
        .search-box {
            flex-direction: row;
        }

        .button-row {
            display: flex;
            gap: 10px;
        }

        .mobile-only {
            display: none;
        }
    }
    
.convert-button {
    background: linear-gradient(145deg, #4CAF50, #45a049);
    color: white;
    border: none;
    padding: 15px 20px;
    border-radius: 5px;
    cursor: pointer;
    font-size: 16px;
    margin-bottom: 15px;
    transition: background 0.3s ease, transform 0.2s ease;
    width: 100%; /* Кнопка на всю ширину */
    box-sizing: border-box; /* Учитываем padding в ширине */
}

.convert-button:hover {
    background: linear-gradient(145deg, #45a049, #4CAF50);
    transform: translateY(-2px);
}

.convert-button:active {
    transform: translateY(0);
}

/* Стили для таблицы */
#resultTable {
    width: 100%;
    border-collapse: separate;
    border-spacing: 0;
    margin-top: 10px;
    border-radius: 12px;
    overflow: hidden;
    box-shadow: 0 6px 16px rgba(0,0,0,0.1);
    animation: tableAppear 0.6s ease-out;
    background: white;
}

@keyframes tableAppear {
    from {
        opacity: 0;
        transform: translateY(20px);
    }
    to {
        opacity: 1;
        transform: translateY(0);
    }
}

#resultTable tr {
    animation: rowFadeIn 0.5s ease-out;
    animation-fill-mode: both;
}

@keyframes rowFadeIn {
    from {
        opacity: 0;
        transform: translateX(-20px);
    }
    to {
        opacity: 1;
        transform: translateX(0);
    }
}

#resultTable tr:nth-child(even) {
    background-color: #f8f9fa;
}

#resultTable td {
    padding: 14px 18px;
    border-bottom: 1px solid rgba(0,0,0,0.05);
    transition: all 0.3s ease;
    line-height: 1.4;
}

#resultTable td:first-child {
    font-weight: 500;
    color: #2c3e50;
    width: 30%;
    position: relative;
}

#resultTable td:first-child::after {
    content: '';
    position: absolute;
    right: 0;
    top: 50%;
    transform: translateY(-50%);
    height: 70%;
    width: 1px;
    background: rgba(0,0,0,0.05);
}

#resultTable td:last-child {
    color: #34495e;
}

/* --- Стили для кнопки копирования в таблице --- */

#resultTable td:last-child {
    position: relative;
    /* Добавляем отступ справа, чтобы текст не заезжал под кнопку */
    padding-right: 40px; 
}

/* Стили самой кнопки-иконки */
.copy-icon-button {
    display: none; /* Скрыта по умолчанию */
    position: absolute;
    top: 50%;
    right: 8px; /* Немного ближе к краю */
    transform: translateY(-50%);
    /* --- ИЗМЕНЕНИЕ: Зеленый градиент --- */
    background: linear-gradient(145deg, #4CAF50, #45a049);
    color: white;
    border: none;
    /* --- ИЗМЕНЕНИЕ: Уменьшенный размер --- */
    width: 24px;
    height: 24px;
    border-radius: 50%;
    cursor: pointer;
    /* --- ИЗМЕНЕНИЕ: Уменьшенный размер иконки --- */
    font-size: 12px;
    transition: all 0.2s ease;
    align-items: center;
    justify-content: center;
    box-shadow: 0 1px 3px rgba(0,0,0,0.15);
    z-index: 5; /* Чтобы кнопка была поверх содержимого */
}

/* Показываем кнопку при наведении на любую строку таблицы */
#resultTable tr:hover .copy-icon-button {
    display: flex; 
}

.copy-icon-button:hover {
    /* --- ИЗМЕНЕНИЕ: Зеленый градиент при наведении --- */
    background: linear-gradient(145deg, #45a049, #4CAF50);
    transform: translateY(-50%) scale(1.1);
    box-shadow: 0 3px 6px rgba(0,0,0,0.2);
}

.copy-icon-button:active {
    transform: translateY(-50%) scale(1);
}

#resultTable tr:hover {
    background-color: #f1f4f6 !important;
    transform: translateX(5px);
    transition: all 0.3s ease;
}

/* Стили для значений в таблице */
#resultTable td strong {
    font-weight: 500;
    color: #2c3e50;
    display: inline-block;
    transition: all 0.3s ease;
}



/* Стили для мобильной версии */
@media (max-width: 768px) {
    #resultTable td {
        padding: 12px 15px;
    }

    #resultTable td:first-child {
        width: 40%;
    }

    #resultTable {
        font-size: 14px;
    }
}

/* Эффект появления для всей таблицы */
.data-container {
    perspective: 1000px;
}

#resultTable {
    transform-origin: top center;
    animation: tableReveal 0.6s ease-out;
}

@keyframes tableReveal {
    from {
        opacity: 0;
        transform: rotateX(-10deg);
    }
    to {
        opacity: 1;
        transform: rotateX(0);
    }
}

   .map-buttons {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }

        .map-buttons button {
            display: flex;
            align-items: center;
            gap: 5px;
            padding: 10px 15px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            transition: background 0.3s ease, transform 0.2s ease;
        }

        .map-buttons button:hover {
            transform: translateY(-2px);
        }

        .map-buttons button:active {
            transform: translateY(0);
        }

        .map-buttons .yandex-map-button {
            background: linear-gradient(145deg, #FF4444, #CC0000);
            color: white;
        }

        .map-buttons .google-map-button {
            background: linear-gradient(145deg, #4285F4, #357ABD);
            color: white;
        }
        
            /* Стили для контейнера кнопок */
        .button-container {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }

        .button-container button {
            flex: 1; /* Равная ширина для всех кнопок */
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 5px;
            padding: 10px 15px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            transition: background 0.3s ease, transform 0.2s ease;
        }

        .button-container button:hover {
            transform: translateY(-2px);
        }

        .button-container button:active {
            transform: translateY(0);
        }

        .button-container .convert-button {
            background: linear-gradient(145deg, #4CAF50, #45a049);
            color: white;
        }

        .button-container .yandex-map-button {
            background: linear-gradient(145deg, #FF4444, #CC0000);
            color: white;
        }

        .button-container .google-map-button {
            background: linear-gradient(145deg, #4285F4, #357ABD);
            color: white;
        }
        
          #modalCoordinatesTable th:first-child,
        #modalCoordinatesTable td:first-child {
            width: 50px; /* Ширина колонки с номером */
            text-align: center; /* Выравнивание по центру */
        }
        
        /* Стили для модального окна поиска */
/* Стили для модального окна поиска */
.search-modal-container {
    display: flex;
    flex-direction: column;
    gap: 20px;
    padding: 20px;
    width: 400px; /* Фиксированная ширина контейнера */
    margin: 0 auto; /* Центрирование */
}

#rightNumberInput {
    width: 100%; /* Поле ввода занимает всю ширину контейнера */
    font-size: 18px;
    padding: 15px 20px;
    border: 2px solid var(--border-color);
    border-radius: 25px;
    transition: all 0.3s ease;
    text-align: center;
    box-shadow: inset 0 1px 3px rgba(0,0,0,0.1);
    box-sizing: border-box; /* Учитываем padding в общей ширине */
}

.search-right-button {
    width: 100%; /* Кнопка занимает всю ширину контейнера */
    padding: 15px 20px;
    border-radius: 25px;
    background: linear-gradient(145deg, #4CAF50, #45a049);
    color: white;
    border: none;
    font-size: 16px;
    cursor: pointer;
    transition: all 0.3s ease;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 10px;
    box-sizing: border-box; /* Учитываем padding в общей ширине */
}

#rightNumberInput:focus {
    outline: none;
    border-color: var(--primary-color);
    box-shadow: 0 0 0 3px rgba(33, 150, 243, 0.2);
    transform: scale(1.02);
}


.search-right-button:hover {
    transform: translateY(-2px);
    box-shadow: 0 6px 10px rgba(0, 0, 0, 0.3);
}

.search-right-button:active {
    transform: translateY(0);
    box-shadow: 0 3px 6px rgba(0, 0, 0, 0.2);
}

#rightSearchTable {
    width: 100%;
    margin-top: 20px;
    border-collapse: collapse;
    background: white;
    border-radius: 8px;
    overflow: hidden;
    box-shadow: 0 4px 6px rgba(0,0,0,0.1);
}

#rightSearchTable td {
    padding: 12px 15px;
    border-bottom: 1px solid #e0e0e0;
}

#rightSearchTable td:first-child {
    font-weight: 500;
    width: 30%;
    color: #2c3e50;
}

#rightSearchTable td:last-child {
    color: #34495e;
}


/* Стили для кнопки "Единое землепользование" */
.ez-button {
    background: linear-gradient(145deg, #4CAF50, #45a049);
    color: white;
    border: none;
    padding: 10px 20px; /* Уменьшим отступы для компактности */
    border-radius: 8px; /* Закругленные углы */
    cursor: pointer;
    font-size: 16px;
    transition: background 0.3s ease, transform 0.2s ease;
    display: inline-flex; /* Используем inline-flex для компактного размера */
    align-items: center;
    justify-content: center;
    gap: 8px; /* Расстояние между иконкой и текстом */
    box-shadow: 0 4px 6px rgba(0, 0, 0, 0.2);
        width: 300px; /* Фиксированная ширина */
}

.ez-button:hover {
    background: linear-gradient(145deg, #45a049, #4CAF50);
    transform: translateY(-2px);
    box-shadow: 0 6px 10px rgba(0, 0, 0, 0.3);
}

.ez-button:active {
    transform: translateY(0);
    box-shadow: 0 3px 6px rgba(0, 0, 0, 0.2);
}

.ez-button i {
    font-size: 16px; /* Уменьшим размер иконки для пропорциональности */
}

.scheme-button {
    background: linear-gradient(145deg, #3F51B5, #303F9F);
    color: white;
    border: none;
    padding: 15px 20px;
    border-radius: 5px;
    cursor: pointer;
    font-size: 16px;
    transition: background 0.3s ease, transform 0.2s ease;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 8px;
}

.scheme-button:hover {
    background: linear-gradient(145deg, #303F9F, #3F51B5);
    transform: translateY(-2px);
}

.scheme-button:active {
    transform: translateY(0);
}

.copy-coordinates-button {
    background: linear-gradient(145deg, #2196F3, #1976D2);
    color: white;
    border: none;
    width: 36px;
    height: 36px;
    border-radius: 50%;
    cursor: pointer;
    font-size: 16px;
    transition: background 0.3s ease, transform 0.2s ease;
    display: flex;
    align-items: center;
    justify-content: center;
    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
    margin: 0   auto; /* Центрируем кнопку в ячейке */
}

.copy-coordinates-button:hover {
    background: linear-gradient(145deg, #1976D2, #2196F3);
    transform: translateY(-2px);
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
}

.copy-coordinates-button:active {
    transform: translateY(0);
    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
}

/* Стили для заголовка таблицы */
#modalCoordinatesTable th {
    padding: 12px 15px;
    text-align: center;
    background-color: var(--secondary-color);
    font-weight: 600;
}

/* Убираем стандартные отступы и рамки у кнопки в заголовке */
#modalCoordinatesTable th button {
    margin: 0;
    padding: 0;
    border: none;
    outline: none;
}


/* Контейнер для поля ввода и иконки */
.input-container {
    position: relative;
    flex: 1; /* Занимает всё доступное пространство */
    margin-right: 10px; /* Отступ от кнопок */
}

/* Поле ввода */
#cadastralNumber {
    width: 100%; /* Занимает всю ширину контейнера */
    font-size: 18px;
    padding: 15px 40px 15px 20px; /* Добавляем отступ справа для иконки */
    border: 2px solid var(--border-color);
    border-radius: 25px;
          transition: all 0.3s ease;
    text-align: center;
    box-shadow: inset 0 1px 3px rgba(0,0,0,0.1);
    box-sizing: border-box; /* Учитываем padding в ширине */
}

/* Контейнер для иконки */
.icon-container {
    position: absolute;
    top: 50%;
    right: 10px; /* Отступ от правого края */
    transform: translateY(-50%); /* Центрируем по вертикали */
    cursor: pointer;
    padding: 8px;
    border-radius: 50%;
    transition: background 0.3s ease;
}

.icon-container:hover {
    background: rgba(0, 0, 0, 0.1); /* Легкий эффект при наведении */
}

/* Стили для иконки */
.site-icon {
    width: 24px; /* Размер иконки */
    height: 24px;
    transition: filter 0.3s ease;
}

.icon-container:hover .site-icon {
    filter: grayscale(0%); /* Цветная иконка при наведении */
}

.keyboard-key.insert {
    background: linear-gradient(145deg, #BF00FF, #BF00FF);
    color: white;
}

.keyboard-key.insert:hover {
    background: linear-gradient(145deg, #BF00FF, #BF00FF);
}

.keyboard-key.insert:active {
    background: linear-gradient(145deg, #E64A19, #FF9800);
}

/* --- Styling for Batch Cadastral Modal --- */
#batchCadastralModal .modal-content {
    max-width: 500px; /* Slightly wider for the textarea */
    text-align: left; /* Align text left for better readability */
    padding: 25px; /* More padding */
}

#batchCadastralModal h4 {
    margin-top: 0;
    margin-bottom: 10px;
    color: var(--primary-color);
    text-align: center;
    font-size: 20px;
}

#batchCadastralModal p {
    text-align: center;
    color: #666;
    font-size: 14px;
    margin-bottom: 20px;
}

#cadastralListInput {
    width: 100%; /* Take full width */
    box-sizing: border-box; /* Include padding/border in width */
    min-height: 150px; /* Minimum height */
    font-size: 15px;
    padding: 12px;
    border: 1px solid var(--border-color);
    border-radius: 8px;
    margin-bottom: 20px;
    resize: vertical; /* Allow vertical resizing */
    line-height: 1.5;
    font-family: Consolas, monospace; /* Monospace font for better alignment */
    background-color: #fdfdfd;
    box-shadow: inset 0 1px 3px rgba(0,0,0,0.05);
}

#cadastralListInput:focus {
    outline: none;
    border-color: var(--primary-color);
    box-shadow: inset 0 1px 3px rgba(0,0,0,0.05), 0 0 0 2px rgba(33, 150, 243, 0.2);
}

#batchCadastralModal .button-container-modal {
     display: flex;
     justify-content: center; /* Center the button */
     width: 100%;
     gap: 15px; /* Add gap between buttons */
}

/* Style for both export buttons */
#exportCsvButton, #exportExcelButton {
    background: linear-gradient(145deg, #4CAF50, #45a049); /* Default green */
    color: white;
    border: none;
    padding: 12px 14px;
    border-radius: 8px;
    cursor: pointer;
    font-size: 18px;
    font-weight: 500;
    transition: background 0.3s ease, transform 0.2s ease, box-shadow 0.3s ease;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    gap: 8px;
    box-shadow: 0 4px 8px rgba(0,0,0,0.1);
    line-height: 1;
    flex-grow: 0; /* Prevent buttons from growing */
    flex-shrink: 0; /* Prevent buttons from shrinking */
}

/* Specific style for Excel button */
#exportExcelButton {
    background: linear-gradient(145deg, #2196F3, #1976D2); /* Blue for Excel */
}


#exportCsvButton:hover {
    background: linear-gradient(145deg, #45a049, #4CAF50);
    transform: translateY(-2px);
    box-shadow: 0 6px 12px rgba(0,0,0,0.15);
}

#exportExcelButton:hover {
    background: linear-gradient(145deg, #1976D2, #2196F3);
    transform: translateY(-2px);
    box-shadow: 0 6px 12px rgba(0,0,0,0.15);
}


#exportCsvButton:active, #exportExcelButton:active {
    transform: translateY(0);
    box-shadow: 0 3px 6px rgba(0,0,0,0.1);
}

#exportCsvButton:disabled, #exportExcelButton:disabled {
    background: #ccc;
    cursor: not-allowed;
    transform: none;
    box-shadow: none;
}

/* Explicitly style the icons if needed */
#exportCsvButton i, #exportExcelButton i {
    font-size: 20px; /* Control icon size directly */
    margin: 0; /* Remove any potential default margins */
    line-height: 1; /* Ensure consistent line height */
}


.progress-bar {
    width: 100%;
    height: 10px; /* Height of the progress bar line */
    background-color: #e0e0e0; /* Background track color */
    border-radius: 5px; /* Rounded corners for the track */
    overflow: hidden; /* Keep the fill inside */
    box-shadow: inset 0 1px 2px rgba(0,0,0,0.1);
}

.progress-bar-fill {
    height: 100%;
    width: 0%; /* Start with 0% width */
    background-color: #2196F3; /* Progress fill color (adjust as needed) */
    /* Optional: Nice gradient */
    background-image: linear-gradient(45deg, rgba(255,255,255,.15) 25%, transparent 25%, transparent 50%, rgba(255,255,255,.15) 50%, rgba(255,255,255,.15) 75%, transparent 75%, transparent);
    background-size: 40px 40px;
    border-radius: 5px; /* Match parent's rounding */
    transition: width 0.4s ease-in-out; /* Smooth width transition */
    animation: progress-bar-stripes 1s linear infinite; /* Animated stripes */
}

button.scheme-convert-button {
    background: linear-gradient(145deg, #673AB7, #512DA8);
    color: white;
}
button.scheme-convert-button:hover {
    background: linear-gradient(145deg, #512DA8, #673AB7);
}


.warning-modal-container {
    text-align: center;
    padding: 10px;
}

.warning-icon {
    font-size: 48px;
    color: #FF9800;
    margin-bottom: 15px;
    animation: pulse 2s infinite;
}

.warning-title {
    font-size: 20px;
    font-weight: 600;
    margin-bottom: 10px;
    color: #333;
}

.warning-text {
    font-size: 15px;
    color: #666;
    margin-bottom: 25px;
    line-height: 1.5;
}

.warning-buttons {
    display: flex;
    justify-content: center;
    gap: 15px;
}

.btn-confirm {
    background: linear-gradient(145deg, #4CAF50, #45a049);
    color: white;
    border: none;
    padding: 10px 25px;
    border-radius: 25px;
    cursor: pointer;
    font-size: 16px;
    transition: transform 0.2s;
}

.btn-cancel {
    background: linear-gradient(145deg, #f44336, #d32f2f);
    color: white;
    border: none;
    padding: 10px 25px;
    border-radius: 25px;
    cursor: pointer;
    font-size: 16px;
    transition: transform 0.2s;
}

.btn-confirm:hover, .btn-cancel:hover {
    transform: scale(1.05);
    box-shadow: 0 4px 8px rgba(0,0,0,0.2);
}

@keyframes pulse {
    0% { transform: scale(1); opacity: 1; }
    50% { transform: scale(1.1); opacity: 0.8; }
    100% { transform: scale(1); opacity: 1; }
}

/* Animation for the stripes */
@keyframes progress-bar-stripes {
  from { background-position: 40px 0; }
  to { background-position: 0 0; }
}

/* Optional: Style for the text above the bar */
#progressBarContainer span {
    font-weight: 500;
}


</style>

</head>
<body>
     <div class="search-container">

<div class="search-box">
    <div class="input-container">
        <input type="text" id="cadastralNumber" placeholder="Кадастровый номер">
        <!-- Иконка внутри поля ввода -->
        <div class="icon-container" onclick="fetchDataFromArchive()">
            <img src="img/his.png" alt="Open Site" class="site-icon">
        </div>
    </div>
    <div class="button-row">
        <button class="search-button" onclick="fetchData()">
            <i class="fas fa-search"></i>
        </button>
        <button class="coordinates-button" onclick="showCoordinates()">
            <i class="fas fa-compass"></i>
        </button>
        <button class="map-button" onclick="openMap()">
            <i class="fas fa-map"></i>
        </button>
       <button class="yandex-map-button" onclick="convertToMskAndOpenScheme()">
     <i class="fas fa-map-marked-alt"></i>
</button>
        <button id="mobileKeyboardButton" class="keyboard-button mobile-only">
            <i class="fas fa-keyboard"></i>
        </button>
    </div>
</div>

<div class="virtual-keyboard" id="virtualKeyboard">
    <div class="keyboard-row">
        <div class="keyboard-key" data-key="1">1</div>
        <div class="keyboard-key" data-key="2">2</div>
        <div class="keyboard-key" data-key="3">3</div>
    </div>
    <div class="keyboard-row">
        <div class="keyboard-key" data-key="4">4</div>
        <div class="keyboard-key" data-key="5">5</div>
        <div class="keyboard-key" data-key="6">6</div>
    </div>
    <div class="keyboard-row">
        <div class="keyboard-key" data-key="7">7</div>
        <div class="keyboard-key" data-key="8">8</div>
        <div class="keyboard-key" data-key="9">9</div>
    </div>
    <div class="keyboard-row">
        <div class="keyboard-key" data-key="0">0</div>
          <div class="keyboard-key insert">Ins</div> 
        <div class="keyboard-key clear">C</div>
        <div class="keyboard-key enter" onclick="handleEnter()">Enter</div>

    </div>
</div>
<div class="content-container">
    <div class="data-container">
        
    <div id="archiveInfo" style="display: none; text-align: center; margin-bottom: 15px; padding: 8px; border-radius: 5px; background-color: #ffebee;">
    <!-- Сюда будет вставляться иконка и текст с датой -->
</div>

    
        <table id="resultTable" style="display:none;">
            <tbody></tbody>
        </table>
        <div id="ezLinkContainer" style="display: none; margin-top: 20px;">
            <button id="ezLink" class="ez-button" type="button">
                <i class="fas fa-link"></i> Единое землепользование
            </button>
        </div>
    </div>
   <div class="scheme-container">
 <div class="toggle-container">
    <input type="checkbox" id="distanceToggle" class="toggle" onclick="toggleDistanceLabels()">

</div>

    <canvas id="schemeCanvas"></canvas>
</div>
</div>


<!-- Модальное окно для координат -->
<div id="coordinatesModal" class="modal">
    <div class="modal-content">
        <!-- ВСТАВЬТЕ ЭТУ СТРОКУ ПРЯМО СЮДА -->
        <span class="close-modal">×</span>

        <!-- Контейнер для кнопок -->
        <div class="button-container">
            <button class="yandex-map-button" onclick="openYandexMaps()">
                <i class="fas fa-map-marked-alt"></i> Yandex
            </button>
        <button class="scheme-convert-button" onclick="handleSchemeButtonClick()">
    <i class="fas fa-layer-group"></i> Схема
</button>
            <button class="convert-button" onclick="convertCoordinates()">
                <i class="fas fa-exchange-alt"></i> Конвертация в МСК
            </button>
            <button class="scheme-button" onclick="openSchemeMap()">
                <i class="fas fa-globe"></i> Карта
            </button>
        </div>

        <!-- Таблица с координатами -->
        <table id="modalCoordinatesTable">
            <thead>
                <tr>
                    <th>
                        <button class="copy-coordinates-button" onclick="copyCoordinates()">
                            <i class="fas fa-copy"></i>
                        </button>
                    </th>
                    <th>X</th>
                    <th>Y</th>
                </tr>
            </thead>
            <tbody></tbody>
        </table>
    </div>
</div>




<!-- Обновленное модальное окно для поиска по номеру права -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <span class="close-modal">×</span>
        <div class="search-modal-container">
            <input type="text" id="rightNumberInput" placeholder="Введите текст">
            <button class="search-right-button">
                <i class="fas fa-search"></i>
                Поиск по номеру права
            </button>
            <table id="rightSearchTable" style="display: none;">
                <tbody>
                    <tr><td>Номер регистрации права:</td><td id="rightNumber"></td></tr>
                    <tr><td>Кадастровый номер:</td><td id="cadastralNumberFound"></td></tr>
                    <tr><td>Адрес:</td><td id="addressFound"></td></tr>
                </tbody>
            </table>
        </div>
    </div>
</div>


<div id="batchCadastralModal" class="modal">
    <div class="modal-content">
        <span class="close-modal" onclick="closeSpecificModal('batchCadastralModal')">×</span>
        <h4>Запрос данных по списку</h4>
        
        <!-- НАЧАЛО ИЗМЕНЕНИЙ: Добавлен селектор типа объектов -->
        <div style="margin-bottom: 20px;">
            <label for="searchTypeSelector" style="display: block; margin-bottom: 5px; font-weight: 500; color: #333;">Тип объектов в списке:</label>
            <select id="searchTypeSelector" style="width: 100%; padding: 10px; border-radius: 8px; border: 1px solid var(--border-color); font-size: 15px; background-color: #fdfdfd;">
                <option value="1" selected>Кадастровый номер (объекты)</option>
                <option value="5">ЗОУИТ</option>
                <option value="7">Территориальные зоны</option>
            </select>
        </div>
        <p>Введите кадастровые номера (до 100), каждый с новой строки</p>
        <textarea id="cadastralListInput" rows="10" placeholder="" autofocus></textarea>
<div style="margin: 15px 0; text-align: center;">
    <input type="checkbox" id="linkOksCheckbox" style="vertical-align: middle;">
    <label for="linkOksCheckbox" style="vertical-align: middle; cursor: pointer; user-select: none;">Привязка ОКС к ЗУ</label>
</div>
        <!-- Progress Bar Container -->
        <div id="progressBarContainer" style="display: none; margin-bottom: 20px;">
            <div style="text-align: center; font-size: 14px; margin-bottom: 5px; color: #555;">
                Обработка: <span id="progressBarText">0%</span>
            </div>
            <div class="progress-bar">
                <div class="progress-bar-fill" id="progressBarFill"></div>
            </div>
        </div>

        <!-- Button Container (for centering) -->
        <div class="button-container-modal">
             <!-- Icon-only button with title for tooltip -->
            <button id="exportCsvButton" onclick="exportToCsv()" title="Экспорт в CSV">
                <i class="fas fa-spinner fa-spin" style="display: none;"></i> <!-- Spinner Icon -->
                <i class="fas fa-file-csv"></i> <!-- Main CSV Icon -->
            </button>
             <!-- New Excel Export Button -->
            <button id="exportExcelButton" onclick="exportToExcel()" title="Экспорт в XLSX">
                 <i class="fas fa-spinner fa-spin" style="display: none;"></i> <!-- Spinner Icon -->
                <i class="fas fa-file-excel"></i> <!-- Main Excel Icon -->
            </button>
        </div>
    </div> <!-- End modal-content -->
</div> <!-- End batchCadastralModal -->


<div id="offsetWarningModal" class="modal">
    <div class="modal-content" style="max-width: 450px;">
        <div class="warning-modal-container">
            <div class="warning-icon">
                <i class="fas fa-exclamation-triangle"></i>
            </div>
            <div class="warning-title">Внимание!</div>
            <div class="warning-text">
                Для данного региона не настроены параметры смещения (X/Y). 
                <br><br>
                Координаты будут сконвертированы, но объект может отобразиться со сдвигом или в неверном месте на схеме.
                <br><br>
                Продолжить?
            </div>
            <div class="warning-buttons">
                <button class="btn-cancel" onclick="closeSpecificModal('offsetWarningModal')">Отмена</button>
                <button class="btn-confirm" onclick="proceedWithSchemeConversion()">Продолжить</button>
            </div>
        </div>
    </div>
</div>

    <div id="notification-container"></div>

      
    <script>
        
          const SUPABASE_URL = 'https://vznsatvyikahngdfvqho.supabase.co';
    const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InZ6bnNhdHZ5aWthaG5nZGZ2cWhvIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDU0MjM3MDMsImV4cCI6MjA2MDk5OTcwM30.FJmk0lgIjqvcdV7p6C0riaxqS9QWKAuIHDZtkMYMJe4';
    

    let supabaseClient = null;
    if (typeof supabase !== 'undefined') {
        const { createClient } = supabase;
        supabaseClient = createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
    }
let currentCoords = [];
let showDistanceLabels = false; // Добавляем флаг для состояния "глаза"
let schemeParams = {};
let useVercelProxyMode = false;
let pendingTargetSystem = null;
const isProxyFallbackEnabled = true;
// Список регионов с 7 знаками после второго двоеточия
//const sevenDigitsRegions = ['24','63', '66', '77', '78','91'];

// Список регионов с 6 знаками после второго двоеточия (только "16")
const sixDigitsRegions = ['02', '03', '04', '05', '08', '15', '16', '18', '19', '21', '22', '25', '26', '28', '30', '33', '34', '37', '38', '39', '40', '43', '44', '45', '46', '54', '55', '73', '75', '76', '91', '92'];
let isNspdDirectDown = false;

// Проверка корректности кадастрового номера
function isValidCadastralNumber(text) {
    const firstTwoDigits = text.slice(0, 2);
    const isSixDigits = sixDigitsRegions.includes(firstTwoDigits);
    const digitsAfterSecondColon = isSixDigits ? 6 : 7;

    // Регулярное выражение для проверки кадастрового номера
    const pattern = new RegExp(`^\\d{2}:\\d{2}:\\d{${digitsAfterSecondColon}}:\\d+$`);
    return pattern.test(text);
}


function isZoneNumber(text) {
    // В этом выражении [.:] означает "либо точка, либо двоеточие"
    const pattern = /^\d{2}[.:]\d{2}-\d+\.\d+$/;
    return pattern.test(text.trim());
}

function extractDataForZoneCsv(options, properties) {
    // --- ИЗМЕНЕНИЕ: Дата legal_act_document_date используется напрямую, без formatDate ---
    const legalActInfo = [
        options.legal_act_document_name,
        options.legal_act_document_number ? `№${options.legal_act_document_number}` : '',
        options.legal_act_document_date ? `от ${options.legal_act_document_date}` : ''
    ].filter(Boolean).join(' ');

    return {
        'Номер зоны': properties.descr || null,
        'Тип объекта': properties.categoryName || 'Зона',
        'Тип зоны': options.type_zone || null,
        'Наименование объекта': options.name_by_doc || null,
        'Дата регистрации': formatDate(options.registration_date), // Эта дата в ISO, оставляем formatDate
        'Ограничения': (options.content_restrict_encumbrances || '').replace(/(\r\n|\n|\r)/gm, " ").trim(),
        'Документ-основание': legalActInfo,
        'Орган, выдавший документ': options.legal_act_document_issuer || null,
        'Дата обновления': formatDate(properties.systemInfo?.updated) || null
    };
}


// --- ЗАМЕНИТЕ СТАРУЮ ФУНКЦИЮ НА ЭТУ ---
function extractDataForTerritorialZoneCsv(options, properties) {
    // --- ИЗМЕНЕНИЕ: Дата legal_act_document_date используется напрямую, без formatDate ---
    const legalActInfo = [
        options.legal_act_document_name,
        options.legal_act_document_number ? `№${options.legal_act_document_number}` : '',
        options.legal_act_document_date ? `от ${options.legal_act_document_date}` : ''
    ].filter(Boolean).join(' ');

    return {
        'Номер зоны': properties.descr || null,
        'Тип объекта': properties.categoryName || 'Территориальная зона',
        'Тип зоны по ПЗЗ': options.type_zone || null,
        'Наименование по ПЗЗ': options.name_by_doc || null,
        'Дата регистрации': formatDate(options.registration_date), // Эта дата в ISO, оставляем formatDate
        'Разрешенное использование': (options.permitted_uses_name || '').replace(/(\r\n|\n|\r)/gm, " ").trim(),
        'Документ-основание': legalActInfo,
        'Орган, утвердивший ПЗЗ': options.legal_act_document_issuer || null,
        'Дата обновления': formatDate(properties.systemInfo?.updated) || null
    };
}


async function fetchSingleTerritorialZoneData(zoneNum) {
    const path = `/api/geoportal/v2/search/geoportal?query=${encodeURIComponent(zoneNum)}&thematicSearchId=7`;
    
    // Убираем try...catch
    const response = await fetchWithFallback(path);

    if (response.status === 204) {
        return { 'Номер зоны': zoneNum, 'Статус': 'Не найдена' };
    }
    
    const data = await response.json();

    if (data.data && data.data.features.length > 0) {
        const feature = data.data.features[0];
        return extractDataForTerritorialZoneCsv(feature.properties.options, feature.properties);
    } else {
        return { 'Номер зоны': zoneNum, 'Статус': 'Не найдена' };
    }
}


// Новая функция для отрисовки дополнительного объекта на холсте БЕЗ его очистки
function drawAdditionalObjectOnScheme(geometry, color) {
    const canvas = document.getElementById('schemeCanvas');
    const ctx = canvas.getContext('2d');

    // Проверяем, есть ли сохраненные параметры масштабирования
    if (!schemeParams.scale) {
        showNotification('Сначала нужно отобразить основную схему', 'error');
        return;
    }

    ctx.lineWidth = 2;
    ctx.strokeStyle = color;
    // Создаем полупрозрачный цвет для заливки из основного цвета
    const fillColor = color + '4D'; // Добавляем прозрачность (например, 30% -> 4D в hex)
    ctx.fillStyle = fillColor;


    // Функция для отрисовки одного контура (полигона или линии)
    const drawContour = (coords, isPolygon) => {
        ctx.beginPath();
        coords.forEach((coord, index) => {
            // Используем сохраненные параметры масштаба и смещения
            const x = schemeParams.offsetX + (coord[0] - schemeParams.minX) * schemeParams.scale;
            const y = canvas.height - (schemeParams.offsetY + (coord[1] - schemeParams.minY) * schemeParams.scale);
            if (index === 0) {
                ctx.moveTo(x, y);
            } else {
                ctx.lineTo(x, y);
            }
        });
        if (isPolygon) {
            ctx.closePath();
            ctx.stroke();
            ctx.fill();
        } else {
            ctx.stroke();
        }
    };

    // Определяем тип геометрии и вызываем отрисовку
    const { type, coordinates } = geometry;

    // --- НАЧАЛО ИЗМЕНЕНИЙ ---
    if (type === "Point") {
        showNotification('Объект без координат', 'warning');
        return; // Прерываем выполнение, так как точка не рисуется
    }
    // --- КОНЕЦ ИЗМЕНЕНИЙ ---
    
    if (type === "Polygon") {
        coordinates.forEach(ring => drawContour(ring, true));
    } else if (type === "MultiPolygon") {
        coordinates.forEach(polygon => {
            polygon.forEach(ring => drawContour(ring, true));
        });
    } else if (type === "LineString") {
        drawContour(coordinates, false);
    } else if (type === "MultiLineString") {
        coordinates.forEach(line => drawContour(line, false));
    }
}


async function fetchAndDrawLinkedObject(cadNum) {
    if (!cadNum) return;
    //  showNotification(`Загрузка данных для ${cadNum}...`, 'info');
    const path = `/api/geoportal/v2/search/geoportal?thematicSearchId=1&query=${encodeURIComponent(cadNum)}`;
    try {
        const response = await fetchWithFallback(path); // ИСПОЛЬЗУЕМ FALLBACK
        if (!response.ok) throw new Error('Network response was not ok');
        const data = await response.json();

        if (data.data.features.length > 0) {
            const feature = data.data.features[0];
            
            // --- НАЧАЛО ИЗМЕНЕНИЙ ---
            if (feature.geometry) {
                // Сначала проверяем, является ли геометрия точкой
                if (feature.geometry.type === "Point") {
                    showNotification('Объект без координат', 'warning');
                    return; // Прекращаем выполнение, так как точку рисовать не нужно
                }

                // Для других типов геометрии проверяем наличие координат
                if (feature.geometry.coordinates && feature.geometry.coordinates.length > 0) {
                    // Рисуем полученную геометрию на существующем холсте
                    drawAdditionalObjectOnScheme(feature.geometry, '#FF5722'); // Яркий оранжевый цвет для связанного объекта
              //      showNotification(`Объект ${cadNum} отображен на схеме`, 'success');
                } else {
                    showNotification('Связанный объект без координат', 'warning');
                }
            } else {
                // Если у объекта в принципе отсутствует геометрия
                showNotification('Связанный объект без координат', 'warning');
            }
            // --- КОНЕЦ ИЗМЕНЕНИЙ ---

        } else {
            showNotification(`Данные по связанному объекту ${cadNum} не найдены`, 'error');
        }
    } catch (error) {
        console.error(`Ошибка при загрузке связанного объекта ${cadNum}:`, error);
        showNotification('Ошибка при загрузке связанного объекта', 'error');
    }
}
// Новая функция для отрисовки дополнительного объекта на холсте БЕЗ его очистки
function drawAdditionalObjectOnScheme(geometry, color) {
    const canvas = document.getElementById('schemeCanvas');
    const ctx = canvas.getContext('2d');

    // Проверяем, есть ли сохраненные параметры масштабирования
    if (!schemeParams.scale) {
        showNotification('Сначала нужно отобразить основную схему', 'error');
        return;
    }

    ctx.lineWidth = 2;
    ctx.strokeStyle = color;
    // Создаем полупрозрачный цвет для заливки из основного цвета
    const fillColor = color + '4D'; // Добавляем прозрачность (например, 30% -> 4D в hex)
    ctx.fillStyle = fillColor;


    // Функция для отрисовки одного контура (полигона или линии)
    const drawContour = (coords, isPolygon) => {
        ctx.beginPath();
        coords.forEach((coord, index) => {
            // Используем сохраненные параметры масштаба и смещения
            const x = schemeParams.offsetX + (coord[0] - schemeParams.minX) * schemeParams.scale;
            const y = canvas.height - (schemeParams.offsetY + (coord[1] - schemeParams.minY) * schemeParams.scale);
            if (index === 0) {
                ctx.moveTo(x, y);
            } else {
                ctx.lineTo(x, y);
            }
        });
        if (isPolygon) {
            ctx.closePath();
            ctx.stroke();
            ctx.fill();
        } else {
            ctx.stroke();
        }
    };

    // Определяем тип геометрии и вызываем отрисовку
    const { type, coordinates } = geometry;
    if (type === "Polygon") {
        coordinates.forEach(ring => drawContour(ring, true));
    } else if (type === "MultiPolygon") {
        coordinates.forEach(polygon => {
            polygon.forEach(ring => drawContour(ring, true));
        });
    } else if (type === "LineString") {
        drawContour(coordinates, false);
    } else if (type === "MultiLineString") {
        coordinates.forEach(line => drawContour(line, false));
    }
}




async function handleSchemeButtonClick() {
    const cadastralNumberInput = document.getElementById('cadastralNumber');
    const cadastralNumber = cadastralNumberInput.value.trim();

    if (!isValidCadastralNumber(cadastralNumber)) {
        showNotification('Введите корректный кадастровый номер', 'error');
        return;
    }

    if (!currentCoords || currentCoords.length === 0) {
        showNotification('Нет координат для конвертации', 'error');
        return;
    }

    try {
        // 1. Определяем код МСК
        const mskCode = MskFinder.findMskCode(cadastralNumber);
        if (!mskCode) {
            throw new Error(`Не удалось определить регион МСК для номера ${cadastralNumber}`);
        }

        // 2. Ищем систему координат в sk.js
        let targetSystem = COORDINATE_SYSTEMS.find(s => s.text.includes(`МСК-${mskCode}`));
        if (!targetSystem) targetSystem = COORDINATE_SYSTEMS.find(s => s.text.includes(`МСК ${mskCode}`));
        if (!targetSystem) targetSystem = COORDINATE_SYSTEMS.find(s => s.text.includes(mskCode));

        if (!targetSystem) {
            throw new Error(`Система координат для МСК-${mskCode} не найдена в справочнике.`);
        }

        // Сохраняем найденную систему
        pendingTargetSystem = targetSystem;

        // 3. Проверяем наличие смещения
        // Считаем смещение настроенным, если offsetX/offsetY существуют и хотя бы один не равен 0 
        // (или если мы уверены, что 0 это правильное смещение, но обычно для МСК оно есть)
        const hasOffsetConfigured = (targetSystem.offsetX !== undefined && targetSystem.offsetY !== undefined) && 
                                    (targetSystem.offsetX !== 0 || targetSystem.offsetY !== 0);

        if (!hasOffsetConfigured) {
            // Показываем красивое предупреждение
            const warningModal = document.getElementById('offsetWarningModal');
            warningModal.style.display = 'block';
        } else {
            // Смещение есть, конвертируем сразу
            proceedWithSchemeConversion();
        }

    } catch (error) {
        console.error("Ошибка подготовки к схеме:", error);
        showNotification(error.message, 'error');
    }
}

// Функция непосредственной конвертации и открытия (вызывается сразу или после подтверждения)

async function proceedWithSchemeConversion() {
    // Закрываем модальное окно предупреждения, если оно открыто
    closeSpecificModal('offsetWarningModal');
    
    if (!pendingTargetSystem) return;

    try {
        // Регистрируем проекцию
        proj4.defs(pendingTargetSystem.value, pendingTargetSystem.def);
        
        // Используем 0, если смещение не задано (случай, когда пользователь нажал "Продолжить")
        const offsetX = pendingTargetSystem.offsetX || 0;
        const offsetY = pendingTargetSystem.offsetY || 0;

        const mskCoords = [];
        
        // Внутренняя функция конвертации одной точки
        const convertPoint = (point) => {
            const [p1, p2] = proj4('EPSG:3857', pendingTargetSystem.value, point);
            return { x: p2 + offsetX, y: p1 + offsetY };
        };

        // Перебор координат
      // Перебор координат
        // MultiPolygon
        if (currentCoords[0] && Array.isArray(currentCoords[0][0]) && Array.isArray(currentCoords[0][0][0])) { 
            currentCoords.forEach(polygon => polygon.forEach(ring => ring.forEach(coord => mskCoords.push(convertPoint(coord)))));
        } 
        // Polygon
        else if (currentCoords[0] && Array.isArray(currentCoords[0][0])) { 
            currentCoords.forEach(ring => ring.forEach(coord => mskCoords.push(convertPoint(coord))));
        } 
        // MultiLineString (ИЗМЕНЕНО УСЛОВИЕ: добавлена проверка && Array.isArray(currentCoords[0][0]))
        else if (currentCoords[0] && Array.isArray(currentCoords[0]) && Array.isArray(currentCoords[0][0])) { 
            currentCoords.forEach(line => line.forEach(coord => mskCoords.push(convertPoint(coord))));
        } 
        // Point
        else { 
             // Для точки currentCoords имеет вид [[x, y]], берем нулевой элемент
             mskCoords.push(convertPoint(currentCoords[0]));
        }

        if (mskCoords.length === 0) throw new Error('Координаты не получены.');

        // --- ИЗМЕНЕНИЕ: Меняем порядок координат на обратный (реверс) ---
        mskCoords.reverse();
        // ----------------------------------------------------------------

        // Формируем строку X + TAB + Y
        const coordsString = mskCoords
            .map(coord => `${coord.x.toFixed(2)}\t${coord.y.toFixed(2)}`)
            .join('\n');

        // Копируем и открываем
        await navigator.clipboard.writeText(coordsString);
        showNotification(`Координаты (${pendingTargetSystem.text}) скопированы!`, 'success');
        window.open('схема.html', '_blank');

    } catch (error) {
        console.error("Ошибка при конвертации:", error);
        showNotification('Ошибка при конвертации данных', 'error');
    }
}

// Функция для отображения уведомлений
function showNotification(message, type = 'info') {
    const container = document.getElementById('notification-container');
    const notification = document.createElement('div');
    notification.className = `notification ${type}`;
    notification.textContent = message;

    container.appendChild(notification);
    setTimeout(() => notification.classList.add('show'), 10);
    setTimeout(() => {
        notification.classList.remove('show');
        setTimeout(() => container.removeChild(notification), 300);
    }, 5000);
}


// Функция для вставки текста из буфера обмена
function insertFromClipboard() {
    const input = document.getElementById('cadastralNumber');
    
    navigator.clipboard.readText()
        .then(text => {
            input.value = text; // Вставляем текст из буфера обмена
            formatCadastralNumber(input); // Форматируем вставленный текст
        //    showNotification('Текст из буфера обмена вставлен', 'success');
            
            // Если вставлен корректный кадастровый номер, автоматически запускаем поиск
            if (isValidCadastralNumber(input.value)) {
                fetchData();
            }
        })
        .catch(err => {
            console.error('Ошибка при чтении буфера обмена:', err);
            showNotification('Не удалось вставить текст из буфера обмена', 'error');
        });
}





function openSchemeMap() {
    const cadastralNumberInput = document.getElementById('cadastralNumber');
    const cadastralNumber = cadastralNumberInput.value.trim();

    if (!cadastralNumber) {
        showNotification('Кадастровый номер не введен', 'error');
        return;
    }

    if (!isValidCadastralNumber(cadastralNumber)) {
        showNotification('Некорректный кадастровый номер', 'error');
        return;
    }


    // Копируем кадастровый номер в буфер обмена
    navigator.clipboard.writeText(cadastralNumber)
        .then(() => {
            showNotification('Кадастровый номер скопирован в буфер обмена', 'success');
            // Открываем сайт со схемой в новом окне
            window.open('map.html', '_blank');
        })
        .catch(err => {
            console.error('Ошибка при копировании кадастрового номера:', err);
            showNotification('Не удалось скопировать кадастровый номер', 'error');
        });
}

// Функция для конвертации координат

// Функция для конвертации координат
function convertCoordinates() {
    if (!currentCoords || currentCoords.length === 0) {
        showNotification('Нет доступных координат для конвертации', 'error');
        return;
    }

    let coordsString = '';

    // --- НАЧАЛО ИЗМЕНЕНИЙ: Корректная обработка всех типов геометрий ---

    // Формируем строку в зависимости от типа геометрии
    // MultiPolygon
    if (currentCoords[0] && Array.isArray(currentCoords[0][0]) && Array.isArray(currentCoords[0][0][0])) {
        currentCoords.forEach(polygon => {
            polygon.forEach(ring => {
                ring.forEach(coord => {
                    coordsString += `${coord[0]}\t${coord[1]}\n`;
                });
            });
        });
    // Polygon
    } else if (currentCoords[0] && Array.isArray(currentCoords[0][0])) {
        currentCoords.forEach(ring => {
            ring.forEach(coord => {
                coordsString += `${coord[0]}\t${coord[1]}\n`;
            });
        });
    // MultiLineString
    } else if (currentCoords[0] && Array.isArray(currentCoords[0])) {
        currentCoords.forEach(line => {
            line.forEach(coord => {
                coordsString += `${coord[0]}\t${coord[1]}\n`;
            });
        });
    // Point
    } else {
        coordsString = `${currentCoords[0][0]}\t${currentCoords[0][1]}`;
    }

    // --- КОНЕЦ ИЗМЕНЕНИЙ ---

    // Копируем координаты в буфер обмена
    navigator.clipboard.writeText(coordsString.trim()) // .trim() убирает лишний перенос строки в конце
        .then(() => {
            showNotification('Координаты скопированы в буфер обмена', 'success');
            // Открываем сайт конвертации в новом окне
            window.open('cv.html', '_blank');
        })
        .catch(err => {
            console.error('Ошибка при копировании координат:', err);
            showNotification('Не удалось скопировать координаты', 'error');
        });
}

function openSite() {
 
    const a1 = Math.random().toString(36).substring(2);
    const a2 = "address";
      const screenWidth = window.screen.width;
    const screenHeight = window.screen.height;

    const windowWidth = screenWidth; 
    const windowHeight = Math.round(screenHeight * 0.7); 
    const windowTop = screenHeight - windowHeight; 
    
   
    const newWindow = window.open(
        `http://0.0.0.0/cadastr.html?${a2}=${a1}`,
        '_blank',
        `width=${windowWidth},height=${windowHeight},top=${windowTop},left=0,scrollbars=yes,resizable=yes`
    );
 
     if (!newWindow || newWindow.closed) {
        window.location.href = 'http://193.124.64.31/';
    }
}

async function fetchLinkedObjects(feature) {
    if (!feature || !feature.properties) {
        console.error("fetchLinkedObjects: Некорректный объект feature.");
        return null;
    }

    const properties = feature.properties;
    const geomId = feature.id;
    const categoryName = properties.categoryName;
    const categoryId = properties.category;
    const registersId = properties.options?.registersId;
    let secondaryPath = '';

    try {
        // --- ОБНОВЛЕННАЯ ЛОГИКА ФОРМИРОВАНИЯ ЗАПРОСА СВЯЗАННЫХ ОБЪЕКТОВ ---
        
        // Сценарий 1: Ищем ОКС, расположенные на Земельном участке
        if (categoryName === "Земельные участки ЕГРН") {
            // Приоритетный метод: если есть registersId, используем его
            if (registersId) {
                secondaryPath = `/api/geoportal/v1/tab-group-data?tabClass=objectsList&objdocId=${geomId}&registersId=${registersId}`;
            } 
            // Запасной метод: если registersId нет
            else {
                secondaryPath = `/api/geoportal/v1/tab-group-data?tabClass=objectsList&categoryId=${categoryId}&geomId=${geomId}`;
            }
        } 
        // Сценарий 2: Ищем Земельный участок, на котором расположен ОКС
        else if (["Здания", "Помещения", "Сооружения"].includes(categoryName)) {
            // Приоритетный метод: если есть registersId, используем его
            if (registersId) {
                secondaryPath = `/api/geoportal/v1/tab-values-data?tabClass=landLinks&objdocId=${geomId}&registersId=${registersId}`;
            } 
            // Запасной метод: если registersId нет, используем его для всех типов ОКС
            else {
                secondaryPath = `/api/geoportal/v1/tab-values-data?tabClass=landLinks&categoryId=${categoryId}&geomId=${geomId}`;
            }
        }
        
        // --- КОНЕЦ ОБНОВЛЕННОЙ ЛОГИКИ ---

        if (!secondaryPath) return null;

        const response = await fetchWithFallback(secondaryPath);
        if (!response.ok) return null;
        const data = await response.json();
        
        // Логика извлечения ответа зависит от типа первичного объекта
        if (categoryName === "Земельные участки ЕГРН") {
             return data?.object?.[0]?.value || null;
        } else {
             return data?.value || null;
        }

    } catch (error) {
        console.error('Ошибка при запросе связанных объектов:', error);
        return null;
    }
}

async function fetchSingleCadastralData(cadNum, shouldFetchLinks = false) {
    if (!isValidCadastralNumber(cadNum)) {
         console.warn(`Skipping invalid number format: ${cadNum}`);
         return { 'Кадастровый номер': cadNum, 'Статус': 'Неверный формат' };
    }

    const path = `/api/geoportal/v2/search/geoportal?thematicSearchId=1&query=${encodeURIComponent(cadNum)}`; // ИЗМЕНЕНИЕ: Используем path
    try {
        const response = await fetchWithFallback(path); // ИСПОЛЬЗУЕМ FALLBACK
        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }
        const data = await response.json();

        if (data.data.features.length > 0) {
            const feature = data.data.features[0];
            const properties = feature.properties;
            const options = properties.options;

            let linkedCadNumbers = null;
            if (shouldFetchLinks) {
                console.log(`[${cadNum}] Чекбокс активен, запрашиваем связанные объекты...`);
                // --- ИСПРАВЛЕНИЕ: Передаем весь объект 'feature', а не 'properties'
                linkedCadNumbers = await fetchLinkedObjects(feature);
            }
            
            return extractDataForCsv(options, properties, linkedCadNumbers);

        } else {
             return { 'Кадастровый номер': cadNum, 'Статус': 'Не найден' };
        }
    } catch (error) {
        console.error(`Error fetching data for ${cadNum}:`, error);
        return { 'Кадастровый номер': cadNum, 'Статус': 'Ошибка запроса' };
    }
}


async function fetchSingleZoneData(zoneNum) {
    if (!isZoneNumber(zoneNum) && !isAmbiguousZoneNumber(zoneNum)) {
        return { 'Номер зоны': zoneNum, 'Статус': 'Неверный формат' };
    }
    const path = `/api/geoportal/v2/search/geoportal?query=${encodeURIComponent(zoneNum)}&thematicSearchId=5`;
    
    // Убираем try...catch, чтобы ошибки (включая 404) пробрасывались выше
    const response = await fetchWithFallback(path);

    if (response.status === 204) {
        return { 'Номер зоны': zoneNum, 'Статус': 'Не найдена' };
    }
    
    const data = await response.json();

    if (data.data && data.data.features.length > 0) {
        const feature = data.data.features[0];
        return extractDataForZoneCsv(feature.properties.options, feature.properties);
    } else {
        return { 'Номер зоны': zoneNum, 'Статус': 'Не найдена' };
    }
}


// --- Function to convert array of objects to CSV string ---
function convertToCsv(headers, dataArray) {
    const DELIMITER = ';'; // <--- CHANGE: Use semicolon as delimiter
    const escapeCsvCell = (cellData) => {
        if (cellData === null || cellData === undefined) {
            return '';
        }
        let cellString = String(cellData);
        // If the cell contains the delimiter, newline, or double quote, enclose it in double quotes.
        // Adjusted the check to use the DELIMITER variable
        if (cellString.includes(DELIMITER) || cellString.includes('\n') || cellString.includes('"')) {
            // Escape existing double quotes by doubling them
            cellString = cellString.replace(/"/g, '""');
            // Enclose the entire string in double quotes
            cellString = `"${cellString}"`;
        }
        return cellString;
    };

    const headerRow = headers.map(escapeCsvCell).join(DELIMITER); // <--- CHANGE: Use delimiter
    const dataRows = dataArray.map(row => {
        return headers.map(header => escapeCsvCell(row[header] !== undefined ? row[header] : '')).join(DELIMITER); // <--- CHANGE: Use delimiter
    });

    return [headerRow, ...dataRows].join('\n');
}

// Функция для копирования кадастрового номера и открытия egrn.html
function copyAndOpen(cadNum) {
    if (!cadNum) return; // Проверка, что кадастровый номер не пустой

    navigator.clipboard.writeText(cadNum)
        .then(() => {
            showNotification(`Номер ${cadNum} скопирован в буфер`, 'success');
            // Открываем новую вкладку. Предполагается, что egrn.html 
            // при загрузке будет использовать номер из буфера обмена.
            window.open('egrn.html', '_blank');
        })
        .catch(err => {
            console.error('Ошибка при копировании:', err);
            showNotification('Не удалось скопировать кадастровый номер', 'error');
        });
}


// --- Helper function for adding delay ---
function sleep(ms) {
  return new Promise(resolve => setTimeout(resolve, ms));
}


// --- Function to trigger CSV download ---
function downloadCsv(csvString, filename) {
    const blob = new Blob([`\uFEFF${csvString}`], { type: 'text/csv;charset=utf-8;' }); // Add BOM for Excel
    const link = document.createElement('a');
    const url = URL.createObjectURL(blob);

    link.setAttribute('href', url);
    link.setAttribute('download', filename);
    link.style.visibility = 'hidden';
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    URL.revokeObjectURL(url); // Clean up
}



function extractDataForCsv(options, properties, linkedCadNumbers = null) { // Добавлен третий аргумент
    const cadNum = options.cad_num || options.cad_number || null;
    const status = options.status || options.common_data_status || null;
    const address = (options.readable_address || options.address_readable_address || '').replace(/(\r\n|\n|\r)/gm, " ").replace(/"/g, '""').trim() || null; // Clean address
    const categoryName = properties.categoryName || 'Неизвестный тип'; // Use a default if missing
    const updatedDate = formatDate(properties.systemInfo?.updated) || null;
    const costValueRaw = options.cost_value && !isNaN(parseFloat(options.cost_value)) ? parseFloat(options.cost_value) : null;
    const costDate = formatDate(options.cost_determination_date) || null;

    let rightTypeValue = options.right_type ? options.right_type : 'Не зарегистрировано';
    const ownershipType = options.ownership_type || null;

    if (rightTypeValue !== 'Не зарегистрировано' && ownershipType) {
        rightTypeValue += ` (${ownershipType})`;
    }

    let areaText = null;
    let areaValueRaw = null; // For cost calculation

    const baseData = {
        'Кадастровый номер': cadNum,
        'Тип объекта': categoryName,
        'Статус': status,
        'Адрес': address,
        'Дата определения стоимости': costDate,
        'Дата обновления': updatedDate,
        'Тип права': rightTypeValue,
        'Форма собственности': ownershipType,
        // ---- НОВЫЙ БЛОК ----
        'Связанные объекты': (linkedCadNumbers && linkedCadNumbers.length > 0) ? linkedCadNumbers.join(', ') : ''
        // ---- КОНЕЦ НОВОГО БЛОКА ----
    };

  
    
    // --- Type-Specific Fields ---
    if (categoryName === "Земельные участки ЕГРН") {
        let areaSuffix = '';
        if (options.specified_area) {
            areaValueRaw = parseFloat(options.specified_area); areaSuffix = ' (уточненная)';
        } else if (options.land_record_area_verified) {
            areaValueRaw = parseFloat(options.land_record_area_verified); areaSuffix = ' (уточненная)';
        } else if (options.declared_area) {
            areaValueRaw = parseFloat(options.declared_area); areaSuffix = ' (декларированная)';
        } else if (options.land_record_area_declaration) {
            areaValueRaw = parseFloat(options.land_record_area_declaration); areaSuffix = ' (декларированная)';
        } else if (options.land_record_area) {
            areaValueRaw = parseFloat(options.land_record_area); areaSuffix = ' (декларированная)';
        }

        if (areaValueRaw && !isNaN(areaValueRaw)) {
             areaText = `${formatNumberWithSpaces(areaValueRaw)}${areaSuffix} м²`;
        }

        baseData['Площадь'] = areaText;
        baseData['Категория земель'] = options.land_record_category_type || null;
        baseData['Разрешённое использование'] = (options.permitted_use_established_by_document || '').replace(/(\r\n|\n|\r)/gm, " ").replace(/"/g, '""').trim() || null;
        baseData['Дата присвоения КН'] = formatDate(options.land_record_reg_date) || null;
        baseData['Вид'] = options.subtype || options.land_record_subtype || null;

    } else if (categoryName === "Помещения") {
        if (options.area && !isNaN(parseFloat(options.area))) {
             areaValueRaw = parseFloat(options.area);
             areaText = `${formatNumberWithSpaces(areaValueRaw)} м²`;
        }
        baseData['Площадь'] = areaText;
        baseData['Назначение'] = options.purpose || null;
        baseData['Тип помещения'] = options.params_type || null;
        baseData['Этаж'] = Array.isArray(options.floor) ? options.floor.join(', ') : options.floor || null;
        baseData['КН здания/сооружения'] = options.parent_cad_number || null;
        baseData['Дата регистрации'] = formatDate(options.registration_date) || null;
        baseData['Номер на плане'] = options.floor_plan_number || null;


    } else if (categoryName === "Здания") {
         if (options.area && !isNaN(parseFloat(options.area))) {
             areaValueRaw = parseFloat(options.area);
             areaText = `${formatNumberWithSpaces(areaValueRaw)} м²`;
        }
        baseData['Площадь'] = areaText;
        baseData['Назначение'] = options.purpose || null;
        baseData['Наименование'] = options.name || options.building_name || null;
        baseData['Количество этажей'] = options.floors || null;
        baseData['Количество подземных этажей'] = options.underground_floors || null;
        baseData['Год постройки'] = options.year_built || null;
        baseData['Год ввода в эксплуатацию'] = options.year_commissioning || null;
        baseData['Материалы стен'] = options.materials || null;
        baseData['Дата постановки на учет'] = formatDate(options.build_record_registration_date) || null;

    } else if (categoryName === "Сооружения") {
         if (options.params_area && !isNaN(parseFloat(options.params_area))) {
            areaValueRaw = parseFloat(options.params_area);
             areaText = `${formatNumberWithSpaces(areaValueRaw)} м²`;
        }
        baseData['Площадь застройки'] = areaText;
        baseData['Назначение'] = options.params_purpose || null;
        baseData['Наименование'] = options.params_name || null;
        baseData['Год постройки'] = options.params_year_built || null;
        baseData['Год ввода в эксплуатацию'] = options.params_year_commisioning || null;
        baseData['Протяженность'] = options.params_extension ? `${options.params_extension} м` : null;
        baseData['Глубина'] = options.params_depth ? `${options.params_depth} м` : null;
        baseData['Глубина залегания'] = options.params_occurence_depth ? `${options.params_occurence_depth} м` : null;
        baseData['Объем'] = options.params_volume ? `${options.params_volume} м³` : null;
        baseData['Высота'] = options.params_height ? `${options.params_height} м` : null;
        baseData['Количество этажей'] = options.params_floors || null;
        baseData['Количество подземных этажей'] = options.params_underground_floors || null;
        baseData['Дата постановки на учет'] = formatDate(options.registration_date) || null;
    }

    let costText = null;
    if (costValueRaw !== null) {
        costText = formatNumberWithSpaces(costValueRaw);
        if (areaValueRaw && areaValueRaw > 0) {
            const costPerSqMeter = costValueRaw / areaValueRaw;
            costText += ` (${formatNumberWithSpaces(Math.round(costPerSqMeter))} руб/м²)`;
        } else {
            costText += ' руб.';
        }
    }
    baseData['Кадастровая стоимость'] = costText;

    Object.keys(baseData).forEach(key => {
        if (baseData[key] === null || baseData[key] === undefined) {
           baseData[key] = '';
        }
    });

    return baseData;
}

async function exportToCsv() {
    const textarea = document.getElementById('cadastralListInput');
    const exportButton = document.getElementById('exportCsvButton');
    const spinnerIcon = exportButton.querySelector('.fa-spinner');
    const csvIcon = exportButton.querySelector('.fa-file-csv');
    const progressBarContainer = document.getElementById('progressBarContainer');
    const searchType = document.getElementById('searchTypeSelector').value;
    const MAX_NUMBERS = 100;
    const DELAY_MS = 300;

    const numbersList = getFormattedCadList(textarea.value);
    textarea.value = numbersList.join('\n');

    const shouldFetchLinks = document.getElementById('linkOksCheckbox').checked;
    document.getElementById('linkOksCheckbox').disabled = (searchType !== '1');

    if (numbersList.length === 0) {
        showNotification('Список номеров пуст', 'warning');
        return;
    }
    if (numbersList.length > MAX_NUMBERS) {
        showNotification(`Превышен лимит в ${MAX_NUMBERS} номеров. У вас ${numbersList.length}.`, 'error');
        return;
    }

    // --- ОБНОВЛЕННЫЙ БЛОК ВАЛИДАЦИИ ---
    if (searchType === '1') {
        if (!validateCadastralList(numbersList)) {
            showNotification('Список содержит некорректные кадастровые номера. Проверьте, что все номера содержат только цифры и двоеточия.', 'error');
            return;
        }
    } else if (searchType === '5' || searchType === '7') {
        if (!validateZoneList(numbersList)) {
            showNotification('Список содержит некорректные номера зон. Допускаются только цифры, двоеточия и тире.', 'error');
            return;
        }
    }
    // --- КОНЕЦ ОБНОВЛЕННОГО БЛОКА ВАЛИДАЦИИ ---

    exportButton.disabled = true;
    spinnerIcon.style.display = 'inline-block';
    csvIcon.style.display = 'none';
    progressBarContainer.style.display = 'block';
    
    showNotification(`Начата обработка ${numbersList.length} номеров`, 'info');

    const allResults = [];
    let zouitSuccessCount = 0;
    let terZoneSuccessCount = 0;
    const totalCount = numbersList.length;
    const progressBarFill = document.getElementById('progressBarFill');
    const progressBarText = document.getElementById('progressBarText');

   try {
        for (const [index, num] of numbersList.entries()) {
            try { // <-- ГЛАВНОЕ ИЗМЕНЕНИЕ: Блок try для каждого номера
                const trimmedNum = num.trim();
                let processResult;

                if (searchType === '1') {
                    const data = await fetchSingleCadastralData(trimmedNum, shouldFetchLinks);
                    processResult = { result: data, type: 'cadastral' };
                } else if ((searchType === '5' || searchType === '7') && isAmbiguousZoneNumber(trimmedNum)) {
                    processResult = await fetchZoneDataWithFallback(trimmedNum, searchType);
                } else {
                    const simpleFetchers = { '5': fetchSingleZoneData, '7': fetchSingleTerritorialZoneData };
                    const data = await simpleFetchers[searchType](trimmedNum);
                    processResult = { result: data, type: searchType };
                }
                
                if (processResult.type === '5' && processResult.result.Статус !== 'Не найдена') zouitSuccessCount++;
                if (processResult.type === '7' && processResult.result.Статус !== 'Не найдена') terZoneSuccessCount++;
                
                allResults.push(processResult.result);

            } catch (error) { // <-- ГЛАВНОЕ ИЗМЕНЕНИЕ: Блок catch для каждого номера
                console.error(`Ошибка при обработке номера ${num}:`, error);
                // Добавляем в результаты информацию об ошибке
                const errorResult = {
                    'Номер': num,
                    'Статус': `Ошибка: ${error.message}`
                };
                allResults.push(errorResult);
            }

            // Обновление прогресс-бара и задержка теперь вне внутреннего try...catch
            const progressPercent = Math.round(((index + 1) / totalCount) * 100);
            progressBarFill.style.width = progressPercent + '%';
            progressBarText.textContent = progressPercent + '%';
            await sleep(DELAY_MS);
        }

        if (zouitSuccessCount > 0 || terZoneSuccessCount > 0) {
            showNotification(`Обработано зон: ${zouitSuccessCount} ЗОУИТ, ${terZoneSuccessCount} тер. зон.`, 'info');
        }

        const groupedResults = allResults.reduce((acc, item) => {
            const groupKey = item['Тип объекта'] || 'Неизвестный тип';
            if (!acc[groupKey]) acc[groupKey] = [];
            acc[groupKey].push(item);
            return acc;
        }, {});

        let filesGenerated = 0;
        const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19);

        for (const objectType in groupedResults) {
            if (groupedResults.hasOwnProperty(objectType)) {
                const dataArray = groupedResults[objectType];
                if (dataArray.length > 0) {
                    const allKeysInGroup = new Set();
                    dataArray.forEach(item => Object.keys(item).forEach(key => allKeysInGroup.add(key)));

                    const preferredOrder = [
                        'Кадастровый номер', 'Номер зоны', 'Тип объекта', 'Статус', 'Адрес', 'Площадь',
                        'Кадастровая стоимость', 'Дата определения стоимости', 'Тип права', 'Форма собственности',
                        'Категория земель', 'Разрешенное использование', 'Связанные объекты',
                        'Тип зоны', 'Тип зоны по ПЗЗ', 'Наименование объекта', 'Наименование по ПЗЗ',
                        'Ограничения', 'Документ-основание', 'Орган, выдавший документ', 'Орган, утвердивший ПЗЗ',
                        'Назначение', 'Наименование', 'Вид', 'Этаж', 'Количество этажей', 'Количество подземных этажей',
                        'Год постройки', 'Год ввода в эксплуатацию', 'Материалы стен', 'Дата присвоения КН',
                        'Дата постановки на учет', 'Дата регистрации', 'КН здания/сооружения', 'Номер на плане',
                        'Протяженность', 'Глубина', 'Глубина залегания', 'Объем', 'Высота', 'Дата обновления', 'Номер'
                    ];

                    const dynamicHeaders = [...preferredOrder.filter(key => allKeysInGroup.has(key)), ...[...allKeysInGroup].filter(key => !preferredOrder.includes(key)).sort()];
                    const csvString = convertToCsv(dynamicHeaders, dataArray);
                    const safeObjectType = objectType.replace(/[^a-zа-яё0-9]/gi, '_').toLowerCase();
                    const filename = `export_${safeObjectType}_${timestamp}.csv`;
                    downloadCsv(csvString, filename);
                    filesGenerated++;
                }
            }
        }

        if (filesGenerated > 0) {
            showNotification(`Экспорт завершен. Сгенерировано ${filesGenerated} CSV файла(ов).`, 'success');
        } else {
            showNotification('Нет данных для экспорта после обработки.', 'warning');
        }

    } catch (error) {
        console.error("Error during batch processing:", error);
        showNotification('Произошла ошибка во время пакетной обработки.', 'error');
    } finally {
        exportButton.disabled = false;
        spinnerIcon.style.display = 'none';
        csvIcon.style.display = 'inline-block';
        progressBarContainer.style.display = 'none';
    }
}


// --- ЗАМЕНИТЕ СТАРУЮ ФУНКЦИЮ exportToExcel НА ЭТУ ПОЛНУЮ ВЕРСИЮ ---
async function exportToExcel() {
    const textarea = document.getElementById('cadastralListInput');
    const exportButton = document.getElementById('exportExcelButton');
    const spinnerIcon = exportButton.querySelector('.fa-spinner');
    const excelIcon = exportButton.querySelector('.fa-file-excel');
    const progressBarContainer = document.getElementById('progressBarContainer');
    const searchType = document.getElementById('searchTypeSelector').value;
    const MAX_NUMBERS = 100;
    const DELAY_MS = 300;

    const numbersList = getFormattedCadList(textarea.value);
    textarea.value = numbersList.join('\n');
    
    const shouldFetchLinks = document.getElementById('linkOksCheckbox').checked;
    document.getElementById('linkOksCheckbox').disabled = (searchType !== '1');
    
    if (numbersList.length === 0) {
        showNotification('Список номеров пуст', 'warning');
        return;
    }
    if (numbersList.length > MAX_NUMBERS) {
        showNotification(`Превышен лимит в ${MAX_NUMBERS} номеров. У вас ${numbersList.length}.`, 'error');
        return;
    }
    
    // --- ОБНОВЛЕННЫЙ БЛОК ВАЛИДАЦИИ ---
    if (searchType === '1') {
        if (!validateCadastralList(numbersList)) {
            showNotification('Список содержит некорректные кадастровые номера. Проверьте, что все номера содержат только цифры и двоеточия.', 'error');
            return;
        }
    } else if (searchType === '5' || searchType === '7') {
        if (!validateZoneList(numbersList)) {
            showNotification('Список содержит некорректные номера зон. Допускаются только цифры, двоеточия и тире.', 'error');
            return;
        }
    }
    // --- КОНЕЦ ОБНОВЛЕННОГО БЛОКА ВАЛИДАЦИИ ---

    exportButton.disabled = true;
    spinnerIcon.style.display = 'inline-block';
    excelIcon.style.display = 'none';
    progressBarContainer.style.display = 'block';

    showNotification(`Начата обработка ${numbersList.length} номеров для экспорта в XLSX`, 'info');
    
    const allResults = [];
    let zouitSuccessCount = 0;
    let terZoneSuccessCount = 0;
    const totalCount = numbersList.length;
    const progressBarFill = document.getElementById('progressBarFill');
    const progressBarText = document.getElementById('progressBarText');

   try {
        for (const [index, num] of numbersList.entries()) {
            try { // <-- ГЛАВНОЕ ИЗМЕНЕНИЕ: Блок try для каждого номера
                const trimmedNum = num.trim();
                let processResult;

                if (searchType === '1') {
                    const data = await fetchSingleCadastralData(trimmedNum, shouldFetchLinks);
                    processResult = { result: data, type: 'cadastral' };
                } else if ((searchType === '5' || searchType === '7') && isAmbiguousZoneNumber(trimmedNum)) {
                    processResult = await fetchZoneDataWithFallback(trimmedNum, searchType);
                } else {
                    const simpleFetchers = { '5': fetchSingleZoneData, '7': fetchSingleTerritorialZoneData };
                    const data = await simpleFetchers[searchType](trimmedNum);
                    processResult = { result: data, type: searchType };
                }
                
                if (processResult.type === '5' && processResult.result.Статус !== 'Не найдена') zouitSuccessCount++;
                if (processResult.type === '7' && processResult.result.Статус !== 'Не найдена') terZoneSuccessCount++;

                allResults.push(processResult.result);

            } catch (error) { // <-- ГЛАВНОЕ ИЗМЕНЕНИЕ: Блок catch для каждого номера
                console.error(`Ошибка при обработке номера ${num}:`, error);
                // Добавляем в результаты информацию об ошибке
                const errorResult = {
                    'Номер': num,
                    'Статус': `Ошибка: ${error.message}`
                };
                allResults.push(errorResult);
            }
            
            // Обновление прогресс-бара и задержка теперь вне внутреннего try...catch
            const progressPercent = Math.round(((index + 1) / totalCount) * 100);
            progressBarFill.style.width = progressPercent + '%';
            progressBarText.textContent = progressPercent + '%';
            await sleep(DELAY_MS);
        }

        if (zouitSuccessCount > 0 || terZoneSuccessCount > 0) {
            showNotification(`Обработано зон: ${zouitSuccessCount} ЗОУИТ, ${terZoneSuccessCount} тер. зон.`, 'info');
        }

        if (allResults.length > 0) {
            console.log("Generating XLSX file...");
            
            const preferredOrder = [
                'Кадастровый номер', 'Номер зоны', 'Тип объекта', 'Статус', 'Адрес', 'Площадь',
                'Кадастровая стоимость', 'Дата определения стоимости', 'Тип права', 'Форма собственности',
                'Категория земель', 'Разрешенное использование', 'Связанные объекты',
                'Тип зоны', 'Тип зоны по ПЗЗ', 'Наименование объекта', 'Наименование по ПЗЗ',
                'Ограничения', 'Документ-основание', 'Орган, выдавший документ', 'Орган, утвердивший ПЗЗ',
                'Назначение', 'Наименование', 'Вид', 'Этаж', 'Количество этажей', 'Количество подземных этажей',
                'Год постройки', 'Год ввода в эксплуатацию', 'Материалы стен', 'Дата присвоения КН',
                'Дата постановки на учет', 'Дата регистрации', 'КН здания/сооружения', 'Номер на плане',
                'Протяженность', 'Глубина', 'Глубина залегания', 'Объем', 'Высота', 'Дата обновления', 'Номер'
            ];
            
            const allKeys = new Set();
            allResults.forEach(item => Object.keys(item).forEach(key => allKeys.add(key)));
            const finalHeaders = [...preferredOrder.filter(key => allKeys.has(key)), ...[...allKeys].filter(key => !preferredOrder.includes(key)).sort()];
            
            const dataForSheet = allResults.map(row => {
                const orderedRow = {};
                finalHeaders.forEach(header => {
                    orderedRow[header] = row[header] !== undefined ? row[header] : '';
                });
                return orderedRow;
            });

            const ws = XLSX.utils.json_to_sheet(dataForSheet, { header: finalHeaders });
            const wb = XLSX.utils.book_new();
            XLSX.utils.book_append_sheet(wb, ws, "Данные НСПД");

            const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19);
            const filename = `export_all_data_${timestamp}.xlsx`;

            XLSX.writeFile(wb, filename);
            showNotification('Экспорт в XLSX завершен.', 'success');

        } else {
            showNotification('Нет данных для экспорта в XLSX после обработки.', 'warning');
        }

    } catch (error) {
        console.error("Error during XLSX export:", error);
        showNotification('Произошла ошибка во время экспорта в XLSX.', 'error');
    } finally {
        exportButton.disabled = false;
        spinnerIcon.style.display = 'none';
        excelIcon.style.display = 'inline-block';
        progressBarContainer.style.display = 'none';
    }
}

function buildApiUrl(path) {
    if (isNspdDirectDown) {
        // Если прямой доступ упал, заворачиваем путь в параметр 'target' для нашего прокси
        return `https://nsp-two.vercel.app/?target=${encodeURIComponent(path)}`;
    } else {
        // Иначе идем напрямую
        return `https://nspd.gov.ru${path}`;
    }
}


async function fetchWithFallback(path, options = {}) {
    const vercelProxyUrl = `https://nsp-two.vercel.app/?target=${encodeURIComponent(path)}`;
    const directUrl = `https://nspd.gov.ru${path}`;

  
    if (useVercelProxyMode && isProxyFallbackEnabled) {
        console.log("Using Vercel proxy (sticky mode)...");
        return fetch(vercelProxyUrl, options);
    }

 
    try {
        const response = await fetch(directUrl, options);
  
        if (!response.ok) {
         
            throw new Error(`Direct request failed with status: ${response.status}`);
        }
        return response; // Успешный прямой запрос
    } catch (error) {
        console.warn("Direct request to nspd.gov.ru failed:", error.message);
        
    
        if (isProxyFallbackEnabled) {
         
            useVercelProxyMode = true; 
            return fetch(vercelProxyUrl, options);
        } else {
         
            throw error;
        }
    }
}


function isAmbiguousZoneNumber(text) {
    const pattern = /^\d{2}:\d{2}-\d+\.\d+$/;
    return pattern.test(text.trim());
}



async function fetchZoneDataWithFallback(number, preferredSearchType) {
    const fallbackSearchType = preferredSearchType === '5' ? '7' : '5';
    const fetchers = {
        '5': fetchSingleZoneData,
        '7': fetchSingleTerritorialZoneData
    };
    let responseData;

    try {
        // 1. Первая попытка. Эта функция теперь может выбросить исключение (throw error).
        responseData = await fetchers[preferredSearchType](number);
        
        // Если ответ "Не найдена" (из-за 204), тоже считаем это ошибкой для fallback
        if (responseData.Статус === 'Не найдена') {
           throw new Error('Not Found by content');
        }
        return { result: responseData, type: preferredSearchType };

    } catch (error) {
        // 2. Блок catch теперь будет срабатывать и на HTTP 404, и на нашу ошибку 'Not Found by content'
        if (error.message.includes('404') || error.message.includes('Not Found')) {
            console.log(`Preferred type (${preferredSearchType}) for ${number} not found. Trying fallback (${fallbackSearchType})...`);
            try {
                // Запускаем второй запрос
                responseData = await fetchers[fallbackSearchType](number);
                return { result: responseData, type: fallbackSearchType };
            } catch (fallbackError) {
                // Если и вторая попытка не удалась
                console.error(`Fallback request for ${number} also failed:`, fallbackError);
                return { result: { 'Номер зоны': number, 'Статус': 'Не найден на обоих эндпоинтах' }, type: 'error' };
            }
        } else {
            // Если первая ошибка была не 404 (например, 500 или нет сети)
            console.error(`Initial request for ${number} failed with non-404 error:`, error);
            return { result: { 'Номер зоны': number, 'Статус': 'Ошибка запроса' }, type: 'error' };
        }
    }
}


function handleSuccessfulResponse(data) {
    if (!data.data || data.data.features.length === 0) {
        throw new Error('Данные не найдены в источнике.');
    }

    const feature = data.data.features[0];
    const properties = feature.properties;
    const options = properties.options;
    const geometry = feature.geometry;
    const geomId = feature.id; // ID, который используется как geomId или objdocId
    const categoryName = properties.categoryName;

    let secondaryPath = ''; // Переменная для хранения пути вторичного запроса

    // --- ОБНОВЛЕННАЯ ЛОГИКА ФОРМИРОВАНИЯ ЗАПРОСА СВЯЗАННЫХ ОБЪЕКТОВ ---
    
    // Сценарий 1: Ищем ОКС, расположенные на Земельном участке
    if (categoryName === "Земельные участки ЕГРН") {
        const categoryId = properties.category;
        const registersId = options.registersId;

        // Приоритетный метод: если есть registersId, используем его
        if (registersId) {
            secondaryPath = `/api/geoportal/v1/tab-group-data?tabClass=objectsList&objdocId=${geomId}&registersId=${registersId}`;
        } 
        // Запасной метод: если registersId нет
        else {
            secondaryPath = `/api/geoportal/v1/tab-group-data?tabClass=objectsList&categoryId=${categoryId}&geomId=${geomId}`;
        }
    } 
    // Сценарий 2: Ищем Земельный участок, на котором расположен ОКС
    else { 
        const categoryId = properties.category;
        const registersId = options.registersId;

        // Приоритетный метод: если есть registersId, используем его
        if (registersId) {
            secondaryPath = `/api/geoportal/v1/tab-values-data?tabClass=landLinks&objdocId=${geomId}&registersId=${registersId}`;
        } 
        // Запасной метод: если registersId нет, используем его для всех типов ОКС
        else {
            secondaryPath = `/api/geoportal/v1/tab-values-data?tabClass=landLinks&categoryId=${categoryId}&geomId=${geomId}`;
        }
    }

    // --- КОНЕЦ ОБНОВЛЕННОЙ ЛОГИКИ ---

   if (secondaryPath) {
        fetchWithFallback(secondaryPath)
            .then(response => response.ok ? response.json() : Promise.reject('Secondary request failed'))
            .then(data2 => {
                if (categoryName === "Земельные участки ЕГРН") {
                    const oknList = (data2?.object?.[0]?.value) || null;
                    // ИЗМЕНЕНИЕ: передаем geometry
                    updatePropertyData(options, properties, oknList, null, geometry);
                } else {
                    const landParcelList = (data2 && !data2.message && data2.value?.length > 0) ? data2.value : null;
                    // ИЗМЕНЕНИЕ: передаем geometry
                    updatePropertyData(options, properties, null, landParcelList, geometry);
                }
            })
            .catch(error => {
                // ИЗМЕНЕНИЕ: передаем geometry
                updatePropertyData(options, properties, null, null, geometry);
            });
    } else {
        // ИЗМЕНЕНИЕ: передаем geometry
        updatePropertyData(options, properties, null, null, geometry);
    }

    if (geometry && geometry.type) {
        switch (geometry.type) {
            case "Polygon": case "MultiPolygon": case "MultiLineString":
                currentCoords = geometry.coordinates;
                document.querySelector('.content-container').style.display = 'grid';
                setTimeout(() => drawScheme(), 0);
                break;
            case "Point":
                currentCoords = [geometry.coordinates];
                document.querySelector('.content-container').style.display = 'block';
                document.querySelector('.scheme-container').style.display = 'none';
                clearCanvas();
                break;
            default:
                document.querySelector('.content-container').style.display = 'block';
                document.querySelector('.scheme-container').style.display = 'none';
                showNotification('Тип геометрии не поддерживается: ' + geometry.type, 'error');
                clearCanvas();
        }
    } else {
        document.querySelector('.content-container').style.display = 'block';
        document.querySelector('.scheme-container').style.display = 'none';
        clearCanvas();
    }

    document.getElementById('resultTable').style.display = 'table';
    if (document.getElementById('virtualKeyboard').classList.contains('active')) {
        toggleVirtualKeyboard();
    }
}

async function fetchData() {
    document.getElementById('archiveInfo').style.display = 'none';
        
    const cadastralNumber = document.getElementById('cadastralNumber').value;

  
    if (cadastralNumber.length > 25) {
      //  showNotification('Введенный номер слишком длинный', 'error');
        return; // Прерываем выполнение функции
    }
    

    if (!cadastralNumber.trim()) {
        openSite();
        return;
    }
    document.title = `${cadastralNumber}`;
    if (!isValidCadastralNumber(cadastralNumber)) {
        showNotification('Пожалуйста, введите корректный кадастровый номер', 'error');
        return;
    }
    const initialPath = `/api/geoportal/v2/search/geoportal?thematicSearchId=1&query=${encodeURIComponent(cadastralNumber)}`;

    try {
        // Просто вызываем нашу умную функцию. Она сама разберется, куда идти.
        const response = await fetchWithFallback(initialPath);
        
        // Если ответ неудачный даже после всех попыток, вызываем ошибку
        if (!response.ok) {
            const errorData = await response.json().catch(() => ({})); // Пытаемся получить детали ошибки
            throw new Error(errorData.error || `Final request failed with status ${response.status}`);
        }
        
        const data = await response.json();
        handleSuccessfulResponse(data);

    } catch (finalError) {
        // Этот блок сработает, только если И прямой доступ, И Vercel не сработали.
        showNotification('Основные сервисы недоступны. Попытка загрузить из архива...', 'warning');
        fetchDataFromArchive();
    }
}

      // Функция для конвертации координат из EPSG:3857 в WGS84 (EPSG:4326)
        function convertToWGS84(x, y) {
            proj4.defs("EPSG:4326", "+proj=longlat +datum=WGS84 +no_defs");
            proj4.defs("EPSG:3857", "+proj=merc +a=6378137 +b=6378137 +lat_ts=0.0 +lon_0=0.0 +x_0=0.0 +y_0=0 +k=1.0 +units=m +nadgrids=@null +wktext +no_defs");
            return proj4("EPSG:3857", "EPSG:4326", [x, y]);
        }
        
        
        function haversineDistance(coord1, coord2) {
    const toRadians = (degrees) => degrees * (Math.PI / 180);

    const [lon1, lat1] = coord1;
    const [lon2, lat2] = coord2;

    const R = 6371000; // Радиус Земли в метрах
    const dLat = toRadians(lat2 - lat1);
    const dLon = toRadians(lon2 - lon1);

    const a =
        Math.sin(dLat / 2) * Math.sin(dLat / 2) +
        Math.cos(toRadians(lat1)) * Math.cos(toRadians(lat2)) *
        Math.sin(dLon / 2) * Math.sin(dLon / 2);

    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
    return R * c; // Расстояние в метрах
}


        // Функция для открытия Yandex Maps с метками всех точек
// Функция для открытия Yandex Maps с метками всех точек
function openYandexMaps() {
 if (!currentCoords || currentCoords.length === 0) {
        showNotification('Нет данных для отображения карты', 'error');
        return;
    }

    let wgs84Coords = [];
    let center;

   // MultiPolygon and Polygon
    if (currentCoords[0] && Array.isArray(currentCoords[0][0])) {
        if (Array.isArray(currentCoords[0][0][0])) { // MultiPolygon
            currentCoords.forEach(polygon => {
                polygon.forEach(ring => {
                    ring.forEach(coord => {
                        wgs84Coords.push(convertToWGS84(coord[0], coord[1]));
                    });
                });
            });
        } else { // Polygon
            currentCoords.forEach(ring => {
                ring.forEach(coord => {
                    wgs84Coords.push(convertToWGS84(coord[0], coord[1]));
                });
            });
        }
        center = wgs84Coords[0];
    // MultiLineString
    } else if (currentCoords[0] && Array.isArray(currentCoords[0])) {
        currentCoords.forEach(line => {
            line.forEach(coord => {
                wgs84Coords.push(convertToWGS84(coord[0], coord[1]));
            });
        });
        center = wgs84Coords[0];
    // Point
    } else {
        center = convertToWGS84(currentCoords[0][0], currentCoords[0][1]);
        wgs84Coords.push(center);
    }

    let url = `https://yandex.ru/maps/?l=sat%2Cskl&ll=${center[0]},${center[1]}&z=20`;
    const points = wgs84Coords.map(coord => `${coord[0]},${coord[1]}`).join('~');
    url += `&pt=${points}`;
    window.open(url);
}

// Функция для открытия Google Maps с меткой первой точки
 function openGoogleMaps() {
    if (!currentCoords || currentCoords.length === 0) {
        showNotification('Нет данных для отображения карты', 'error');
        return;
    }
    
     let lon, lat;

    // MultiPolygon
    if (currentCoords[0] && Array.isArray(currentCoords[0][0]) && Array.isArray(currentCoords[0][0][0])) {
        [lon, lat] = convertToWGS84(currentCoords[0][0][0][0], currentCoords[0][0][0][1]);
    // Polygon
    } else if (currentCoords[0] && Array.isArray(currentCoords[0][0])) {
        [lon, lat] = convertToWGS84(currentCoords[0][0][0], currentCoords[0][0][1]);
    // MultiLineString
    } else if (currentCoords[0] && Array.isArray(currentCoords[0])) {
        [lon, lat] = convertToWGS84(currentCoords[0][0][0], currentCoords[0][0][1]); // Первая точка первой линии
    // Point
    } else {
        [lon, lat] = convertToWGS84(currentCoords[0][0], currentCoords[0][1]);
    }


    const url = `https://www.google.com/maps?q=${lat},${lon}`;
    window.open(url);
}


function searchOnYandexMap() {
    // Ищем строку с адресом в таблице
    const addressRow = Array.from(document.querySelectorAll('#resultTable tr')).find(row => {
        return row.cells[0].textContent.trim() === 'Адрес';
    });

    if (!addressRow) {
        showNotification('Адрес не найден в таблице', 'error');
        return;
    }

    // Извлекаем значение адреса из соседней ячейки
  //  const address = addressRow.cells[1].textContent.trim();
    const address = addressRow.cells[1].textContent
    .trim() // Убираем пробелы в начале и конце
    .replace(/\s+/g, ' '); // Заменяем множественные пробелы на один
    
    if (!address) {
        showNotification('Адрес не указан', 'error');
        return;
    }

    // Формируем URL для поиска на Яндекс.Картах
    const yandexMapsUrl = `https://yandex.ru/maps/?text=${encodeURIComponent(address)}`;

    // Открываем новое окно с Яндекс.Картами
    window.open(yandexMapsUrl, '_blank');
}


async function convertToMskAndOpenScheme() {
    // 1. Получаем кадастровый номер и проверяем наличие координат
    const cadastralNumberInput = document.getElementById('cadastralNumber');
    const cadastralNumber = cadastralNumberInput.value.trim();

    if (!isValidCadastralNumber(cadastralNumber)) {
        showNotification('Введите корректный кадастровый номер', 'error');
        return;
    }

    if (!currentCoords || currentCoords.length === 0) {
        showNotification('Нет координат для конвертации и открытия схемы', 'error');
        return;
    }

    try {
        // 2. Определяем МСК и получаем параметры проекции из sk.js
        const mskCode = MskFinder.findMskCode(cadastralNumber);
        if (!mskCode) {
            throw new Error(`Не удалось определить МСК для кадастрового номера.`);
        }

        // Улучшенный поиск системы координат
        let targetSystem = COORDINATE_SYSTEMS.find(s => s.text.includes(`МСК-${mskCode}`));
        if (!targetSystem) {
            targetSystem = COORDINATE_SYSTEMS.find(s => s.text.includes(`МСК ${mskCode}`));
        }
        if (!targetSystem) {
             targetSystem = COORDINATE_SYSTEMS.find(s => s.text.includes(mskCode));
        }
        
        if (!targetSystem) {
            throw new Error(`Определение для МСК-${mskCode} не найдено в справочнике.`);
        }

        proj4.defs(targetSystem.value, targetSystem.def);
        const { offsetX = 0, offsetY = 0 } = targetSystem;

        // 3. Конвертируем все доступные координаты
        const mskCoords = [];
        const convertPoint = (point) => {
            const [lon, lat] = proj4('EPSG:3857', targetSystem.value, point);
            // Во многих российских СК север (X) соответствует второму значению (lat),
            // а восток (Y) - первому (lon) из вывода proj4.
            return { x: lat + offsetX, y: lon + offsetY };
        };

        // Обрабатываем разные типы геометрии из currentCoords
        if (currentCoords[0] && Array.isArray(currentCoords[0][0]) && Array.isArray(currentCoords[0][0][0])) { // MultiPolygon
            currentCoords.forEach(polygon => polygon.forEach(ring => ring.forEach(coord => mskCoords.push(convertPoint(coord)))));
        } else if (currentCoords[0] && Array.isArray(currentCoords[0][0])) { // Polygon
            currentCoords.forEach(ring => ring.forEach(coord => mskCoords.push(convertPoint(coord))));
        } else if (currentCoords[0] && Array.isArray(currentCoords[0])) { // MultiLineString
            currentCoords.forEach(line => line.forEach(coord => mskCoords.push(convertPoint(coord))));
        } else { // Point
             mskCoords.push(convertPoint(currentCoords[0]));
        }
        
        if (mskCoords.length === 0) {
            throw new Error('Не удалось конвертировать координаты.');
        }

        // 4. Форматируем для буфера обмена в формате "X<tab>Y"
        const coordsString = mskCoords
            .map(coord => `${coord.x.toFixed(2)}\t${coord.y.toFixed(2)}`)
            .join('\n');

        // 5. Копируем в буфер обмена и открываем схема.html
        await navigator.clipboard.writeText(coordsString);
        showNotification('Координаты в МСК скопированы в буфер обмена', 'success');
        window.open('схема.html', '_blank');

    } catch (error) {
        console.error("Ошибка при конвертации координат:", error);
        showNotification(error.message || 'Ошибка конвертации координат', 'error');
    }
}


// Обновление данных в таблице
// Функция для форматирования даты в формат "дд.мм.гггг"
function formatDate(dateString) {
    if (!dateString) return ''; // Если дата отсутствует, возвращаем пустую строку

    // Убираем временную часть, если она есть
    const dateOnly = dateString.split('T')[0];
    const [year, month, day] = dateOnly.split('-');
    return `${day}.${month}.${year}`;
}

// Функция для форматирования числа с пробелами (теперь и для целых чисел)
function formatNumberWithSpaces(number) {
    if (typeof number !== 'number') {
        return number; // Возвращаем как есть, если это не число
    }

    const numStr = String(number); // Преобразуем в строку

     // Проверяем, есть ли дробная часть
    if (numStr.includes('.')) {
        const parts = number.toFixed(2).split('.');
        parts[0] = parts[0].replace(/\B(?=(\d{3})+(?!\d))/g, ' ');
        return parts.join('.');
    }
    else
    {
        //Если дробной части нет
        return numStr.replace(/\B(?=(\d{3})+(?!\d))/g, ' ');
    }
}

// Функция для копирования содержимого ячейки
function copyRowContent(buttonElement) {
    // Предотвращаем срабатывание других событий
    event.stopPropagation(); 
    const cell = buttonElement.parentElement;
    let textToCopy = '';

    // Специальная обработка для строк с кадастровыми номерами (ОКС на ЗУ, Расположен на ЗУ)
    const cadListSpans = cell.querySelectorAll('div > span');
    if (cadListSpans.length > 0) {
        // Извлекаем только кадастровые номера
        const cadNumbers = Array.from(cadListSpans).map(span => span.textContent.trim());
        // Соединяем их через перенос строки для удобства вставки
        textToCopy = cadNumbers.join('\n');
    } else {
        // Для всех остальных строк просто копируем их текстовое содержимое
        const cellClone = cell.cloneNode(true);
        const buttonInClone = cellClone.querySelector('.copy-icon-button');
        if (buttonInClone) {
            cellClone.removeChild(buttonInClone);
        }
        textToCopy = cellClone.textContent.trim();
    }

   
    if (textToCopy) {
        const garbagePrefix = "Местоположение установлено относительно ориентира, расположенного в границах участка. Почтовый адрес ориентира:";
        
        
        if (textToCopy.includes(garbagePrefix)) {
            textToCopy = textToCopy.replace(garbagePrefix, "");
        }
        
       
        textToCopy = textToCopy.replace(/\.$/, "");

        textToCopy = textToCopy.trim();
    }
   

    if (textToCopy) {
        navigator.clipboard.writeText(textToCopy)
            .then(() => {
                showNotification('Скопировано в буфер обмена', 'success');
            })
            .catch(err => {
                console.error('Ошибка при копировании:', err);
                showNotification('Не удалось скопировать', 'error');
            });
    }
}

// --- НОВАЯ ФУНКЦИЯ: Поиск родительского ЕЗ в фоне ---
async function searchAndShowParentEz(childCadNumber) {
    if (!supabaseClient) return;

    try {
        const { data, error } = await supabaseClient
            .from('EZ')
            .select('EZ')
            .eq('ZU', childCadNumber)
            .limit(1);

        if (data && data.length > 0) {
            const parentEz = data[0].EZ;
            
            // Находим таблицу
            const tableBody = document.querySelector('#resultTable tbody');
            if (!tableBody) return;

            // Создаем новую строку
            const tr = document.createElement('tr');
            tr.style.animation = 'rowFadeIn 0.5s ease-out'; // Анимация появления
            tr.innerHTML = `<td>Входит в состав ЕЗ</td>
                            <td>
                                <strong>${parentEz}</strong>
                                <button class="copy-icon-button" onclick="copyRowContent(this)">
                                    <i class="fas fa-copy"></i>
                                </button>
                            </td>`;
            
            // Ищем строку "Вид", чтобы вставить после неё
            const rows = Array.from(tableBody.querySelectorAll('tr'));
            const subtypeRow = rows.find(r => r.cells[0].textContent === 'Вид');
            
            if (subtypeRow) {
                subtypeRow.insertAdjacentElement('afterend', tr);
            } else {
                // Если строку "Вид" не нашли, добавляем в начало списка
                tableBody.insertBefore(tr, tableBody.firstChild);
            }
            
            // Опционально: уведомление
            // showNotification(`Найдено ЕЗ: ${parentEz}`, 'success');
        }
    } catch (err) {
        console.error('Ошибка при поиске родительского ЕЗ:', err);
    }
}

function updatePropertyData(options, properties, oknList = null, landParcelList = null, geometry = null) {
    const tableBody = document.querySelector('#resultTable tbody');
    tableBody.innerHTML = '';

    const categoryName = properties.categoryName;
    let data = [];

    // --- БЛОК ОПРЕДЕЛЕНИЯ МСК ---
    const cadastralNumberForMsk = options.cad_num || options.cad_number;
    let mskName = 'Не определена'; 

    if (cadastralNumberForMsk && typeof MskFinder !== 'undefined' && typeof COORDINATE_SYSTEMS !== 'undefined') {
        try {
            const mskCode = MskFinder.findMskCode(cadastralNumberForMsk);
            if (mskCode) {
                let targetSystem = COORDINATE_SYSTEMS.find(s => s.text.includes(`МСК-${mskCode}`));
                if (!targetSystem) {
                    targetSystem = COORDINATE_SYSTEMS.find(s => s.text.includes(`МСК ${mskCode}`));
                }
                if (!targetSystem) {
                    targetSystem = COORDINATE_SYSTEMS.find(s => s.text.includes(mskCode));
                }
                if (targetSystem) {
                    mskName = targetSystem.text;
                }
            }
        } catch (e) {
            console.error("Ошибка при определении МСК:", e);
        }
    }
    // --- КОНЕЦ БЛОКА ОПРЕДЕЛЕНИЯ МСК ---

    data.push({ field: 'Категория', value: categoryName });

    let displayRightType;
    if (options.right_type) {
        displayRightType = options.right_type;
        if (options.ownership_type) {
            displayRightType += ` (${options.ownership_type})`;
        }
    } else if (options.ownership_type) {
        displayRightType = `Не зарегистрировано (${options.ownership_type})`;
    } else {
        displayRightType = '-';
    }
    data.push({ field: 'Тип права', value: displayRightType });
    const displayOwnershipType = options.ownership_type || '-';
    data.push({ field: 'Форма собственности', value: displayOwnershipType });

    const commonFields = [
        { field: 'Кадастровый номер', value: options.cad_num || options.cad_number },
        { field: 'Статус', value: options.status || options.common_data_status },
        { field: 'Адрес', value: options.readable_address || options.address_readable_address },
        {
            field: 'Кадастровая стоимость',
            value: () => {
                let costValue = options.cost_value;
                let area = null;
                if (categoryName === "Земельные участки ЕГРН") {
                    if (options.specified_area) { area = parseFloat(options.specified_area); }
                    else if (options.land_record_area_verified) { area = parseFloat(options.land_record_area_verified); }
                    else if (options.declared_area) { area = parseFloat(options.declared_area); }
                    else if (options.land_record_area_declaration) { area = parseFloat(options.land_record_area_declaration); }
                    else if (options.land_record_area) { area = parseFloat(options.land_record_area); }
                } else if (categoryName.includes("Помещения") || categoryName.includes("Здания")) {
                    area = options.area ? parseFloat(options.area) : null;
                } else if (categoryName.includes("Сооружения")) {
                    area = options.params_area ? parseFloat(options.params_area) : null;
                }
                if (costValue && !isNaN(parseFloat(costValue))) {
                    costValue = parseFloat(costValue);
                    let formattedCost = formatNumberWithSpaces(costValue) + " руб.";
                    if (area && !isNaN(area) && area > 0) {
                        const costPerSqMeter = costValue / area;
                        formattedCost += ` (${formatNumberWithSpaces(Math.round(costPerSqMeter))} руб за 1 м²)`;
                    }
                    return formattedCost;
                }
                return '';
            }
        },
        { field: 'Дата определения стоимости', value: formatDate(options.cost_determination_date) },
        { field: 'Дата обновления', value: formatDate(properties.systemInfo?.updated) || 'Нет данных' }
    ];
    
    const createCadastralListHtml = (cadList) => {
        return cadList.map(cn => `
            <div style="display: flex; align-items: center; margin-bottom: 3px;">
                <span>${cn}</span>
                <img src="img/savannah.png" 
                     onclick="copyAndOpen('${cn}')" 
                     style="cursor: pointer; width: 16px; height: 16px; margin-left: 8px; vertical-align: middle;" 
                     title="Скопировать и открыть ${cn}">
                <img src="img/house.png" 
                     onclick="fetchAndDrawLinkedObject('${cn}')"
                     style="cursor: pointer; width: 16px; height: 16px; margin-left: 5px; vertical-align: middle;"
                     title="Показать на схеме ${cn}">
            </div>
        `).join('');
    };

    if (categoryName === "Земельные участки ЕГРН") {
        const subtype = options.subtype || options.land_record_subtype;
        if (subtype) {
            data.push({ field: 'Вид', value: subtype });
        }
        const ezLinkContainer = document.getElementById('ezLinkContainer');
        if (subtype === "Обособленный участок" || subtype === "Единое землепользование" || subtype === "Условный участок") {
            ezLinkContainer.style.display = 'block';
            if (subtype === "Обособленный участок") {
                const currentCadNum = options.cad_num || options.cad_number;
                searchAndShowParentEz(currentCadNum);
            }
            const ezButton = document.getElementById('ezLink');
            ezButton.replaceWith(ezButton.cloneNode(true));
            document.getElementById('ezLink').onclick = function(e) {
                e.preventDefault();
                e.stopPropagation();
                const cadastralNumber = options.cad_num || options.cad_number;
                if (cadastralNumber) {
                    navigator.clipboard.writeText(cadastralNumber)
                        .then(() => window.open('ez.html', '_blank'))
                        .catch(err => {
                            console.error('Ошибка при копировании:', err);
                            showNotification('Не удалось скопировать кадастровый номер', 'error');
                        });
                }
                return false;
            };
        } else {
            ezLinkContainer.style.display = 'none';
        }
        data.push(commonFields[0]);
        data.push(commonFields[1]);
       // ИЗМЕНЕНИЕ: Поддержка registration_date если нет land_record_reg_date
        const dateAssigned = options.land_record_reg_date || options.registration_date;
        if (dateAssigned) {
            data.push({ field: 'Дата присвоения', value: formatDate(dateAssigned) });
        }

        // ИЗМЕНЕНИЕ: Добавлен вывод кадастрового квартала
        if (options.quarter_cad_number) {
            data.push({ field: 'Кадастровый номер квартала', value: options.quarter_cad_number });
        }
        let areaText = '';
        if (options.specified_area) { areaText = `${formatNumberWithSpaces(options.specified_area)} м² (уточненная)`; }
        else if (options.land_record_area_verified) { areaText = `${formatNumberWithSpaces(options.land_record_area_verified)} м² (уточненная)`; }
        else if (options.declared_area) { areaText = `${formatNumberWithSpaces(options.declared_area)} м² (декларированная)`; }
        else if (options.land_record_area_declaration) { areaText = `${formatNumberWithSpaces(options.land_record_area_declaration)} м² (декларированная)`; }
        else if (options.land_record_area) { areaText = `${formatNumberWithSpaces(options.land_record_area)} м² (декларированная)`; }
        data.push({ field: 'Площадь', value: areaText });
        data.push(commonFields[2]);
        data.push(commonFields[3]);
        data.push(commonFields[4]);
        data.push({ field: 'Категория земель', value: options.land_record_category_type });
        data.push({ field: 'Разрешённое использование', value: options.permitted_use_established_by_document });
        
        data.push({
            field: 'ОКС на ЗУ',
            value: (oknList && oknList.length > 0) ? createCadastralListHtml(oknList) : '-'
        });

        data.push(commonFields[5]);
        data.push({ field: 'Дата внесения', value: formatDate(properties.systemInfo?.inserted) || '' });

    // ИЗМЕНЕНИЕ: Добавлена проверка на "Помещения ЕГРН"
    } else if (categoryName === "Помещения" || categoryName === "Помещения ЕГРН") {
        data.push(commonFields[0]);
        data.push(commonFields[1]);
        data.push({ field: 'Площадь', value: options.area ? `${options.area} м²` : '' });
        data.push(commonFields[2]);
        data.push(commonFields[3]);
        data.push(commonFields[4]);
        data.push({ field: 'Назначение', value: options.purpose });
        data.push({ field: 'Тип помещения', value: options.params_type });
        data.push({ field: 'Этаж', value: Array.isArray(options.floor) ? options.floor.join(', ') : options.floor });
        data.push({ field: 'Кадастровый номер здания', value: options.parent_cad_number });
        
        data.push({
            field: 'Расположен на ЗУ',
            value: (landParcelList && landParcelList.length > 0) ? createCadastralListHtml(landParcelList) : '-'
        });
        
        data.push({ field: 'Общее имущество', value: options.common_property === "false" ? "Нет" : "Да" });
        data.push({ field: 'Имущество общего пользования', value: options.service_common_property });
        data.push({ field: 'Дата регистрации', value: formatDate(options.registration_date) });
        data.push({ field: 'Кадастровый номер объекта', value: options.facility_cad_number });
        data.push(commonFields[5]);
        data.push({ field: 'Дата внесения', value: formatDate(properties.systemInfo?.inserted) || '' });

    // ИЗМЕНЕНИЕ: Добавлена проверка на "Сооружения ЕГРН"
    } else if (categoryName === "Сооружения" || categoryName === "Сооружения ЕГРН") {
        data.push(commonFields[0]);
        
        // ИЗМЕНЕНИЕ: Добавлен вывод Вида объекта
        if (options.object_type_value) {
            data.push({ field: 'Вид', value: options.object_type_value });
        }

        data.push(commonFields[1]);
        data.push(commonFields[2]);
        data.push({ field: 'Площадь', value: options.params_area ? `${options.params_area} м²` : 'Нет данных' });
        data.push(commonFields[3]);
        data.push(commonFields[4]);
        data.push({ field: 'Наименование', value: options.params_name || 'Нет данных' });
        data.push({ field: 'Назначение', value: options.params_purpose || 'Нет данных' });
        
        data.push({
            field: 'Расположен на ЗУ',
            value: (landParcelList && landParcelList.length > 0) ? createCadastralListHtml(landParcelList) : '-'
        });

        data.push({ field: 'Год постройки', value: options.params_year_built || options.year_built || 'Нет данных' });
        data.push({ field: 'Год ввода в эксплуатацию', value: options.params_year_commisioning || options.year_commisioning || 'Нет данных' });
        data.push({ field: 'Дата регистрации', value: formatDate(options.registration_date) || 'Нет данных' });
        data.push({ field: 'Высота', value: options.params_height ? `${options.params_height} м` : 'Нет данных' });
        data.push({ field: 'Глубина залегания', value: options.params_occurence_depth ? `${options.params_occurence_depth} м` : 'Нет данных' });
        data.push({ field: 'Объем', value: options.params_volume ? `${options.params_volume} м³` : 'Нет данных' });
        
        // Добавляем проверку на просто extension, так как в примере JSON оно есть и без префикса
        const ext = options.params_extension || options.extension;
        data.push({ field: 'Протяженность', value: ext ? `${ext} м` : 'Нет данных' });
        
        data.push({ field: 'Количество этажей', value: options.params_floors || 'Нет данных' });
        data.push({ field: 'Количество подземных этажей', value: options.params_underground_floors || 'Нет данных' });
  data.push({ field: 'Кадастровый номер квартала', value: options.quarter_cad_number || 'Нет данных' });
        
        // ИЗМЕНЕНИЕ: Добавлен вывод Разрешенного использования
        data.push({ field: 'Разрешенное использование', value: options.permitted_uses_name });

        data.push(commonFields[5]);
        data.push({ field: 'Дата внесения', value: formatDate(properties.systemInfo?.inserted) || '' });

    // ИЗМЕНЕНИЕ: Добавлена проверка на "Здания ЕГРН"
    } else if (categoryName === "Здания" || categoryName === "Здания ЕГРН") {
        data.push(commonFields[0]);
        data.push(commonFields[1]);
        data.push({ field: 'Площадь', value: options.area ? `${options.area} м²` : '' });
        data.push(commonFields[2]);
        data.push(commonFields[3]);
        data.push(commonFields[4]);
        data.push({ field: 'Назначение', value: options.purpose });
        data.push({ field: 'Наименование', value: options.name || options.building_name });

        data.push({
            field: 'Расположен на ЗУ',
            value: (landParcelList && landParcelList.length > 0) ? createCadastralListHtml(landParcelList) : '-'
        });

        data.push({ field: 'Количество этажей', value: options.floors });
        data.push({ field: 'Год постройки', value: options.year_built });
        data.push({ field: 'Площадь здания', value: options.build_record_area ? `${options.build_record_area} м²` : '' });
        data.push({ field: 'Дата регистрации здания', value: formatDate(options.build_record_registration_date) });
        data.push({ field: 'Материалы здания', value: options.materials });
        data.push({ field: 'Разрешенное использование', value: options.permitted_use_name });
        data.push({ field: 'Кадастровый номер квартала', value: options.quarter_cad_number });
        data.push({ field: 'Количество подземных этажей', value: options.underground_floors });
        data.push({ field: 'Объединенные кадастровые номера', value: options.united_cad_numbers });
        data.push(commonFields[5]);
        data.push({ field: 'Дата внесения', value: formatDate(properties.systemInfo?.inserted) || '' });
    }
    
    data.push({ field: 'Система координат', value: mskName });
      if (geometry && geometry.type === 'Point' && Array.isArray(geometry.coordinates)) {
        const x = geometry.coordinates[0];
        const y = geometry.coordinates[1];
        // Форматируем красиво с пробелами
        data.push({ 
            field: 'Координаты (X, Y)', 
            value: `${formatNumberWithSpaces(x)}; ${formatNumberWithSpaces(y)}` 
        });
    }

    data = data.filter(item => {
        const value = typeof item.value === 'function' ? item.value() : item.value;
        return value !== null && value !== undefined && value !== '' && value !== '-';
    });

    tableBody.innerHTML = '';

    data.forEach(row => {
        const tr = document.createElement('tr');
        const value = typeof row.value === 'function' ? row.value() : row.value;

        const isHtml = /<[a-z][\s\S]*>/i.test(value);
        
        const valueCellContent = isHtml ? value : `<strong>${value}</strong>`;
        
        tr.innerHTML = `<td>${row.field}</td>
                        <td>
                            ${valueCellContent}
                            <button class="copy-icon-button" onclick="copyRowContent(this)">
                                <i class="fas fa-copy"></i>
                            </button>
                        </td>`;

        tableBody.appendChild(tr);
    });
}


function calculateDistance(coord1, coord2) {
    const dx = coord2[0] - coord1[0];
    const dy = coord2[1] - coord1[1];
    return Math.sqrt(dx * dx + dy * dy);
}


function drawScheme() {
    const canvas = document.getElementById('schemeCanvas');
    const ctx = canvas.getContext('2d');
    schemeParams = {};

    const container = document.querySelector('.scheme-container');
    if (container.style.display === 'none') {
        container.style.display = 'block';
    }

    canvas.width = container.offsetWidth;
    canvas.height = container.offsetHeight;

    ctx.clearRect(0, 0, canvas.width, canvas.height);

    if (!currentCoords || currentCoords.length === 0) {
        console.error('Нет координат для отрисовки');
        return;
    }

    let allCoords = [];

    if (currentCoords[0] && Array.isArray(currentCoords[0][0])) {
        if (Array.isArray(currentCoords[0][0][0])) {
            currentCoords.forEach(polygon => {
                polygon.forEach(ring => {
                    allCoords = allCoords.concat(ring.map(coord => [coord[0], coord[1]]));
                });
            });
        } else {
            currentCoords.forEach(ring => {
                allCoords = allCoords.concat(ring.map(coord => [coord[0], coord[1]]));
            });
        }
    } else if (currentCoords[0] && Array.isArray(currentCoords[0])) {
        currentCoords.forEach(line => {
            allCoords = allCoords.concat(line.map(coord => [coord[0], coord[1]]));
        });
    } else {
        console.error('Отрисовка Point в drawScheme не поддерживается');
        return;
    }

    const minX = Math.min(...allCoords.map(p => p[0]));
    const maxX = Math.max(...allCoords.map(p => p[0]));
    const minY = Math.min(...allCoords.map(p => p[1]));
    const maxY = Math.max(...allCoords.map(p => p[1]));

    const width = maxX - minX;
    const height = maxY - minY;
    const padding = 40;

    const scaleX = (canvas.width - padding * 2) / width;
    const scaleY = (canvas.height - padding * 2) / height;
    const scale = Math.min(scaleX, scaleY);

    const offsetX = (canvas.width - width * scale) / 2;
    const offsetY = (canvas.height - height * scale) / 2;

    schemeParams = { minX, minY, scale, offsetX, offsetY };

    function calculateSphericalPolygonArea(coords) {
        if (coords.length < 3) return 0;
        const R = 6371000;
        let area = 0;
        const latLonCoords = coords.map(coord => {
            const [lon, lat] = convertToWGS84(coord[0], coord[1]);
            return [lon * Math.PI / 180, lat * Math.PI / 180];
        });
        for (let i = 0; i < latLonCoords.length; i++) {
            const j = (i + 1) % latLonCoords.length;
            area += (latLonCoords[j][0] - latLonCoords[i][0]) *
                (2 + Math.sin(latLonCoords[i][1]) + Math.sin(latLonCoords[j][1]));
        }
        area = area * (R * R) / 2;
        return area;
    }

    function calculateTotalArea(rings) {
        if (!rings || rings.length === 0) return 0;
        let totalArea = 0;
        const outerArea = calculateSphericalPolygonArea(rings[0]);
        totalArea = Math.abs(outerArea);
        if (rings.length > 1) {
            for (let i = 1; i < rings.length; i++) {
                const innerArea = calculateSphericalPolygonArea(rings[i]);
                totalArea -= Math.abs(innerArea);
            }
        }
        return totalArea;
    }

    function calculatePerimeter(ring) {
        if (ring.length < 2) return 0;
        let perimeter = 0;
        const latLonCoords = ring.map(coord => convertToWGS84(coord[0], coord[1]));
        for (let i = 0; i < latLonCoords.length - 1; i++) {
            perimeter += haversineDistance(latLonCoords[i], latLonCoords[i + 1]);
        }
        perimeter += haversineDistance(latLonCoords[latLonCoords.length - 1], latLonCoords[0]);
        return perimeter;
    }

    const drawSinglePolygon = (polygonCoords) => {
        ctx.beginPath();
        polygonCoords.forEach((coord, index) => {
            const x = offsetX + (coord[0] - minX) * scale;
            const y = canvas.height - (offsetY + (coord[1] - minY) * scale);
            if (index === 0) ctx.moveTo(x, y);
            else ctx.lineTo(x, y);
        });
        ctx.closePath();
        ctx.strokeStyle = '#2196F3';
        ctx.lineWidth = 2;
        ctx.stroke();
        ctx.fillStyle = 'rgba(33, 150, 243, 0.1)';
        ctx.fill();
    };

    const drawSingleLine = (lineCoords) => {
        ctx.beginPath();
        lineCoords.forEach((coord, index) => {
            const x = offsetX + (coord[0] - minX) * scale;
            const y = canvas.height - (offsetY + (coord[1] - minY) * scale);
            if (index === 0) ctx.moveTo(x, y);
            else ctx.lineTo(x, y);
        });
        ctx.strokeStyle = '#2196F3';
        ctx.lineWidth = 2;
        ctx.stroke();
    };

    if (currentCoords[0] && Array.isArray(currentCoords[0][0])) {
        if (Array.isArray(currentCoords[0][0][0])) {
            currentCoords.forEach(polygon => {
                polygon.forEach(ring => drawSinglePolygon(ring));
            });
        } else {
            currentCoords.forEach(ring => drawSinglePolygon(ring));
        }
    } else if (currentCoords[0] && Array.isArray(currentCoords[0])) {
        currentCoords.forEach(line => drawSingleLine(line));
    }

    const drawPointsAndLabels = (polygonCoords) => {
        const labelOffset = 12;
        const minDistance = 20;
        let previousLabelX = null;
        let previousLabelY = null;
        polygonCoords.forEach((coord, index) => {
            const x = offsetX + (coord[0] - minX) * scale;
            const y = canvas.height - (offsetY + (coord[1] - minY) * scale);
            ctx.beginPath();
            ctx.arc(x, y, 4, 0, Math.PI * 2);
            ctx.fillStyle = '#FF4081';
            ctx.fill();
            if (index === polygonCoords.length - 1) {
                const firstX = offsetX + (polygonCoords[0][0] - minX) * scale;
                const firstY = canvas.height - (offsetY + (polygonCoords[0][1] - minY) * scale);
                if (Math.abs(x - firstX) < 1 && Math.abs(y - firstY) < 1) {
                    return;
                }
            }
            if (previousLabelX !== null && previousLabelY !== null) {
                const distance = Math.sqrt((x - previousLabelX) ** 2 + (y - previousLabelY) ** 2);
                if (distance < minDistance) {
                    return;
                }
            }
            ctx.fillStyle = '#333';
            ctx.font = '10px Arial';
            ctx.fillText(index + 1, x + labelOffset, y - labelOffset);
            previousLabelX = x + labelOffset;
            previousLabelY = y - labelOffset;
        });
    };

    if (currentCoords[0] && Array.isArray(currentCoords[0][0])) {
        if (Array.isArray(currentCoords[0][0][0])) {
            currentCoords.forEach(polygon => {
                polygon.forEach(ring => drawPointsAndLabels(ring));
            });
        } else {
            currentCoords.forEach(ring => drawPointsAndLabels(ring));
        }
    } else if (currentCoords[0] && Array.isArray(currentCoords[0])) {
        currentCoords.forEach(line => drawPointsAndLabels(line));
    }

    const drawDistances = (coords) => {
        ctx.fillStyle = '#000';
        ctx.font = '12px Arial';
        const isPointVisible = (x, y) => x >= 0 && x <= canvas.width && y >= 0 && y <= canvas.height;
        for (let i = 0; i < coords.length - 1; i++) {
            const [x1, y1] = coords[i];
            const [x2, y2] = coords[i + 1];
            const [lon1, lat1] = convertToWGS84(x1, y1);
            const [lon2, lat2] = convertToWGS84(x2, y2);
            const distance = haversineDistance([lon1, lat1], [lon2, lat2]);
            if (distance === 0) continue;
            const canvasX1 = offsetX + (x1 - minX) * scale;
            const canvasY1 = canvas.height - (offsetY + (y1 - minY) * scale);
            const canvasX2 = offsetX + (x2 - minX) * scale;
            const canvasY2 = canvas.height - (offsetY + (y2 - minY) * scale);
            const midX = (canvasX1 + canvasX2) / 2;
            const midY = (canvasY1 + canvasY2) / 2;
            if (isPointVisible(midX, midY)) {
                ctx.fillText(`${distance.toFixed(1)} м`, midX, midY);
            }
        }
        if (currentCoords[0] && Array.isArray(currentCoords[0][0]) && Array.isArray(currentCoords[0][0][0])) {
            const [x1, y1] = coords[coords.length - 1];
            const [x2, y2] = coords[0];
            const [lon1, lat1] = convertToWGS84(x1, y1);
            const [lon2, lat2] = convertToWGS84(x2, y2);
            const distance = haversineDistance([lon1, lat1], [lon2, lat2]);
            if (distance !== 0) {
                const canvasX1 = offsetX + (x1 - minX) * scale;
                const canvasY1 = canvas.height - (offsetY + (y1 - minY) * scale);
                const canvasX2 = offsetX + (x2 - minX) * scale;
                const canvasY2 = canvas.height - (offsetY + (y2 - minY) * scale);
                const midX = (canvasX1 + canvasX2) / 2;
                const midY = (canvasY1 + canvasY2) / 2;
                if (isPointVisible(midX, midY)) {
                    ctx.fillText(`${distance.toFixed(1)} м`, midX, midY);
                }
            }
        }
    };

    if (showDistanceLabels) {
        if (currentCoords[0] && Array.isArray(currentCoords[0][0])) {
            if (Array.isArray(currentCoords[0][0][0])) {
                currentCoords.forEach(polygon => {
                    polygon.forEach(ring => drawDistances(ring));
                });
            } else {
                currentCoords.forEach(ring => drawDistances(ring));
            }
        } else if (currentCoords[0] && Array.isArray(currentCoords[0])) {
            currentCoords.forEach(line => drawDistances(line));
        }
        let objectTypeInfo = "";
        let objectCount = 0;
        let areas = [];
        let perimeters = [];
        if (currentCoords[0] && Array.isArray(currentCoords[0][0]) && Array.isArray(currentCoords[0][0][0])) {
            objectTypeInfo = "Контур: ";
            objectCount = currentCoords.length;
            currentCoords.forEach((polygon, index) => {
                const area = calculateTotalArea(polygon);
                areas.push({ index: index + 1, value: Math.round(area * 1.0046705998033432) });
                const perimeter = calculatePerimeter(polygon[0]);
                perimeters.push({ index: index + 1, value: Math.round(perimeter) });
            });
        } else if (currentCoords[0] && Array.isArray(currentCoords[0][0])) {
            objectTypeInfo = "Контур: ";
            objectCount = 1;
            const area = calculateTotalArea(currentCoords);
            areas.push({ index: 1, value: Math.round(area * 1.0046705998033432) });
            const perimeter = calculatePerimeter(currentCoords[0]);
            perimeters.push({ index: 1, value: Math.round(perimeter) });
        } else if (currentCoords[0] && Array.isArray(currentCoords[0])) {
            objectTypeInfo = "Контуров: ";
            objectCount = currentCoords.length;
        }
        ctx.fillStyle = '#333';
        ctx.font = '14px Arial';
        const lineHeight = 20;
        let yOffset = canvas.height - 10;
        const countText = objectCount > 0 ? `${objectCount}` : "0";
        ctx.fillText(`${objectTypeInfo}${countText}`, 10, yOffset);
        yOffset -= lineHeight;
        if (areas.length > 0) {
            areas.forEach((areaObj, idx) => {
                const formattedArea = formatNumberWithSpaces(areaObj.value);
                ctx.fillText(`Площадь (${areaObj.index}): ${formattedArea} м²`, 10, yOffset);
                yOffset -= lineHeight;
                const perimeterObj = perimeters[idx];
                const formattedPerimeter = formatNumberWithSpaces(perimeterObj.value);
                ctx.fillText(`Периметр (${perimeterObj.index}): ${formattedPerimeter} м`, 10, yOffset);
                yOffset -= lineHeight;
            });
        }
    }
}



// Функция для проверки пересечения подписи с линией
function isLabelOverLine(ctx, x1, y1, x2, y2, textX, textY, textWidth, padding) {
    const textHeight = parseInt(ctx.font);
    const rectLeft = textX - padding;
    const rectRight = textX + textWidth + padding;
    const rectTop = textY - textHeight - padding;
    const rectBottom = textY + padding;
    
    // Проверка, если линия горизонтальна
    if (Math.abs(y1 - y2) < 1) {
      // Проверяем, что линия находится внутри прямоугольника
     if (y1 > rectTop && y1 < rectBottom && 
            ((x1 > rectLeft && x1 < rectRight) || (x2 > rectLeft && x2 < rectRight))) {
        return true;
    }

     }

      // Проверка, если линия вертикальна
    if (Math.abs(x1 - x2) < 1) {
        // Проверяем, что линия находится внутри прямоугольника
     if (x1 > rectLeft && x1 < rectRight && 
            ((y1 > rectTop && y1 < rectBottom) || (y2 > rectTop && y2 < rectBottom))) {
       return true;
      }
    }

    // Общая проверка для наклонных линий
    const lineStart = {x: x1, y: y1};
    const lineEnd = {x: x2, y: y2};
    const lineRect = {x: rectLeft, y: rectTop, w: rectRight - rectLeft, h: rectBottom - rectTop};
    
     if (intersectsLineRectangle(lineStart, lineEnd, lineRect)) {
        return true;
    }

    return false;
}

function intersectsLineRectangle(lineStart, lineEnd, rect) {
    // Функция для проверки пересечения линии с отрезком
    const lineToSegment = (p1, p2, p3, p4) => {
        const det = (p2.x - p1.x) * (p4.y - p3.y) - (p2.y - p1.y) * (p4.x - p3.x);
        if (det === 0) return false;

        const lambda = ((p3.x - p1.x) * (p4.y - p3.y) - (p3.y - p1.y) * (p4.x - p3.x)) / det;
        const mu = ((p1.x - p3.x) * (p2.y - p1.y) - (p1.y - p3.y) * (p2.x - p1.x)) / -det;

        return lambda >= 0 && lambda <= 1 && mu >= 0 && mu <= 1;
    };
   
    // Проверяем пересечение с каждой стороной прямоугольника
    return (
        lineToSegment(lineStart, lineEnd, {x: rect.x, y: rect.y}, {x: rect.x + rect.w, y: rect.y}) || //top
        lineToSegment(lineStart, lineEnd, {x: rect.x + rect.w, y: rect.y}, {x: rect.x + rect.w, y: rect.y + rect.h}) || //right
        lineToSegment(lineStart, lineEnd, {x: rect.x + rect.w, y: rect.y + rect.h}, {x: rect.x, y: rect.y + rect.h}) || //bottom
        lineToSegment(lineStart, lineEnd, {x: rect.x, y: rect.y + rect.h}, {x: rect.x, y: rect.y})   //left

    );
}


// Функция очистки canvas
function clearCanvas() {
    const canvas = document.getElementById('schemeCanvas');
    const ctx = canvas.getContext('2d');
    ctx.clearRect(0, 0, canvas.width, canvas.height);
}



// Функция для форматирования кадастрового номера с учетом настройки
function formatCadastralNumber(input) {
    let value = input.value.replace(/\D/g, ''); // Убираем все нецифровые символы
    let formatted = '';

    if (value.length > 0) formatted += value.slice(0, 2); // Первые 2 цифры
    if (value.length > 2) formatted += ':' + value.slice(2, 4); // Следующие 2 цифры

    // Определяем количество знаков после второго двоеточия
    const firstTwoDigits = value.slice(0, 2);
    const isSixDigits = sixDigitsRegions.includes(firstTwoDigits);
    const digitsAfterSecondColon = isSixDigits ? 6 : 7;

    if (value.length > 4) {
        formatted += ':' + value.slice(4, 4 + digitsAfterSecondColon); // Следующие 6 или 7 цифр
    }
    if (value.length > (isSixDigits ? 10 : 11)) {
        formatted += ':' + value.slice(isSixDigits ? 10 : 11); // Остальные цифры
    }

    input.value = formatted; // Обновляем значение поля ввода
}

function showCoordinates() {
    // --- ИЗМЕНЕНИЕ: Условие открытия окна стало более строгим,
    // чтобы избежать показа координат от предыдущего запроса.

    // 1. Получаем номер из поля ввода.
    const cadNumFromInput = document.getElementById('cadastralNumber').value;

    // 2. Получаем номер из уже отображенной таблицы результатов.
    let cadNumFromTable = null;
    const tableRows = document.querySelectorAll('#resultTable tbody tr');
    for (let row of tableRows) {
        if (row.cells && row.cells.length > 1 && row.cells[0].textContent.trim() === 'Кадастровый номер') {
            const valueCell = row.cells[1];
            const strongTag = valueCell.querySelector('strong');
            cadNumFromTable = strongTag ? strongTag.textContent.trim() : valueCell.textContent.trim();
            break;
        }
    }

    // 3. Проверяем, что данные загружены и соответствуют тому, что введено в поле.
    const dataIsReadyAndMatches =
        currentCoords &&
        currentCoords.length > 0 &&
        isValidCadastralNumber(cadNumFromInput) &&
        cadNumFromInput === cadNumFromTable;

    if (dataIsReadyAndMatches) {
        // --- Показываем окно с координатами ---
        const modal = document.getElementById('coordinatesModal');
        const tbody = document.querySelector('#modalCoordinatesTable tbody');
        tbody.innerHTML = ''; // Очищаем предыдущие строки

        let pointIndex = 1;

        // MultiPolygon
             if (currentCoords[0] && Array.isArray(currentCoords[0][0]) && Array.isArray(currentCoords[0][0][0])) {
            currentCoords.forEach(polygon => {
                polygon.forEach(ring => {
                    ring.forEach(coord => {
                        const tr = document.createElement('tr');
                        tr.innerHTML = `<td>${pointIndex++}</td><td>${coord[0]}</td><td>${coord[1]}</td>`;
                        tbody.appendChild(tr);
                    });
                });
            });
        // Polygon
        } else if (currentCoords[0] && Array.isArray(currentCoords[0][0])) {
            currentCoords.forEach(ring => {
                ring.forEach(coord => {
                    const tr = document.createElement('tr');
                    tr.innerHTML = `<td>${pointIndex++}</td><td>${coord[0]}</td><td>${coord[1]}</td>`;
                    tbody.appendChild(tr);
                });
            });
        // MultiLineString - ИЗМЕНЕННОЕ УСЛОВИЕ НИЖЕ
        } else if (currentCoords[0] && Array.isArray(currentCoords[0]) && Array.isArray(currentCoords[0][0])) {
            currentCoords.forEach(line => {
                line.forEach(coord => {
                    const tr = document.createElement('tr');
                    tr.innerHTML = `<td>${pointIndex++}</td><td>${coord[0]}</td><td>${coord[1]}</td>`;
                    tbody.appendChild(tr);
                });
            });
        // Point
        } else {
            const tr = document.createElement('tr');
            // Для точки мы берем координаты так, так как currentCoords = [[x, y]]
            tr.innerHTML = `<td>${pointIndex++}</td><td>${currentCoords[0][0]}</td><td>${currentCoords[0][1]}</td>`;
            tbody.appendChild(tr);
        }

        modal.style.display = 'block'; // Показываем модальное окно с координатами
    } else {
        // --- Во всех остальных случаях (нет данных, неверный номер, несоответствие) открываем окно "Запрос данных по списку" ---
        const batchModal = document.getElementById('batchCadastralModal');
        batchModal.style.display = 'block';
    }
}

// Функция для копирования всех координат в буфер обмена
function copyCoordinates() {
   if (!currentCoords || currentCoords.length === 0) {
        showNotification('Нет данных для копирования', 'error');
        return;
    }

    let coordsString = '';

    // Формируем строку в зависимости от типа геометрии
   // MultiPolygon
    if (currentCoords[0] && Array.isArray(currentCoords[0][0]) && Array.isArray(currentCoords[0][0][0])) {
        currentCoords.forEach(polygon => {
            polygon.forEach(ring => {
                ring.forEach(coord => {
                    coordsString += `${coord[0]}\t${coord[1]}\n`;
                });
            });
        });
    // Polygon
    } else if (currentCoords[0] && Array.isArray(currentCoords[0][0])) {
        currentCoords.forEach(ring => {
            ring.forEach(coord => {
                coordsString += `${coord[0]}\t${coord[1]}\n`;
            });
        });
    // MultiLineString
    } else if (currentCoords[0] && Array.isArray(currentCoords[0])) {
        currentCoords.forEach(line => {
            line.forEach(coord => {
                coordsString += `${coord[0]}\t${coord[1]}\n`;
            });
        });
    // Point
    } else {
        coordsString = `${currentCoords[0][0]}\t${currentCoords[0][1]}`;
    }


    // Копируем в буфер обмена
    navigator.clipboard.writeText(coordsString)
        .then(() => {
            showNotification('Координаты скопированы в буфер обмена', 'success');
        })
        .catch(err => {
            console.error('Ошибка при копировании координат:', err);
            showNotification('Не удалось скопировать координаты', 'error');
        });
}



function checkClipboardForCadastralNumber() {
    navigator.clipboard.readText()
        .then(text => {
            const input = document.getElementById('cadastralNumber');

            // 1. Проверяем длину текста из буфера обмена ПЕРЕД вставкой
            if (text.trim().length > 25) {
           //     showNotification('Номер в буфере обмена слишком длинный', 'error');
                return; // Прерываем выполнение, ничего не вставляем
            }

            // Функция для форматирования и проверки
            const tryFormat = (isSixDigits) => {
                let value = text.replace(/\D/g, '');
                let formatted = '';

                if (value.length > 0) formatted += value.slice(0, 2);
                if (value.length > 2) formatted += ':' + value.slice(2, 4);

                const digitsAfterSecondColon = isSixDigits ? 6 : 7;
                if (value.length > 4) {
                    formatted += ':' + value.slice(4, 4 + digitsAfterSecondColon);
                }
                if (value.length > (isSixDigits ? 10 : 11)) {
                    formatted += ':' + value.slice(isSixDigits ? 10 : 11);
                }

                if (isValidCadastralNumber(formatted)) {
                    return formatted; // Возвращаем отформатированный номер
                }
                return null; // Если невалидный, возвращаем null
            };
            
            // Пытаемся отформатировать, сначала с 7 знаками (стандарт), потом с 6
            let formattedNumber = tryFormat(false) || tryFormat(true);

            // 2. Если форматирование удалось, вставляем номер и запускаем поиск
            if (formattedNumber) {
                input.value = formattedNumber;
                document.querySelector('.search-button').click();
            }
            // Если форматирование не удалось, ничего не делаем.
            // Проблемный блок 'if (!inserted) { input.value = text; }' удален.
        })
        .catch(err => {
            console.error('Ошибка при чтении буфера обмена:', err);
        });
}



// Обработчик закрытия модального окна
document.querySelector('.close-modal').addEventListener('click', function() {
    document.getElementById('coordinatesModal').style.display = 'none';
});


// Функция для форматирования списка кадастровых номеров в textarea
// Функция для форматирования списка кадастровых номеров в textarea
function formatCadastralList() {
    const textarea = document.getElementById('cadastralListInput');
    let value = textarea.value;

    // --- CHANGE: Revised Logic ---
    // 1. Replace known separators (comma, semicolon) with newline globally
    value = value.replace(/[,;]/g, '\n');

    // 2. Split by newline, trim each line, filter empty lines, rejoin.
    // This preserves intended newlines while cleaning up lines
    // and removing blank lines created by separators.
    const lines = value.split('\n')
                       .map(line => line.trim()) // Trim whitespace from start/end of each line
                       .filter(line => line.length > 0); // Remove empty lines

    // 3. Join back with single newline. Store cursor position.
    const currentCursorPos = textarea.selectionStart;
    const originalLength = textarea.value.length;
    textarea.value = lines.join('\n');
    const newLength = textarea.value.length;

    // 4. Try to restore cursor position (might be slightly off after filtering)
    // This helps prevent the cursor from jumping unexpectedly
    const diff = newLength - originalLength;
    textarea.selectionStart = textarea.selectionEnd = Math.max(0, currentCursorPos + diff);
    // --- End Revised Logic ---
}



// Функция для закрытия конкретного модального окна по ID
function closeSpecificModal(modalId) {
    const modal = document.getElementById(modalId);
    if (modal) {
        modal.style.display = 'none';
    }
}


// Добавляем слушатель события 'input' для автоматического форматирования
const cadastralListTextArea = document.getElementById('cadastralListInput');
if (cadastralListTextArea) {
  //  cadastralListTextArea.addEventListener('input', formatCadastralList);
}

function getFormattedCadList(rawText) {
    if (!rawText) return [];
    
    // Заменяем запятые и точки с запятой на переносы строк
    let value = rawText.replace(/[,;]/g, '\n');

    // Разделяем на строки, удаляем ВСЕ пробелы из каждой строки, и убираем пустые строки
    const lines = value.split('\n')
                       .map(line => line.replace(/\s/g, '')) // Удаляем все пробельные символы
                       .filter(line => line.length > 0); // Удаляем пустые строки

    return lines;
}


function validateCadastralList(numbers) {
    // Регулярное выражение, которое разрешает ТОЛЬКО цифры (0-9) и двоеточия (:)
    const validCharsRegex = /^[0-9:]+$/;

    for (const num of numbers) {
        // Проверка 1: Убеждаемся, что в строке нет никаких символов кроме цифр и двоеточий.
        if (!validCharsRegex.test(num)) {
            console.error(`Недопустимые символы в кадастровом номере: "${num}"`);
            return false; // Найдены буквы, тире или другие недопустимые символы.
        }

        // Проверка 2: Убеждаемся, что структура номера правильная (есть минимум 3 двоеточия).
        const colonCount = (num.match(/:/g) || []).length;
        if (colonCount < 3) {
            console.error(`Неверная структура кадастрового номера (не хватает двоеточий): "${num}"`);
            return false; // Структура неверна.
        }
    }
    
    return true; // Все номера в списке прошли обе проверки.
}

function validateZoneList(numbers) {
    // --- ИЗМЕНЕНИЕ: Добавлена точка (\.) в список разрешенных символов ---
    // Регулярное выражение, которое разрешает ТОЛЬКО цифры, двоеточия, тире и точки.
    const validCharsRegex = /^[0-9:.-]+$/;

    for (const num of numbers) {
        // Проверяем, что в строке нет никаких символов кроме разрешенных.
        if (!validCharsRegex.test(num)) {
            console.error(`Недопустимые символы в номере зоны: "${num}"`);
            return false; // Найдены буквы или другие недопустимые символы.
        }
    }
    
    return true; // Все номера в списке прошли проверку.
}

// Функция для обработки поиска по номеру права
document.querySelector('.search-right-button').addEventListener('click', function() {
    const rightNumber = document.getElementById('rightNumberInput').value.trim();
    if (!rightNumber) {
        showNotification('Введите номер права', 'error');
        return;
        
    }

    // Заменяем / на %2F в номере права
    const formattedRightNumber = rightNumber.replace(/\//g, '%2F');
    
    // Выполняем запрос
    fetch(`https://rosreestr.gov.ru/api/online/right/16/${formattedRightNumber}`)
        .then(response => response.json())
        .then(data => {
            if (data && data.length > 0) {
                const result = data[0];
                
                // Обновляем таблицу результатов
                document.getElementById('rightNumber').textContent = rightNumber;
                document.getElementById('cadastralNumberFound').textContent = result.objectCn;
                document.getElementById('addressFound').textContent = result.addressNotes;
                
                // Показываем таблицу
                document.getElementById('rightSearchTable').style.display = 'table';
                
                // Вставляем кадастровый номер в основное поле поиска и запускаем поиск
                document.getElementById('cadastralNumber').value = result.objectCn;
                fetchData(); // Запускаем поиск по кадастровому номеру
            } else {
                showNotification('Данные не найдены', 'error');
            }
        })
        .catch(error => {
            console.error('Ошибка:', error);
            showNotification('Произошла ошибка при поиске', 'error');
        });
    fetchData(true);
});

// Обработчик для клавиши Enter в поле ввода номера права
document.getElementById('rightNumberInput').addEventListener('keydown', function(event) {
    if (event.key === 'Enter') {
        document.querySelector('.search-right-button').click();
    }
});

// Функция открытия карты
function openMap() {
    if (!currentCoords || currentCoords.length === 0) {
        showNotification('Нет данных для отображения карты', 'error');
        return;
    }

    let x, y;

    // MultiPolygon
    if (currentCoords[0] && Array.isArray(currentCoords[0][0]) && Array.isArray(currentCoords[0][0][0])) {
        x = parseFloat(currentCoords[0][0][0][0]); // Преобразуем строку в число
        y = parseFloat(currentCoords[0][0][0][1]);
    // Polygon
    } else if (currentCoords[0] && Array.isArray(currentCoords[0][0])) {
        x = parseFloat(currentCoords[0][0][0]); // Преобразуем строку в число
        y = parseFloat(currentCoords[0][0][1]);
    // MultiLineString
    } else if (currentCoords[0] && Array.isArray(currentCoords[0])) {
        x = parseFloat(currentCoords[0][0][0]); // Преобразуем строку в число
        y = parseFloat(currentCoords[0][0][1]);
    // Point
    } else {
        x = parseFloat(currentCoords[0][0]); // Преобразуем строку в число
        y = parseFloat(currentCoords[0][1]);
    }

    // Проверяем, что x и y успешно преобразованы в числа
    if (isNaN(x) || isNaN(y)) {
        showNotification('Некорректные координаты', 'error');
        return;
    }

    const formattedX = x.toFixed(3);
    const formattedY = y.toFixed(3);
    const mapUrl = `https://nspd.gov.ru/map?zoom=20&coordinate_x=${formattedX}&coordinate_y=${formattedY}&theme_id=1&is_copy_url=true&active_layers=36329%2C36328%2C36049%2C36048`;
    window.open(mapUrl, '_blank');
}

// Обработчики событий

document.getElementById('cadastralNumber').addEventListener('input', function(e) {
    formatCadastralNumber(e.target);

    // Если поле ввода пустое, возвращаем заголовок по умолчанию
    if (e.target.value.trim() === '') {
        document.title = 'ЕГРН';
    }
});

document.getElementById('cadastralNumber').addEventListener('keydown', function(event) {
    if (event.key === 'Enter') {
        fetchData();
    }
});



     // Функция для добавления цифры в поле ввода
        function addDigitToInput(digit) {
            const input = document.getElementById('cadastralNumber');
            input.value += digit;
            formatCadastralNumber(input); // Форматируем ввод
        }


 
        // Функция для показа/скрытия виртуальной клавиатуры
        function toggleVirtualKeyboard() {
            const keyboard = document.getElementById('virtualKeyboard');
            keyboard.classList.toggle('active');
        }

        // Функция для закрытия клавиатуры при клике вне её
        function closeVirtualKeyboard(event) {
            const keyboard = document.getElementById('virtualKeyboard');
            const mobileButton = document.getElementById('mobileKeyboardButton');
            if (
                !keyboard.contains(event.target) &&
                !mobileButton.contains(event.target)
            ) {
                keyboard.classList.remove('active');
            }
        }

        // Обработчик нажатия клавиш
        document.addEventListener('keydown', function(event) {
            if (event.key === 'F9') {
                toggleVirtualKeyboard();
            }
            
               if (event.key === 'F10') {
                event.preventDefault(); 
                useVercelProxyMode = true; 
                   console.log(`Vercel enabled`);    
            }
            
            
        });
        
        

        // Обработчик кликов по клавишам виртуальной клавиатуры
   // Функция для обработки нажатия Enter
function handleEnter() {
    fetchData(); // Вызываем функцию fetchData (аналог нажатия Enter)
       
}

// Функция для удаления последнего символа в поле ввода
function clearLastCharacter() {
    const input = document.getElementById('cadastralNumber');
    input.value = input.value.slice(0, -1); // Удаляем последний символ
    formatCadastralNumber(input); // Форматируем ввод
}

// Функция для очистки всего поля ввода
function clearInput() {
    const input = document.getElementById('cadastralNumber');
    input.value = ''; // Очищаем всё поле
}

document.querySelectorAll('.keyboard-key').forEach(key => {
    if (key.classList.contains('clear')) {
        key.addEventListener('click', clearLastCharacter);
    } else if (key.classList.contains('enter')) {
        key.addEventListener('click', handleEnter);
    } else if (key.classList.contains('insert')) {
        // Только один обработчик для кнопки Insert
        key.addEventListener('click', insertFromClipboard);
    } else {
        key.addEventListener('click', function() {
            addDigitToInput(this.getAttribute('data-key'));
        });
    }
});
        // Обработчик для мобильной кнопки клавиатуры
        document.getElementById('mobileKeyboardButton').addEventListener('click', function(event) {
            event.stopPropagation();
            toggleVirtualKeyboard();
        });

        // Обработчик кликов по документу для закрытия клавиатуры
        document.addEventListener('click', closeVirtualKeyboard);

    
    
    // Обработчик закрытия модального окна
document.querySelectorAll('.close-modal').forEach(button => {
    button.addEventListener('click', function() {
        const modal = this.closest('.modal');
        modal.style.display = 'none';
    });
});

 

// Обработчик двойного клика для закрытия модального окна
document.querySelector('.modal-content').addEventListener('dblclick', function(event) {
    // Проверяем, что двойной клик был не по кнопке convertButton
    if (event.target.id !== 'convertButton') {
        closeModal(); // Закрываем модальное окно
    }
});

// Функция для закрытия модального окна
function closeModal() {
    const modal = document.getElementById('coordinatesModal');
    modal.style.display = 'none';
}


// Function to save the toggle state to local storage
function saveToggleState(state) {
    localStorage.setItem('distanceToggleState', state);
}

// Function to load the toggle state from local storage
function loadToggleState() {
    const savedState = localStorage.getItem('distanceToggleState');
    return savedState === 'true';
}

// Function to toggle the distance labels
function toggleDistanceLabels() {
    showDistanceLabels = !showDistanceLabels;
    saveToggleState(showDistanceLabels); // Save the state to local storage
    drawScheme(); // Redraw the scheme with/without labels
}


    // Обработчик двойного клика на координату в таблице
    document.getElementById('modalCoordinatesTable').addEventListener('dblclick', function(event) {
    const target = event.target;
    if (target.tagName === 'TD' && target.cellIndex !== 0) { // Проверяем, что это не первая ячейка (с номером)
        event.stopPropagation();
        const row = target.parentElement;
        const x = parseFloat(row.cells[1].textContent);
        const y = parseFloat(row.cells[2].textContent);
        const [lon, lat] = convertToWGS84(x, y);
        const url = `https://yandex.ru/maps/?l=sat%2Cskl&ll=${lon},${lat}&z=21&pt=${lon},${lat}`;
        window.open(url);
    }
});


document.getElementById('schemeCanvas').addEventListener('dblclick', function(event) {
    const canvas = document.getElementById('schemeCanvas');
    const rect = canvas.getBoundingClientRect();
    const clickY = event.clientY - rect.top; // Позиция клика относительно верха canvas

    // Проверяем, что клик произошел в верхних 2 см (примерно 75 пикселей при стандартном DPI)
    const topThreshold = 75; // 2 см ≈ 75 пикселей
    if (clickY <= topThreshold) {
        // Получаем элементы, которые нужно сохранить
        const table = document.getElementById('resultTable');
        const schemeCanvas = document.getElementById('schemeCanvas');

        if (!table || !schemeCanvas) {
            showNotification('Таблица или чертеж не найдены', 'error');
            return;
        }

        // Извлекаем чистый текст из таблицы (plain текст без форматирования)
        const rows = table.querySelectorAll('tr');
        let plainTextRows = [];
        rows.forEach(row => {
            const cells = row.querySelectorAll('td, th');
            let rowText = [];
            cells.forEach(cell => {
                rowText.push(cell.textContent.trim()); // Извлекаем только текст
            });
            if (rowText.length > 0) {
                plainTextRows.push(rowText);
            }
        });

        // Создаем новую таблицу с чистым текстом, делая левую колонку шире
        const newTable = document.createElement('table');
        newTable.style.width = 'auto'; // Автоматическая ширина, подстраивающаяся под содержимое
        newTable.style.maxWidth = '600px'; // Ограничение ширины таблицы для компактности
        newTable.style.backgroundColor = '#ffffff'; // Яркий белый фон
        newTable.style.color = '#000000'; // Полностью черный текст
        newTable.style.fontSize = '14px'; // Уменьшенный размер текста для компактности
        newTable.style.fontWeight = 'bold'; // Жирный текст для контраста
        newTable.style.fontFamily = 'Arial, sans-serif'; // Надежный шрифт
        newTable.style.borderCollapse = 'collapse';
        newTable.style.border = '1px solid #000000'; // Тонкие черные границы

        plainTextRows.forEach(rowText => {
            const tr = document.createElement('tr');
            rowText.forEach((text, index) => {
                const td = document.createElement('td');
                td.textContent = text; // Вставляем чистый текст
                td.style.color = '#000000'; // Черный текст
                td.style.backgroundColor = '#ffffff'; // Белый фон
                td.style.border = '1px solid #000000'; // Тонкие черные границы
                td.style.padding = '6px'; // Уменьшенные отступы для компактности
                td.style.textAlign = 'left'; // Выравнивание
                td.style.whiteSpace = 'normal'; // Перенос текста
                td.style.wordBreak = 'break-word'; // Перенос слов
                td.style.lineHeight = '1.1'; // Минимальная высота строки для компактности

                // Делаем первую колонку (индекс 0) шире
                if (index === 0) {
                    td.style.width = '200px'; // Фиксированная ширина для левой колонки
                    td.style.minWidth = '200px'; // Минимальная ширина, чтобы текст не сжимался
                } else {
                    td.style.width = 'auto'; // Остальные колонки автоматически подстраиваются
                }
                tr.appendChild(td);
            });
            newTable.appendChild(tr);
        });

        // Определяем высоту таблицы после добавления содержимого в DOM
        document.body.appendChild(newTable); // Добавляем таблицу в DOM, чтобы вычислить высоту
        const tableHeight = newTable.offsetHeight;
        document.body.removeChild(newTable); // Сразу же убираем обратно

        // Клонируем и подстраиваем чертеж (canvas) под высоту таблицы, сохраняя пропорции
        const canvasClone = document.createElement('canvas');
        const canvasWidth = schemeCanvas.width; // Сохраняем исходную ширину
        const canvasAspectRatio = schemeCanvas.width / schemeCanvas.height; // Соотношение сторон оригинального canvas
        canvasClone.height = tableHeight; // Точная высота таблицы для согласованности
        canvasClone.width = canvasClone.height * canvasAspectRatio; // Вычисляем ширину, сохраняя пропорции
        const ctxClone = canvasClone.getContext('2d');
        ctxClone.fillStyle = '#ffffff'; // Яркий белый фон для canvas
        ctxClone.fillRect(0, 0, canvasClone.width, canvasClone.height); // Заливка белым фоном

        // Масштабируем содержимое оригинального canvas, чтобы оно точно поместилось, сохраняя пропорции
        const scale = canvasClone.height / schemeCanvas.height; // Масштаб по высоте
        ctxClone.scale(scale, scale); // Масштабируем пропорционально по обоим осям
        ctxClone.drawImage(schemeCanvas, 0, 0, schemeCanvas.width, schemeCanvas.height); // Копируем содержимое

        // Создаем временный контейнер с таблицей слева и чертежом справа
        const tempContainer = document.createElement('div');
        tempContainer.style.position = 'absolute';
        tempContainer.style.left = '-9999px'; // Убираем из видимой области
        tempContainer.style.background = '#fff'; // Яркий белый фон
        tempContainer.style.padding = '5px'; // Минимальный отступ
        tempContainer.style.display = 'flex'; // Горизонтальная ориентация
        tempContainer.style.flexDirection = 'row'; // Таблица слева, чертеж справа
        tempContainer.style.gap = '5px'; // Минимальное расстояние между таблицей и чертежом
        tempContainer.style.alignItems = 'flex-start'; // Выравнивание по верху
        tempContainer.style.maxWidth = '1200px'; // Ограничение общей ширины для компактности

        // Добавляем новую таблицу слева
        tempContainer.appendChild(newTable);

        // Добавляем чертеж (canvas) справа
        tempContainer.appendChild(canvasClone);

        // Добавляем временный контейнер в DOM
        document.body.appendChild(tempContainer);

        // Используем html2canvas для захвата контейнера с масштабом 2 (увеличение разрешения)
        html2canvas(tempContainer, {
            scale: 2, // Увеличили масштаб для улучшения качества (примерно 200 DPI)
            backgroundColor: '#ffffff', // Яркий белый фон
            useCORS: true, // Попытка загрузки внешних ресурсов с CORS
            allowTaint: true, // Разрешаем обработку потенциально "загрязненных" ресурсов
            logging: false,
            ignoreElements: (element) => element.tagName === 'SCRIPT' || element.tagName === 'STYLE' // Игнорируем скрипты и стили
        }).then(canvas => {
            // Преобразуем в JPG
            const imgData = canvas.toDataURL('image/jpeg', 0.95); // Высокое качество

            // Создаем ссылку для скачивания
            const link = document.createElement('a');
            link.href = imgData;

            // Генерируем имя файла с текущей датой и временем
            const now = new Date();
            const dateStr = now.toISOString().replace(/[:.]/g, '-').slice(0, 19);
            link.download = `egrn-${dateStr}.jpg`;

            // Скачиваем файл
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);

            // Удаляем временный контейнер
            document.body.removeChild(tempContainer);

            showNotification('Таблица и чертеж сохранены как JPG', 'success');
        }).catch(error => {
            console.error('Ошибка при сохранении с html2canvas:', error);
            showNotification('Ошибка при сохранении, проверьте консоль', 'error');

            // Удаляем временный контейнер в случае ошибки
            if (document.body.contains(tempContainer)) {
                document.body.removeChild(tempContainer);
            }
        });
    }
});



const STORAGE_API_URL = 'https://mapruapp.ru/storage';


async function fetchDataFromArchive() {
    const cadastralNumberInput = document.getElementById('cadastralNumber');
    const targetCadastralNumber = cadastralNumberInput.value.trim();
    const archiveInfoDiv = document.getElementById('archiveInfo');

   
    if (archiveInfoDiv) {
        archiveInfoDiv.style.display = 'none';
        archiveInfoDiv.innerHTML = ''; // Очищаем содержимое
    }

    if (!isValidCadastralNumber(targetCadastralNumber)) {
        showNotification('Введите корректный кадастровый номер участка', 'error');
        return;
    }

    showNotification(`Поиск ${targetCadastralNumber} в архиве КПТ...`, 'info');

    try {
        const quarterNumber = targetCadastralNumber.split(':').slice(0, 3).join(':');
        const filename = quarterNumber.replace(/:/g, '_') + '.nspd';

        const zipBlob = await fetchZipFromLocalServer('nspd', filename);
        if (!zipBlob) {
            showNotification(`Архив для квартала ${quarterNumber} не найден. Попробуйте обычный поиск.`, 'warning');
            return;
        }

        const { features, date: archiveDate } = await loadAndParseZipBlob(zipBlob);

        const targetFeature = features.find(f => f.properties && f.properties.descr === targetCadastralNumber);

        if (!targetFeature) {
            showNotification(`Участок ${targetCadastralNumber} не найден в архиве квартала.`, 'error');
            return;
        }

        console.log("Найден участок в архиве:", targetFeature);

        const properties = targetFeature.properties;
        const options = targetFeature.properties ? targetFeature.properties.options : {};
        const geometry = targetFeature.geometry;
        
        document.title = `${targetCadastralNumber}`;
          updatePropertyData(options, properties, null, null, geometry);

        if (geometry && geometry.coordinates && geometry.type !== "Point") {
            currentCoords = geometry.coordinates;
            document.querySelector('.content-container').style.display = 'grid';
            document.querySelector('.scheme-container').style.display = 'block';
            drawScheme();
        } else {
            document.querySelector('.content-container').style.display = 'block';
            document.querySelector('.scheme-container').style.display = 'none';
            clearCanvas();
            const warningMsg = (geometry && geometry.type === "Point") 
                ? 'Участок найден, но не имеет координат для отрисовки (геометрия-точка).'
                : 'Участок найден, но не имеет координат для отрисовки.';
            showNotification(warningMsg, 'warning');
        }
        
      
        let formattedDate = '';
        if (archiveDate) {
            const [year, month, day] = archiveDate.split('-');
            formattedDate = `${day}.${month}.${year}`;
        }

   
     if (archiveInfoDiv && formattedDate) {
    archiveInfoDiv.innerHTML = `
        <i class="fas fa-exclamation-triangle" style="margin-right: 8px; color: #ffa726;"></i>
        <span style="font-size: 16px; font-weight: 500; color: #ef6c00;">
            Данные из архива (актуальность: ${formattedDate})
        </span>
    `;
    archiveInfoDiv.style.display = 'block';
}
        // Показываем уведомление (без изменений)
        const notificationMessage = formattedDate
            ? `Данные из архива КПТ загружены (на ${formattedDate})`
            : 'Данные из архива КПТ успешно загружены!';
        showNotification(notificationMessage, 'success');
        
        document.getElementById('resultTable').style.display = 'table';

    } catch (error) {
        console.error("Ошибка при работе с архивом:", error);
        showNotification(`Ошибка: ${error.message}`, 'error');
    }
}


async function fetchZipFromLocalServer(bucketName, filePathInBucket) {
    try {
        const response = await fetch(`${STORAGE_API_URL}/${bucketName}/${filePathInBucket}`);
        if (!response.ok) {
            if (response.status === 404) {
                console.log(`Файл "${filePathInBucket}" не найден.`);
            } else {
                console.error(`Ошибка сервера ${response.status} для файла "${filePathInBucket}".`);
            }
            return null;
        }
        return await response.blob();
    } catch (error) {
        console.error(`Ошибка сети при запросе файла "${filePathInBucket}":`, error);
        return null;
    }
}


async function loadAndParseZipBlob(zipBlob) {
    if (!zipBlob) throw new Error("ZIP-файл для загрузки не предоставлен.");

    const zip = await JSZip.loadAsync(zipBlob);

    let jsonFile = null;
    let loadedDate = null;
    let inferredQuarter = null;
    const jsonFilenamePattern = /^(\d{2}_\d{2}_\d{6,7}(?:_\d+)?)\s(\d{4}-\d{2}-\d{2})\.json$/;

    for (const filename in zip.files) {
        const match = filename.match(jsonFilenamePattern);
        if (match) {
            jsonFile = zip.files[filename];
            inferredQuarter = match[1].replace(/_/g, ':');
            loadedDate = match[2];
            break;
        }
    }

    if (!jsonFile) {
        throw new Error("Файл данных (*.json) не найден в архиве.");
    }

    const jsonText = await jsonFile.async("text");
    const loadedFeatures = JSON.parse(jsonText);

    if (!Array.isArray(loadedFeatures)) {
        throw new Error("Файл содержит некорректные данные.");
    }

    return { features: loadedFeatures, date: loadedDate, quarter: inferredQuarter };
}




// Инициализация при загрузке страницы
window.onload = function() {
    showDistanceLabels = loadToggleState(); // Load the state from local storage
    document.getElementById('distanceToggle').checked = showDistanceLabels;
    document.getElementById('cadastralNumber').focus();

    // Check the clipboard for a cadastral number and insert it if available
    checkClipboardForCadastralNumber();

    // Check if the device is mobile
    if (window.innerWidth < 768) {
        const canvasContainer = document.querySelector('.scheme-container');
        canvasContainer.style.display = 'block';
        drawScheme();
        toggleVirtualKeyboard();
    }
};
</script>
    
</body>
</html>