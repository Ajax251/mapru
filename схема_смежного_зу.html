<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Схема смежного ЗУ</title>
    <link href="webfonts/all.min.css" rel="stylesheet">
    <link rel="icon" href="webfonts/sm.png" type="image/png">
    <script src="webfonts/jszip.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
  <script src="sk.js"></script>
    <script src="msk.js"></script>
    <script src="webfonts/proj4.js"></script>
    <style>
    body, html {
        font-family: 'Roboto', Arial, sans-serif;
        margin: 0;
        padding: 0;
        height: 100%;
        overflow: hidden;
        background-color: #f0f4f8;
        color: #333;
    }

    .container {
        display: flex;
        height: 100vh;
        animation: fadeIn 0.5s ease;
    }

    @keyframes fadeIn {
        from { opacity: 0; }
        to { opacity: 1; }
    }

    .left-panel, .right-panel {
        width: 15%;
        display: flex;
        flex-direction: column;
        padding: 15px;
        box-sizing: border-box;
        background-color: #ffffff;
        box-shadow: 0 0 10px rgba(0,0,0,0.1);
        transition: all 0.3s ease;
    }

    .left-panel:hover, .right-panel:hover {
        box-shadow: 0 0 15px rgba(0,0,0,0.2);
    }

    .right-panel {
        width: 30%;
        display: flex;
        flex-direction: column;
        padding: 15px;
        box-sizing: border-box;
        background-color: #ffffff;
        box-shadow: 0 0 10px rgba(0,0,0,0.1);
        border-left: 1px solid #e0e0e0;
    }

    .center-panel {
        width: 55%;
        height: 100%;
        display: flex;
        flex-direction: column;
        padding: 15px;
        box-sizing: border-box;
        background-color: #ffffff;
        box-shadow: 0 0 10px rgba(0,0,0,0.1);
    }

    .coordsInput {
        height: 50%;
        width: 100%;
        resize: none;
        box-sizing: border-box;
        margin-bottom: 15px;
        border: 1px solid #ccc;
        padding: 10px;
        font-size: 14px;
        border-radius: 5px;
        transition: all 0.3s ease;
    }

    .coordsInput:focus {
        border-color: #007bff;
        box-shadow: 0 0 5px rgba(0,123,255,0.5);
    }
    #canvas {
        width: 100%;
        height: calc(100% - 180px); /* Changed from 100px to 180px */
        border: 2px solid silver;
        box-sizing: border-box;
        border-radius: 5px;
        transition: all 0.3s ease;
    }
    #canvas:hover {
        box-shadow: 0 0 10px rgba(0,123,255,0.3);
    }

    #clickedCoords {
        height: calc(100% - 150px);
        width: 100%;
        resize: none;
        border: 1px solid #ccc;
        padding: 10px;
        font-size: 12px;
        border-radius: 5px;
        transition: all 0.3s ease;
        margin-bottom: 10px;
    }

    #clickedCoords:focus {
        border-color: #28a745;
        box-shadow: 0 0 5px rgba(40,167,69,0.5);
    }

    h1 {
        margin: 0;
        padding: 15px;
        text-align: center;
        font-size: 24px;
        color: #5064c8;
        text-shadow: 1px 1px 2px rgba(0,0,0,0.1);
        animation: slideDown 0.5s ease;
    }

    @keyframes slideDown {
        from { transform: translateY(-20px); opacity: 0; }
        to { transform: translateY(0); opacity: 1; }
    }

    h2 {
        margin-top: 0;
        font-size: 18px;
        color: #28a745;
        animation: slideRight 0.5s ease;
    }
     h3 {
        margin-top: 0;
        margin-bottom: 15px;
        font-size: 1.3em;
        color: #333;
        text-align: center;
    }

    @keyframes slideRight {
        from { transform: translateX(-20px); opacity: 0; }
        to { transform: translateX(0); opacity: 1; }
    }

    .button-container {
        display: flex;
        justify-content: center;
        gap: 15px;
        margin-top: 15px;
    }

    .custom-button {
        padding: 12px 24px;
        font-size: 16px;
        border: none;
        border-radius: 5px;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: all 0.3s ease;
        box-shadow: 0 2px 5px rgba(0,0,0,0.2);
           margin-top: 10px;
    }

    .custom-button:hover {
        transform: translateY(-2px);
        box-shadow: 0 4px 8px rgba(0,0,0,0.2);
    }

    .custom-button:active {
        transform: translateY(1px);
        box-shadow: 0 1px 3px rgba(0,0,0,0.2);
    }

    .btn-csv {
        background-color: #28a745;
        color: white;
    }

    .btn-csv:hover {
        background-color: #218838;
    }

    .btn-copy {
        background-color: #ffa500;
        color: white;
    }

    .btn-copy:hover {
        background-color: #ff8c00;
    }

    .icon {
        margin-right: 8px;
    }

    #log, #distanceLog {
        margin-top: 15px;
        padding: 10px;
        background-color: #f8f9fa;
        border-radius: 5px;
        box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        animation: fadeIn 0.5s ease;
        font-size: 0.9em;
        max-height: 80px; 
        overflow-y: auto;
    }

#modal, #knInputDialog {
        display: none;
        position: fixed;
        z-index: 1001; /* ИЗМЕНЕНИЕ: Увеличено с 1000 до 1001 */
        left: 0;
        top: 0;
        width: 100%;
        height: 100%;
        overflow: auto;
        background-color: rgba(0,0,0,0.4);
        animation: fadeIn 0.3s ease;
        align-items: center; 
        justify-content: center; 
    }

    
    .btn-pink {
        background-color: #FF69B4;
        color: white;
        margin-top: 10px;
    }

    .btn-pink:hover {
        background-color: #FF1493;
    }

    .btn-royal-blue {
        background-color: #4169E1;
        color: white;
        margin-top: 10px;
    }

    .btn-royal-blue:hover {
        background-color: #0000CD;
    }
    
    .btn-supabase {
        background-color: #50C878; 
        color: white;
    }
    .btn-supabase:hover {
        background-color: #30A16E;
    }


    .btn-mif, .btn-xml {
        margin-right: 5px;
    }

    .modal-content {
        background-color: #fefefe;
        padding: 25px; 
        border: 1px solid #888;
        width: auto; 
        min-width: 300px; 
        max-width: 400px; 
        text-align: center;
        border-radius: 10px;
        box-shadow: 0 5px 25px rgba(0,0,0,0.25); 
        animation: zoomIn 0.3s ease; 
        position: relative;
    }
    
    #knInputDialog .modal-content {
         width: 360px; 
    }
    #knInput {
        width: calc(100% - 30px); 
        padding: 12px 15px;
        margin-bottom: 20px; 
        border: 1px solid #ced4da;
        border-radius: 6px;
        box-sizing: border-box;
        font-size: 17px;
        text-align: center;
        transition: border-color 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
    }
    #knInput:focus {
        border-color: #007bff;
        box-shadow: 0 0 0 0.2rem rgba(0, 123, 255, 0.25);
        outline: none;
    }


    @keyframes zoomIn {
        from { transform: scale(0.8); opacity: 0; } 
        to { transform: scale(1); opacity: 1; }
    }

    .close-button {
        position: absolute;
        top: 10px;
        right: 15px;
        font-size: 28px;
        color: #aaa;
        cursor: pointer;
        transition: color 0.3s ease;
        font-weight: bold;
        line-height: 1;
    }

    .close-button:hover {
        color: #333;
    }

    .modal-buttons {
        display: flex;
        justify-content: space-between;
        margin-top: 20px; 
    }
  
    #knInputDialog .modal-buttons {
        justify-content: space-between; /* Распределяет кнопки по всей ширине */
        gap: 8px; /* Немного уменьшаем зазор между кнопками */
    }

 
    .modal-button {
        flex: 1;
        margin: 0 5px;
        padding: 10px 15px; 
        font-size: 15px; 
        border: none;
        border-radius: 6px; 
        cursor: pointer;
        transition: all 0.3s ease;
        font-weight: 500; 
        position: relative; /* ДОБАВЛЕНО: Для надежности */
    }
  
  
    #knInputDialog .modal-button {
        flex: 1; /* Позволяет кнопкам равномерно занимать доступное пространство */
        padding: 10px 15px; /* Уменьшаем горизонтальные отступы для экономии места */
    }


    .modal-button:hover {
        transform: translateY(-2px);
        box-shadow: 0 3px 7px rgba(0,0,0,0.15); 
    }

    .btn-blue {
        background-color: #007bff;
        color: white;
    }

    .btn-blue:hover {
        background-color: #0056b3;
    }

    .btn-white {
        background-color: white;
        color: black;
        border: 1px solid #ccc;
    }

    .btn-white:hover {
        background-color: #f8f9fa;
    }

    .btn-red {
        background-color: #dc3545;
        color: white;
    }

    .btn-red:hover {
        background-color: #c82333;
    }

    .highlight-circle, .pulse-circle {
        position: absolute;
        border: 2px solid green;
        border-radius: 50%;
        pointer-events: none;
    }

  .highlight-circle, .pulse-circle {
    position: absolute;
    border: 2px solid;
    border-radius: 50%;
    pointer-events: none;
}

.highlight-circle {
    animation: rotate 2s linear infinite;
}

    @keyframes rotate {
        from { transform: rotate(0deg); }
        to { transform: rotate(360deg); }
    }

    @keyframes pulse {
        0% { transform: scale(1); opacity: 1; }
        50% { transform: scale(1.5); opacity: 0.7; }
        100% { transform: scale(1); opacity: 1; }
    }

    .flash-button {
        animation: flash 1s;
    }

    @keyframes flash {
        0% { background-color: #ffa500; }
        50% { background-color: #ffff00; }
        100% { background-color: #ffa500; }
    }

    #notification {
        position: fixed;
        top: 20px;
        right: 20px;
        padding: 10px 20px;
        background-color: #28a745;
        color: white;
        border-radius: 5px;
        box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        display: none;
        animation: slideLeftRegular 0.3s ease;
        z-index: 2000;
        max-width: 80%;
        word-wrap: break-word;
    }
    
    #dataMismatchNotification {
        position: fixed;
        top: 10px;
        left: 50%;
        transform: translateX(-50%);
        padding: 10px 20px;
        background-color: #ffc107;
        color: #333;
        border-radius: 5px;
        box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        display: none;
        z-index: 2001;
        text-align: center;
        max-width: 90%;
        word-wrap: break-word;
    }


    @keyframes slideLeftRegular {
        from { transform: translateX(100%); opacity: 0; }
        to { transform: translateX(0); opacity: 1; }
    }
    
    #customDialog {
        display: none;
        position: fixed;
        z-index: 1000;
        left: 0;
        top: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.5);
        justify-content: center;
        align-items: center;
    }

    #customDialog .modal-content {
        background-color: #fff;
        padding: 20px;
        border-radius: 10px;
        width: 400px;
        box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
        animation: zoomIn 0.3s ease;
    }

    #customDialog label, #knInputDialog label {
        display: block;
        margin-bottom: 8px; 
        font-weight: bold;
        text-align: left; 
    }

    #customDialog input {
        width: 100%;
        padding: 8px;
        margin-bottom: 15px;
        border: 1px solid #ccc;
        border-radius: 5px;
    }

    #customDialog .modal-buttons {
        display: flex;
        justify-content: flex-end;
        gap: 10px;
    }

    #customDialog .modal-button {
        padding: 10px 20px;
        border: none;
        border-radius: 5px;
        cursor: pointer;
        font-size: 14px;
    }

    #customDialog .btn-blue {
        background-color: #007bff;
        color: white;
    }

    #customDialog .btn-blue:hover {
        background-color: #0056b3;
    }

    #customDialog .btn-red {
        background-color: #dc3545;
        color: white;
    }

    #customDialog .btn-red:hover {
        background-color: #c82333;
    }
        .btn-egrn {
        background-color: #28a745;
        color: white;
    }
    .btn-egrn:hover {
        background-color: #218838;
    }
    
    .btn-check {
        background-color: #fd7e14; /* Оранжевый */
        color: white;
    }

    .btn-check:hover {
        background-color: #e86a00;
    }


    </style>
</head>
<body>
    <div id="dataMismatchNotification"></div>
    <div class="container">
        <div class="left-panel">
            <textarea id="coordsInput1" class="coordsInput" placeholder="Введите координаты уточняемого/образуемого ЗУ (красный контур) в формате X(tab)Y, по одной паре на строку" oninput="handleInput()"></textarea>
            <button class="custom-button btn-mif btn-pink" onclick="loadFromMIF('coordsInput1')"><i class="fas fa-file-import icon"></i>Вставить из MIF</button>
            <button class="custom-button btn-xml btn-pink" onclick="loadFromXML('coordsInput1')"><i class="fas fa-file-import icon"></i>Вставить из XML</button>

            <textarea id="coordsInput2" class="coordsInput" placeholder="Введите координаты смежного/исходного ЗУ (синий контур) в формате X(tab)Y, по одной паре на строку" oninput="handleInput()"></textarea>
            <button class="custom-button btn-mif btn-royal-blue" onclick="loadFromMIF('coordsInput2')"><i class="fas fa-file-import icon"></i>Вставить из MIF</button>
            <button class="custom-button btn-xml btn-royal-blue" onclick="loadFromXML('coordsInput2')"><i class="fas fa-file-import icon"></i>Вставить из XML</button>
            <button class="custom-button btn-supabase btn-royal-blue" onclick="showKnInputDialog('coordsInput2')"><i class="fas fa-database icon"></i>Вставить по КН</button>
        </div>
        <div class="center-panel">
            <h1>CSV с описанием части границы смежного ЗУ</h1>
            <canvas id="canvas"></canvas>
            <div id="log"></div>
            <div id="distanceLog"></div>
        </div>
        <div class="right-panel">
            <h2>Координаты части границы</h2>
            <textarea id="clickedCoords"></textarea>
            <button class="custom-button btn-copy" onclick="copyClickedCoords()"><i class="fas fa-copy icon"></i>Копировать</button>
            <button class="custom-button btn-csv" onclick="exportToCSV()"><i class="fas fa-file-excel icon"></i>Экспорт в CSV</button>
            <button class="custom-button" onclick="deleteSelectedLine()">Удалить строку</button>
              <button class="custom-button btn-check" onclick="runVerification()">Проверить</button>
        </div>
    </div>
    <div id="notification"></div>

<div id="modal">
        <div class="modal-content">
            <span class="close-button" onclick="hideModal()">&times;</span>
            <h3>Выберите тип точки</h3>
            <div class="modal-buttons">
                <button class="modal-button btn-blue" onclick="addPoint('initial')">Исходная точка</button>
                <button class="modal-button btn-white" onclick="addPoint('removed')">Удаляемая точка</button>
                <button class="modal-button btn-red" onclick="addPoint('new')">Новая точка</button>
            </div>
        </div>
    </div>

    <div id="customDialog">
        <div class="modal-content">
            <span class="close-button" onclick="hideCustomDialog()">&times;</span>
            <h3>Исправление части границы</h3>
            <label for="pointsInput">Точки:</label>
            <input type="text" id="pointsInput" placeholder="Введите точки">
            <label for="cadastralNumberInput">Кадастровый номер:</label>
            <input type="text" id="cadastralNumberInput" placeholder="Введите кадастровый номер">
            <label for="addressInput">Адрес:</label>
            <input type="text" id="addressInput" placeholder="Введите адрес">
            <div class="modal-buttons">
                <button class="modal-button btn-blue" onclick="copyText()">Копировать</button>
                <button class="modal-button btn-red" onclick="hideCustomDialog()">Отмена</button>
            </div>
        </div>
    </div>

    <div id="knInputDialog">
        <div class="modal-content">
            <span class="close-button" onclick="hideKnInputDialog()">&times;</span>
            <h3>Загрузка по КН</h3>
            <label for="knInput">Кадастровый номер:</label>
            <input type="text" id="knInput" placeholder="XX:XX:XXXXXX(X):YY">
            <div class="modal-buttons">
                <button class="modal-button btn-supabase" id="knEgrnButton">Добавить из ЕГРН</button>
                <button class="modal-button btn-blue" id="knConfirmButton">Добавить из XML</button>
                <button class="modal-button btn-red" onclick="hideKnInputDialog()">Отмена</button>
            </div>
        </div>
    </div>
    
<script>
let clickedX, clickedY;
let verificationContour = null; 
let problematicPoint = null; 
let highlightCircle = null;
let pulseCircle = null;
let hoveredPoint = null;
let pointCounter = 1;
let selectedPoints = [];
let isSelectingPoints = false;
let isDragging = false;
let lastX, lastY;
let offsetX = 0, offsetY = 0;
let scale = 1;
let removedPointsCoords = [];
let currentTextareaIdForKNLoad = null;

let notificationQueue = [];
let isNotificationActive = false;

const STORAGE_API_URL = 'https://mapruapp.ru/storage'; 
const BUCKET_NAME = 'kpt';

const sevenDigitsRegions = ['24', '50', '63', '66', '77', '78', '91'];


function parseClickedCoordsForRemovedPoints() {
    removedPointsCoords = [];
    const coordsTextArea = document.getElementById('clickedCoords');
    const lines = coordsTextArea.value.trim().split('\n');

    lines.forEach(line => {
        if (line.trim() === '') return;

        const parts = line.split('\t');
        if (parts.length >= 6 && parts[4] === 'л' && parts[5] === 'л') {
            const x = parseFloat(parts[2].replace(',', '.'));
            const y = parseFloat(parts[3].replace(',', '.'));
            if (!isNaN(x) && !isNaN(y)) {
                removedPointsCoords.push({ x: x, y: y });
            }
        }
    });
}

function isValidCoordinateFormat(text) {
    if (!text || typeof text !== 'string') return false;
    // Фильтруем пустые строки и проверяем, что осталось как минимум 2 строки с данными
    const lines = text.trim().split('\n').filter(line => line.trim() !== '');
    if (lines.length < 2) return false;

    // Проверяем каждую строку на соответствие формату "число<таб>число"
    return lines.every(line => {
        const parts = line.split('\t');
        if (parts.length !== 2) return false;
        const x = parseFloat(parts[0].replace(',', '.'));
        const y = parseFloat(parts[1].replace(',', '.'));
        return !isNaN(x) && !isNaN(y);
    });
}


function drawContour(coords1, coords2) {
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    function processCoords(coords) {
        return coords.map(coord => coord.split('\t').map(c => parseFloat(c.replace(',', '.')))).filter(p => p && p.length === 2 && !isNaN(p[0]) && !isNaN(p[1]));
    }

    const points1 = processCoords(coords1);
    const points2 = processCoords(coords2);

    const allPoints = [...points1, ...points2];
     if (allPoints.length === 0) {
        displayLog(points1, points2);
        return;
    }
    
    const minX = Math.min(...allPoints.map(p => p[1]));
    const minY = Math.min(...allPoints.map(p => p[0]));
    const maxX = Math.max(...allPoints.map(p => p[1]));
    const maxY = Math.max(...allPoints.map(p => p[0]));

    const scaleX = (maxX - minX === 0) ? 1 : canvas.width / (maxX - minX);
    const scaleY = (maxY - minY === 0) ? 1 : canvas.height / (maxY - minY);
    const baseScale = Math.min(scaleX, scaleY) * 0.9;

    function transformCoords(x, y) {
        const canvasX = (offsetX + (y - minX) * baseScale) * scale;
        const canvasY = canvas.height - (offsetY + (x - minY) * baseScale) * scale;
        return [canvasX, canvasY];
    }

    function drawObject(points, color, prefix = '') {
        if (!points || points.length === 0) return;
        ctx.beginPath();
        points.forEach(([x, y], index) => {
            const [canvasX, canvasY] = transformCoords(x, y);
            if (index === 0) {
                ctx.moveTo(canvasX, canvasY);
            } else {
                ctx.lineTo(canvasX, canvasY);
            }
        });
        ctx.strokeStyle = color;
        ctx.stroke();

        ctx.fillStyle = color;
        ctx.font = '12px Arial';

        points.forEach(([x, y], index) => {
            const [canvasX, canvasY] = transformCoords(x, y);
            ctx.beginPath();
            ctx.arc(canvasX, canvasY, 3, 0, 2 * Math.PI);
            ctx.fill();

            let isClosingPointSameAsFirst = false;
            if (points.length > 1 && index === points.length -1) {
                if (x === points[0][0] && y === points[0][1]) {
                    isClosingPointSameAsFirst = true;
                }
            }
             if (!isClosingPointSameAsFirst) {
                 ctx.fillText(`${prefix}${index + 1}`, canvasX + 5, canvasY - 5);
            }
        });
    }

    if (points1.length > 0) drawObject(points1, 'red', 'н');
    if (points2.length > 0) drawObject(points2, 'blue');
    
    if (removedPointsCoords && removedPointsCoords.length > 0) {
        ctx.strokeStyle = 'red';
        ctx.lineWidth = 2;
        removedPointsCoords.forEach(point => {
            if (!isNaN(point.x) && !isNaN(point.y)) {
                const [canvasX, canvasY] = transformCoords(point.x, point.y);
                ctx.beginPath();
                ctx.arc(canvasX, canvasY, 7, 0, 2 * Math.PI);
                ctx.stroke();
            }
        });
        ctx.lineWidth = 1;
    }

    displayLog(points1, points2);

    const allPointsWithIndices = [
        ...points1.map((p, i) => ({point: p, index: i, object: 1})),
        ...points2.map((p, i) => ({point: p, index: i, object: 2}))
    ];

    if (isSelectingPoints && selectedPoints.length >= 2) {
        ctx.beginPath();
        selectedPoints.forEach(([x, y], index) => {
            const [canvasX, canvasY] = transformCoords(x, y);
            if (index === 0) {
                ctx.moveTo(canvasX, canvasY);
            } else {
                ctx.lineTo(canvasX, canvasY);
            }
        });
        ctx.strokeStyle = 'green';
        ctx.lineWidth = 2;
        ctx.stroke();
        ctx.lineWidth = 1;
    }

   canvas.onmousemove = function(event) {
        if (isDragging) {
            drag(event);
        } else {
            const rect = canvas.getBoundingClientRect();
            const mouseX = event.clientX - rect.left;
            const mouseY = event.clientY - rect.top;

            hoveredPoint = allPointsWithIndices.find(({point}) => {
                if (isNaN(point[0]) || isNaN(point[1])) return false;
                const [canvasX, canvasY] = transformCoords(point[0], point[1]);
                const distance = Math.sqrt((mouseX - canvasX)**2 + (mouseY - canvasY)**2);
                return distance <= 5;
            });

            if (hoveredPoint) {
                if (!highlightCircle) {
                    highlightCircle = document.createElement('div');
                    highlightCircle.className = 'highlight-circle';
                    document.body.appendChild(highlightCircle);
                }
                if (!isNaN(hoveredPoint.point[0]) && !isNaN(hoveredPoint.point[1])) {
                    const [canvasX, canvasY] = transformCoords(hoveredPoint.point[0], hoveredPoint.point[1]);
                    highlightCircle.style.left = (canvas.offsetLeft + canvasX - 10) + 'px';
                    highlightCircle.style.top = (canvas.offsetTop + canvasY - 10) + 'px';
                    highlightCircle.style.width = '20px';
                    highlightCircle.style.height = '20px';
                    highlightCircle.style.borderColor = hoveredPoint.object === 1 ? 'red' : 'blue';
                }
            } else if (highlightCircle) {
                if (highlightCircle.parentNode) {
                    document.body.removeChild(highlightCircle);
                }
                highlightCircle = null;
            }
        }
    };

    canvas.onclick = function(event) {
        const rect = canvas.getBoundingClientRect();
        const clickX = event.clientX - rect.left;
        const clickY = event.clientY - rect.top;

        const clickedPoint = allPointsWithIndices.find(({point}) => {
            if (isNaN(point[0]) || isNaN(point[1])) return false;
            const [canvasX, canvasY] = transformCoords(point[0], point[1]);
            const distance = Math.sqrt((clickX - canvasX)**2 + (clickY - canvasY)**2);
            return distance <= 5;
        });

        if (clickedPoint) {
            clickedX = clickedPoint.point[0];
            clickedY = clickedPoint.point[1];

            if (pulseCircle && pulseCircle.parentNode) {
                document.body.removeChild(pulseCircle);
            }
            pulseCircle = document.createElement('div');
            pulseCircle.className = 'pulse-circle';
            if (!isNaN(clickedX) && !isNaN(clickedY)) {
                const [canvasX, canvasY] = transformCoords(clickedX, clickedY);
                pulseCircle.style.left = (canvas.offsetLeft + canvasX - 30) + 'px';
                pulseCircle.style.top = (canvas.offsetTop + canvasY - 30) + 'px';
                pulseCircle.style.width = '60px';
                pulseCircle.style.height = '60px';
                document.body.appendChild(pulseCircle);
            }

            showModal();

            setTimeout(() => {
                if (pulseCircle && pulseCircle.parentNode) {
                    document.body.removeChild(pulseCircle);
                }
                pulseCircle = null;
            }, 1000);
        }
    };
    
    
    
        if (verificationContour && verificationContour.length > 0) {
        // Соединение линий нового контура
        ctx.beginPath();
        verificationContour.forEach(([x, y], index) => {
            const [canvasX, canvasY] = transformCoords(x, y);
            if (index === 0) ctx.moveTo(canvasX, canvasY);
            else ctx.lineTo(canvasX, canvasY);
        });
        ctx.strokeStyle = 'orange';
        ctx.lineWidth = 3; // Делаем линию жирной для наглядности
        ctx.stroke();
        
        // Отрисовка точек нового контура
        verificationContour.forEach(([x, y], index) => {
            const [canvasX, canvasY] = transformCoords(x, y);
            ctx.beginPath();
            ctx.arc(canvasX, canvasY, 4, 0, 2 * Math.PI);
            ctx.fillStyle = 'orange';
            ctx.fill();
        });

        ctx.lineWidth = 1; // Возвращаем толщину линии по умолчанию
    }
    
       if (problematicPoint) {
        const [canvasX, canvasY] = transformCoords(problematicPoint.x, problematicPoint.y);
        ctx.strokeStyle = 'red';
        ctx.fillStyle = 'rgba(255, 0, 0, 0.2)';
        ctx.lineWidth = 3;
        
        ctx.beginPath();
        ctx.arc(canvasX, canvasY, 15, 0, 2 * Math.PI); // Большой круг
        ctx.fill();
        ctx.stroke();
        
        // Перекрестие для акцента
        ctx.beginPath();
        ctx.moveTo(canvasX - 10, canvasY);
        ctx.lineTo(canvasX + 10, canvasY);
        ctx.moveTo(canvasX, canvasY - 10);
        ctx.lineTo(canvasX, canvasY + 10);
        ctx.stroke();
        
        ctx.lineWidth = 1;
    }
    
}


function runVerification() {
    // Сброс предыдущих результатов
    verificationContour = null;
    problematicPoint = null;

    const initialCoordsText = document.getElementById('coordsInput2').value.trim();
    const changesText = document.getElementById('clickedCoords').value.trim();

    if (!initialCoordsText || !changesText) {
        showNotification("Ошибка: Поля с исходным контуром и изменениями должны быть заполнены.", 4000);
        return;
    }

    const initialPoints = initialCoordsText.split('\n').map(line => {
        const parts = line.split('\t');
        const x = parseFloat(parts[0].replace(',', '.'));
        const y = parseFloat(parts[1].replace(',', '.'));
        return (!isNaN(x) && !isNaN(y)) ? { x, y } : null;
    }).filter(Boolean);

    // ШАГ 1: Парсим таблицу изменений на ДВА списка: новый сегмент и явно удаленные точки.
    const newSegmentPoints = [];
    const explicitlyDeletedPoints = [];
    changesText.split('\n').forEach(line => {
        const parts = line.split('\t');
        if (parts.length < 5) return;

        const oldX = parseFloat(parts[parts.length - 4].replace(',', '.'));
        const oldY = parseFloat(parts[parts.length - 3].replace(',', '.'));
        const newXStr = parts[parts.length - 2].trim().toLowerCase();
        const newYStr = parts[parts.length - 1].trim().toLowerCase();

        if (newXStr === 'л' || newYStr === 'л') {
            if (!isNaN(oldX) && !isNaN(oldY)) explicitlyDeletedPoints.push({ x: oldX, y: oldY });
            return; // Точка удалена, в новый контур не идет
        }
        
        let x, y;
        const newX = parseFloat(newXStr.replace(',', '.'));
        const newY = parseFloat(newYStr.replace(',', '.'));
        if (!isNaN(newX) && !isNaN(newY)) { x = newX; y = newY; } 
        else if (!isNaN(oldX) && !isNaN(oldY)) { x = oldX; y = oldY; }
        
        if (x !== undefined) newSegmentPoints.push({ x, y });
    });

    if (newSegmentPoints.length < 2) {
        showNotification("Ошибка: Для проверки нужно как минимум 2 точки в итоговой границе.", 4000);
        return;
    }
    
    // ШАГ 2: Находим узловые точки и СТАРЫЙ сегмент
    const findPointIndex = (p, arr) => arr.findIndex(item => Math.abs(item.x - p.x) < 0.01 && Math.abs(item.y - p.y) < 0.01);
    
    const startIndex = findPointIndex(newSegmentPoints[0], initialPoints);
    const endIndex = findPointIndex(newSegmentPoints[newSegmentPoints.length - 1], initialPoints);

    if (startIndex === -1 || endIndex === -1) {
        showNotification("КРИТИЧЕСКАЯ ОШИБКА: Начальная и/или конечная точка нового сегмента не найдены в исходном контуре!", 6000);
        return;
    }

    // ШАГ 3: Главная проверка. Находим все точки старого сегмента, которые должны были быть обработаны.
    const oldSegmentInternalPoints = (startIndex < endIndex) 
        ? initialPoints.slice(startIndex + 1, endIndex) 
        : initialPoints.slice(endIndex + 1, startIndex);

    for (const internalPoint of oldSegmentInternalPoints) {
        // Проверяем, была ли эта точка явно удалена
        const wasDeleted = findPointIndex(internalPoint, explicitlyDeletedPoints) !== -1;
        // Проверяем, была ли эта точка переопределена (т.е. присутствует в новом сегменте)
        const wasRedefined = findPointIndex(internalPoint, newSegmentPoints) !== -1;

        if (!wasDeleted && !wasRedefined) {
            // ОШИБКА! Найдена "забытая" точка
            problematicPoint = internalPoint;
            showNotification(`ОШИБКА: Точка с коорд. ${internalPoint.x.toFixed(2)}, ${internalPoint.y.toFixed(2)} не была удалена или переопределена!`, 7000);
            drawContour(initialCoordsText.split('\n'), initialCoordsText.split('\n')); // Перерисовываем для отображения ошибки
            return;
        }
    }
    
    // ШАГ 4: Если все проверки пройдены, строим новый контур
    let newContourPoints = [];
    if (startIndex < endIndex) {
        newContourPoints.push(...initialPoints.slice(0, startIndex), ...newSegmentPoints, ...initialPoints.slice(endIndex + 1));
    } else {
        newContourPoints.push(...newSegmentPoints, ...initialPoints.slice(endIndex + 1, startIndex));
    }

    // Проверка на замкнутость
    const first = newContourPoints[0], last = newContourPoints[newContourPoints.length - 1];
    if (Math.abs(first.x - last.x) > 0.01 || Math.abs(first.y - last.y) > 0.01) {
        showNotification("ВНИМАНИЕ: Итоговый контур (оранжевый) не замкнут!", 6000);
    } else {
        showNotification("Проверка выполнена. Новый контур отрисован оранжевым.", 3000);
    }

    verificationContour = newContourPoints.map(p => [p.x, p.y]);
    drawContour(document.getElementById('coordsInput1').value.split('\n'), initialCoordsText.split('\n'));
}

function startDragging(e) {
    isDragging = true;
    lastX = e.clientX;
    lastY = e.clientY;
}

function drag(e) {
    if (isDragging) {
        const deltaX = e.clientX - lastX;
        const deltaY = e.clientY - lastY;
        offsetX += deltaX / scale;
        offsetY -= deltaY / scale;
        lastX = e.clientX;
        lastY = e.clientY;
        handleInput();
    }
}

function stopDragging() {
    isDragging = false;
}

function zoom(e) {
    e.preventDefault();
    const zoomIntensity = 0.1;
    const wheel = e.deltaY < 0 ? 1 : -1;
    const zoomFactor = Math.exp(wheel * zoomIntensity);
    
    const rect = canvas.getBoundingClientRect();
    const mouseX = e.clientX - rect.left;
    const mouseY = e.clientY - rect.top;

    const newScale = scale * zoomFactor;

    if (newScale > 0.1 && newScale < 10) {
        offsetX = (offsetX - mouseX / scale) * zoomFactor + mouseX / newScale;
        offsetY = (offsetY - (canvas.height - mouseY) / scale) * zoomFactor + (canvas.height - mouseY) / newScale;

        scale = newScale;
        handleInput();
    }
}

function loadFromMIF(textareaId) {
    const fileInput = document.createElement('input');
    fileInput.type = 'file';
    fileInput.accept = '.mif';
    fileInput.onchange = function(event) {
        const file = event.target.files[0];
        const reader = new FileReader();
        reader.onload = function(e) {
            const content = e.target.result;
            const coordinates = parseMIFCoordinates(content);
            const textarea = document.getElementById(textareaId);
            textarea.value = coordinates.map(coord => `${coord.x.toFixed(2)}\t${coord.y.toFixed(2)}`).join('\n');
            handleInput();
        };
        reader.readAsText(file);
    };
    fileInput.click();
}

function loadFromXML(textareaId) {
    const fileInput = document.createElement('input');
    fileInput.type = 'file';
    fileInput.accept = '.xml, .zip';
    fileInput.onchange = function(event) {
        const file = event.target.files[0];
        const reader = new FileReader();

        reader.onload = function(e) {
            const content = e.target.result;
            if (file.name.endsWith('.zip')) {
                processZipFile(content, textareaId);
            } else if (file.name.endsWith('.xml')) {
                const coordinates = extractCoordinatesFromXML(content);
                const textarea = document.getElementById(textareaId);
                textarea.value = coordinates.map(coord => `${coord.x.toFixed(2)}\t${coord.y.toFixed(2)}`).join('\n');
                handleInput();
            } else {
                alert('Неподдерживаемый формат файла. Пожалуйста, выберите XML или ZIP.');
            }
        };

        if (file.name.endsWith('.zip')) {
            reader.readAsBinaryString(file);
        } else if (file.name.endsWith('.xml')) {
            reader.readAsText(file);
        }
    };
    fileInput.click();
}

function processZipFile(zipContent, textareaId) {
    JSZip.loadAsync(zipContent).then(function(zip) {
        let xmlFile = null;
        zip.forEach(function(relativePath, zipEntry) {
            if (relativePath.endsWith('.xml') && !zipEntry.dir) {
                xmlFile = zipEntry;
            }
        });

        if (xmlFile) {
            xmlFile.async('string').then(function(xmlContent) {
                const coordinates = extractCoordinatesFromXML(xmlContent);
                const textarea = document.getElementById(textareaId);
                textarea.value = coordinates.map(coord => `${coord.x.toFixed(2)}\t${coord.y.toFixed(2)}`).join('\n');
                handleInput();
            });
        } else {
            alert('XML-файл не найден в архиве ZIP.');
        }
    }).catch(function(error) {
        console.error('Ошибка при обработке ZIP-файла:', error);
        alert('Ошибка при обработке ZIP-файла.');
    });
}

function extractCoordinatesFromXML(content) {
    const parser = new DOMParser();
    const xmlDoc = parser.parseFromString(content, "text/xml");
    const result = [];
    const ordinates = xmlDoc.getElementsByTagName("Ordinate");
    if (ordinates.length > 0) {
        for (let i = 0; i < ordinates.length; i++) {
            const xEl = ordinates[i].getElementsByTagName("X")[0] || ordinates[i].getElementsByTagName("x")[0];
            const yEl = ordinates[i].getElementsByTagName("Y")[0] || ordinates[i].getElementsByTagName("y")[0];
            if (xEl && yEl) {
                const x = parseFloat(xEl.textContent);
                const y = parseFloat(yEl.textContent);
                result.push({x: x, y: y});
            }
        }
    } else {
        const contoursLocationElement = xmlDoc.getElementsByTagName("contours_location")[0];
        if (contoursLocationElement) {
            const contourOrdinates = contoursLocationElement.getElementsByTagName("ordinate");
            for (let j = 0; j < contourOrdinates.length; j++) {
                const xEl = contourOrdinates[j].getElementsByTagName("x")[0];
                const yEl = contourOrdinates[j].getElementsByTagName("y")[0];
                 if (xEl && yEl) {
                    const x = parseFloat(xEl.textContent);
                    const y = parseFloat(yEl.textContent);
                    result.push({x: x, y: y});
                }
            }
        }
    }
    return result;
}

function parseMIFCoordinates(content) {
    const lines = content.split('\n');
    let coordinates = [];
    let inRegion = false;
    let coordinateCount = 0;

    for (let line of lines) {
        line = line.trim();
        if (line.toLowerCase().startsWith('region')) {
            inRegion = true;
            continue;
        }
        if (inRegion) {
            if (/^\d+$/.test(line) && coordinateCount === 0) {
                 coordinateCount = parseInt(line);
                 continue;
            }
            if (coordinateCount > 0) {
                const parts = line.split(/\s+/).map(Number);
                if(parts.length >= 2){
                    coordinates.push({
                        x: parts[1],
                        y: parts[0]
                    });
                }
                coordinateCount--;
            }
        }
    }
    return coordinates;
}

function handleInput() {
       verificationContour = null;
         problematicPoint = null; 
    const input1 = document.getElementById('coordsInput1').value.trim();
    const input2 = document.getElementById('coordsInput2').value.trim();
    const coords1 = input1.split('\n').filter(line => line.trim() !== '');
    const coords2 = input2.split('\n').filter(line => line.trim() !== '');

    parseClickedCoordsForRemovedPoints();

    if (coords1.length > 0 || coords2.length > 0) {
        drawContour(coords1, coords2);
    }

    localStorage.setItem('coordsInput1', input1);
    localStorage.setItem('coordsInput2', input2);
    localStorage.setItem('clickedCoords', document.getElementById('clickedCoords').value);
}

function showModal() {
    const modal = document.getElementById('modal');
    modal.style.display = 'flex'; 
    const modalContent = modal.querySelector('.modal-content');
    modalContent.style.animation = 'none';
    setTimeout(() => {
        modalContent.style.animation = 'zoomIn 0.3s ease';
    }, 10);
}

function hideModal() {
    document.getElementById('modal').style.display = 'none';
}

function addPoint(type) {
    const coordsTextArea = document.getElementById('clickedCoords');
    let newLine = '';
    switch (type) {
        case 'initial':
            newLine = `\t${pointCounter}\t${clickedX.toFixed(2)}\t${clickedY.toFixed(2)}\t${clickedX.toFixed(2)}\t${clickedY.toFixed(2)}`;
            pointCounter++;
            isSelectingPoints = true;
            selectedPoints.push([clickedX, clickedY]);
            break;
        case 'removed':
            newLine = `\t${pointCounter}\t${clickedX.toFixed(2)}\t${clickedY.toFixed(2)}\tл\tл`;
            pointCounter++;
            break;
        case 'new':
            // If a point is hovered, use its 1-based index as the designation.
            // The 'н' prefix in the first column indicates the "new" type.
            // The designation itself should not be prefixed with 'н' again.
            let pointNumber = hoveredPoint ? (hoveredPoint.index + 1).toString() : '';
            newLine = `н\t${pointNumber}\t\t\t${clickedX.toFixed(2)}\t${clickedY.toFixed(2)}`;
            isSelectingPoints = true;
            selectedPoints.push([clickedX, clickedY]);
            break;
    }
    coordsTextArea.value += newLine + '\n';
    coordsTextArea.scrollTop = coordsTextArea.scrollHeight;
    hideModal();

    handleInput();

    localStorage.setItem('clickedCoords', coordsTextArea.value);
}

function copyClickedCoords() {
    const coordsTextArea = document.getElementById('clickedCoords');
    navigator.clipboard.writeText(coordsTextArea.value).then(() => {
        showNotification('Координаты скопированы в буфер обмена');
        const copyButton = document.querySelector('.btn-copy');
        copyButton.classList.add('flash-button');
        setTimeout(() => {
            copyButton.classList.remove('flash-button');
        }, 2000);
    });
    
    isSelectingPoints = false;
    selectedPoints = [];
    handleInput();
}

function showNotification(message, duration = 3000) {
    notificationQueue.push({ message, duration });
    if (!isNotificationActive) {
        processNotificationQueue();
    }
}


function processNotificationQueue() {
    if (notificationQueue.length === 0) {
        isNotificationActive = false;
        return;
    }

    isNotificationActive = true;
    const notificationData = notificationQueue.shift();
    const notificationElement = document.getElementById('notification');

    notificationElement.textContent = notificationData.message;
    notificationElement.style.display = 'block';

    setTimeout(() => {
        notificationElement.style.display = 'none';
        // После того как уведомление скрылось, обрабатываем следующее в очереди
        processNotificationQueue();
    }, notificationData.duration);
}

function showDataMismatchNotification(message) {
    const notificationDiv = document.getElementById('dataMismatchNotification');
    notificationDiv.innerHTML = message; 
    notificationDiv.style.display = 'block';
}

function hideDataMismatchNotification() {
    const notificationDiv = document.getElementById('dataMismatchNotification');
    notificationDiv.style.display = 'none';
}


function resizeCanvas() {
    const canvas = document.getElementById('canvas');
    canvas.width = canvas.offsetWidth;
    canvas.height = canvas.offsetHeight;
    handleInput();
}

function calculateArea(points) {
    let area = 0;
    for (let i = 0; i < points.length; i++) {
        const [x1, y1] = points[i];
        const [x2, y2] = points[(i + 1) % points.length];
        area += x1 * y2 - y1 * x2;
    }
    return Math.abs(area) / 2;
}

function calculatePerimeter(points) {
    let perimeter = 0;
    for (let i = 0; i < points.length; i++) {
        const [x1, y1] = points[i];
        const [x2, y2] = points[(i + 1) % points.length];
        perimeter += Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);
    }
    return perimeter;
}

function displayLog(points1, points2) {
    const logElement = document.getElementById('log');
    logElement.innerHTML = '';

    function addObjectInfo(points, objectName, color) {
        if (points.length > 0) {
            const area = calculateArea(points);
            const perimeter = calculatePerimeter(points);
            logElement.innerHTML += `<span style="color: ${color};">${objectName}: S = ${area.toFixed(2)} м², P = ${perimeter.toFixed(2)} м</span><br>`;
        }
    }

    addObjectInfo(points1, "Уточняемый/образуемый ЗУ", "red");
    addObjectInfo(points2, "Смежный/исходный ЗУ", "blue");
}


function exportToCSV() {
    const coordsTextArea = document.getElementById('clickedCoords');
    const lines = coordsTextArea.value.trim().split('\n');

    let csvContent = "Контур;Префикс номера;Номер;Старый X;Старый Y;Новый X;Новый Y;Метод определения;Формула;Радиус;Погрешность;Описание закрепления\n;;;;;;;;;;;\n";

    lines.forEach((line) => {
        line = line.trim();
        const parts = line.split(/\s+/);

        let csvLine = '[1];';

        if (parts[0] === 'н') {
            csvLine += 'н;' + parts[1] + ';;;' + parts[2] + ';' + parts[3] + ';;;;0.1;Долговременный межевой знак';
        } else {
            csvLine += ';' + parts[0] + ';';

            if (parts.length === 5) {
                csvLine += `${parts[1]};${parts[2]};${parts[3]};${parts[4]}`;
            } else if (parts.length === 6) {
                csvLine += `${parts[1]};${parts[2]};л;л`;
            }

            csvLine += ';;;;0.3;Данные отсутствуют';
        }

        csvContent += csvLine + '\n';
    });

    const blob = new Blob([new Uint8Array([0xEF, 0xBB, 0xBF]), csvContent], { type: 'text/csv;charset=utf-8;' });
    const link = document.createElement("a");
    if (link.download !== undefined) {
        const url = URL.createObjectURL(blob);
        link.setAttribute("href", url);
        link.setAttribute("download", "coordinates.csv");
        link.style.visibility = 'hidden';
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
    }
}

function deleteSelectedLine() {
    const coordsTextArea = document.getElementById('clickedCoords');
    const start = coordsTextArea.selectionStart;
    const text = coordsTextArea.value;
    let lineStart = text.lastIndexOf('\n', start - 1);
    if (lineStart === -1) lineStart = 0; else lineStart +=1;
    let lineEnd = text.indexOf('\n', start);
    if (lineEnd === -1) lineEnd = text.length;

    coordsTextArea.value = text.substring(0, lineStart) + text.substring(lineEnd + (text[lineEnd] === '\n' ? 1 : 0));
    updatePointCounter();
    localStorage.setItem('clickedCoords', coordsTextArea.value);
    handleInput();
}

function updatePointCounter() {
    const coordsTextArea = document.getElementById('clickedCoords');
    const lines = coordsTextArea.value.trim().split('\n').filter(Boolean);
    pointCounter = 1;
     lines.forEach(line => {
        const parts = line.trim().split('\t');
        if (parts.length > 1 && !isNaN(parseInt(parts[1]))) {
            const num = parseInt(parts[1]);
            if (num >= pointCounter) {
                pointCounter = num + 1;
            }
        }
    });
    if (lines.length === 0) pointCounter = 1;
}


function loadFromLocalStorage() {
    const coordsInput1 = localStorage.getItem('coordsInput1');
    const coordsInput2 = localStorage.getItem('coordsInput2');
    const clickedCoords = localStorage.getItem('clickedCoords');

    if (coordsInput1) document.getElementById('coordsInput1').value = coordsInput1;
    if (coordsInput2) document.getElementById('coordsInput2').value = coordsInput2;
    if (clickedCoords) document.getElementById('clickedCoords').value = clickedCoords;
    
    updatePointCounter();
    handleInput();
}


function showCustomDialog() {
    const modal = document.getElementById('customDialog');
    modal.style.display = 'flex';
}

function hideCustomDialog() {
    const modal = document.getElementById('customDialog');
    modal.style.display = 'none';
}

function copyText() {
    const points = document.getElementById('pointsInput').value;
    const cadastralNumber = document.getElementById('cadastralNumberInput').value;
    const address = document.getElementById('addressInput').value;

    const text = `В ходе кадастровых работ обнаружена реестровая ошибка, а именно выявлено несоответствие сведений в части границы смежного ЗУ, которые содержатся в ЕГРН с его фактическим местоположением на местности, в отношении ЗУ с кадастровым номером ${cadastralNumber}. Реестровая ошибка исправлялась только в части границы ${points}, другие границы в ходе кадастровых работ не уточнялись и не изменялись. Исправление ошибки в местоположении границ смежного ЗУ с КН ${cadastralNumber} осуществлялось согласно пункту 2 статьи 43 Федерального закона от 13.07.2015 № ФЗ-218 «О государственной регистрации недвижимости». В соответствии с изложенным, в отношении ЗУ с КН ${cadastralNumber}, расположенного по адресу: ${address} проведены кадастровые работы в связи с уточнением местоположения части границы ЗУ с целью исправления реестровой ошибки в сведениях ЕГРН, по результатам которых исправленный каталог координат включен в межевой план.`;

    navigator.clipboard.writeText(text).then(() => {
        showNotification('Текст скопирован в буфер обмена');
        hideCustomDialog();
    });
}

function showKnInputDialog(textareaId) {
    currentTextareaIdForKNLoad = textareaId;
    const dialog = document.getElementById('knInputDialog');
    dialog.style.display = 'flex'; 
    const knInput = document.getElementById('knInput');
    if(knInput) { 
        knInput.value = '';
        knInput.focus();
    }
}

function hideKnInputDialog() {
    const dialog = document.getElementById('knInputDialog');
    dialog.style.display = 'none';
    // Do not reset currentTextareaIdForKNLoad here, it's needed by handleKnConfirm
}

async function handleKnConfirm() {
    const knInput = document.getElementById('knInput');
    if (!knInput) {
        console.error("knInput element not found");
        showNotification("Ошибка: элемент ввода КН не найден.");
        hideKnInputDialog(); // Ensure dialog is hidden
        return;
    }
    const fullCadNumber = knInput.value.trim();

    if (!isValidCadastralNumberSupabase(fullCadNumber)) {
        showNotification("Неверный формат кадастрового номера. Ожидается XX:XX:XXXXXX(X):YY");
        // Do not hide dialog, let user correct.
        return;
    }

    hideKnInputDialog(); // Hide dialog after successful validation or before async call

    if (!currentTextareaIdForKNLoad) {
        console.error("currentTextareaIdForKNLoad is not set.");
        showNotification("Ошибка: не указано целевое текстовое поле.");
        return;
    }

    try {
        showNotification("Загрузка ...");
        const { parcelContours, parcelDataForCheck } = await loadFromSupabaseByKN(fullCadNumber);

        if (parcelContours && parcelContours.length > 0 && parcelContours.some(c => c.length > 0)) {
            const textarea = document.getElementById(currentTextareaIdForKNLoad);
            if (!textarea) {
                console.error(`Textarea with ID ${currentTextareaIdForKNLoad} not found.`);
                showNotification("Ошибка: целевое текстовое поле не найдено.");
                return;
            }
            const coordsStrings = [];
            parcelContours.forEach(contour => {
                if (contour.length > 0) {
                    contour.forEach(point => {
                        coordsStrings.push(`${point.x.toFixed(2)}\t${point.y.toFixed(2)}`);
                    });
                }
            });
            textarea.value = coordsStrings.join('\n');
            handleInput();
            showNotification("Координаты загружены из XML КПТ");

            if (parcelDataForCheck) {
                await checkNSPDData(fullCadNumber, parcelDataForCheck.areaNumeric, parcelDataForCheck.totalPoints, parcelDataForCheck.isDeclared);
            }

        } else {
            showNotification(`Координаты для ${fullCadNumber} не найдены или пусты в базе.`);
            hideDataMismatchNotification();
        }
    } catch (error) {
        console.error("Ошибка загрузки из Supabase:", error);
        showNotification(`Ошибка: ${error.message}`);
        hideDataMismatchNotification();
    } finally {
        currentTextareaIdForKNLoad = null; // Reset after operation
    }
}


function formatCadastralNumberSupabase(inputElement) {
    let value = inputElement.value.replace(/[^\d]/g, '');
    let formatted = '';
    const originalLength = value.length;

    if (originalLength > 0) formatted += value.substring(0, Math.min(2, originalLength));
    if (originalLength > 2) formatted += ':' + value.substring(2, Math.min(4, originalLength));
    
    const firstTwoDigits = value.substring(0, 2);
    const isSevenDigitQ = sevenDigitsRegions.includes(firstTwoDigits);
    const quarterMaxLength = isSevenDigitQ ? 7 : 6;

    if (originalLength > 4) formatted += ':' + value.substring(4, Math.min(4 + quarterMaxLength, originalLength));
    if (originalLength > (4 + quarterMaxLength)) formatted += ':' + value.substring(4 + quarterMaxLength);
    
    inputElement.value = formatted;
}

function isValidCadastralNumberSupabase(text) {
    if (!text) return false;
    const firstTwoDigits = text.slice(0, 2);
    const isSevenDigitQ = sevenDigitsRegions.includes(firstTwoDigits);
    const digitsAfterSecondColon = isSevenDigitQ ? 7 : 6;
    const patternFull = new RegExp(`^\\d{2}:\\d{2}:\\d{${digitsAfterSecondColon}}:\\d+$`);
    const patternQuarter = new RegExp(`^\\d{2}:\\d{2}:\\d{${digitsAfterSecondColon}}$`);
    return patternFull.test(text) || patternQuarter.test(text);
}

async function loadFromSupabaseByKN(fullCadNumber) {
  

    const parts = fullCadNumber.split(':');
    if (parts.length < 3) throw new Error("Не удалось извлечь кадастровый квартал из номера.");
    const quarterNumber = parts.slice(0, 3).join(':');

    const { xmlContent, kptFileName } = await fetchAndProcessKPTFromServer(quarterNumber, fullCadNumber);
    const { parcelContours, parcelData } = await processXMLDataFromSupabase(xmlContent, fullCadNumber, kptFileName);
    
    const parcelDataForCheck = parcelData ? {
        areaNumeric: parcelData.areaNumeric,
        totalPoints: parcelContours.reduce((sum, contour) => sum + (contour.length || 0) , 0),
        isDeclared: parcelData.areaString ? parcelData.areaString.startsWith("Декларированная:") : false
    } : null;

    return { parcelContours, parcelDataForCheck };
}

async function fetchAndProcessKPTFromServer(quarterNumber, fullCadNumber) {
    const serverQuarterPrefix = quarterNumber.replace(/:/g, '_');

    // 1. Получаем список файлов с вашего сервера
    const responseList = await fetch(`${STORAGE_API_URL}/${BUCKET_NAME}?search=${serverQuarterPrefix}`);
    if (!responseList.ok) {
        throw new Error(`Ошибка получения списка файлов: ${responseList.statusText}`);
    }
    const fileList = await responseList.json();

    if (!fileList || fileList.length === 0) {
        throw new Error(`КПТ для квартала ${quarterNumber} не найдены на сервере.`);
    }

    // 2. Находим самый свежий файл
    const matchingFiles = fileList.filter(file =>
        file.name.startsWith(serverQuarterPrefix) && file.name.toLowerCase().endsWith('.zip')
    );
    if (matchingFiles.length === 0) {
        throw new Error(`ZIP-архивы КПТ для квартала ${quarterNumber} не найдены.`);
    }
    const latestFile = findLatestKptFileSupabase(matchingFiles); // Используем существующую функцию поиска
    if (!latestFile) {
        throw new Error("Не удалось определить последний файл КПТ.");
    }

    // 3. Скачиваем выбранный файл с вашего сервера
    const responseDownload = await fetch(`${STORAGE_API_URL}/${BUCKET_NAME}/${latestFile.name}`);
    if (!responseDownload.ok) {
        throw new Error(`Ошибка загрузки файла ${latestFile.name}: ${responseDownload.statusText}`);
    }
    const blob = await responseDownload.blob();
    if (!blob) {
        throw new Error("Не удалось получить содержимое файла КПТ с сервера.");
    }

    // 4. Распаковываем и обрабатываем XML
    const zip = await JSZip.loadAsync(blob);
    let xmlFileEntry = null;
    for (const fileNameInZip in zip.files) {
        if (fileNameInZip.toLowerCase().endsWith('.xml') && !zip.files[fileNameInZip].dir) {
            xmlFileEntry = zip.files[fileNameInZip];
            break;
        }
    }
    if (!xmlFileEntry) {
        throw new Error("XML-файл не найден в архиве КПТ.");
    }
    const xmlContent = await xmlFileEntry.async('string');
    return { xmlContent, kptFileName: latestFile.name };
}

function findLatestKptFileSupabase(files) {
    if (!files || files.length === 0) return null;
    const dateRegex = /(\d{4}-\d{2}-\d{2})/;
    return files
        .map(file => ({ name: file.name, date: (file.name.match(dateRegex) ? new Date(file.name.match(dateRegex)[1]) : new Date(0)) }))
        .sort((a, b) => b.date - a.date)[0];
}

async function processXMLDataFromSupabase(xmlContent, fullCadNumber, kptFileName) {
    const parser = new DOMParser();
    const xmlDoc = parser.parseFromString(xmlContent, "text/xml");

    const landRecords = xmlDoc.querySelectorAll('land_record');
    let foundLandRecord = null;
    landRecords.forEach(record => {
        const cadNumberElem = record.querySelector('object > common_data > cad_number');
        if (cadNumberElem && cadNumberElem.textContent.trim() === fullCadNumber) {
            foundLandRecord = record;
        }
    });

    if (!foundLandRecord) {
        throw new Error(`Supabase: Участок ${fullCadNumber} не найден в XML файле ${kptFileName}.`);
    }

    const parcelContours = extractParcelCoordinatesXMLFromSupabase(foundLandRecord);
    const parcelData = extractParcelDataForCheck(foundLandRecord);

    return { parcelContours, parcelData };
}

function extractParcelDataForCheck(landRecordNode) {
    const data = {};
    const areaElement = landRecordNode.querySelector('params > area');
    const areaValueText = getElementValueSupabase(areaElement, 'value');
    data.areaNumeric = areaValueText ? parseFloat(areaValueText.replace(',', '.')) : null;
    const inaccuracy = getElementValueSupabase(areaElement, 'inaccuracy');
    data.areaString = data.areaNumeric !== null ? (inaccuracy ? `Уточненная: ${data.areaNumeric} ±${inaccuracy} кв.м.` : `Декларированная: ${data.areaNumeric} кв.м.`) : 'Нет данных';
    return data;
}

function extractParcelCoordinatesXMLFromSupabase(landRecordNode) {
    const result = [];
    const contoursLocationNode = landRecordNode.querySelector("contours_location");
    if (contoursLocationNode) {
        const processSpatialElements = (spatialElementParentNode) => {
            const spatialElementNodes = spatialElementParentNode.querySelectorAll("spatial_element");
            spatialElementNodes.forEach(spatialElementNode => {
                const ordinatesNode = spatialElementNode.querySelector("ordinates");
                if (ordinatesNode) {
                    const contourCoords = [];
                    const ordinateNodes = ordinatesNode.querySelectorAll("ordinate");
                    ordinateNodes.forEach(ordNode => {
                        const xValNode = ordNode.querySelector("x");
                        const yValNode = ordNode.querySelector("y");
                        if (xValNode && yValNode) {
                            const x = parseFloat(xValNode.textContent.trim());
                            const y = parseFloat(yValNode.textContent.trim());
                            if (!isNaN(x) && !isNaN(y)) contourCoords.push({ x: x, y: y });
                        }
                    });
                    if (contourCoords.length > 0) result.push(contourCoords);
                }
            });
        };
        const contourNodes = contoursLocationNode.querySelectorAll("contours > contour");
        if (contourNodes.length > 0) {
            contourNodes.forEach(contourNode => {
                let elementsParent = contourNode.querySelector("entity_spatial > spatials_elements");
                if (!elementsParent) elementsParent = contourNode.querySelector("entity_spatial");
                if (!elementsParent) elementsParent = contourNode;
                if (elementsParent) processSpatialElements(elementsParent);
            });
        }

        if (result.length === 0) {
            let directParent = contoursLocationNode.querySelector("entity_spatial > spatials_elements");
            if (!directParent) directParent = contoursLocationNode.querySelector("entity_spatial");
            if (!directParent) directParent = contoursLocationNode.querySelector("spatials_elements");
            if (!directParent && contoursLocationNode.querySelector("spatial_element")) {
                directParent = contoursLocationNode;
            }
            if (directParent) processSpatialElements(directParent);
        }
    }
    
    if (result.length === 0) {
        const spatialDataNode = landRecordNode.querySelector("spatial_data");
        if (spatialDataNode) {
            const processSpatialElementsSpatialData = (spatialElementParentNode) => {
                const spatialElementNodes = spatialElementParentNode.querySelectorAll("spatial_element");
                spatialElementNodes.forEach(spatialElementNode => {
                    const ordinatesNode = spatialElementNode.querySelector("ordinates");
                    if (ordinatesNode) {
                        const contourCoords = [];
                        const ordinateNodes = ordinatesNode.querySelectorAll("ordinate");
                        ordinateNodes.forEach(ordNode => {
                            const xValNode = ordNode.querySelector("x");
                            const yValNode = ordNode.querySelector("y");
                            if (xValNode && yValNode) {
                                const x = parseFloat(xValNode.textContent.trim());
                                const y = parseFloat(yValNode.textContent.trim());
                                if (!isNaN(x) && !isNaN(y)) contourCoords.push({ x: x, y: y });
                            }
                        });
                        if (contourCoords.length > 0) result.push(contourCoords);
                    }
                });
            };
            let elementsParent = spatialDataNode.querySelector("entity_spatial > spatials_elements");
            if(!elementsParent) elementsParent = spatialDataNode.querySelector("entity_spatial");
            if(!elementsParent) elementsParent = spatialDataNode;
            if (elementsParent) processSpatialElementsSpatialData(elementsParent);
        }
    }
    return result;
}

function getElementValueSupabase(element, tagName) {
    if (!element) return '';
    const parts = tagName.split('>');
    let currentElement = element;
    for (let part of parts) {
        currentElement = currentElement.querySelector(part);
        if (!currentElement) return '';
    }
    return currentElement.textContent.trim();
}

async function handleKnEgrnConfirm() {
    const knInput = document.getElementById('knInput');
    const fullCadNumber = knInput.value.trim();

    if (!isValidCadastralNumberSupabase(fullCadNumber)) {
        showNotification("Неверный формат кадастрового номера.");
        return;
    }

    hideKnInputDialog();

    if (!currentTextareaIdForKNLoad) {
        showNotification("Ошибка: не указано целевое текстовое поле.");
        return;
    }
    
    showNotification(`Загрузка данных из ЕГРН для ${fullCadNumber}...`);
    try {
        // fetchEgrnCoordinates вернет массив контуров
        const contoursArray = await fetchEgrnCoordinates(fullCadNumber);
        
        if (contoursArray && contoursArray.length > 0) {
            // Форматируем массив контуров в единую строку
            const newCoordsText = contoursArray.map(contourPoints => 
                contourPoints.map(c => `${c.x.toFixed(2)}\t${c.y.toFixed(2)}`).join('\n')
            ).join('\n\n');

            const textarea = document.getElementById(currentTextareaIdForKNLoad);
            textarea.value = newCoordsText;
            
            handleInput(); // Перерисовываем чертеж
            showNotification(`Участок ${fullCadNumber} успешно добавлен из ЕГРН.`);
        } else {
             showNotification(`Не удалось получить координаты для ${fullCadNumber} из ЕГРН.`);
        }
    } catch (error) {
        showNotification(`Ошибка: ${error.message}`);
        console.error("Ошибка при добавлении из ЕГРН:", error);
    } finally {
        currentTextareaIdForKNLoad = null; // Сбрасываем после операции
    }
}


async function fetchEgrnCoordinates(cadNumber) {
    const url = `https://nspd.gov.ru/api/geoportal/v2/search/geoportal?thematicSearchId=1&query=${encodeURIComponent(cadNumber)}`;
    try {
        const response = await fetch(url);
        if (!response.ok) {
            throw new Error(`Ошибка сети при запросе к ЕГРН: ${response.status}`);
        }
        const data = await response.json();
        
        if (data.data?.features?.length > 0) {
            const feature = data.data.features[0];
            if (feature.geometry) {
                return autoDetectAndConvertEgrnCoords(feature.geometry, cadNumber);
            } else {
                throw new Error('Для данного участка геометрия в ЕГРН не найдена.');
            }
        } else {
            throw new Error('Участок не найден в ЕГРН.');
        }
    } catch (error) {
        throw error;
    }
}

function autoDetectAndConvertEgrnCoords(geometry, cadNumber) {
    if (typeof proj4 === 'undefined' || typeof COORDINATE_SYSTEMS === 'undefined' || typeof MskFinder === 'undefined') {
        throw new Error("Библиотеки для конвертации координат (proj4, sk, msk) не загружены.");
    }
    const mskCode = MskFinder.findMskCode(cadNumber); 
    if (!mskCode) throw new Error("Не удалось автоматически определить МСК для данного региона.");

    const searchString = "МСК " + mskCode;
    const targetSystem = COORDINATE_SYSTEMS.find(s => s.text.startsWith(searchString));
    
    if (!targetSystem) {
        throw new Error(`Не удалось найти систему координат для "${searchString}" в sk.js.`);
    }

    proj4.defs(targetSystem.value, targetSystem.def);
    
    const { offsetX = 0, offsetY = 0 } = targetSystem;
    const convertedContours = [];

    const convertRing = ring => ring.map(coord => {
        const [lon, lat] = proj4('EPSG:3857', targetSystem.value, coord);
        const val1 = lat + offsetX;
        const val2 = lon + offsetY;
        return { x: Math.min(val1, val2), y: Math.max(val1, val2) };
    });

    const processGeom = (geom) => {
        if (!geom) return;
        if (geom.type === 'Polygon') {
            geom.coordinates.forEach(ring => {
                if (ring.length > 0) convertedContours.push(convertRing(ring));
            });
        } else if (geom.type === 'MultiPolygon') {
            geom.coordinates.forEach(polygon => {
                polygon.forEach(ring => {
                    if (ring.length > 0) convertedContours.push(convertRing(ring));
                });
            });
        }
    };
    
    processGeom(geometry);
    return convertedContours;
}



async function checkNSPDData(cadNumber, xmlArea, xmlPoints, xmlIsDeclared) {
    hideDataMismatchNotification();
    const url = `https://nspd.gov.ru/api/geoportal/v2/search/geoportal?thematicSearchId=1&query=${encodeURIComponent(cadNumber)}`;
    try {
        const response = await fetch(url);
        if (!response.ok) {
            console.warn(`NSPD: Ошибка сети: ${response.status}`);
            showDataMismatchNotification(`<strong>NSPD: Ошибка сети ${response.status}.</strong> Не удалось проверить актуальность данных.`);
            return;
        }
        const data = await response.json();

        if (data.data && data.data.features && data.data.features.length > 0) {
            const feature = data.data.features[0];
            const options = feature.properties.options;
            const properties = feature.properties;

            let egrnArea = null;
            let egrnIsDeclared = false;
            const categoryName = properties.categoryName;

            if (categoryName === "Земельные участки ЕГРН") {
                if (options.specified_area && !isNaN(parseFloat(options.specified_area))) egrnArea = parseFloat(options.specified_area);
                else if (options.land_record_area_verified && !isNaN(parseFloat(options.land_record_area_verified))) egrnArea = parseFloat(options.land_record_area_verified);
                else if (options.land_record_area && !isNaN(parseFloat(options.land_record_area))) egrnArea = parseFloat(options.land_record_area);
                else if (options.land_record_area_declaration && !isNaN(parseFloat(options.land_record_area_declaration))) {
                    egrnArea = parseFloat(options.land_record_area_declaration);
                    egrnIsDeclared = true;
                } else if (options.declared_area && !isNaN(parseFloat(options.declared_area))) {
                    egrnArea = parseFloat(options.declared_area);
                    egrnIsDeclared = true;
                }
            }

            let egrnPoints = 0;
            if (feature.geometry) {
                function countEgrnCoords(geom) {
                    let count = 0;
                    if (!geom || !geom.type) return 0;
                    switch (geom.type) {
                        case "Polygon": geom.coordinates.forEach(ring => count += ring.length); break;
                        case "MultiPolygon": geom.coordinates.forEach(polygon => polygon.forEach(ring => count += ring.length)); break;
                        case "GeometryCollection": if (geom.geometries) geom.geometries.forEach(g => count += countEgrnCoords(g)); break;
                    }
                    return count;
                }
                egrnPoints = countEgrnCoords(feature.geometry);
            }

            let areaMismatch = false;
            if (xmlArea !== null && egrnArea !== null) {
                if (Math.round(xmlArea) !== Math.round(egrnArea)) {
                    areaMismatch = true;
                }
            } else if (xmlArea !== null || egrnArea !== null) { // If one is null and other is not, it's a mismatch
                areaMismatch = true; 
            }
             
            if (xmlIsDeclared && !egrnIsDeclared && (xmlArea !== null && egrnArea !== null) && Math.round(xmlArea) !== Math.round(egrnArea)) {
                areaMismatch = true; 
            } else if (xmlIsDeclared && egrnIsDeclared && (xmlArea !== null && egrnArea !== null) && Math.round(xmlArea) !== Math.round(egrnArea)) {
                areaMismatch = true;
            } else if (!xmlIsDeclared && !egrnIsDeclared && (xmlArea !== null && egrnArea !== null) && Math.round(xmlArea) !== Math.round(egrnArea)) {
                 areaMismatch = true;
            } else if (!xmlIsDeclared && egrnIsDeclared && (xmlArea !== null && egrnArea !== null) && Math.round(xmlArea) !== Math.round(egrnArea)) {
                 areaMismatch = true;
            }


            const pointsMismatch = xmlPoints !== egrnPoints;

            if (areaMismatch || pointsMismatch) {
                let message = "<strong>Данные XML неактуальны</strong><br>";
                if (areaMismatch) message += `Площадь XML: ${xmlArea !== null ? Math.round(xmlArea) : 'N/A'} (${xmlIsDeclared ? 'декл.' : 'уточн.'}), ЕГРН: ${egrnArea !== null ? Math.round(egrnArea) : 'N/A'} (${egrnIsDeclared ? 'декл.' : 'уточн.'}).<br>`;
                if (pointsMismatch) message += `Точки XML: ${xmlPoints}, ЕГРН: ${egrnPoints}.`;
                
                showDataMismatchNotification(message);
            } else {
                 showNotification("Данные XML (площадь и количество точек) совпадают со сведениями ЕГРН", 7000);
            }

        } else {
            console.warn(`NSPD: Участок ${cadNumber} не найден.`);
            showDataMismatchNotification(`<strong>Внимание!</strong> Участок ${cadNumber} не найден в ЕГРН. Данные XML не могут быть проверены на актуальность.`);
        }
    } catch (error) {
        console.error("Ошибка при проверке данных NSPD:", error);
        showDataMismatchNotification(`<strong>Ошибка при проверке данных ЕГРН:</strong> ${error.message}`);
    }
}


window.addEventListener('resize', resizeCanvas);
document.addEventListener('DOMContentLoaded', () => {
    resizeCanvas();
    loadFromLocalStorage();
    
     
    const coordsInput1 = document.getElementById('coordsInput1');
    if (coordsInput1.value.trim() === '' && navigator.clipboard && typeof navigator.clipboard.readText === 'function') {
        navigator.clipboard.readText().then(text => {
            if (isValidCoordinateFormat(text)) {
                coordsInput1.value = text;
                handleInput(); // Обновляем канвас и состояние
            }
        }).catch(err => {
            // Ошибки (например, отсутствие прав доступа к буферу) игнорируются, как и требовалось
            console.warn('Не удалось прочитать буфер обмена при загрузке:', err);
        });
    }

    const canvas = document.getElementById('canvas');
    canvas.addEventListener('mousedown', startDragging);
    canvas.addEventListener('mousemove', drag);
    canvas.addEventListener('mouseup', stopDragging);
    canvas.addEventListener('mouseleave', stopDragging);
    canvas.addEventListener('wheel', zoom);

    const coordsTextArea = document.getElementById('clickedCoords');
    coordsTextArea.removeAttribute('readonly');
    
    document.addEventListener('keydown', function(event) {
        if (event.key === 'F9') {
            showCustomDialog();
        }
        if (event.key === 'Escape') {
            hideKnInputDialog();
            hideCustomDialog();
            hideModal();
        }
    });

    const knInputElement = document.getElementById('knInput');
    if (knInputElement) {
        knInputElement.addEventListener('input', () => formatCadastralNumberSupabase(knInputElement));
        knInputElement.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                const confirmButton = document.getElementById('knConfirmButton');
                if(confirmButton) confirmButton.click();
            }
        });
    }
const confirmButton = document.getElementById('knConfirmButton');
    if(confirmButton) confirmButton.addEventListener('click', handleKnConfirm);
    
    // ИСПРАВЛЕННЫЙ БЛОК
    const egrnButton = document.getElementById('knEgrnButton');
    if(egrnButton) egrnButton.addEventListener('click', handleKnEgrnConfirm); 
    
});

</script>
</body>
</html>