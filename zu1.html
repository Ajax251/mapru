<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ЗУ из XML и ЕГРН</title>
    <link rel="stylesheet" href="webfonts/all.min.css">
    <script src="webfonts/jszip.min.js"></script>
    <script src="webfonts/proj4.js"></script>
    <link rel="icon" href="https://i.ibb.co/xST7XFmq/zu.png" type="image/png">
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            line-height: 1.6;
            margin: 0;
            padding: 0;
            background-color: #f4f7f6;
            color: #333;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
        }

        .container {
            width: 100%;
            max-width: 600px;
            padding: 20px;
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .input-section {
            background-color: #fff;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.05);
            display: flex;
            flex-direction: column;
            gap: 10px;
            position: relative;
        }

        #cadastralInput {
            width: 100%;
            padding: 12px 15px;
            border: 1px solid #ced4da;
            border-radius: 6px;
            box-sizing: border-box;
            font-size: 17px;
            text-align: center;
            transition: border-color 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
        }

        #cadastralInput:focus {
            border-color: #007bff;
            box-shadow: 0 0 0 0.2rem rgba(0, 123, 255, 0.25);
            outline: none;
        }

        #loadParcelBtn {
            padding: 10px 15px;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
            transition: background-color 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }

        #loadParcelBtn:hover {
            background-color: #0056b3;
        }
        #loadParcelBtn:disabled {
            background-color: #305CDE;
            cursor: not-allowed;
        }

        .loader-common {
            text-align: center;
            padding: 10px;
            font-size: 16px;
            color: #007bff;
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }
         .loader-common .loader-text {
            margin-bottom: 8px;
        }
         .loader-common i.fa-spinner {
            margin-left: 8px;
            display: inline-block;
         }
        .loader-common .progress-bar-container {
            width: 80%;
            margin: 10px auto 0;
            background-color: #e0e0e0;
            border-radius: 4px;
            overflow: hidden;
            height: 10px;
            display: none;
        }
        .loader-common .progress-bar {
            width: 0%;
            height: 100%;
            background-color: #007bff;
            transition: width 0.2s ease-out;
        }

        .error-messages-common {
            color: #dc3545;
            padding: 10px;
            background-color: #f8d7da;
            border: 1px solid #f5c6cb;
            border-radius: 4px;
            margin-top: 10px;
        }

        .results-parent-container {
            width: 100%;
            max-width: 1240px;
            padding: 0 20px;
            box-sizing: border-box;
            margin-top: 20px;
        }

        .results-container {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .info-section, .drawing-section {
            background-color: #fff;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.05);
        }

        .info-section h2 {
            margin-top: 0;
            color: #0056b3;
            font-size: 1.2em;
            border-bottom: 1px solid #eee;
            padding-bottom: 8px;
            margin-bottom: 15px;
            text-align: center;
        }

        .info-section h2.clickable-header {
            color: white;
            padding: 10px 15px;
            border-radius: 6px;
            font-size: 1.1em;
            cursor: pointer;
            transition: background-color 0.2s ease, transform 0.1s ease, box-shadow 0.2s ease;
            border-bottom: none;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            display: block;
            text-align: center;
            margin-bottom: 15px;
            margin-top: 0;
        }

        #h2XMLHeader.clickable-header {
            background-color: cornflowerblue;
            color: white;
        }
        #h2XMLHeader.clickable-header:hover {
            background-color: #507cb8; 
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.15);
        }
        #h2XMLHeader.clickable-header:active {
            background-color: #406394; 
            transform: translateY(0px);
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        #h2EGRNHeader.clickable-header {
            background-color: #4CBB17; /* Kelly Green */
            color: white; /* White text for better contrast on Kelly Green */
        }
        #h2EGRNHeader.clickable-header:hover {
            background-color: #3E9A13; /* Darker Kelly Green */
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.15);
        }
        #h2EGRNHeader.clickable-header:active {
            background-color: #337F0F; /* Even darker Kelly Green */
            transform: translateY(0px);
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .drawing-section h2 {
            margin-top: 0;
            color: #0056b3;
            font-size: 1.2em;
            border-bottom: 1px solid #eee;
            padding-bottom: 8px;
            margin-bottom: 15px;
            text-align: center;
        }


        #parcelCanvasXML, #parcelCanvasEGRN {
            width: 100%;
            border: 1px solid #eee;
            border-radius: 4px;
            display: block;
            background-color: #f0f8ff;
        }
        .drawing-section {
             padding: 5px;
             position: relative;
        }

        .parcel-data-table table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.9em;
        }
        .parcel-data-table th, .parcel-data-table td {
            border: 1px solid #eee;
            padding: 8px;
            text-align: left;
            word-break: break-word;
        }
        .parcel-data-table th {
            background-color: #f9f9f9;
            font-weight: 500;
            width: 40%;
        }
        .parcel-data-table tr.area-same {
            background-color: #e6ffe6 !important;
        }
        .parcel-data-table tr.area-different {
            background-color: #ffe6e6 !important;
        }

        .parcel-data-table tr.accuracy-good-row {
            background-color: #e6ffe6 !important;
        }

        .parcel-data-table tr.accuracy-bad-row {
            background-color: #ffe6e6 !important;
        }

        .parcel-data-table tr.points-same {
            background-color: #e6ffe6 !important;
        }
        .parcel-data-table tr.points-different {
            background-color: #ffe6e6 !important;
        }


        .export-section {
            display: flex;
            justify-content: space-around;
            padding: 10px;
            background-color: #fff;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.05);
            margin-top: 15px;
        }

        .export-section button {
            color: white;
            border: none;
            border-radius: 50%;
            width: 44px;
            height: 44px;
            font-size: 18px;
            cursor: pointer;
            transition: background-color 0.2s, transform 0.1s, opacity 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .export-section button:hover:not(:disabled) {
            opacity: 0.8;
            transform: translateY(-2px);
        }
         .export-section button:disabled {
            background-color: #ccc !important;
            color: #666 !important;
            cursor: not-allowed;
            transform: none;
         }

        .toggle-container {
            position: absolute;
            top: 10px;
            right: 10px;
            z-index: 10;
        }
        .toggle-container .toggle {
            display: none;
        }
        .toggle-container .toggle + label {
            display: inline-block;
            width: 40px;
            height: 20px;
            background-color: #ccc;
            border-radius: 20px;
            position: relative;
            cursor: pointer;
            transition: background-color 0.3s ease;
            border: 1px solid #bbb;
            box-shadow: inset 0 1px 3px rgba(0,0,0,0.2);
        }
        .toggle-container .toggle + label:after {
            content: '';
            display: inline-block;
            position: absolute;
            width: 16px;
            height: 16px;
            background-color: #fff;
            top: 2px;
            left: 2px;
            border-radius: 50%;
            transition: all 0.3s ease;
            box-shadow: 0 1px 2px rgba(0,0,0,0.3);
        }
        .toggle-container .toggle + label:hover:after {
             box-shadow: 0 1px 3px rgba(0,0,0,0.4);
        }
        .toggle-container .toggle:checked + label {
            background-color: #007bff;
            border-color: #0056b3;
        }
        .toggle-container .toggle:checked + label:after {
            left: 22px;
        }
        .toggle-container-xml {}
        .toggle-container-egrn {}


        #outdatedDataNotification {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(255, 193, 7, 0.95);
            color: black;
            padding: 20px 30px;
            border-radius: 8px;
            box-shadow: 0 5px 20px rgba(0,0,0,0.25);
            z-index: 1000;
            text-align: center;
            font-size: 1.1em;
            font-weight: 500;
            border: 1px solid rgba(0,0,0,0.1);
        }
        #outdatedDataNotification i {
            margin-right: 10px;
            color: #d9534f;
        }


        @media (min-width: 769px) {
            .container {
                 max-width: 800px;
            }
            .results-container {
                display: grid;
                grid-template-columns: 1fr 1fr;
                grid-template-rows: auto auto;
                grid-template-areas:
                    "xmlInfo egrnInfo"
                    "xmlDrawing egrnDrawing";
                gap: 20px;
            }
            #parcelInfoSectionXML { grid-area: xmlInfo; }
            #parcelInfoSectionEGRN { grid-area: egrnInfo; }
            #drawingSectionXML { grid-area: xmlDrawing; }
            #drawingSectionEGRN { grid-area: egrnDrawing; }
            .export-section {
                max-width: 600px;
                margin: 20px auto;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="input-section">
            <input type="text" id="cadastralInput" placeholder="Кадастровый номер">
            <button id="loadParcelBtn"><i class="fas fa-search"></i> </button>
        </div>
        <div id="loaderXML" class="loader-common">
            <span class="loader-text">Загрузка XML...</span> <i class="fas fa-spinner fa-spin"></i>
            <div class="progress-bar-container">
                <div class="progress-bar"></div>
            </div>
        </div>
        <div id="errorMessagesXML" class="error-messages-common" style="display:none;"></div>
    </div>

    <div class="results-parent-container">
        <div class="results-container" style="display:none;">
            <div id="parcelInfoSectionXML" class="info-section" style="display:none;">
                <h2 id="h2XMLHeader">XML КПТ</h2>
                <div id="parcelDataTableXML" class="parcel-data-table"></div>
            </div>

            <div id="parcelInfoSectionEGRN" class="info-section" style="display:none;">
                <h2 id="h2EGRNHeader">ЕГРН</h2>
                <div id="loaderEGRN" class="loader-common" style="padding: 5px 0;">
                    <span class="loader-text"></span><i class="fas fa-spinner fa-spin"></i>
                </div>
                <div id="errorMessagesEGRN" class="error-messages-common" style="display:none;"></div>
                <div id="parcelDataTableEGRN" class="parcel-data-table"></div>
            </div>

            <div id="drawingSectionXML" class="drawing-section" style="display:none;">
                 <div class="toggle-container toggle-container-xml">
                    <input type="checkbox" id="distanceToggleXML" class="toggle">
                    <label for="distanceToggleXML" title="Показать/скрыть длины линий и площадь/периметр (XML)"></label>
                </div>
                <canvas id="parcelCanvasXML"></canvas>
            </div>

            <div id="drawingSectionEGRN" class="drawing-section" style="display:none;">
                 <div class="toggle-container toggle-container-egrn">
                    <input type="checkbox" id="distanceToggleEGRN" class="toggle">
                    <label for="distanceToggleEGRN" title="Показать/скрыть длины линий и площадь/периметр (ЕГРН)"></label>
                </div>
                <canvas id="parcelCanvasEGRN"></canvas>
            </div>
        </div>

        <div id="exportSectionXML" class="export-section" style="display:none;">
            <button id="exportMifBtn" title="Экспорт в MIF (из XML)" disabled><i class="fas fa-file-invoice"></i></button>
            <button id="exportDxfBtn" title="Экспорт в DXF (из XML)" disabled><i class="fas fa-drafting-compass"></i></button>
            <button id="exportTxtBtn" title="Экспорт в TXT (из XML)" disabled><i class="fas fa-file-alt"></i></button>
        </div>
    </div>

    <div id="outdatedDataNotification">
        <i class="fas fa-exclamation-triangle"></i>Данные в XML неактуальны
    </div>

  <script>
    
        let currentParcelDataXML = null;
        let currentParcelContoursXML = null;
        let kptDate = '';
        let kptRegNum = '';
        let currentEgrnFeature = null;

        let showDistanceLabelsXML = false;
        let showDistanceLabelsEGRN = false;

        let areaXMLValue = null;
        let areaEGRNValue = null;
        let xmlTotalPointCount = null;
        let egrnTotalPointCount = null;
        let xmlIsDeclared = false;
        let egrnIsDeclared = false;
        
        const STORAGE_API_URL = 'https://mapruapp.ru/storage'; 
const BUCKET_NAME = 'kpt'; 

        const cadastralInput = document.getElementById('cadastralInput');
        const loadParcelBtn = document.getElementById('loadParcelBtn');
        const loaderXMLDiv = document.getElementById('loaderXML');
        const loaderXMLTextSpan = loaderXMLDiv.querySelector('.loader-text');
        const progressBarContainerXML = loaderXMLDiv.querySelector('.progress-bar-container');
        const progressBarXML = loaderXMLDiv.querySelector('.progress-bar');
        const spinnerIconXML = loaderXMLDiv.querySelector('.fa-spinner');
        const errorMessagesXMLDiv = document.getElementById('errorMessagesXML');

        const drawingSectionXMLDiv = document.getElementById('drawingSectionXML');
        const parcelCanvasXML = document.getElementById('parcelCanvasXML');
        const distanceToggleXML = document.getElementById('distanceToggleXML');
        const parcelInfoSectionXMLDiv = document.getElementById('parcelInfoSectionXML');
        const parcelDataTableXMLDiv = document.getElementById('parcelDataTableXML');

        const exportSectionXMLDiv = document.getElementById('exportSectionXML');
        const exportMifBtn = document.getElementById('exportMifBtn');
        const exportDxfBtn = document.getElementById('exportDxfBtn');
        const exportTxtBtn = document.getElementById('exportTxtBtn');

        const loaderEGRNDiv = document.getElementById('loaderEGRN');
        const loaderEGRNTextSpan = loaderEGRNDiv.querySelector('.loader-text');
        const errorMessagesEGRNDiv = document.getElementById('errorMessagesEGRN');
        const drawingSectionEGRNDiv = document.getElementById('drawingSectionEGRN');
        const parcelCanvasEGRN = document.getElementById('parcelCanvasEGRN');
        const distanceToggleEGRN = document.getElementById('distanceToggleEGRN');
        const parcelInfoSectionEGRNDiv = document.getElementById('parcelInfoSectionEGRN');
        const parcelDataTableEGRNDiv = document.getElementById('parcelDataTableEGRN');

        const resultsContainerDiv = document.querySelector('.results-container');
        const outdatedDataNotificationDiv = document.getElementById('outdatedDataNotification');
        const sevenDigitsRegions = ['24', '50', '63', '66', '77', '78', '91'];

        if (typeof proj4 !== 'undefined') {
            proj4.defs("EPSG:3857", "+proj=merc +a=6378137 +b=6378137 +lat_ts=0.0 +lon_0=0.0 +x_0=0.0 +y_0=0 +k=1.0 +units=m +nadgrids=@null +wktext +no_defs");
            proj4.defs("EPSG:4326", "+proj=longlat +datum=WGS84 +no_defs");
        } else {
            console.error("Proj4 library not loaded.");
            showError("Ошибка загрузки библиотеки Proj4. Функционал карты ЕГРН может быть ограничен.", 'egrn');
        }

 

        loadParcelBtn.addEventListener('click', handleLoadParcel);
        cadastralInput.addEventListener('input', () => {
            formatCadastralNumber(cadastralInput);
        });
        cadastralInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') handleLoadParcel();
        });

        distanceToggleXML.addEventListener('change', () => {
            showDistanceLabelsXML = distanceToggleXML.checked;
            localStorage.setItem('showDistanceLabelsXML', String(showDistanceLabelsXML));
            if (currentParcelContoursXML && currentParcelContoursXML.length > 0) {
                drawParcelOnCanvasXML(currentParcelContoursXML);
            }
        });

        distanceToggleEGRN.addEventListener('change', () => {
            showDistanceLabelsEGRN = distanceToggleEGRN.checked;
            localStorage.setItem('showDistanceLabelsEGRN', String(showDistanceLabelsEGRN));
            if (currentEgrnFeature && currentEgrnFeature.geometry) {
                drawEgrnParcelOnCanvas(currentEgrnFeature.geometry);
            }
        });

        showDistanceLabelsXML = localStorage.getItem('showDistanceLabelsXML') === 'true';
        distanceToggleXML.checked = showDistanceLabelsXML;
        showDistanceLabelsEGRN = localStorage.getItem('showDistanceLabelsEGRN') === 'true';
        distanceToggleEGRN.checked = showDistanceLabelsEGRN;


        function getRandomColor() {
            const letters = '0123456789ABCDEF';
            let color = '#';
            for (let i = 0; i < 6; i++) color += letters[Math.floor(Math.random() * 16)];
            return color;
        }

        function getContrastYIQ(hexcolor) {
            hexcolor = hexcolor.replace('#', '');
            const r = parseInt(hexcolor.substr(0, 2), 16);
            const g = parseInt(hexcolor.substr(2, 2), 16);
            const b = parseInt(hexcolor.substr(4, 2), 16);
            const yiq = ((r * 299) + (g * 587) + (b * 114)) / 1000;
            return (yiq >= 128) ? 'black' : 'white';
        }

        function setRandomExportButtonColors() {
            [exportMifBtn, exportDxfBtn, exportTxtBtn].forEach(button => {
                const randomColor = getRandomColor();
                button.style.backgroundColor = randomColor;
                button.style.color = getContrastYIQ(randomColor);
            });
        }
        setRandomExportButtonColors();

        function drawRotatedText(ctx, text, x1, y1, x2, y2, font, color, yOffset = -3) {
            ctx.save();
            ctx.translate((x1 + x2) / 2, (y1 + y2) / 2);
            let angle = Math.atan2(y2 - y1, x2 - x1);
            if (angle < -Math.PI / 2 || angle > Math.PI / 2) {
                angle += Math.PI;
            }
            ctx.rotate(angle);
            ctx.fillStyle = color;
            ctx.font = font;
            ctx.textAlign = 'center';
            ctx.fillText(text, 0, yOffset);
            ctx.restore();
        }

        function makeHeaderClickable(headerElement, urlToOpen, descriptiveText) {
            if (!headerElement) return;

            headerElement.classList.add('clickable-header');
            headerElement.setAttribute('title', `Нажмите, чтобы скопировать КН и открыть ${descriptiveText} в новой вкладке`);

            if (headerElement._clickHandler) {
                headerElement.removeEventListener('click', headerElement._clickHandler);
            }

            headerElement._clickHandler = async function() {
                const cadNumber = cadastralInput.value.trim();

                if (cadNumber) {
                    try {
                        await navigator.clipboard.writeText(cadNumber);
                    } catch (err) {
                        console.error('Не удалось скопировать кадастровый номер:', err);
                        alert('Не удалось скопировать кадастровый номер. Ваш браузер может не поддерживать эту функцию или требовать разрешений.');
                    }
                }
                window.open(urlToOpen, '_blank');
            };
            headerElement.addEventListener('click', headerElement._clickHandler);
        }

        function resetButtonHeader(headerElement) {
            if (!headerElement) return;
            headerElement.classList.remove('clickable-header');
            headerElement.removeAttribute('title');

            if (headerElement._initialTextContent) {
                headerElement.textContent = headerElement._initialTextContent;
            }

            if (headerElement._clickHandler) {
                headerElement.removeEventListener('click', headerElement._clickHandler);
                delete headerElement._clickHandler;
            }
        }


        async function handleLoadParcel() {
            const fullCadNumber = cadastralInput.value.trim();
            if (!isValidCadastralNumber(fullCadNumber)) {
                showError("Неверный формат кадастрового номера. Ожидается XX:XX:XXXXXX(X):YY", 'xml');
                return;
            }
            const parts = fullCadNumber.split(':');
            if (parts.length < 3) {
                showError("Не удалось извлечь кадастровый квартал", 'xml');
                return;
            }
            const quarterNumber = parts.slice(0, 3).join(':');

            resetUI();
            resultsContainerDiv.style.display = 'grid';

            const xmlProcessingPromise = async () => {
                showLoaderXML(true, null, 0);
                parcelInfoSectionXMLDiv.style.display = 'block';
                try {
                    const { xmlContent, kptFileName } = await fetchAndProcessKPT(quarterNumber, fullCadNumber);
                    showLoaderXML(true, null, 95);
                    const { parcelData, parcelContours } = await processXMLData(xmlContent, fullCadNumber, kptFileName);

                    currentParcelDataXML = parcelData;
                    displayParcelInfoTableXML(currentParcelDataXML);

                    if (currentParcelDataXML) {
                        const h2XML = parcelInfoSectionXMLDiv.querySelector('#h2XMLHeader');
                        makeHeaderClickable(h2XML, 'схема_xml.html', 'схему XML');
                    }


                    if (currentParcelContoursXML && currentParcelContoursXML.length > 0 && currentParcelContoursXML.some(c => c.length > 0)) {
                        drawingSectionXMLDiv.style.display = 'block';
                        const originallyShowLabelsXML = showDistanceLabelsXML;
                        if (originallyShowLabelsXML) {
                            showDistanceLabelsXML = false;
                            drawParcelOnCanvasXML(currentParcelContoursXML);
                            showDistanceLabelsXML = true;
                        }
                        drawParcelOnCanvasXML(currentParcelContoursXML);
                        setExportButtonsState(true);
                        exportSectionXMLDiv.style.display = 'flex';
                    } else {
                        drawingSectionXMLDiv.style.display = 'none';
                        setExportButtonsState(false);
                        exportSectionXMLDiv.style.display = 'none';
                        if (currentParcelDataXML) {
                             showError(`Координаты для участка ${fullCadNumber} не найдены или пусты в XML`, 'xml');
                        }
                    }
                    showLoaderXML(true, ``, 100);
                    await new Promise(resolve => setTimeout(resolve, 500));
                    return { success: true };
                } catch (error) {
                    console.error("Error in XML processing:", error);
                    showError(error.message || "Произошла ошибка при загрузке XML данных", 'xml');
                    setExportButtonsState(false);
                    exportSectionXMLDiv.style.display = 'none';
                    drawingSectionXMLDiv.style.display = 'none';
                    displayParcelInfoTableXML(null);
                    return { success: false, error };
                } finally {
                    showLoaderXML(false);
                }
            };

            const egrnProcessingPromise = async () => {
                showLoaderEGRN(true, '');
                parcelInfoSectionEGRNDiv.style.display = 'block';
                try {
                    await fetchAndProcessEGRN(fullCadNumber);
                    if (currentEgrnFeature) {
                        const h2EGRN = parcelInfoSectionEGRNDiv.querySelector('#h2EGRNHeader');
                        makeHeaderClickable(h2EGRN, 'egrn.html', 'данные ЕГРН');
                    }
                    return { success: true };
                } catch (error) {
                    console.error("Error in EGRN processing:", error);
                    let egrnErrorMessage;

                    if (error.message === 'EGRN_NOT_FOUND_404' || error.message === 'Участок не найден в ЕГРН') {
                        egrnErrorMessage = "Кадастровый номер не найден в ЕГРН";
                    } else if (error.message && error.message.startsWith('Ошибка сети ЕГРН')) {
                        egrnErrorMessage = "Сервер ЕГРН не доступен.";
                    } else if (error instanceof SyntaxError) {
                        egrnErrorMessage = "Ошибка обработки ответа от сервера ЕГРН (неверный формат).";
                    }
                    else {
                        egrnErrorMessage = error.message || "Произошла непредвиденная ошибка при загрузке данных ЕГРН.";
                    }

                    showError(egrnErrorMessage, 'egrn');
                    drawingSectionEGRNDiv.style.display = 'none';
                    parcelDataTableEGRNDiv.innerHTML = `<p style="color:red;">Данные ЕГРН не загружены: ${egrnErrorMessage}</p>`;
                    compareAndHighlightAreas();
                    compareAndHighlightPointCounts();
                    return { success: false, error };
                } finally {
                    showLoaderEGRN(false);
                }
            };

            await Promise.allSettled([
                xmlProcessingPromise(),
                egrnProcessingPromise()
            ]);
        }

        function showLoaderXML(show, message = null, progress = null) {
            if (show) {
                loaderXMLDiv.style.display = 'flex';
                loadParcelBtn.disabled = true;

                if (progress !== null && progress >= 0 && progress <= 100) {
                    progressBarContainerXML.style.display = 'block';
                    progressBarXML.style.width = `${progress}%`;
                    loaderXMLTextSpan.style.display = 'none';
                    spinnerIconXML.style.display = 'none';

                    if (progress === 100 && message && message.includes("Готово")) {
                        loaderXMLTextSpan.textContent = message;
                        loaderXMLTextSpan.style.display = 'block';
                    }
                } else {
                    progressBarContainerXML.style.display = 'none';
                    progressBarXML.style.width = `0%`;
                    loaderXMLTextSpan.textContent = message || "Загрузка XML...";
                    loaderXMLTextSpan.style.display = 'block';
                    spinnerIconXML.style.display = 'inline-block';
                }
            } else {
                loaderXMLDiv.style.display = 'none';
                loadParcelBtn.disabled = false;
                progressBarContainerXML.style.display = 'none';
                progressBarXML.style.width = `0%`;
                loaderXMLTextSpan.textContent = "Загрузка XML...";
                loaderXMLTextSpan.style.display = 'block';
                spinnerIconXML.style.display = 'inline-block';
            }
        }


        function showLoaderEGRN(show, message = "Загрузка ЕГРН...") {
            if (show) {
                loaderEGRNTextSpan.textContent = message;
                loaderEGRNDiv.style.display = 'flex';
            } else {
                loaderEGRNDiv.style.display = 'none';
            }
        }

async function fetchAndProcessKPT(quarterNumber, fullCadNumber) {
    const serverQuarterPrefix = quarterNumber.replace(/:/g, '_');
    showLoaderXML(true, null, 10);

    // 1. Получаем список файлов с вашего сервера
    const responseList = await fetch(`${STORAGE_API_URL}/${BUCKET_NAME}?search=${serverQuarterPrefix}`);
    if (!responseList.ok) {
        throw new Error(`Ошибка получения списка файлов: ${responseList.statusText}`);
    }
    const fileList = await responseList.json();

    if (!fileList || fileList.length === 0) {
        throw new Error(`КПТ для квартала ${quarterNumber} не найдены на сервере.`);
    }
    showLoaderXML(true, null, 25);

    // 2. Находим самый свежий файл (логика остается прежней)
    const matchingFiles = fileList.filter(file =>
        file.name.startsWith(serverQuarterPrefix) && file.name.toLowerCase().endsWith('.zip')
    );
    if (matchingFiles.length === 0) {
        throw new Error(`ZIP-архивы КПТ для квартала ${quarterNumber} не найдены.`);
    }
    const latestFile = findLatestKptFile(matchingFiles);
    if (!latestFile) {
        throw new Error("Не удалось определить последний файл КПТ.");
    }
    showLoaderXML(true, null, 40);

    // 3. Скачиваем выбранный файл с вашего сервера
    const responseDownload = await fetch(`${STORAGE_API_URL}/${BUCKET_NAME}/${latestFile.name}`);
    if (!responseDownload.ok) {
        throw new Error(`Ошибка загрузки файла ${latestFile.name}: ${responseDownload.statusText}`);
    }
    const blob = await responseDownload.blob();
    if (!blob) {
        throw new Error("Не удалось получить содержимое файла КПТ с сервера.");
    }
    showLoaderXML(true, null, 65);

    // 4. Распаковываем и обрабатываем XML (логика остается прежней)
    const zip = await JSZip.loadAsync(blob);
    let xmlFileEntry = null;
    for (const fileNameInZip in zip.files) {
        if (fileNameInZip.toLowerCase().endsWith('.xml') && !zip.files[fileNameInZip].dir) {
            xmlFileEntry = zip.files[fileNameInZip];
            break;
        }
    }
    if (!xmlFileEntry) {
        throw new Error("XML-файл не найден в архиве КПТ.");
    }
    showLoaderXML(true, null, 85);
    const xmlContent = await xmlFileEntry.async('string');

    return { xmlContent, kptFileName: latestFile.name };
}
        async function processXMLData(xmlContent, fullCadNumber, kptFileName) {
            const parser = new DOMParser();
            const xmlDoc = parser.parseFromString(xmlContent, "text/xml");
            kptDate = '';
            kptRegNum = '';
            const dateFormationElem = xmlDoc.querySelector('extract_cadastral_plan_territory > details_statement > group_top_requisites > date_formation');
            if (dateFormationElem) {
                const rawDate = dateFormationElem.textContent.trim();
                const parts = rawDate.split('-');
                kptDate = (parts.length === 3) ? `${parts[2]}.${parts[1]}.${parts[0]}` : rawDate;
            }
            const regNumberElem = xmlDoc.querySelector('extract_cadastral_plan_territory > details_statement > group_top_requisites > registration_number');
            if (regNumberElem) kptRegNum = regNumberElem.textContent.trim();
            const landRecords = xmlDoc.querySelectorAll('land_record');
            let foundLandRecord = null;
            landRecords.forEach(record => {
                const cadNumberElem = record.querySelector('object > common_data > cad_number');
                if (cadNumberElem && cadNumberElem.textContent.trim() === fullCadNumber) {
                    foundLandRecord = record;
                }
            });
            if (!foundLandRecord) {
                throw new Error(`Участок ${fullCadNumber} не найден в XML файле ${kptFileName}.`);
            }
            const parcelData = extractParcelDataXML(foundLandRecord);
            currentParcelContoursXML = extractParcelCoordinatesXML(foundLandRecord);

            if (currentParcelContoursXML && currentParcelContoursXML.length > 0 && currentParcelContoursXML.some(c => c.length > 0)) {
                xmlTotalPointCount = currentParcelContoursXML.reduce((sum, contour) => sum + contour.length, 0);
            } else {
                xmlTotalPointCount = 0;
            }
            return { parcelData, parcelContours: currentParcelContoursXML };
        }

        function resetUI() {
            resultsContainerDiv.style.display = 'none';
            errorMessagesXMLDiv.style.display = 'none';
            errorMessagesXMLDiv.textContent = '';
            drawingSectionXMLDiv.style.display = 'none';
            parcelInfoSectionXMLDiv.style.display = 'none';
            exportSectionXMLDiv.style.display = 'none';
            parcelDataTableXMLDiv.innerHTML = '';
            if (parcelCanvasXML) {
                const ctxXML = parcelCanvasXML.getContext('2d');
                ctxXML.clearRect(0, 0, parcelCanvasXML.width, parcelCanvasXML.height);
            }

            const h2XML = parcelInfoSectionXMLDiv.querySelector('#h2XMLHeader');
            if (h2XML) resetButtonHeader(h2XML);
            const h2EGRN = parcelInfoSectionEGRNDiv.querySelector('#h2EGRNHeader');
            if (h2EGRN) resetButtonHeader(h2EGRN);

            currentParcelDataXML = null;
            currentParcelContoursXML = null;
            kptDate = '';
            kptRegNum = '';
            setExportButtonsState(false);

            errorMessagesEGRNDiv.style.display = 'none';
            errorMessagesEGRNDiv.textContent = '';
            drawingSectionEGRNDiv.style.display = 'none';
            parcelInfoSectionEGRNDiv.style.display = 'none';
            parcelDataTableEGRNDiv.innerHTML = '';
            if (parcelCanvasEGRN) {
                const ctxEGRN = parcelCanvasEGRN.getContext('2d');
                ctxEGRN.clearRect(0, 0, parcelCanvasEGRN.width, parcelCanvasEGRN.height);
            }
            currentEgrnFeature = null;
            showLoaderEGRN(false);

            areaXMLValue = null;
            areaEGRNValue = null;
            xmlTotalPointCount = null;
            egrnTotalPointCount = null;
            xmlIsDeclared = false;
            egrnIsDeclared = false;

            const oldXmlAreaRow = document.getElementById('xmlAreaRow');
            if (oldXmlAreaRow) oldXmlAreaRow.className = '';
            const oldEgrnAreaRow = document.getElementById('egrnAreaRow');
            if (oldEgrnAreaRow) oldEgrnAreaRow.className = '';

            const oldXmlPointCountRow = document.getElementById('xmlPointCountRow');
            if (oldXmlPointCountRow) oldXmlPointCountRow.className = '';
            const oldEgrnPointCountRow = document.getElementById('egrnPointCountRow');
            if (oldEgrnPointCountRow) oldEgrnPointCountRow.className = '';

            const accuracyRow = parcelDataTableXMLDiv.querySelector('tr[class*="accuracy-"]');
             if (accuracyRow) {
                accuracyRow.classList.remove('accuracy-good-row', 'accuracy-bad-row');
             }


            if (outdatedDataNotificationDiv) outdatedDataNotificationDiv.style.display = 'none';
        }

        function showError(message, type = 'xml') {
            let errorDiv = (type === 'egrn') ? errorMessagesEGRNDiv : errorMessagesXMLDiv;
            errorDiv.textContent = message;
            errorDiv.style.display = 'block';
        }

        function extractParcelDataXML(landRecordNode) {
            const data = {};
            data.cadNumber = getElementValue(landRecordNode, 'object > common_data > cad_number');
            data.objectType = getElementValue(landRecordNode, 'object > common_data > type > value');
            data.address = getElementValue(landRecordNode, 'address_location > address > readable_address') || 'Нет данных';

            const areaElement = landRecordNode.querySelector('params > area');
            const areaValueText = getElementValue(areaElement, 'value');
            data.areaNumeric = areaValueText ? parseFloat(areaValueText.replace(',', '.')) : null;
            const inaccuracy = getElementValue(areaElement, 'inaccuracy');
            data.areaString = data.areaNumeric !== null ? (inaccuracy ? `Уточненная: ${formatNumberWithSpaces(data.areaNumeric)} ±${inaccuracy} кв.м.` : `Декларированная: ${formatNumberWithSpaces(data.areaNumeric)} кв.м.`) : 'Нет данных';

            data.permittedUse = getElementValue(landRecordNode, 'params > permitted_use > permitted_use_established > by_document') || 'Нет данных';
            data.category = getElementValue(landRecordNode, 'params > category > type > value') || 'Нет данных';
            const costValue = getElementValue(landRecordNode, 'cost > value');
            data.cadastralValue = costValue ? parseFloat(costValue).toLocaleString('ru-RU') + ' руб.' : 'Нет данных';

            let allDeltaValues = [];
            const processSpatialElementsForDelta = (spatialElementParentNode) => {
                if (!spatialElementParentNode) return;
                const spatialElementNodes = spatialElementParentNode.querySelectorAll("spatial_element");
                spatialElementNodes.forEach(spatialElementNode => {
                    const ordinatesNode = spatialElementNode.querySelector("ordinates");
                    if (ordinatesNode) {
                        const ordinateNodes = ordinatesNode.querySelectorAll("ordinate");
                        ordinateNodes.forEach(ordNode => {
                            const deltaElem = ordNode.querySelector("delta_geopoint");
                            if (deltaElem && deltaElem.textContent) {
                                const deltaVal = parseFloat(deltaElem.textContent.trim());
                                if (!isNaN(deltaVal)) {
                                    allDeltaValues.push(deltaVal);
                                }
                            }
                        });
                    }
                });
            };

            const contoursLocationNode = landRecordNode.querySelector("contours_location");
            if (contoursLocationNode) {
                const contourNodes = contoursLocationNode.querySelectorAll("contours > contour");
                if (contourNodes.length > 0) {
                    contourNodes.forEach(contourNode => {
                        let elementsParent = contourNode.querySelector("entity_spatial > spatials_elements");
                        if (!elementsParent) elementsParent = contourNode.querySelector("entity_spatial");
                        if (!elementsParent) elementsParent = contourNode;
                        if (elementsParent) processSpatialElementsForDelta(elementsParent);
                    });
                }

                if (allDeltaValues.length === 0) {
                    let fallbackParent = contoursLocationNode.querySelector("entity_spatial > spatials_elements");
                    if (!fallbackParent) fallbackParent = contoursLocationNode.querySelector("entity_spatial");
                    if (!fallbackParent) fallbackParent = contoursLocationNode.querySelector("spatials_elements");
                    if (!fallbackParent && contoursLocationNode.querySelector("spatial_element")) {
                         fallbackParent = contoursLocationNode;
                    }
                    if (fallbackParent) processSpatialElementsForDelta(fallbackParent);
                }
            }

            if (allDeltaValues.length === 0) {
                const spatialDataNode = landRecordNode.querySelector("spatial_data");
                if (spatialDataNode) {
                    let elementsParent = spatialDataNode.querySelector("entity_spatial > spatials_elements");
                    if(!elementsParent) elementsParent = spatialDataNode.querySelector("entity_spatial");
                    if(!elementsParent) elementsParent = spatialDataNode;
                    if (elementsParent) processSpatialElementsForDelta(elementsParent);
                }
            }

            if (allDeltaValues.length > 0) {
                data.maxDeltaGeopoint = Math.max(...allDeltaValues).toString();
            } else {
                data.maxDeltaGeopoint = '—';
            }
            return data;
        }

        function displayParcelInfoTableXML(data) {
            areaXMLValue = null;
            xmlIsDeclared = false;
            if (!data && !kptDate && !kptRegNum) {
                 parcelInfoSectionXMLDiv.style.display = 'none';
                 currentParcelDataXML = null;
                 xmlTotalPointCount = null;
                 compareAndHighlightAreas();
                 compareAndHighlightPointCounts();
                 return;
            }

            let tableHTML = '<table>';
            const displayOrder = [
                { key: 'cadNumber', label: 'Кадастровый номер' },
                { key: 'objectType', label: 'Тип объекта' },
                { key: 'address', label: 'Адрес' },
                { key: 'areaString', label: 'Площадь' },
                { key: 'permittedUse', label: 'Разрешенное использование' },
                { key: 'category', label: 'Категория земель' },
                { key: 'maxDeltaGeopoint', label: 'Погрешность' },
                { key: 'cadastralValue', label: 'Кадастровая стоимость' }
            ];

            if (data) {
                displayOrder.forEach(item => {
                    if (data[item.key] || data[item.key] === '—' || typeof data[item.key] === 'number') {
                        let rowAttributes = '';

                        if (item.key === 'areaString') {
                            areaXMLValue = data.areaNumeric;
                            rowAttributes += ' id="xmlAreaRow"';
                            if (data.areaString && data.areaString.startsWith("Декларированная:")) {
                                xmlIsDeclared = true;
                            }
                        }

                        if (item.key === 'maxDeltaGeopoint' && data[item.key] !== '—') {
                            const deltaValue = parseFloat(data[item.key]);
                            if (!isNaN(deltaValue)) {
                                let accuracyClass = '';
                                if (deltaValue === 0.1) {
                                    accuracyClass = 'accuracy-good-row';
                                } else if (deltaValue === 0.2 || deltaValue === 0.3) {
                                    accuracyClass = 'accuracy-bad-row';
                                }

                                if (accuracyClass) {
                                    if (rowAttributes.includes('class="')) {
                                        rowAttributes = rowAttributes.replace('class="', `class="${accuracyClass} `);
                                    } else {
                                        rowAttributes += ` class="${accuracyClass}"`;
                                    }
                                }
                            }
                        }
                        tableHTML += `<tr${rowAttributes}><th>${item.label}</th><td>${data[item.key]}</td></tr>`;
                    }
                });
            }

            let kptInfoHTML = '';
            if (kptDate || kptRegNum) {
                let fileInfoText = '';
                if (kptRegNum) fileInfoText += kptRegNum;
                if (kptDate) fileInfoText += `${kptRegNum ? ' от ' : 'Дата XML: '}${kptDate}`;
                kptInfoHTML = `<tr><th>Источник XML</th><td>${fileInfoText}</td></tr>`;
            }
            tableHTML += kptInfoHTML;

            let pointDisplayText = '—';
            if (typeof xmlTotalPointCount === 'number') {
                if (xmlTotalPointCount > 0) {
                    pointDisplayText = xmlTotalPointCount;
                } else {
                    if (currentParcelContoursXML && currentParcelContoursXML.length > 0 && !currentParcelContoursXML.some(c => c.length > 0)) {
                         pointDisplayText = '0 (контуры пусты)';
                    } else if (!currentParcelContoursXML || currentParcelContoursXML.length === 0) {
                         pointDisplayText = '0 (нет данных о координатах)';
                    } else {
                         pointDisplayText = '0';
                    }
                }
            }
            tableHTML += `<tr id="xmlPointCountRow"><th>Кол-во точек (XML)</th><td>${pointDisplayText}</td></tr>`;

            tableHTML += '</table>';
            parcelDataTableXMLDiv.innerHTML = tableHTML;
            parcelInfoSectionXMLDiv.style.display = 'block';
            compareAndHighlightAreas();
            compareAndHighlightPointCounts();
        }


        function drawParcelOnCanvasXML(contours) {
            const canvas = parcelCanvasXML;
            const ctx = canvas.getContext('2d');

            const resolvedContainerWidth = drawingSectionXMLDiv.clientWidth > 0 ? drawingSectionXMLDiv.clientWidth : 300;
            canvas.width = resolvedContainerWidth;
            canvas.height = canvas.width * (3/4);
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            if (!contours || contours.length === 0 || contours.every(c => c.length === 0)) return;

            let allPoints = [];
            contours.forEach(contour => allPoints.push(...contour));
            if (allPoints.length === 0) return;

            let minGeoX = Infinity, maxGeoX = -Infinity, minGeoY = Infinity, maxGeoY = -Infinity;
            allPoints.forEach(p => {
                minGeoX = Math.min(minGeoX, p.x); maxGeoX = Math.max(maxGeoX, p.x);
                minGeoY = Math.min(minGeoY, p.y); maxGeoY = Math.max(maxGeoY, p.y);
            });

            const dataGeoWidth = (maxGeoY - minGeoY) || 1;
            const dataGeoHeight = (maxGeoX - minGeoX) || 1;

            const jsInternalPadding = 20;
            const scaleMultiplier = 0.9;
            const effectiveCanvasWidth = canvas.width - 2 * jsInternalPadding;
            const effectiveCanvasHeight = canvas.height - 2 * jsInternalPadding;

            let scale;
            if (dataGeoWidth === 0 || dataGeoHeight === 0) scale = 1;
            else scale = Math.min(effectiveCanvasWidth / dataGeoWidth, effectiveCanvasHeight / dataGeoHeight) * scaleMultiplier;

            const drawingActualCanvasWidth = dataGeoWidth * scale;
            const drawingActualCanvasHeight = dataGeoHeight * scale;
            const offsetX_canvas = jsInternalPadding + (effectiveCanvasWidth - drawingActualCanvasWidth) / 2;
            const offsetY_canvas = jsInternalPadding + (effectiveCanvasHeight - drawingActualCanvasHeight) / 2;

            ctx.strokeStyle = '#007bff'; ctx.lineWidth = 2; ctx.fillStyle = 'rgba(0, 123, 255, 0.1)';

            let totalGeometricAreaXML = 0;
            let totalGeometricPerimeterXML = 0;

            contours.forEach(contour => {
                if (contour.length < 1) return;
                ctx.beginPath();
                const canvasPoints = contour.map(point => {
                    return {
                        x_canvas: offsetX_canvas + (point.y - minGeoY) * scale,
                        y_canvas: offsetY_canvas + (maxGeoX - point.x) * scale
                    };
                });

                canvasPoints.forEach((cp, index) => {
                    if (index === 0) ctx.moveTo(cp.x_canvas, cp.y_canvas);
                    else ctx.lineTo(cp.x_canvas, cp.y_canvas);
                });

                let isClosed = false;
                if (contour.length > 2 && Math.abs(contour[0].x - contour[contour.length - 1].x) < 1e-6 && Math.abs(contour[0].y - contour[contour.length - 1].y) < 1e-6) {
                    ctx.closePath();
                    ctx.fill();
                    isClosed = true;
                }
                ctx.stroke();

                if (showDistanceLabelsXML && contour.length > 0) {
                    let contourPerimeter = 0;
                    for (let i = 0; i < contour.length; i++) {
                        const p1_xml = contour[i];
                        const p2_xml = contour[(i + 1) % contour.length];

                        if (i === contour.length - 1 && !isClosed) break;

                        const dist = Math.sqrt(Math.pow(p2_xml.y - p1_xml.y, 2) + Math.pow(p2_xml.x - p1_xml.x, 2));
                        contourPerimeter += dist;

                        const cp1 = canvasPoints[i];
                        const cp2 = canvasPoints[(i + 1) % contour.length];
                        drawRotatedText(ctx, dist.toFixed(2) + "м", cp1.x_canvas, cp1.y_canvas, cp2.x_canvas, cp2.y_canvas, '10px Arial', 'black');
                    }
                    totalGeometricPerimeterXML += contourPerimeter;

                    if (isClosed && contour.length >= 3) {
                        let contourArea = 0;
                        for (let j = 0; j < contour.length; j++) {
                            const p_curr = contour[j];
                            const p_next = contour[(j + 1) % contour.length];
                            contourArea += (p_curr.y * p_next.x - p_next.y * p_curr.x);
                        }
                        totalGeometricAreaXML += Math.abs(contourArea / 2.0);
                    }
                }
            });

            if (showDistanceLabelsXML) {
                ctx.fillStyle = 'black'; ctx.font = '11px Arial'; ctx.textAlign = 'left';
                ctx.fillText(`Площадь (XML): ~${formatNumberWithSpaces(Math.round(totalGeometricAreaXML))} м²`, 10, canvas.height - 25);
                ctx.fillText(`Периметр (XML): ~${formatNumberWithSpaces(Math.round(totalGeometricPerimeterXML))} м`, 10, canvas.height - 10);
            }
        }


        function setExportButtonsState(enabled) {
            exportMifBtn.disabled = !enabled;
            exportDxfBtn.disabled = !enabled;
            exportTxtBtn.disabled = !enabled;
        }
        function getElementValue(element, tagName) {
             if (!element) return '';
            const parts = tagName.split('>');
            let currentElement = element;
            for (let part of parts) {
                currentElement = currentElement.querySelector(part);
                if (!currentElement) return '';
            }
            return currentElement.textContent.trim();
        }
        function formatCadastralNumber(input) {
            let value = input.value.replace(/[^\d]/g, '');
            let formatted = '';
            const originalLength = value.length;
            if (originalLength > 0) formatted += value.substring(0, Math.min(2, originalLength));
            if (originalLength > 2) formatted += ':' + value.substring(2, Math.min(4, originalLength));
            const firstTwoDigits = value.substring(0, 2);
            const isSevenDigitQ = sevenDigitsRegions.includes(firstTwoDigits);
            const quarterMaxLength = isSevenDigitQ ? 7 : 6;
            if (originalLength > 4) formatted += ':' + value.substring(4, Math.min(4 + quarterMaxLength, originalLength));
            if (originalLength > (4 + quarterMaxLength)) formatted += ':' + value.substring(4 + quarterMaxLength);
            input.value = formatted;
        }
        function isValidCadastralNumber(text) {
            if (!text) return false;
            const firstTwoDigits = text.slice(0, 2);
            const isSevenDigitQ = sevenDigitsRegions.includes(firstTwoDigits);
            const digitsAfterSecondColon = isSevenDigitQ ? 7 : 6;
            const pattern = new RegExp(`^\\d{2}:\\d{2}:\\d{${digitsAfterSecondColon}}:\\d+$`);
            return pattern.test(text);
        }
        function findLatestKptFile(files) {
            if (!files || files.length === 0) return null;
            const dateRegex = /(\d{4}-\d{2}-\d{2})/;
            return files
                .map(file => ({ name: file.name, date: (file.name.match(dateRegex) ? new Date(file.name.match(dateRegex)[1]) : new Date(0)) }))
                .sort((a, b) => b.date - a.date)[0];
        }



        function extractParcelCoordinatesXML(landRecordNode) {
            const result = [];
            const contoursLocationNode = landRecordNode.querySelector("contours_location");
            if (contoursLocationNode) {
                const processSpatialElements = (spatialElementParentNode) => {
                    const spatialElementNodes = spatialElementParentNode.querySelectorAll("spatial_element");
                    spatialElementNodes.forEach(spatialElementNode => {
                        const ordinatesNode = spatialElementNode.querySelector("ordinates");
                        if (ordinatesNode) {
                            const contourCoords = [];
                            const ordinateNodes = ordinatesNode.querySelectorAll("ordinate");
                            ordinateNodes.forEach(ordNode => {
                                const xVal = getElementValue(ordNode, "x");
                                const yVal = getElementValue(ordNode, "y");
                                if (xVal && yVal) {
                                    const x = parseFloat(xVal); const y = parseFloat(yVal);
                                    if (!isNaN(x) && !isNaN(y)) contourCoords.push({ x, y });
                                }
                            });
                            if (contourCoords.length > 0) result.push(contourCoords);
                        }
                    });
                };
                const contourNodes = contoursLocationNode.querySelectorAll("contours > contour");
                if (contourNodes.length > 0) {
                    contourNodes.forEach(contourNode => {
                        let elementsParent = contourNode.querySelector("entity_spatial > spatials_elements");
                        if (!elementsParent) elementsParent = contourNode.querySelector("entity_spatial");
                        if (!elementsParent) elementsParent = contourNode;
                        if (elementsParent) processSpatialElements(elementsParent);
                    });
                }

                if (result.length === 0) {
                    let directParent = contoursLocationNode.querySelector("entity_spatial > spatials_elements");
                    if (!directParent) directParent = contoursLocationNode.querySelector("entity_spatial");
                    if (!directParent) directParent = contoursLocationNode.querySelector("spatials_elements");
                    if (!directParent && contoursLocationNode.querySelector("spatial_element")) {
                        directParent = contoursLocationNode;
                    }
                    if (directParent) processSpatialElements(directParent);
                }
            }
            return result;
        }

        async function fetchAndProcessEGRN(cadNumber) {
            const url = `https://nspd.gov.ru/api/geoportal/v2/search/geoportal?thematicSearchId=1&query=${encodeURIComponent(cadNumber)}`;
            let response;
            try {
                response = await fetch(url);

                if (response.status === 404) { // Specific check for 404
                    throw new Error('EGRN_NOT_FOUND_404');
                }
                if (!response.ok) { // Other server errors (5xx, 401, etc.)
                    throw new Error(`Ошибка сети ЕГРН: ${response.status} ${response.statusText}`);
                }
                
                const data = await response.json(); // Could throw SyntaxError

                if (data.data && data.data.features && data.data.features.length > 0) {
                    currentEgrnFeature = data.data.features[0];

                    if (currentEgrnFeature.geometry && (currentEgrnFeature.geometry.coordinates || (currentEgrnFeature.geometry.geometries && currentEgrnFeature.geometry.geometries.length > 0) )) {
                        let tempAllPointsFlat = [];
                        function extractEgrnCoordsForCount(geom) {
                            if (!geom || !geom.type) return;
                            switch (geom.type) {
                                case "Polygon": geom.coordinates.forEach(ring => ring.forEach(coord => tempAllPointsFlat.push(coord))); break;
                                case "MultiPolygon": geom.coordinates.forEach(polygon => polygon.forEach(ring => ring.forEach(coord => tempAllPointsFlat.push(coord)))); break;
                                case "Point": tempAllPointsFlat.push(geom.coordinates); break;
                                case "MultiLineString": geom.coordinates.forEach(line => line.forEach(coord => tempAllPointsFlat.push(coord))); break;
                                case "GeometryCollection": if (geom.geometries) geom.geometries.forEach(g => extractEgrnCoordsForCount(g)); break;
                            }
                        }
                        extractEgrnCoordsForCount(currentEgrnFeature.geometry);
                        egrnTotalPointCount = tempAllPointsFlat.length;
                        drawingSectionEGRNDiv.style.display = 'block';

                        const originallyShowLabelsEGRN = showDistanceLabelsEGRN;
                        if (originallyShowLabelsEGRN) {
                            showDistanceLabelsEGRN = false;
                            drawEgrnParcelOnCanvas(currentEgrnFeature.geometry);
                            showDistanceLabelsEGRN = true;
                        }
                        drawEgrnParcelOnCanvas(currentEgrnFeature.geometry);

                    } else {
                        egrnTotalPointCount = 0;
                        showError('Геометрия не найдена в ЕГРН для данного объекта (объект найден, но без координат).', 'egrn');
                        drawingSectionEGRNDiv.style.display = 'none';
                    }

                    displayEgrnInfoTable(currentEgrnFeature.properties.options, currentEgrnFeature.properties);
                    parcelInfoSectionEGRNDiv.style.display = 'block';

                } else { // This is for 200 OK but no features found
                    throw new Error('Участок не найден в ЕГРН');
                }
            } catch (error) {
                 if (error instanceof TypeError && error.message === 'Failed to fetch') { // Network level error
                    throw new Error('Ошибка сети ЕГРН: Не удалось выполнить запрос (Failed to fetch)');
                }
                // Re-throw other errors (EGRN_NOT_FOUND_404, "Участок не найден в ЕГРН", SyntaxError, or "Ошибка сети ЕГРН: status statusText")
                throw error; 
            }
        }

        function displayEgrnInfoTable(options, properties) {
            parcelDataTableEGRNDiv.innerHTML = '';
            areaEGRNValue = null;
            egrnIsDeclared = false;
            let tableHTML = '<table>';
            const categoryName = properties.categoryName || "Неизвестный тип";
            const dataRows = [];

            dataRows.push({ label: 'Тип объекта', value: categoryName });
            dataRows.push({ label: 'Кадастровый номер', value: options.cad_num || options.cad_number });
            dataRows.push({ label: 'Статус', value: options.status || options.common_data_status });
            dataRows.push({ label: 'Адрес', value: options.readable_address || options.address_readable_address });

            let areaValueForCost = null, areaDisplayValue = 'Нет данных';
            let isAreaRowForEGRN = false;

            if (categoryName === "Земельные участки ЕГРН") {
                if (options.specified_area && !isNaN(parseFloat(options.specified_area))) {
                    areaValueForCost = parseFloat(options.specified_area);
                    areaDisplayValue = `Уточненная: ${formatNumberWithSpaces(areaValueForCost)} м²`;
                } else if (options.land_record_area_verified && !isNaN(parseFloat(options.land_record_area_verified))) {
                    areaValueForCost = parseFloat(options.land_record_area_verified);
                    areaDisplayValue = `Уточненная: ${formatNumberWithSpaces(areaValueForCost)} м²`;
                } else if (options.land_record_area && !isNaN(parseFloat(options.land_record_area))) {
                    areaValueForCost = parseFloat(options.land_record_area);
                    areaDisplayValue = `Уточненная: ${formatNumberWithSpaces(areaValueForCost)} м²`;
                } else if (options.land_record_area_declaration && !isNaN(parseFloat(options.land_record_area_declaration))) {
                    areaValueForCost = parseFloat(options.land_record_area_declaration);
                    areaDisplayValue = `Декларированная: ${formatNumberWithSpaces(areaValueForCost)} м²`;
                    egrnIsDeclared = true;
                } else if (options.declared_area && !isNaN(parseFloat(options.declared_area))) {
                    areaValueForCost = parseFloat(options.declared_area);
                    areaDisplayValue = `Декларированная: ${formatNumberWithSpaces(areaValueForCost)} м²`;
                    egrnIsDeclared = true;
                }
                dataRows.push({ label: 'Площадь', value: areaDisplayValue, isArea: true });
                isAreaRowForEGRN = true;
                dataRows.push({ label: 'Категория земель', value: options.land_record_category_type });
                dataRows.push({ label: 'Разрешенное использование', value: options.permitted_use_established_by_document });
                dataRows.push({ label: 'Дата присвоения КН', value: formatDateEGRN(options.land_record_reg_date) });
            } else if (categoryName === "Помещения" || categoryName === "Здания") {
                if (options.area && !isNaN(parseFloat(options.area))) {
                     areaValueForCost = parseFloat(options.area);
                     areaDisplayValue = `${formatNumberWithSpaces(areaValueForCost)} м²`;
                }
                dataRows.push({ label: 'Площадь', value: areaDisplayValue, isArea: true });
                isAreaRowForEGRN = true;
                dataRows.push({ label: 'Назначение', value: options.purpose });
                if (categoryName === "Здания") {
                    dataRows.push({ label: 'Наименование', value: options.name || options.building_name });
                    dataRows.push({ label: 'Кол-во этажей', value: options.floors });
                    dataRows.push({ label: 'Год постройки', value: options.year_built });
                } else {
                     dataRows.push({ label: 'Тип помещения', value: options.params_type });
                     dataRows.push({ label: 'Этаж', value: Array.isArray(options.floor) ? options.floor.join(', ') : options.floor });
                     dataRows.push({ label: 'КН здания/сооружения', value: options.parent_cad_number });
                }
            } else if (categoryName === "Сооружения") {
                 if (options.params_area && !isNaN(parseFloat(options.params_area))) {
                    areaValueForCost = parseFloat(options.params_area);
                    areaDisplayValue = `${formatNumberWithSpaces(areaValueForCost)} м² (пл. застройки)`;
                 }
                 dataRows.push({ label: 'Площадь застройки', value: areaDisplayValue, isArea: true });
                 isAreaRowForEGRN = true;
                 dataRows.push({ label: 'Назначение', value: options.params_purpose });
                 dataRows.push({ label: 'Наименование', value: options.params_name });
                 dataRows.push({ label: 'Год постройки', value: options.params_year_built });
                 if(options.params_extension) dataRows.push({label: 'Протяженность', value: `${options.params_extension} м`});
            }

            if (isAreaRowForEGRN) {
                areaEGRNValue = areaValueForCost;
            }

            let costDisplayValue = 'Нет данных';
            if (options.cost_value && !isNaN(parseFloat(options.cost_value))) {
                const cost = parseFloat(options.cost_value);
                costDisplayValue = formatNumberWithSpaces(cost) + " руб.";
                if (areaValueForCost && areaValueForCost > 0 && (categoryName === "Земельные участки ЕГРН" || categoryName === "Помещения" || categoryName === "Здания")) {
                    costDisplayValue += ` (${formatNumberWithSpaces(Math.round(cost / areaValueForCost))} руб/м²)`;
                }
            }
            dataRows.push({ label: 'Кадастровая стоимость', value: costDisplayValue });
            dataRows.push({ label: 'Дата определения КС', value: formatDateEGRN(options.cost_determination_date) });
            dataRows.push({ label: 'Дата обновления в ЕГРН', value: formatDateEGRN(properties.systemInfo?.updated) });

            dataRows.forEach(row => {
                if (row.value || typeof row.value === 'number' || (typeof row.value === 'string' && row.value.trim() !== '')) {
                    let rowAttributes = '';
                    if (row.isArea) {
                        rowAttributes = ' id="egrnAreaRow"';
                    }
                    tableHTML += `<tr${rowAttributes}><th>${row.label}</th><td>${row.value !== null && row.value !== undefined ? row.value : 'Нет данных'}</td></tr>`;
                }
            });

            let egrnPointDisplayText = '—';
            if (typeof egrnTotalPointCount === 'number') {
                if (egrnTotalPointCount > 0) {
                    egrnPointDisplayText = egrnTotalPointCount;
                } else {
                    if (currentEgrnFeature && !currentEgrnFeature.geometry) {
                         egrnPointDisplayText = '0 (нет элемента геометрии)';
                    } else if (currentEgrnFeature && currentEgrnFeature.geometry) {
                         egrnPointDisplayText = '0 (геометрия пуста или невалидна)';
                    } else {
                         egrnPointDisplayText = '0 (нет координат)';
                    }
                }
            }
            tableHTML += `<tr id="egrnPointCountRow"><th>Кол-во точек (ЕГРН)</th><td>${egrnPointDisplayText}</td></tr>`;

            tableHTML += '</table>';
            parcelDataTableEGRNDiv.innerHTML = tableHTML;
            compareAndHighlightAreas();
            compareAndHighlightPointCounts();
        }

        function compareAndHighlightAreas() {
            const xmlAreaRow = document.getElementById('xmlAreaRow');
            const egrnAreaRow = document.getElementById('egrnAreaRow');

            if (xmlAreaRow) xmlAreaRow.classList.remove('area-same', 'area-different');
            if (egrnAreaRow) egrnAreaRow.classList.remove('area-same', 'area-different');

            outdatedDataNotificationDiv.style.display = 'none';

            let areasAreComparableAndPresent = areaXMLValue !== null && typeof areaXMLValue === 'number' &&
                                               areaEGRNValue !== null && typeof areaEGRNValue === 'number';

            let areasNumericallyDiffer = false;
            if (areasAreComparableAndPresent && Math.round(areaXMLValue) !== Math.round(areaEGRNValue)) {
                areasNumericallyDiffer = true;
            }

            if (xmlAreaRow) {
                if (xmlIsDeclared) {
                    xmlAreaRow.classList.add('area-different');
                } else if (areasAreComparableAndPresent) {
                    if (areasNumericallyDiffer) {
                        xmlAreaRow.classList.add('area-different');
                    } else {
                        if (!egrnIsDeclared || (egrnIsDeclared && !areasNumericallyDiffer) ) {
                             xmlAreaRow.classList.add('area-same');
                        } else {
                             xmlAreaRow.classList.add('area-different');
                        }
                    }
                }
            }

            if (egrnAreaRow) {
                if (egrnIsDeclared) {
                    egrnAreaRow.classList.add('area-different');
                } else {
                    egrnAreaRow.classList.add('area-same');
                }
            }


            const xmlPts = xmlTotalPointCount;
            const egrnPts = egrnTotalPointCount;
            let pointsDiffer = false;
            if (typeof xmlPts === 'number' && typeof egrnPts === 'number' && xmlPts !== egrnPts) {
                pointsDiffer = true;
            }

            if ( pointsDiffer ||
                 (areasAreComparableAndPresent && areasNumericallyDiffer) ||
                 (xmlIsDeclared && !egrnIsDeclared && areaXMLValue !== null && areaEGRNValue !== null)
               ) {
                outdatedDataNotificationDiv.style.display = 'block';
            }
        }


        function compareAndHighlightPointCounts() {
            const xmlPointCountRow = document.getElementById('xmlPointCountRow');
            const egrnPointCountRow = document.getElementById('egrnPointCountRow');

            if (xmlPointCountRow) xmlPointCountRow.className = '';
            if (egrnPointCountRow) egrnPointCountRow.className = '';

            if (xmlPointCountRow) xmlPointCountRow.id = 'xmlPointCountRow';
            if (egrnPointCountRow) egrnPointCountRow.id = 'egrnPointCountRow';


            const pointsAreComparable = typeof xmlTotalPointCount === 'number' &&
                                        typeof egrnTotalPointCount === 'number';

            if (pointsAreComparable && xmlPointCountRow && egrnPointCountRow) {
                if (xmlTotalPointCount === egrnTotalPointCount) {
                    xmlPointCountRow.classList.add('points-same');
                    egrnPointCountRow.classList.add('points-same');
                } else {
                    xmlPointCountRow.classList.add('points-different');
                    egrnPointCountRow.classList.add('points-different');
                }
            }
        }


        function formatDateEGRN(dateString) {
            if (!dateString) return '';
            try {
                const date = new Date(dateString);
                return `${String(date.getDate()).padStart(2, '0')}.${String(date.getMonth() + 1).padStart(2, '0')}.${date.getFullYear()}`;
            } catch (e) { return dateString; }
        }
        function formatNumberWithSpaces(number) {
            if (typeof number !== 'number' || isNaN(number)) return number;
            return number.toLocaleString('ru-RU', { maximumFractionDigits: 2 });
        }

        function drawEgrnParcelOnCanvas(geometry) {
            const canvas = parcelCanvasEGRN;
            const ctx = canvas.getContext('2d');

            const resolvedContainerWidthEGRN = drawingSectionEGRNDiv.clientWidth > 0 ? drawingSectionEGRNDiv.clientWidth : 300;
            canvas.width = resolvedContainerWidthEGRN;
            canvas.height = canvas.width * (3/4);
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            if (!geometry || (!geometry.coordinates && (!geometry.geometries || geometry.geometries.length === 0))) return;
            let allPointsFlat = [];
            function extractCoordinates(geom) {
                if (!geom || !geom.type) return;
                switch (geom.type) {
                    case "Polygon": geom.coordinates.forEach(ring => ring.forEach(coord => allPointsFlat.push(coord))); break;
                    case "MultiPolygon": geom.coordinates.forEach(polygon => polygon.forEach(ring => ring.forEach(coord => tempAllPointsFlat.push(coord)))); break;
                    case "Point": allPointsFlat.push(geom.coordinates); break;
                    case "MultiLineString": geom.coordinates.forEach(line => line.forEach(coord => tempAllPointsFlat.push(coord))); break;
                    case "GeometryCollection": if (geom.geometries) geom.geometries.forEach(g => extractCoordinates(g)); break;
                }
            }
            extractCoordinates(geometry);
            if (allPointsFlat.length === 0) return;

            let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
            allPointsFlat.forEach(p => {
                minX = Math.min(minX, p[0]); maxX = Math.max(maxX, p[0]);
                minY = Math.min(minY, p[1]); maxY = Math.max(maxY, p[1]);
            });
            const dataWidth = (maxX - minX) || 1;
            const dataHeight = (maxY - minY) || 1;

            const jsInternalPadding = 20;
            const scaleMultiplier = 0.9;

            const effectiveCanvasWidth = canvas.width - 2 * jsInternalPadding;
            const effectiveCanvasHeight = canvas.height - 2 * jsInternalPadding;
            let scaleValue;
            if (dataWidth === 0 || dataHeight === 0) scaleValue = 1;
            else scaleValue = Math.min(effectiveCanvasWidth / dataWidth, effectiveCanvasHeight / dataHeight) * scaleMultiplier;

            const drawingActualCanvasWidth = dataWidth * scaleValue;
            const drawingActualCanvasHeight = dataHeight * scaleValue;
            const offsetX_canvas = jsInternalPadding + (effectiveCanvasWidth - drawingActualCanvasWidth) / 2;
            const offsetY_canvas = jsInternalPadding + (effectiveCanvasHeight - drawingActualCanvasHeight) / 2;

            function transform(coord) {
                return {
                    x: offsetX_canvas + (coord[0] - minX) * scaleValue,
                    y: offsetY_canvas + (maxY - coord[1]) * scaleValue
                };
            }
            ctx.strokeStyle = '#28a745'; ctx.lineWidth = 2; ctx.fillStyle = 'rgba(40, 167, 69, 0.1)';

            function drawPath(pathCoords, isClosedAndFill) {
                if (pathCoords.length === 0) return;
                ctx.beginPath();
                const canvasPathCoords = pathCoords.map(geoCoord => transform(geoCoord));

                canvasPathCoords.forEach((p_canvas, index) => {
                    if (index === 0) ctx.moveTo(p_canvas.x, p_canvas.y); else ctx.lineTo(p_canvas.x, p_canvas.y);
                });

                if (isClosedAndFill) { ctx.closePath(); ctx.fill(); }
                ctx.stroke();

                if (showDistanceLabelsEGRN && pathCoords.length > 0) {
                    for (let i = 0; i < pathCoords.length; i++) {
                        const p1_geo = pathCoords[i];
                        const p2_geo = pathCoords[(i + 1) % pathCoords.length];

                        if (i === pathCoords.length - 1 && !isClosedAndFill) break;

                        const p1_canvas = canvasPathCoords[i];
                        const p2_canvas = canvasPathCoords[(i + 1) % pathCoords.length];

                        const dist = haversineDistance(convertToWGS84(p1_geo[0], p1_geo[1]), convertToWGS84(p2_geo[0], p2_geo[1]));
                        drawRotatedText(ctx, dist.toFixed(1) + "м", p1_canvas.x, p1_canvas.y, p2_canvas.x, p2_canvas.y, '10px Arial', 'black');
                    }
                }
            }
            function processGeometryPart(geomPart) {
                 switch (geomPart.type) {
                    case "Polygon": geomPart.coordinates.forEach((ring, index) => drawPath(ring, index === 0)); break;
                    case "MultiPolygon": geomPart.coordinates.forEach(polygon => polygon.forEach((ring, index) => drawPath(ring, index === 0))); break;
                    case "MultiLineString": geomPart.coordinates.forEach(line => drawPath(line, false)); break;
                    case "Point":
                        break;
                    case "GeometryCollection": if(geomPart.geometries) geomPart.geometries.forEach(g => processGeometryPart(g)); break;
                }
            }
            processGeometryPart(geometry);

            if (showDistanceLabelsEGRN && (geometry.type === "Polygon" || geometry.type === "MultiPolygon")) {
                let totalArea = 0, totalPerimeter = 0;
                const calculateRingArea = (ringCoords) => {
                    if (ringCoords.length < 3) return 0;
                    const wgsRing = ringCoords.map(c => convertToWGS84(c[0], c[1]));
                    let area = 0; const R = 6371000;
                    let sum = 0;
                    for (let i = 0; i < wgsRing.length; i++) {
                        const p1_lon_rad = wgsRing[i][0] * Math.PI / 180;
                        const p1_lat_rad = wgsRing[i][1] * Math.PI / 180;
                        const p2_lon_rad = wgsRing[(i + 1) % wgsRing.length][0] * Math.PI / 180;
                        const p2_lat_rad = wgsRing[(i + 1) % wgsRing.length][1] * Math.PI / 180;
                        sum += (p2_lon_rad - p1_lon_rad) * (2 + Math.sin(p1_lat_rad) + Math.sin(p2_lat_rad));
                    }
                    area = Math.abs(sum * R * R / 2.0);
                    return area * 1.0046705998;
                };
                const calculateRingPerimeter = (ringCoords) => {
                    let perimeter = 0; if (ringCoords.length < 2) return 0;
                    const wgsRing = ringCoords.map(c => convertToWGS84(c[0], c[1]));
                    for (let i = 0; i < wgsRing.length; i++) {
                        perimeter += haversineDistance(wgsRing[i], wgsRing[(i + 1) % wgsRing.length]);
                    }
                    return perimeter;
                };

                if (geometry.type === "Polygon") {
                    totalArea = calculateRingArea(geometry.coordinates[0]);
                    for(let i = 1; i < geometry.coordinates.length; i++) {
                        totalArea -= calculateRingArea(geometry.coordinates[i]);
                    }
                    totalPerimeter = calculateRingPerimeter(geometry.coordinates[0]);
                } else if (geometry.type === "MultiPolygon") {
                    geometry.coordinates.forEach(polygon => {
                        let polygonArea = calculateRingArea(polygon[0]);
                        for(let i = 1; i < polygon.length; i++) {
                            polygonArea -= calculateRingArea(polygon[i]);
                        }
                        totalArea += polygonArea;
                        totalPerimeter += calculateRingPerimeter(polygon[0]);
                    });
                }
                ctx.fillStyle = 'black'; ctx.font = '11px Arial'; ctx.textAlign = 'left';
                ctx.fillText(`Площадь (ЕГРН): ~${formatNumberWithSpaces(Math.round(totalArea))} м²`, 10, canvas.height - 25);
                ctx.fillText(`Периметр (ЕГРН): ~${formatNumberWithSpaces(Math.round(totalPerimeter))} м`, 10, canvas.height - 10);
            }
        }
        function convertToWGS84(x_merc, y_merc) {
            if (typeof proj4 === 'undefined') return [0,0];
            return proj4("EPSG:3857", "EPSG:4326", [x_merc, y_merc]);
        }
        function haversineDistance(coords1_wgs_lonlat, coords2_wgs_lonlat) {
            const R = 6371e3;
            const φ1 = coords1_wgs_lonlat[1] * Math.PI/180;
            const φ2 = coords2_wgs_lonlat[1] * Math.PI/180;
            const Δφ = (coords2_wgs_lonlat[1]-coords1_wgs_lonlat[1]) * Math.PI/180;
            const Δλ = (coords2_wgs_lonlat[0]-coords1_wgs_lonlat[0]) * Math.PI/180;
            const a = Math.sin(Δφ/2) * Math.sin(Δφ/2) +
                      Math.cos(φ1) * Math.cos(φ2) *
                      Math.sin(Δλ/2) * Math.sin(Δλ/2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
            return R * c;
        }

        function getCoordinatesForDefaultTxtExport(contours) {
            const resultCoords = [];
            if (!contours || contours.length === 0) return resultCoords;
            contours.forEach((contour, contourIdx) => {
                if (contour.length === 0) return;
                contour.forEach(p => resultCoords.push(`${p.x.toFixed(2)}\t${p.y.toFixed(2)}`));
                if (contourIdx < contours.length - 1 && contours[contourIdx+1] && contours[contourIdx+1].length > 0) {
                     resultCoords.push("");
                }
            });
            return resultCoords;
        }

        function generateMIF(contours) {
            let mifContent = `Version 300\nCharset "WindowsCyrillic"\nDelimiter ","\nCoordSys NonEarth Units "m" Bounds (0, 0) (10000000, 10000000)\nColumns 2\n  X Decimal(15, 2)\n  Y Decimal(15, 2)\nData\n\n`;
            if (!contours || contours.length === 0 || contours.every(c => c.length === 0)) return "";

            const validContours = contours.filter(c => c.length > 0);
            if (validContours.length === 0) return "";

            mifContent += `Region ${validContours.length}\n`;
            validContours.forEach(contour => {
                mifContent += `${contour.length}\n`;
                contour.forEach(p => mifContent += `${p.y.toFixed(2)} ${p.x.toFixed(2)}\n`);
            });
            return mifContent;
        }

        function generateDXF(contours) {
            let dxfContent = `0\nSECTION\n2\nHEADER\n0\nENDSEC\n0\nSECTION\n2\nTABLES\n0\nENDSEC\n0\nSECTION\n2\nBLOCKS\n0\nENDSEC\n0\nSECTION\n2\nENTITIES\n`;
            if (!contours || contours.length === 0 || contours.every(c => c.length === 0)) {
                dxfContent += `0\nSEQEND\n0\nENDSEC\n0\nEOF\n`;
                return dxfContent;
            }

            const validContours = contours.filter(c => c.length > 0);

            validContours.forEach((contour) => {
                let isClosedPoly = false;
                if (contour.length > 2) {
                     const firstPt = contour[0];
                     const lastPt = contour[contour.length - 1];
                     if (Math.abs(firstPt.x - lastPt.x) < 1e-3 && Math.abs(firstPt.y - lastPt.y) < 1e-3) {
                         isClosedPoly = true;
                     }
                }

                dxfContent += `0\nLWPOLYLINE\n8\n0\n66\n1\n70\n${isClosedPoly ? 1 : 0}\n90\n${contour.length}\n`;
                contour.forEach(p => dxfContent += `10\n${p.y.toFixed(2)}\n20\n${p.x.toFixed(2)}\n`);
            });
            dxfContent += `0\nENDSEC\n0\nEOF\n`;

            return dxfContent;
        }

        function downloadFile(content, filename, contentType) {
            const blob = new Blob([content], { type: contentType });
            const a = document.createElement('a');
            a.href = URL.createObjectURL(blob);
            a.download = filename;
            document.body.appendChild(a); a.click(); document.body.removeChild(a);
            URL.revokeObjectURL(a.href);
        }

        exportMifBtn.addEventListener('click', () => {
            if (currentParcelContoursXML) {
                const mifContent = generateMIF(currentParcelContoursXML);
                if (mifContent) downloadFile(mifContent, `${currentParcelDataXML?.cadNumber?.replace(/:/g,'_') || 'parcel'}.mif`, 'application/vnd.mif');
                else showError("Не удалось сгенерировать MIF: нет валидных контуров.", 'xml');
            } else {
                showError("Нет данных XML для экспорта MIF.", 'xml');
            }
        });
        exportDxfBtn.addEventListener('click', () => {
             if (currentParcelContoursXML) {
                const dxfContent = generateDXF(currentParcelContoursXML);
                const hasDrawableContours = currentParcelContoursXML.some(c => c.length > 0);
                if (dxfContent && hasDrawableContours) {
                    downloadFile(dxfContent, `${currentParcelDataXML?.cadNumber?.replace(/:/g,'_') || 'parcel'}.dxf`, 'application/dxf');
                } else if (!hasDrawableContours) {
                    showError("Нет валидных контуров в XML для экспорта DXF.", 'xml');
                } else {
                     showError("Не удалось сгенерировать DXF.", 'xml');
                }

            } else {
                 showError("Нет данных XML для экспорта DXF.", 'xml');
            }
        });

        exportTxtBtn.addEventListener('click', () => {
            if (!currentParcelContoursXML || currentParcelContoursXML.length === 0 || currentParcelContoursXML.every(c => c.length === 0)) {
                showError("Нет данных XML для экспорта координат.", 'xml');
                return;
            }

            const startPointNumberStr = prompt("Введите номер для первой точки (оставьте пустым для формата N[tab]E):", "");
            const cadNumForFilename = currentParcelDataXML?.cadNumber?.replace(/:/g, '_') || 'parcel';
            let txtContent = "";
            let filename = `${cadNumForFilename}_coords_Northing_Easting.txt`;

            if (startPointNumberStr === null) {
                return;
            }

            if (startPointNumberStr.trim() === "") {
                const coordsForExport = getCoordinatesForDefaultTxtExport(currentParcelContoursXML);
                txtContent = coordsForExport.join('\n');
            } else {
                const startPointNumber = parseInt(startPointNumberStr, 10);
                if (!isNaN(startPointNumber)) {
                    let currentPointNum = startPointNumber;
                    const numberedLines = [];
                    currentParcelContoursXML.forEach((contour) => {
                        if (contour.length === 0) return;
                        contour.forEach(point => {
                            numberedLines.push(`${currentPointNum},${point.x.toFixed(2)},${point.y.toFixed(2)}`);
                            currentPointNum++;
                        });
                        if (currentParcelContoursXML.filter(c => c.length > 0).length > 1 &&
                            currentParcelContoursXML.indexOf(contour) < currentParcelContoursXML.length -1 &&
                            contour !== currentParcelContoursXML[currentParcelContoursXML.length-1] &&
                            currentParcelContoursXML[currentParcelContoursXML.indexOf(contour)+1].length > 0
                           ) {
                           numberedLines.push("");
                        }
                    });
                    txtContent = numberedLines.join('\n');
                    filename = `${cadNumForFilename}_coords_Num_N_E.txt`;
                } else {
                    alert("Номер начальной точки введен некорректно. Будет использован формат N[tab]E.");
                    const coordsForExport = getCoordinatesForDefaultTxtExport(currentParcelContoursXML);
                    txtContent = coordsForExport.join('\n');
                }
            }

            if (txtContent || (txtContent === "" && filename.includes("_Num_N_E.txt") && currentParcelContoursXML.every(c => c.length === 0) ) ) {
                downloadFile(txtContent, filename, 'text/plain;charset=utf-8');
            } else if (!txtContent && currentParcelContoursXML.some(c => c.length > 0)) {
                showError("Не удалось сгенерировать TXT: ошибка обработки координат.", 'xml');
            }
        });

         async function checkClipboardAndAutoSearch() {
            if (!navigator.clipboard || !navigator.clipboard.readText) {
                return;
            }

            try {
                const text = await navigator.clipboard.readText();
                const trimmedText = text.trim();

                if (!trimmedText) {
                    return; // Выход, если буфер обмена пуст
                }

                // Не вставлять, если текст содержит буквы или является слишком длинным.
                // Длинный, но действительный кадастровый номер вряд ли превысит 30 символов.
                // Это предотвращает вставку случайного длинного текста, но позволяет работать со всеми валидными номерами.
                if (/[a-zA-Zа-яА-Я]/.test(trimmedText) || trimmedText.length > 30) {
                    return;
                }

                const tempInputHolder = { value: trimmedText };
                formatCadastralNumber(tempInputHolder);
                const formattedNumber = tempInputHolder.value;

                if (isValidCadastralNumber(formattedNumber)) {
                    if (cadastralInput && loadParcelBtn) {
                        cadastralInput.value = formattedNumber;
                        if (!loadParcelBtn.disabled) {
                            loadParcelBtn.click();
                        }
                    }
                }
            } catch (err) {
                // Не выводить ошибок, если, например, нет разрешений на чтение буфера обмена
            }
        }
        
        window.addEventListener('DOMContentLoaded', () => {
            const h2XML = parcelInfoSectionXMLDiv.querySelector('#h2XMLHeader');
            if (h2XML) h2XML._initialTextContent = h2XML.textContent;
            const h2EGRN = parcelInfoSectionEGRNDiv.querySelector('#h2EGRNHeader');
            if (h2EGRN) h2EGRN._initialTextContent = h2EGRN.textContent;

            checkClipboardAndAutoSearch();
        });
    </script>
</body>
</html>