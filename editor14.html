<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ГеоРедактор</title>
    <link rel="stylesheet" href="webfonts/all.min.css">
    <link rel="icon" href="img/ed.png" type="image/png">
    <script src="webfonts/jszip.min.js"></script>
 

    <style>
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            margin: 0;
            background-color: #f0f0f0;
            overflow: hidden;
        }

        #objectAnalysisContainer {
            position: fixed;
            left: 20%;
            top: 0;
            width: 80%;
            height: 100vh;
            background: white;
            z-index: 999;
        }

        #objectAnalysisCanvas {
            width: 100%;
            height: 100%;
            cursor: grab;
        }
         #objectAnalysisCanvas.drawing-mode {
             cursor: crosshair;
         }
         #objectAnalysisCanvas.editing-point-mode {
             cursor: move;
         }
         #objectAnalysisCanvas.geometry-edit-mode-add {
            cursor: cell;
         }
         #objectAnalysisCanvas.geometry-edit-mode-hover-point {
            cursor: pointer;
         }


        #infoPanel {
            position: fixed;
            top: 0;
            left: 0;
            width: 20%;
            height: 100vh;
            background-color: #f8f8f8;
            border-right: 1px solid #ddd;
            overflow-y: auto;
            z-index: 1000;
            padding: 20px;
            user-select: none;
            box-shadow: 2px 0 10px rgba(0,0,0,0.1);
        }

        .action-button {
            position: absolute;
            right: 20px;
            background-color: #4a69bd;
            color: white;
            border: none;
            padding: 10px;
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            width: 50px;
            height: 50px;
            font-size: 18px;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }
        .action-button:hover {
            transform: scale(1.1);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.3);
        }
         .action-button:active {
             transform: scale(0.95);
         }
         .action-button.active {
              box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
              transform: scale(0.98);
         }

        #addObjectBtn {
            bottom: 20px;
            background-color: #4a69bd;
        }
        #addObjectBtn:hover { background-color: #354f9e; }

        #drawObjectBtn {
             bottom: 80px;
             background-color: #f39c12;
         }
         #drawObjectBtn:hover { background-color: #e67e22; }
         #drawObjectBtn.active { background-color: #d35400; }

         #finishDrawingBtn {
             bottom: 80px;
             background-color: #2ecc71;
             display: none;
         }
         #finishDrawingBtn:hover { background-color: #27ae60; }

        #togglePointsBtn {
             bottom: 140px;
             background-color: #e74c3c;
         }
        #togglePointsBtn:hover { background-color: #c0392b; }

        #rulerBtn {
            bottom: 200px;
            background-color: #3498db;
        }
        #rulerBtn:hover { background-color: #2980b9; }
        #rulerBtn.active { background-color: #27ae60; }


               #toggleGeometryEditBtn {
            bottom: 260px;
            background-color: #9b59b6;
        }
        #toggleGeometryEditBtn:hover {
            background-color: #8e44ad; 
        }
        #toggleGeometryEditBtn.active {
            background-color: #e74c3c; 
        }
        #toggleGeometryEditBtn.active:hover {
            background-color: #c0392b; 
        }


        #undoGeometryChangeBtn {
            bottom: 320px;
            background-color: #e67e22;
            display: none;
        }
        #undoGeometryChangeBtn:hover { background-color: #d35400; }
        #undoGeometryChangeBtn:disabled {
            background-color: #bdc3c7;
            cursor: not-allowed;
            transform: scale(1);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }


        #measurementPanel {
            position: absolute;
            bottom: 80px;
            left: 20px;
            background-color: rgba(255, 255, 255, 0.9);
            padding: 10px 15px;
            border-radius: 5px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
            font-size: 14px;
            max-width: 300px;
            display: none;
            z-index: 1100;
        }
        #measurementPanel.active { display: block; animation: fadeIn 0.3s; }
        .measurement-title { font-weight: bold; margin-bottom: 8px; color: #2c3e50; display: flex; align-items: center; }
        .measurement-title i { margin-right: 5px; color: #3498db; }
        .measurement-coordinates { margin-bottom: 8px; padding-left: 10px; border-left: 3px solid #3498db; font-family: monospace; }
        .measurement-distance { font-weight: bold; color: #e74c3c; font-size: 16px; text-align: center; margin-top: 8px; padding: 5px; background-color: rgba(231, 76, 60, 0.1); border-radius: 3px; }
        #resetMeasurementBtn { background-color: #3498db; color: white; border: none; padding: 5px 10px; border-radius: 3px; margin-top: 8px; cursor: pointer; width: 100%; transition: background-color 0.3s; }
        #resetMeasurementBtn:hover { background-color: #2980b9; }

               #gridInfoPanel {
            position: absolute;
            bottom: 20px;
            left: calc(20% + 20px);
            background-color: rgba(255, 255, 255, 0.85);
            padding: 8px 12px;
            border-radius: 5px;
            font-size: 12px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            z-index: 1000;
            display: flex;
            align-items: center;
            pointer-events: none;
            transition: opacity 0.3s;
            opacity: 0.8;
            color: royalblue;
        }
        #gridInfoPanel i { margin-right: 5px; color: royalblue; }
        #gridInfoPanel:hover { opacity: 1; }

        #cursorInfoPanel {
            position: absolute;
            bottom: 20px;
            left: calc(20% + 150px);
            background-color: rgba(255, 255, 255, 0.85);
            padding: 8px 12px;
            border-radius: 5px;
            font-size: 12px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            z-index: 1000;
            display: flex;
            align-items: center;
            pointer-events: none;
            transition: opacity 0.3s;
            opacity: 0.8;
            color: royalblue;
        }
        #cursorInfoPanel i { margin-right: 5px; color: royalblue; }
        #cursorInfoPanel:hover { opacity: 1; }


        #selectedObjectInfo h3 {
            text-align: center;
            font-size: 1.2em;
            margin-bottom: 10px;
            color: #336699;
            border-bottom: 2px solid #336699;
            padding-bottom: 5px;
            font-weight: bold;
            cursor: pointer;
        }
         #selectedObjectInfo h3:hover {
             color: #4a69bd;
         }
        #selectedObjectInfo .info-item {
            display: flex;
            justify-content: space-between;
            padding: 6px 0;
            border-bottom: 1px solid #eee;
        }
        #selectedObjectInfo .info-item span:first-child {
            font-weight: bold;
            color: #555;
            margin-right: 10px;
        }
        #selectedObjectInfo .info-item span:last-child {
            color: #333;
            text-align: right;
        }
        #selectedObjectInfo .info-item span.copyable {
             cursor: pointer;
             transition: color 0.2s;
        }
         #selectedObjectInfo .info-item span.copyable:hover {
              color: #4a69bd;
         }
         .flash {
            animation: flash 0.5s;
        }
        @keyframes flash {
            0%, 100% { background-color: inherit; }
            50% { background-color: #90EE90; }
        }


        #coordsDialog {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 400px;
            background-color: white;
            border-radius: 10px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            z-index: 2000;
            padding: 20px;
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        @keyframes fadeInDialog { from { opacity: 0; transform: translate(-50%, -50%) scale(0.95); } to { opacity: 1; transform: translate(-50%, -50%) scale(1); } }
        #coordsDialog.show {
             opacity: 1;
             animation: fadeInDialog 0.3s ease-out forwards;
        }
        #coordsDialog h3 { margin: 0 0 15px; font-size: 18px; color: #333; }
        #coordsInput {
            width: 100%;
            height: 150px;
            padding: 8px;
            border: 1px solid #ccc;
            border-radius: 4px;
            box-sizing: border-box;
            resize: vertical;
            font-size: 14px;
            margin-bottom: 15px;
            transition: border-color 0.3s;
        }
        #coordsInput:focus { border-color: #4a69bd; box-shadow: 0 0 5px rgba(74, 105, 189, 0.5); outline: none; }
        .dialog-buttons { display: flex; justify-content: space-between; gap: 10px; }
        #importCoordsBtn, #importFromFileBtn, #closeDialogBtn {
            background-color: #4a69bd;
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s;
            flex: 1;
            font-size: 14px;
            position: relative;
            overflow: hidden;
        }
        #importCoordsBtn:hover, #importFromFileBtn:hover {
            background-color: #354f9e;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }
        #importCoordsBtn:active, #importFromFileBtn:active, #closeDialogBtn:active {
            transform: translateY(1px);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        #closeDialogBtn { background-color: #dc3545; }
        #closeDialogBtn:hover { background-color: #c82333; transform: translateY(-2px); box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2); }

        #dialogOverlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0);
            z-index: 1999;
            backdrop-filter: blur(0px);
            opacity: 0;
            transition: opacity 0.3s ease, background-color 0.3s ease, backdrop-filter 0.3s ease;
        }
        #dialogOverlay.show {
             opacity: 1;
             background-color: rgba(0, 0, 0, 0.5);
             backdrop-filter: blur(2px);
        }


        #tooltip {
            position: absolute;
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 12px;
            pointer-events: none;
            z-index: 1001;
            display: none;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
            font-weight: bold;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
        }

        .notification {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 15px 20px;
            border-radius: 5px;
            color: white;
            font-size: 14px;
            z-index: 9999;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            transform: translateX(120%);
            transition: transform 0.3s ease;
            max-width: 300px;
            border: 1px solid rgba(0, 0, 0, 0.1);
            text-shadow: 0 0 2px rgba(0, 0, 0, 0.5);
        }
        .notification.info { background-color: #3498db; }
        .notification.success { background-color: #4CAF50; }
        .notification.error { background-color: #F44336; }
        .notification.warning { background-color: #FF9800; }
        .notification.show { transform: translateX(0); }
        .notification i { margin-right: 10px; }

        #loaderContainer {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background-color: rgba(173, 216, 230, 0.9);
            display: none; justify-content: center; align-items: center;
            z-index: 10000; backdrop-filter: blur(3px); flex-direction: column;
        }
        .spinner-container { width: 80px; height: 80px; position: relative; }
        .spinner-ring { position: absolute; width: 100%; height: 100%; border-radius: 50%; border: 6px solid transparent; border-top-color: #3498db; animation: spin 1.2s cubic-bezier(0.5, 0, 0.5, 1) infinite; box-sizing: border-box; }
        .spinner-ring:before, .spinner-ring:after { content: ''; position: absolute; border-radius: 50%; border: 6px solid transparent; box-sizing: border-box; }
        .spinner-ring:before { top: -6px; left: -6px; right: -6px; bottom: -6px; border-top-color: #2980b9; animation: spin 2s cubic-bezier(0.5, 0, 0.5, 1) infinite; }
        .spinner-ring:after { top: 6px; left: 6px; right: 6px; bottom: 6px; border-top-color: #6ab7e2; animation: spin 0.8s cubic-bezier(0.5, 0, 0.5, 1) infinite; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        .loading-text { color: #2c3e50; font-size: 18px; font-weight: bold; margin-top: 30px; letter-spacing: 1px; text-shadow: 0 1px 2px rgba(255, 255, 255, 0.5); animation: pulse 1.5s ease infinite; text-align: center; line-height: 1.5; min-height: 50px; }
        @keyframes pulse { 0%, 100% { opacity: 0.7; } 50% { opacity: 1; } }

        .coordinates-table {
            width: 100%; border-collapse: collapse; margin-top: 15px;
            animation: fadeInCoords 0.3s ease;
        }
        @keyframes fadeInCoords {
            from { opacity: 0; transform: translateY(-10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .coordinates-table th, .coordinates-table td { border: 1px solid #ddd; padding: 8px; text-align: center; }
        .coordinates-table th { background-color: #f2f2f2; }
        .coordinate-row { cursor: pointer; transition: background-color 0.3s; }
        .coordinate-row:hover { background-color: #f0f8ff; }
        .coordinate-row.selected-coordinate { background-color: #ffebee !important; border-left: 3px solid #f44336; font-weight: bold; }
        .coordinate-row .copyable { cursor: pointer; }

        .panel-button {
            margin-top: 10px; width: 100%; padding: 10px; color: white;
            border: none; border-radius: 5px; cursor: pointer; transition: all 0.3s;
            display: flex; align-items: center; justify-content: center;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
        .panel-button:hover { transform: translateY(-2px); box-shadow: 0 4px 8px rgba(0,0,0,0.3); }
        .panel-button:active { transform: translateY(1px); box-shadow: 0 1px 2px rgba(0,0,0,0.2); }
        .panel-button i { margin-right: 8px; }

        #showCoordinatesBtn { background-color: #4a69bd; margin-bottom: 10px; }
        #showCoordinatesBtn:hover { background-color: #354f9e; }

        #copyAllCoordinatesBtn {
            background-color: #1abc9c;
            margin-bottom: 10px;
        }
        #copyAllCoordinatesBtn:hover {
            background-color: #16a085;
        }

        #centerObjectBtn { background-color: #2ecc71; margin-bottom: 10px; }
        #centerObjectBtn:hover { background-color: #27ae60; }
        #renameObjectBtn { background-color: #f39c12; margin-bottom: 10px; }
        #renameObjectBtn:hover { background-color: #e67e22; }
        #deleteObjectBtn { background-color: #e74c3c; }
        #deleteObjectBtn:hover { background-color: #c0392b; }


        .panel-section {
            padding-bottom: 15px;
            margin-bottom: 15px;
            border-bottom: 1px solid #ddd;
        }
        .panel-section:last-child { border-bottom: none; margin-bottom: 0; }
        .section-title {
            background-color: #4a69bd; color: white; padding: 8px 12px;
            border-radius: 4px; margin-top: 15px; margin-bottom: 10px;
            font-weight: bold; position: relative; overflow: hidden;
            font-size: 0.9em;
        }
        .section-title i { margin-right: 8px; }

        .section-title-action {
            position: absolute;
            right: 12px;
            top: 50%;
            transform: translateY(-50%);
            cursor: pointer;
            transition: color 0.2s, transform 0.2s;
            opacity: 0.8;
        }
        .section-title-action:hover {
            color: #ffdddd;
            transform: translateY(-50%) scale(1.15);
            opacity: 1;
        }
        .section-title-action:active {
             transform: translateY(-50%) scale(1.05);
        }

        #intersectionList {
            list-style: none; padding: 0; margin-top: 10px;
        }
        #intersectionList li {
            padding: 8px 12px; border: 1px solid #ddd; margin-bottom: 5px;
            border-radius: 4px; background-color: #fff; cursor: pointer;
            transition: all 0.2s; position: relative; overflow: hidden;
            font-size: 0.9em;
        }
        #intersectionList li:hover {
            background-color: #f0f0f0; transform: translateX(5px);
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        #intersectionList li:before {
            content: ''; position: absolute; left: 0; top: 0; height: 100%;
            width: 3px; background-color: #4a69bd; transform: scaleY(0);
            transition: transform 0.2s;
        }
        #intersectionList li:hover:before { transform: scaleY(1); }
         #intersectionList li.full-containment { border-left: 3px solid #27ae60; background-color: #e8f8f5; }
         #intersectionList li.contained-by { border-left: 3px solid #af7ac5; background-color: #f4ecf7; }
         #intersectionList li.partial-overlap { border-left: 3px solid #f39c12; background-color: #fef9e7; }
         #intersectionList li .overlap-details { font-size: 0.8em; color: #666; margin-top: 3px; display: block; }

        #objectListContainer { max-height: 250px; overflow-y: auto; }
        #objectList li {
             padding: 5px 8px; margin-bottom: 3px; border-radius: 3px;
             cursor: pointer; display: flex; align-items: center;
             border: 1px solid transparent; transition: background-color 0.2s, border-color 0.2s;
             font-size: 0.9em;
        }
         #objectList li:hover { background-color: #f0f0f0; }
         #objectList li.selected { background-color: #e0f2f7; border-color: #b3e5fc; font-weight: bold; }
         #objectList li .color-indicator {
             display: inline-block; width: 12px; height: 12px; border-radius: 3px;
             margin-right: 8px; flex-shrink: 0; border: 1px solid #ccc;
         }
         #objectList li .name-span {
             flex-grow: 1; overflow: hidden; white-space: nowrap; text-overflow: ellipsis;
         }


        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-10px); }
            to { opacity: 1; transform: translateY(0); }
        }


        #namePromptOverlay {
            display: none;
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background-color: rgba(0, 0, 0, 0.4);
            z-index: 2999;
            backdrop-filter: blur(1.5px);
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        #namePromptOverlay.show {
            opacity: 1;
            display: block;
        }

        #namePromptDialog {
            display: none;
            position: fixed;
            top: 40%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0.95);
            width: 350px;
            background-color: white;
            border-radius: 10px;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.25);
            z-index: 3000;
            padding: 25px;
            opacity: 0;
            transition: opacity 0.3s ease, transform 0.3s ease;
            box-sizing: border-box;
        }

        #namePromptDialog.show {
            opacity: 1;
            transform: translate(-50%, -50%) scale(1);
            display: block;
        }

        #namePromptDialog h3 {
            margin: 0 0 20px;
            font-size: 1.2em;
            color: #333;
            text-align: center;
            font-weight: 600;
        }

        #namePromptInput {
            width: 100%;
            padding: 12px 10px;
            border: 1px solid #ccc;
            border-radius: 5px;
            box-sizing: border-box;
            font-size: 1em;
            margin-bottom: 20px;
            transition: border-color 0.3s, box-shadow 0.3s;
        }
        #namePromptInput:focus {
            border-color: #4a69bd;
            box-shadow: 0 0 0 3px rgba(74, 105, 189, 0.2);
            outline: none;
        }
        #namePromptDialog .dialog-buttons {
            justify-content: space-between;
        }

        #namePromptSaveBtn, #namePromptCancelBtn {
            background-color: #4a69bd;
            color: white; border: none; padding: 10px 15px; border-radius: 5px;
            cursor: pointer; transition: all 0.3s; flex-basis: 48%;
            font-size: 0.95em; display: flex; align-items: center; justify-content: center; gap: 5px;
        }
        #namePromptSaveBtn:hover { background-color: #354f9e; transform: translateY(-1px); }
        #namePromptSaveBtn:active { transform: translateY(0px); }

        #namePromptCancelBtn {
            background-color: #6c757d;
        }
        #namePromptCancelBtn:hover { background-color: #5a6268; transform: translateY(-1px); }
        #namePromptCancelBtn:active { transform: translateY(0px); }

         #viewInfoPanel {
            position: absolute;
            bottom: 20px;
            left: calc(20% + 420px);
            background-color: rgba(255, 255, 255, 0.85);
            padding: 8px 12px;
            border-radius: 5px;
            font-size: 12px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            z-index: 1000;
            display: flex;
            align-items: center;
            pointer-events: none;
            transition: opacity 0.3s;
            opacity: 0.8;
            color: #27ae60;
            white-space: nowrap;
        }
        #viewInfoPanel i {
             margin-right: 5px;
             color: #27ae60;
         }
        #viewInfoPanel:hover {
             opacity: 1;
         }
         
           @media (max-width: 768px) {
            /* Перемещаем кнопки действий в правый верхний угол на мобильных */
            .action-button {
                /* Обнуляем bottom, чтобы top сработал */
                bottom: auto !important; /* Используем !important для переопределения инлайновых стилей, если они есть, или высокой специфичности */
            }

            #addObjectBtn {
                top: 20px;
            }
            #drawObjectBtn, #finishDrawingBtn { /* finishDrawingBtn делит место с drawObjectBtn */
                top: 80px;
            }
            #togglePointsBtn {
                top: 140px;
            }
            #rulerBtn {
                top: 200px;
            }
            #toggleGeometryEditBtn {
                top: 260px;
            }
            #undoGeometryChangeBtn {
                top: 320px;
            }

            /* Если информационные панели снизу мешают кнопкам, их тоже можно сдвинуть */
            /* Например, если они накладываются */
            /*
            #gridInfoPanel, #cursorInfoPanel, #viewInfoPanel {
                bottom: auto;
                top: 20px;
            }
            #gridInfoPanel { left: 20px; }
            #cursorInfoPanel { left: 150px; }
            #viewInfoPanel { left: 280px; }
            */
        }
        
        #quarterLoadOptionsButtons .panel-button:hover {
    filter: brightness(110%);
}

/* Существующие стили для undo оставляем, добавляем для cutObjectBtn */
         #cutObjectBtn {
            bottom: 380px; 
            background-color: #34495e;
        }


        #cutObjectBtn:hover {
            background-color: #2c3e50;
        }
        #cutObjectBtn.active {
            background-color: #e74c3c; /* Красный при активности */
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.5);
        }
        
           #unionObjectBtn {
            bottom: 440px;
            background-color: #16a085;
            display: none;
        }
        #unionObjectBtn:hover {
            background-color: #1abc9c;
        }
        #unionObjectBtn.active {
            background-color: #e74c3c;
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.5);
        }

        #intersectPointsBtn {
            bottom: 500px; 
            background-color: #8e44ad;
        }
        
        #toggleLabelsDialogBtn.active {
            background-color: #138496 !important;
            box-shadow: inset 0 3px 5px rgba(0,0,0,0.2);
            border: 2px solid #0c5460;
        }

         @media (max-width: 768px) {
            #cutObjectBtn { top: 380px; bottom: auto !important; }
            #unionObjectBtn { top: 440px; bottom: auto !important; }
            #intersectPointsBtn { top: 500px; bottom: auto !important; }
        }
        
          #intersectPointsBtn {
            bottom: 500px; 
            background-color: #8e44ad;
        }
        
        
        #intersectPointsBtn:hover {
            background-color: #732d91;
        }
        #intersectPointsBtn.active {
            background-color: #e74c3c;
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.5);
        }
        
        @media (max-width: 768px) {
            #intersectPointsBtn {
                top: 440px;
                bottom: auto !important;
            }
        }
        
        #findCoordsBtn {
            background-color: #8e44ad; /* Фиолетовый цвет */
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 50%; /* Круглые края как у остальных */
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s;
            flex: 1;
            font-size: 14px;
        }
        #findCoordsBtn:hover {
            background-color: #732d91;
            transform: translateY(-2px);
        }
        
       #openSchemaBtn {
            background-color: #9b59b6;
            margin-bottom: 10px;
        }
        #openSchemaBtn:hover {
            background-color: #8e44ad; 
        }
        
          .visibility-toggle {
            margin-left: 10px;
            cursor: pointer;
            color: #777;
            padding: 5px;
            transition: color 0.2s;
            display: flex;
            align-items: center;
        }
        .visibility-toggle:hover {
            color: #333;
            transform: scale(1.1);
        }
        /* Убедимся, что иконка не сжимается */
        .visibility-toggle i {
            pointer-events: none;
        }
        
        /* Стили для кастомного подтверждения */
        #customConfirmOverlay {
            display: none;
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            z-index: 4000;
            backdrop-filter: blur(2px);
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        #customConfirmOverlay.show {
            opacity: 1;
            display: block;
        }

        #customConfirmDialog {
            display: none;
            position: fixed;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%) scale(0.95);
            width: 400px;
            background-color: white;
            border-radius: 12px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2);
            z-index: 4001;
            padding: 30px;
            box-sizing: border-box;
            opacity: 0;
            transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            text-align: center;
        }
        #customConfirmDialog.show {
            opacity: 1;
            transform: translate(-50%, -50%) scale(1);
            display: block;
        }
        #customConfirmTitle {
            margin: 0 0 15px;
            font-size: 1.3em;
            color: #222;
            font-weight: bold;
        }
        #customConfirmMessage {
            color: #555;
            margin-bottom: 25px;
            font-size: 1em;
            line-height: 1.5;
        }
        
     #customConfirmYesBtn {
            background-color: #2ecc71; 
            color: white;
            border: none;
            padding: 10px 30px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 1em;
            transition: all 0.2s;
            min-width: 100px;
            font-weight: bold;
            box-shadow: 0 2px 5px rgba(46, 204, 113, 0.3);
        }
        #customConfirmYesBtn:hover {
            background-color: #27ae60;
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(46, 204, 113, 0.4);
        }
        #customConfirmYesBtn:active {
            transform: translateY(0);
        }

        #customConfirmNoBtn {
            background-color: #e74c3c; 
            color: white;
            border: none;
            padding: 10px 30px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 1em;
            transition: all 0.2s;
            min-width: 100px;
            font-weight: bold;
            box-shadow: 0 2px 5px rgba(231, 76, 60, 0.3);
        }
        #customConfirmNoBtn:hover {
            background-color: #c0392b; 
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(231, 76, 60, 0.4);
        }
        #customConfirmNoBtn:active {
            transform: translateY(0);
        }
    </style>
</head>
<body>

<div id="infoPanel">
    <div class="panel-section">
        <h4>Информация об объекте</h4>
        <div id="selectedObjectInfo">
            <p style="color: #777; font-style: italic; text-align: center;">Выберите объект на схеме (двойной клик) или добавьте новый.</p>
        </div>
        <div id="coordinatesTableContainer"></div>
    </div>

    <div class="panel-section">
        <div class="section-title" style="display: none;" id="intersectionsTitle">
            <i class="fas fa-vector-square"></i> Пересечения и Наложения
        </div>
        <div id="intersectionsContainer">
            <ul id="intersectionList"></ul>
        </div>
    </div>

    <div class="panel-section">
       <div class="section-title">
            <i class="fas fa-list"></i> Список объектов (<span id="objectCount">0</span>)
            
                <span id="hideAllObjectsBtn" class="section-title-action" title="Скрыть все объекты (видимость)" style="right: 100px;">
                <i class="fas fa-eye-slash"></i>
            </span>
            
              <span id="showAllObjectsBtn" class="section-title-action" title="Показать все" style="right: 40px;">
                <i class="fas fa-expand"></i>
                            </span>
                            
                            <span id="showAdjacentPointsBtn" class="section-title-action" title="Показать точки смежных (1м)" style="right: 70px;">
    <i class="fas fa-dot-circle"></i>
</span>


            <span id="deleteAllObjectsBtn" class="section-title-action" title="Удалить все объекты">
                <i class="fas fa-eraser"></i>
            </span>
        </div>
        <div id="objectListContainer">
            <ul id="objectList"></ul>
        </div>
    </div>
</div>

<div id="objectAnalysisContainer">
    <canvas id="objectAnalysisCanvas"></canvas>
    <button id="addObjectBtn" class="action-button" title="Добавить объект из координат">
        <i class="fas fa-plus"></i>
    </button>
    <button id="drawObjectBtn" class="action-button" title="Нарисовать объект">
        <i class="fas fa-pencil-alt"></i>
    </button>
    <button id="finishDrawingBtn" class="action-button" title="Завершить создание объекта">
        <i class="fas fa-check"></i>
    </button>
    <button id="togglePointsBtn" class="action-button" title="Показать/скрыть точки">
        <i class="fas fa-map-marker-alt"></i>
    </button>
    <button id="rulerBtn" class="action-button" title="Измерить расстояние">
        <i class="fas fa-ruler"></i>
    </button>
    <button id="toggleGeometryEditBtn" class="action-button" title="Редактировать геометрию">
        <i class="fas fa-edit"></i>
    </button>
    <button id="undoGeometryChangeBtn" class="action-button" title="Отменить изменение геометрии">
        <i class="fas fa-undo"></i>
    </button>
    
      <button id="cutObjectBtn" class="action-button" title="Рассечение объекта (Разность)" style="display: none;">
        <i class="fas fa-cut"></i>
    </button>
        <button id="unionObjectBtn" class="action-button" title="Объединение объектов" style="display: none;">
        <i class="fas fa-object-group"></i>
    </button>
    
       <button id="intersectPointsBtn" class="action-button" title="Создать точки пересечения" style="display: none;">
        <i class="fas fa-project-diagram"></i>
    </button>


    <div id="measurementPanel">
        <div class="measurement-title"><i class="fas fa-ruler"></i> Измерение</div>
        <div class="measurement-coordinates" id="measurementCoordinates">...</div>
        <div class="measurement-distance" id="measurementDistance">Расстояние: -</div>
        <button id="resetMeasurementBtn">Сбросить</button>
    </div>

    <div id="gridInfoPanel">
        <i class="fas fa-th"></i>
        <span id="gridStepText"></span>
    </div>
    <div id="cursorInfoPanel">
        <i class="fas fa-mouse-pointer"></i>
        <span id="cursorCoordinates">X: 0.00, Y: 0.00</span>
    </div>
      <div id="viewInfoPanel">
        <i class="fas fa-ruler-horizontal"></i>
        <span id="viewInfoText">Обзор: -</span>
    </div>
</div>

<div id="tooltip"></div>

<div id="dialogOverlay"></div>
<div id="coordsDialog">
    <h3>Добавить объект</h3>
    
        <div style="display: flex; gap: 10px; margin-bottom: 15px; padding-bottom: 15px; border-bottom: 1px solid #eee;">
        <button id="saveProjectBtn" class="panel-button" style="margin: 0; background-color: #27ae60;">
            <i class="fas fa-file-export"></i> Сохранить проект
        </button>
        <button id="openProjectBtn" class="panel-button" style="margin: 0; background-color: #e67e22;">
            <i class="fas fa-folder-open"></i> Открыть проект
        </button>
          <button id="toggleLabelsDialogBtn" class="panel-button" style="margin: 0; background-color: #17a2b8;">
            <i class="fas fa-tag"></i> Подписи координат
        </button>
        
        <!-- Скрытый инпут для загрузки файла -->
        <input type="file" id="projectFileInput" accept=".geoed" style="display: none;">
    </div>
    
       <div style="margin-bottom: 15px; text-align: left;">
        <label for="importModeSelect" style="text-align: left; margin-bottom: 5px; font-size: 14px;">Режим загрузки для кадастровых номеров:</label>
        <select id="importModeSelect" style="width: 100%; padding: 8px; border-radius: 4px; border: 1px solid #ccc;">
            <!-- Опции будут добавлены через JavaScript -->
        </select>
    </div>
    
      <div style="margin-bottom: 10px; display: flex; align-items: center; gap: 10px; background: #f9f9f9; padding: 8px; border-radius: 4px;">
        <input type="checkbox" id="useFixedColor" style="cursor: pointer;">
        <label for="useFixedColor" style="cursor: pointer; user-select: none;">Использовать фиксированный цвет:</label>
        <input type="color" id="importColorInput" value="#FF0000" style="cursor: pointer; height: 25px; border: none; background: none;">
    </div>
    
<textarea id="coordsInput" placeholder="Варианты ввода:
1. Координаты (X Y или X tab Y)
2. Кадастровые номера или номера кварталов (каждый с новой строки)
3. Кадастровый номер (1-я строка) и координаты (со 2-й строки) — для создания объекта с именем {кадастровый номер}"></textarea>

<div class="dialog-buttons">
        <button id="importCoordsBtn">
            <i class="fas fa-cloud-download-alt"></i> Загрузить и Добавить
        </button>
        <button id="importFromFileBtn" title="Импорт координат из TXT/CSV файла (X Y или Y X)">
            <i class="fas fa-file-upload"></i> Файл (X Y)
        </button>
        <!-- НОВАЯ КНОПКА -->
        <button id="findCoordsBtn" title="Отобразить каждую координату как отдельную точку (прицел)">
            <i class="fas fa-crosshairs"></i> Найти координаты
        </button>
        <!-- КОНЕЦ НОВОЙ КНОПКИ -->
        <button id="closeDialogBtn">
            <i class="fas fa-times"></i> Закрыть
        </button>
    </div>
</div>

<div id="loaderContainer">
  <div class="spinner-container">
    <div class="spinner-ring"></div>
  </div>
  <div class="loading-text">Загрузка...</div>
  <!-- Добавлена кнопка отмены -->
  <button id="cancelLoadBtn" style="margin-top: 20px; padding: 8px 20px; background: #e74c3c; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 14px; display: none;">
      <i class="fas fa-times"></i> Отменить
  </button>
</div>

<div id="namePromptOverlay"></div>
<div id="namePromptDialog">
    <h3 id="namePromptTitle">Имя объекта</h3>
    <input type="text" id="namePromptInput" placeholder="Введите имя...">
    <div class="dialog-buttons">
        <button id="namePromptSaveBtn">
            <i class="fas fa-check"></i> Сохранить
        </button>
        <button id="namePromptCancelBtn">
            <i class="fas fa-times"></i> Отмена
        </button>
    </div>
</div>

<div id="quarterLoadOptionsDialog" style="display: none; position: fixed; top: 40%; left: 50%; transform: translate(-50%, -50%); width: 400px; background-color: white; border-radius: 10px; box-shadow: 0 5px 20px rgba(0, 0, 0, 0.25); z-index: 3000; padding: 25px; box-sizing: border-box; text-align: center;">
    <h3 id="quarterLoadOptionsTitle" style="margin: 0 0 20px; font-size: 1.2em; color: #333; font-weight: 600;">Режим загрузки квартала</h3>
    <div id="quarterLoadOptionsButtons" style="display: flex; flex-direction: column; gap: 10px;">
        <button data-load-type="all" class="panel-button" style="background-color: #3498db; margin: 0;"><i class="fas fa-layer-group"></i> Загрузить все объекты</button>
        <button data-load-type="zu" class="panel-button" style="background-color: #2ecc71; margin: 0;"><i class="fas fa-map-marked-alt"></i> Только Земельные Участки (ЗУ)</button>
       <button data-load-type="oks" class="panel-button" style="background-color: #e67e22; margin: 0;"><i class="fas fa-building"></i> Только Здания</button>
        <button data-load-type="construction" class="panel-button" style="background-color: #f1c40f; margin: 0;"><i class="fas fa-industry"></i> Только Сооружения</button>
        <button data-load-type="adjacent" class="panel-button" style="background-color: #9b59b6; margin: 0;"><i class="fas fa-vector-square"></i> Только смежные объекты</button>
    </div>
    <button id="quarterLoadOptionsCancelBtn" class="panel-button" style="background-color: #6c757d; margin-top: 20px;">
        <i class="fas fa-times"></i> Отмена
    </button>
</div>


<!-- Диалог выбора действия при пересечении -->
<div id="intersectionOptionsDialog" style="display: none; position: fixed; top: 40%; left: 50%; transform: translate(-50%, -50%); width: 450px; background-color: white; border-radius: 10px; box-shadow: 0 5px 20px rgba(0, 0, 0, 0.25); z-index: 3000; padding: 25px; box-sizing: border-box; text-align: center;">
    <h3 style="margin: 0 0 15px; font-size: 1.2em; color: #333; font-weight: 600;">Пересечение найдено</h3>
    <p id="intersectionCountText" style="margin-bottom: 20px; color: #666;">Найдено точек: 0</p>
    
    <div style="display: flex; flex-direction: column; gap: 10px;">
        <button onclick="applyIntersectionChoice('create_only')" class="panel-button" style="background-color: #3498db; margin: 0;">
            <i class="fas fa-map-marker-alt"></i> 1. Создать только точки (новые объекты)
        </button>
        <button onclick="applyIntersectionChoice('modify_both')" class="panel-button" style="background-color: #8e44ad; margin: 0;">
            <i class="fas fa-vector-square"></i> 2. Создать точки в обоих полигонах
        </button>
        <button onclick="applyIntersectionChoice('modify_first')" class="panel-button" style="background-color: #e67e22; margin: 0;">
            <i class="fas fa-draw-polygon"></i> 3. Создать точки только в объекте №1
        </button>
        <button onclick="applyIntersectionChoice('modify_second')" class="panel-button" style="background-color: #2ecc71; margin: 0;">
            <i class="fas fa-draw-polygon"></i> 4. Создать точки только в объекте №2
        </button>
    </div>
    
    <button onclick="closeIntersectionDialog()" class="panel-button" style="background-color: #6c757d; margin-top: 20px;">
        <i class="fas fa-times"></i> Отмена
    </button>
</div>

<div id="customConfirmOverlay"></div>
<div id="customConfirmDialog">
    <h3 id="customConfirmTitle">Подтвердите действие</h3>
    <p id="customConfirmMessage">Текст сообщения...</p>
    <div class="dialog-buttons" style="justify-content: center; gap: 15px;">
        <button id="customConfirmYesBtn">Да</button>
        <button id="customConfirmNoBtn">Нет</button>
    </div>
</div>


  <script src="webfonts/proj4.js"></script>
<script src="sk.js"></script>

<script>

     let userObjects = [];
    let selectedObjectIndex = -1;
    let nextObjectId = 1;
    const objectColors = [ '#FF6347', '#4682B4', '#32CD32', '#FFD700', '#6A5ACD', '#FF4500', '#1E90FF', '#ADFF2F', '#DAA520', '#8A2BE2', '#DC143C', '#00CED1', '#9ACD32', '#FF8C00', '#9932CC' ];
    let nextColorIndex = 0;

    let scale = 1;
    let offsetX = 0;
    let offsetY = 0;
    let minX = undefined, minY = undefined, maxX = undefined, maxY = undefined;

    let isDragging = false;
    let startX, startY;
    let lastOffsetX = 0, lastOffsetY = 0;
    let selectedCoordinate = null;
    let showPoints = true;

    let rulerMode = false;
    let rulerPoints = [];
    let isDrawingMode = false;
    let isDrawingActive = false;
    let currentDrawingPoints = [];
    let currentMousePos = { x: 0, y: 0 };

    let isGeometryEditMode = false;
    let editingObjectIndex = -1;
    let isMovingPoint = false;
    let movedPointInfo = null;
    let snappedToPointVisual = null;
    let geometryHistory = [];
    
    let isNspdLoadCancelled = false; 
    
       let isCutToolActive = false;
    let cutTargetIndex = -1; 
    
    let isUnionToolActive = false;
    let unionTargetIndex = -1;
    
    let isIntersectToolActive = false;
let intersectTargetIndex = -1;

 let pendingIntersectionData = null
 let showLabels = false;
 
    let adjacentPointsMode = false;
    let adjacentObjectIndices = new Set();
    
    const MAX_GEOMETRY_HISTORY = 10;

    const SNAP_RADIUS_SCREEN = 10;
    const ADD_POINT_THRESHOLD_SCREEN = 7;
    const GRAB_POINT_RADIUS_SCREEN = 7;
    window.lastPointMoveEndTime = 0;

const STORAGE_API_URL = 'https://mapruapp.ru/storage';
const BUCKET_NAME = 'kpt';

    const sevenDigitsRegions = ['24', '50', '63', '66', '77', '78', '91'];


    const canvas = document.getElementById('objectAnalysisCanvas');
    const ctx = canvas.getContext('2d');
    const tooltip = document.getElementById('tooltip');
    const selectedObjectInfoDiv = document.getElementById('selectedObjectInfo');
    const coordinatesTableContainer = document.getElementById('coordinatesTableContainer');
    const intersectionsTitle = document.getElementById('intersectionsTitle');
    const intersectionList = document.getElementById('intersectionList');
    const objectListUL = document.getElementById('objectList');
    const objectCountSpan = document.getElementById('objectCount');
    const coordsDialog = document.getElementById('coordsDialog');
    const dialogOverlay = document.getElementById('dialogOverlay');
    const coordsInput = document.getElementById('coordsInput');
    const gridInfoText = document.getElementById('gridStepText');
    const cursorCoordinates = document.getElementById('cursorCoordinates');
    const measurementPanel = document.getElementById('measurementPanel');
    const measurementCoordinates = document.getElementById('measurementCoordinates');
    const measurementDistance = document.getElementById('measurementDistance');
    const loaderContainer = document.getElementById('loaderContainer');
    const loaderTextElement = loaderContainer.querySelector('.loading-text');
    const drawObjectBtn = document.getElementById('drawObjectBtn');
    const finishDrawingBtn = document.getElementById('finishDrawingBtn');
    const namePromptDialog = document.getElementById('namePromptDialog');
    const namePromptOverlay = document.getElementById('namePromptOverlay');
    const namePromptTitle = document.getElementById('namePromptTitle');
    const namePromptInput = document.getElementById('namePromptInput');
    const viewInfoText = document.getElementById('viewInfoText');
    const toggleGeometryEditBtn = document.getElementById('toggleGeometryEditBtn');
    const undoGeometryChangeBtn = document.getElementById('undoGeometryChangeBtn');
    const rulerBtn = document.getElementById('rulerBtn');
    
    const nextObjectIdPlaceholder = "%%NEXT_OBJECT_ID_PLACEHOLDER%%"; // Для временных имен


    function roundCoord(value) {
        if (!isFinite(value)) return value;
        return parseFloat(value.toFixed(2));
    }


function showCustomConfirm(title, message) {
        return new Promise((resolve) => {
            const overlay = document.getElementById('customConfirmOverlay');
            const dialog = document.getElementById('customConfirmDialog');
            const titleEl = document.getElementById('customConfirmTitle');
            const msgEl = document.getElementById('customConfirmMessage');
            const yesBtn = document.getElementById('customConfirmYesBtn');
            const noBtn = document.getElementById('customConfirmNoBtn');

            titleEl.textContent = title;
            msgEl.textContent = message;

            overlay.classList.add('show');
            dialog.style.display = 'block';
            
            // Небольшая задержка для анимации появления
            requestAnimationFrame(() => {
                dialog.classList.add('show');
            });

            const close = (result) => {
                dialog.classList.remove('show');
                overlay.classList.remove('show');
                setTimeout(() => {
                    dialog.style.display = 'none';
                    // Удаляем обработчики, чтобы не дублировались при следующем вызове
                    yesBtn.onclick = null;
                    noBtn.onclick = null;
                    resolve(result);
                }, 300);
            };

            yesBtn.onclick = () => close(true);
            noBtn.onclick = () => close(false);
            
            // Закрытие по клику на фон (как "Нет")
            overlay.onclick = () => close(false);
        });
    }
    
    
function updateObjectMetrics(obj) {
    if (!obj || !obj.contours || obj.contours.length === 0) {
        obj.area = 0;
        obj.perimeter = 0;
        return;
    }

    obj.contours.forEach((contour) => {
        if (contour) {
            for (let i = 0; i < contour.length; i++) {
                if (contour[i]) {
                    contour[i].x = roundCoord(contour[i].x);
                    contour[i].y = roundCoord(contour[i].y);
                }
            }

            if (obj.type === 'polygon' && obj.subType !== 'construction_record' && contour.length >= 3) {
                const firstPt = contour[0];
                const lastPt = contour[contour.length - 1];
                const PRECISION_THRESHOLD = 0.001;
                if (!(Math.abs(firstPt.x - lastPt.x) < PRECISION_THRESHOLD && Math.abs(firstPt.y - lastPt.y) < PRECISION_THRESHOLD)) {
                    contour.push({ x: firstPt.x, y: firstPt.y });
                }
            }
        }
    });

    if (obj.type === 'polygon' && obj.subType !== 'construction_record') {
        const polygonStats = obj.contours.map(c => ({
            contour: c,
            area: calculatePolygonArea(c)
        }));

        let totalArea = 0;

        for (let i = 0; i < polygonStats.length; i++) {
            let nestingLevel = 0;
            const currentPoly = polygonStats[i];
            
            // Если площадь 0, пропускаем
            if (currentPoly.area < 1e-9) continue;

            for (let j = 0; j < polygonStats.length; j++) {
                if (i === j) continue;
                const otherPoly = polygonStats[j];
                
                // Оптимизация: контур может быть внутри только если он меньше по площади
                if (otherPoly.area > currentPoly.area) {
                    // Проверяем, находится ли первая точка текущего контура внутри другого контура
                    if (isPointInPolygon(currentPoly.contour[0], otherPoly.contour)) {
                        nestingLevel++;
                    }
                }
            }

            // Четный уровень вложенности (0, 2...) -> Добавляем площадь (Внешний контур или Остров)
            // Нечетный уровень вложенности (1, 3...) -> Вычитаем площадь (Дырка или Озеро в острове)
            if (nestingLevel % 2 === 0) {
                totalArea += currentPoly.area;
            } else {
                totalArea -= currentPoly.area;
            }
        }
        obj.area = roundCoord(Math.abs(totalArea));
    } else {
        obj.area = 0;
    }

    let totalPerimeter = 0;
    const isConsideredPolygonForCalc = obj.type === 'polygon' && obj.subType !== 'construction_record';
    obj.contours.forEach(c => {
        totalPerimeter += calculatePolygonPerimeter(c, isConsideredPolygonForCalc);
    });
    obj.perimeter = roundCoord(totalPerimeter);
}

    function deepCloneContours(contours) {
        if (!contours) return [];
        return contours.map(contour => {
            if (!contour) return null;
            return contour.map(p => (p ? { ...p } : null));
        });
    }

    function saveGeometryStateForUndo(objIndex) {
        if (objIndex < 0 || objIndex >= userObjects.length || !userObjects[objIndex]) return;
        const obj = userObjects[objIndex];
        geometryHistory.push(deepCloneContours(obj.contours));
        if (geometryHistory.length > MAX_GEOMETRY_HISTORY) {
            geometryHistory.shift();
        }
        updateUndoButtonState();
    }

    function undoLastGeometryChange() {
        if (!isGeometryEditMode || editingObjectIndex === -1 || geometryHistory.length === 0) return;
        const obj = userObjects[editingObjectIndex];
        if (!obj) return;

        const previousContours = geometryHistory.pop();
        if (previousContours) {
            obj.contours = previousContours;
            updateObjectMetrics(obj);
            displayObjectInfo(editingObjectIndex);
            redraw(true);
            saveState();
            showNotification("Действие отменено", "info", "undo");
        }
        updateUndoButtonState();
    }

  function updateUndoButtonState() {
        const undoBtn = document.getElementById('undoGeometryChangeBtn');
        const cutBtn = document.getElementById('cutObjectBtn');
        const unionBtn = document.getElementById('unionObjectBtn');
        const intBtn = document.getElementById('intersectPointsBtn');

        if (isGeometryEditMode) {
            cutBtn.style.display = 'flex';
            unionBtn.style.display = 'flex';
            intBtn.style.display = 'flex';

            if (editingObjectIndex !== -1) {
                undoBtn.style.display = 'flex';
                undoBtn.disabled = geometryHistory.length === 0;
            } else {
                undoBtn.style.display = 'none';
            }

            if (editingObjectIndex === -1) {
                if (isCutToolActive) toggleCutTool();
                if (isUnionToolActive) toggleUnionTool();
                if (isIntersectToolActive) toggleIntersectTool();
            }

        } else {
            undoBtn.style.display = 'none';
            undoBtn.disabled = true;

            cutBtn.style.display = 'none';
            cutBtn.classList.remove('active');
            isCutToolActive = false;
            cutTargetIndex = -1;

            unionBtn.style.display = 'none';
            unionBtn.classList.remove('active');
            isUnionToolActive = false;
            unionTargetIndex = -1;

            intBtn.style.display = 'none';
            intBtn.classList.remove('active');
            isIntersectToolActive = false;
            intersectTargetIndex = -1;
        }
    }
    
    function toggleCutTool() {
        if (!isGeometryEditMode) return;
        
        isCutToolActive = !isCutToolActive;
        const btn = document.getElementById('cutObjectBtn');
        
        if (isCutToolActive) {
            btn.classList.add('active');
            cutTargetIndex = -1;
            showNotification("Инструмент «Ножницы»: Двойной клик по РАССЕКАЕМОМУ объекту.", "info", "cut");
            canvas.style.cursor = 'crosshair';
        } else {
            btn.classList.remove('active');
            cutTargetIndex = -1;
            showNotification("Инструмент «Ножницы» выключен.", "info", "times");
            canvas.style.cursor = 'default';
        }
        redraw(true);
    }


    function loadState() {
        try {
            const savedStateJSON = localStorage.getItem('geoAnalyzerState');
            if (savedStateJSON) {
                const state = JSON.parse(savedStateJSON);
                // Фильтруем null/undefined объекты, которые могли сохраниться из-за ошибки
                userObjects = (state.userObjects || []).filter(o => o && o.id && o.contours);
                nextObjectId = state.nextObjectId || 1;
                nextColorIndex = state.nextColorIndex || 0;
                showPoints = state.showPoints === undefined ? true : state.showPoints;

                if (state.view && state.view.minX !== undefined && isFinite(state.view.scale)) {
                    scale = state.view.scale;
                    offsetX = state.view.offsetX;
                    offsetY = state.view.offsetY;
                    minX = state.view.minX;
                    minY = state.view.minY;
                    maxX = state.view.maxX;
                    maxY = state.view.maxY;
                    if (!hasValidView()) {
                        console.warn("Загруженное состояние вида невалидно, сброс.");
                        calculateBounds(); // Рассчитать границы на основе загруженных объектов
                        resetView();     // Затем сбросить вид
                    }
                } else {
                    calculateBounds();
                    resetView();
                }
                console.log("Состояние загружено из localStorage.");
            } else {
                userObjects = []; // Инициализация, если состояния нет
                nextObjectId = 1;
                nextColorIndex = 0;
                showPoints = true;
                calculateBounds();
                resetView();
                console.log("Сохраненное состояние не найдено, начинаем с чистого листа.");
            }
        } catch (e) {
            console.error("Ошибка загрузки состояния:", e);
            userObjects = []; // Сброс при ошибке
            nextObjectId = 1;
            nextColorIndex = 0;
            showPoints = true;
            calculateBounds();
            resetView();
            showNotification("Ошибка загрузки сохраненного состояния. Начинаем с чистого листа.", "warning", "hdd");
        }
        // Обновление метрик объектов после загрузки
        userObjects.forEach(obj => updateObjectMetrics(obj));
    }

async function initializeApp() { // Сделана асинхронной
       canvas.width = canvas.offsetWidth;
       canvas.height = canvas.offsetHeight;
        setupEventListeners();
       loadState();
        populateImportModeSelect(); 

        // 2. Проверка буфера обмена. Если успешно и пользователь согласен, userObjects будут очищены и заполнены заново.
        const clipboardImported = await checkClipboardForObjects();

        // 3. Обновление UI и состояния
        // Если из буфера не было импорта, то userObjects остаются те, что из loadState.
        // Если был импорт, userObjects уже обновлены.
        updateObjectList();


        if (userObjects.length > 0 && (!hasValidView() || clipboardImported)) {
             calculateBounds();
             resetView();
        } else if (userObjects.length === 0) {
            calculateBounds();
            resetView();
        }

        redraw(false);
        updateViewInfo();
        updateToggleButtonStates();
        updateUndoButtonState();
    }

    const cMinXGlob = () => (minX === undefined || !isFinite(minX)) ? 0 : minX;
    const cMinYGlob = () => (minY === undefined || !isFinite(minY)) ? 0 : minY;

    function calculateBounds() {
        const canvasWidth = canvas.width || 100;
        const canvasHeight = canvas.height || 100;

        if (userObjects.length === 0) {
             minX = 0; minY = 0; maxX = canvasWidth; maxY = canvasHeight;
             return;
         }

         let currentMinX = Infinity, currentMinY = Infinity, currentMaxX = -Infinity, currentMaxY = -Infinity;
         let hasValidPoints = false;
         userObjects.forEach(obj => {
             if (!obj || !obj.contours) return;
             obj.contours.forEach(contour => {
                 if (!contour) return;
                 contour.forEach(p => {
                     if (p && isFinite(p.x) && isFinite(p.y)) {
                         currentMinX = Math.min(currentMinX, p.x); currentMinY = Math.min(currentMinY, p.y);
                         currentMaxX = Math.max(currentMaxX, p.x); currentMaxY = Math.max(currentMaxY, p.y);
                         hasValidPoints = true;
                     }
                 });
             });
         });

         if (hasValidPoints && isFinite(currentMinX)) {
            minX = currentMinX; minY = currentMinY; maxX = currentMaxX; maxY = currentMaxY;
         } else {
              minX = 0; minY = 0; maxX = canvasWidth; maxY = canvasHeight;
         }
    }
    

    
    
   


    
    
// --- НОВАЯ ВСПОМОГАТЕЛЬНАЯ ФУНКЦИЯ ---
    function isCoordinateLine(line) {
        if (!line) return false;
        // Заменяем запятые на точки, разбиваем по пробелам или табуляции
        const parts = line.replace(/,/g, '.').trim().split(/[\s\t]+/);
        // Должно быть минимум 2 части (X и Y)
        if (parts.length < 2) return false;
        
        // Проверяем, являются ли первые две части числами
        const x = parseFloat(parts[0]);
        const y = parseFloat(parts[1]);
        
        return isFinite(x) && isFinite(y);
    }

    // --- ОБНОВЛЕННАЯ ФУНКЦИЯ ПАРСИНГА ---
// --- ОБНОВЛЕННАЯ ФУНКЦИЯ ПАРСИНГА С ГРУППИРОВКОЙ ПО ИМЕНИ (FIX ДЛЯ СЛОЖНЫХ ПОЛИГОНОВ) ---
    function parseTextToObjects(text, defaultColor = null) {
        if (!text || !text.trim()) return [];

        const lines = text.trim().split('\n').map(l => l.trim());
        if (lines.length === 0) return [];

        // 1. Группируем строки по заголовкам (Кадастровым номерам)
        const groupsMap = new Map();
        let currentName = null;
        let unnamedCounter = 0;

        lines.forEach(line => {
            // Пропускаем пустые строки, но используем их как разделитель логики внутри парсера координат
            if (!line) return;

            if (isCoordinateLine(line)) {
                // Если координаты встретились до первого заголовка
                if (currentName === null) {
                    unnamedCounter++;
                    currentName = `Объект без имени ${unnamedCounter}`; 
                }

                if (!groupsMap.has(currentName)) {
                    groupsMap.set(currentName, { 
                        displayName: currentName.startsWith('Объект без имени') ? null : currentName, 
                        lines: [] 
                    });
                }
                groupsMap.get(currentName).lines.push(line);
            } else {
                // Это строка-заголовок (КН или имя)
                const newName = line;
                
                // Если такое имя уже есть в Map, мы просто продолжим добавлять в него.
                // Если нет - создадим новую запись.
                if (!groupsMap.has(newName)) {
                    groupsMap.set(newName, { 
                        displayName: newName, 
                        lines: [] 
                    });
                } else {
                    // Если группа уже есть и в ней есть данные, добавляем разделитель,
                    // чтобы парсер координат понял, что начался новый контур этого же объекта
                    const group = groupsMap.get(newName);
                    if (group.lines.length > 0) {
                         group.lines.push(''); // Пустая строка как разделитель контуров
                    }
                }
                
                // Переключаем "курсор" на это имя
                currentName = newName;
            }
        });

        const resultObjects = [];

        // 2. Создаем объекты. ВСЕ контуры одного имени попадают в ОДИН объект.
        groupsMap.forEach((groupData, keyName) => {
            const coordinatesText = groupData.lines.join('\n');
            
            // Парсим все контуры для этого имени
            // Функция parseCoordinatesFromText сама разобьет их по разрывам координат
            const allContours = parseCoordinatesFromText(coordinatesText);
            
            if (allContours.length === 0) return;

            // Определяем тип объекта на основе первого контура
            // (для сложной геометрии это обычно полигон)
            const mainContour = allContours[0];
            let objectType = 'point';
            
            if (mainContour.length >= 3) {
                 // Проверка на замкнутость
                const first = mainContour[0];
                const last = mainContour[mainContour.length - 1];
                if (Math.abs(first.x - last.x) < 0.001 && Math.abs(first.y - last.y) < 0.001) {
                    objectType = 'polygon';
                } else {
                    objectType = 'line';
                }
            } else if (mainContour.length === 2) {
                objectType = 'line';
            }

            // Формируем имя
            let finalName = groupData.displayName || keyName;
            
            // ВАЖНО: Мы НЕ вызываем здесь consolidateContoursIntoObjects для разделения.
            // Мы передаем allContours как есть в один объект.
            // Это заставит систему отрисовки (ctx.fill('evenodd')) корректно нарисовать "дырки",
            // так как они будут частями одного пути (path).
            
            resultObjects.push({
                contours: allContours, // Все части (внешние и внутренние) вместе
                name: finalName,
                type: objectType,
                color: defaultColor
            });
        });

        return resultObjects;
    }



async function checkClipboardForObjects() {
    try {
        const text = await navigator.clipboard.readText();
        if (!text || text.trim().length === 0) return false;

        const trimmedText = text.trim();
        const lines = trimmedText.split('\n').map(l=>l.trim()).filter(l=>l);

        // 1. Одиночный КН без координат -> загрузка из сети
        if (lines.length === 1 && isValidCadastralNumberFormat(lines[0])) {
            showLoader(true, `Загрузка ${lines[0]}...`);
            userObjects = []; nextObjectId = 1; nextColorIndex = 0; selectedObjectIndex = -1; editingObjectIndex = -1; geometryHistory = [];
            await handleImportFromCadNumbers([lines[0]]);
            showLoader(false);
            return true;
        }

        // 2. Попытка парсинга как объектов
        const objectsToAdd = parseTextToObjects(trimmedText);

        if (objectsToAdd.length > 0) {
            showLoader(true, "Импорт из буфера обмена...");
            userObjects = []; nextObjectId = 1; nextColorIndex = 0; selectedObjectIndex = -1; editingObjectIndex = -1; geometryHistory = [];
            
            let addedBatch = [];
            objectsToAdd.forEach(objData => {
                const realName = objData.name.replace(nextObjectIdPlaceholder, nextObjectId);
                
                // ИСПРАВЛЕНО: передаем objData.contours без лишних []
                const newObj = addObjectInternal(objData.contours, realName, objData.type, true);
                
                if (newObj) addedBatch.push(newObj);
            });

            if (addedBatch.length > 0) {
                finalizeBatchAdd(addedBatch);
                showNotification(`Импортировано ${addedBatch.length} объектов из буфера.`, "success", "clipboard-check");
                showLoader(false);
                return true;
            }
        }
    } catch (err) {
        console.warn('Ошибка буфера обмена:', err);
    }
    showLoader(false);
    return false;
}
  


    
    function updateViewInfo() {
        if (!viewInfoText || !hasValidView() || !canvas || canvas.width <= 0 || scale <= 1e-9) {
            if(viewInfoText) viewInfoText.textContent = `Обзор: -`;
            return;
        }
        const visibleWidthMeters = canvas.width / scale;
        let displayText;
        if (!isFinite(visibleWidthMeters)) {
             displayText = `Высота: -`;
        } else if (visibleWidthMeters >= 1000) {
            displayText = `Высота: ${(visibleWidthMeters / 1000).toFixed(2)} км`;
        } else {
            displayText = `Высота: ${visibleWidthMeters.toFixed(1)} м`;
        }
        viewInfoText.textContent = displayText;
    }
    function resetView() {
        calculateBounds();
        const canvasWidth = canvas.width || 100;
        const canvasHeight = canvas.height || 100;

        if (minX === undefined || !isFinite(minX) || maxX === undefined || !isFinite(maxX) ||
            minY === undefined || !isFinite(minY) || maxY === undefined || !isFinite(maxY))
        {
             scale = 1; offsetX = 0; offsetY = 0;
             minX = 0; minY = 0; maxX = canvasWidth; maxY = canvasHeight;
        } else {
            const dataWidth = Math.max(1e-6, maxX - minX);
            const dataHeight = Math.max(1e-6, maxY - minY);
            const scaleX = canvasWidth / dataWidth * 0.9;
            const scaleY = canvasHeight / dataHeight * 0.9;
            scale = Math.max(1e-9, Math.min(Math.min(scaleX, scaleY), 10000));
            if (!isFinite(scale) || scale <= 0) scale = 1;

            const centerX = minX + dataWidth / 2;
            const centerY = minY + dataHeight / 2;
            offsetX = canvasWidth / 2 - (centerY - cMinYGlob()) * scale;
            offsetY = canvasHeight / 2 - (centerX - cMinXGlob()) * scale;
        }

        if (!isFinite(scale) || scale <= 0) scale = 1;
        if (!isFinite(offsetX)) offsetX = 0;
        if (!isFinite(offsetY)) offsetY = 0;

        if (!hasValidView()) {
             scale = 1; offsetX = 0; offsetY = 0;
             minX = 0; minY = 0; maxX = canvasWidth; maxY = canvasHeight;
        }
         updateViewInfo();
    }
    function hasValidView() {
        return isFinite(scale) && scale > 1e-9 &&
               isFinite(offsetX) && isFinite(offsetY) &&
               minX !== undefined && minY !== undefined && maxX !== undefined && maxY !== undefined &&
               isFinite(minX) && isFinite(minY) && isFinite(maxX) && isFinite(maxY);
    }

function updateToggleButtonStates() {
        const pointsBtn = document.getElementById('togglePointsBtn');
        if (pointsBtn) {
            pointsBtn.style.backgroundColor = showPoints ? '#e74c3c' : '#7f8c8d';
        }
        
        const adjBtn = document.getElementById('showAdjacentPointsBtn');
        if (adjBtn) {
            if (adjacentPointsMode) {
                adjBtn.style.color = '#e74c3c'; // Активный цвет
                // ИСПРАВЛЕНИЕ: Добавляем translateY(-50%), чтобы кнопка оставалась по центру
                adjBtn.style.transform = 'translateY(-50%) scale(1.2)';
            } else {
                adjBtn.style.color = ''; 
                // ИСПРАВЛЕНИЕ: Сбрасываем только scale, но оставляем позиционирование CSS
                adjBtn.style.transform = ''; 
            }
        }

        const rulerBtn = document.getElementById('rulerBtn');
        if (rulerBtn) {
            rulerBtn.classList.toggle('active', rulerMode);
        }

        const drawBtn = document.getElementById('drawObjectBtn');
        if (drawBtn) {
            drawBtn.classList.toggle('active', isDrawingMode);
        }

        const finishDrawBtn = document.getElementById('finishDrawingBtn');
        if (finishDrawBtn) {
            finishDrawBtn.style.display = isDrawingActive ? 'flex' : 'none';
        }

        const geomEditBtn = document.getElementById('toggleGeometryEditBtn');
        if (geomEditBtn) {
            geomEditBtn.classList.toggle('active', isGeometryEditMode);
        }

        updateUndoButtonState();

        canvas.classList.toggle('drawing-mode', isDrawingMode && isDrawingActive);
        canvas.classList.toggle('editing-point-mode', isMovingPoint);

        const labelsDlgBtn = document.getElementById('toggleLabelsDialogBtn');
        if (labelsDlgBtn) {
            if (showLabels) {
                labelsDlgBtn.classList.add('active');
                labelsDlgBtn.innerHTML = '<i class="fas fa-check-square"></i> Подписи вкл.';
            } else {
                labelsDlgBtn.classList.remove('active');
                labelsDlgBtn.innerHTML = '<i class="fas fa-tag"></i> Подписи коорд.';
            }
        }
    }

function setupEventListeners() {
        canvas.addEventListener('mousedown', handleMouseDown);
        canvas.addEventListener('mousemove', handleMouseMove);
        canvas.addEventListener('mouseup', handleMouseUp);
        canvas.addEventListener('wheel', handleWheel, { passive: false });
        canvas.addEventListener('click', handleClick);
        canvas.addEventListener('dblclick', handleDoubleClick);
        canvas.addEventListener('mouseout', handleMouseOut);
        canvas.addEventListener('contextmenu', handleContextMenu);
        
        const toggleLabelsDialogBtn = document.getElementById('toggleLabelsDialogBtn');
        if (toggleLabelsDialogBtn) {
            toggleLabelsDialogBtn.addEventListener('click', toggleLabelsVisibility);
        }
        
            document.getElementById('saveProjectBtn').addEventListener('click', saveProjectToJson);
        document.getElementById('openProjectBtn').addEventListener('click', () => {
            document.getElementById('projectFileInput').click();
        });
        document.getElementById('projectFileInput').addEventListener('change', loadProjectFromJson);
        
        
        document.getElementById('findCoordsBtn').addEventListener('click', handleFindCoordinates);

        document.getElementById('addObjectBtn').addEventListener('click', openCoordsDialog);
        document.getElementById('togglePointsBtn').addEventListener('click', togglePointsVisibility);
           document.getElementById('hideAllObjectsBtn').addEventListener('click', hideAllObjects);
        document.getElementById('rulerBtn').addEventListener('click', () => toggleMode('ruler'));
        document.getElementById('resetMeasurementBtn').addEventListener('click', resetMeasurement);
        drawObjectBtn.addEventListener('click', () => toggleMode('draw'));
        document.getElementById('cutObjectBtn').addEventListener('click', toggleCutTool);
  document.getElementById('unionObjectBtn').addEventListener('click', toggleUnionTool);
        document.getElementById('intersectPointsBtn').addEventListener('click', toggleIntersectTool);

        finishDrawingBtn.addEventListener('click', finishDrawingAsLineOrPoint);
        toggleGeometryEditBtn.addEventListener('click', () => toggleMode('geometryEdit'));
        undoGeometryChangeBtn.addEventListener('click', undoLastGeometryChange);

        document.getElementById('importCoordsBtn').addEventListener('click', handleUniversalImport);
        document.getElementById('importFromFileBtn').addEventListener('click', handleImportFromFile);
        document.getElementById('closeDialogBtn').addEventListener('click', closeCoordsDialog);
        dialogOverlay.addEventListener('click', closeCoordsDialog);
        coordsDialog.addEventListener('click', (e) => e.stopPropagation());

        window.addEventListener('resize', () => {
             canvas.width = canvas.offsetWidth;
             canvas.height = canvas.offsetHeight;
             calculateBounds();
             redraw(true);
        });

        // --- ИЗМЕНЕНИЕ: Расширенный обработчик клавиатуры (Стрелки + Escape) ---
        document.addEventListener('keydown', (e) => {
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') {
                return;
            }

            const panStep = 50;
            const zoomStep = 1.2; 
            let handled = false;

            if (e.key === 'ArrowLeft') {
                offsetX += panStep;
                handled = true;
            } else if (e.key === 'ArrowRight') {
                offsetX -= panStep;
                handled = true;
            } else if (e.key === 'ArrowUp') {
                offsetY -= panStep;
                handled = true;
            } else if (e.key === 'ArrowDown') {
                offsetY += panStep;
                handled = true;
            } 
            else if (e.key === '+' || e.key === '=') {
                const cX = canvas.width / 2;
                const cY = canvas.height / 2;
                const dataPoint = inverseTransformCoord(cX, cY);

                if (isFinite(dataPoint.x) && isFinite(dataPoint.y)) {
                    let newScale = scale * zoomStep;
                    newScale = Math.max(1e-9, Math.min(newScale, 10000));
                    scale = newScale;

                    offsetX = cX - (dataPoint.y - cMinYGlob()) * scale;
                    offsetY = canvas.height - cY - (dataPoint.x - cMinXGlob()) * scale;
                    
                    updateViewInfo();
                    handled = true;
                }
            } 
            else if (e.key === '-' || e.key === '_') {
                const cX = canvas.width / 2;
                const cY = canvas.height / 2;
                const dataPoint = inverseTransformCoord(cX, cY);

                if (isFinite(dataPoint.x) && isFinite(dataPoint.y)) {
                    let newScale = scale / zoomStep;
                    newScale = Math.max(1e-9, Math.min(newScale, 10000));
                    scale = newScale;

                    offsetX = cX - (dataPoint.y - cMinYGlob()) * scale;
                    offsetY = canvas.height - cY - (dataPoint.x - cMinXGlob()) * scale;
                    
                    updateViewInfo();
                    handled = true;
                }
            }

            if (handled) {
                e.preventDefault();
                redraw(true);
                return;
            }

            if (e.key === 'Escape') {
                if (loaderContainer.style.display === 'flex') {
                    isNspdLoadCancelled = true;
                    showLoader(false);
                    showNotification("Загрузка отменена пользователем.", "warning", "hand-paper");
                    return;
                }
                if (isGeometryEditMode) {
                    deactivateGeometryEditMode();
                }
                if (isDrawingMode) {
                    cancelDrawing();
                }
                if (rulerMode) {
                    toggleMode('ruler');
                }
            }
        });

        document.getElementById('cancelLoadBtn').addEventListener('click', () => {
            isNspdLoadCancelled = true;
            showNotification("Отмена загрузки...", "warning");
            document.getElementById('cancelLoadBtn').style.display = 'none';
            loaderTextElement.textContent = "Остановка...";
        });
        
        document.getElementById('deleteAllObjectsBtn').addEventListener('click', deleteAllObjects);
        
            document.getElementById('showAdjacentPointsBtn').addEventListener('click', toggleAdjacentPointsMode);
            
          document.getElementById('showAllObjectsBtn').addEventListener('click', () => {
            if (userObjects.length > 0) {
                resetView();   // Пересчитывает границы и масштаб
                redraw(true);  // Перерисовывает холст
            } else {
                showNotification("Нет объектов для отображения.", "info");
            }
        });
        document.getElementById('importModeSelect').addEventListener('change', (e) => {
            localStorage.setItem('selectedImportMode', e.target.value);
        });
    }

    function activateGeometryEditMode() {
        if (selectedObjectIndex === -1) {
            showNotification("Сначала выберите объект для редактирования.", "warning", "hand-pointer");
            return false;
        }
        isGeometryEditMode = true;
        editingObjectIndex = selectedObjectIndex;
        geometryHistory = [];
        saveGeometryStateForUndo(editingObjectIndex);

        if (rulerMode) { rulerMode = false; measurementPanel.classList.remove('active'); rulerPoints = []; }
        if (isDrawingMode) { isDrawingMode = false; isDrawingActive = false; currentDrawingPoints = []; }

        showNotification(`Режим редактирования для "${userObjects[editingObjectIndex].name || 'Объект ' + userObjects[editingObjectIndex].id}". Клик на сегмент - добавить. ПКМ на точку - удалить.`, "info", "edit");
        redraw(true);
        return true;
    }

    function deactivateGeometryEditMode(showNotif = true) {
        if (!isGeometryEditMode) return;
        isGeometryEditMode = false;
        editingObjectIndex = -1;
        isMovingPoint = false;
        movedPointInfo = null;
        snappedToPointVisual = null;
        geometryHistory = [];

        if (showNotif) showNotification("Режим редактирования геометрии выключен.", "info", "edit");
        if (!rulerMode && !isDrawingMode) canvas.style.cursor = 'grab';
        redraw(true);
    }


   function toggleMode(modeToToggle) {
        if (modeToToggle !== 'ruler' && rulerMode) {
            rulerMode = false; measurementPanel.classList.remove('active'); rulerPoints = [];
        }
        if (modeToToggle !== 'draw' && isDrawingMode) {
            isDrawingMode = false; isDrawingActive = false; currentDrawingPoints = [];
        }
        if (modeToToggle !== 'geometryEdit' && isGeometryEditMode) {
            deactivateGeometryEditMode(false);
        }

        if (modeToToggle === 'ruler') {
            rulerMode = !rulerMode;
            if (rulerMode) {
                resetMeasurement(); measurementPanel.classList.add('active');
                showNotification('Режим измерения включен.', 'info', 'ruler');
                canvas.style.cursor = 'crosshair';
            } else {
                // --- ИЗМЕНЕНИЕ: Скрываем панель и сбрасываем точки при выключении ---
                measurementPanel.classList.remove('active');
                rulerPoints = [];
                // -------------------------------------------------------------------
                showNotification('Режим измерения выключен.', 'info', 'ruler');
            }
        } else if (modeToToggle === 'draw') {
            isDrawingMode = !isDrawingMode;
            if (isDrawingMode) activateDrawingMode();
            else cancelDrawing();
        } else if (modeToToggle === 'geometryEdit') {
            if (isGeometryEditMode) {
                deactivateGeometryEditMode();
            } else {
                activateGeometryEditMode();
            }
        }

        if (!rulerMode && !isDrawingMode && !isGeometryEditMode && !isMovingPoint) {
            canvas.style.cursor = 'grab';
        }
        updateToggleButtonStates();
        redraw(true);
    }


     function saveState() {
        try {
            const maxObjectsToSave = 50;
            const validObjects = userObjects.filter(o => o);
            const objectsToSave = validObjects.slice(-maxObjectsToSave);
            const state = {
                userObjects: objectsToSave, nextObjectId, nextColorIndex,
                view: hasValidView() ? { scale, offsetX, offsetY, minX, minY, maxX, maxY } : null,
                showPoints
            };
            localStorage.setItem('geoAnalyzerState', JSON.stringify(state));
        } catch (e) {
             if (e.name === 'QuotaExceededError') {
                  localStorage.removeItem('geoAnalyzerState');
                   showNotification("Хранилище переполнено. Старые данные удалены.", "warning", "hdd");
             } else { console.error("Ошибка сохранения состояния:", e); showNotification("Ошибка сохранения состояния.", "error", "save"); }
        }
    }

function addObjectInternal(contoursData, name, objectType, isMultiPart = false, subType = null, specificColor = null) {
    if (!contoursData || contoursData.length === 0 || contoursData.every(c => !c || c.length === 0)) {
        if (!isMultiPart) showNotification("Не удалось добавить объект: нет контуров или они пусты.", "error", "exclamation-circle");
        return null;
    }

    const processedContours = contoursData.map(contour => {
        if (!contour || contour.length === 0) return null;
        const roundedContour = contour.map(p => ({ x: roundCoord(p.x), y: roundCoord(p.y) }));
        const validPoints = roundedContour.filter(p => p && isFinite(p.x) && isFinite(p.y));
        if (validPoints.length === 0) return null;
        return validPoints;
    }).filter(c => c !== null && c.length > 0);

    if (processedContours.length === 0) {
        if (!isMultiPart) showNotification("Не удалось добавить объект: нет валидных координат в контурах.", "error", "exclamation-circle");
        return null;
    }

    let finalObjectType = objectType;
    const firstValidContour = processedContours[0];
    if (firstValidContour.length < 3 && objectType === 'polygon') {
        finalObjectType = firstValidContour.length === 2 ? 'line' : 'point';
    } else if (firstValidContour.length < 2 && objectType === 'line') {
        finalObjectType = 'point';
    }
    if ((finalObjectType === 'line' || finalObjectType === 'polygon') && firstValidContour.length === 1) {
        finalObjectType = 'point';
    }

    const newId = nextObjectId++;
    
    // --- ИЗМЕНЕНИЕ: Логика выбора цвета ---
    let newColor;
    if (specificColor) {
        newColor = specificColor;
        // Не увеличиваем nextColorIndex, чтобы авто-цвета не "сбивались" впустую, 
        // или наоборот - можно не трогать, это не критично.
    } else {
        newColor = objectColors[nextColorIndex % objectColors.length]; 
        nextColorIndex++;
    }
    // -------------------------------------

    const newObject = {
        id: newId,
        name,
        type: finalObjectType,
        subType: subType,
        contours: processedContours,
        color: newColor,
        area: 0,
        perimeter: 0,
         visible: true 
    };
    
    updateObjectMetrics(newObject);

    userObjects.push(newObject);
    const newIndex = userObjects.length - 1;

    if (!isMultiPart) {
        updateObjectList();
        selectedObjectIndex = newIndex;
        calculateBounds();
        displayObjectInfo(selectedObjectIndex);
        setTimeout(() => { centerOnObject(newIndex, true); }, 50);
          checkTotalPointsAndHide(); 
        saveState();
        redraw(true);
    }
    return newObject;
}

async function deleteObject(index) {
        if (index < 0 || index >= userObjects.length || !userObjects[index]) return;
        const obj = userObjects[index];
        const objectName = obj.name || `Объект ${obj.id}`;
        
        // ЗАМЕНА confirm НА showCustomConfirm
        const confirmed = await showCustomConfirm(
            "Удаление объекта", 
            `Вы уверены, что хотите удалить "${objectName}"?`
        );

        if (confirmed) {
             if(isGeometryEditMode && editingObjectIndex === index) {
                deactivateGeometryEditMode(false);
            }
            userObjects.splice(index, 1);
            const wasSelected = (selectedObjectIndex === index);

            if (wasSelected) { selectedObjectIndex = -1; displayObjectInfo(-1); }
            else if (selectedObjectIndex > index) { selectedObjectIndex--; }

            if(editingObjectIndex > index) editingObjectIndex--;
            else if (editingObjectIndex === index) editingObjectIndex = -1;


            showNotification(`"${objectName}" удален`, "info", "trash-alt");
            updateObjectList();
            calculateBounds();
            if (!hasValidView()) {
                resetView();
                redraw(false);
            } else {
                 redraw(true);
            }
            saveState();
        }
    }
    
    
    async function renameObject(index, newName) {
         if (index < 0 || index >= userObjects.length || !userObjects[index] || !newName || !newName.trim()) {
              showNotification("Имя объекта не может быть пустым.", "warning", "exclamation-triangle"); return;
         }
         const finalName = newName.trim(); userObjects[index].name = finalName;
         displayObjectInfo(index); updateObjectList(); redraw(true);
         showNotification(`Объект переименован в "${finalName}"`, "success", "pencil-alt"); saveState();
    }

    function openCoordsDialog() {
        if (isDrawingMode || isMovingPoint || isGeometryEditMode) {
            showNotification("Завершите текущее действие перед импортом.", "warning", "pause-circle"); return;
        }
        coordsInput.value = ''; coordsDialog.style.display = 'block'; dialogOverlay.style.display = 'block';
        requestAnimationFrame(() => { dialogOverlay.classList.add('show'); coordsDialog.classList.add('show'); coordsInput.focus(); });
    }
    function closeCoordsDialog() {
        dialogOverlay.classList.remove('show'); coordsDialog.classList.remove('show');
        setTimeout(() => { coordsDialog.style.display = 'none'; dialogOverlay.style.display = 'none'; }, 300);
    }
    async function promptAndAddObjectInternal(contoursData, objectType, defaultName) {
        const name = await showNamePrompt(`Имя нового объекта (${defaultName}):`, defaultName || `Объект ${nextObjectId}`);
        if (name !== null) {
            // Ensure contoursData is an array of contours
            const contoursArray = Array.isArray(contoursData[0]) ? contoursData : [contoursData];
            return addObjectInternal(contoursArray, name, objectType, true);
        } else {
            showNotification(`Добавление "${defaultName || 'объекта'}" отменено.`, 'warning', 'times-circle');
            return null;
        }
    }
    
        // --- НОВАЯ ФУНКЦИЯ для заполнения нового селектора в модальном окне ---
function populateImportModeSelect() {
        const select = document.getElementById('importModeSelect');
        if (!select) return;

        // (Эта часть остается без изменений - она заполняет список)
        select.innerHTML = '<option value="xml">Из архива КПТ (XML файл)</option>';
        if (typeof COORDINATE_SYSTEMS !== 'undefined') {
            const mskSystems = COORDINATE_SYSTEMS.filter(sys => sys.value.startsWith('EPSG:') && sys.value !== 'EPSG:4326' && sys.value !== 'EPSG:3857');
            mskSystems.forEach(sys => {
                const option = document.createElement('option');
                option.value = sys.value;
                option.textContent = `EPSG3857 -> ${sys.text}`;
                select.appendChild(option);
            });
        }
        
        // --- ДОБАВЬТЕ ЭТОТ КОД ---
        // Загружаем и устанавливаем сохраненное значение
        const savedMode = localStorage.getItem('selectedImportMode');
        if (savedMode) {
            // Проверяем, существует ли такая опция в списке, на случай если список изменился
            if (select.querySelector(`option[value="${savedMode}"]`)) {
                select.value = savedMode;
            }
        }
    }

async function handleImportFromNspdAndConvertToMsk(cadNumbers, destScId) {
    closeCoordsDialog();
    if (cadNumbers.length > 100) {
        showNotification("Превышен лимит в 100 кадастровых номеров.", "error");
        return;
    }

    const destSystem = COORDINATE_SYSTEMS.find(s => s.value === destScId);
    if (!destSystem || !destSystem.def) {
        showNotification(`Не найдено определение для целевой СК: ${destScId}`, "error");
        return;
    }

    proj4.defs(destSystem.value, destSystem.def);
    if (typeof proj4.defs['EPSG:3857'] === 'undefined') {
         proj4.defs("EPSG:3857", COORDINATE_SYSTEMS.find(s => s.value === "EPSG:3857").def);
    }
    if (typeof proj4.defs['EPSG:4326'] === 'undefined') {
         proj4.defs("EPSG:4326", COORDINATE_SYSTEMS.find(s => s.value === "EPSG:4326").def);
    }

    let addedObjects = [];
    let errors = 0;
    
    isNspdLoadCancelled = false; 
    
    showLoader(true, `Подготовка к загрузке ${cadNumbers.length} участков...`);

    for (let i = 0; i < cadNumbers.length; i++) {
        if (isNspdLoadCancelled) {
            console.log("Загрузка прервана пользователем.");
            break; 
        }

        const kn = cadNumbers[i];
        showLoader(true, `Загрузка ${i + 1}/${cadNumbers.length}: ${kn}`);

        try {
            const feature = await fetchCadastralData(kn);
            if (!feature.geometry || !feature.geometry.coordinates) {
                throw new Error('У объекта нет координат в ЕГРН.');
            }

            // --- НАЧАЛО КЛЮЧЕВОГО ИЗМЕНЕНИЯ ---
            // Определяем subType на основе категории из ответа НСПД
            const categoryId = feature.properties.category;
            let subType = null;
            if (categoryId === 36368) { // ID для Земельных участков
                subType = 'land_record';
            } else if (categoryId === 36369) { // ID для Зданий
                subType = 'build_record';
            } else if (categoryId === 36383) { // ID для Сооружений
                subType = 'construction_record';
            }
            console.log(`[handleImportFromNspd] Для КН ${kn} определен subType: ${subType} (ID категории: ${categoryId})`);
            // --- КОНЕЦ КЛЮЧЕВОГО ИЗМЕНЕНИЯ ---
            
            const geometryType = feature.geometry.type;
            const polygonsData = geometryType === 'MultiPolygon' ? feature.geometry.coordinates : [feature.geometry.coordinates];
            
            const objectMskContours = [];
            polygonsData.forEach(polygonRings => {
                polygonRings.forEach(ring => {
                    const mskPoints = ring.map(coord_3857 => {
                        const wgs84 = proj4('EPSG:3857', 'EPSG:4326', coord_3857);
                        const msk = proj4('EPSG:4326', destSystem.value, wgs84);
                        
                        const finalX = msk[1] + (destSystem.offsetX || 0);
                        const finalY = msk[0] + (destSystem.offsetY || 0);

                        return { x: roundCoord(finalX), y: roundCoord(finalY) };
                    });
                    objectMskContours.push(mskPoints);
                });
            });

            if (objectMskContours.length > 0) {
                // --- НАЧАЛО КЛЮЧЕВОГО ИЗМЕНЕНИЯ ---
                // Передаем определенный subType в функцию создания объекта
                const newObj = addObjectInternal(objectMskContours, kn, "polygon", true, subType);
                // --- КОНЕЦ КЛЮЧЕВОГО ИЗМЕНЕНИЯ ---
                if (newObj) {
                    addedObjects.push(newObj);
                }
            } else {
                throw new Error('Не удалось извлечь контуры.');
            }

        } catch (error) {
            console.error(`Ошибка для КН ${kn}:`, error);
            showNotification(`Ошибка для ${kn}: ${error.message}`, "error");
            errors++;
        }

        if (i < cadNumbers.length - 1) {
            await new Promise(resolve => setTimeout(resolve, 500));
        }
    }

    showLoader(false);
    if (addedObjects.length > 0) {
        finalizeBatchAdd(addedObjects);
        showNotification(`Загружено ${addedObjects.length} участков. ${errors > 0 ? errors + ' с ошибками.' : ''}`, "success", "check-circle");
    } else if (errors > 0 && !isNspdLoadCancelled) {
        showNotification(`Не удалось загрузить участки. Ошибок: ${errors}.`, "error", "exclamation-triangle");
    }
}
    
    function isQuarterFormat(text) {
        if (!text) return false;
        // Проверяет формат XX:XX:XXXXXX или XX:XX:XXXXXXX
        const quarterRegex = /^\d{2}:\d{2}:(\d{6}|\d{7})$/;
        return quarterRegex.test(text.trim());
    }

    function showQuarterLoadOptionsDialog(quarterNumber) {
        const dialog = document.getElementById('quarterLoadOptionsDialog');
        const overlay = document.getElementById('dialogOverlay');
        const title = document.getElementById('quarterLoadOptionsTitle');
        const adjacentBtn = dialog.querySelector('button[data-load-type="adjacent"]');

        title.textContent = `Загрузка квартала ${quarterNumber}`;

        // Делаем кнопку "Смежные объекты" неактивной, если на карте пусто
        if (userObjects.length === 0) {
            adjacentBtn.disabled = true;
            adjacentBtn.style.opacity = '0.5';
            adjacentBtn.title = 'Эта опция доступна, когда на карте уже есть объекты';
        } else {
            adjacentBtn.disabled = false;
            adjacentBtn.style.opacity = '1';
            adjacentBtn.title = '';
        }
        
        // Удаляем старые обработчики, чтобы избежать многократных вызовов
        const newButtons = document.getElementById('quarterLoadOptionsButtons').cloneNode(true);
        document.getElementById('quarterLoadOptionsButtons').parentNode.replaceChild(newButtons, document.getElementById('quarterLoadOptionsButtons'));

        newButtons.querySelectorAll('button').forEach(button => {
            button.onclick = () => processQuarterLoad(quarterNumber, button.dataset.loadType);
        });

        document.getElementById('quarterLoadOptionsCancelBtn').onclick = closeQuarterLoadOptionsDialog;
        overlay.onclick = closeQuarterLoadOptionsDialog;
        dialog.style.display = 'block';
        overlay.classList.add('show');
    }

    function closeQuarterLoadOptionsDialog() {
        document.getElementById('quarterLoadOptionsDialog').style.display = 'none';
        document.getElementById('dialogOverlay').classList.remove('show');
    }
    
    
    // --- ЛОГИКА СМЕЖНЫХ ТОЧЕК ---

function getObjectBoundingBox(obj) {
    let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
    if (!obj.contours) return null;
    obj.contours.forEach(c => {
        if (!c) return;
        c.forEach(p => {
            if (p && isFinite(p.x) && isFinite(p.y)) {
                minX = Math.min(minX, p.x); minY = Math.min(minY, p.y);
                maxX = Math.max(maxX, p.x); maxY = Math.max(maxY, p.y);
            }
        });
    });
    if (minX === Infinity) return null;
    return { minX, minY, maxX, maxY };
}

function calculateAdjacentIndices(targetIndex) {
    const indices = new Set();
    if (targetIndex < 0 || targetIndex >= userObjects.length) return indices;

    indices.add(targetIndex); // Добавляем сам выбранный объект
    const targetObj = userObjects[targetIndex];
    const targetBBox = getObjectBoundingBox(targetObj);
    if (!targetBBox) return indices;

    // Расширяем BBox на 1.5 метра для грубой фильтрации
    const buffer = 1.5;
    const expandedTargetBBox = {
        minX: targetBBox.minX - buffer, minY: targetBBox.minY - buffer,
        maxX: targetBBox.maxX + buffer, maxY: targetBBox.maxY + buffer
    };

    const thresholdSq = 1.0 * 1.0; // 1 метр в квадрате

    // Получаем сегменты целевого объекта ОДИН РАЗ
    const segsTarget = getAllSegments(targetObj);

    userObjects.forEach((otherObj, idx) => {
        if (idx === targetIndex) return;
        if (!otherObj.contours) return;

        // 1. Грубая проверка по BBox (отсеиваем далекие объекты)
        const otherBBox = getObjectBoundingBox(otherObj);
        if (!otherBBox) return;

        if (otherBBox.maxX < expandedTargetBBox.minX || otherBBox.minX > expandedTargetBBox.maxX ||
            otherBBox.maxY < expandedTargetBBox.minY || otherBBox.minY > expandedTargetBBox.maxY) {
            return;
        }

        let isAdjacent = false;
        const segsOther = getAllSegments(otherObj);

        // --- НОВАЯ ПРОВЕРКА: ПЕРЕСЕЧЕНИЕ ЛИНИЙ (SEGMENT to SEGMENT) ---
        // Это решает проблему на скриншоте, когда полигоны накладываются, но вершины далеко
        for (const s1 of segsTarget) {
            for (const s2 of segsOther) {
                // Используем уже существующую функцию getSegmentIntersection
                if (getSegmentIntersection(s1.p1, s1.p2, s2.p1, s2.p2)) {
                    isAdjacent = true;
                    break;
                }
            }
            if (isAdjacent) break;
        }
        // --------------------------------------------------------------

        // Если прямого пересечения линий нет, проверяем близость (1 метр)
        if (!isAdjacent) {
            // Проверка: Точки Other рядом с сегментами Target
            for (const contour of otherObj.contours) {
                if (!contour) continue;
                for (const pt of contour) {
                    for (const seg of segsTarget) {
                        const distSq = pointLineDistSq(pt.x, pt.y, seg.p1.x, seg.p1.y, seg.p2.x, seg.p2.y);
                        if (distSq <= thresholdSq) {
                            isAdjacent = true; break;
                        }
                    }
                    if (isAdjacent) break;
                }
                if (isAdjacent) break;
            }
        }

        // Обратная проверка: Точки Target рядом с сегментами Other
        if (!isAdjacent) {
            for (const contour of targetObj.contours) {
                if (!contour) continue;
                for (const pt of contour) {
                    for (const seg of segsOther) {
                        const distSq = pointLineDistSq(pt.x, pt.y, seg.p1.x, seg.p1.y, seg.p2.x, seg.p2.y);
                        if (distSq <= thresholdSq) {
                            isAdjacent = true; break;
                        }
                    }
                    if (isAdjacent) break;
                }
                if (isAdjacent) break;
            }
        }

        if (isAdjacent) {
            indices.add(idx);
        }
    });

    return indices;
}

function toggleAdjacentPointsMode() {
    if (adjacentPointsMode) {
        // Выключение режима
        adjacentPointsMode = false;
        adjacentObjectIndices.clear();
        showNotification("Режим смежных точек выключен.", "info");
    } else {
        // Включение режима
        if (selectedObjectIndex === -1) {
            showNotification("Выберите объект для отображения смежных точек.", "warning", "hand-pointer");
            return;
        }

        const countBefore = adjacentObjectIndices.size;
        showLoader(true, "Поиск смежных объектов (1м)...");
        
        // Используем setTimeout, чтобы лоадер успел отрисоваться
        setTimeout(() => {
            adjacentObjectIndices = calculateAdjacentIndices(selectedObjectIndex);
            adjacentPointsMode = true;
            
            // Выключаем глобальные точки
            showPoints = false;
            
            showLoader(false);
            showNotification(`Показаны точки для ${adjacentObjectIndices.size} объектов (выбранный + смежные).`, "success", "dot-circle");
            
            // Обновляем кнопки и перерисовываем
            updateToggleButtonStates();
            redraw(true);
        }, 50);
        return; // redraw внутри timeout
    }
    
    updateToggleButtonStates();
    redraw(true);
}
    

async function handleUniversalImport() {
    const inputText = coordsInput.value.trim();
    if (!inputText) {
        showNotification("Поле ввода пустое.", "warning", "exclamation-triangle");
        return;
    }

    const useFixedColor = document.getElementById('useFixedColor').checked;
    const fixedColor = useFixedColor ? document.getElementById('importColorInput').value : null;

    const lines = inputText.split('\n').map(line => line.trim()).filter(line => line);
    
    // 1. Проверка на чистый список КН (без координат) для загрузки из интернета
    // Если первая строка КН, а вторая КН - это список.
    // Если первая КН, а вторая координаты - это наш случай с ручным вводом.
    const firstIsKn = isValidCadastralNumberFormat(lines[0]);
    const secondIsKn = lines.length > 1 && isValidCadastralNumberFormat(lines[1]);
    const isKnList = firstIsKn && (lines.length === 1 || secondIsKn);
    
    const isSingleQuarter = lines.length === 1 && isQuarterFormat(lines[0]);

    if (isSingleQuarter) {
        closeCoordsDialog();
        showQuarterLoadOptionsDialog(lines[0]);
        return; 
    }

  if (isKnList) {
        const importMode = document.getElementById('importModeSelect').value;
        if (importMode === 'xml') {
            await handleImportFromCadNumbers(lines);
        } else {
            // ЗАМЕНА confirm НА showCustomConfirm
            if (lines.length > 20) {
                const confirmed = await showCustomConfirm(
                    "Большой список",
                    `В списке ${lines.length} объектов. Это может занять время. Продолжить?`
                );
                if (!confirmed) return;
            }
            
            await handleImportFromNspdAndConvertToMsk(lines, importMode);
        }
        return;
    }

    // 2. Обработка текста (Координаты или Имя+Координаты)
    const objectsToAdd = parseTextToObjects(inputText, fixedColor);
    
 if (objectsToAdd.length > 0) {
        closeCoordsDialog();
        let addedBatch = [];
        
        objectsToAdd.forEach(objData => {
            const realName = objData.name.replace(nextObjectIdPlaceholder, nextObjectId);
            
            // ИСПРАВЛЕНО: objData.contours уже является массивом контуров (внешний + дырки),
            // поэтому квадратные скобки [] вокруг него НЕ НУЖНЫ.
            const newObj = addObjectInternal(
                objData.contours,  // <-- Передаем как есть
                realName, 
                objData.type, 
                true, 
                null, 
                objData.color
            );
            if (newObj) addedBatch.push(newObj);
        });

        if (addedBatch.length > 0) {
            finalizeBatchAdd(addedBatch);
            showNotification(`Добавлено ${addedBatch.length} объектов.`, "success");
        }
    } else {
        showNotification("Не удалось распознать данные.", "error");
    }
}


async function processQuarterLoad(quarterNumber, filterType) {
    closeQuarterLoadOptionsDialog();

    // Определяем источник данных из основного диалогового окна
    const importMode = document.getElementById('importModeSelect').value;

    if (importMode === 'xml') {
        // --- Существующая логика для загрузки из XML-архива КПТ ---
        showLoader(true, `Загрузка данных КПТ для квартала ${quarterNumber}...`);
        try {
            const xmlContent = await fetchKptXmlContent(quarterNumber);
            if (!xmlContent) {
                showLoader(false);
                return;
            }

            showLoader(true, `Обработка XML, фильтр: ${filterType}...`);
            await new Promise(resolve => setTimeout(resolve, 50));
            
            const objectsToAdd = extractObjectsFromXml(xmlContent, filterType);
            
            if (objectsToAdd.length === 0) {
                showNotification(`В файле КПТ для квартала ${quarterNumber} не найдено объектов, соответствующих фильтру.`, "info");
                showLoader(false);
                return;
            }

            let addedObjectsBatch = [];
            objectsToAdd.forEach(objData => {
                const isPolygon = objData.contours.some(c => c.length >= 3);
                const objectType = isPolygon ? 'polygon' : (objData.contours.some(c => c.length >= 2) ? 'line' : 'point');
                const newObj = addObjectInternal(objData.contours, objData.name, objectType, true);
                if (newObj) {
                    addedObjectsBatch.push(newObj);
                }
            });

            if (addedObjectsBatch.length > 0) {
                finalizeBatchAdd(addedObjectsBatch);
                showNotification(`Загружено ${addedObjectsBatch.length} объектов из файла КПТ ${quarterNumber}.`, "success");
            }
        } catch (error) {
            console.error("Ошибка при загрузке квартала из КПТ XML:", error);
            showNotification(`Ошибка загрузки из КПТ: ${error.message}`, "error");
        } finally {
            showLoader(false);
        }
    } else {

        if (filterType === 'adjacent') {
            showNotification(`Загрузка смежных объектов не поддерживается.`, "warning");
            return;
        }
        // 'importMode' в этом случае является ID целевой системы координат, например 'EPSG:6331602'
        await handleImportQuarterFromNspdAndConvertToMsk(quarterNumber, filterType, importMode);
    }
}

// НОВАЯ ФУНКЦИЯ
async function handleImportQuarterFromNspdAndConvertToMsk(quarterNumber, filterType, destScId) {
    isNspdLoadCancelled = false;
    showLoader(true, `Загрузка данных EPSG3857 для квартала ${quarterNumber}...`);

    try {
        const destSystem = COORDINATE_SYSTEMS.find(s => s.value === destScId);
        if (!destSystem || !destSystem.def) {
            throw new Error(`Не найдено определение для целевой СК: ${destScId}`);
        }
        proj4.defs(destSystem.value, destSystem.def);
        if (typeof proj4.defs['EPSG:3857'] === 'undefined') {
             proj4.defs("EPSG:3857", COORDINATE_SYSTEMS.find(s => s.value === "EPSG:3857").def);
        }
        if (typeof proj4.defs['EPSG:4326'] === 'undefined') {
             proj4.defs("EPSG:4326", COORDINATE_SYSTEMS.find(s => s.value === "EPSG:4326").def);
        }

        showLoader(true, `Запрос геометрии квартала ${quarterNumber}...`);
        if (isNspdLoadCancelled) return; 

        const quarterGeomUrl = `https://nspd.gov.ru/api/geoportal/v2/search/geoportal?thematicSearchId=2&query=${quarterNumber}`;
        const quarterGeomData = await fetchNspd(quarterGeomUrl);
        const quarterFeature = quarterGeomData?.data?.features?.[0];
        if (!quarterFeature || !quarterFeature.geometry) {
            throw new Error(`Не найдена геометрия для квартала ${quarterNumber}`);
        }
        
        const categories = [];
        if (filterType === 'zu' || filterType === 'all') categories.push({ "id": 36368, "name": "land_record" });
        if (filterType === 'oks' || filterType === 'all') categories.push({ "id": 36369, "name": "build_record" });
        if (filterType === 'construction' || filterType === 'all') categories.push({ "id": 36383, "name": "construction_record" });
        
        if (categories.length === 0) {
             throw new Error(`Неизвестный тип фильтра: ${filterType}`);
        }
        
        showLoader(true, `Загрузка объектов (${filterType}) в квартале ${quarterNumber}...`);
        if (isNspdLoadCancelled) return; 

        const requestBody = {
            "geom": { "type": "FeatureCollection", "features": [{ "type": "Feature", "geometry": quarterFeature.geometry, "properties": {} }] },
            "categories": categories.map(c => ({ "id": c.id }))
        };
        const intersectsUrl = 'https://nspd.gov.ru/api/geoportal/v1/intersects?typeIntersect=fullObject';
        
        const intersectsResponse = await fetch(intersectsUrl, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json', 'Referer': 'https://nspd.gov.ru/' },
            body: JSON.stringify(requestBody)
        });
        if (!intersectsResponse.ok) throw new Error(`Ошибка при запросе объектов: ${intersectsResponse.statusText}`);
        const objectsData = await intersectsResponse.json();
        
        const featuresToConvert = objectsData.features || [];
        if (featuresToConvert.length === 0) {
            showNotification(`В квартале ${quarterNumber} не найдено объектов типа '${filterType}' `, "info");
            return;
        }

        showLoader(true, `Конвертация ${featuresToConvert.length} объектов...`);
        let addedObjectsBatch = [];
        let errors = 0;

        for (const feature of featuresToConvert) {
            if (isNspdLoadCancelled) {
                console.log("Конвертация объектов квартала прервана пользователем.");
                break;
            }

            try {
                const cadNumber = feature.properties.descr || feature.properties.options?.cad_num || `Объект без КН`;
                if (!feature.geometry || !feature.geometry.coordinates) {
                    console.warn(`Пропущен объект ${cadNumber} - нет геометрии.`);
                    continue;
                }

                const categoryId = feature.properties.category;
                const categoryInfo = categories.find(c => c.id === categoryId);
                const subType = categoryInfo ? categoryInfo.name : null;

                const geometryType = feature.geometry.type;
                const coordinatesArray = feature.geometry.coordinates;

                // --- НАЧАЛО ИЗМЕНЕНИЙ ---
                // Логика обработки координат для разных типов геометрии
                let rings = [];
                if (geometryType === "Polygon") {
                    // coordinates для Polygon это [ [ [x,y],... ], [ [x,y],... ] ] (внешний и дырки)
                    // Мы берем все эти массивы как отдельные контуры.
                    rings = coordinatesArray;
                } else if (geometryType === "MultiPolygon") {
                    // coordinates для MultiPolygon это [ [ [ [x,y],... ] ] , [ [ [ [x,y],... ] ] ] ]
                    // Уплощаем до уровня отдельных контуров
                    rings = coordinatesArray.flat(1);
                } else {
                    console.warn(`Неподдерживаемый тип геометрии "${geometryType}" для объекта ${cadNumber}`);
                    continue;
                }

                const objectMskContours = [];
                rings.forEach(ring => {
                    if (!ring || ring.length === 0) return;
                    const mskPoints = ring.map(coord_3857 => {
                        const wgs84 = proj4('EPSG:3857', 'EPSG:4326', coord_3857);
                        const msk = proj4('EPSG:4326', destSystem.value, wgs84);
                        const finalX = msk[1] + (destSystem.offsetX || 0);
                        const finalY = msk[0] + (destSystem.offsetY || 0);
                        return { x: roundCoord(finalX), y: roundCoord(finalY) };
                    });
                    if (mskPoints.length > 0) {
                        objectMskContours.push(mskPoints);
                    }
                });
                // --- КОНЕЦ ИЗМЕНЕНИЙ ---

                if (objectMskContours.length > 0) {
                    const newObj = addObjectInternal(objectMskContours, cadNumber, "polygon", true, subType);
                    if (newObj) {
                        addedObjectsBatch.push(newObj);
                    }
                } else {
                     errors++;
                }
            } catch (convertError) {
                errors++;
                console.error(`Ошибка конвертации для объекта`, feature, convertError);
            }
        }
        
        if (addedObjectsBatch.length > 0) {
            finalizeBatchAdd(addedObjectsBatch);
            showNotification(`Загружено и конвертировано ${addedObjectsBatch.length} объектов ${errors > 0 ? errors + ' с ошибками.' : ''}`, "success");
        } else if (errors > 0 && !isNspdLoadCancelled) {
             showNotification(`Не удалось загрузить или конвертировать объекты. Ошибок: ${errors}.`, "error");
        }

    } catch (error) {
        if (!isNspdLoadCancelled) { 
            console.error("Ошибка при загрузке квартала:", error);
            showNotification(`Ошибка загрузки: ${error.message}`, "error");
        }
    } finally {
        if (!isNspdLoadCancelled) { 
            showLoader(false); 
        }
    }
}


async function handleFindCoordinates() {
        const inputText = coordsInput.value.trim();
        if (!inputText) {
            showNotification("Поле ввода пустое.", "warning", "exclamation-triangle");
            return;
        }

        // Парсим координаты (используем существующую функцию)
        const parsedContours = parseCoordinatesFromText(inputText);
        
        if (parsedContours && parsedContours.length > 0) {
            closeCoordsDialog();
            
            // Собираем ВСЕ точки из всех контуров в один плоский массив
            const allPoints = [];
            parsedContours.forEach(contour => {
                contour.forEach(p => allPoints.push(p));
            });

            if (allPoints.length === 0) return;

            showLoader(true, `Создание ${allPoints.length} точек...`);

            // Добавляем каждую точку как отдельный объект
            // Используем subType = 'crosshair' для особого стиля отрисовки
            const addedBatch = [];
            let counter = 1;
            
            // Чтобы не вешать браузер при тысячах точек, делаем небольшую задержку
            await new Promise(resolve => setTimeout(resolve, 50));

            allPoints.forEach(pt => {
                // Создаем контур из одной точки
                const singlePointContour = [[{ x: pt.x, y: pt.y }]];
                const name = `Тчк ${counter++}`;
                
                // subType: 'crosshair' будет сигналом для drawObjects рисовать прицел
                const newObj = addObjectInternal(singlePointContour, name, 'point', true, 'crosshair');
                if (newObj) addedBatch.push(newObj);
            });

            if (addedBatch.length > 0) {
                finalizeBatchAdd(addedBatch);
                showNotification(`Добавлено ${addedBatch.length} точек поиска.`, "success", "crosshairs");
            }
            
            showLoader(false);
        } else {
            showNotification("Не удалось распознать координаты.", "error");
        }
    }
    
    
    
function extractObjectsFromXml(xmlContent, filterType) {
    // --- НАЧАЛО БЛОКА ЛОГИРОВАНИЯ ---
    console.log(`%c[DEBUG] Запуск extractObjectsFromXml. Режим фильтрации: "${filterType}"`, 'color: blue; font-weight: bold;');
    // --- КОНЕЦ БЛОКА ЛОГИРОВАНИЯ ---

    const parser = new DOMParser();
    const xmlDoc = parser.parseFromString(xmlContent, "text/xml");
    const extracted = [];
    const TOLERANCE_DIGITS = 2;

    if (filterType === 'adjacent') {
        // --- Логика ТОЛЬКО для режима "Смежные" ---
        console.log('%c[ADJACENT] Активирован режим поиска смежных объектов.', 'color: purple;');

        if (userObjects.length === 0) {
            showNotification("Для загрузки смежных объектов на карте должен быть хотя бы один объект.", "warning");
            console.warn('[ADJACENT] На карте нет объектов для сравнения. Прерывание.');
            return [];
        }
        
        console.log(`[ADJACENT] Объектов на карте для проверки: ${userObjects.length}`);

        // 1. Собираем все точки существующих объектов в Set
        const existingPoints = new Set();
        userObjects.forEach(obj => {
            if (!obj.contours) return;
            obj.contours.forEach(contour => {
                if (!contour) return;
                contour.forEach(p => {
                    if (p && isFinite(p.x) && isFinite(p.y)) {
                        existingPoints.add(`${p.x.toFixed(TOLERANCE_DIGITS)}_${p.y.toFixed(TOLERANCE_DIGITS)}`);
                    }
                });
            });
        });
        
        console.log(`[ADJACENT] Собрано уникальных точек с карты для сравнения: ${existingPoints.size}`);
        if (existingPoints.size === 0) {
             console.error('[ADJACENT] КРИТИЧЕСКАЯ ОШИБКА: Объекты на карте есть, но не удалось собрать их точки!');
             return [];
        }

        // 2. Извлекаем ВСЕ объекты из XML для проверки
        const allRecordsFromXml = xmlDoc.querySelectorAll('land_record, build_records build_record, construction_records construction_record');
        console.log(`[ADJACENT] Найдено в XML файле для проверки: ${allRecordsFromXml.length} объектов.`);

        allRecordsFromXml.forEach(record => {
            const cadNumber = getElementValueFromNode(record, 'object > common_data > cad_number');
            if (!cadNumber) return;

            console.log(`[ADJACENT] --- Проверка объекта из XML: ${cadNumber} ---`);

            const contours = extractCoordinatesFromXMLNode(record);
            if (contours.length === 0) {
                console.log(`[ADJACENT] У объекта ${cadNumber} не найдено координат. Пропуск.`);
                return;
            }

            let isAdjacent = false;
            let matchingPoint = null;

            // 3. Проверяем каждый объект из XML на наличие хотя бы одной общей точки
            for (const newContour of contours) {
                if (!newContour) continue;
                for (const newPoint of newContour) {
                    const pointKey = `${newPoint.x.toFixed(TOLERANCE_DIGITS)}_${newPoint.y.toFixed(TOLERANCE_DIGITS)}`;
                    if (existingPoints.has(pointKey)) {
                        isAdjacent = true;
                        matchingPoint = pointKey; // Запоминаем точку, на которой нашли совпадение
                        break;
                    }
                }
                if (isAdjacent) break;
            }

            // 4. Если объект был помечен как смежный, добавляем его в результат
            if (isAdjacent) {
                console.log(`%c[ADJACENT] РЕШЕНИЕ: Добавить объект ${cadNumber}. Найдена общая точка: ${matchingPoint}`, 'color: green;');
                extracted.push({
                    name: cadNumber,
                    contours: contours
                });
            } else {
                 console.log(`%c[ADJACENT] РЕШЕНИЕ: Пропустить объект ${cadNumber}. Общих точек не найдено.`, 'color: red;');
            }
        });
        
        console.log(`%c[DEBUG] Завершение extractObjectsFromXml. Всего для добавления: ${extracted.length} смежных объектов.`, 'color: blue; font-weight: bold;');
        return extracted;

    } else {
        // --- Логика для ВСЕХ ОСТАЛЬНЫХ режимов ---
        console.log(`[DEBUG] Активирован режим фильтрации "${filterType}".`);

        const processRecords = (records, objectCategory) => {
            if (filterType !== 'all' && filterType !== objectCategory) return;
            console.log(`[DEBUG] Обработка ${records.length} записей для категории "${objectCategory}".`);
            records.forEach(record => {
                const cadNumber = getElementValueFromNode(record, 'object > common_data > cad_number');
                if (!cadNumber) return;
                const contours = extractCoordinatesFromXMLNode(record);
                if (contours.length > 0) {
                    extracted.push({ name: cadNumber, contours: contours });
                }
            });
        };

        processRecords(xmlDoc.querySelectorAll('land_record'), 'zu');
        processRecords(xmlDoc.querySelectorAll('build_records build_record'), 'oks');
        processRecords(xmlDoc.querySelectorAll('construction_records construction_record'), 'construction');

        console.log(`%c[DEBUG] Завершение extractObjectsFromXml. Всего для добавления: ${extracted.length} объектов.`, 'color: blue; font-weight: bold;');
        return extracted;
    }
}

  function onSegment(p, q, r, tolerance) {
        return (q.x <= Math.max(p.x, r.x) + tolerance && q.x >= Math.min(p.x, r.x) - tolerance &&
                q.y <= Math.max(p.y, r.y) + tolerance && q.y >= Math.min(p.y, r.y) - tolerance);
    }

    function orientation(p, q, r, tolerance) {
        const val = (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
        if (Math.abs(val) < tolerance) return 0; // Коллинеарны
        return (val > 0) ? 1 : 2; // По часовой или против часовой стрелки
    }

    function segmentsCoincide(p1, q1, p2, q2, tolerance = 0.01) {
        // Проверяем, что все 4 точки коллинеарны
        if (orientation(p1, q1, p2, tolerance) !== 0 ||
            orientation(p1, q1, q2, tolerance) !== 0 ||
            orientation(p2, q2, p1, tolerance) !== 0 ||
            orientation(p2, q2, q1, tolerance) !== 0) {
            return false;
        }

        // Проверяем, что отрезки пересекаются (накладываются)
        if (onSegment(p1, p2, q1) || onSegment(p1, q2, q1) ||
            onSegment(p2, p1, q2) || onSegment(p2, q1, q2)) {
            return true;
        }

        return false;
    }
    
    
async function fetchKptXmlContent(quarterNumber) {
    const serverQuarterPrefix = quarterNumber.replace(/:/g, '_');
    try {
        const responseList = await fetch(`${STORAGE_API_URL}/${BUCKET_NAME}?search=${serverQuarterPrefix}`);
        if (!responseList.ok) throw new Error(`Ошибка сети: ${responseList.statusText}`);
        
        const fileList = await responseList.json();
        if (!fileList || fileList.length === 0) throw new Error(`КПТ для квартала ${quarterNumber} не найдены.`);

        const matchingFiles = fileList.filter(f => f.name.startsWith(serverQuarterPrefix) && f.name.toLowerCase().endsWith('.zip'));
        if (matchingFiles.length === 0) throw new Error(`Архивы КПТ для квартала ${quarterNumber} не найдены.`);

        const latestFile = matchingFiles.sort((a, b) => b.name.localeCompare(a.name))[0];
        
        const responseDownload = await fetch(`${STORAGE_API_URL}/${BUCKET_NAME}/${latestFile.name}`);
        if (!responseDownload.ok) throw new Error(`Ошибка загрузки файла: ${responseDownload.statusText}`);
        
        const blob = await responseDownload.blob();
        const zip = await JSZip.loadAsync(blob);
        
        let xmlFileEntry = null;
        for (const fileNameInZip in zip.files) {
            if (fileNameInZip.toLowerCase().endsWith('.xml') && !zip.files[fileNameInZip].dir) {
                xmlFileEntry = zip.files[fileNameInZip];
                break;
            }
        }
        if (!xmlFileEntry) throw new Error("XML-файл не найден в архиве.");

        return await xmlFileEntry.async('string');

    } catch (error) {
        throw new Error(error.message); // Перебрасываем ошибку для обработки в `processQuarterLoad`
    }
}

// Новые функции для расчета смежности по Bbox
function calculateObjectsBoundingBox(objects) {
    if (!objects || objects.length === 0) return null;
    let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
    let hasPoints = false;
    objects.forEach(obj => {
        if (!obj.contours) return;
        obj.contours.forEach(contour => {
            if (!contour) return;
            contour.forEach(p => {
                if (p && isFinite(p.x) && isFinite(p.y)) {
                    minX = Math.min(minX, p.x);
                    minY = Math.min(minY, p.y);
                    maxX = Math.max(maxX, p.x);
                    maxY = Math.max(maxY, p.y);
                    hasPoints = true;
                }
            });
        });
    });
    return hasPoints ? { minX, minY, maxX, maxY } : null;
}

function doBoundingBoxesIntersect(box1, box2) {
    if (!box1 || !box2) return false;
    return (
        box1.minX <= box2.maxX &&
        box1.maxX >= box2.minX &&
        box1.minY <= box2.maxY &&
        box1.maxY >= box2.minY
    );
}

function consolidateContoursIntoObjects(contours) {
        // 1. Подготовка данных с вычислением площади
        let items = contours.map(c => ({
            contour: c,
            area: calculatePolygonArea(c),
            holes: []
        }));

        // 2. Сортировка по убыванию площади (от самого большого к самому маленькому)
        items.sort((a, b) => b.area - a.area);

        const roots = [];

        // 3. Проверка вложенности
        items.forEach(item => {
            let bestParent = null;

            // Ищем подходящего родителя среди уже отобранных "корневых" полигонов
            for (const r of roots) {
                // Проверяем, находится ли первая точка текущего контура внутри потенциального родителя
                // (Этого обычно достаточно для корректной геометрии)
                if (isPointInPolygon(item.contour[0], r.contour)) {
                    // Если нашли родителя, проверяем, является ли он "ближайшим" (наименьшим из подходящих)
                    // Хотя при сортировке по убыванию первый найденный часто подходит, 
                    // поиск наименьшего родителя обеспечивает корректную вложенность (остров внутри озера на острове)
                    if (!bestParent || r.area < bestParent.area) {
                        bestParent = r;
                    }
                }
            }

            if (bestParent) {
                // Если родитель найден, добавляем текущий контур как дырку
                bestParent.holes.push(item.contour);
            } else {
                // Если родителя нет, это новый внешний контур
                roots.push(item);
            }
        });

        // 4. Возвращаем массив объектов, где каждый объект — это массив контуров [внешний, дырка1, дырка2...]
        return roots.map(r => [r.contour, ...r.holes]);
    }
    

async function handleImportFromTextareaCoordinates(text, color = null) {
     const parsedContours = parseCoordinatesFromText(text);
     if (parsedContours && parsedContours.length > 0) {
        closeCoordsDialog();
        
        const groupedContours = consolidateContoursIntoObjects(parsedContours);
        
        let addedObjects = [];
        for (let i = 0; i < groupedContours.length; i++) {
            const objectContours = groupedContours[i];
            
            if (objectContours && objectContours.length > 0) {
                 const mainContour = objectContours[0];
                 const isClosed = mainContour.length >= 3 &&
                               Math.abs(mainContour[0].x - mainContour[mainContour.length - 1].x) < 0.001 &&
                               Math.abs(mainContour[0].y - mainContour[mainContour.length - 1].y) < 0.001;
                
                let objectType = isClosed ? 'polygon' : (mainContour.length >= 2 ? 'line' : 'point');
                
                const nameBase = groupedContours.length > 1 ? `Участок ${nextObjectId} (${i+1})` : `Участок ${nextObjectId}`;

                // --- ИЗМЕНЕНИЕ: Передаем color ---
                const newObj = addObjectInternal(objectContours, nameBase, objectType, true, null, color);
                // ---------------------------------
                if(newObj) addedObjects.push(newObj);
            }
        }

        if(addedObjects.length > 0) {
            finalizeBatchAdd(addedObjects);
        }

     } else { showNotification("Не удалось распознать валидные координаты X Y.", "error", "exclamation-circle"); }
}

async function handleImportFromFile() {
         // --- СЧИТЫВАНИЕ ЦВЕТА ---
         const useFixedColor = document.getElementById('useFixedColor').checked;
         const fixedColor = useFixedColor ? document.getElementById('importColorInput').value : null;
         // ------------------------

         const fileInput = document.createElement('input'); fileInput.type = 'file'; fileInput.accept = '.txt,.csv';
         fileInput.onchange = async (e) => {
             const file = e.target.files[0]; if (!file) return;
             const baseName = file.name.split('.').slice(0, -1).join('.') || `Файл ${nextObjectId}`;
             const reader = new FileReader();
             reader.onload = async (event) => {
                 const content = event.target.result;
                 const parsedContours = parseCoordinatesFromText(content);
                  if (parsedContours && parsedContours.length > 0) {
                      closeCoordsDialog();
                      let addedObjects = [];
                      for (let i = 0; i < parsedContours.length; i++) {
                          const contour = parsedContours[i];
                           if (contour && contour.length > 0) {
                               const isClosed = contour.length >= 3 &&
                                   Math.abs(contour[0].x - contour[contour.length - 1].x) < 0.001 &&
                                   Math.abs(contour[0].y - contour[contour.length - 1].y) < 0.001;
                               let objectType = isClosed ? 'polygon' : (contour.length >= 2 ? 'line' : 'point');
                               
                               const autoName = `${baseName}${parsedContours.length > 1 ? '_'+(i+1) : ''}`;
                               
                               // --- ИЗМЕНЕНИЕ: Передаем fixedColor ---
                               const newObj = addObjectInternal([contour], autoName, objectType, true, null, fixedColor);
                               // --------------------------------------
                               
                               if(newObj) addedObjects.push(newObj);
                           }
                      }
                      if(addedObjects.length > 0) {
                          finalizeBatchAdd(addedObjects);
                      }
                  } else { showNotification('Не удалось найти валидные координаты в файле.', 'error', 'exclamation-circle'); }
             };
             reader.onerror = () => { showNotification('Ошибка чтения файла.', 'error', 'exclamation-circle'); };
             reader.readAsText(file);
         };
         fileInput.click();
    }

    function parseCoordinatesFromText(text) {
        const lines = text.split('\n');
        const contours = [];
        let currentContour = [];
        lines.forEach(line => {
            line = line.trim().replace(/,/g, '.');
            if (line === '') { // Пустая строка разделяет контуры
                if (currentContour.length > 0) {
                    contours.push(currentContour);
                    currentContour = [];
                }
            } else {
                const parts = line.split(/[\s\t]+/);
                if (parts.length >= 2) {
                    let x = parseFloat(parts[0]);
                    let y = parseFloat(parts[1]);
                     if (!isFinite(x) || !isFinite(y)) { // Try swapping if first parse failed
                         x = parseFloat(parts[1]);
                         y = parseFloat(parts[0]);
                     }
                    if (isFinite(x) && isFinite(y)) {
                        currentContour.push({ x: roundCoord(x), y: roundCoord(y) });
                    }
                }
            }
        });
        if (currentContour.length > 0) { // Добавляем последний контур, если он не пустой
            contours.push(currentContour);
        }
        return contours.filter(c => c.length > 0); // Возвращаем только непустые контуры
    }

    function showNamePrompt(title, initialValue = '') {
        return new Promise((resolve) => {
            namePromptTitle.textContent = title; namePromptInput.value = initialValue;
            namePromptDialog.classList.add('show'); namePromptOverlay.classList.add('show');
            namePromptInput.focus(); namePromptInput.select();
            let resolved = false;
            const cleanupAndResolve = (value) => { if (resolved) return; resolved = true; namePromptSaveBtn.onclick = null; namePromptCancelBtn.onclick = null; namePromptOverlay.onclick = null; namePromptInput.onkeydown = null; namePromptDialog.classList.remove('show'); namePromptOverlay.classList.remove('show'); resolve(value); };
            const handleSave = () => { const name = namePromptInput.value.trim(); if (name) cleanupAndResolve(name); else { showNotification("Имя не может быть пустым.", "warning"); namePromptInput.focus(); } };
            const handleCancel = () => cleanupAndResolve(null);
            const handleKeydown = (e) => { if (e.key === 'Enter') { e.preventDefault(); handleSave(); } else if (e.key === 'Escape') handleCancel(); };
            namePromptSaveBtn.onclick = handleSave; namePromptCancelBtn.onclick = handleCancel; namePromptOverlay.onclick = handleCancel; namePromptInput.onkeydown = handleKeydown;
        });
    }
    function calculatePolygonArea(polygon) {
        let area = 0; const n = polygon.length; if (n < 3) return 0;
        for (let i = 0; i < n; i++) {
            const p1 = polygon[i]; const p2 = polygon[(i + 1) % n];
            if (!p1 || !p2 || !isFinite(p1.x) || !isFinite(p1.y) || !isFinite(p2.x) || !isFinite(p2.y)) return 0;
            area += (p1.x * p2.y - p2.x * p1.y);
        }
        return roundCoord(Math.abs(area / 2.0));
    }
    function calculatePolygonPerimeter(polygon, isClosed = true) {
        let length = 0; const n = polygon.length; if (n < 1) return 0; if (n === 1) return 0;
        for (let i = 0; i < n - 1; i++) {
            const p1 = polygon[i]; const p2 = polygon[i + 1];
            if (!p1 || !p2 || !isFinite(p1.x) || !isFinite(p1.y) || !isFinite(p2.x) || !isFinite(p2.y)) return NaN;
            const dist = calculateDistance(p1,p2); if (isNaN(dist)) return NaN; length += dist;
        }
        if (isClosed && n >= 3) {
            const p1 = polygon[n - 1]; const p2 = polygon[0];
            // Ensure points are valid before calculating distance.
            if (!p1 || !p2 || !isFinite(p1.x) || !isFinite(p1.y) || !isFinite(p2.x) || !isFinite(p2.y)) return NaN;
             // Check if first and last points are indeed the same for a closed polygon before adding last segment.
            const PRECISION_THRESHOLD = 0.001;
            if (Math.abs(p1.x - p2.x) > PRECISION_THRESHOLD || Math.abs(p1.y - p2.y) > PRECISION_THRESHOLD) {
                // This case implies the polygon was not properly closed by having the last point identical to the first.
                // The updateObjectMetrics function should handle closing it.
                // For perimeter calculation, we should calculate distance if they are meant to be connected.
                 const dist = calculateDistance(p1, p2); if (isNaN(dist)) return NaN; length += dist;
            }
        }
        return roundCoord(length);
    }
   function checkIntersection(poly1, poly2) {
    if (!poly1 || poly1.length < 3 || !poly2 || poly2.length < 3) return { intersects: false, contains: false, containedBy: false, sharedVertices: 0 };
    let min1x=Infinity,min1y=Infinity,max1x=-Infinity,max1y=-Infinity,v1=false;
    let min2x=Infinity,min2y=Infinity,max2x=-Infinity,max2y=-Infinity,v2=false;
    poly1.forEach(p => { if(p&&isFinite(p.x)&&isFinite(p.y)){min1x=Math.min(min1x,p.x);min1y=Math.min(min1y,p.y);max1x=Math.max(max1x,p.x);max1y=Math.max(max1y,p.y);v1=true;} });
    poly2.forEach(p => { if(p&&isFinite(p.x)&&isFinite(p.y)){min2x=Math.min(min2x,p.x);min2y=Math.min(min2y,p.y);max2x=Math.max(max2x,p.x);max2y=Math.max(max2y,p.y);v2=true;} });
    if(!v1||!v2) return { intersects: false, contains: false, containedBy: false, sharedVertices: 0 };
    const sharedVertices = countSharedVertices(poly1, poly2);
    if(max1x < min2x || max2x < min1x || max1y < min2y || max2y < min1y) {
        return { intersects: sharedVertices > 0, contains: false, containedBy: false, sharedVertices };
    }
    let intersects=false;
    for(const p1 of poly1){if(p1&&isFinite(p1.x)&&isFinite(p1.y)&&isPointInPolygon(p1,poly2)){intersects=true;break;}}
    if(!intersects){for(const p2 of poly2){if(p2&&isFinite(p2.x)&&isFinite(p2.y)&&isPointInPolygon(p2,poly1)){intersects=true;break;}}}
    let contains=false, containedBy=false;
    if(intersects || !(max1x < min2x || max2x < min1x || max1y < min2y || max2y < min1y)) {
        contains = poly2.every(p => (p && isFinite(p.x) && isFinite(p.y)) ? isPointInPolygon(p, poly1) : true);
        containedBy = poly1.every(p => (p && isFinite(p.x) && isFinite(p.y)) ? isPointInPolygon(p, poly2) : true);
    }
    if(contains && containedBy){ contains = false; containedBy = false; intersects = true; }
    if(containedBy || contains) { intersects = true; }
    return { intersects, contains, containedBy, sharedVertices };
}
    function isPointInPolygon(point, polygon) {
        if (!polygon || polygon.length < 3 || !point || !isFinite(point.x) || !isFinite(point.y)) return false;
        let inside = false;
        const ptX = point.x;
        const ptY = point.y;
        for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
            const pi = polygon[i], pj = polygon[j];
            if (!pi || !pj || !isFinite(pi.x) || !isFinite(pi.y) || !isFinite(pj.x) || !isFinite(pj.y)) continue;
            const xi = pi.x, yi = pi.y;
            const xj = pj.x, yj = pj.y;
            if ((xi === ptX && yi === ptY) || (xj === ptX && yj === ptY)) return true;
            const onHorizontal = (Math.abs(yi - ptY) < 1e-9 && Math.abs(yj - ptY) < 1e-9) && (ptX >= Math.min(xi, xj) - 1e-9 && ptX <= Math.max(xi, xj) + 1e-9);
            const onVertical = (Math.abs(xi - ptX) < 1e-9 && Math.abs(xj - ptX) < 1e-9) && (ptY >= Math.min(yi, yj) - 1e-9 && ptY <= Math.max(yi, yj) + 1e-9);
            if (onHorizontal || onVertical) return true;
            const intersect = ((yi > ptY) !== (yj > ptY)) && (ptX < (xj - xi) * (ptY - yi) / (yj - yi) + xi);
            if (intersect) inside = !inside;
        }
        return inside;
    }
    function getContourCentroid(contour) {
        if (!contour || contour.length === 0) return { x: NaN, y: NaN };
        let sumX = 0, sumY = 0; let validPoints = 0;
        contour.forEach(p => { if (p && isFinite(p.x) && isFinite(p.y)) { sumX += p.x; sumY += p.y; validPoints++; } });
        if (validPoints === 0) return { x: NaN, y: NaN };
        return { x: roundCoord(sumX / validPoints), y: roundCoord(sumY / validPoints) };
    }
    const transformCoord = (dataX, dataY) => {
        const cH = canvas.height || 0;
        const cX = offsetX + (dataY - cMinYGlob()) * scale;
        const cY = cH - (offsetY + (dataX - cMinXGlob()) * scale);
        return [cX, cY];
    };
    const inverseTransformCoord = (canvasX, canvasY) => {
        const cH = canvas.height || 0;
        if (Math.abs(scale) < 1e-9) return { x: NaN, y: NaN };
        const dX_raw = cMinXGlob() + (cH - canvasY - offsetY) / scale;
        const dY_raw = cMinYGlob() + (canvasX - offsetX) / scale;
        return { x: roundCoord(dX_raw), y: roundCoord(dY_raw) };
    };

    function redraw(preserveTransform = false) {
        if (canvas.width !== canvas.offsetWidth || canvas.height !== canvas.offsetHeight) {
            canvas.width = canvas.offsetWidth; canvas.height = canvas.offsetHeight;
            if (!preserveTransform) { calculateBounds(); if (!hasValidView()) resetView(); }
        }
        ctx.setTransform(1, 0, 0, 1, 0, 0); ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = 'white'; ctx.fillRect(0, 0, canvas.width, canvas.height);
        if (userObjects.length === 0 && !rulerMode && !isDrawingActive && !isGeometryEditMode) {
             ctx.fillStyle = "#777"; ctx.font = "16px Arial"; ctx.textAlign = "center";
             ctx.fillText("Добавьте объекты (+), нарисуйте (✎), редактируйте () или измерьте (📏)", canvas.width / 2, canvas.height / 2);
        }
        if (!preserveTransform) calculateBounds();
        if (!hasValidView()) { ctx.fillStyle = "red"; ctx.font = "bold 18px Arial"; ctx.textAlign = "center"; ctx.fillText("Ошибка отображения: Невалидное состояние вида.", canvas.width / 2, canvas.height / 2); return; }

        const gridStep = determineGridStep();
        drawGrid(ctx, gridStep);
        drawObjects(ctx);
        drawActiveDrawingPreview(ctx);
        drawRuler(ctx);
     
        
        drawSelectedCoordinateMarker(ctx);
        drawSnapHighlight(ctx);

        if (showLabels) {
            drawCoordinateLabels(ctx);
        }

        updateGridInfo(gridStep);
        updateViewInfo();
    }

    function getPointState(pointToCheck, currentObjectIndex) {
        let isInsideOtherPolygon = false;
        let isCoincidentWithOther = false;
        if (!pointToCheck || !isFinite(pointToCheck.x) || !isFinite(pointToCheck.y)) {
            return { isCoincident: false, isInsideOther: false };
        }
        userObjects.forEach((otherObj, otherIndex) => {
            if (currentObjectIndex === otherIndex || !otherObj || !otherObj.contours) return;
            if (!isCoincidentWithOther) {
                for (const otherContour of otherObj.contours) {
                    if (!otherContour) continue;
                    for (const otherPoint of otherContour) {
                        if (otherPoint && isFinite(otherPoint.x) && isFinite(otherPoint.y)) {
                            if (pointToCheck.x === otherPoint.x && pointToCheck.y === otherPoint.y) {
                                isCoincidentWithOther = true; break;
                            }
                        }
                    }
                    if (isCoincidentWithOther) break;
                }
            }
            if (!isInsideOtherPolygon && otherObj.type === 'polygon' && otherObj.contours[0] && otherObj.contours[0].length >= 3) {
                let pointIsPartOfOtherPolygonBoundary = false;
                if (otherObj.contours[0]) {
                    for(const boundaryPoint of otherObj.contours[0]) {
                         if (boundaryPoint && isFinite(boundaryPoint.x) && isFinite(boundaryPoint.y)) {
                             if (pointToCheck.x === boundaryPoint.x && pointToCheck.y === boundaryPoint.y) {
                                pointIsPartOfOtherPolygonBoundary = true; break;
                             }
                         }
                    }
                }
                if (!pointIsPartOfOtherPolygonBoundary && isPointInPolygon(pointToCheck, otherObj.contours[0])) {
                    isInsideOtherPolygon = true;
                }
            }
        });
        return { isCoincident: isCoincidentWithOther, isInsideOther: isInsideOtherPolygon };
    }


function drawObjects(ctx) {
    userObjects.forEach((obj, index) => {
        if (!obj || !obj.contours) return;
        if (obj.visible === false) return;
        const isSelected = (index === selectedObjectIndex);
        const isBeingEdited = (isGeometryEditMode && index === editingObjectIndex);

        ctx.strokeStyle = obj.color || '#000000';
        ctx.lineWidth = (isSelected || isBeingEdited) ? 2.5 : 1.5;

        // 1. Отрисовка линий/полигонов (без изменений)
        if (obj.subType === 'construction_record') {
            obj.contours.forEach(contour => {
                if (!contour || contour.length < 1) return;
                ctx.beginPath();
                contour.forEach((point, pIdx) => {
                    const [canvasX, canvasY] = transformCoord(point.x, point.y);
                    if (pIdx === 0) { ctx.moveTo(canvasX, canvasY); } else { ctx.lineTo(canvasX, canvasY); }
                });
                ctx.stroke();
            });
        } else {
            const fillColor = (obj.type === 'polygon') ? hexToRgba(obj.color || '#000000', (isSelected || isBeingEdited) ? 0.3 : 0.15) : 'transparent';
            ctx.fillStyle = fillColor;

            if (obj.type === 'polygon') {
                ctx.beginPath();
                let hasValidContour = false;
                obj.contours.forEach((contour) => {
                    if (!contour || contour.length === 0) return;
                    let firstPoint = true;
                    contour.forEach((point) => {
                        const [canvasX, canvasY] = transformCoord(point.x, point.y);
                        if (firstPoint) { ctx.moveTo(canvasX, canvasY); firstPoint = false; } else { ctx.lineTo(canvasX, canvasY); }
                    });
                    ctx.closePath(); hasValidContour = true;
                });
                if (hasValidContour) { ctx.fill('evenodd'); ctx.stroke(); }
            } else if (obj.type === 'line') {
                 obj.contours.forEach((contour) => {
                    if (!contour || contour.length === 0) return;
                    ctx.beginPath();
                    contour.forEach((point, pIdx) => {
                        const [canvasX, canvasY] = transformCoord(point.x, point.y);
                        if (pIdx === 0) ctx.moveTo(canvasX, canvasY); else ctx.lineTo(canvasX, canvasY);
                    });
                    ctx.stroke();
                });
            } else if (obj.type === 'point') {
                // Отрисовка точек-объектов (без изменений)
                obj.contours.forEach((contour) => {
                    if (!contour || contour.length === 0) return;
                    if (contour[0] && isFinite(contour[0].x) && isFinite(contour[0].y)){
                        const [cx, cy] = transformCoord(contour[0].x, contour[0].y);
                        if(isFinite(cx) && isFinite(cy)){
                            ctx.save(); ctx.setTransform(1,0,0,1,0,0);
                            if (obj.subType === 'crosshair') {
                                const size = (isSelected || isBeingEdited) ? 10 : 7;
                                ctx.strokeStyle = obj.color || '#e74c3c'; ctx.lineWidth = (isSelected || isBeingEdited) ? 3 : 2;
                                ctx.beginPath(); ctx.moveTo(cx - size, cy); ctx.lineTo(cx + size, cy);
                                ctx.moveTo(cx, cy - size); ctx.lineTo(cx, cy + size); ctx.stroke();
                                ctx.beginPath(); ctx.arc(cx, cy, size / 1.5, 0, Math.PI * 2); ctx.stroke();
                                if (scale > 0.5) { 
                                    ctx.fillStyle = '#333'; ctx.font = "10px monospace";
                                    ctx.fillText(`${contour[0].x.toFixed(2)}, ${contour[0].y.toFixed(2)}`, cx + size, cy - size);
                                }
                            } else {
                                ctx.fillStyle=obj.color||'#000000';
                                ctx.beginPath(); ctx.arc(cx,cy,(isSelected || isBeingEdited)?5:3.5,0,Math.PI*2); ctx.closePath(); ctx.fill();
                                ctx.strokeStyle='white'; ctx.lineWidth=1; ctx.stroke();
                            }
                            ctx.restore();
                        }
                    }
                });
            }
        }

        // 2. ОТРИСОВКА ВЕРШИН (ЗДЕСЬ БЫЛА ОШИБКА)
        // Определяем, нужно ли рисовать точки для ЭТОГО конкретного объекта
        const shouldDrawPointsForThisObj = (showPoints) || (adjacentPointsMode && adjacentObjectIndices.has(index));

        // Убрали внешний if (showPoints...), который всё блокировал
        if (shouldDrawPointsForThisObj && obj.contours.some(c => c && c.length > 0) && obj.type !== 'point') {
            obj.contours.forEach((contour, cIdx) => {
                if (!contour) return;
                contour.forEach((point, pIdx) => {
                    if (!point || !isFinite(point.x) || !isFinite(point.y)) return;
                    const [px, py] = transformCoord(point.x, point.y);
                    if (!isFinite(px) || !isFinite(py)) return;

                    const pointState = getPointState(point, index);
                    ctx.save(); ctx.setTransform(1, 0, 0, 1, 0, 0);
                    ctx.lineWidth = 1;
                    const isCurrentMovingPoint = isMovingPoint && movedPointInfo?.objectIndex === index && movedPointInfo?.contourIndex === cIdx && movedPointInfo?.pointIndex === pIdx;
                    const highlightRadius = (isSelected || isBeingEdited || isCurrentMovingPoint ? 4 : 3) + 2.5;

                    if (pointState.isCoincident && !isCurrentMovingPoint) {
                        ctx.strokeStyle = 'rgba(0, 200, 0, 0.9)';
                        ctx.beginPath(); ctx.arc(px, py, highlightRadius, 0, Math.PI * 2); ctx.stroke();
                    } else if (pointState.isInsideOther && !isCurrentMovingPoint) {
                        ctx.strokeStyle = 'rgba(255, 0, 0, 0.8)';
                        ctx.beginPath(); ctx.arc(px, py, highlightRadius, 0, Math.PI * 2); ctx.stroke();
                    }
                    ctx.restore();

                    ctx.save(); ctx.setTransform(1, 0, 0, 1, 0, 0);
                    let pointFill = isSelected || isBeingEdited ? hexToRgba(obj.color, 0.9) : hexToRgba(obj.color, 0.7);
                    let pointRadius = isSelected || isBeingEdited ? 4 : 3;
                    if(isCurrentMovingPoint){ pointFill = 'yellow'; pointRadius = 5; }

                    ctx.fillStyle = pointFill;
                    ctx.beginPath(); ctx.arc(px, py, pointRadius, 0, Math.PI * 2); ctx.closePath(); ctx.fill();
                    ctx.strokeStyle = 'white'; ctx.lineWidth = 0.5; ctx.stroke();
                    ctx.restore();
                });
            });
        }

        // 3. Подписи названий (без изменений)
        if (scale > 0.005 && obj.contours.length > 0 && obj.contours[0] && obj.contours[0].length > 0) {
            const firstContour = obj.contours[0];
            if (firstContour.every(p => p && isFinite(p.x) && isFinite(p.y))) {
                const labelPos = getContourCentroid(firstContour);
                if (labelPos && isFinite(labelPos.x) && isFinite(labelPos.y)) {
                    const [labelX, labelY] = transformCoord(labelPos.x, labelPos.y);
                    if (isFinite(labelX) && isFinite(labelY)) {
                        ctx.save(); ctx.setTransform(1, 0, 0, 1, 0, 0);
                        ctx.font = "bold 11px Arial";
                        ctx.fillStyle = obj.color || '#000000';
                        ctx.strokeStyle = 'white'; ctx.lineWidth = 2.5;
                        ctx.textAlign = "center"; ctx.textBaseline = "bottom";
                        ctx.strokeText(obj.name || `Объект ${obj.id}`, labelX, labelY - 5);
                        ctx.fillText(obj.name || `Объект ${obj.id}`, labelX, labelY - 5);
                        ctx.restore();
                    }
                }
            }
        }
    });
}

    
    function drawActiveDrawingPreview(ctx) {
        if (!isDrawingActive || currentDrawingPoints.length === 0) return;
        ctx.save(); ctx.setTransform(1, 0, 0, 1, 0, 0);
        ctx.strokeStyle = '#f39c12'; ctx.fillStyle = 'rgba(243, 156, 18, 0.7)';
        ctx.lineWidth = 1.5; ctx.globalAlpha = 0.8;
        ctx.beginPath();
        let firstDrawPoint = true;
        currentDrawingPoints.forEach((point) => {
            if (!point || !isFinite(point.x) || !isFinite(point.y)) return;
            const [cx, cy] = transformCoord(point.x, point.y);
            if (!isFinite(cx) || !isFinite(cy)) return;
            if (firstDrawPoint) { ctx.moveTo(cx, cy); firstDrawPoint = false; }
            else { ctx.lineTo(cx, cy); }
        });
        if (!firstDrawPoint) ctx.stroke();

        currentDrawingPoints.forEach((point) => {
            if (!point || !isFinite(point.x) || !isFinite(point.y)) return;
            const [cx, cy] = transformCoord(point.x, point.y);
            if (!isFinite(cx) || !isFinite(cy)) return;
            ctx.save();
            ctx.fillStyle = 'rgba(243, 156, 18, 0.7)'; ctx.strokeStyle = 'white'; ctx.lineWidth = 1;
            ctx.beginPath(); ctx.arc(cx, cy, 4, 0, Math.PI * 2); ctx.fill(); ctx.stroke();
            ctx.restore();
        });

        if (!firstDrawPoint && currentMousePos && isFinite(currentMousePos.x) && isFinite(currentMousePos.y)) {
            const lastPoint = currentDrawingPoints[currentDrawingPoints.length - 1];
            if (lastPoint && isFinite(lastPoint.x) && isFinite(lastPoint.y)) {
                const [lastX, lastY] = transformCoord(lastPoint.x, lastPoint.y);
                const [cursorCanvasX, cursorCanvasY] = transformCoord(currentMousePos.x, currentMousePos.y);
                if (isFinite(lastX) && isFinite(lastY) && isFinite(cursorCanvasX) && isFinite(cursorCanvasY)) {
                    ctx.beginPath(); ctx.moveTo(lastX, lastY); ctx.lineTo(cursorCanvasX, cursorCanvasY);
                    ctx.setLineDash([4, 4]); ctx.strokeStyle = '#f39c12'; ctx.lineWidth = 1; ctx.stroke();
                    ctx.setLineDash([]);
                }
            }
        }
        ctx.restore();
    }
    function drawRuler(ctx) {
      if (!rulerMode || rulerPoints.length === 0) return;
      ctx.save(); ctx.setTransform(1, 0, 0, 1, 0, 0);
      ctx.strokeStyle = '#e74c3c'; ctx.fillStyle = '#e74c3c';
      ctx.lineWidth = 2; ctx.font = 'bold 12px Arial';
      const p1 = rulerPoints[0];
      if (p1 && isFinite(p1.x) && isFinite(p1.y)) {
        const [p1x, p1y] = transformCoord(p1.x, p1.y);
        if (isFinite(p1x) && isFinite(p1y)) {
          ctx.beginPath(); ctx.arc(p1x, p1y, 5, 0, Math.PI * 2); ctx.fill();
          if (rulerPoints.length === 2) {
            const p2 = rulerPoints[1];
            if (p2 && isFinite(p2.x) && isFinite(p2.y)) {
              const [p2x, p2y] = transformCoord(p2.x, p2.y);
              if (isFinite(p2x) && isFinite(p2y)) {
                ctx.beginPath(); ctx.arc(p2x, p2y, 5, 0, Math.PI * 2); ctx.fill();
                ctx.beginPath(); ctx.moveTo(p1x, p1y); ctx.lineTo(p2x, p2y); ctx.stroke();
                const distance = calculateDistance(p1, p2);
                if (isFinite(distance)) {
                  const midX = (p1x + p2x) / 2; const midY = (p1y + p2y) / 2;
                  const labelText = distance.toFixed(2) + ' м';
                  const textWidth = ctx.measureText(labelText).width;
                  ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                  ctx.fillRect(midX - textWidth / 2 - 4, midY - 8, textWidth + 8, 16);
                  ctx.fillStyle = '#e74c3c'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                  ctx.fillText(labelText, midX, midY);
                }
              }
            }
          }
        }
      }
      ctx.restore();
    }
    function drawSelectedCoordinateMarker(ctx) {
        if (!selectedCoordinate || !isFinite(selectedCoordinate.x) || !isFinite(selectedCoordinate.y)) return;
        const [selX, selY] = transformCoord(selectedCoordinate.x, selectedCoordinate.y);
        if (!isFinite(selX) || !isFinite(selY)) return;
        ctx.save(); ctx.setTransform(1, 0, 0, 1, 0, 0);
        ctx.fillStyle = 'rgba(255, 0, 0, 0.8)'; ctx.strokeStyle = 'white'; ctx.lineWidth = 2;
        ctx.beginPath(); ctx.arc(selX, selY, 6, 0, Math.PI * 2); ctx.fill(); ctx.stroke();
        ctx.restore();
    }
   
function drawSnapHighlight(ctx) {
    if (!snappedToPointVisual) return;
    const [snapX, snapY] = transformCoord(snappedToPointVisual.x, snappedToPointVisual.y);
    if (!isFinite(snapX) || !isFinite(snapY)) return;

    ctx.save();
    ctx.setTransform(1, 0, 0, 1, 0, 0);
    ctx.strokeStyle = '#FF0000';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(snapX, snapY, GRAB_POINT_RADIUS_SCREEN + 2, 0, Math.PI * 2);
    ctx.stroke();
    const crossSize = GRAB_POINT_RADIUS_SCREEN + 4;
    ctx.beginPath();
    ctx.moveTo(snapX - crossSize, snapY); ctx.lineTo(snapX + crossSize, snapY);
    ctx.moveTo(snapX, snapY - crossSize); ctx.lineTo(snapX, snapY + crossSize);
    ctx.stroke();
    ctx.restore();
}


    function determineGridStep() {
        const possibleSteps = [0.01, 0.05, 0.1, 0.5, 1, 5, 10, 50, 100, 200, 500, 1000, 5000, 10000, 50000];
        const targetPixelSize = 40;
        let bestStep = 100;
        if (!hasValidView() || scale <= 0) return bestStep;
        for (const step of possibleSteps) {
            const pixelSize = step * scale;
            if (pixelSize >= targetPixelSize) { bestStep = step; break; }
            bestStep = step;
        }
        if (bestStep * scale < 10 && possibleSteps.indexOf(bestStep) < possibleSteps.length - 1) {
            bestStep = possibleSteps[possibleSteps.indexOf(bestStep) + 1];
        }
        return bestStep;
    }
    function updateGridInfo(gridStep) {
        let stepText;
        if (!isFinite(gridStep) || gridStep <= 0) stepText = '-';
        else if (gridStep < 0.1) stepText = `${(gridStep * 100).toFixed(0)} см`;
        else if (gridStep < 1) stepText = `${gridStep.toFixed(1)} м`;
        else if (gridStep >= 1000) stepText = `${(gridStep / 1000).toFixed(1)} км`;
        else stepText = `${gridStep.toFixed(0)} м`;
        gridInfoText.textContent = ` ${stepText}`;
    }
    function drawGrid(ctx, gridStep) {
        if (!hasValidView() || !isFinite(gridStep) || gridStep <= 0) return;
        ctx.save(); ctx.setTransform(1, 0, 0, 1, 0, 0);
        ctx.strokeStyle = 'rgba(200, 200, 200, 0.6)'; ctx.lineWidth = 0.5;
        ctx.beginPath();
        const cW = canvas.width, cH = canvas.height, tol = 10;
        const tl = inverseTransformCoord(0, 0); const br = inverseTransformCoord(cW, cH);
        if (!isFinite(tl.x) || !isFinite(tl.y) || !isFinite(br.x) || !isFinite(br.y)) { ctx.restore(); return; }
        const minDX = Math.min(tl.x, br.x), maxDX = Math.max(tl.x, br.x);
        const minDY = Math.min(tl.y, br.y), maxDY = Math.max(tl.y, br.y);
        const startDX = Math.floor(minDX / gridStep) * gridStep;
        const endDX = Math.ceil(maxDX / gridStep) * gridStep;
        const startDY = Math.floor(minDY / gridStep) * gridStep;
        const endDY = Math.ceil(maxDY / gridStep) * gridStep;
        for (let dX = startDX; dX <= endDX; dX += gridStep) {
            const [, lCY] = transformCoord(dX, 0);
            if (isFinite(lCY) && lCY >= -tol && lCY <= cH + tol) { ctx.moveTo(0, lCY); ctx.lineTo(cW, lCY); }
        }
        for (let dY = startDY; dY <= endDY; dY += gridStep) {
            const [lCX, ] = transformCoord(0, dY);
            if (isFinite(lCX) && lCX >= -tol && lCX <= cW + tol) { ctx.moveTo(lCX, 0); ctx.lineTo(lCX, cH); }
        }
        ctx.stroke(); ctx.restore();
    }

// Вспомогательная функция для получения уникальных точек полигона (без замыкающей)
    function getUniquePolygonPoints(contour) {
        if (!contour || contour.length === 0) return [];
        const unique = [...contour];
        const first = unique[0];
        const last = unique[unique.length - 1];
        
        // Если полигон замкнут (первая и последняя точки совпадают), удаляем последнюю
        if (unique.length > 1 && 
            Math.abs(first.x - last.x) < 0.000001 && 
            Math.abs(first.y - last.y) < 0.000001) {
            unique.pop();
        }
        return unique;
    }

   function countSharedVertices(poly1, poly2) {
        if (!poly1 || !poly2 || poly1.length === 0 || poly2.length === 0) return 0;
        let sharedCount = 0;
        
        // Используем уникальные точки для сравнения
        const uniqueP1 = getUniquePolygonPoints(poly1);
        const uniqueP2 = getUniquePolygonPoints(poly2);
        
        const addedCoords = new Set();
        
        // Собираем координаты второго полигона в Set для быстрого поиска
        // Округляем до 2 знаков для надежного сравнения координат
        const p2Set = new Set();
        for (const p2 of uniqueP2) {
            if (!p2 || !isFinite(p2.x) || !isFinite(p2.y)) continue;
            // Используем небольшой допуск при формировании ключа или toFixed(3)
            p2Set.add(`${p2.x.toFixed(3)}_${p2.y.toFixed(3)}`);
        }

        for (const p1 of uniqueP1) {
            if (!p1 || !isFinite(p1.x) || !isFinite(p1.y)) continue;
            const key = `${p1.x.toFixed(3)}_${p1.y.toFixed(3)}`;
            
            if (p2Set.has(key)) {
                sharedCount++;
            }
        }
        return sharedCount;
    }
    
    
    function updateCursorInfo(x, y) {
        if (!isFinite(x) || !isFinite(y)) { cursorCoordinates.textContent = `X: -, Y: -`; }
        else { cursorCoordinates.textContent = `X: ${x.toFixed(2)}, Y: ${y.toFixed(2)}`; }
    }

 function handleMouseDown(e) {
        const rect = canvas.getBoundingClientRect();
        const canvasMouseX = e.clientX - rect.left;
        const canvasMouseY = e.clientY - rect.top;
        const clickDataPoint = inverseTransformCoord(canvasMouseX, canvasMouseY);

        if (isDrawingMode && isDrawingActive) return;
        if (rulerMode) return;

        if (isGeometryEditMode && editingObjectIndex !== -1) {
            const obj = userObjects[editingObjectIndex];
            if (!obj || !obj.contours) { deactivateGeometryEditMode(); return; }

            const grabRadiusDataSq = (GRAB_POINT_RADIUS_SCREEN / scale) ** 2;
            let foundPointToEdit = false;

            for (let cIdx = 0; cIdx < obj.contours.length; cIdx++) {
                const contour = obj.contours[cIdx];
                if (!contour) continue;
                for (let pIdx = 0; pIdx < contour.length; pIdx++) {
                    const point = contour[pIdx];
                    if (!point || !isFinite(point.x) || !isFinite(point.y)) continue;
                    const distSq = (clickDataPoint.x - point.x)**2 + (clickDataPoint.y - point.y)**2;
                    if (distSq < grabRadiusDataSq) {
                        isMovingPoint = true;
                        movedPointInfo = {
                            objectIndex: editingObjectIndex, contourIndex: cIdx, pointIndex: pIdx,
                            originalX: point.x, originalY: point.y
                        };
                        // --- НАЧАЛО ИЗМЕНЕНИЙ ---
                        const editingObj = userObjects[editingObjectIndex];
                        if (editingObj && editingObj.type === 'polygon') {
                            movedPointInfo.originalArea = editingObj.area;
                        }
                        // --- КОНЕЦ ИЗМЕНЕНИЙ ---
                        saveGeometryStateForUndo(editingObjectIndex);
                        canvas.classList.add('editing-point-mode');
                        isDragging = false;
                        foundPointToEdit = true;
                        redraw(true);
                        break;
                    }
                }
                if (foundPointToEdit) break;
            }
            if (foundPointToEdit) return;
            return;
        }

        isDragging = true;
        startX = e.clientX; startY = e.clientY;
        lastOffsetX = offsetX; lastOffsetY = offsetY;
        canvas.style.cursor = 'grabbing';
    }



function handleMouseMove(e) {
    const r = canvas.getBoundingClientRect();
    const cX = e.clientX - r.left;
    const cY = e.clientY - r.top;

    if (!hasValidView()) {
        updateCursorInfo(NaN, NaN);
        canvas.style.cursor = 'not-allowed';
        tooltip.style.display = 'none';
        return;
    }
    const dP = inverseTransformCoord(cX, cY);
    currentMousePos = { x: dP.x, y: dP.y };
    updateCursorInfo(dP.x, dP.y);

    if (!isMovingPoint) snappedToPointVisual = null;

    if (isMovingPoint || (isDrawingMode && isDrawingActive) || rulerMode) {
        let targetPoint = { x: currentMousePos.x, y: currentMousePos.y };
        const snapRadiusDataSq = (SNAP_RADIUS_SCREEN / scale) ** 2;
        let bestSnapDistSq = snapRadiusDataSq;
        let foundSnap = false;

        for (const snapObj of userObjects) {
            if (!snapObj.contours) continue;
            for (const snapContour of snapObj.contours) {
                if (!snapContour) continue;
                for (let i = 0; i < snapContour.length; i++) {
                    const snapCandidatePt = snapContour[i];
                    if (isMovingPoint && movedPointInfo &&
                        snapObj === userObjects[movedPointInfo.objectIndex] &&
                        snapContour === userObjects[movedPointInfo.objectIndex].contours[movedPointInfo.contourIndex] &&
                        i === movedPointInfo.pointIndex) {
                        continue;
                    }
                    const distSq = (dP.x - snapCandidatePt.x) ** 2 + (dP.y - snapCandidatePt.y) ** 2;
                    if (distSq < bestSnapDistSq) {
                        bestSnapDistSq = distSq;
                        targetPoint = { x: snapCandidatePt.x, y: snapCandidatePt.y };
                        snappedToPointVisual = { ...targetPoint };
                        foundSnap = true;
                    }
                }
            }
        }

        if (foundSnap) {
            currentMousePos = targetPoint;
        }

        if (isMovingPoint && movedPointInfo) {
            const objToUpdate = userObjects[movedPointInfo.objectIndex];
            const contourToUpdate = objToUpdate.contours[movedPointInfo.contourIndex];
            const pointToUpdate = contourToUpdate[movedPointInfo.pointIndex];

            pointToUpdate.x = targetPoint.x;
            pointToUpdate.y = targetPoint.y;

            if (objToUpdate.type === 'polygon' && contourToUpdate.length > 1) {
                const lastIndex = contourToUpdate.length - 1;
                if (movedPointInfo.pointIndex === 0) {
                    const lastPoint = contourToUpdate[lastIndex];
                    if (lastPoint) { lastPoint.x = targetPoint.x; lastPoint.y = targetPoint.y; }
                } else if (movedPointInfo.pointIndex === lastIndex) {
                    const firstPoint = contourToUpdate[0];
                    if (firstPoint) { firstPoint.x = targetPoint.x; firstPoint.y = targetPoint.y; }
                }
            }

            updateObjectMetrics(objToUpdate);
            if (movedPointInfo.objectIndex === selectedObjectIndex && objToUpdate.type === 'polygon' && movedPointInfo.originalArea !== undefined) {
                const areaSpan = document.querySelector('#selectedObjectInfo .info-item[data-label="Площадь (кв. м)"] span:last-child');
                if (areaSpan) {
                    const newArea = objToUpdate.area;
                    const originalArea = movedPointInfo.originalArea;
                    const diff = newArea - originalArea;
                    const diffSign = diff > 0 ? '+' : '';
                    const diffColor = diff > 0 ? '#27ae60' : (diff < 0 ? '#e74c3c' : '#7f8c8d');
                    areaSpan.innerHTML = `${originalArea.toFixed(2)} &rarr; <strong>${newArea.toFixed(2)}</strong> <span style="font-size: 0.9em; color: ${diffColor};">(${diffSign}${diff.toFixed(2)})</span>`;
                }
            }
            redraw(true);
            return;
        }
    }

    if (isDragging) {
        offsetX = lastOffsetX + (e.clientX - startX);
        offsetY = lastOffsetY - (e.clientY - startY);
        redraw(true);
        tooltip.style.display = 'none';
    } else {
        let hObjArea = false;
        let hPointInfo = null;
        let hSegment = false;

        const hoverPointRadiusDataSq = (GRAB_POINT_RADIUS_SCREEN / scale) ** 2;
        let minPtDistSq = hoverPointRadiusDataSq;

       if (!rulerMode && !isDrawingActive && !isGeometryEditMode && isFinite(dP.x) && isFinite(dP.y)) {
            for (let i = userObjects.length - 1; i >= 0; i--) {
                const o = userObjects[i];
                // --- ДОБАВИТЬ ЭТУ СТРОКУ ---
                if (o.visible === false) continue; 
                // ---------------------------
                if (o?.type === 'polygon' && o.contours?.[0] && isPointInPolygon(dP, o.contours[0])) {
                    hObjArea = true; break;
                }
            }
        }
        if ((showPoints || adjacentPointsMode) && isFinite(dP.x) && isFinite(dP.y)) {
            for (let i = userObjects.length - 1; i >= 0; i--) {
                const o = userObjects[i];
                if (!o?.contours || o.type === 'point') continue;
              
                if (o.visible === false) continue;
                if (isGeometryEditMode && editingObjectIndex !== -1 && i !== editingObjectIndex) continue;

                
                if (adjacentPointsMode && !adjacentObjectIndices.has(i)) continue;
           
                if (!adjacentPointsMode && !showPoints) continue;

                for (let cIdx = 0; cIdx < o.contours.length; cIdx++) {
                    const c = o.contours[cIdx]; if (!c) continue;
                    for (let pIdx = 0; pIdx < c.length; pIdx++) {
                        const p = c[pIdx];
                        if (p && isFinite(p.x) && isFinite(p.y)) {
                            const dx = p.x - dP.x; const dy = p.y - dP.y;
                            const distanceSq = dx * dx + dy * dy;
                            if (distanceSq < minPtDistSq) {
                                minPtDistSq = distanceSq;
                                hPointInfo = { point: p, objectIndex: i, contourIndex: cIdx, pointInContourIndex: pIdx };
                            }
                        }
                    }
                }
            }
        }
        if (isGeometryEditMode && editingObjectIndex !== -1 && !hPointInfo) {
            const obj = userObjects[editingObjectIndex];
            if (obj && obj.contours) {
                const addPointThresholdDataSq = (ADD_POINT_THRESHOLD_SCREEN / scale) ** 2;
                obj.contours.forEach(contour => {
                    if (!contour || contour.length < (obj.type === 'line' ? 1 : 2)) return;
                    const numSegments = obj.type === 'polygon' ? contour.length : contour.length - 1;
                    if (numSegments < 1 && obj.type !== 'point') return;

                    for (let sIdx = 0; sIdx < numSegments; sIdx++) {
                        const p1 = contour[sIdx];
                        const p2 = contour[(sIdx + 1) % (obj.type === 'polygon' ? contour.length : Infinity)];
                        if (!p2 && obj.type === 'line' && sIdx === contour.length - 1) continue;
                        const closestPtOnSeg = getClosestPointOnSegment(dP, p1, p2);
                        const distSq = (dP.x - closestPtOnSeg.x) ** 2 + (dP.y - closestPtOnSeg.y) ** 2;
                        if (distSq < addPointThresholdDataSq) {
                            hSegment = true; break;
                        }
                    }
                    if (hSegment) return;
                });
            }
        }

      if (hPointInfo) {
            const hPt = hPointInfo.point; let tooltipText = ''; let sequentialIndex = -1;
            if (selectedObjectIndex !== -1 && hPointInfo.objectIndex === selectedObjectIndex) {
                const selObj = userObjects[selectedObjectIndex];
                if (selObj && selObj.contours) {
                    let counter = 1; let found = false;
                    for (let cIdx = 0; cIdx < selObj.contours.length; cIdx++) {
                        const contour = selObj.contours[cIdx]; if (!contour) continue;
                        
                        // Запоминаем номер первой точки текущего контура, чтобы присвоить его замыкающей точке
                        let contourStartId = counter;

                        for (let pIdx = 0; pIdx < contour.length; pIdx++) {
                            const pt = contour[pIdx]; if (!pt || !isFinite(pt.x) || !isFinite(pt.y)) continue;
                            
                            // Проверка: является ли точка замыкающей (дубликат первой точки контура)
                            let isClosingDuplicate = false;
                            if (selObj.type === 'polygon' && pIdx === contour.length - 1 && contour.length > 1) {
                                const firstPt = contour[0];
                                const PRECISION_THRESHOLD = 0.001;
                                if (Math.abs(pt.x - firstPt.x) < PRECISION_THRESHOLD && Math.abs(pt.y - firstPt.y) < PRECISION_THRESHOLD) {
                                    isClosingDuplicate = true;
                                }
                            }

                            if (cIdx === hPointInfo.contourIndex && pIdx === hPointInfo.pointInContourIndex) {
                                // Если навели на замыкающую точку, показываем номер начала контура, иначе текущий счетчик
                                sequentialIndex = isClosingDuplicate ? contourStartId : counter;
                                found = true; break;
                            }
                            
                            // Увеличиваем общий счетчик только если точка НЕ является замыкающей дубликатом
                            // Это синхронизирует нумерацию с таблицей
                            if (!isClosingDuplicate) {
                                counter++;
                            }
                        }
                        
                        if (found) break;

                        // Сброс счетчика для неполигональных объектов (линий/точек), если нужно соответствовать логике таблицы
                        if (selObj.type !== 'polygon') counter = 1;
                    }
                }
            }
            tooltipText = sequentialIndex !== -1 ? `№: ${sequentialIndex}\nX: ${hPt.x.toFixed(2)}\nY: ${hPt.y.toFixed(2)}` : `X: ${hPt.x.toFixed(2)}\nY: ${hPt.y.toFixed(2)}`;
            if (isGeometryEditMode && hPointInfo.objectIndex === editingObjectIndex && hPointInfo.point) {
                tooltipText += "\n(ПКМ для удаления)";
            }
            const pointState = getPointState(hPt, hPointInfo.objectIndex);
            let tooltipColor = 'rgba(52, 152, 219, 0.85)';
            if (pointState.isCoincident) tooltipColor = 'rgba(46, 204, 113, 0.85)';
            else if (pointState.isInsideOther) tooltipColor = 'rgba(231, 76, 60, 0.85)';
            tooltip.style.backgroundColor = tooltipColor; tooltip.style.color = 'white';
            tooltip.style.display = 'block'; tooltip.textContent = tooltipText;
            tooltip.style.left = `${e.clientX + 10}px`; tooltip.style.top = `${e.clientY + 10}px`;
            tooltip.style.whiteSpace = 'pre';
        } else {
            tooltip.style.display = 'none';
        }

        canvas.classList.remove('geometry-edit-mode-hover-point', 'geometry-edit-mode-add');

        if (isDrawingActive) canvas.style.cursor = 'crosshair';
        else if (rulerMode) canvas.style.cursor = 'crosshair';
        else if (isGeometryEditMode && editingObjectIndex !== -1) {
            if (hPointInfo && hPointInfo.objectIndex === editingObjectIndex) {
                canvas.classList.add('geometry-edit-mode-hover-point');
                canvas.style.cursor = '';
            } else if (hSegment) {
                canvas.classList.add('geometry-edit-mode-add');
                canvas.style.cursor = '';
            }
            else canvas.style.cursor = 'default';
        }
        else if (hPointInfo || hObjArea) canvas.style.cursor = 'pointer';
        else canvas.style.cursor = 'grab';

        if (isDrawingActive || isGeometryEditMode || rulerMode) redraw(true);
    }
}

function handleMouseOut() {
    if (isDragging) {
        isDragging = false;
        if (!isDrawingMode && !isMovingPoint && !rulerMode && !isGeometryEditMode) canvas.style.cursor = 'grab';
        saveState();
    }
    tooltip.style.display = 'none';
    snappedToPointVisual = null;
    if (isDrawingActive && currentDrawingPoints.length > 0) {
        currentMousePos = currentDrawingPoints[currentDrawingPoints.length-1] || {x:NaN, y:NaN};
        redraw(true);
    }
    updateCursorInfo(NaN, NaN);
}
    
async function deleteAllObjects() {
        if (userObjects.length === 0) {
            showNotification("Список объектов уже пуст.", "info", "info-circle");
            return;
        }

        // ЗАМЕНА confirm НА showCustomConfirm
        const confirmed = await showCustomConfirm(
            "Очистить карту", 
            `Вы уверены, что хотите удалить ВСЕ объекты (${userObjects.length} шт.)? Это действие необратимо.`
        );

        if (confirmed) {
            // Сброс всех состояний
            userObjects = [];
            selectedObjectIndex = -1;
            if(isGeometryEditMode) {
                deactivateGeometryEditMode(false);
            }
            editingObjectIndex = -1;
            geometryHistory = [];
            nextObjectId = 1;
            nextColorIndex = 0;

            displayObjectInfo(-1);
            updateObjectList();
            updateToggleButtonStates();
            
            saveState();
            redraw(false);
            showNotification("Все объекты удалены.", "success", "trash-alt");
        }
    }
    
    function hideAllObjects() {
        if (userObjects.length === 0) return;

        // 1. Проверяем, есть ли хотя бы один ВИДИМЫЙ объект
        // Если есть видимые -> значит действие "Скрыть все"
        // Если ВСЕ скрыты -> значит действие "Показать все"
        const hasVisible = userObjects.some(obj => obj.visible !== false);
        const btnIcon = document.querySelector('#hideAllObjectsBtn i');

        let msg = "";
        let iconClass = "";

        if (hasVisible) {
            // ДЕЙСТВИЕ: СКРЫТЬ ВСЕ
            userObjects.forEach(obj => obj.visible = false);
            
            // Сброс выбора, если скрыли выбранный
            if (selectedObjectIndex !== -1) {
                selectedObjectIndex = -1;
                displayObjectInfo(-1);
                if (isGeometryEditMode) deactivateGeometryEditMode(false);
            }
            
            msg = "Все объекты скрыты.";
            iconClass = "eye-slash";
            if(btnIcon) btnIcon.className = "fas fa-eye"; // Меняем иконку кнопки на "Показать"
            if(document.getElementById('hideAllObjectsBtn')) document.getElementById('hideAllObjectsBtn').title = "Показать все объекты";

        } else {
            // ДЕЙСТВИЕ: ПОКАЗАТЬ ВСЕ
            userObjects.forEach(obj => obj.visible = true);
            
            msg = "Все объекты показаны.";
            iconClass = "eye";
            if(btnIcon) btnIcon.className = "fas fa-eye-slash"; // Меняем иконку кнопки на "Скрыть"
            if(document.getElementById('hideAllObjectsBtn')) document.getElementById('hideAllObjectsBtn').title = "Скрыть все объекты";
        }

        updateObjectList(); 
        redraw(true);       
        saveState();
        showNotification(msg, "info", iconClass);
    }
    
 function handleMouseUp(e) {
        const wasMovingPoint = isMovingPoint;

        if (isMovingPoint) {
            isMovingPoint = false;
            snappedToPointVisual = null;
            canvas.classList.remove('editing-point-mode');
            updateObjectMetrics(userObjects[movedPointInfo.objectIndex]);
            if (movedPointInfo.objectIndex === selectedObjectIndex) {
                 displayObjectInfo(selectedObjectIndex); // <-- Эта строка восстановит нормальное отображение панели
            }
            movedPointInfo = null;
            saveState();
            redraw(true);
            window.lastPointMoveEndTime = Date.now();
        } else if (isDragging) {
            isDragging = false;
            saveState();
        }

        if (!rulerMode && !isDrawingMode && !isGeometryEditMode && !isMovingPoint) {
            canvas.style.cursor = 'grab';
        }
    }

    function handleWheel(e) {
        if ((isDrawingMode && isDrawingActive) || isMovingPoint) {
            e.preventDefault(); return;
        }
        e.preventDefault();
        if (!hasValidView()) { calculateBounds(); resetView(); if (!hasValidView()) return; }

        const zoomFactor = 1.1;
        const zoomDir = e.deltaY < 0 ? zoomFactor : 1 / zoomFactor;

        const rect = canvas.getBoundingClientRect();
        const mouseCX = e.clientX - rect.left; const mouseCY = e.clientY - rect.top;
        const dataMouseBefore = inverseTransformCoord(mouseCX, mouseCY);
        if (!isFinite(dataMouseBefore.x) || !isFinite(dataMouseBefore.y)) return;

        const newScale = scale * zoomDir;
        const minScale = 1e-9, maxScale = 10000;
        if (newScale < minScale || newScale > maxScale) return;
        scale = newScale;

        offsetX = mouseCX - (dataMouseBefore.y - cMinYGlob()) * scale;
        offsetY = canvas.height - mouseCY - (dataMouseBefore.x - cMinXGlob()) * scale;

        if (!hasValidView()) resetView();
        redraw(true); updateViewInfo(); saveState();
    }

    function getClosestPointOnSegment(p, a, b) {
        const abx = b.x - a.x;
        const aby = b.y - a.y;
        const apx = p.x - a.x;
        const apy = p.y - a.y;

        const ab_ab = abx * abx + aby * aby;
        if (ab_ab === 0) return { x: a.x, y: a.y };

        let t = (apx * abx + apy * aby) / ab_ab;
        t = Math.max(0, Math.min(1, t));

        return {
            x: roundCoord(a.x + t * abx),
            y: roundCoord(a.y + t * aby)
        };
    }


function handleClick(e) {
    if (e.button !== 0) return;

    const timeSinceLastPointMoveEnd = Date.now() - (window.lastPointMoveEndTime || 0);
    if (timeSinceLastPointMoveEnd < 50) {
        return;
    }

    if (e.detail > 1) return;
    if (!hasValidView()) return;

    const r = canvas.getBoundingClientRect();
    const cX = e.clientX - r.left;
    const cY = e.clientY - r.top;
    const dP = inverseTransformCoord(cX, cY);
    if (!isFinite(dP.x) || !isFinite(dP.y)) return;

    if (isDrawingMode && isDrawingActive) {
        const pointToAdd = snappedToPointVisual
            ? { x: snappedToPointVisual.x, y: snappedToPointVisual.y }
            : { x: dP.x, y: dP.y };
        currentDrawingPoints.push(pointToAdd);
        redraw(true);
    } else if (rulerMode) {
        if (rulerPoints.length < 2) {
            const pointToAdd = snappedToPointVisual
                ? { x: snappedToPointVisual.x, y: snappedToPointVisual.y }
                : { x: dP.x, y: dP.y };
            rulerPoints.push(pointToAdd);
            updateMeasurementPanel();
            redraw(true);
            if (rulerPoints.length === 2) {
                const dist = calculateDistance(rulerPoints[0], rulerPoints[1]);
                if (isFinite(dist)) showNotification(`Расстояние: ${dist.toFixed(2)} м`, "success", "ruler");
                else showNotification(`Не удалось измерить`, "error");
            }
        }
    } else if (isGeometryEditMode && editingObjectIndex !== -1 && !e.altKey) {
        const obj = userObjects[editingObjectIndex];
        if (!obj || !obj.contours) return;

        let bestMatch = { distSq: Infinity, contourIndex: -1, segmentIndex: -1, newPoint: null };
        const clickThresholdDataSq = (ADD_POINT_THRESHOLD_SCREEN / scale) ** 2;

        obj.contours.forEach((contour, cIdx) => {
            if (!contour || contour.length < (obj.type === 'line' ? 1 : 2)) return;
            const numSegments = obj.type === 'polygon' ? contour.length : contour.length - 1;
            if (numSegments < 1 && obj.type !== 'point') return;

            for (let sIdx = 0; sIdx < numSegments; sIdx++) {
                const p1 = contour[sIdx];
                const p2 = contour[(sIdx + 1) % (obj.type === 'polygon' ? contour.length : Infinity)];
                if (!p2 && obj.type === 'line' && sIdx === contour.length - 1) continue;

                const closestPtOnSeg = getClosestPointOnSegment(dP, p1, p2);
                const distSq = (dP.x - closestPtOnSeg.x) ** 2 + (dP.y - closestPtOnSeg.y) ** 2;

                if (distSq < bestMatch.distSq && distSq < clickThresholdDataSq) {
                    bestMatch = {
                        distSq, contourIndex: cIdx, segmentIndex: sIdx,
                        newPoint: closestPtOnSeg
                    };
                }
            }
        });

        if (bestMatch.newPoint) {
            saveGeometryStateForUndo(editingObjectIndex);
            const contourToModify = userObjects[editingObjectIndex].contours[bestMatch.contourIndex];
            contourToModify.splice(bestMatch.segmentIndex + 1, 0, bestMatch.newPoint);
            updateObjectMetrics(userObjects[editingObjectIndex]);
            displayObjectInfo(editingObjectIndex);
            showNotification("Точка добавлена на сегмент.", "success", "plus-circle");
            redraw(true);
            saveState();
            return;
        }
    }
}

async function handleContextMenu(e) {
        e.preventDefault();
        if (!isGeometryEditMode || editingObjectIndex === -1) return;

        const r = canvas.getBoundingClientRect();
        const cX = e.clientX - r.left; const cY = e.clientY - r.top;
        const clickDataPoint = inverseTransformCoord(cX, cY);

        const obj = userObjects[editingObjectIndex];
        if (!obj || !obj.contours) return;

        const grabRadiusDataSq = (GRAB_POINT_RADIUS_SCREEN / scale) ** 2;
        let pointToDeleteInfo = null;

        for (let cIdx = 0; cIdx < obj.contours.length; cIdx++) {
            const contour = obj.contours[cIdx];
            if (!contour) continue;
            const minPoints = obj.type === 'polygon' ? 3 : (obj.type === 'line' ? 2 : Infinity);

            for (let pIdx = 0; pIdx < contour.length; pIdx++) {
                const point = contour[pIdx];
                if (!point || !isFinite(point.x) || !isFinite(point.y)) continue;
                const distSq = (clickDataPoint.x - point.x)**2 + (clickDataPoint.y - point.y)**2;
                if (distSq < grabRadiusDataSq) {
                    if (contour.length > minPoints) {
                        pointToDeleteInfo = { contourIndex: cIdx, pointIndex: pIdx, object: obj };
                    } else {
                        showNotification(`Нельзя удалить вершину: минимум ${minPoints} вершин.`, "warning", "ban");
                        return;
                    }
                    break;
                }
            }
            if (pointToDeleteInfo) break;
        }

        if (pointToDeleteInfo) {
            // ЗАМЕНА confirm НА showCustomConfirm
            const confirmed = await showCustomConfirm(
                "Удаление вершины",
                "Удалить выбранную вершину?"
            );

            if (confirmed) {
                saveGeometryStateForUndo(editingObjectIndex);
                const contourToModify = pointToDeleteInfo.object.contours[pointToDeleteInfo.contourIndex];
                contourToModify.splice(pointToDeleteInfo.pointIndex, 1);
                updateObjectMetrics(pointToDeleteInfo.object);
                displayObjectInfo(editingObjectIndex);
                showNotification("Вершина удалена.", "info", "trash-alt");
                redraw(true);
                saveState();
            }
        }
    }



 function handleUnionSelection(point) {
        let clickedIdx = -1;
        for (let i = userObjects.length - 1; i >= 0; i--) {
            const obj = userObjects[i];
            if (obj && obj.type === 'polygon' && obj.contours) {
                const hits = obj.contours.some(c => isPointInPolygon(point, c));
                if (hits) {
                    clickedIdx = i;
                    break;
                }
            }
        }

        if (clickedIdx === -1) return;

        if (unionTargetIndex === -1) {
            unionTargetIndex = clickedIdx;
            const objName = userObjects[clickedIdx].name || `Объект ${userObjects[clickedIdx].id}`;
            showNotification(`Выбран №1: "${objName}". Двойной клик по смежному объекту.`, "warning", "hand-pointer");
        } else {
            if (clickedIdx === unionTargetIndex) {
                showNotification("Выберите другой объект для объединения.", "error");
                return;
            }
            const targetName = userObjects[unionTargetIndex].name || `Объект ${userObjects[unionTargetIndex].id}`;
            const mergeName = userObjects[clickedIdx].name || `Объект ${userObjects[clickedIdx].id}`;
            
            showNotification(`Объединение "${targetName}" и "${mergeName}"...`, "info", "cog");
            executeUnionOperation(unionTargetIndex, clickedIdx);
            toggleUnionTool();
        }
    }

 function executeUnionOperation(idx1, idx2) {
        const obj1 = userObjects[idx1];
        const obj2 = userObjects[idx2];
        if (!obj1 || !obj2) return;

        if (editingObjectIndex !== idx1) editingObjectIndex = idx1;
        saveGeometryStateForUndo(idx1);

        try {
            ensureClosed(obj1.contours);
            ensureClosed(obj2.contours);

            // 1. Приводим к единой ориентации (по часовой стрелке)
            forceClockwise(obj1.contours);
            forceClockwise(obj2.contours);

            // Работаем с копиями
            let currentUnionList = deepCloneContours(obj1.contours);
            const poly2 = deepCloneContours(obj2.contours);

            // ШАГ 1: Вливаем второй объект (или его части) в список контуров первого объекта
            poly2.forEach(ring2 => {
                if (ring2.length < 3) return;
                
                // Добавляем контур второго объекта в общий список
                currentUnionList.push(ring2);
            });

            // ШАГ 2: Рекурсивное самообъединение (SELF-UNION / MERGE)
            // Мы "трясем" список контуров, пока они перестанут слипаться друг с другом.
            // Это решает проблему "моста", когда добавленный кусок соединяет два ранее разрозненных контура.
            let changed = true;
            let iterations = 0;
            const MAX_ITERATIONS = 50; // Защита от вечного цикла

            while (changed && iterations < MAX_ITERATIONS) {
                changed = false;
                iterations++;

                for (let i = 0; i < currentUnionList.length; i++) {
                    for (let j = i + 1; j < currentUnionList.length; j++) {
                        const c1 = currentUnionList[i];
                        const c2 = currentUnionList[j];

                        // Пробуем объединить пару
                        const unionRes = computeUnion(c1, c2);

                        // Если результат - ОДИН контур, значит произошло слияние
                        if (unionRes.length === 1) {
                            // Заменяем c1 на результат объединения
                            currentUnionList[i] = unionRes[0];
                            // Удаляем c2 из списка
                            currentUnionList.splice(j, 1);
                            
                            changed = true;
                            // Прерываем внутренний цикл, чтобы начать проход заново с новым контуром
                            break; 
                        }
                    }
                    if (changed) break; // Прерываем внешний цикл, начинаем заново while
                }
            }

            // ШАГ 3: Финальная очистка (удаление вложенных мусорных контуров)
            const finalCleanedList = [];
            // Сортируем по площади (от больших к меньшим)
            currentUnionList.sort((a, b) => calculatePolygonArea(b) - calculatePolygonArea(a));
            
            currentUnionList.forEach((contour, idx) => {
                let isInsideLarger = false;
                for (let i = 0; i < idx; i++) {
                    // Если контур полностью внутри другого большего контура (и они уже одной ориентации)
                    // значит это артефакт слияния, который не стал дыркой, а остался внутри.
                    if (isPointInPolygonRobust(contour[0], currentUnionList[i], true)) {
                        // Дополнительная проверка: проверяем середину контура, чтобы исключить ложные срабатывания на границах
                        const midIdx = Math.floor(contour.length / 2);
                        if (isPointInPolygonRobust(contour[midIdx], currentUnionList[i], true)) {
                            isInsideLarger = true;
                            break;
                        }
                    }
                }
                if (!isInsideLarger) {
                    finalCleanedList.push(contour);
                }
            });

            obj1.contours = finalCleanedList;
            cleanObjectContours(obj1);
            updateObjectMetrics(obj1);

            // Удаляем второй объект
            userObjects.splice(idx2, 1);
            if (editingObjectIndex > idx2) editingObjectIndex--;
            
            showNotification("Объекты объединены в единый контур.", "success", "object-group");
            
            displayObjectInfo(editingObjectIndex);
            updateObjectList();
            redraw(true);

        } catch (e) {
            console.error("UNION ERROR:", e);
            showNotification("Ошибка объединения: " + e.message, "error");
        }
    }

    function computeUnion(subject, clipper) {
        const intersections = findIntersectionsRobust(subject, clipper);
        
        // Если пересечений нет
        if (intersections.length === 0) {
            // Если clipper внутри subject -> результат subject (clipper поглощен)
            if (isPointInPolygonRobust(clipper[0], subject, true)) return [subject]; 
            // Если subject внутри clipper -> результат clipper (subject поглощен)
            if (isPointInPolygonRobust(subject[0], clipper, true)) return [clipper];
            // Иначе они раздельные
            return [subject, clipper]; 
        }

        const subjWithInt = insertPointsAndMark(subject, intersections, true);
        const clipWithInt = insertPointsAndMark(clipper, intersections, false);

        const subjArcs = splitByIntersections(subjWithInt);
        const clipArcs = splitByIntersections(clipWithInt);

        const finalArcs = [];

        // Логика Union:
        // Берем части Subject, которые СНАРУЖИ Clipper
        subjArcs.forEach(arc => {
            const mid = getArcMidpoint(arc);
            // boundaryResult=true означает "включая границу". 
            // !true = false. То есть общая граница удаляется.
            if (!isPointInPolygonRobust(mid, clipper, true)) { 
                finalArcs.push(arc);
            }
        });

        // Берем части Clipper, которые СНАРУЖИ Subject
        clipArcs.forEach(arc => {
            const mid = getArcMidpoint(arc);
            if (!isPointInPolygonRobust(mid, subject, true)) {
                finalArcs.push(arc);
            }
        });

        return stitchArcs(finalArcs);
    }


    function comparePolygons(p1, p2) {
        if (p1.length !== p2.length) return false;
        return p1.every((pt, i) => Math.abs(pt.x - p2[i].x) < 0.001 && Math.abs(pt.y - p2[i].y) < 0.001);
    }
    
    
     function getSignedArea(contour) {
        let area = 0;
        for (let i = 0; i < contour.length; i++) {
            const j = (i + 1) % contour.length;
            area += (contour[i].x * contour[j].y);
            area -= (contour[i].y * contour[j].x);
        }
        return area / 2;
    }

    function forceClockwise(contours) {
        if (!contours) return;
        contours.forEach((contour, idx) => {
            if (!contour || contour.length < 3) return;
            // В системе координат Canvas (Y вниз): 
            // Положительная площадь = По часовой стрелке (CW)
            // Отрицательная площадь = Против часовой стрелки (CCW)
            // Примечание: в математике (Y вверх) наоборот.
            // Здесь предполагаем, что нам нужна "положительная" ориентация для внешних контуров.
            const area = getSignedArea(contour);
            if (area < 0) { // Если против часовой -> разворачиваем
                contours[idx] = contour.reverse();
            }
        });
    }
    
    
function handleDoubleClick(e) {
        e.preventDefault();
        if (!hasValidView()) return;
        const r = canvas.getBoundingClientRect();
        const cX = e.clientX - r.left; const cY = e.clientY - r.top;
        const dP = inverseTransformCoord(cX, cY);
        if (!isFinite(dP.x) || !isFinite(dP.y)) return;

        if (isDrawingMode && isDrawingActive) {
            finishDrawingAsPolygon();
        } 
        else if (isCutToolActive && isGeometryEditMode) {
            handleCutSelection(dP);
        }
        
           else if (isUnionToolActive && isGeometryEditMode) {
            handleUnionSelection(dP);
        }
        
      
        else if (isIntersectToolActive && isGeometryEditMode) {
            handleIntersectSelection(dP);
        }
    
        else if (!rulerMode && !isMovingPoint && !isGeometryEditMode) {
            selectObjectByPoint(dP);
        }
    }
    
      function handleCutSelection(point) {
        // Ищем объект под курсором
        let clickedIdx = -1;
        // Проходим в обратном порядке (сверху вниз)
        for (let i = userObjects.length - 1; i >= 0; i--) {
            const obj = userObjects[i];
            if (obj && obj.type === 'polygon' && obj.contours) {
                // Проверяем попадание в любой из контуров
                const hits = obj.contours.some(c => isPointInPolygon(point, c));
                if (hits) {
                    clickedIdx = i;
                    break;
                }
            }
        }

        if (clickedIdx === -1) return;

        if (cutTargetIndex === -1) {
            // ШАГ 1: Выбор Рассекаемого объекта
            cutTargetIndex = clickedIdx;
            const objName = userObjects[clickedIdx].name || `Объект ${userObjects[clickedIdx].id}`;
            showNotification(`Рассекаемый: "${objName}". Теперь двойной клик по РЕЗАКУ.`, "warning", "crosshairs");
            // Можно добавить визуальное выделение, но пока ограничимся перерисовкой (если добавите логику отрисовки)
        } else {
            // ШАГ 2: Выбор Резака
            if (clickedIdx === cutTargetIndex) {
                showNotification("Резак должен отличаться от рассекаемого объекта.", "error");
                return;
            }
            const cutterName = userObjects[clickedIdx].name || `Объект ${userObjects[clickedIdx].id}`;
            showNotification(`Резак: "${cutterName}". Выполняю разрез...`, "info", "cog");
            
            // Запуск операции
            executeCutOperation(cutTargetIndex, clickedIdx);
            
            // Сброс после операции
            toggleCutTool(); 
        }
    }
    
    

    
    
    
    
    
    
    
    
    

function selectObjectByPoint(dataClickPoint) {
        let clickedIdx = -1; let minArea = Infinity;
        userObjects.forEach((obj, index) => {
            if (!obj || !obj.contours) return;

            // --- НОВОЕ: Игнорируем скрытые объекты при клике ---
            if (obj.visible === false) return;
            // --------------------------------------------------

            let containsPoint = false;
            for (const contour of obj.contours) {
                if (obj.type === 'polygon' && contour && contour.length >= 3 && isPointInPolygon(dataClickPoint, contour)) {
                    containsPoint = true; break;
                }
            }
            if (containsPoint) {
                const area = (obj.area !== undefined && isFinite(obj.area)) ? obj.area : Infinity;
                if (area < minArea) { minArea = area; clickedIdx = index; }
            }
        })
        if (clickedIdx !== -1) {
            if (isGeometryEditMode && editingObjectIndex !== clickedIdx) {
                deactivateGeometryEditMode(false);
            }
            
                if (clickedIdx !== selectedObjectIndex && adjacentPointsMode) {
                // Если кликнули на другой объект, а режим включен -> выключаем или пересчитываем
                // Для простоты - выключаем, чтобы не путать пользователя
                adjacentPointsMode = false;
                adjacentObjectIndices.clear();
                showNotification("Смена объекта: режим смежных точек сброшен.", "info");
            }
            
            selectedObjectIndex = clickedIdx;
            displayObjectInfo(selectedObjectIndex); updateObjectListSelection();
        } else {
            if (!isGeometryEditMode) {
                selectedObjectIndex = -1;
                displayObjectInfo(-1); updateObjectListSelection();
            }
        }
        selectedCoordinate = null;
        redraw(true);
    }
    function centerOnObject(index, adjustZoom = false) {
        if (index < 0 || index >= userObjects.length || !userObjects[index]) return;
        const obj = userObjects[index];
        if (!obj.contours || obj.contours.length === 0 || !obj.contours[0] || obj.contours[0].length === 0) {
            showNotification("Невозможно центрировать: нет валидных координат.", "warning", "exclamation-triangle"); return;
        };
        let oMinX = Infinity, oMinY = Infinity, oMaxX = -Infinity, oMaxY = -Infinity, hasPts = false;
        obj.contours.forEach(c => {
            if (!c) return;
            c.forEach(p => {
                if (p && isFinite(p.x) && isFinite(p.y)) {
                    oMinX = Math.min(oMinX, p.x); oMinY = Math.min(oMinY, p.y);
                    oMaxX = Math.max(oMaxX, p.x); oMaxY = Math.max(oMaxY, p.y);
                    hasPts = true;
                }
            });
        });
        if (!hasPts) {
            showNotification("Невозможно центрировать: координаты объекта невалидны.", "error", "exclamation-circle"); return;
        }
        const oW = Math.max(1e-6, oMaxX - oMinX); const oH = Math.max(1e-6, oMaxY - oMinY);
        const oCX = oMinX + oW / 2; const oCY = oMinY + oH / 2;
        const cW = canvas.width || 100; const cH = canvas.height || 100;
        calculateBounds();
        if (adjustZoom) {
            const sX = cW / oW * 0.8; const sY = cH / oH * 0.8;
            let nS = Math.min(sX, sY);
            nS = Math.max(1e-9, Math.min(nS, 10000));
            if (!isFinite(nS) || nS <= 0) nS = scale; scale = nS;
        }
        offsetX = cW / 2 - (roundCoord(oCY) - cMinYGlob()) * scale;
        offsetY = cH / 2 - (roundCoord(oCX) - cMinXGlob()) * scale;
        if (!hasValidView()) resetView();
        updateViewInfo(); redraw(true); saveState();
        if (!adjustZoom) showNotification(`Центрировано на "${obj.name || `Объект ${obj.id}`}"`, "info", "crosshairs");
    }
   
     function addInfoItem(label, value, isCopyable = false, objectIndex = -1) {
        let displayValue = 'Н/Д';
        if (value !== undefined && value !== null) {
            if (typeof value === 'number' && isFinite(value)) {
                displayValue = value.toFixed(2);
            } else if (typeof value === 'string') {
                displayValue = value;
            } else if (typeof value === 'number') {
                 displayValue = 'Не число';
            }
        }
        const itemDiv = document.createElement('div');
        itemDiv.className = 'info-item';
        itemDiv.dataset.label = label; // <-- ДОБАВЛЕНО: Уникальный идентификатор для элемента
        const labelSpan = document.createElement('span');
        labelSpan.textContent = label;
        const valueSpan = document.createElement('span');
        valueSpan.textContent = displayValue;
        if (label === 'Цвет' && value !== 'Н/Д' && objectIndex !== -1) {
            valueSpan.classList.add('color-picker-trigger'); valueSpan.title = 'Кликните для выбора цвета';
            valueSpan.style.cursor = 'pointer'; valueSpan.style.fontWeight = 'bold';
            const colorSwatch = document.createElement('span');
            colorSwatch.style.display = 'inline-block'; colorSwatch.style.width = '12px'; colorSwatch.style.height = '12px';
            colorSwatch.style.backgroundColor = value; colorSwatch.style.border = '1px solid #ccc';
            colorSwatch.style.marginRight = '5px'; colorSwatch.style.verticalAlign = 'middle';
            valueSpan.prepend(colorSwatch);
        } else if (isCopyable && displayValue !== 'Н/Д' && displayValue !== 'Не число') {
            valueSpan.classList.add('copyable'); valueSpan.title = 'Двойной клик для копирования';
            valueSpan.ondblclick = (e) => {
                e.stopPropagation(); copyToClipboard(value.toString());
                valueSpan.classList.add('flash'); setTimeout(() => valueSpan.classList.remove('flash'), 500);
            };
        }
        itemDiv.appendChild(labelSpan); itemDiv.appendChild(valueSpan);
        selectedObjectInfoDiv.appendChild(itemDiv); return itemDiv;
    }
    
    
    function displayObjectInfo(index) {
        selectedObjectIndex = index;
        if (isGeometryEditMode && editingObjectIndex !== selectedObjectIndex) {
            deactivateGeometryEditMode(false);
        }

        selectedObjectInfoDiv.innerHTML = ''; coordinatesTableContainer.innerHTML = '';
        intersectionList.innerHTML = ''; intersectionsTitle.style.display = 'none';

        if (index < 0 || index >= userObjects.length || !userObjects[index]) {
            selectedObjectInfoDiv.innerHTML = '<p style="color: #777; font-style: italic; text-align: center;">Объект не выбран.</p>';
            updateObjectListSelection(); return;
        }
        const obj = userObjects[index];
        const nameContainer = document.createElement('div'); nameContainer.style.marginBottom = '10px';
        const nameLabel = document.createElement('h3'); nameLabel.textContent = obj.name || `Объект ${obj.id}`;
        nameLabel.title = "Кликните для переименования"; nameLabel.onclick = () => handleRenameRequest(index);
        nameContainer.appendChild(nameLabel); selectedObjectInfoDiv.appendChild(nameContainer);

        const pointCount = (obj.contours || []).reduce((sum, c) => sum + (c ? c.length : 0), 0);
        let typeDisplay = 'Н/Д';
        if (obj.type === 'polygon') typeDisplay = 'Полигон';
        else if (obj.type === 'line') typeDisplay = 'Линия';
        else if (obj.type === 'point') typeDisplay = 'Точка';

        addInfoItem('ID', obj.id); addInfoItem('Тип', typeDisplay);
        addInfoItem('Цвет', obj.color || 'Н/Д', false, index);
        addInfoItem(obj.type === 'line' ? 'Длина (м)' : 'Периметр (м)', obj.perimeter);
        addInfoItem('Площадь (кв. м)', obj.type === 'polygon' && obj.area > 1e-9 ? obj.area : 0);
        addInfoItem('Контуры', (obj.contours || []).length); addInfoItem('Точки', pointCount);

        const colorValueSpan = selectedObjectInfoDiv.querySelector('.color-picker-trigger');
        if (colorValueSpan) {
             colorValueSpan.onclick = (e) => {
                 e.stopPropagation();
                 if (index < 0 || index >= userObjects.length || !userObjects[index]) return;
                 const currentColor = userObjects[index].color || '#000000';
                 const colorInput = document.createElement('input');
                 colorInput.type = 'color'; colorInput.value = currentColor;
                 colorInput.style.position = 'absolute'; colorInput.style.left = '-9999px'; colorInput.style.top = '-9999px';
                 colorInput.onchange = (event) => {
                     const newColor = event.target.value; userObjects[index].color = newColor;
                     colorValueSpan.textContent = newColor;
                     const colorSwatch = colorValueSpan.querySelector('span');
                     if (colorSwatch) colorSwatch.style.backgroundColor = newColor;
                     else {
                           const newSwatch = document.createElement('span');
                           newSwatch.style.display = 'inline-block'; newSwatch.style.width = '12px'; newSwatch.style.height = '12px';
                           newSwatch.style.backgroundColor = newColor; newSwatch.style.border = '1px solid #ccc';
                           newSwatch.style.marginRight = '5px'; newSwatch.style.verticalAlign = 'middle';
                           colorValueSpan.prepend(newSwatch);
                     }
                     updateObjectListColorIndicator(index, newColor); redraw(true); saveState();
                     showNotification(`Цвет объекта "${obj.name || obj.id}" изменен на ${newColor}`, 'success', 'palette');
                     document.body.removeChild(colorInput);
                 };
                 document.body.appendChild(colorInput); colorInput.click();
                 colorInput.onblur = () => { setTimeout(() => { if (colorInput.parentNode === document.body) document.body.removeChild(colorInput); }, 100); };
            };
        }
        const btnContainer = document.createElement('div'); btnContainer.style.marginTop = '15px';
        const showCoordsBtn = document.createElement('button'); showCoordsBtn.id = 'showCoordinatesBtn'; showCoordsBtn.className = 'panel-button'; showCoordsBtn.innerHTML = '<i class="fas fa-list-ol"></i> Координаты'; showCoordsBtn.onclick = () => toggleCoordinatesTable(index); btnContainer.appendChild(showCoordsBtn);
        
              const schemaBtn = document.createElement('button'); 
        schemaBtn.id = 'openSchemaBtn'; 
        schemaBtn.className = 'panel-button'; 
        schemaBtn.innerHTML = '<i class="fas fa-map"></i> Схема'; 
        schemaBtn.title = 'Скопировать координаты и открыть схему';
        schemaBtn.onclick = () => {
            handleCopyAllCoordinates(index); 
            window.open('схема.html', '_blank'); 
        };
        btnContainer.appendChild(schemaBtn);
        
        const copyAllCoordsBtn = document.createElement('button'); copyAllCoordsBtn.id = 'copyAllCoordinatesBtn'; copyAllCoordsBtn.className = 'panel-button'; copyAllCoordsBtn.innerHTML = '<i class="fas fa-copy"></i> Копировать'; copyAllCoordsBtn.title = 'Скопировать все координаты объекта (X\tY)'; copyAllCoordsBtn.onclick = () => handleCopyAllCoordinates(index); btnContainer.appendChild(copyAllCoordsBtn);
        const centerBtn = document.createElement('button'); centerBtn.id = 'centerObjectBtn'; centerBtn.className = 'panel-button'; centerBtn.innerHTML = '<i class="fas fa-crosshairs"></i> Центрировать'; centerBtn.onclick = () => centerOnObject(index, false); btnContainer.appendChild(centerBtn);
        const renameBtn = document.createElement('button'); renameBtn.id = 'renameObjectBtn'; renameBtn.className = 'panel-button'; renameBtn.innerHTML = '<i class="fas fa-pencil-alt"></i> Переименовать'; renameBtn.onclick = () => handleRenameRequest(index); btnContainer.appendChild(renameBtn);
        const deleteBtn = document.createElement('button'); deleteBtn.id = 'deleteObjectBtn'; deleteBtn.className = 'panel-button'; deleteBtn.innerHTML = '<i class="fas fa-trash-alt"></i> Удалить'; deleteBtn.onclick = () => deleteObject(index); btnContainer.appendChild(deleteBtn);
        selectedObjectInfoDiv.appendChild(btnContainer);

        calculateAndDisplayIntersections(index); updateObjectListSelection();
    }
    function handleCopyAllCoordinates(objectIndex) {
        if (objectIndex < 0 || objectIndex >= userObjects.length || !userObjects[objectIndex]) {
            showNotification("Объект не выбран или невалиден.", "error", "exclamation-circle"); return;
        }
        const obj = userObjects[objectIndex];
        if (!obj.contours || obj.contours.length === 0) {
            showNotification("У объекта нет координат для копирования.", "warning", "exclamation-triangle"); return;
        }
        let allCoordsString = "";
        obj.contours.forEach((contour, cIdx) => {
            if (!contour) return;
            contour.forEach(point => {
                if (point && isFinite(point.x) && isFinite(point.y)) {
                    allCoordsString += `${point.x.toFixed(2)}\t${point.y.toFixed(2)}\n`;
                }
            });
            if (obj.contours.length > 1 && cIdx < obj.contours.length - 1 && contour.length > 0) {
                 allCoordsString += "\n"; // Add blank line between contours for multi-contour objects
            }
        });
        if (allCoordsString.trim() === "") {
            showNotification("Нет валидных координат для копирования.", "warning", "exclamation-triangle"); return;
        }
        copyToClipboard(allCoordsString.trim());
    }

function toggleCoordinatesTable(index) {
    if (index < 0 || index >= userObjects.length || !userObjects[index]) return;
    const obj = userObjects[index];
    const btn = document.getElementById('showCoordinatesBtn');
    const isVisible = coordinatesTableContainer.querySelector('.coordinates-table') !== null;

    if (isVisible) {
        coordinatesTableContainer.innerHTML = '';
        if (btn) btn.innerHTML = '<i class="fas fa-list-ol"></i> Координаты';
        selectedCoordinate = null;
        redraw(true);
    } else {
        let selectedPointsForTable = [];
        let pointCounter = 1;

        (obj.contours || []).forEach((contour, contourIndex) => {
            if (!contour || contour.length === 0) return;

            let contourCoordsText = "";
            contour.forEach(p => {
                if (p && isFinite(p.x) && isFinite(p.y)) {
                    contourCoordsText += `${p.x.toFixed(2)}\t${p.y.toFixed(2)}\n`;
                }
            });

            let isClosingPointIdenticalToFirstForThisContour = false;

            if (obj.contours.length > 1) {
                selectedPointsForTable.push({
                    isHeader: true,
                    text: `Контур ${contourIndex + 1}`,
                    coordsToCopy: contourCoordsText.trim()
                });
            }

            contour.forEach((point, pIdx) => {
                if (point && isFinite(point.x) && isFinite(point.y)) {
                    let displayPointNumber;
                    let isThisSpecificPointADuplicateCloser = false;

                    if (obj.type === 'polygon' &&
                        pIdx === contour.length - 1 &&
                        contour.length > 1) {

                        const firstPt = contour[0];
                        const PRECISION_THRESHOLD = 0.001;
                        if (Math.abs(point.x - firstPt.x) < PRECISION_THRESHOLD &&
                            Math.abs(point.y - firstPt.y) < PRECISION_THRESHOLD) {
                            displayPointNumber = 1;
                            isThisSpecificPointADuplicateCloser = true;
                            isClosingPointIdenticalToFirstForThisContour = true;
                        } else {
                            displayPointNumber = pointCounter;
                        }
                    } else {
                        displayPointNumber = pointCounter;
                    }

                    selectedPointsForTable.push({
                        contour: contourIndex + 1,
                        point: displayPointNumber,
                        x: point.x,
                        y: point.y,
                        isClosingDuplicate: isThisSpecificPointADuplicateCloser
                    });

                    if (!isThisSpecificPointADuplicateCloser) {
                        pointCounter++;
                    }
                }
            });

            if (obj.type !== 'polygon' || contour.length === 0 || !isClosingPointIdenticalToFirstForThisContour) {
                pointCounter = 1;
            }
        });

        displayCoordinatesTable(selectedPointsForTable);
        if (btn) btn.innerHTML = '<i class="fas fa-times"></i> Скрыть Координаты';
    }
}


 function toggleUnionTool() {
        if (!isGeometryEditMode) return;

        if (isCutToolActive) toggleCutTool();
        if (isIntersectToolActive) toggleIntersectTool();

        isUnionToolActive = !isUnionToolActive;
        const btn = document.getElementById('unionObjectBtn');

        if (isUnionToolActive) {
            btn.classList.add('active');
            unionTargetIndex = -1;
            showNotification("Инструмент «Объединение»: Двойной клик по ПЕРВОМУ объекту.", "info", "object-group");
            canvas.style.cursor = 'crosshair';
        } else {
            btn.classList.remove('active');
            unionTargetIndex = -1;
            showNotification("Инструмент «Объединение» выключен.", "info", "times");
            canvas.style.cursor = 'default';
        }
        redraw(true);
    }

function displayCoordinatesTable(points) {
    if (!points || points.length === 0) {
        coordinatesTableContainer.innerHTML = '<p style="color: #777; font-style: italic; text-align: center; margin-top: 10px;">Нет координат.</p>';
        return;
    }
    let tableHtml = `<table class="coordinates-table"><thead><tr><th>№ п/п</th><th>X</th><th>Y</th></tr></thead><tbody>`;
    points.forEach(point => {
        if (point.isHeader) {
            tableHtml += `<tr>
                <th colspan="3" style="background-color: #e9ecef; text-align: center; vertical-align: middle;">
                    ${point.text}
                    <button class="copy-contour-btn" data-coords="${point.coordsToCopy}" title="Копировать координаты этого контура" style="border: none; background: transparent; cursor: pointer; color: #4a69bd; margin-left: 10px; padding: 2px 6px; transition: color 0.2s;">
                        <i class="fas fa-copy"></i>
                    </button>
                </th>
            </tr>`;
        } else {
            const rowClass = point.isClosingDuplicate ? 'coordinate-row closing-duplicate' : 'coordinate-row';
            tableHtml += `<tr class="${rowClass}" data-x="${point.x}" data-y="${point.y}"><td>${point.point}</td><td class="copyable">${point.x.toFixed(2)}</td><td class="copyable">${point.y.toFixed(2)}</td></tr>`;
        }
    });
    tableHtml += `</tbody></table>`;
    coordinatesTableContainer.innerHTML = tableHtml;

    coordinatesTableContainer.querySelectorAll('.copy-contour-btn').forEach(btn => {
        btn.addEventListener('click', function(e) {
            e.stopPropagation();
            const coords = this.getAttribute('data-coords');
            if (coords) {
                copyToClipboard(coords);
                const originalIcon = this.innerHTML;
                this.innerHTML = '<i class="fas fa-check"></i>';
                setTimeout(() => {
                    this.innerHTML = originalIcon;
                }, 1000);
            }
        });
        btn.addEventListener('mouseenter', function() {
            this.style.color = '#354f9e';
            this.style.transform = 'scale(1.1)';
        });
        btn.addEventListener('mouseleave', function() {
            this.style.color = '#4a69bd';
            this.style.transform = 'scale(1)';
        });
    });

    coordinatesTableContainer.querySelectorAll('.coordinate-row:not(.closing-duplicate):not([data-is-header="true"])').forEach(row => {
        row.querySelectorAll('.copyable').forEach(cell => {
            cell.ondblclick = function(e) {
                e.stopPropagation();
                copyToClipboard(this.textContent);
                this.closest('tr')?.classList.add('flash');
                setTimeout(() => this.closest('tr')?.classList.remove('flash'), 500);
            };
        });
        row.onclick = function() {
            document.querySelectorAll('.coordinate-row.selected-coordinate').forEach(r => r.classList.remove('selected-coordinate'));
            this.classList.add('selected-coordinate');
            const x = parseFloat(this.dataset.x);
            const y = parseFloat(this.dataset.y);
            if (isFinite(x) && isFinite(y)) {
                selectedCoordinate = {
                    x,
                    y
                };
                highlightPointOnMap(x, y);
            } else {
                selectedCoordinate = null;
            }
        };
    });
}


    function highlightPointOnMap(x, y) {
        if (!hasValidView() || !isFinite(x) || !isFinite(y)) return;
        let pulseSize = 8; let pulseOpacity = 1; let animationFrameId = null;
        const pulse = () => {
            redraw(true); if (pulseOpacity <= 0 || !hasValidView()) { window.currentPulseAnimation = null; redraw(true); return; }
            const [cx, cy] = transformCoord(x, y); if (!isFinite(cx) || !isFinite(cy)) { window.currentPulseAnimation = null; return; }
            ctx.save(); ctx.setTransform(1, 0, 0, 1, 0, 0);
            ctx.strokeStyle = `rgba(255, 0, 0, ${pulseOpacity})`; ctx.lineWidth = 2.5;
            ctx.beginPath(); ctx.arc(cx, cy, pulseSize, 0, Math.PI * 2); ctx.stroke();
            ctx.fillStyle = 'rgba(255, 0, 0, 0.8)'; ctx.strokeStyle = 'white'; ctx.lineWidth = 1;
            ctx.beginPath(); ctx.arc(cx, cy, 5, 0, Math.PI * 2); ctx.fill(); ctx.stroke();
            ctx.restore();
            pulseSize += 1.5; pulseOpacity -= 0.06;
            if (pulseOpacity > 0) animationFrameId = requestAnimationFrame(pulse);
            else { window.currentPulseAnimation = null; redraw(true); }
        };
        if (window.currentPulseAnimation) cancelAnimationFrame(window.currentPulseAnimation);
        window.currentPulseAnimation = requestAnimationFrame(pulse);
    }

function calculateAndDisplayIntersections(selectedIndex) {
        intersectionList.innerHTML = '';
        if (selectedIndex < 0 || selectedIndex >= userObjects.length || !userObjects[selectedIndex]) {
            intersectionsTitle.style.display = 'none'; return;
        }
        const selectedObj = userObjects[selectedIndex];
        if (!selectedObj.contours || selectedObj.contours.length === 0 || selectedObj.type !== 'polygon') {
            intersectionList.innerHTML = '<li style="color: #777; font-style: italic;">Проверка пересечений доступна только для полигонов.</li>';
            intersectionsTitle.style.display = 'block'; return;
        }
        
        const selPolygon = selectedObj.contours[0];
        if (!selPolygon || selPolygon.length < 3 || !selPolygon.every(p => p && isFinite(p.x) && isFinite(p.y))) {
            intersectionList.innerHTML = '<li style="color: #777; font-style: italic;">Выбранный объект не является валидным полигоном.</li>';
            intersectionsTitle.style.display = 'block'; return;
        }
        
        // 1. Получаем уникальные точки (без замыкающей)
        const uniqueSelPoints = getUniquePolygonPoints(selPolygon);
        
        let hasRelations = false; 

        userObjects.forEach((otherObj, otherIndex) => {
            if (selectedIndex === otherIndex || !otherObj || !otherObj.contours || otherObj.contours.length === 0 || otherObj.type !== 'polygon') return;
            if (otherObj.visible === false) return;
            
            const otherPolygon = otherObj.contours[0];
            if (!otherPolygon || otherPolygon.length < 3 || !otherPolygon.every(p => p && isFinite(p.x) && isFinite(p.y))) return;
            
            const uniqueOtherPoints = getUniquePolygonPoints(otherPolygon);

            const result = checkIntersection(selPolygon, otherPolygon);
            
            let message = ""; let liClass = ''; let relationFound = false;
            const otherName = otherObj.name || `Объект ${otherObj.id}`;

            if (result.contains) { 
                let insideHole = false;
                if (selectedObj.contours.length > 1) {
                    for (let i = 1; i < selectedObj.contours.length; i++) {
                        const hole = selectedObj.contours[i];
                        if (uniqueOtherPoints.every(p => isPointInPolygon(p, hole))) { insideHole = true; break; }
                    }
                }
                if (insideHole) {
                    message = `Находится вокруг <strong>${otherName}</strong>`;
                    liClass = 'boundary-touch'; 
                } else {
                    message = `Полностью содержит <strong>${otherName}</strong>`; 
                    liClass = 'full-containment';
                }
                relationFound = true; 
            }
            else if (result.containedBy) { 
                let insideHole = false;
                if (otherObj.contours.length > 1) {
                    for (let i = 1; i < otherObj.contours.length; i++) {
                        const hole = otherObj.contours[i];
                        if (uniqueSelPoints.every(p => isPointInPolygon(p, hole))) { insideHole = true; break; }
                    }
                }
                if (insideHole) {
                    message = `Находится в дырке <strong>${otherName}</strong>`;
                    liClass = 'contained-by'; 
                } else {
                    message = `Полностью содержится в <strong>${otherName}</strong>`; 
                    liClass = 'contained-by';
                }
                relationFound = true; 
            }
            else if (result.intersects) {
                let pointsPoly1InPoly2 = 0; 
                uniqueSelPoints.forEach(p => { if (isPointInPolygon(p, otherPolygon)) pointsPoly1InPoly2++; });
                
                let pointsPoly2InPoly1 = 0; 
                uniqueOtherPoints.forEach(p => { if (isPointInPolygon(p, selPolygon)) pointsPoly2InPoly1++; });

                if (pointsPoly1InPoly2 > result.sharedVertices || pointsPoly2InPoly1 > result.sharedVertices) {
                    message = `Имеет наложение на <strong>${otherName}</strong>`;
                    if (result.sharedVertices > 0) {
                        const n = result.sharedVertices;
                        if (n === 1) { 
                            message += ` (имеет 1 общую точку)`; 
                        } else { 
                            const pw = (n > 1 && n < 5) ? 'ки' : 'ек'; 
                            message += ` (имеет ${n} общих точ${pw})`; 
                        }
                    }
                    liClass = 'partial-overlap'; if (result.sharedVertices > 0) liClass += ' shared-vertices';
                } else {
                    if (result.sharedVertices > 0) { 
                        const n = result.sharedVertices;
                        let pointsText;
                        // ИСПРАВЛЕНИЕ: Жестко задаем текст для 1 точки, чтобы не было "точточку"
                        if (n === 1) { 
                            pointsText = `1 общую точку`; 
                        } else { 
                            const pw = (n > 1 && n < 5) ? 'ки' : 'ек'; 
                            pointsText = `${n} общих точ${pw}`; 
                        }
                        message = `Имеет общую границу с <strong>${otherName}</strong> (${pointsText})`; 
                        liClass = 'boundary-touch';
                    } else { 
                        message = `Имеет наложение на <strong>${otherName}</strong>`; 
                        liClass = 'partial-overlap';
                    }
                }
                relationFound = true;
            } else if (result.sharedVertices > 0) {
                const n = result.sharedVertices;
                let pointsText;
                // ИСПРАВЛЕНИЕ: Аналогично для случая простого касания
                if (n === 1) { 
                    pointsText = `1 общую точку`; 
                } else { 
                    const pw = (n > 1 && n < 5) ? 'ки' : 'ек'; 
                    pointsText = `${n} общих точ${pw}`; 
                }
                message = `Имеет общую границу с <strong>${otherName}</strong> (${pointsText})`;
                liClass = 'boundary-touch';
                relationFound = true;
            }

            if (relationFound) { 
                hasRelations = true; 
                const li = document.createElement('li'); 
                li.innerHTML = message; 
                li.className = liClass; 
                li.title = `Кликните для выбора объекта ${otherName}`; 
                li.onclick = () => { displayObjectInfo(otherIndex); }; 
                intersectionList.appendChild(li); 
            }
        });

        intersectionsTitle.style.display = 'block';
        if (!hasRelations) intersectionList.innerHTML = '<li style="color: #777; font-style: italic;">Пересечений, наложений или общих границ не найдено.</li>';
    }

function toggleObjectVisibility(index) {
    if (userObjects[index]) {
        if (userObjects[index].visible === undefined) {
            userObjects[index].visible = true;
        }

        userObjects[index].visible = !userObjects[index].visible;
        
        // --- НОВОЕ: Если скрыли объект ---
        if (!userObjects[index].visible) {
            // Если скрываемый объект был выбран
            if (selectedObjectIndex === index) {
                
                // Если был активен режим редактирования геометрии этого объекта - выключаем его
                if (isGeometryEditMode && editingObjectIndex === index) {
                    deactivateGeometryEditMode(false);
                }

                // Сбрасываем выбор
                selectedObjectIndex = -1;
                displayObjectInfo(-1);
            }
        }
        // ---------------------------------

        updateObjectList(); 
        redraw(true);       
        saveState();        
    }
}



function updateObjectList() {
    objectListUL.innerHTML = ''; 
    const validObjects = userObjects.filter(o => o); 
    objectCountSpan.textContent = validObjects.length;
    
    if (validObjects.length === 0) { 
        objectListUL.innerHTML = '<li style="color: #777; font-style: italic; padding: 5px 0;">Нет объектов</li>'; 
        return; 
    }
    
    const sortedObjects = [...validObjects].sort((a, b) => (a.id || 0) - (b.id || 0));
    
    sortedObjects.forEach((obj) => {
        const originalIndex = userObjects.findIndex(o => o && o.id === obj.id); 
        if (originalIndex === -1) return;
        
        const li = document.createElement('li'); 
        li.dataset.originalIndex = originalIndex;
        
        // --- Стили для li, чтобы выровнять элементы ---
        li.style.display = 'flex';
        li.style.alignItems = 'center';
        li.style.justifyContent = 'space-between'; // Распределяем пространство
        // ----------------------------------------------

        // Контейнер для цвета и имени (левая часть)
        const leftContent = document.createElement('div');
        leftContent.style.display = 'flex';
        leftContent.style.alignItems = 'center';
        leftContent.style.flexGrow = '1';
        leftContent.style.overflow = 'hidden';

        const colorIndicator = document.createElement('span'); 
        colorIndicator.className = 'color-indicator'; 
        colorIndicator.style.backgroundColor = obj.color || '#ccc';
        
        const nameSpan = document.createElement('span'); 
        nameSpan.className = 'name-span';
        const objName = obj.name || `Объект ${obj.id}`; 
        nameSpan.textContent = objName; 
        nameSpan.title = objName;
        
        leftContent.appendChild(colorIndicator);
        leftContent.appendChild(nameSpan);
        li.appendChild(leftContent);

        // --- ДОБАВЛЕНО: Кнопка видимости (правая часть) ---
        const visibilityBtn = document.createElement('span');
        visibilityBtn.className = 'visibility-toggle';
        // Если visible undefined (старые сохранения), считаем true
        const isVisible = obj.visible !== false; 
        
// Внутри updateObjectList
visibilityBtn.innerHTML = isVisible 
    ? '<i class="fas fa-layer-group" title="Скрыть слой" style="color: #3498db;"></i>' 
    : '<i class="fas fa-layer-group" title="Показать слой" style="color: #ddd;"></i>';
            
        visibilityBtn.onclick = (e) => {
            e.stopPropagation(); // Чтобы не выделялся сам объект при клике на глаз
            toggleObjectVisibility(originalIndex);
        };
        li.appendChild(visibilityBtn);
        // --------------------------------------------------

        if (originalIndex === selectedObjectIndex) li.classList.add('selected');

         li.onclick = (e) => {
            // Пропускаем клик по иконке глаза
            if (e.target.closest('.visibility-toggle')) return;

            const idx = parseInt(li.dataset.originalIndex);
            
            // --- НОВОЕ: Проверка на скрытость ---
            if (userObjects[idx] && userObjects[idx].visible === false) {
                // Можно добавить уведомление, если нужно
                // showNotification("Нельзя выбрать скрытый объект", "warning");
                return; // Прерываем выполнение, выбор не происходит
            }
            // ------------------------------------

            if (!isNaN(idx) && selectedObjectIndex !== idx) {
                  if (adjacentPointsMode) {
                    adjacentPointsMode = false;
                    adjacentObjectIndices.clear();
                }
                
                if (isDrawingMode && isDrawingActive) cancelDrawing();
                if (isGeometryEditMode) deactivateGeometryEditMode(false);
                displayObjectInfo(idx);
                redraw(true);
            } else if (!isNaN(idx) && selectedObjectIndex === idx) {
                if (isGeometryEditMode && editingObjectIndex !== idx) {
                    deactivateGeometryEditMode(false);
                    activateGeometryEditMode();
                }
            }
        };
        objectListUL.appendChild(li);
    });
    updateObjectListSelection();
}


    function updateObjectListSelection() {
        const items = objectListUL.querySelectorAll('li'); items.forEach(li => { if (!li.dataset.originalIndex) return; const idx = parseInt(li.dataset.originalIndex); if (isNaN(idx)) return; if (idx === selectedObjectIndex) { li.classList.add('selected'); requestAnimationFrame(() => { try { li.scrollIntoView({ behavior: 'smooth', block: 'nearest' }); } catch(e) { li.scrollIntoView(false); } }); } else { li.classList.remove('selected'); } });
    }
    function updateObjectListColorIndicator(objectIndex, newColor) {
        if (!objectListUL) return; const items = objectListUL.querySelectorAll('li'); items.forEach(li => { if (li.dataset.originalIndex === String(objectIndex)) { const colorIndicator = li.querySelector('.color-indicator'); if (colorIndicator) colorIndicator.style.backgroundColor = newColor || '#ccc'; } });
    }
    function showNotification(message, type = 'info', icon = 'info-circle') {
        const n = document.createElement('div'); n.className = `notification ${type}`; n.innerHTML = `<i class="fas fa-${icon}"></i> ${message}`; document.body.appendChild(n); requestAnimationFrame(() => { n.classList.add('show'); setTimeout(() => { n.classList.remove('show'); setTimeout(() => n.remove(), 500); }, 3000); });
    }
    function copyToClipboard(text) {
        if (text === undefined || text === null) text = ''; navigator.clipboard.writeText(text.toString()).then(() => { const sT = text.toString().substring(0, 30); showNotification(`Скопировано: "${sT}${text.toString().length > 30 ? '...' : ''}"`, 'success', 'check-circle'); }).catch(err => { showNotification('Ошибка копирования в буфер', 'error', 'exclamation-circle'); });
    }
    function hexToRgba(hex, alpha) {
        if (typeof alpha !== 'number' || !isFinite(alpha)) alpha = 1.0; alpha = Math.max(0, Math.min(1, alpha)); if (!hex || typeof hex !== 'string') hex = '#000000'; hex = hex.replace('#', ''); if (hex.length === 3) hex = hex[0]+hex[0]+hex[1]+hex[1]+hex[2]+hex[2]; if (hex.length !== 6) hex = '000000'; const r = parseInt(hex.substring(0, 2), 16); const g = parseInt(hex.substring(2, 4), 16); const b = parseInt(hex.substring(4, 6), 16); if (isNaN(r) || isNaN(g) || isNaN(b)) return `rgba(0, 0, 0, ${alpha})`; return `rgba(${r}, ${g}, ${b}, ${alpha})`;
    }
    function resetMeasurement() { rulerPoints = []; updateMeasurementPanel(); redraw(true); }
    function updateMeasurementPanel() { if (!rulerMode) return; let coordText = 'Точка 1: -<br>Точка 2: -'; let distText = 'Расстояние: -'; if (rulerPoints.length >= 1) { const p1 = rulerPoints[0]; const p1x = (p1 && isFinite(p1.x)) ? p1.x.toFixed(2) : '-'; const p1y = (p1 && isFinite(p1.y)) ? p1.y.toFixed(2) : '-'; coordText = `Точка 1: X=${p1x}, Y=${p1y}<br>Точка 2: Выберите...`; } if (rulerPoints.length === 2) { const p1 = rulerPoints[0]; const p2 = rulerPoints[1]; if (p1 && p2 && isFinite(p1.x) && isFinite(p1.y) && isFinite(p2.x) && isFinite(p2.y)) { const dist = calculateDistance(p1, p2); coordText = `Точка 1: X=${p1.x.toFixed(2)}, Y=${p1.y.toFixed(2)}<br>Точка 2: X=${p2.x.toFixed(2)}, Y=${p2.y.toFixed(2)}`; distText = `Расстояние: ${isFinite(dist) ? dist.toFixed(2) + ' м' : '-'}`; } else { coordText = `Точка 1: ${isFinite(p1?.x) ? p1.x.toFixed(2) : '-'}, Y=${isFinite(p1?.y) ? p1.y.toFixed(2) : '-'}<br>Точка 2: Ошибка`; distText = 'Расстояние: -'; } } measurementCoordinates.innerHTML = coordText; measurementDistance.textContent = distText; }
    function calculateDistance(p1, p2) { if (!p1 || !p2 || !isFinite(p1.x) || !isFinite(p1.y) || !isFinite(p2.x) || !isFinite(p2.y)) return NaN; const dx = p2.x - p1.x; const dy = p2.y - p1.y; return Math.sqrt(dx * dx + dy * dy); }
    function togglePointsVisibility() { showPoints = !showPoints; redraw(true); showNotification(showPoints ? 'Точки включены' : 'Точки отключены', 'info', showPoints ? 'eye' : 'eye-slash'); updateToggleButtonStates(); saveState(); }

    function activateDrawingMode() { isDrawingMode = true; isDrawingActive = true; currentDrawingPoints = []; showNotification('Режим рисования. Клик: точка. Двойной клик: полигон. ✓: линия/точка.', 'info', 'pencil-alt'); selectedObjectIndex = -1; displayObjectInfo(-1); updateObjectListSelection(); redraw(true); }
    function cancelDrawing() { if (isDrawingActive) { showNotification('Рисование отменено.', 'info', 'times-circle'); } finalizeDrawingState(); }

 function finalizeDrawingState() {
    isDrawingMode = false;
    isDrawingActive = false;
    currentDrawingPoints = [];
    snappedToPointVisual = null;
    redraw(true);
    if (!rulerMode && !isGeometryEditMode && !isMovingPoint) canvas.style.cursor = 'grab';
    updateToggleButtonStates();
}
    
    async function finishDrawingAsPolygon() {
         if (!isDrawingActive) return;
         const validPointsRaw = currentDrawingPoints.filter(p => p && isFinite(p.x) && isFinite(p.y));
         if (validPointsRaw.length < 3) {
             showNotification("Нужно минимум 3 точки для полигона.", "warning", "exclamation-triangle");
             return;
         }
         let finalPolygonPoints = [...validPointsRaw];
         const firstPoint = finalPolygonPoints[0];
         const lastPoint = finalPolygonPoints[finalPolygonPoints.length - 1];
         const PRECISION_THRESHOLD = 0.001;
         const isAlreadyClosed = Math.abs(firstPoint.x - lastPoint.x) < PRECISION_THRESHOLD &&
                                 Math.abs(firstPoint.y - lastPoint.y) < PRECISION_THRESHOLD;
         if (!isAlreadyClosed) {
             finalPolygonPoints.push({ x: firstPoint.x, y: firstPoint.y });
         }
         if (finalPolygonPoints.length < 3) {
            showNotification("Недостаточно уникальных точек для полигона после замыкания.", "warning", "exclamation-triangle");
            return;
         }
         showLoader(false);
         const name = await showNamePrompt("Имя нового полигона:", `Нарисованный ${nextObjectId}`);
         if (name !== null) {
            const newObj = addObjectInternal([finalPolygonPoints], name, 'polygon', true); // Pass as array of contours
            if (newObj) {
                 finalizeBatchAdd([newObj]);
            }
         } else {
            showNotification('Создание полигона отменено.', 'warning', 'times-circle');
         }
         finalizeDrawingState();
    }
    async function finishDrawingAsLineOrPoint() {
        if (!isDrawingActive) return;
        const validPoints = currentDrawingPoints.filter(p => p && isFinite(p.x) && isFinite(p.y));
        if (validPoints.length < 1) { showNotification("Нет точек для создания объекта.", "warning", "exclamation-triangle"); cancelDrawing(); return; }
        const objectType = validPoints.length >= 2 ? 'line' : 'point';
        const typeDesc = objectType === 'line' ? 'линии' : 'точки';
        showLoader(false);
        const name = await showNamePrompt(`Имя новой ${typeDesc}:`, `Нарисованный ${nextObjectId}`);
        if (name !== null) {
            const newObj = addObjectInternal([validPoints], name, objectType, true); // Pass as array of contours
             if (newObj) {
                 finalizeBatchAdd([newObj]);
            }
        } else {
            showNotification(`Создание ${typeDesc} отменено.`, 'warning', 'times-circle');
        }
        finalizeDrawingState();
    }
    async function handleRenameRequest(index) {
        if (index < 0 || index >= userObjects.length || !userObjects[index]) return;
        const currentName = userObjects[index].name || `Объект ${userObjects[index].id}`;
        const newName = await showNamePrompt(`Переименовать объект:`, currentName);
        if (newName !== null) await renameObject(index, newName);
    }

const USE_PROXY_FALLBACK = false;

async function fetchNspd(url) {
    const requestHeaders = {
        'Referer': 'https://nspd.gov.ru/'
    };

    try {
        const directResponse = await fetch(url, { headers: requestHeaders });
        if (!directResponse.ok) {
            throw new Error(`Прямой запрос не удался: ${directResponse.status}`);
        }
        return await directResponse.json();
    } catch (error) {
        if (USE_PROXY_FALLBACK) {
            console.warn(`Прямой запрос не удался: ${error.message}. Переключаюсь на прокси.`);
            
            const vercelProxyUrl = 'https://nsp-two.vercel.app/';
            const urlObject = new URL(url);
            const targetPath = `${urlObject.pathname}${urlObject.search}`;
            const proxyRequestUrl = `${vercelProxyUrl}?target=${encodeURIComponent(targetPath)}`;

            const proxyResponse = await fetch(proxyRequestUrl, { headers: requestHeaders });
            if (!proxyResponse.ok) {
                const errorText = await proxyResponse.text();
                throw new Error(`Запрос через прокси также не удался: ${proxyResponse.statusText}. Ответ: ${errorText}`);
            }
            return await proxyResponse.json();
        } else {
            throw error;
        }
    }
}

    async function fetchCadastralData(cadastralNumber) {
        const url = `https://nspd.gov.ru/api/geoportal/v2/search/geoportal?thematicSearchId=1&query=${cadastralNumber}`;
        const data = await fetchNspd(url);

        if (!data.data || !data.data.features || data.data.features.length === 0) {
            throw new Error(`Объект с КН ${cadastralNumber} не найден в ЕГРН.`);
        }
        return data.data.features[0];
    }

    // --- Supabase specific functions ---
    function isValidCadastralNumberFormat(text) {
        if (!text) return false;
        const pattern = new RegExp(`^\\d{2}:\\d{2}:\\d{6,7}:\\d+$`);
        return pattern.test(text);
    }

    function getElementValueFromNode(element, tagName) {
        if (!element) return '';
        const parts = tagName.split('>');
        let currentElement = element;
        for (let part of parts) {
            currentElement = currentElement.querySelector(part);
            if (!currentElement) return '';
        }
        return currentElement.textContent.trim();
    }


function extractCoordinatesFromXMLNode(recordNode) {
    const allContoursData = [];

    // Вспомогательная функция для извлечения точек из контейнера (entity_spatial или spatials_elements)
    const processSpatialNode = (container) => {
        if (!container) return;
        
        // В KPT координаты лежат в spatial_element.
        // querySelectorAll найдет их даже если они вложены в spatials_elements
        const spatialElements = container.querySelectorAll("spatial_element");
        
        spatialElements.forEach(spEl => {
            const ordinates = spEl.querySelectorAll("ordinates > ordinate");
            const currentContourPoints = [];
            
            ordinates.forEach(ord => {
                // Используем простые селекторы для скорости и надежности
                const xNode = ord.querySelector("x");
                const yNode = ord.querySelector("y");
                
                if (xNode && yNode) {
                    const x = parseFloat(xNode.textContent);
                    const y = parseFloat(yNode.textContent);
                    
                    if (isFinite(x) && isFinite(y)) {
                        currentContourPoints.push({ x: roundCoord(x), y: roundCoord(y) });
                    }
                }
            });

            if (currentContourPoints.length > 0) {
                allContoursData.push(currentContourPoints);
            }
        });
    };

    // 1. Сценарий для Земельных участков (land_record) в КПТ: ищем contours_location
    const contoursLocation = recordNode.querySelector("contours_location");
    
    if (contoursLocation) {
        // Внутри могут быть contours -> contour
        const contours = contoursLocation.querySelectorAll("contours > contour");
        
        if (contours.length > 0) {
            contours.forEach(c => {
                // Ищем entity_spatial внутри контура
                processSpatialNode(c.querySelector("entity_spatial"));
            });
        } else {
            // Иногда entity_spatial лежит сразу в contours_location (без contour)
            processSpatialNode(contoursLocation.querySelector("entity_spatial"));
        }
    } 
    // 2. Сценарий для ОКС (build_record), Сооружений и выписок КВЗУ: ищем entity_spatial напрямую в корне объекта
    else {
        const entitySpatial = recordNode.querySelector("entity_spatial");
        if (entitySpatial) {
            processSpatialNode(entitySpatial);
        } else {
            // Фолбэк: пробуем найти contours напрямую, если это старый формат или специфическая выписка
            const directContours = recordNode.querySelectorAll("contours > contour");
            directContours.forEach(c => processSpatialNode(c.querySelector("entity_spatial")));
        }
    }

    if (allContoursData.length === 0) {
        const cadNumberElem = recordNode.querySelector('common_data > cad_number');
        const cadNumber = cadNumberElem ? cadNumberElem.textContent.trim() : 'Неизвестный';
        // console.warn(`[CoordExtractor] Не удалось извлечь координаты для ${cadNumber}. Проверьте структуру XML.`);
    }

    return allContoursData;
}


async function fetchParcelCoordinatesFromStorage(cadNumber) {
    console.log(`[StorageAPI] Запрос для КН: ${cadNumber}`);
    const parts = cadNumber.split(':');
    if (parts.length < 3) {
        const errorMsg = `Неверный формат КН для извлечения квартала: ${cadNumber}`;
        showNotification(errorMsg, "error", "hashtag");
        console.error(`[StorageAPI] ${errorMsg}`);
        return null;
    }
    const quarterNumber = parts.slice(0, 3).join(':');
    const serverQuarterPrefix = quarterNumber.replace(/:/g, '_');
    console.log(`[StorageAPI] Поиск файлов для квартала: ${serverQuarterPrefix}`);

    try {
        const responseList = await fetch(`${STORAGE_API_URL}/${BUCKET_NAME}?search=${serverQuarterPrefix}`);
        if (!responseList.ok) throw new Error(`Ошибка получения списка файлов: ${responseList.statusText}`);
        
        const fileList = await responseList.json();
        if (!fileList || fileList.length === 0) throw new Error(`КПТ для квартала ${quarterNumber} не найдены на сервере.`);

        const matchingFiles = fileList.filter(f => f.name.startsWith(serverQuarterPrefix) && f.name.toLowerCase().endsWith('.zip'));
        if (matchingFiles.length === 0) throw new Error(`Архивы КПТ для квартала ${quarterNumber} не найдены.`);

        const latestFile = matchingFiles.sort((a, b) => b.name.localeCompare(a.name))[0];
        console.log(`[StorageAPI] Выбран файл КПТ: ${latestFile.name}`);

        const responseDownload = await fetch(`${STORAGE_API_URL}/${BUCKET_NAME}/${latestFile.name}`);
        if (!responseDownload.ok) throw new Error(`Ошибка загрузки файла: ${responseDownload.statusText}`);
        
        const blob = await responseDownload.blob();
        const zip = await JSZip.loadAsync(blob);
        
        let xmlFileEntry = null;
        for (const fileNameInZip in zip.files) {
            if (fileNameInZip.toLowerCase().endsWith('.xml') && !zip.files[fileNameInZip].dir) {
                xmlFileEntry = zip.files[fileNameInZip];
                break;
            }
        }
        if (!xmlFileEntry) throw new Error("XML-файл не найден в архиве КПТ.");

        const xmlContent = await xmlFileEntry.async('string');
        const parser = new DOMParser();
        const xmlDoc = parser.parseFromString(xmlContent, "text/xml");
        
        let foundRecordNode = null;

        const allRecords = xmlDoc.querySelectorAll('land_record, build_record, construction_record');
        
        for (const record of allRecords) {
            const cnElem = record.querySelector('object > common_data > cad_number');
            if (cnElem && cnElem.textContent.trim() === cadNumber) {
                foundRecordNode = record;
                break; 
            }
        }

        if (!foundRecordNode) {
            throw new Error(`Объект ${cadNumber} не найден в XML файле ${latestFile.name}.`);
        }
        
        const extractedContours = extractCoordinatesFromXMLNode(foundRecordNode);
        const objectType = foundRecordNode.tagName.toLowerCase(); // 'land_record', 'build_record', 'construction_record'
        
        console.log(`[StorageAPI] Извлечено контуров для ${cadNumber}: ${extractedContours.length}, тип: ${objectType}`);
        return { contours: extractedContours, type: objectType }; // Возвращаем объект с контурами и типом

    } catch (error) {
        console.error(`[StorageAPI] Общая ошибка для КН ${cadNumber}:`, error);
        showNotification(`Ошибка для ${cadNumber}: ${error.message}`, "error", "times-circle");
        return null;
    }
}


function showLoader(show, text = "Загрузка...") {
    const btn = document.getElementById('cancelLoadBtn');
    if (show) {
        loaderTextElement.textContent = text;
        loaderContainer.style.display = 'flex';
        // Показываем кнопку отмены
        if (btn) btn.style.display = 'block';
    } else {
        loaderContainer.style.display = 'none';
        if (btn) btn.style.display = 'none';
    }
}

async function handleImportFromCadNumbers(cadNumbers) {
    if (!STORAGE_API_URL) {
        showNotification("URL хранилища не задан.", "error", "server");
        return;
    }
    closeCoordsDialog();

    let addedObjects = [];
    let errors = 0;
    
    // Сбрасываем флаг отмены перед началом
    isNspdLoadCancelled = false;

    // 1. Группируем кадастровые номера по кварталам
    const tasksByQuarter = {};
    
    cadNumbers.forEach(cn => {
        const parts = cn.split(':');
        if (parts.length >= 3) {
            // Получаем квартал (например, 16:56:010130)
            const quarter = parts.slice(0, 3).join(':');
            if (!tasksByQuarter[quarter]) {
                tasksByQuarter[quarter] = [];
            }
            tasksByQuarter[quarter].push(cn);
        } else {
            console.warn(`Неверный формат КН: ${cn}`);
            errors++;
        }
    });

    const quartersToProcess = Object.keys(tasksByQuarter);
    showLoader(true, `Обработка ${quartersToProcess.length} кварталов...`);

    // 2. Проходим по каждому кварталу
    for (let i = 0; i < quartersToProcess.length; i++) {
        if (isNspdLoadCancelled) {
            console.log("Загрузка прервана пользователем.");
            break;
        }

        const quarter = quartersToProcess[i];
        const cnsInQuarter = tasksByQuarter[quarter];
        
        showLoader(true, `Загрузка квартала ${quarter} (${i + 1}/${quartersToProcess.length})...`);

        try {
            // Скачиваем XML один раз для всего квартала
            const xmlContent = await fetchKptXmlContent(quarter);
            
            if (!xmlContent) {
                throw new Error("Файл пуст или не найден");
            }

            // Парсим XML один раз
            const parser = new DOMParser();
            const xmlDoc = parser.parseFromString(xmlContent, "text/xml");

            // Создаем карту (Map) всех объектов в XML для быстрого поиска
            // Ключ: Кадастровый номер, Значение: XML-узел
            const recordsMap = new Map();
            const allRecords = xmlDoc.querySelectorAll('land_record, build_record, construction_record');
            
            allRecords.forEach(record => {
                const cnNode = record.querySelector('common_data > cad_number');
                if (cnNode) {
                    recordsMap.set(cnNode.textContent.trim(), record);
                }
            });

            // 3. Извлекаем нужные объекты из этого XML
            cnsInQuarter.forEach(cn => {
                const recordNode = recordsMap.get(cn);
                
                if (recordNode) {
                    const contours = extractCoordinatesFromXMLNode(recordNode);
                    const objectType = recordNode.tagName.toLowerCase(); // 'land_record' и т.д.
                    
                    if (contours && contours.length > 0) {
                        const newObj = addObjectInternal(contours, cn, "polygon", true, objectType);
                        if (newObj) {
                            addedObjects.push(newObj);
                        } else {
                            errors++;
                        }
                    } else {
                        console.warn(`Контуры не найдены для ${cn}`);
                        errors++;
                    }
                } else {
                    console.warn(`Объект ${cn} не найден в файле квартала.`);
                    errors++;
                }
            });

        } catch (err) {
            console.error(`Ошибка обработки квартала ${quarter}:`, err);
            // Если ошибка загрузки квартала, помечаем все КН в нем как ошибочные
            errors += cnsInQuarter.length;
            showNotification(`Ошибка загрузки квартала ${quarter}: ${err.message}`, "error");
        }
    }

    showLoader(false);

    // Добавляем на карту то, что успели загрузить
    if (addedObjects.length > 0) {
        finalizeBatchAdd(addedObjects);
        const msg = isNspdLoadCancelled 
            ? `Загрузка прервана. Успешно загружено: ${addedObjects.length}.`
            : `Загружено ${addedObjects.length} объектов.`;
        
        showNotification(msg, isNspdLoadCancelled ? "warning" : "success");
    } else {
        if (isNspdLoadCancelled) {
            showNotification("Загрузка отменена. Объектов не добавлено.", "info");
        } else if (errors > 0) {
            showNotification(`Не удалось загрузить объекты. Ошибок: ${errors}.`, "error");
        } else {
            showNotification("Объекты не найдены.", "warning");
        }
    }
}


    function checkTotalPointsAndHide() {
        // Если точки уже скрыты, проверять не нужно
        if (!showPoints) return;

        let totalPoints = 0;
        for (const obj of userObjects) {
            if (obj && obj.contours) {
                for (const contour of obj.contours) {
                    if (contour) {
                        totalPoints += contour.length;
                    }
                }
            }
        }

        if (totalPoints > 2000) {
            showPoints = false;
            updateToggleButtonStates(); // Обновляем состояние кнопки
            showNotification("Точки скрыты автоматически в целях производительности (более 2000 вершин).", "warning", "eye-slash");
        }
    }

    function finalizeBatchAdd(addedObjectsArray) {
        if (addedObjectsArray.length === 0) return;
        updateObjectList();
        selectedObjectIndex = userObjects.indexOf(addedObjectsArray[addedObjectsArray.length - 1]);
        calculateBounds();
        displayObjectInfo(selectedObjectIndex);
        setTimeout(() => {
            if (selectedObjectIndex !== -1) centerOnObject(selectedObjectIndex, true);
            else resetView();
        }, 100);
         checkTotalPointsAndHide();
        saveState();
        redraw(true);
    }
    
    
    
    
    
    
    
    
    // --- ИНСТРУМЕНТ: ТОЧКИ ПЕРЕСЕЧЕНИЯ ---

    function toggleIntersectTool() {
        if (!isGeometryEditMode) return;
        
        // Выключаем другие инструменты если активны
        if (isCutToolActive) toggleCutTool();

        isIntersectToolActive = !isIntersectToolActive;
        const btn = document.getElementById('intersectPointsBtn');
        
        if (isIntersectToolActive) {
            btn.classList.add('active');
            intersectTargetIndex = -1;
            showNotification("Инструмент «Пересечения»: Выберите ПЕРВЫЙ объект (двойной клик).", "info", "project-diagram");
            canvas.style.cursor = 'crosshair';
        } else {
            btn.classList.remove('active');
            intersectTargetIndex = -1;
            showNotification("Инструмент «Пересечения» выключен.", "info", "times");
            canvas.style.cursor = 'default';
        }
        redraw(true);
    }


    function handleIntersectSelection(point) {
        let clickedIdx = -1;
        // Ищем объект под курсором
        for (let i = userObjects.length - 1; i >= 0; i--) {
            const obj = userObjects[i];
            if (obj && obj.contours) {
                if (obj.type === 'polygon' && obj.contours.some(c => isPointInPolygonRobust(point, c))) {
                    clickedIdx = i; break;
                }
            }
        }

        if (clickedIdx === -1) return;

        if (intersectTargetIndex === -1) {
            intersectTargetIndex = clickedIdx;
            const objName = userObjects[clickedIdx].name || `Объект ${userObjects[clickedIdx].id}`;
            showNotification(`Выбран №1: "${objName}". Выберите ВТОРОЙ объект.`, "warning", "hand-pointer");
        } else {
            if (clickedIdx === intersectTargetIndex) {
                 showNotification("Выберите другой объект.", "error");
                 return; 
            }

            const obj2Name = userObjects[clickedIdx].name || `Объект ${userObjects[clickedIdx].id}`;
            showNotification(`Второй: "${obj2Name}". Расчет пересечений...`, "info", "cog");
            
            // Вместо создания сразу, запускаем расчет и открываем диалог
            prepareIntersectionOptions(intersectTargetIndex, clickedIdx);
        }
    }

    // НОВАЯ ФУНКЦИЯ: Расчет точек и открытие диалога
    function prepareIntersectionOptions(idx1, idx2) {
        const points = calculateIntersectionCoordinates(idx1, idx2);
        
        if (points.length === 0) {
            showNotification("Пересечений не найдено.", "warning");
            intersectTargetIndex = -1; // Сброс
            return;
        }

        // Сохраняем данные для выбора пользователя
        pendingIntersectionData = {
            points: points,
            idx1: idx1,
            idx2: idx2
        };

        // Открываем диалог
        const dialog = document.getElementById('intersectionOptionsDialog');
        const overlay = document.getElementById('dialogOverlay');
        document.getElementById('intersectionCountText').textContent = `Найдено точек пересечения: ${points.length}`;
        
        dialog.style.display = 'block';
        overlay.classList.add('show');
        overlay.style.display = 'block';
    }

    // НОВАЯ ФУНКЦИЯ: Расчет координат (вынесена из старой createIntersectionPoints)
    function calculateIntersectionCoordinates(idx1, idx2) {
        const obj1 = userObjects[idx1];
        const obj2 = userObjects[idx2];
        if (!obj1 || !obj2) return [];

        const segs1 = getAllSegments(obj1);
        const segs2 = getAllSegments(obj2);
        let foundPoints = [];

        for (let s1 of segs1) {
            for (let s2 of segs2) {
                const pt = getSegmentIntersection(s1.p1, s1.p2, s2.p1, s2.p2);
                if (pt) {
                    const roundedX = Math.round(pt.x * 100) / 100;
                    const roundedY = Math.round(pt.y * 100) / 100;
                    
                    const exists = foundPoints.some(fp => 
                        Math.abs(fp.x - roundedX) < 1e-4 && Math.abs(fp.y - roundedY) < 1e-4
                    );

                    if (!exists) {
                        foundPoints.push({ x: roundedX, y: roundedY });
                    }
                }
            }
        }
        return foundPoints;
    }

    // НОВАЯ ФУНКЦИЯ: Закрытие диалога
    function closeIntersectionDialog() {
        const dialog = document.getElementById('intersectionOptionsDialog');
        const overlay = document.getElementById('dialogOverlay');
        dialog.style.display = 'none';
        overlay.classList.remove('show');
        setTimeout(() => { overlay.style.display = 'none'; }, 300);
        
        // Сбрасываем выбор инструмента
        intersectTargetIndex = -1;
        pendingIntersectionData = null;
        redraw(true);
    }

    // НОВАЯ ФУНКЦИЯ: Применение выбора пользователя
    function applyIntersectionChoice(mode) {
        if (!pendingIntersectionData) return;

        const { points, idx1, idx2 } = pendingIntersectionData;
        let msg = "";

        // 1. Просто создать новые точки (как раньше)
        if (mode === 'create_only') {
            createIndependentPoints(points);
            msg = "Созданы новые объекты-точки.";
        }
        
        // 2. Внедрить в оба объекта
        else if (mode === 'modify_both') {
            let count1 = insertPointsIntoObjectGeometry(idx1, points);
            let count2 = insertPointsIntoObjectGeometry(idx2, points);
            msg = `Точки добавлены: в Объект 1 (${count1}), в Объект 2 (${count2}).`;
            // Также обновляем метрики, так как геометрия изменилась
            updateObjectMetrics(userObjects[idx1]);
            updateObjectMetrics(userObjects[idx2]);
        }

        // 3. Внедрить только в первый
        else if (mode === 'modify_first') {
            let count = insertPointsIntoObjectGeometry(idx1, points);
            msg = `Точки добавлены в Объект 1 (${count} шт).`;
            updateObjectMetrics(userObjects[idx1]);
        }

        // 4. Внедрить только во второй
        else if (mode === 'modify_second') {
            let count = insertPointsIntoObjectGeometry(idx2, points);
            msg = `Точки добавлены в Объект 2 (${count} шт).`;
            updateObjectMetrics(userObjects[idx2]);
        }

        showNotification(msg, "success", "check-circle");
        
        // Если меняли геометрию, нужно сохранить историю для Undo (если бы мы были в режиме редактирования конкретного объекта, но тут глобальная операция)
        saveState();
        closeIntersectionDialog();
    }

    // Вспомогательная: Создать независимые точки
    function createIndependentPoints(points) {
        points.forEach(pt => {
            const name = `Точка ${nextObjectId}`;
            addObjectInternal([[{ x: pt.x, y: pt.y }]], name, 'point', true);
        });
        updateObjectList();
    }

    // Вспомогательная: Внедрение массива точек в геометрию объекта
   function insertPointsIntoObjectGeometry(objIndex, points) {
        const obj = userObjects[objIndex];
        if (!obj || !obj.contours) return 0;

        let totalInserted = 0;
        const tolerance = 0.01; // Допуск расстояния (в единицах карты)

        // Проходим по каждому контуру объекта
        for (let cIdx = 0; cIdx < obj.contours.length; cIdx++) {
            const oldContour = obj.contours[cIdx];
            if (!oldContour || oldContour.length < 2) continue;

            const newContour = [];
            const len = oldContour.length;
            // Определяем количество сегментов (для полигона замыкаем, для линии нет)
            const segmentCount = (obj.type === 'polygon') ? len : len - 1;

            for (let i = 0; i < segmentCount; i++) {
                const p1 = oldContour[i];
                const p2 = oldContour[(i + 1) % len]; // Следующая точка (с замыканием)

                // 1. Добавляем начало сегмента в новый контур
                newContour.push({ x: p1.x, y: p1.y });

                // 2. Ищем все точки пересечения, которые лежат на этом сегменте
                const pointsOnSegment = [];

                points.forEach(pt => {
                    // Проверка: лежит ли точка на отрезке p1-p2
                    if (isPointOnSegmentRobust(pt, p1, p2, tolerance)) {
                        // Проверка: не является ли точка дубликатом p1 или p2
                        const distToP1 = (pt.x - p1.x)**2 + (pt.y - p1.y)**2;
                        const distToP2 = (pt.x - p2.x)**2 + (pt.y - p2.y)**2;
                        
                        // Если точка достаточно далеко от краев, считаем её новой
                        if (distToP1 > tolerance && distToP2 > tolerance) {
                             // Проверяем, не добавили ли мы её уже в этот список (защита от дублей)
                            const alreadyAdded = pointsOnSegment.some(existing => 
                                (existing.x - pt.x)**2 + (existing.y - pt.y)**2 < 0.000001
                            );
                            if (!alreadyAdded) {
                                pointsOnSegment.push({ x: pt.x, y: pt.y });
                            }
                        }
                    }
                });

                // 3. Если нашли точки, их нужно отсортировать по удаленности от p1,
                // чтобы вставить в правильном порядке
                if (pointsOnSegment.length > 0) {
                    pointsOnSegment.sort((a, b) => {
                        const distA = (a.x - p1.x)**2 + (a.y - p1.y)**2;
                        const distB = (b.x - p1.x)**2 + (b.y - p1.y)**2;
                        return distA - distB;
                    });

                    // Добавляем отсортированные точки в новый контур
                    pointsOnSegment.forEach(pt => {
                        newContour.push(pt);
                        totalInserted++;
                    });
                }
            }

            // Для линии нужно добавить самую последнюю точку, так как цикл шел до len-1
            if (obj.type !== 'polygon') {
                const lastPt = oldContour[len - 1];
                newContour.push({ x: lastPt.x, y: lastPt.y });
            }

            // Заменяем старый контур на новый, обогащенный точками
            obj.contours[cIdx] = newContour;
        }

        return totalInserted;
    }

    // Вспомогательная: Надежная проверка попадания точки на отрезок
    function isPointOnSegmentRobust(p, a, b, tolerance) {
        // 1. Проверка по Bounding Box (грубая отсечка)
        const minX = Math.min(a.x, b.x) - tolerance;
        const maxX = Math.max(a.x, b.x) + tolerance;
        const minY = Math.min(a.y, b.y) - tolerance;
        const maxY = Math.max(a.y, b.y) + tolerance;

        if (p.x < minX || p.x > maxX || p.y < minY || p.y > maxY) {
            return false;
        }

        // 2. Расстояние от точки до прямой
        const distSq = pointLineDistSq(p.x, p.y, a.x, a.y, b.x, b.y);
        
        // Если расстояние меньше квадрата допуска, считаем, что попали
        return distSq < (tolerance * tolerance);
    }

    // Вспомогательная: лежит ли точка на сегменте (с допуском)
    function isPointOnSegment(p, a, b) {
        const crossProduct = (p.y - a.y) * (b.x - a.x) - (p.x - a.x) * (b.y - a.y);
        if (Math.abs(crossProduct) > 0.01) return false; // Не на одной прямой

        const dotProduct = (p.x - a.x) * (b.x - a.x) + (p.y - a.y) * (b.y - a.y);
        if (dotProduct < 0) return false; // За точкой a

        const squaredLengthBA = (b.x - a.x)*(b.x - a.x) + (b.y - a.y)*(b.y - a.y);
        if (dotProduct > squaredLengthBA) return false; // За точкой b

        return true;
    }

    // Получить плоский список сегментов для объекта
    function getAllSegments(obj) {
        const segments = [];
        if (!obj.contours) return segments;

        obj.contours.forEach(contour => {
            if (!contour || contour.length < 2) return;
            
            // Если полигон, замыкаем (проверяем последний с первым)
            // Если линия - нет.
            const len = contour.length;
            const loop = (obj.type === 'polygon');
            const limit = loop ? len : len - 1;

            for (let i = 0; i < limit; i++) {
                const p1 = contour[i];
                const p2 = contour[(i + 1) % len];
                segments.push({ p1: p1, p2: p2 });
            }
        });
        return segments;
    }
    
    
    //Split
    
function executeCutOperation(targetIdx, cutterIdx) {
        console.log(`[CUT-OP] Начинаем операцию Weiler-Atherton.`);
        const targetObj = userObjects[targetIdx];
        const cutterObj = userObjects[cutterIdx];

        if (!targetObj || !cutterObj) return;

        if (editingObjectIndex !== targetIdx) editingObjectIndex = targetIdx;
        saveGeometryStateForUndo(targetIdx);

        try {
            // 1. Предварительная очистка
            ensureClosed(targetObj.contours);
            ensureClosed(cutterObj.contours);

            // Работаем с копиями
            const subjectPolys = deepCloneContours(targetObj.contours);
            const clipperPolys = deepCloneContours(cutterObj.contours);

            let currentSubjectList = subjectPolys;

            clipperPolys.forEach(clipperRing => {
                if (clipperRing.length < 3) return;
                const nextPassList = [];
                currentSubjectList.forEach(subjectRing => {
                    const diff = computeDifference(subjectRing, clipperRing);
                    if (diff && diff.length > 0) {
                        nextPassList.push(...diff);
                    }
                });
                currentSubjectList = nextPassList;
            });

            // Присваиваем результат
            targetObj.contours = currentSubjectList;

            // 2. ФИНАЛЬНАЯ ЧИСТКА (Удаление дублей и микро-полигонов)
            console.log("[DEBUG-CLEAN] Запуск финальной очистки...");
            cleanObjectContours(targetObj);
            
            if (targetObj.contours.length === 0) {
                showNotification("Объект исчез в результате резки.", "warning");
            } else {
                updateObjectMetrics(targetObj);
                showNotification("Рассечение выполнено.", "success", "cut");
            }
            
            // ЛОГ РЕЗУЛЬТАТА
            targetObj.contours.forEach((c, i) => {
                console.log(`[DEBUG-RESULT] Контур #${i}: ${c.length} точек.`);
            });

            displayObjectInfo(targetIdx);
            redraw(true);

        } catch (e) {
            console.error("CUT ERROR:", e);
            showNotification("Ошибка: " + e.message, "error");
        }
    }

    // --- УЛУЧШЕННАЯ ФУНКЦИЯ ОЧИСТКИ ---

    function cleanObjectContours(obj) {
        if (!obj.contours) return;
        
        const validContours = [];
        
        obj.contours.forEach((contour, cIdx) => {
            if (!contour || contour.length === 0) return;
            
            // Шаг 1: Удаляем соседние дубликаты
            const unique = [];
            unique.push(contour[0]);
            
            for (let i = 1; i < contour.length; i++) {
                const prev = unique[unique.length - 1];
                const curr = contour[i];
                // Дистанция > 1мм
                if ((prev.x - curr.x)**2 + (prev.y - curr.y)**2 > 0.000001) {
                    unique.push(curr);
                }
            }

            // Шаг 2: Проверка на вырожденность (минимум 3 уникальные точки для полигона)
            let checkPoly = [...unique];
            if (checkPoly.length > 1) {
                const f = checkPoly[0];
                const l = checkPoly[checkPoly.length - 1];
                if ((f.x - l.x)**2 + (f.y - l.y)**2 < 0.000001) {
                    checkPoly.pop();
                }
            }

            if (checkPoly.length < 3) {
                console.log(`[DEBUG-CLEAN] Контур #${cIdx} удален: мало точек.`);
                return; 
            }

            // Шаг 3: Проверка ПЛОЩАДИ
            let area = 0;
            for (let i = 0; i < checkPoly.length; i++) {
                const p1 = checkPoly[i];
                const p2 = checkPoly[(i + 1) % checkPoly.length];
                area += (p1.x * p2.y - p2.x * p1.y);
            }
            area = Math.abs(area / 2.0);

            if (area < 0.0001) { 
                console.log(`[DEBUG-CLEAN] Контур #${cIdx} удален: микро-площадь.`);
                return; 
            }

            // Замыкаем корректно
            const first = unique[0];
            const last = unique[unique.length - 1];
            if ((first.x - last.x)**2 + (first.y - last.y)**2 > 0.000001) {
                unique.push({ x: first.x, y: first.y });
            }
            
            validContours.push(unique);
        });

        obj.contours = validContours;
    }

    function ensureClosed(contours) {
        contours.forEach(c => {
            if (c.length > 2) {
                const first = c[0];
                const last = c[c.length - 1];
                if ((first.x - last.x)**2 + (first.y - last.y)**2 > 0.000001) {
                    c.push({ x: first.x, y: first.y });
                }
            }
        });
    }

    function deepCloneContours(contours) {
        if (!contours) return [];
        return contours.map(contour => {
            if (!contour) return null;
            return contour.map(p => (p ? { ...p } : null));
        });
    }

    // --- АЛГОРИТМ РАЗНОСТИ ---

function computeDifference(subject, clipper) {
        const intersections = findIntersectionsRobust(subject, clipper);
        
        if (intersections.length === 0) {
            // 1. Если Исходный объект полностью внутри Резака -> удаляем его (возвращаем пусто)
            if (isPointInPolygonRobust(subject[0], clipper)) return [];
            
            // 2. ИЗМЕНЕНИЕ: Если Резак полностью внутри Исходного объекта -> возвращаем оба контура
            // Система отрисовки и расчета площади сама поймет, что внутренний контур — это дырка
            if (isPointInPolygonRobust(clipper[0], subject)) {
                // Возвращаем [Внешний, Дырка]
                // Копируем массивы для безопасности
                return [ [...subject], [...clipper] ];
            }

            // 3. Если пересечений и вложенности нет -> возвращаем исходный объект как есть
            return [subject];
        }

        const subjWithInt = insertPointsAndMark(subject, intersections, true);
        const clipWithInt = insertPointsAndMark(clipper, intersections, false);

        const subjArcs = splitByIntersections(subjWithInt);
        const clipArcs = splitByIntersections(clipWithInt);

        const finalArcs = [];

        // Дуги цели (снаружи резака)
        subjArcs.forEach(arc => {
            const mid = getArcMidpoint(arc);
            if (!isPointInPolygonRobust(mid, clipper, false)) { 
                finalArcs.push(arc);
            }
        });

        // Дуги резака (внутри цели) - РАЗВОРОТ
        clipArcs.forEach(arc => {
            const mid = getArcMidpoint(arc);
            if (isPointInPolygonRobust(mid, subject, true)) {
                finalArcs.push(arc.reverse());
            }
        });

        return stitchArcs(finalArcs);
    }

    function findIntersectionsRobust(poly1, poly2) {
        const intersects = [];
        for (let i = 0; i < poly1.length - 1; i++) {
            for (let j = 0; j < poly2.length - 1; j++) {
                const p1 = poly1[i]; const p2 = poly1[i + 1];
                const q1 = poly2[j]; const q2 = poly2[j + 1];
                
                // Используем восстановленное имя getSegmentIntersection
                const pt = getSegmentIntersection(p1, p2, q1, q2);
                if (pt) {
                    intersects.push({
                        p: pt,
                        sIdx: i,
                        cIdx: j
                    });
                }
            }
        }
        return intersects;
    }

    // --- ВОССТАНОВЛЕНО ИМЯ getSegmentIntersection ---
    function getSegmentIntersection(p1, p2, q1, q2) {
        const d1x = p2.x - p1.x; const d1y = p2.y - p1.y;
        const d2x = q2.x - q1.x; const d2y = q2.y - q1.y;
        const det = d1x * d2y - d1y * d2x;
        if (Math.abs(det) < 1e-9) return null;

        const rX = q1.x - p1.x; const rY = q1.y - p1.y;
        const t = (rX * d2y - rY * d2x) / det;
        const u = (rX * d1y - rY * d1x) / det;

        const EPS = 1e-5;
        if (t >= -EPS && t <= 1 + EPS && u >= -EPS && u <= 1 + EPS) {
            return { x: p1.x + t * d1x, y: p1.y + t * d1y };
        }
        return null;
    }

    function insertPointsAndMark(poly, intersections, isSubject) {
        const result = [];
        for (let i = 0; i < poly.length - 1; i++) {
            const p1 = poly[i];
            result.push({ x: p1.x, y: p1.y, isIntersection: false });

            const hits = intersections.filter(it => (isSubject ? it.sIdx : it.cIdx) === i);
            hits.sort((a,b) => ((a.p.x - p1.x)**2 + (a.p.y - p1.y)**2) - ((b.p.x - p1.x)**2 + (b.p.y - p1.y)**2));

            hits.forEach(hit => {
                const last = result[result.length - 1];
                if ((hit.p.x - last.x)**2 + (hit.p.y - last.y)**2 > 0.000001) {
                    result.push({ x: hit.p.x, y: hit.p.y, isIntersection: true });
                }
            });
        }
        const first = poly[0];
        result.push({ x: first.x, y: first.y, isIntersection: false });
        return result;
    }

    function splitByIntersections(pointsWithFlags) {
        const arcs = [];
        let startIndex = pointsWithFlags.findIndex(p => p.isIntersection);
        
        if (startIndex === -1) return [pointsWithFlags.map(p => ({x:p.x, y:p.y}))];

        const uniquePoints = pointsWithFlags.slice(0, pointsWithFlags.length - 1);
        const rotated = [
            ...uniquePoints.slice(startIndex),
            ...uniquePoints.slice(0, startIndex),
            uniquePoints[startIndex]
        ];
        
        let currentArc = [{x: rotated[0].x, y: rotated[0].y}];
        
        for (let i = 1; i < rotated.length; i++) {
            const p = rotated[i];
            currentArc.push({x: p.x, y: p.y});
            
            if (p.isIntersection && i < rotated.length) {
                arcs.push(currentArc);
                currentArc = [{x: p.x, y: p.y}];
            }
        }
        return arcs;
    }

    function getArcMidpoint(arc) {
        const midIdx = Math.floor(arc.length / 2);
        if (arc.length === 2) {
             return { x: (arc[0].x + arc[1].x)/2, y: (arc[0].y + arc[1].y)/2 };
        }
        const p1 = arc[midIdx-1] || arc[0];
        const p2 = arc[midIdx];
        return { x: (p1.x + p2.x)/2, y: (p1.y + p2.y)/2 };
    }

    function stitchArcs(arcs) {
        if (arcs.length === 0) return [];
        
        const polygons = [];
        const used = new Array(arcs.length).fill(false);
        const tolerance = 0.0001; 

        while(true) {
            const startIdx = used.findIndex(u => !u);
            if (startIdx === -1) break;

            const poly = [];
            let currIdx = startIdx;
            let watchdog = 0;
            
            while (currIdx !== -1 && !used[currIdx] && watchdog < arcs.length * 2) {
                used[currIdx] = true;
                const arc = arcs[currIdx];
                watchdog++;
                
                poly.push(...arc.slice(0, arc.length - 1));
                
                const tail = arc[arc.length - 1];
                
                let nextIdx = -1;
                for (let i = 0; i < arcs.length; i++) {
                    if (!used[i]) {
                        const head = arcs[i][0];
                        if ((head.x - tail.x)**2 + (head.y - tail.y)**2 < tolerance) {
                            nextIdx = i;
                            break;
                        }
                    }
                }
                
                if (nextIdx !== -1) {
                    currIdx = nextIdx;
                } else {
                    poly.push(tail);
                    const first = poly[0];
                    if ((first.x - tail.x)**2 + (first.y - tail.y)**2 > tolerance) {
                        poly.push({x: first.x, y: first.y});
                    }
                    currIdx = -1;
                }
            }
            if (poly.length >= 3) polygons.push(poly);
        }
        return polygons;
    }

   function saveProjectToJson() {
        if (userObjects.length === 0) {
            showNotification("Проект пуст. Нет объектов для сохранения.", "warning");
            return;
        }

        try {
            const projectData = {
                version: "1.0",
                timestamp: new Date().toISOString(),
                app: "GeoEditor",
                state: {
                    userObjects: userObjects,
                    nextObjectId: nextObjectId,
                    nextColorIndex: nextColorIndex,
                    showPoints: showPoints,
                    view: {
                        scale: scale,
                        offsetX: offsetX,
                        offsetY: offsetY,
                        minX: minX,
                        minY: minY,
                        maxX: maxX,
                        maxY: maxY
                    }
                }
            };

            const jsonString = JSON.stringify(projectData, null, 2);
            const blob = new Blob([jsonString], { type: "application/json" });
            const url = URL.createObjectURL(blob);
            
            const now = new Date();
            const dateStr = now.toISOString().slice(0,10);
            const timeStr = now.toTimeString().slice(0,8).replace(/:/g, '-');
            const fileName = `geo_project_${dateStr}_${timeStr}.geoed`;

            const a = document.createElement('a');
            a.href = url;
            a.download = fileName;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);

            showNotification("Проект успешно сохранен!", "success", "file-download");
            closeCoordsDialog();

        } catch (e) {
            console.error("Ошибка сохранения проекта:", e);
            showNotification("Ошибка при сохранении файла.", "error");
        }
    }

function loadProjectFromJson(event) {
        const file = event.target.files[0];
        if (!file) return;

        const reader = new FileReader();
        
        // ДОБАВЛЕНО async
        reader.onload = async function(e) {
            try {
                const jsonContent = e.target.result;
                const projectData = JSON.parse(jsonContent);

                if (!projectData || !projectData.state || !Array.isArray(projectData.state.userObjects)) {
                    throw new Error("Неверный формат файла проекта.");
                }

                // ЗАМЕНА confirm НА showCustomConfirm
                const confirmed = await showCustomConfirm(
                    "Загрузка проекта",
                    "Загрузка проекта заменит все текущие объекты. Продолжить?"
                );

                if (confirmed) {
                    const state = projectData.state;
                    
                    userObjects = state.userObjects;
                    nextObjectId = state.nextObjectId || 1;
                    nextColorIndex = state.nextColorIndex || 0;
                    showPoints = state.showPoints !== undefined ? state.showPoints : true;

                    if (state.view) {
                        scale = state.view.scale || 1;
                        offsetX = state.view.offsetX || 0;
                        offsetY = state.view.offsetY || 0;
                        minX = state.view.minX;
                        minY = state.view.minY;
                        maxX = state.view.maxX;
                        maxY = state.view.maxY;
                    } else {
                        calculateBounds();
                        resetView();
                    }

                    selectedObjectIndex = -1;
                    editingObjectIndex = -1;
                    isGeometryEditMode = false;
                    geometryHistory = [];

                    updateObjectList();
                    displayObjectInfo(-1);
                    updateToggleButtonStates();
                    updateViewInfo();
                    
                    redraw(true); 
                    saveState();
                    
                    showNotification(`Проект загружен. Объектов: ${userObjects.length}`, "success", "folder-open");
                    closeCoordsDialog();
                }
            } catch (err) {
                console.error("Ошибка загрузки проекта:", err);
                showNotification("Ошибка чтения файла: " + err.message, "error");
            } finally {
                event.target.value = ''; 
            }
        };

        reader.onerror = function() {
            showNotification("Ошибка чтения файла.", "error");
        };

        reader.readAsText(file);
    }
    

    function isPointInPolygonRobust(pt, poly, boundaryResult = false) {
        let inside = false;
        const rx = pt.x; const ry = pt.y;
        
        for (let i = 0, j = poly.length - 1; i < poly.length; j = i++) {
            const xi = poly[i].x; const yi = poly[i].y;
            const xj = poly[j].x; const yj = poly[j].y;

            // Проверка на попадание точно в ребро
            const dist = pointLineDistSq(rx, ry, xi, yi, xj, yj);
            if (dist < 1e-10) return boundaryResult;
            
            const intersect = ((yi > ry) !== (yj > ry)) &&
                (rx < (xj - xi) * (ry - yi) / (yj - yi) + xi);
            if (intersect) inside = !inside;
        }
        return inside;
    }

    function pointLineDistSq(px, py, x1, y1, x2, y2) {
        const A = px - x1; const B = py - y1;
        const C = x2 - x1; const D = y2 - y1;
        const dot = A * C + B * D;
        const lenSq = C * C + D * D;
        let param = -1;
        if (lenSq !== 0) param = dot / lenSq;
        let xx, yy;
        if (param < 0) { xx = x1; yy = y1; }
        else if (param > 1) { xx = x2; yy = y2; }
        else { xx = x1 + param * C; yy = y1 + param * D; }
        const dx = px - xx; const dy = py - yy;
        return dx * dx + dy * dy;
    }
    
    function toggleLabelsVisibility() {
        showLabels = !showLabels;
        redraw(true);
        updateToggleButtonStates();
        saveState();
    }

function drawCoordinateLabels(ctx) {
        if (!userObjects || userObjects.length === 0) return;
        // УДАЛЕНО: if (obj.visible === false) return; (вызывало ошибку ReferenceError)

        ctx.save();
        ctx.setTransform(1, 0, 0, 1, 0, 0);
        // Используем monospace для ровного выравнивания цифр
        ctx.font = "11px monospace";
        ctx.textBaseline = "bottom";
        ctx.textAlign = "left"; // Всегда рисуем слева направо для предсказуемости

        const occupiedRects = [];
        const drawnPoints = new Set();
        const padding = 5;       // Отступ текста от начала линии
        const leaderLength = 40; // Длина наклонной линии
        
        // Углы: СВ, СЗ, ЮВ, ЮЗ
        const angles = [ -Math.PI / 4, -3 * Math.PI / 4, Math.PI / 4, 3 * Math.PI / 4 ];

        userObjects.forEach(obj => {
            // ДОБАВЛЕНО: Проверка видимости перенесена внутрь цикла
            if (obj.visible === false) return;

            if (!obj.contours) return;
            obj.contours.forEach(contour => {
                if (!contour) return;
                contour.forEach(pt => {
                    if (!pt || !isFinite(pt.x) || !isFinite(pt.y)) return;

                    const pointKey = `${pt.x.toFixed(3)}_${pt.y.toFixed(3)}`;
                    if (drawnPoints.has(pointKey)) return;
                    drawnPoints.add(pointKey);

                    const [cx, cy] = transformCoord(pt.x, pt.y);
                    
                    if (cx < -50 || cy < -50 || cx > canvas.width + 50 || cy > canvas.height + 50) return;

                    const textX = `X: ${pt.x.toFixed(2)}`;
                    const textY = `Y: ${pt.y.toFixed(2)}`;
                    
                    // Вычисляем точную ширину самой длинной строки
                    const widthX = ctx.measureText(textX).width;
                    const widthY = ctx.measureText(textY).width;
                    const maxTextWidth = Math.max(widthX, widthY);
                    
                    // Длина полки равна ширине текста + отступы по краям
                    const shelfLen = maxTextWidth + (padding * 2); 
                    const boxHeight = 30;

                    let bestPos = null;

                    for (let angle of angles) {
                        const isRightSide = Math.abs(angle) < Math.PI / 2;
                        
                        const elbowX = cx + Math.cos(angle) * leaderLength;
                        const elbowY = cy + Math.sin(angle) * leaderLength;
                        
                        // Если справа: бокс начинается от локтя
                        // Если слева: бокс начинается (локоть - ширина)
                        const rectX = isRightSide ? elbowX : (elbowX - shelfLen);
                        const rectY = elbowY - boxHeight;

                        const currentRect = { x: rectX, y: rectY, w: shelfLen, h: boxHeight };
                        
                        let collision = false;
                        for (let occ of occupiedRects) {
                            // Простая проверка пересечения прямоугольников
                            if (currentRect.x < occ.x + occ.w &&
                                currentRect.x + currentRect.w > occ.x &&
                                currentRect.y < occ.y + occ.h &&
                                currentRect.y + currentRect.h > occ.y) {
                                collision = true;
                                break;
                            }
                        }

                        if (!collision) {
                            bestPos = { angle, elbowX, elbowY, isRightSide, rect: currentRect, shelfLen };
                            break; 
                        }
                    }

                    // Дефолтная позиция (СВ), если всё занято
                    if (!bestPos) {
                        const angle = -Math.PI / 4;
                        const elbowX = cx + Math.cos(angle) * leaderLength;
                        const elbowY = cy + Math.sin(angle) * leaderLength;
                        const isRightSide = true;
                        bestPos = { 
                            angle, elbowX, elbowY, isRightSide, shelfLen,
                            rect: { x: elbowX, y: elbowY - boxHeight, w: shelfLen, h: boxHeight } 
                        };
                    }

                    occupiedRects.push(bestPos.rect);

                    // --- ОТРИСОВКА ---
                    
                    // 1. Линии
                    ctx.strokeStyle = '#333';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.setLineDash([3, 2]); // Пунктир
                    
                    ctx.moveTo(cx, cy);
                    ctx.lineTo(bestPos.elbowX, bestPos.elbowY);
                    
                    // Вычисляем конец полки
                    const shelfEndX = bestPos.isRightSide 
                        ? (bestPos.elbowX + bestPos.shelfLen) 
                        : (bestPos.elbowX - bestPos.shelfLen);
                        
                    ctx.lineTo(shelfEndX, bestPos.elbowY);
                    ctx.stroke();
                    ctx.setLineDash([]); // Сброс пунктира

                    // 2. Фон под текстом (для читаемости)
                    ctx.globalAlpha = 0.7;
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.9)'; // Чуть более непрозрачный
                    // Рисуем фон чуть выше линии
                    ctx.fillRect(bestPos.rect.x, bestPos.rect.y, bestPos.rect.w, bestPos.rect.h);
                    ctx.globalAlpha = 1.0;

                    // 3. Текст
                    ctx.fillStyle = '#000';
                    
                    // Определяем начало текста. 
                    // Если справа: от локтя + отступ.
                    // Если слева: от левого края полки + отступ.
                    const textStartX = bestPos.isRightSide 
                        ? (bestPos.elbowX + padding) 
                        : (shelfEndX + padding);

                    // Y смещения: -4px (нижняя строка), -16px (верхняя строка)
                    ctx.fillText(textY, textStartX, bestPos.elbowY - 4);
                    ctx.fillText(textX, textStartX, bestPos.elbowY - 16);
                    
                    // 4. Точка привязки
                    ctx.beginPath();
                    ctx.arc(cx, cy, 2, 0, Math.PI * 2);
                    ctx.fill();
                });
            });
        });

        ctx.restore();
    }
    


    document.addEventListener('DOMContentLoaded', initializeApp);

</script>
</body>
</html>