<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Межевой/Технический план</title>
    <script src="webfonts/jszip.min.js"></script>
    <script src="webfonts/proj4.js"></script>
    <script src="sk.js"></script>
    <script src="msk.js"></script>
    <link rel="stylesheet" href="webfonts/all.min.css">
    <link id="favicon" rel="icon" href="img/mpch.png" type="image/png">
    <style>
        :root {
            --primary-color: #2563eb;
            --secondary-color: #f8fafc;
            --accent-color: #0ea5e9;
            --success-color: #10b981;
            --warning-color: #f97316;
            --error-color: #ef4444;
            --info-color: #8b5cf6;
            --text-primary: #1e293b;
            --text-secondary: #64748b;
            --border-color: #e2e8f0;
            --shadow-sm: 0 1px 2px 0 rgb(0 0 0 / 0.05);
            --shadow-md: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            line-height: 1.6;
            background-color: #f0f4f8;
            color: var(--text-primary);
        }
        .container {
            max-width: 1800px;
            margin: 20px auto;
            background: white;
            border-radius: 16px;
            box-shadow: var(--shadow-lg);
            overflow: hidden;
        }
        .content { padding: 24px; }
        .file-upload-section {
            background: var(--secondary-color);
            border-radius: 12px;
            padding: 12px;
            margin-bottom: 20px;
            border: 2px dashed var(--border-color);
            transition: all 0.3s ease;
        }
        .file-upload-area {
            text-align: center;
            cursor: pointer;
            padding: 12px 16px;
            border-radius: 8px;
            transition: all 0.3s ease;
            position: relative;
            user-select: none;
        }
        .file-upload-area:hover { background: white; transform: translateY(-2px); box-shadow: var(--shadow-sm); }
        .file-upload-area.dragover { background: #dbeafe !important; border-color: var(--primary-color) !important; }
        .file-upload-section.dragover { border-color: var(--primary-color); background: #f0f9ff; }
        .upload-icon { margin-bottom: 8px; line-height: 1; }
        .upload-icon img { width: 48px; height: 48px; object-fit: contain; }
        .upload-text { font-size: 1.1rem; font-weight: 600; color: var(--text-primary); margin-bottom: 4px; }
        .upload-subtext { color: var(--text-secondary); font-size: 0.9rem; }
        #fileInput { display: none; }
        .status-container {
            text-align: center; margin: 24px 0; min-height: 60px;
            display: flex; align-items: center; justify-content: center; gap: 16px;
        }
        .loader {
            width: 32px; height: 32px; border: 3px solid #f3f4f6;
            border-top: 3px solid var(--primary-color); border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        .status-text { font-size: 1.1rem; font-weight: 500; color: var(--text-secondary); }
        .hidden { display: none; }
        #resultsContainer {
            display: grid;
            grid-template-columns: 2fr 1.2fr;
            gap: 24px;
            align-items: start;
        }
        #mainColumn, #sidebarColumn {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        .section {
            background: white; border-radius: 12px;
            border: 1px solid var(--border-color); box-shadow: var(--shadow-sm); overflow: hidden;
            width: 100%;
            margin-bottom: 0;
        }
        .section-header {
            background: linear-gradient(135deg, #f8fafc 0%, #eef2f7 100%);
            padding: 16px 20px; border-bottom: 1px solid var(--border-color);
            display: flex;
            align-items: center;
            gap: 12px;
        }
        .section-icon {
            width: 24px;
            height: 24px;
            color: var(--primary-color);
            flex-shrink: 0;
        }
        .section-title { font-size: 1.3rem; font-weight: 600; color: var(--text-primary); margin: 0; }
        .header-button {
            margin-left: auto;
            padding: 4px; border-radius: 6px;
            transition: all 0.2s; cursor: pointer;
            display: flex; align-items: center;
            border: none; background: transparent;
            color: var(--primary-color);
        }
        .header-button:hover { background-color: var(--border-color); transform: scale(1.1); }
        .header-button i { font-size: 20px; }
        .info-grid {
            display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 16px; margin-bottom: 16px;
        }
        .info-card {
            background: var(--secondary-color); border-radius: 8px; padding: 16px;
            border: 1px solid var(--border-color);
        }
        .info-label {
            font-size: 0.85rem; font-weight: 600; color: var(--text-secondary);
            text-transform: uppercase; letter-spacing: 0.5px; margin-bottom: 4px;
        }
        .info-value { font-size: 1rem; color: var(--text-primary); font-weight: 500; }
        .info-value code {
            background: #e2e8f0; padding: 2px 6px; border-radius: 4px;
            font-family: 'Courier New', monospace; font-size: 0.95rem;
        }
        .data-table {
            width: 100%; border-collapse: collapse; margin-top: 16px;
            border-radius: 8px; overflow: hidden; box-shadow: var(--shadow-sm);
        }
        .data-table th, .data-table td {
            padding: 12px 16px;
            border-bottom: 1px solid var(--border-color);
            vertical-align: middle;
            text-align: center;
        }
        .data-table th {
            background: var(--primary-color); color: white;
            font-weight: 600; font-size: 0.9rem;
        }
        .data-table tbody tr:hover { background: var(--secondary-color); }
        .data-table tbody tr:last-child td { border-bottom: none; }
        .data-table td:first-child, .data-table .left-align { text-align: left; }
        .data-table .no-wrap { white-space: nowrap; }
        .coord-table td:first-child { text-align: center; font-weight: 600; }
        .coord-table td:nth-child(4) { text-align: left; }
        .data-table.lengths-table td:first-child { text-align: center; }
        .address-display {
            background: linear-gradient(135deg, #f0f9ff 0%, #e0f2fe 100%);
            border: 1px solid #bae6fd; border-radius: 8px; padding: 16px;
            font-size: 1.1rem; font-weight: 500; color: var(--text-primary);
        }
        .conclusion-text {
            background: #f8fafc; border: 1px solid var(--border-color); border-radius: 8px;
            padding: 16px; font-size: 0.95rem;
            line-height: 1.5; white-space: pre-wrap; word-wrap: break-word;
        }
        .error-message {
            background: #fef2f2; border: 1px solid #fecaca; border-radius: 8px;
            padding: 16px; color: var(--error-color); font-weight: 500; text-align: center;
        }
        .subsection { margin-top: 24px; }
        .subsection-title {
            font-size: 1.1rem; font-weight: 600; color: var(--text-primary);
            margin-bottom: 12px; padding-bottom: 8px; border-bottom: 2px solid var(--border-color);
        }
        .file-name {
            font-family: 'Courier New', monospace; background: #e2e8f0; padding: 2px 6px;
            border-radius: 4px; font-size: 0.95rem;
        }
        #printButtonContainer {
            text-align: center; margin-bottom: 20px;
            display: flex; justify-content: center; gap: 16px;
        }
        .print-btn {
            background-color: var(--primary-color); color: white; border: none;
            padding: 12px 24px; border-radius: 8px; font-size: 1rem;
            font-weight: 600; cursor: pointer; display: inline-flex;
            align-items: center; gap: 10px; transition: all 0.2s ease;
            box-shadow: var(--shadow-md);
        }
        .print-btn:hover {
            background-color: #1d4ed8; box-shadow: var(--shadow-lg);
            transform: translateY(-2px);
        }
        .print-btn svg, .print-btn i { width: 20px; height: 20px; }
        .docs-btn { background-color: #22c55e; }
        .docs-btn:hover { background-color: #16a34a; }
        .paste-btn { background-color: var(--warning-color); }
        .paste-btn:hover { background-color: #ea580c; }
        .contradiction-btn { background-color: var(--info-color); }
        .contradiction-btn:hover { background-color: #7c3aed; }
        .validation-message {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px 16px;
            border-radius: 8px;
            margin-top: 12px;
            font-weight: 500;
        }
        .validation-message:first-child { margin-top: 0; }
        .validation-message .icon { width: 24px; height: 24px; flex-shrink: 0; }
        .validation-error { background-color: #fef2f2; border: 1px solid #fecaca; color: #b91c1c; }
        .validation-warning { background-color: #fffbeb; border: 1px solid #fde68a; color: #b45309; }
        .validation-success { background-color: #f0fdf4; border: 1px solid #bbf7d0; color: #15803d; }
        #cadastralNumbersList {
            list-style-type: none; padding-left: 0;
            display: flex; flex-wrap: wrap; gap: 8px;
        }
        #cadastralNumbersList li {
            padding: 4px 10px; border-radius: 6px; font-family: 'Courier New', monospace;
            border: 1px solid;
        }
        .doc-check-list { list-style: none; padding: 0; margin-top: 12px; }
        .doc-check-list li { display: flex; align-items: center; gap: 8px; padding: 4px 0; font-weight: 500; }
        .doc-check-list .fa-check-circle { color: var(--success-color); }
        .doc-check-list .fa-times-circle { color: var(--error-color); }
        .contradiction-table {
            width: 100%;
            border-collapse: separate;
            border-spacing: 0;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            overflow: hidden;
            box-shadow: var(--shadow-sm);
        }
        .contradiction-table th, .contradiction-table td {
            padding: 12px;
            text-align: left;
            border-bottom: 1px solid var(--border-color);
        }
        .contradiction-table th {
            background-color: var(--info-color);
            color: white;
            font-weight: 600;
        }
        .contradiction-table td {
            font-size: 0.9rem;
            vertical-align: top;
        }
        .contradiction-table tbody tr:last-child td { border-bottom: none; }
        .contradiction-table tbody tr:nth-child(even) { background-color: #f8fafc; }
        .contradiction-table td:nth-child(1) { font-weight: bold; color: var(--text-primary); }
        .contradiction-table td:nth-child(3), .contradiction-table td:nth-child(5) {
            font-family: 'Courier New', monospace;
            background-color: #f1f5f9;
            border-radius: 4px;
            padding: 8px;
            word-break: break-word;
        }
        .contradiction-table .source-label {
            font-size: 0.8rem;
            color: var(--text-secondary);
            font-weight: 600;
            display: block;
            margin-bottom: 4px;
        }
        .modal-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background-color: rgba(30, 41, 59, 0.6);
            justify-content: center; align-items: center;
            z-index: 1000; padding: 20px;
            display: none;
        }
        .ai-modal-content {
            background-color: white; padding: 24px; border-radius: 16px;
            box-shadow: var(--shadow-lg);
            width: 90%; height: 85%; max-width: 900px;
            display: flex; flex-direction: column; position: relative;
        }
        .ai-modal-header {
            display: flex; justify-content: space-between; align-items: center;
            padding-bottom: 12px; border-bottom: 1px solid var(--border-color); margin-bottom: 16px;
        }
        .ai-modal-header h2 {
            font-size: 1.5rem; color: var(--text-primary); width: 100%; text-align: center;
            padding-left: 24px;
        }
        .ai-modal-close-button {
            font-size: 2rem; font-weight: bold; color: var(--text-secondary);
            cursor: pointer; line-height: 1; padding: 0 5px;
            transition: color 0.2s;
        }
        .ai-modal-close-button:hover { color: var(--text-primary); }
        #aiCheckResultDisplay { flex-grow: 1; overflow-y: auto; font-size: 1rem; line-height: 1.6; color: var(--text-primary); }
        .ai-spinner { display: flex; align-items: center; justify-content: center; gap: 16px; color: var(--text-secondary); font-size: 1.1rem; height: 100%; }
        .ai-feedback { white-space: pre-wrap; margin-bottom: 16px; background-color: #f8fafc; padding: 12px; border-radius: 8px; border: 1px solid var(--border-color); }
        .ai-corrected-text { background-color: #f0fdf4; color: #064e3b; padding: 12px; border: 1px solid #bbf7d0; border-radius: 8px; white-space: pre-wrap; font-family: 'Courier New', monospace; }
        .ai-modal-content h4 { font-size: 1.1rem; font-weight: 600; margin-bottom: 10px; color: var(--text-primary); display: flex; align-items: center; justify-content: center; gap: 8px; }
        .ai-modal-content h4 i { font-size: 1.2em; background: linear-gradient(135deg, #2563eb, #0ea5e9); -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text; text-fill-color: transparent; }
        .ai-copy-button { margin-top: 16px; background-color: var(--success-color); color: white; border: none; padding: 10px 20px; border-radius: 8px; font-size: 1rem; font-weight: 500; cursor: pointer; display: inline-flex; align-items: center; gap: 8px; transition: background-color 0.2s ease; }
        .ai-copy-button:hover { background-color: #059669; }
        .ai-copy-button:disabled { background-color: var(--text-secondary); cursor: not-allowed; }
        .ai-copy-button i { font-size: 1rem; }
        .ai-result-error { color: var(--error-color); font-weight: 500; }
        .ai-result-success { color: var(--success-color); font-weight: 500; display: flex; align-items: center; gap: 8px; font-size: 1.1rem; }
        .ai-modal-controls { display: flex; align-items: center; gap: 10px; position: absolute; top: 16px; right: 16px; }
        .ai-modal-minimize-button { font-size: 1.1rem; font-weight: bold; color: var(--text-secondary); cursor: pointer; line-height: 1; padding: 5px; transition: color 0.2s, transform 0.2s; }
        .ai-modal-minimize-button:hover { color: var(--text-primary); transform: scale(1.1); }
        .ai-modal-overlay.minimized { background: none; pointer-events: none; align-items: flex-end; justify-content: flex-end; }
        .ai-modal-overlay.minimized .ai-modal-content { height: auto; width: 350px; min-height: 0; box-shadow: var(--shadow-lg); cursor: pointer; pointer-events: auto; transition: all 0.3s ease-in-out; }
        .ai-modal-overlay.minimized #aiCheckResultDisplay { display: none; }
        .ai-modal-overlay.minimized .ai-modal-minimize-button i::before { content: "\f2d0"; }
        .docs-modal-content {
            background-color: white; padding: 24px; border-radius: 16px;
            box-shadow: var(--shadow-lg);
            width: 90%; max-width: 600px;
            display: flex; flex-direction: column;
        }
        .docs-modal-header {
            display: flex; justify-content: space-between; align-items: center;
            padding-bottom: 12px; border-bottom: 1px solid var(--border-color); margin-bottom: 16px;
        }
        .docs-modal-header h2 { font-size: 1.5rem; color: var(--text-primary); }
        #docsListTextarea {
            width: 100%; min-height: 200px; flex-grow: 1;
            padding: 12px; border-radius: 8px; border: 1px solid var(--border-color);
            font-family: 'Courier New', monospace; font-size: 1rem; line-height: 1.5;
            resize: vertical;
        }
        .docs-modal-footer { margin-top: 16px; display: flex; justify-content: flex-end; gap: 12px; }
        .docs-modal-btn {
            padding: 10px 20px; font-size: 1rem; font-weight: 500;
            border-radius: 8px; border: none; cursor: pointer;
            transition: all 0.2s ease;
        }
        #saveDocsListBtn { background-color: var(--primary-color); color: white; }
        #saveDocsListBtn:hover { background-color: #1d4ed8; }
        .docs-modal-close-button { background-color: var(--secondary-color); color: var(--text-primary); border: 1px solid var(--border-color); }
        .docs-modal-close-button:hover { background-color: var(--border-color); }
        .oks-schema-modal-content {
            background-color: white;
            padding: 0;
            border-radius: 16px;
            box-shadow: var(--shadow-lg);
            width: 95%;
            max-width: 900px;
            max-height: 90vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        .oks-schema-modal-header {
            display: flex;
            align-items: center;
            gap: 16px;
            padding: 16px 24px;
            background: linear-gradient(135deg, #f8fafc 0%, #eef2f7 100%);
            border-bottom: 1px solid var(--border-color);
        }
        .oks-schema-modal-header h2 {
            font-size: 1.25rem;
            color: var(--text-primary);
            margin: 0;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .oks-schema-modal-header h2 i {
            color: var(--primary-color);
        }
        .oks-schema-legend {
            display: flex;
            gap: 16px;
            margin-left: auto;
            margin-right: 16px;
            flex-wrap: wrap;
        }
        .legend-item {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 0.9rem;
            color: var(--text-secondary);
        }
        .legend-color {
            width: 20px;
            height: 4px;
            border-radius: 2px;
        }
        .oks-schema-modal-body {
            padding: 16px;
            flex-grow: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            background: #f8fafc;
            min-height: 400px;
        }
        #oksSchemaCanvas {
            border: 1px solid var(--border-color);
            border-radius: 8px;
            background: white;
            max-width: 100%;
        }
        .oks-schema-info {
            padding: 12px 24px;
            background: var(--secondary-color);
            border-top: 1px solid var(--border-color);
            font-size: 0.9rem;
            color: var(--text-secondary);
            max-height: 200px;
            overflow-y: auto;
        }
        .oks-schema-info .oks-info-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 4px 0;
        }
        .oks-schema-info .oks-info-item .color-marker {
            width: 12px;
            height: 12px;
            border-radius: 3px;
            flex-shrink: 0;
        }
        .oks-missing-warning {
            background: #fef3c7;
            border: 1px solid #f59e0b;
            border-radius: 8px;
            padding: 12px 16px;
            margin-top: 12px;
            color: #92400e;
        }
        .oks-missing-warning .missing-title {
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 8px;
        }
        .oks-missing-list {
            list-style: none;
            padding: 0;
            margin: 0;
        }
        .oks-missing-list li {
            padding: 4px 0;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .oks-found-in-nspd {
            background: #ecfdf5;
            border: 1px solid #10b981;
            border-radius: 8px;
            padding: 12px 16px;
            margin-top: 12px;
            color: #065f46;
        }
        
        .check-oks-egrn-btn {
    background: linear-gradient(135deg, #0ea5e9 0%, #2563eb 100%);
    border: none;
    color: white;
    padding: 8px 16px !important;
    font-size: 0.9rem !important;
    font-weight: 600;
    border-radius: 8px;
    cursor: pointer;
    display: inline-flex;
    align-items: center;
    gap: 8px;
    transition: all 0.3s ease;
    box-shadow: 0 2px 8px rgba(37, 99, 235, 0.3);
}

.check-oks-egrn-btn:hover {
    background: linear-gradient(135deg, #0284c7 0%, #1d4ed8 100%);
    box-shadow: 0 4px 12px rgba(37, 99, 235, 0.4);
    transform: translateY(-2px);
}

.check-oks-egrn-btn:active {
    transform: translateY(0);
}

.check-oks-egrn-btn:disabled {
    background: linear-gradient(135deg, #94a3b8 0%, #64748b 100%);
    cursor: not-allowed;
    transform: none;
    box-shadow: none;
}

.check-oks-egrn-btn i {
    font-size: 1em;
}

.check-oks-egrn-btn .btn-text {
    white-space: nowrap;
}

.check-zu-btn {
    background: linear-gradient(135deg, #10b981 0%, #059669 100%);
    border: none;
    color: white;
    padding: 8px 16px !important;
    font-size: 0.9rem !important;
    font-weight: 600;
    border-radius: 8px;
    cursor: pointer;
    display: inline-flex;
    align-items: center;
    gap: 8px;
    transition: all 0.3s ease;
    box-shadow: 0 2px 8px rgba(16, 185, 129, 0.3);
}

.check-zu-btn:hover {
    background: linear-gradient(135deg, #059669 0%, #047857 100%);
    box-shadow: 0 4px 12px rgba(16, 185, 129, 0.4);
    transform: translateY(-2px);
}

.check-zu-btn:active {
    transform: translateY(0);
}

.check-zu-btn:disabled {
    background: linear-gradient(135deg, #94a3b8 0%, #64748b 100%);
    cursor: not-allowed;
    transform: none;
    box-shadow: none;
}

.check-zu-btn i {
    font-size: 1em;
}

.check-zu-btn .btn-text {
    white-space: nowrap;
}

/* Модалка проверки смежного ЗУ */
.related-parcel-modal-content {
    background-color: white;
    padding: 0;
    border-radius: 12px;
    box-shadow: var(--shadow-lg);
    
    /* Делаем окно большим, почти на весь экран */
    width: 98%; 
    height: 95%;
    max-width: 1800px;
    max-height: 98vh;
    
    display: flex;
    flex-direction: column;
    overflow: hidden;
    position: relative; /* Для позиционирования анимаций если нужно */
}

.related-parcel-modal-header {
    display: flex;
    align-items: center;
    justify-content: space-between; /* Разносим заголовок и кнопку */
    padding: 12px 24px;
    background: linear-gradient(135deg, #f8fafc 0%, #eef2f7 100%);
    border-bottom: 1px solid var(--border-color);
    flex-shrink: 0; /* Заголовок не сжимается */
}

.related-parcel-modal-header h2 {
    font-size: 1.25rem;
    color: var(--text-primary);
    margin: 0;
    display: flex;
    align-items: center;
    gap: 10px;
}


.red-close-btn {
    width: 36px;
    height: 36px;
    background-color: #ef4444; /* Красный цвет */
    color: white;
    border-radius: 8px; /* Скругленные углы */
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    transition: all 0.2s ease;
    box-shadow: 0 2px 5px rgba(239, 68, 68, 0.3);
    font-size: 1.2rem;
    border: none;
}

.red-close-btn:hover {
    background-color: #dc2626; /* Темнее при наведении */
    transform: translateY(-2px);
    box-shadow: 0 4px 8px rgba(239, 68, 68, 0.4);
}

.red-close-btn:active {
    transform: translateY(0);
}

.related-parcel-modal-header h2 i {
    color: var(--info-color);
}


.related-parcel-legend .legend-item {
    display: flex;
    align-items: center;
    gap: 5px;
    color: var(--text-secondary);
}

.related-parcel-legend .legend-line {
    width: 24px;
    height: 3px;
    border-radius: 2px;
}

.related-parcel-legend .legend-line.dashed {
    background: repeating-linear-gradient(90deg, currentColor, currentColor 4px, transparent 4px, transparent 8px);
    height: 2px;
}

.related-parcel-legend .legend-point {
    width: 10px;
    height: 10px;
    border-radius: 50%;
}

related-parcel-modal-body {
    padding: 16px;
    flex-grow: 1; /* Занимает все свободное место */
    display: flex;
    align-items: center;
    justify-content: center;
    background: #f8fafc;
    
    /* ВАЖНО: Убираем фиксированную высоту, чтобы работало на весь экран */
    min-height: 0; 
    height: 100%;
    overflow: hidden;
    position: relative;
}

#relatedParcelCanvas {
    /* Канвас должен вписываться, но сохранять пропорции */
    max-width: 100%;
    max-height: 100%;
    border: 1px solid var(--border-color);
    border-radius: 4px;
    background: white;
    box-shadow: var(--shadow-sm);
}

.related-parcel-legend {
    display: flex;
    flex-wrap: wrap;
    gap: 16px;
    padding: 10px 24px;
    background: #ffffff;
    border-top: 1px solid var(--border-color);
    justify-content: center;
    flex-shrink: 0;
}


/* Инфо-панель снизу, не растягивается, с прокруткой если нужно */
.related-parcel-info {
    padding: 16px 24px;
    background: var(--secondary-color);
    border-top: 1px solid var(--border-color);
    max-height: 250px; /* Ограничиваем высоту инфо-блока */
    overflow-y: auto;
    flex-shrink: 0;
}

.related-parcel-status {
    display: flex;
    align-items: center;
    gap: 12px;
    padding: 12px 16px;
    border-radius: 8px;
    font-weight: 600;
    margin-bottom: 12px;
}

.related-parcel-status.success {
    background: #ecfdf5;
    color: #065f46;
    border: 1px solid #10b981;
}

.related-parcel-status.error {
    background: #fef2f2;
    color: #991b1b;
    border: 1px solid #ef4444;
}

.related-parcel-status.warning {
    background: #fffbeb;
    color: #92400e;
    border: 1px solid #f59e0b;
}

.related-parcel-status i {
    font-size: 1.2em;
}

.related-parcel-details {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
    gap: 12px;
}

.related-parcel-detail-item {
    background: white;
    padding: 10px 14px;
    border-radius: 6px;
    border: 1px solid var(--border-color);
}

.related-parcel-detail-item .label {
    font-size: 0.8rem;
    color: var(--text-secondary);
    text-transform: uppercase;
    letter-spacing: 0.5px;
    margin-bottom: 4px;
}

.related-parcel-detail-item .value {
    font-weight: 600;
    color: var(--text-primary);
}

.related-parcel-errors {
    margin-top: 12px;
    padding: 12px;
    background: #fef2f2;
    border: 1px solid #fecaca;
    border-radius: 8px;
}

.related-parcel-errors .error-title {
    font-weight: 600;
    color: #991b1b;
    margin-bottom: 8px;
    display: flex;
    align-items: center;
    gap: 8px;
}

.related-parcel-errors ul {
    margin: 0;
    padding-left: 24px;
    color: #7f1d1d;
}

.related-parcel-errors li {
    padding: 2px 0;
}

.check-related-btn {
    background: linear-gradient(135deg, #8b5cf6 0%, #7c3aed 100%);
    border: none;
    color: white;
    padding: 8px 16px !important;
    font-size: 0.9rem !important;
    font-weight: 600;
    border-radius: 8px;
    cursor: pointer;
    display: inline-flex;
    align-items: center;
    gap: 8px;
    transition: all 0.3s ease;
    box-shadow: 0 2px 8px rgba(139, 92, 246, 0.3);
}

.check-related-btn:hover {
    background: linear-gradient(135deg, #7c3aed 0%, #6d28d9 100%);
    box-shadow: 0 4px 12px rgba(139, 92, 246, 0.4);
    transform: translateY(-2px);
}

.check-related-btn:disabled {
    background: linear-gradient(135deg, #94a3b8 0%, #64748b 100%);
    cursor: not-allowed;
    transform: none;
    box-shadow: none;
}

.check-related-btn i {
    font-size: 1em;
}



.related-parcel-legend .legend-item {
    display: flex;
    align-items: center;
    gap: 8px;
    font-size: 0.85rem;
    color: var(--text-secondary);
}

.related-parcel-legend .legend-line {
    width: 24px;
    height: 3px;
    border-radius: 2px;
}

.related-parcel-legend .legend-line.dashed {
    background: transparent;
    border-top: 3px dashed;
    height: 0;
}

.related-parcel-legend .legend-point {
    width: 12px;
    height: 12px;
    border-radius: 50%;
}

.related-parcel-modal-body {
    padding: 16px;
    display: flex;
    align-items: center;
    justify-content: center;
    background: #f8fafc;
    min-height: 350px;
    max-height: 50vh;
    overflow: hidden;
}

#relatedParcelCanvas {
    border: 1px solid var(--border-color);
    border-radius: 8px;
    background: white;
    max-width: 100%;
    max-height: 100%;
}


        @media (max-width: 1024px) { #resultsContainer { grid-template-columns: 1fr; } }
        @media (max-width: 768px) {
            .container { margin: 0; border-radius: 0; }
            .content { padding: 16px; }
            .info-grid { grid-template-columns: 1fr; }
            .data-table, .contradiction-table { font-size: 0.8rem; }
            .data-table th, .data-table td, .contradiction-table th, .contradiction-table td { padding: 8px 12px; }
            .ai-modal-content { width: 100%; height: 90%; }
            .oks-schema-legend { display: none; }
        }
        @media print {
            body, .container { padding: 0; margin: 0; box-shadow: none; border: none; background: white; color: black; }
            .file-upload-section, .status-container, #printButtonContainer, .header-button, .validation-section, .ai-modal-overlay, .docs-modal-overlay { display: none !important; }
            #resultsContainer { display: block; gap: 0; }
            #mainColumn, #sidebarColumn { display: block; width: 100%; }
            .section { box-shadow: none; border: 1px solid #ccc; border-radius: 0; page-break-inside: avoid; margin-bottom: 20px; }
            .section-header { background: #f0f0f0 !important; }
            .data-table th, .contradiction-table th { background: #e5e5e5 !important; color: black !important; }
            .info-card, .conclusion-text { background: #f9f9f9 !important; }
            * { -webkit-print-color-adjust: exact !important; print-color-adjust: exact !important; }
        }
    </style>
</head>
<body>
    <div class="container">
        <main class="content">
            <div class="file-upload-section" id="dropSection">
                <div class="file-upload-area" id="dropArea">
                    <div class="upload-icon"><img src="img/mpch.png" alt="Загрузить файл"></div>
                    <div class="upload-text">Выберите XML или ZIP файл (МП, ТП, Акт) или вставьте (Ctrl+V)</div>
                    <div class="upload-subtext" id="fileNameDisplay"></div>
                </div>
                <input type="file" id="fileInput" accept=".xml,.zip">
            </div>
            <div id="printButtonContainer" class="hidden">
                <button id="printButton" class="print-btn">
                    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" d="M6.72 13.829c-.24.03-.48.062-.72.096m.72-.096a42.415 42.415 0 0110.56 0m-10.56 0L6 18.25M3.75 6.75h16.5M3.75 12h16.5m-16.5 5.25h16.5M17.25 4.5l-1.5-1.5-1.5 1.5M6.75 4.5l1.5-1.5 1.5 1.5m12.75 1.5-1.5-1.5-1.5 1.5M6.75 21l1.5 1.5 1.5-1.5m12.75 1.5l-1.5 1.5-1.5-1.5M12 6.75v10.5" />
                    </svg>
                    <span>Печать</span>
                </button>
                <button id="docsButton" class="print-btn docs-btn">
                    <i class="fas fa-file-alt"></i>
                    <span>Документы</span>
                </button>
                <button id="pasteButton" class="print-btn paste-btn">
                    <i class="fas fa-paste"></i>
                    <span>Вставить</span>
                </button>
            </div>
            <div class="status-container" id="statusContainer">
                <div class="loader hidden" id="loader"></div>
                <div id="messageArea">
                    <div class="status-text" id="statusText"></div>
                </div>
            </div>
            <div id="resultsContainer" class="hidden">
                <div id="mainColumn"></div>
                <div id="sidebarColumn"></div>
            </div>
        </main>
    </div>
    <div id="aiCheckModal" class="ai-modal-overlay modal-overlay">
        <div class="ai-modal-content">
            <div class="ai-modal-header">
                <h2>Анализ заключения</h2>
                <div class="ai-modal-controls">
                    <span class="ai-modal-minimize-button" id="aiModalMinimizeBtn"><i class="fas fa-window-minimize"></i></span>
                    <span class="ai-modal-close-button" id="aiModalCloseBtn">×</span>
                </div>
            </div>
            <div id="aiCheckResultDisplay"></div>
        </div>
    </div>
    <div id="docsModal" class="docs-modal-overlay modal-overlay">
        <div class="docs-modal-content">
            <div class="docs-modal-header">
                <h2>Обязательные документы</h2>
                <span class="ai-modal-close-button docs-modal-close-button">×</span>
            </div>
            <p style="color: var(--text-secondary); margin-bottom: 12px;">Введите названия документов для проверки наличия (каждое с новой строки)</p>
            <textarea id="docsListTextarea" placeholder="Например:&#10;Акт&#10;Постановление&#10;Схема"></textarea>
            <div class="docs-modal-footer">
                <button class="docs-modal-btn docs-modal-close-button">Отмена</button>
                <button class="docs-modal-btn" id="saveDocsListBtn">Сохранить</button>
            </div>
        </div>
    </div>
    <div id="oksSchemaModal" class="modal-overlay">
        <div class="oks-schema-modal-content">
            <div class="oks-schema-modal-header">
                <h2><i class="fas fa-layer-group"></i> Схема расположения ОКС</h2>
                <div class="oks-schema-legend">
                    <div class="legend-item"><div class="legend-color" style="background:#2563eb;"></div><span>Земельный участок</span></div>
                    <div class="legend-item"><div class="legend-color" style="background:#ef4444;"></div><span>ОКС (указанные)</span></div>
                    <div class="legend-item"><div class="legend-color" style="background:#f59e0b; border: 2px dashed #b45309;"></div><span>ОКС (найденные в ЕГРН)</span></div>
                </div>
                <span class="ai-modal-close-button" id="oksSchemaModalClose">×</span>
            </div>
            <div class="oks-schema-modal-body">
                <canvas id="oksSchemaCanvas"></canvas>
            </div>
            <div class="oks-schema-info" id="oksSchemaInfo"></div>
        </div>
    </div>
    
    
    <!-- Модалка проверки смежного ЗУ -->
<div id="relatedParcelModal" class="modal-overlay">
    <div class="related-parcel-modal-content">
        <div class="related-parcel-modal-header">
            <h2><i class="fas fa-draw-polygon"></i> Проверка границ смежного ЗУ</h2>
            <!-- Обновленная кнопка закрытия -->
            <button class="red-close-btn" id="relatedParcelModalClose" title="Закрыть окно">
                <i class="fas fa-times"></i>
            </button>
        </div>
        
        <div class="related-parcel-modal-body">
            <canvas id="relatedParcelCanvas"></canvas>
        </div>
        
        <div class="related-parcel-legend" id="relatedParcelLegend">
            <div class="legend-item"><span class="legend-line" style="background:#64748b; opacity:0.5;"></span> Основной ЗУ (ЕГРН)</div>
            <div class="legend-item"><span class="legend-line dashed" style="border-color:#f59e0b;"></span> Смежный ЗУ (ЕГРН)</div>
            <div class="legend-item"><span class="legend-line" style="background:#ef4444;"></span> Удаляемый сегмент</div>
            <div class="legend-item"><span class="legend-line" style="background:#10b981;"></span> Новые точки</div>
            <div class="legend-item"><span class="legend-point" style="background:#3b82f6;"></span> Точки стыковки</div>
            <div class="legend-item"><span class="legend-line" style="background:#2563eb;"></span> Результат</div>
        </div>
        
        <div class="related-parcel-info" id="relatedParcelInfo">
            <!-- Заполняется динамически -->
        </div>
    </div>
</div>
<script>
const MAPRUAPP_PROXY_BASE_URL = "https://mapruapp.ru";
const PROXY_MODE = 1;
const DOCS_LIST_KEY = 'requiredDocsList';
const NSPD_CATEGORY_BUILDINGS = 36369;
const NSPD_CATEGORY_CONSTRUCTIONS = 36383;
const NSPD_CATEGORY_ZU = 36368;

let lastXmlDoc = null;
let lastXmlText = null;
let currentOksData = null;
let currentNspdOksData = null;
let currentMskSystem = null;
let currentTpOksContours = null;
let currentTpZuData = null;
let relatedParcelCheckData = null;

document.addEventListener('DOMContentLoaded', () => {
    const landCategories = { '003001000000': 'Земли сельскохозяйственного назначения', '003002000000': 'Земли населенных пунктов', '003003000000': 'Земли промышленности, энергетики, транспорта и иного специального назначения', '003004000000': 'Земли особо охраняемых территорий и объектов', '003005000000': 'Земли лесного фонда', '003006000000': 'Земли водного фонда', '003007000000': 'Земли запаса', '003008000000': 'Категория не установлена' };
    const accuracyStandards = { '003002000000': 0.10, '003001000000': 2.50, '003003000000': 0.50, '003004000000': 2.50, '003005000000': 5.00, '003006000000': 5.00, '003007000000': 5.00, '003008000000': 2.50 };
    const planTypes = { '1': 'Выдел', '2': 'Раздел', '3': 'Раздел с измененным земельным участком', '4': 'Перераспределение', '5': 'Образование из земель', '6': 'Объединение', '7': 'Перераспределение с землями' };
    const keyParameterTypes = { '01': 'Протяженность, м', '02': 'Площадь, кв. м', '03': 'Объем, куб. м', '04': 'Высота, м', '05': 'Глубина, м', '06': 'Глубина залегания, м' };
    const geopointMethods = {
        '692001000000': 'Геодезический метод',
        '692002000000': 'Фотограмметрический метод',
        '692003000000': 'Картометрический метод',
        '692004000000': 'Иное описание',
        '692005000000': 'Метод спутниковых геодезических измерений (определений)',
        '692006000000': 'Аналитический метод'
    };
    const sectionIcons = {
        generalInfo: `<svg xmlns="http://www.w3.org/2000/svg" class="section-icon" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" /></svg>`,
        participants: `<svg xmlns="http://www.w3.org/2000/svg" class="section-icon" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M17 20h5v-2a3 3 0 00-5.356-1.857M17 20H7m10 0v-2c0-.656-.126-1.283-.356-1.857M7 20H2v-2a3 3 0 015.356-1.857M7 20v-2c0-.656.126-1.283.356-1.857m0 0a5.002 5.002 0 019.288 0M15 7a3 3 0 11-6 0 3 3 0 016 0zm6 3a2 2 0 11-4 0 2 2 0 014 0zM7 10a2 2 0 11-4 0 2 2 0 014 0z" /></svg>`,
        inputData: `<svg xmlns="http://www.w3.org/2000/svg" class="section-icon" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M19 11H5m14 0a2 2 0 012 2v6a2 2 0 01-2 2H5a2 2 0 01-2-2v-6a2 2 0 012-2m14 0V9a2 2 0 00-2-2M5 11V9a2 2 0 012-2m0 0V5a2 2 0 012-2h6a2 2 0 012 2v2M7 7h10" /></svg>`,
        newParcel: `<svg xmlns="http://www.w3.org/2000/svg" class="section-icon" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M9 20l-5.447-2.724A1 1 0 013 16.382V5.618a1 1 0 011.447-.894L9 7m0 13l6-3m-6 3V7m6 10l4.553 2.276A1 1 0 0021 18.382V7.618a1 1 0 00-.553-.894L15 4m0 13V4m0 0L9 7" /></svg>`,
        relatedParcel: `<svg xmlns="http://www.w3.org/2000/svg" class="section-icon" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z" /></svg>`,
        conclusion: `<svg xmlns="http://www.w3.org/2000/svg" class="section-icon" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z" /></svg>`,
        graphics: `<svg xmlns="http://www.w3.org/2000/svg" class="section-icon" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l-1.586-1.586a2 2 0 00-2.828 0L6 14m6-6l.01.01" /><rect x="3" y="3" width="18" height="18" rx="2" ry="2" /></svg>`,
        appendix: `<svg xmlns="http://www.w3.org/2000/svg" class="section-icon" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M15.172 7l-6.586 6.586a2 2 0 102.828 2.828l6.414-6.586a4 4 0 00-5.656-5.656l-6.415 6.585a6 6 0 108.486 8.486L20.5 13" /></svg>`,
        copyXY: `<svg xmlns="http://www.w3.org/2000/svg" class="section-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path><text x="12" y="16.5" font-family="sans-serif" font-size="6" fill="currentColor" text-anchor="middle" font-weight="bold">XY</text></svg>`,
        validation: `<svg xmlns="http://www.w3.org/2000/svg" class="section-icon" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M9 12.75L11.25 15 15 9.75m-3-7.036A11.959 11.959 0 013.598 6 11.99 11.99 0 003 9.749c0 5.592 3.824 10.29 9 11.622 5.176-1.332 9-6.03 9-11.622 0-1.31-.21-2.571-.598-3.751h-.152c-3.196 0-6.1-1.248-8.25-3.286zm0 13.036h.008v.008h-.008v-.008z" /></svg>`,
        contradiction: `<i class="fas fa-balance-scale-right section-icon" style="color: var(--info-color);"></i>`,
        errorIcon: `<svg xmlns="http://www.w3.org/2000/svg" class="icon" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M12 9v3.75m-9.303 3.376c-.866 1.5.217 3.374 1.948 3.374h14.71c1.73 0 2.813-1.874 1.948-3.374L13.949 3.378c-.866-1.5-3.032-1.5-3.898 0L2.697 16.126zM12 15.75h.007v.008H12v-.008z" /></svg>`,
        warningIcon: `<svg xmlns="http://www.w3.org/2000/svg" class="icon" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M12 9v3.75m9-.75a9 9 0 11-18 0 9 9 0 0118 0zm-9 3.75h.008v.008H12v-.008z" /></svg>`,
        successIcon: `<svg xmlns="http://www.w3.org/2000/svg" class="icon" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M9 12.75L11.25 15 15 9.75M21 12a9 9 0 11-18 0 9 9 0 0118 0z" /></svg>`
    };

    const fileInput = document.getElementById('fileInput');
    const loader = document.getElementById('loader');
    const dropArea = document.getElementById('dropArea');
    const dropSection = document.getElementById('dropSection');
    const fileNameDisplay = document.getElementById('fileNameDisplay');
    const statusContainer = document.getElementById('statusContainer');
    const messageArea = document.getElementById('messageArea');
    const resultsContainer = document.getElementById('resultsContainer');
    const mainColumn = document.getElementById('mainColumn');
    const sidebarColumn = document.getElementById('sidebarColumn');
    const printButtonContainer = document.getElementById('printButtonContainer');
    const printButton = document.getElementById('printButton');
    const docsButton = document.getElementById('docsButton');
    const pasteButton = document.getElementById('pasteButton');
    const aiCheckModal = document.getElementById('aiCheckModal');
    const aiModalCloseBtn = document.getElementById('aiModalCloseBtn');
    const aiModalMinimizeBtn = document.getElementById('aiModalMinimizeBtn');
    const aiCheckResultDisplay = document.getElementById('aiCheckResultDisplay');
    const docsModal = document.getElementById('docsModal');
    const docsModalCloseButtons = document.querySelectorAll('.docs-modal-close-button');
    const saveDocsListBtn = document.getElementById('saveDocsListBtn');
    const docsListTextarea = document.getElementById('docsListTextarea');

    const E = (el, sel) => el.querySelector(sel);
    const All = (el, sel) => el.querySelectorAll(sel);
    const T = (el, sel) => el?.querySelector(sel)?.textContent.trim() || '—';
    const A = (el, attr) => el?.getAttribute(attr) || '—';

    const getFullAddress = (addrEl) => {
        if (!addrEl) return '—';
        const getAddrPart = (tagName) => {
            const el = addrEl.querySelector(tagName);
            if (!el) return '';
            const type = el.getAttribute('Type') || '';
            let val = el.textContent.trim();
            if (!val) val = el.getAttribute('Name') || '';
            if (!val) return '';
            return `${type} ${val}`.trim();
        };
        return [
            T(addrEl, 'RussianFederation'), 
            T(addrEl, 'Region') !== '—' ? `Респ. ${T(addrEl, 'Region')}` : '',
            getAddrPart('District'),
            getAddrPart('City'),
            getAddrPart('UrbanDistrict'),
            getAddrPart('SovietVillage'),
            getAddrPart('Locality'),
            getAddrPart('Street'),
            E(addrEl, 'Level1') ? `${A(E(addrEl, 'Level1'), 'Type') !== '—' ? A(E(addrEl, 'Level1'), 'Type') : ''} ${A(E(addrEl, 'Level1'), 'Value') !== '—' ? A(E(addrEl, 'Level1'), 'Value') : ''}` : '',
            E(addrEl, 'Apartment') ? `${A(E(addrEl, 'Apartment'), 'Type') !== '—' ? A(E(addrEl, 'Apartment'), 'Type') : ''} ${A(E(addrEl, 'Apartment'), 'Value') !== '—' ? A(E(addrEl, 'Apartment'), 'Value') : ''}` : '',
            T(addrEl, 'Other')
        ].filter(p => p && p.trim() && p !== '—' && !p.includes('—')).join(', ');
    };
    
    
    function delay(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
}

    function clearResults() {
        resultsContainer.classList.add('hidden');
        printButtonContainer.classList.add('hidden');
        mainColumn.innerHTML = '';
        sidebarColumn.innerHTML = '';
        lastXmlDoc = null;
        lastXmlText = null;
        currentOksData = null;
        currentNspdOksData = null;
        currentMskSystem = null;
    }

    function showStatus(message, isLoading = false) {
        clearResults();
        messageArea.innerHTML = `<div class="status-text">${message}</div>`;
        statusContainer.classList.remove('hidden');
        loader.classList.toggle('hidden', !isLoading);
    }

    function showError(message) {
        clearResults();
        loader.classList.add('hidden');
        statusContainer.classList.remove('hidden');
        messageArea.innerHTML = `<div class="error-message">${message}</div>`;
        console.error(message);
    }

    function escapeHtml(unsafe) {
        if (typeof unsafe !== 'string') return '';
        return unsafe.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#039;");
    }

    function detectMskSystem(cadNumber) {
        if (typeof proj4 === 'undefined' || typeof COORDINATE_SYSTEMS === 'undefined' || typeof MskFinder === 'undefined') {
            return null;
        }
        const mskCode = MskFinder.findMskCode(cadNumber);
        let targetSystem = null;
        if (mskCode) {
            targetSystem = COORDINATE_SYSTEMS.find(s => s.text.includes(`МСК-${mskCode}`)) ||
                           COORDINATE_SYSTEMS.find(s => s.text.includes(`МСК ${mskCode}`)) ||
                           COORDINATE_SYSTEMS.find(s => s.text.includes(mskCode));
        }
        if (!targetSystem) {
            const regionCode = cadNumber.split(':')[0];
            const candidates = COORDINATE_SYSTEMS.filter(s => 
                s.text.includes(`МСК ${regionCode}`) || s.text.includes(`МСК-${regionCode}`)
            );
            if (candidates.length > 0) targetSystem = candidates[0];
        }
        if (targetSystem && proj4.defs(targetSystem.value) === undefined) {
            proj4.defs(targetSystem.value, targetSystem.def);
        }
        return targetSystem;
    }

    function convertMskTo3857(point, mskSystem) {
        if (!mskSystem || typeof proj4 === 'undefined') return null;
        const { offsetX = 0, offsetY = 0 } = mskSystem;
        const mskX = point.x - offsetX;
        const mskY = point.y - offsetY;
        const result = proj4(mskSystem.value, 'EPSG:3857', [mskY, mskX]);
        return result;
    }

    function convert3857ToMsk(coord, mskSystem) {
        if (!mskSystem || typeof proj4 === 'undefined') return null;
        const { offsetX = 0, offsetY = 0 } = mskSystem;
        const [lon, lat] = proj4('EPSG:3857', mskSystem.value, coord);
        return { x: lat + offsetX, y: lon + offsetY };
    }
    
    
function extractContoursFromTechPlan() {
    if (!lastXmlDoc) return { contours: [], isLinear: false };
    
    const mainObject = lastXmlDoc.querySelector('NewBuilding, ExistBuilding, NewConstruction, ExistConstruction, NewFlat, ExistFlat');
    if (!mainObject) return { contours: [], isLinear: false };
    
    const contours = [];
    let isLinear = false;
    
    // Ищем контуры в разных местах
    const contourElements = mainObject.querySelectorAll('Contours > Contour, Contours > NewContour');
    const entitySpatials = mainObject.querySelectorAll('EntitySpatial');
    
    // Обрабатываем контуры
    contourElements.forEach(contourEl => {
        const entitySpatial = contourEl.querySelector('EntitySpatial');
        if (entitySpatial) {
            const ordinates = entitySpatial.querySelectorAll('Ordinate');
            const points = [];
            
            ordinates.forEach(ord => {
                const x = parseFloat(ord.getAttribute('X'));
                const y = parseFloat(ord.getAttribute('Y'));
                if (!isNaN(x) && !isNaN(y)) {
                    points.push({ x, y });
                }
            });
            
            if (points.length > 0) {
                contours.push(points);
                
                // Проверяем замкнутость
                if (points.length > 2) {
                    const first = points[0];
                    const last = points[points.length - 1];
                    const isClosed = Math.abs(first.x - last.x) < 0.01 && Math.abs(first.y - last.y) < 0.01;
                    if (!isClosed) {
                        isLinear = true;
                    }
                }
            }
        }
    });
    
    // Если контуры не найдены через Contours, ищем напрямую EntitySpatial
    if (contours.length === 0) {
        entitySpatials.forEach(entitySpatial => {
            const ordinates = entitySpatial.querySelectorAll('Ordinate');
            const points = [];
            
            ordinates.forEach(ord => {
                const x = parseFloat(ord.getAttribute('X'));
                const y = parseFloat(ord.getAttribute('Y'));
                if (!isNaN(x) && !isNaN(y)) {
                    points.push({ x, y });
                }
            });
            
            if (points.length > 0) {
                contours.push(points);
                
                if (points.length > 2) {
                    const first = points[0];
                    const last = points[points.length - 1];
                    const isClosed = Math.abs(first.x - last.x) < 0.01 && Math.abs(first.y - last.y) < 0.01;
                    if (!isClosed) {
                        isLinear = true;
                    }
                }
            }
        });
    }
    
    return { contours, isLinear };
}

async function searchZuForLinearObject(contours, mskSystem) {
    if (!contours || contours.length === 0 || !mskSystem) return [];
    
    try {
        // Собираем все точки для определения bbox
        const allPoints3857 = [];
        
        for (const contour of contours) {
            for (const point of contour) {
                const converted = convertMskTo3857(point, mskSystem);
                if (converted) {
                    allPoints3857.push(converted);
                }
            }
        }
        
        if (allPoints3857.length === 0) return [];
        
        // Вычисляем bbox
        let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
        allPoints3857.forEach(p => {
            minX = Math.min(minX, p[0]);
            maxX = Math.max(maxX, p[0]);
            minY = Math.min(minY, p[1]);
            maxY = Math.max(maxY, p[1]);
        });
        
        // Добавляем буфер 100 метров
        const buffer = 100;
        minX -= buffer;
        maxX += buffer;
        minY -= buffer;
        maxY += buffer;
        
        // Формируем прямоугольник поиска
        const searchPolygon = [
            [minX, minY],
            [maxX, minY],
            [maxX, maxY],
            [minX, maxY],
            [minX, minY]
        ];
        
        const geometryForApi = {
            "crs": { "type": "name", "properties": { "name": "EPSG:3857" } },
            "type": "Polygon",
            "coordinates": [searchPolygon]
        };
        
        const requestBody = {
            "geom": { 
                "type": "FeatureCollection", 
                "features": [{ "type": "Feature", "geometry": geometryForApi, "properties": {} }] 
            },
            "categories": [{ "id": NSPD_CATEGORY_ZU }]
        };
        
        const response = await fetch('https://nspd.gov.ru/api/geoportal/v1/intersects?typeIntersect=fullObject', {
            method: 'POST', 
            headers: { 'Content-Type': 'application/json' }, 
            body: JSON.stringify(requestBody)
        });
        
        if (!response.ok) return [];
        
        const data = await response.json();
        const allFeatures = data.features || [];
        
        // Фильтруем - оставляем только те ЗУ, через которые реально проходит линия
        const intersectingFeatures = [];
        
        for (const feature of allFeatures) {
            if (checkLineIntersectsPolygon(contours, feature.geometry, mskSystem)) {
                intersectingFeatures.push(feature);
            }
        }
        
        return intersectingFeatures;
        
    } catch (error) {
        console.error('Ошибка поиска ЗУ для линейного объекта:', error);
        return [];
    }
}


function checkLineIntersectsPolygon(lineContours, polygonGeometry, mskSystem) {
    if (!polygonGeometry) return false;
    
    const doSegmentsIntersect = (p1, p2, p3, p4) => {
        const ccw = (a, b, c) => (c.y - a.y) * (b.x - a.x) > (b.y - a.y) * (c.x - a.x);
        return ccw(p1, p3, p4) !== ccw(p2, p3, p4) && ccw(p1, p2, p3) !== ccw(p1, p2, p4);
    };
    
    const pointInPolygon = (point, polygon) => {
        let inside = false;
        for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
            const xi = polygon[i].x, yi = polygon[i].y;
            const xj = polygon[j].x, yj = polygon[j].y;
            if (((yi > point.y) !== (yj > point.y)) && (point.x < (xj - xi) * (point.y - yi) / (yj - yi) + xi)) {
                inside = !inside;
            }
        }
        return inside;
    };
    
    const processRing = (ring3857) => {
        const polygonMsk = ring3857.map(coord => convert3857ToMsk(coord, mskSystem)).filter(p => p !== null);
        if (polygonMsk.length < 3) return false;
        
        for (const lineContour of lineContours) {
            // Проверка: точка линии внутри полигона
            for (const point of lineContour) {
                if (pointInPolygon(point, polygonMsk)) {
                    return true;
                }
            }
            
            // Проверка: отрезок линии пересекает границу полигона
            for (let i = 0; i < lineContour.length - 1; i++) {
                const p1 = lineContour[i];
                const p2 = lineContour[i + 1];
                
                for (let j = 0; j < polygonMsk.length - 1; j++) {
                    const p3 = polygonMsk[j];
                    const p4 = polygonMsk[j + 1];
                    
                    if (doSegmentsIntersect(p1, p2, p3, p4)) {
                        return true;
                    }
                }
            }
        }
        return false;
    };
    
    if (polygonGeometry.type === 'Polygon') {
        return processRing(polygonGeometry.coordinates[0]);
    } else if (polygonGeometry.type === 'MultiPolygon') {
        for (const poly of polygonGeometry.coordinates) {
            if (processRing(poly[0])) return true;
        }
    }
    
    return false;
}

async function checkZuForTechPlan(zuNumbers, button) {
    if (!zuNumbers || zuNumbers.length === 0) return;
    
    const container = button.closest('.subsection');
    const statusDiv = container.querySelector('.zu-check-status');
    const originalButtonHtml = button.innerHTML;
    
    button.disabled = true;
    button.innerHTML = '<i class="fas fa-sync-alt fa-spin"></i> <span class="btn-text">Подготовка...</span>';
    statusDiv.innerHTML = '';
    
    // Определяем МСК по кадастровому кварталу
    const cadBlock = lastXmlDoc?.querySelector('CadastralBlock');
    const cadBlockText = cadBlock?.textContent?.trim();
    if (cadBlockText) {
        currentMskSystem = detectMskSystem(cadBlockText);
    }
    
    if (!currentMskSystem) {
        statusDiv.innerHTML = `<div class="validation-message validation-error">${sectionIcons.errorIcon} Не удалось определить систему координат</div>`;
        button.disabled = false;
        button.innerHTML = originalButtonHtml;
        return;
    }
    
    // Загружаем данные указанных ЗУ из ЕГРН
    const loadedZuData = new Map();
    const notFoundZu = [];
    let successCount = 0;
    
    for (let i = 0; i < zuNumbers.length; i++) {
        const cadNum = zuNumbers[i];
        const zuCard = container.querySelector(`.zu-item[data-cad-number="${cadNum}"]`);
        const addressDiv = zuCard?.querySelector('.zu-address');
        
        if (i > 0) await delay(1000);
        
        button.innerHTML = `<i class="fas fa-sync-alt fa-spin"></i> <span class="btn-text">ЗУ ${i + 1}/${zuNumbers.length}</span>`;
        
        try {
            const url = `https://nspd.gov.ru/api/geoportal/v2/search/geoportal?thematicSearchId=1&query=${encodeURIComponent(cadNum)}`;
            const response = await fetch(url);
            const data = await response.json();
            
            if (data.code === 204 || response.status === 204 || !data?.data?.features?.[0]) {
                if (addressDiv) {
                    addressDiv.innerHTML = '<span style="color:var(--error-color);"><i class="fas fa-question-circle"></i> Не найден в ЕГРН</span>';
                }
                notFoundZu.push(cadNum);
                continue;
            }
            
            const feature = data.data.features[0];
            const options = feature.properties?.options || {};
            const address = options.readable_address || options.address_readable_address || 'Адрес не указан';
            
            if (addressDiv) {
                addressDiv.innerHTML = `<i class="fas fa-hourglass-half" style="color:var(--text-secondary);"></i> ${address}`;
            }
            
            // Конвертируем геометрию ЗУ
            let zuContours = [];
            if (feature.geometry && currentMskSystem) {
                zuContours = await convertEgrnGeometryToMsk(feature.geometry, currentMskSystem);
            }
            
            loadedZuData.set(cadNum.toLowerCase(), {
                cadNumber: cadNum,
                address: address,
                addressDiv: addressDiv,
                contours: zuContours,
                hasCoords: zuContours.length > 0,
                source: 'xml'
            });
            successCount++;
            
        } catch (err) {
            console.error(`Ошибка загрузки ЗУ ${cadNum}:`, err);
            if (addressDiv) {
                addressDiv.innerHTML = `<span style="color:var(--warning-color);"><i class="fas fa-exclamation-triangle"></i> Ошибка запроса</span>`;
            }
        }
    }
    
    await delay(1000);
    
    // Извлекаем контуры ОКС из XML
    const { contours, isLinear } = extractContoursFromTechPlan();
    
    // Сохраняем контуры ОКС для схемы
    currentTpOksContours = contours;
    
    if (contours.length === 0) {
        statusDiv.innerHTML = `<div class="validation-message validation-warning">${sectionIcons.warningIcon} Не удалось извлечь координаты объекта из XML для проверки расположения</div>`;
        
        if (successCount > 0) {
            for (const [cadNumLower, zuData] of loadedZuData) {
                if (zuData.addressDiv) {
                    zuData.addressDiv.innerHTML = `<i class="fas fa-check-circle" style="color:var(--success-color);"></i> ${zuData.address}`;
                }
            }
            statusDiv.innerHTML += `<div class="validation-message validation-success" style="margin-top:8px;">${sectionIcons.successIcon} Найдено в ЕГРН: ${successCount} из ${zuNumbers.length} ЗУ</div>`;
        }
        
        button.disabled = false;
        button.innerHTML = originalButtonHtml;
        return;
    }
    
    button.innerHTML = '<i class="fas fa-sync-alt fa-spin"></i> <span class="btn-text">Поиск ЗУ...</span>';
    
    let nspdZuFeatures = [];
    
    if (isLinear) {
        nspdZuFeatures = await searchZuForLinearObject(contours, currentMskSystem);
    } else {
        nspdZuFeatures = await searchIntersectingObjects(contours, NSPD_CATEGORY_ZU, currentMskSystem);
    }
    
    // Обрабатываем найденные ЗУ
    const nspdZuList = [];
    for (const f of nspdZuFeatures) {
        const cadNum = f.properties?.options?.cad_number || f.properties?.options?.cad_num || f.properties?.descr;
        if (cadNum) {
            let zuContours = [];
            if (f.geometry && currentMskSystem) {
                zuContours = await convertEgrnGeometryToMsk(f.geometry, currentMskSystem);
            }
            nspdZuList.push({
                cadNumber: cadNum,
                address: f.properties?.options?.readable_address || f.properties?.options?.address_readable_address || '',
                category: f.properties?.options?.category_name || '',
                contours: zuContours,
                hasCoords: zuContours.length > 0,
                source: 'nspd'
            });
        }
    }
    
    // Сохраняем данные для схемы
    currentTpZuData = {
        xmlZu: Array.from(loadedZuData.values()),
        nspdZu: nspdZuList
    };
    
    button.innerHTML = '<i class="fas fa-sync-alt fa-spin"></i> <span class="btn-text">Анализ...</span>';
    
    // Сравнение
    const nspdCadNumbers = nspdZuList.map(z => z.cadNumber.toLowerCase());
    const xmlCadNumbers = zuNumbers.map(n => n.trim().toLowerCase());
    
    const wrongLocationZu = [];
    const correctZu = [];
    
    for (const [cadNumLower, zuData] of loadedZuData) {
        if (nspdCadNumbers.includes(cadNumLower)) {
            correctZu.push(zuData);
            if (zuData.addressDiv) {
                zuData.addressDiv.innerHTML = `<i class="fas fa-check-circle" style="color:var(--success-color);"></i> ${zuData.address}`;
            }
        } else {
            wrongLocationZu.push(zuData);
            if (zuData.addressDiv) {
                zuData.addressDiv.innerHTML = `<span style="color:var(--warning-color);"><i class="fas fa-map-marker-alt"></i> ${zuData.address}</span><br><span style="font-size:0.85em; color:var(--error-color);"><i class="fas fa-exclamation-triangle"></i> ОКС не расположен на этом участке!</span>`;
            }
        }
    }
    
    const missingZu = nspdZuList.filter(zu => !xmlCadNumbers.includes(zu.cadNumber.toLowerCase()));
    
    button.disabled = false;
    button.innerHTML = originalButtonHtml;
    
    // Формируем результат
    let statusHtml = '';
    
    // Блок: ЗУ указаны в XML, но ОКС на них не расположен
    if (wrongLocationZu.length > 0) {
        statusHtml += `<div class="validation-message validation-error" style="margin-top:8px; flex-direction:column; align-items:flex-start;">
            <div style="display:flex; align-items:center; gap:8px; margin-bottom:8px;">
                <i class="fas fa-map-marker-alt" style="color:#ef4444;"></i>
                <strong>Указаны в XML, но ОКС на них не расположен (${wrongLocationZu.length}):</strong>
            </div>
            <div style="font-size:0.9em; color:#991b1b;">
                Следующие участки указаны как земельные участки под ОКС, но объект на них фактически не находится:
            </div>
            <ul style="margin:8px 0 0 0; padding-left:0; list-style:none;">
                ${wrongLocationZu.map(z => `<li style="padding:4px 0;">
                    <i class="fas fa-times-circle" style="color:#ef4444;"></i> 
                    <code style="background:#fee2e2; padding:2px 6px; border-radius:4px;">${z.cadNumber}</code>
                    <br><span style="font-size:0.85em; color:var(--text-secondary); margin-left:20px;">${z.address}</span>
                </li>`).join('')}
            </ul>
        </div>`;
    }
    
    // Блок: ЗУ не найдены в ЕГРН
    if (notFoundZu.length > 0) {
        statusHtml += `<div class="validation-message validation-error" style="margin-top:8px; flex-direction:column; align-items:flex-start;">
            <div style="display:flex; align-items:center; gap:8px; margin-bottom:8px;">
                ${sectionIcons.errorIcon} 
                <strong>Не найдены в ЕГРН (${notFoundZu.length}):</strong>
            </div>
            <ul style="margin:8px 0 0 0; padding-left:0; list-style:none;">
                ${notFoundZu.map(kn => `<li style="padding:2px 0;"><i class="fas fa-question-circle" style="color:#ef4444;"></i> <code style="background:#fee2e2; padding:2px 6px; border-radius:4px;">${kn}</code></li>`).join('')}
            </ul>
        </div>`;
    }
    
    // Проверяем есть ли координаты для схемы
    const hasSchemaData = contours.length > 0 || nspdZuList.some(z => z.hasCoords) || Array.from(loadedZuData.values()).some(z => z.hasCoords);
    
    // Блок: Корректно указанные ЗУ
    if (correctZu.length > 0) {
        statusHtml += `<div class="validation-message validation-success" style="margin-top:8px; flex-wrap:wrap;">
            ${sectionIcons.successIcon} Корректно указаны: ${correctZu.length} из ${zuNumbers.length} ЗУ`;
        if (hasSchemaData) {
            statusHtml += `
                <button class="print-btn" style="padding:6px 14px; font-size:0.9rem; margin-left:12px;" id="openTpSchemaBtn">
                    <i class="fas fa-map-marked-alt"></i> Показать на схеме
                </button>`;
        }
        statusHtml += `</div>`;
    } else if (hasSchemaData && (nspdZuList.length > 0 || contours.length > 0)) {
        // Даже если нет корректных, но есть данные - показываем кнопку схемы
        statusHtml += `<div class="validation-message" style="margin-top:8px; background:#f0f9ff; border:1px solid #bae6fd; color:#0369a1; flex-wrap:wrap;">
            <i class="fas fa-info-circle"></i> Данные загружены
            <button class="print-btn" style="padding:6px 14px; font-size:0.9rem; margin-left:12px;" id="openTpSchemaBtn">
                <i class="fas fa-map-marked-alt"></i> Показать на схеме
            </button>
        </div>`;
    }
    
    // Блок: Фактические ЗУ под объектом
    if (nspdZuList.length > 0) {
        statusHtml += `<div class="oks-found-in-nspd">
            <div class="missing-title"><i class="fas fa-search-location"></i> Фактически ОКС расположен на (по данным ЕГРН): ${nspdZuList.length} участок(ов)</div>
            <ul class="oks-missing-list">
                ${nspdZuList.map(z => {
                    const isInXml = xmlCadNumbers.includes(z.cadNumber.toLowerCase());
                    const icon = isInXml ? 'fa-check-circle' : 'fa-exclamation-circle';
                    const iconColor = isInXml ? '#10b981' : '#f59e0b';
                    const statusText = isInXml ? '<span style="color:#10b981;">(указан в XML)</span>' : '<span style="color:#ef4444; font-weight:600;">(НЕ указан в XML)</span>';
                    return `<li>
                        <i class="fas fa-vector-square" style="color:${iconColor}; width:16px;"></i> 
                        <strong>${z.cadNumber}</strong>
                        ${statusText}
                        ${z.address ? '<br><span style="font-size:0.9em; color:var(--text-secondary); margin-left:24px;">' + z.address + '</span>' : ''}
                    </li>`;
                }).join('')}
            </ul>
        </div>`;
    }
    
    // Блок: Не указаны в XML, но ОКС на них расположен
    if (missingZu.length > 0) {
        statusHtml += `<div class="oks-missing-warning">
            <div class="missing-title"><i class="fas fa-exclamation-triangle"></i> Не указаны в XML, но ОКС на них расположен (${missingZu.length}):</div>
            <ul class="oks-missing-list">
                ${missingZu.map(z => `<li>
                    <i class="fas fa-times-circle" style="color:#ef4444; width:16px;"></i> 
                    <strong>${z.cadNumber}</strong>
                    ${z.address ? '<br><span style="font-size:0.9em; color:var(--text-secondary); margin-left:24px;">' + z.address + '</span>' : ''}
                </li>`).join('')}
            </ul>
        </div>`;
    } else if (nspdZuList.length > 0 && missingZu.length === 0 && wrongLocationZu.length === 0 && notFoundZu.length === 0) {
        statusHtml += `<div class="validation-message validation-success" style="margin-top:8px;">
            ${sectionIcons.successIcon} Все земельные участки указаны корректно — расхождений нет
        </div>`;
    }
    
    if (nspdZuList.length === 0 && contours.length > 0) {
        statusHtml += `<div class="validation-message" style="margin-top:8px; background:#f0f9ff; border:1px solid #bae6fd; color:#0369a1;">
            <i class="fas fa-info-circle"></i> Земельные участки под объектом в ЕГРН не обнаружены (возможно, объект расположен на землях неразграниченной госсобственности)
        </div>`;
    }
    
    statusDiv.innerHTML = statusHtml;
    
    // Добавляем обработчик для кнопки схемы
    const schemaBtn = document.getElementById('openTpSchemaBtn');
    if (schemaBtn) {
        schemaBtn.addEventListener('click', () => {
            openTpSchemaModal();
        });
    }
}

function openTpSchemaModal() {
    const modal = document.getElementById('oksSchemaModal');
    // Обновляем заголовок для ТП
    const headerTitle = modal.querySelector('.oks-schema-modal-header h2');
    if (headerTitle) {
        headerTitle.innerHTML = '<i class="fas fa-layer-group"></i> Схема расположения объекта';
    }
    // Обновляем легенду
    const legend = modal.querySelector('.oks-schema-legend');
    if (legend) {
        legend.innerHTML = `
            <div class="legend-item"><div class="legend-color" style="background:#ef4444;"></div><span>Контур ОКС</span></div>
            <div class="legend-item"><div class="legend-color" style="background:#2563eb;"></div><span>ЗУ (указанные в XML)</span></div>
            <div class="legend-item"><div class="legend-color" style="background:#f59e0b; border: 2px dashed #b45309;"></div><span>ЗУ (найденные в ЕГРН)</span></div>
        `;
    }
    modal.style.display = 'flex';
    setTimeout(() => {
        drawTpSchemaCanvas();
    }, 50);
}

function drawTpSchemaCanvas() {
    const canvas = document.getElementById('oksSchemaCanvas');
    const ctx = canvas.getContext('2d');
    const infoDiv = document.getElementById('oksSchemaInfo');
    
    const oksContours = currentTpOksContours || [];
    const xmlZu = currentTpZuData?.xmlZu || [];
    const nspdZu = currentTpZuData?.nspdZu || [];
    
    // ЗУ из XML с координатами
    const xmlZuWithCoords = xmlZu.filter(z => z.hasCoords);
    
    // ЗУ из ЕГРН, которые НЕ указаны в XML
    const xmlCadNumbers = xmlZu.map(z => z.cadNumber.toLowerCase());
    const nspdOnlyZu = nspdZu.filter(z => z.hasCoords && !xmlCadNumbers.includes(z.cadNumber.toLowerCase()));
    
    // Собираем все точки для расчета границ
    const allPoints = [];
    oksContours.forEach(contour => contour.forEach(p => allPoints.push(p)));
    xmlZuWithCoords.forEach(zu => zu.contours.forEach(contour => contour.forEach(p => allPoints.push(p))));
    nspdOnlyZu.forEach(zu => zu.contours.forEach(contour => contour.forEach(p => allPoints.push(p))));
    // Добавляем также ЗУ из XML которые есть в ЕГРН
    nspdZu.filter(z => z.hasCoords && xmlCadNumbers.includes(z.cadNumber.toLowerCase())).forEach(zu => 
        zu.contours.forEach(contour => contour.forEach(p => allPoints.push(p)))
    );
    
    if (allPoints.length === 0) {
        infoDiv.innerHTML = '<div style="color:var(--error-color);">Нет данных для отображения</div>';
        return;
    }
    
    const containerWidth = canvas.parentElement.clientWidth - 32;
    const displayWidth = Math.max(containerWidth, 400);
    const displayHeight = displayWidth * 0.7;
    const dpr = window.devicePixelRatio || 1;
    canvas.width = displayWidth * dpr;
    canvas.height = displayHeight * dpr;
    canvas.style.width = displayWidth + 'px';
    canvas.style.height = displayHeight + 'px';
    ctx.scale(dpr, dpr);
    ctx.clearRect(0, 0, displayWidth, displayHeight);
    
    const transforms = calculateSchemaTransforms(allPoints, displayWidth, displayHeight);
    const { minGeoX, maxGeoX, minGeoY, scale, offsetX_canvas, offsetY_canvas } = transforms;
    
    const toCanvas = (point) => ({
        x: offsetX_canvas + (point.y - transforms.minGeoY) * scale,
        y: offsetY_canvas + (maxGeoX - point.x) * scale
    });
    
    let infoHtml = '';
    
    // 1. Рисуем ЗУ из XML (синим цветом)
    const zuColors = ['#2563eb', '#3b82f6', '#60a5fa', '#93c5fd'];
    let zuColorIndex = 0;
    
    // Найдем ЗУ из nspdZu которые совпадают с XML (чтобы взять их координаты)
    xmlZu.forEach(xmlZuItem => {
        const nspdMatch = nspdZu.find(n => n.cadNumber.toLowerCase() === xmlZuItem.cadNumber.toLowerCase());
        const contoursToUse = nspdMatch?.contours || xmlZuItem.contours || [];
        
        if (contoursToUse.length === 0) return;
        
        const color = zuColors[zuColorIndex % zuColors.length];
        zuColorIndex++;
        
        ctx.strokeStyle = color;
        ctx.lineWidth = 2;
        const r = parseInt(color.slice(1, 3), 16);
        const g = parseInt(color.slice(3, 5), 16);
        const b = parseInt(color.slice(5, 7), 16);
        ctx.fillStyle = `rgba(${r}, ${g}, ${b}, 0.15)`;
        
        contoursToUse.forEach(contour => {
            if (contour.length < 2) return;
            ctx.beginPath();
            const canvasPoints = contour.map(toCanvas);
            canvasPoints.forEach((cp, i) => i === 0 ? ctx.moveTo(cp.x, cp.y) : ctx.lineTo(cp.x, cp.y));
            const isClosed = contour.length > 2 && 
                Math.abs(contour[0].x - contour[contour.length - 1].x) < 1e-3 && 
                Math.abs(contour[0].y - contour[contour.length - 1].y) < 1e-3;
            if (isClosed) {
                ctx.closePath();
                ctx.fill();
            }
            ctx.stroke();
        });
        
        infoHtml += `<div class="oks-info-item">
            <div class="color-marker" style="background:${color};"></div>
            <strong>${xmlZuItem.cadNumber}</strong> — ЗУ из XML ${xmlZuItem.address ? '(' + xmlZuItem.address + ')' : ''} <span style="color:#10b981;">(указан)</span>
        </div>`;
    });
    
    // 2. Рисуем ЗУ из ЕГРН, которые НЕ указаны в XML (оранжевым пунктиром)
    nspdOnlyZu.forEach(zu => {
        const color = '#f59e0b';
        ctx.strokeStyle = color;
        ctx.lineWidth = 2;
        ctx.setLineDash([5, 5]);
        ctx.fillStyle = 'rgba(245, 158, 11, 0.15)';
        
        zu.contours.forEach(contour => {
            if (contour.length < 2) return;
            ctx.beginPath();
            const canvasPoints = contour.map(toCanvas);
            canvasPoints.forEach((cp, i) => i === 0 ? ctx.moveTo(cp.x, cp.y) : ctx.lineTo(cp.x, cp.y));
            const isClosed = contour.length > 2 && 
                Math.abs(contour[0].x - contour[contour.length - 1].x) < 1e-3 && 
                Math.abs(contour[0].y - contour[contour.length - 1].y) < 1e-3;
            if (isClosed) {
                ctx.closePath();
                ctx.fill();
            }
            ctx.stroke();
        });
        ctx.setLineDash([]);
        
        infoHtml += `<div class="oks-info-item">
            <div class="color-marker" style="background:${color}; border: 2px dashed #b45309;"></div>
            <strong>${zu.cadNumber}</strong> — ЗУ из ЕГРН ${zu.address ? '(' + zu.address + ')' : ''} <span style="color:#ef4444; font-weight:600;">(НЕ указан в XML!)</span>
        </div>`;
    });
    
    // 3. Рисуем контур ОКС (красным цветом, поверх всего)
    if (oksContours.length > 0) {
        const oksColor = '#ef4444';
        ctx.strokeStyle = oksColor;
        ctx.lineWidth = 3;
        ctx.fillStyle = 'rgba(239, 68, 68, 0.3)';
        ctx.setLineDash([]);
        
        oksContours.forEach(contour => {
            if (contour.length < 2) return;
            ctx.beginPath();
            const canvasPoints = contour.map(toCanvas);
            canvasPoints.forEach((cp, i) => i === 0 ? ctx.moveTo(cp.x, cp.y) : ctx.lineTo(cp.x, cp.y));
            
            // Проверяем замкнутость
            const isClosed = contour.length > 2 && 
                Math.abs(contour[0].x - contour[contour.length - 1].x) < 1e-3 && 
                Math.abs(contour[0].y - contour[contour.length - 1].y) < 1e-3;
            
            if (isClosed) {
                ctx.closePath();
                ctx.fill();
            }
            ctx.stroke();
        });
        
        // Получаем информацию об ОКС из XML
        const mainObject = lastXmlDoc?.querySelector('NewBuilding, ExistBuilding, NewConstruction, ExistConstruction, NewFlat, ExistFlat');
        const oksCadNum = mainObject?.getAttribute('CadastralNumber') || 'Объект капитального строительства';
        const oksName = mainObject?.querySelector('Name, ObjectName')?.textContent?.trim() || '';
        
        // Добавляем в начало списка
        infoHtml = `<div class="oks-info-item">
            <div class="color-marker" style="background:#ef4444;"></div>
            <strong>${oksCadNum}</strong> — Контур ОКС ${oksName ? '(' + oksName + ')' : ''}
        </div>` + infoHtml;
    }
    
    infoDiv.innerHTML = infoHtml;
}




    function extractParcelContoursFromXml() {
        if (!lastXmlDoc) return [];
        const contours = [];
        const mainParcel = lastXmlDoc.querySelector('NewParcel, SpecifyParcel > ExistParcel');
        if (!mainParcel) return contours;
        const spatialElements = mainParcel.querySelectorAll('EntitySpatial SpatialElement, EntitySpatial > SpatialElement');
        spatialElements.forEach(spatialEl => {
            const ordinates = spatialEl.querySelectorAll('Ordinate, NewOrdinate');
            const contourPoints = [];
            ordinates.forEach(ord => {
                const x = parseFloat(ord.getAttribute('X'));
                const y = parseFloat(ord.getAttribute('Y'));
                if (!isNaN(x) && !isNaN(y)) {
                    contourPoints.push({ x, y });
                }
            });
            if (contourPoints.length > 0) {
                contours.push(contourPoints);
            }
        });
        if (contours.length === 0) {
            const ordinates = mainParcel.querySelectorAll('EntitySpatial Ordinate, EntitySpatial NewOrdinate');
            const contourPoints = [];
            ordinates.forEach(ord => {
                const x = parseFloat(ord.getAttribute('X'));
                const y = parseFloat(ord.getAttribute('Y'));
                if (!isNaN(x) && !isNaN(y)) {
                    contourPoints.push({ x, y });
                }
            });
            if (contourPoints.length > 0) {
                contours.push(contourPoints);
            }
        }
        return contours;
    }

    function getParcelCadastralNumber() {
        if (!lastXmlDoc) return null;
        const specifyParcel = lastXmlDoc.querySelector('SpecifyParcel > ExistParcel');
        if (specifyParcel) {
            return specifyParcel.getAttribute('CadastralNumber');
        }
        const newParcel = lastXmlDoc.querySelector('NewParcel');
        if (newParcel) {
            const cadBlock = newParcel.querySelector('CadastralBlock');
            if (cadBlock) return cadBlock.textContent.trim();
        }
        return null;
    }

    async function searchIntersectingObjects(parcelContours, categoryId, mskSystem) {
        if (!parcelContours || parcelContours.length === 0 || !mskSystem) return [];
        try {
            const outerRing = parcelContours[0];
            if (outerRing.length < 3) return [];
            const transformedRing = outerRing.map(point => {
                return convertMskTo3857(point, mskSystem);
            }).filter(c => c !== null);
            if (transformedRing.length < 3) return [];
            const geometryForApi = {
                "crs": { "type": "name", "properties": { "name": "EPSG:3857" } },
                "type": "Polygon",
                "coordinates": [transformedRing]
            };
            const requestBody = {
                "geom": { 
                    "type": "FeatureCollection", 
                    "features": [{ "type": "Feature", "geometry": geometryForApi, "properties": {} }] 
                },
                "categories": [{ "id": categoryId }]
            };
            const response = await fetch('https://nspd.gov.ru/api/geoportal/v1/intersects?typeIntersect=fullObject', {
                method: 'POST', 
                headers: { 'Content-Type': 'application/json' }, 
                body: JSON.stringify(requestBody)
            });
            if (!response.ok) {
                console.error(`Ошибка запроса для категории ${categoryId}: ${response.status}`);
                return [];
            }
            const data = await response.json();
            return data.features || [];
        } catch (error) {
            console.error(`Ошибка при поиске пересечений для категории ${categoryId}:`, error);
            return [];
        }
    }

    async function searchAllOksOnParcel(parcelContours, mskSystem) {
        const buildings = await searchIntersectingObjects(parcelContours, NSPD_CATEGORY_BUILDINGS, mskSystem);
        const constructions = await searchIntersectingObjects(parcelContours, NSPD_CATEGORY_CONSTRUCTIONS, mskSystem);
        const allOks = [];
        buildings.forEach(f => {
            const cadNum = f.properties?.options?.cad_number || f.properties?.options?.cad_num;
            if (cadNum) {
                allOks.push({
                    cadNumber: cadNum,
                    type: 'Здание',
                    address: f.properties?.options?.readable_address || f.properties?.options?.address_readable_address || '',
                    geometry: f.geometry,
                    source: 'nspd'
                });
            }
        });
        constructions.forEach(f => {
            const cadNum = f.properties?.options?.cad_number || f.properties?.options?.cad_num;
            if (cadNum) {
                allOks.push({
                    cadNumber: cadNum,
                    type: 'Сооружение',
                    address: f.properties?.options?.readable_address || f.properties?.options?.address_readable_address || '',
                    geometry: f.geometry,
                    source: 'nspd'
                });
            }
        });
        return allOks;
    }

    async function convertEgrnGeometryToMsk(geometry, mskSystem) {
        if (!geometry || !mskSystem) return [];
        const convertedContours = [];
        const convertRing = ring => ring.map(coord => convert3857ToMsk(coord, mskSystem)).filter(p => p !== null);
        const processGeom = (geom) => {
            if (!geom) return;
            if (geom.type === 'Polygon') {
                geom.coordinates.forEach(ring => {
                    const converted = convertRing(ring);
                    if (converted.length > 0) convertedContours.push(converted);
                });
            } else if (geom.type === 'MultiPolygon') {
                geom.coordinates.forEach(polygon => polygon.forEach(ring => {
                    const converted = convertRing(ring);
                    if (converted.length > 0) convertedContours.push(converted);
                }));
            } else if (geom.type === 'GeometryCollection') {
                geom.geometries.forEach(processGeom);
            }
        };
        processGeom(geometry);
        return convertedContours;
    }


async function fetchEgrnCoordinates(cadNumber) {
    const url = `https://nspd.gov.ru/api/geoportal/v2/search/geoportal?thematicSearchId=1&query=${encodeURIComponent(cadNumber)}`;
    
    const response = await fetch(url);
    if (!response.ok) {
        throw new Error(`Ошибка сети: ${response.status}`);
    }
    
    const data = await response.json();
    
    if (data.code === 204 || !data.data?.features?.length) {
        throw new Error(`Участок ${cadNumber} не найден в ЕГРН`);
    }
    
    const feature = data.data.features[0];
    if (!feature.geometry) {
        throw new Error(`Геометрия для ${cadNumber} отсутствует в ЕГРН`);
    }
    
    // Определяем МСК для региона
    const mskSystem = detectMskSystem(cadNumber);
    if (!mskSystem) {
        throw new Error(`Не удалось определить МСК для региона`);
    }
    
    // Конвертируем из EPSG:3857 в МСК
    const contours = await convertEgrnGeometryToMsk(feature.geometry, mskSystem);
    
    return contours;
}



async function checkOksInEgrn(oksNumbers, button) {
    if (!oksNumbers || oksNumbers.length === 0) return;
    
    const container = button.closest('.subsection');
    const statusDiv = container.querySelector('.oks-check-status');
    const originalButtonHtml = button.innerHTML;
    
    button.disabled = true;
    button.innerHTML = '<i class="fas fa-sync-alt fa-spin"></i> <span class="btn-text">Подготовка...</span>';
    statusDiv.innerHTML = '';
    
    const cadNumber = getParcelCadastralNumber();
    if (cadNumber) {
        currentMskSystem = detectMskSystem(cadNumber);
    }
    
    const allOksContours = [];
    const notFoundOks = [];
    let successCount = 0;
    let errorCount = 0;
    
    // Временно сохраняем данные о загруженных ОКС для последующей проверки
    const loadedOksData = new Map();
    
    for (let i = 0; i < oksNumbers.length; i++) {
        const cadNum = oksNumbers[i];
        const oksCard = container.querySelector(`.oks-item[data-cad-number="${cadNum}"]`);
        const addressDiv = oksCard?.querySelector('.oks-address');
        
        if (i > 0) {
            await delay(1000);
        }
        
        button.innerHTML = `<i class="fas fa-sync-alt fa-spin"></i> <span class="btn-text">ОКС ${i + 1}/${oksNumbers.length}</span>`;
        
        try {
            const url = `https://nspd.gov.ru/api/geoportal/v2/search/geoportal?thematicSearchId=1&query=${encodeURIComponent(cadNum)}`;
            const response = await fetch(url);
            const data = await response.json();
            
            if (data.code === 204 || response.status === 204) {
                if (addressDiv) {
                    addressDiv.innerHTML = '<span style="color:var(--error-color);"><i class="fas fa-question-circle"></i> Не найден в ЕГРН</span>';
                }
                notFoundOks.push(cadNum);
                errorCount++;
                continue;
            }
            
            if (!response.ok) {
                throw new Error(`Ошибка сервера ${response.status}`);
            }
            
            const feature = data?.data?.features?.[0];
            
            if (!feature) {
                if (addressDiv) {
                    addressDiv.innerHTML = '<span style="color:var(--error-color);"><i class="fas fa-question-circle"></i> Не найден в ЕГРН</span>';
                }
                notFoundOks.push(cadNum);
                errorCount++;
                continue;
            }
            
            const options = feature.properties?.options || {};
            const address = options.readable_address || options.address_readable_address || 'Адрес не указан';
            
            // Пока ставим временную иконку загрузки, позже обновим
            if (addressDiv) {
                addressDiv.innerHTML = `<i class="fas fa-hourglass-half" style="color:var(--text-secondary);"></i> ${address}`;
            }
            
            let contours = [];
            if (feature.geometry && currentMskSystem) {
                contours = await convertEgrnGeometryToMsk(feature.geometry, currentMskSystem);
            }
            
            const oksData = { 
                cadNumber: cadNum, 
                contours: contours,
                address: address,
                hasCoords: contours.length > 0,
                source: 'xml',
                addressDiv: addressDiv
            };
            
            allOksContours.push(oksData);
            loadedOksData.set(cadNum.toLowerCase(), oksData);
            successCount++;
            
        } catch (err) {
            console.error(`Ошибка загрузки ОКС ${cadNum}:`, err);
            if (addressDiv) {
                addressDiv.innerHTML = `<span style="color:var(--warning-color);"><i class="fas fa-exclamation-triangle"></i> Ошибка запроса</span>`;
            }
            errorCount++;
        }
    }
    
    currentOksData = allOksContours;
    
    await delay(1000);
    
    button.innerHTML = '<i class="fas fa-sync-alt fa-spin"></i> <span class="btn-text">Поиск зданий...</span>';
    
    const parcelContours = extractParcelContoursFromXml();
    let nspdOks = [];
    
    if (parcelContours.length > 0 && currentMskSystem) {
        const buildings = await searchIntersectingObjects(parcelContours, NSPD_CATEGORY_BUILDINGS, currentMskSystem);
        
        await delay(1000);
        
        button.innerHTML = '<i class="fas fa-sync-alt fa-spin"></i> <span class="btn-text">Поиск сооружений...</span>';
        
        const constructions = await searchIntersectingObjects(parcelContours, NSPD_CATEGORY_CONSTRUCTIONS, currentMskSystem);
        
        button.innerHTML = '<i class="fas fa-sync-alt fa-spin"></i> <span class="btn-text">Обработка данных...</span>';
        
        for (const f of buildings) {
            const cadNum = f.properties?.options?.cad_number || f.properties?.options?.cad_num;
            if (cadNum) {
                const oksItem = {
                    cadNumber: cadNum,
                    type: 'Здание',
                    address: f.properties?.options?.readable_address || f.properties?.options?.address_readable_address || '',
                    geometry: f.geometry,
                    source: 'nspd',
                    contours: [],
                    hasCoords: false
                };
                if (f.geometry) {
                    oksItem.contours = await convertEgrnGeometryToMsk(f.geometry, currentMskSystem);
                    oksItem.hasCoords = oksItem.contours && oksItem.contours.length > 0;
                }
                nspdOks.push(oksItem);
            }
        }
        
        for (const f of constructions) {
            const cadNum = f.properties?.options?.cad_number || f.properties?.options?.cad_num;
            if (cadNum) {
                const oksItem = {
                    cadNumber: cadNum,
                    type: 'Сооружение',
                    address: f.properties?.options?.readable_address || f.properties?.options?.address_readable_address || '',
                    geometry: f.geometry,
                    source: 'nspd',
                    contours: [],
                    hasCoords: false
                };
                if (f.geometry) {
                    oksItem.contours = await convertEgrnGeometryToMsk(f.geometry, currentMskSystem);
                    oksItem.hasCoords = oksItem.contours && oksItem.contours.length > 0;
                }
                nspdOks.push(oksItem);
            }
        }
    }
    
    currentNspdOksData = nspdOks;
    
    // Получаем список кадастровых номеров ОКС на участке
    const nspdCadNumbers = nspdOks.map(o => o.cadNumber.toLowerCase());
    
    // Проверяем какие ОКС из XML находятся не на этом участке
    const wrongLocationOks = [];
    const correctOks = [];
    
    for (const [cadNumLower, oksData] of loadedOksData) {
        if (nspdCadNumbers.includes(cadNumLower)) {
            // ОКС найден на участке - всё ок
            correctOks.push(oksData);
            if (oksData.addressDiv) {
                oksData.addressDiv.innerHTML = `<i class="fas fa-check-circle" style="color:var(--success-color);"></i> ${oksData.address}`;
            }
        } else {
            // ОКС существует в ЕГРН, но находится не на этом участке
            wrongLocationOks.push(oksData);
            if (oksData.addressDiv) {
                oksData.addressDiv.innerHTML = `<span style="color:var(--warning-color);"><i class="fas fa-map-marker-alt"></i> ${oksData.address}</span><br><span style="font-size:0.85em; color:var(--error-color);"><i class="fas fa-exclamation-triangle"></i> Расположен на другом участке!</span>`;
            }
        }
    }
    
    button.disabled = false;
    button.innerHTML = originalButtonHtml;
    
    const xmlCadNumbers = oksNumbers.map(n => n.trim().toLowerCase());
    const missingOks = nspdOks.filter(oks => !xmlCadNumbers.includes(oks.cadNumber.toLowerCase()));
    const oksWithCoords = allOksContours.filter(o => o.hasCoords).length;
    
    let statusHtml = '';
    
    // Блок: ОКС указаны в XML, но находятся на другом участке
    if (wrongLocationOks.length > 0) {
        statusHtml += `<div class="validation-message validation-error" style="margin-top:8px; flex-direction:column; align-items:flex-start;">
            <div style="display:flex; align-items:center; gap:8px; margin-bottom:8px;">
                <i class="fas fa-map-marker-alt" style="color:#ef4444;"></i>
                <strong>Указаны в XML, но расположены на другом участке (${wrongLocationOks.length}):</strong>
            </div>
            <div style="font-size:0.9em; color:#991b1b;">
                Следующие объекты существуют в ЕГРН, но находятся не на данном земельном участке. Вероятно, указаны ошибочно:
            </div>
            <ul style="margin:8px 0 0 0; padding-left:0; list-style:none;">
                ${wrongLocationOks.map(o => `<li style="padding:4px 0;">
                    <i class="fas fa-times-circle" style="color:#ef4444;"></i> 
                    <code style="background:#fee2e2; padding:2px 6px; border-radius:4px;">${o.cadNumber}</code>
                    <br><span style="font-size:0.85em; color:var(--text-secondary); margin-left:20px;">${o.address}</span>
                </li>`).join('')}
            </ul>
        </div>`;
    }
    
    // Блок: ОКС не найдены в ЕГРН
    if (notFoundOks.length > 0) {
        statusHtml += `<div class="validation-message validation-error" style="margin-top:8px; flex-direction:column; align-items:flex-start;">
            <div style="display:flex; align-items:center; gap:8px; margin-bottom:8px;">
                ${sectionIcons.errorIcon} 
                <strong>Не найдены в ЕГРН (${notFoundOks.length}):</strong>
            </div>
            <div style="font-size:0.9em; color:#991b1b;">
                Возможно, кадастровые номера указаны ошибочно или объекты сняты с учёта:
            </div>
            <ul style="margin:8px 0 0 0; padding-left:0; list-style:none;">
                ${notFoundOks.map(kn => `<li style="padding:2px 0;"><i class="fas fa-question-circle" style="color:#ef4444;"></i> <code style="background:#fee2e2; padding:2px 6px; border-radius:4px;">${kn}</code></li>`).join('')}
            </ul>
        </div>`;
    }
    
    // Блок: Успешно проверенные ОКС
    if (correctOks.length > 0) {
        statusHtml += `<div class="validation-message validation-success" style="margin-top:8px; flex-wrap:wrap;">
            ${sectionIcons.successIcon} Корректно указаны: ${correctOks.length} из ${oksNumbers.length} ОКС.`;
        if (oksWithCoords > 0 || nspdOks.length > 0) {
            statusHtml += `
                <button class="print-btn" style="padding:6px 14px; font-size:0.9rem; margin-left:12px;" id="openOksSchemaBtn">
                    <i class="fas fa-map-marked-alt"></i> Показать на схеме
                </button>`;
        }
        statusHtml += `</div>`;
    } else if (successCount > 0 && wrongLocationOks.length > 0) {
        // Все найденные ОКС на других участках
        statusHtml += `<div class="validation-message validation-warning" style="margin-top:8px;">
            ${sectionIcons.warningIcon} Ни один из указанных ОКС не находится на данном участке
        </div>`;
    }
    
    // Блок: Найдено на участке
    if (nspdOks.length > 0) {
        statusHtml += `<div class="oks-found-in-nspd">
            <div class="missing-title"><i class="fas fa-search-location"></i> Фактически на участке находятся (по данным ЕГРН): ${nspdOks.length} объект(ов)</div>
            <ul class="oks-missing-list">
                ${nspdOks.map(o => {
                    const isInXml = xmlCadNumbers.includes(o.cadNumber.toLowerCase());
                    const icon = isInXml ? 'fa-check-circle' : 'fa-exclamation-circle';
                    const iconColor = isInXml ? '#10b981' : '#f59e0b';
                    const statusText = isInXml ? '<span style="color:#10b981;">(указан в XML)</span>' : '<span style="color:#ef4444; font-weight:600;">(НЕ указан в XML)</span>';
                    return `<li>
                        <i class="fas ${o.type === 'Здание' ? 'fa-building' : 'fa-industry'}" style="color:${iconColor}; width:16px;"></i> 
                        <strong>${o.cadNumber}</strong> 
                        <span style="color:var(--text-secondary);">(${o.type})</span>
                        ${statusText}
                        ${o.address ? '<br><span style="font-size:0.9em; color:var(--text-secondary); margin-left:24px;">' + o.address + '</span>' : ''}
                    </li>`;
                }).join('')}
            </ul>
        </div>`;
    }
    
    // Блок: Не указаны в XML, но найдены на участке
    if (missingOks.length > 0) {
        statusHtml += `<div class="oks-missing-warning">
            <div class="missing-title"><i class="fas fa-exclamation-triangle"></i> Не указаны в XML, но найдены на участке (${missingOks.length}):</div>
            <ul class="oks-missing-list">
                ${missingOks.map(o => `<li>
                    <i class="fas fa-times-circle" style="color:#ef4444; width:16px;"></i> 
                    <strong>${o.cadNumber}</strong> 
                    <span style="color:var(--text-secondary);">(${o.type})</span>
                    ${o.address ? '<br><span style="font-size:0.9em; color:var(--text-secondary); margin-left:24px;">' + o.address + '</span>' : ''}
                </li>`).join('')}
            </ul>
        </div>`;
    } else if (nspdOks.length > 0 && missingOks.length === 0 && wrongLocationOks.length === 0 && notFoundOks.length === 0) {
        statusHtml += `<div class="validation-message validation-success" style="margin-top:8px;">
            ${sectionIcons.successIcon} Все ОКС указаны корректно — расхождений нет
        </div>`;
    }
    
    if (nspdOks.length === 0 && parcelContours.length > 0) {
        statusHtml += `<div class="validation-message" style="margin-top:8px; background:#f0f9ff; border:1px solid #bae6fd; color:#0369a1;">
            <i class="fas fa-info-circle"></i> ОКС на данном участке в ЕГРН не обнаружено
        </div>`;
    }
    
    if (parcelContours.length === 0) {
        statusHtml += `<div class="validation-message validation-warning" style="margin-top:8px;">
            ${sectionIcons.warningIcon} Не удалось выполнить проверку расположения — координаты участка не найдены в XML
        </div>`;
    }
    
    statusDiv.innerHTML = statusHtml;
    
    const schemaBtn = document.getElementById('openOksSchemaBtn');
    if (schemaBtn) {
        schemaBtn.addEventListener('click', () => {
            openOksSchemaModal();
        });
    }
}

    function openOksSchemaModal() {
        const modal = document.getElementById('oksSchemaModal');
        modal.style.display = 'flex';
        setTimeout(() => {
            drawOksSchemaCanvas();
        }, 50);
    }

function closeOksSchemaModal() {
    const modal = document.getElementById('oksSchemaModal');
    modal.style.display = 'none';
    
    // Сбрасываем заголовок на дефолтный (для МП)
    const headerTitle = modal.querySelector('.oks-schema-modal-header h2');
    if (headerTitle) {
        headerTitle.innerHTML = '<i class="fas fa-layer-group"></i> Схема расположения ОКС';
    }
    const legend = modal.querySelector('.oks-schema-legend');
    if (legend) {
        legend.innerHTML = `
            <div class="legend-item"><div class="legend-color" style="background:#2563eb;"></div><span>Земельный участок</span></div>
            <div class="legend-item"><div class="legend-color" style="background:#ef4444;"></div><span>ОКС (указанные)</span></div>
            <div class="legend-item"><div class="legend-color" style="background:#f59e0b; border: 2px dashed #b45309;"></div><span>ОКС (найденные в ЕГРН)</span></div>
        `;
    }
}

    function drawOksSchemaCanvas() {
        const canvas = document.getElementById('oksSchemaCanvas');
        const ctx = canvas.getContext('2d');
        const infoDiv = document.getElementById('oksSchemaInfo');
        const parcelContours = extractParcelContoursFromXml();
        const xmlOks = currentOksData ? currentOksData.filter(o => o.hasCoords) : [];
        const nspdOks = currentNspdOksData ? currentNspdOksData.filter(o => o.hasCoords) : [];
        const xmlCadNumbers = (currentOksData || []).map(o => o.cadNumber.toLowerCase());
        const nspdOnlyOks = nspdOks.filter(o => !xmlCadNumbers.includes(o.cadNumber.toLowerCase()));
        const allPoints = [];
        parcelContours.forEach(contour => contour.forEach(p => allPoints.push(p)));
        xmlOks.forEach(oks => oks.contours.forEach(contour => contour.forEach(p => allPoints.push(p))));
        nspdOnlyOks.forEach(oks => oks.contours.forEach(contour => contour.forEach(p => allPoints.push(p))));
        if (allPoints.length === 0) {
            infoDiv.innerHTML = '<div style="color:var(--error-color);">Нет данных для отображения</div>';
            return;
        }
        const containerWidth = canvas.parentElement.clientWidth - 32;
        const displayWidth = Math.max(containerWidth, 400);
        const displayHeight = displayWidth * 0.7;
        const dpr = window.devicePixelRatio || 1;
        canvas.width = displayWidth * dpr;
        canvas.height = displayHeight * dpr;
        canvas.style.width = displayWidth + 'px';
        canvas.style.height = displayHeight + 'px';
        ctx.scale(dpr, dpr);
        ctx.clearRect(0, 0, displayWidth, displayHeight);
        const transforms = calculateSchemaTransforms(allPoints, displayWidth, displayHeight);
        const { minGeoX, maxGeoX, minGeoY, scale, offsetX_canvas, offsetY_canvas } = transforms;
        const toCanvas = (point) => ({
            x: offsetX_canvas + (point.y - transforms.minGeoY) * scale,
            y: offsetY_canvas + (maxGeoX - point.x) * scale
        });
        ctx.strokeStyle = '#2563eb';
        ctx.lineWidth = 3;
        ctx.fillStyle = 'rgba(37, 99, 235, 0.15)';
        parcelContours.forEach(contour => {
            if (contour.length < 2) return;
            ctx.beginPath();
            const canvasPoints = contour.map(toCanvas);
            canvasPoints.forEach((cp, i) => i === 0 ? ctx.moveTo(cp.x, cp.y) : ctx.lineTo(cp.x, cp.y));
            const isClosed = contour.length > 2 && 
                Math.abs(contour[0].x - contour[contour.length - 1].x) < 1e-3 && 
                Math.abs(contour[0].y - contour[contour.length - 1].y) < 1e-3;
            if (isClosed) {
                ctx.closePath();
                ctx.fill();
            }
            ctx.stroke();
        });
        const oksColors = ['#ef4444', '#f97316', '#ec4899', '#14b8a6', '#84cc16'];
        let infoHtml = '';
        const mainParcel = lastXmlDoc?.querySelector('NewParcel, SpecifyParcel > ExistParcel');
        const parcelCadNum = mainParcel?.getAttribute('CadastralNumber') || mainParcel?.getAttribute('Definition') || 'Земельный участок';
        infoHtml = `<div class="oks-info-item">
            <div class="color-marker" style="background:#2563eb;"></div>
            <strong>${parcelCadNum}</strong> — Земельный участок из межевого плана
        </div>`;
        xmlOks.forEach((oks, index) => {
            const color = oksColors[index % oksColors.length];
            ctx.strokeStyle = color;
            ctx.lineWidth = 2;
            const r = parseInt(color.slice(1, 3), 16);
            const g = parseInt(color.slice(3, 5), 16);
            const b = parseInt(color.slice(5, 7), 16);
            ctx.fillStyle = `rgba(${r}, ${g}, ${b}, 0.3)`;
            oks.contours.forEach(contour => {
                if (contour.length < 2) return;
                ctx.beginPath();
                const canvasPoints = contour.map(toCanvas);
                canvasPoints.forEach((cp, i) => i === 0 ? ctx.moveTo(cp.x, cp.y) : ctx.lineTo(cp.x, cp.y));
                const isClosed = contour.length > 2 && 
                    Math.abs(contour[0].x - contour[contour.length - 1].x) < 1e-3 && 
                    Math.abs(contour[0].y - contour[contour.length - 1].y) < 1e-3;
                if (isClosed) {
                    ctx.closePath();
                    ctx.fill();
                }
                ctx.stroke();
            });
            infoHtml += `<div class="oks-info-item">
                <div class="color-marker" style="background:${color};"></div>
                <strong>${oks.cadNumber}</strong> — ${oks.address} <span style="color:#10b981;">(указан в XML)</span>
            </div>`;
        });
        nspdOnlyOks.forEach((oks) => {
            const color = '#f59e0b';
            ctx.strokeStyle = color;
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);
            ctx.fillStyle = 'rgba(245, 158, 11, 0.2)';
            oks.contours.forEach(contour => {
                if (contour.length < 2) return;
                ctx.beginPath();
                const canvasPoints = contour.map(toCanvas);
                canvasPoints.forEach((cp, i) => i === 0 ? ctx.moveTo(cp.x, cp.y) : ctx.lineTo(cp.x, cp.y));
                const isClosed = contour.length > 2 && 
                    Math.abs(contour[0].x - contour[contour.length - 1].x) < 1e-3 && 
                    Math.abs(contour[0].y - contour[contour.length - 1].y) < 1e-3;
                if (isClosed) {
                    ctx.closePath();
                    ctx.fill();
                }
                ctx.stroke();
            });
            ctx.setLineDash([]);
            infoHtml += `<div class="oks-info-item">
                <div class="color-marker" style="background:${color}; border: 2px dashed #b45309;"></div>
                <strong>${oks.cadNumber}</strong> — ${oks.address} <span style="color:#ef4444; font-weight:600;">(НЕ указан в XML!)</span>
            </div>`;
        });
        infoDiv.innerHTML = infoHtml;
    }

    function calculateSchemaTransforms(points, canvasWidth, canvasHeight) {
        let minGeoX = Infinity, maxGeoX = -Infinity, minGeoY = Infinity, maxGeoY = -Infinity;
        points.forEach(p => {
            minGeoX = Math.min(minGeoX, p.x);
            maxGeoX = Math.max(maxGeoX, p.x);
            minGeoY = Math.min(minGeoY, p.y);
            maxGeoY = Math.max(maxGeoY, p.y);
        });
        const dataGeoWidth = (maxGeoY - minGeoY) || 1;
        const dataGeoHeight = (maxGeoX - minGeoX) || 1;
        const padding = 40;
        const scaleMultiplier = 0.9;
        const effectiveCanvasWidth = canvasWidth - 2 * padding;
        const effectiveCanvasHeight = canvasHeight - 2 * padding;
        const scale = Math.min(effectiveCanvasWidth / dataGeoWidth, effectiveCanvasHeight / dataGeoHeight) * scaleMultiplier;
        const offsetX_canvas = padding + (effectiveCanvasWidth - dataGeoWidth * scale) / 2;
        const offsetY_canvas = padding + (effectiveCanvasHeight - dataGeoHeight * scale) / 2;
        return { minGeoX, maxGeoX, minGeoY, maxGeoY, scale, offsetX_canvas, offsetY_canvas };
    }



// ============== ПРОВЕРКА ГРАНИЦ СМЕЖНОГО ЗУ ==============

function extractSpecifyRelatedParcelData(specifyRelatedParcel) {
    const cadNumber = specifyRelatedParcel.getAttribute('CadastralNumber');
    const changeBorders = All(specifyRelatedParcel, 'ChangeBorder');
    
    const junctionPoints = [];  // Точки стыковки (есть Old и New с одинаковыми координатами)
    const removedPoints = [];   // Удаляемые точки (только Old)
    const newPoints = [];       // Новые точки (только New с PointPref="н")
    
    changeBorders.forEach(cb => {
        const oldOrd = E(cb, 'OldOrdinate');
        const newOrd = E(cb, 'NewOrdinate');
        
        if (oldOrd && newOrd) {
            // Точка стыковки - координаты должны совпадать
            const oldX = parseFloat(A(oldOrd, 'X'));
            const oldY = parseFloat(A(oldOrd, 'Y'));
            const newX = parseFloat(A(newOrd, 'X'));
            const newY = parseFloat(A(newOrd, 'Y'));
            
            if (Math.abs(oldX - newX) < 0.01 && Math.abs(oldY - newY) < 0.01) {
                junctionPoints.push({
                    x: oldX,
                    y: oldY,
                    oldNum: A(oldOrd, 'NumGeopoint'),
                    newNum: A(newOrd, 'NumGeopoint')
                });
            }
        } else if (oldOrd && !newOrd) {
            // Удаляемая точка
            removedPoints.push({
                x: parseFloat(A(oldOrd, 'X')),
                y: parseFloat(A(oldOrd, 'Y')),
                num: A(oldOrd, 'NumGeopoint')
            });
        } else if (!oldOrd && newOrd) {
            // Новая точка
            const pref = A(newOrd, 'PointPref');
            if (pref === 'н') {
                newPoints.push({
                    x: parseFloat(A(newOrd, 'X')),
                    y: parseFloat(A(newOrd, 'Y')),
                    num: A(newOrd, 'NumGeopoint')
                });
            }
        }
    });
    
    return { cadNumber, junctionPoints, removedPoints, newPoints };
}

function findPointInContour(contour, targetPoint, tolerance = 0.5) {
    for (let i = 0; i < contour.length; i++) {
        const dist = Math.sqrt(
            Math.pow(contour[i].x - targetPoint.x, 2) + 
            Math.pow(contour[i].y - targetPoint.y, 2)
        );
        if (dist <= tolerance) {
            return i;
        }
    }
    return -1;
}

function applyBorderChangesToContour(egrnContour, junctionPoints, removedPoints, newPoints) {
    const errors = [];
    
    if (junctionPoints.length < 2) {
        errors.push('Недостаточно точек стыковки (требуется минимум 2)');
        return { resultContour: null, errors, appliedChanges: null };
    }
    
    // Убираем замыкающую точку если есть
    let workContour = [...egrnContour];
    if (workContour.length > 2) {
        const first = workContour[0];
        const last = workContour[workContour.length - 1];
        if (Math.abs(first.x - last.x) < 0.01 && Math.abs(first.y - last.y) < 0.01) {
            workContour.pop();
        }
    }
    
    // Находим индексы точек стыковки
    const junctionIndices = [];
    junctionPoints.forEach((jp, jpIdx) => {
        const idx = findPointInContour(workContour, jp);
        if (idx === -1) {
            errors.push(`Точка стыковки ${jpIdx + 1} (${jp.x.toFixed(2)}, ${jp.y.toFixed(2)}) не найдена в контуре ЕГРН`);
        } else {
            junctionIndices.push({ idx, point: jp });
        }
    });
    
    if (junctionIndices.length < 2) {
        return { resultContour: null, errors, appliedChanges: null };
    }
    
    // Берём первую и последнюю найденные точки стыковки
    junctionIndices.sort((a, b) => a.idx - b.idx);
    const startJunction = junctionIndices[0];
    const endJunction = junctionIndices[junctionIndices.length - 1];
    
    // Определяем какой путь содержит удаляемые точки
    const n = workContour.length;
    
    // Путь A: от start к end по возрастанию индексов
    const pathA = [];
    for (let i = startJunction.idx + 1; i < endJunction.idx; i++) {
        pathA.push({ idx: i, point: workContour[i] });
    }
    
    // Путь B: от end к start через "конец" массива
    const pathB = [];
    for (let i = (endJunction.idx + 1) % n; i !== startJunction.idx; i = (i + 1) % n) {
        pathB.push({ idx: i, point: workContour[i] });
    }
    
    // Проверяем какой путь содержит удаляемые точки
    const countRemovedInPath = (path) => {
        let count = 0;
        path.forEach(p => {
            removedPoints.forEach(rp => {
                const dist = Math.sqrt(Math.pow(p.point.x - rp.x, 2) + Math.pow(p.point.y - rp.y, 2));
                if (dist < 0.5) count++;
            });
        });
        return count;
    };
    
    const removedInA = countRemovedInPath(pathA);
    const removedInB = countRemovedInPath(pathB);
    
    let pathToRemove, pathToKeep, needReverse;
    
    if (removedInA > removedInB) {
        pathToRemove = pathA;
        pathToKeep = pathB;
        needReverse = false;
    } else if (removedInB > removedInA) {
        pathToRemove = pathB;
        pathToKeep = pathA;
        needReverse = true;
    } else {
        // Если одинаково (или 0) - берём более короткий путь для удаления
        if (pathA.length <= pathB.length) {
            pathToRemove = pathA;
            pathToKeep = pathB;
            needReverse = false;
        } else {
            pathToRemove = pathB;
            pathToKeep = pathA;
            needReverse = true;
        }
    }
    
    // Проверяем что все удаляемые точки в pathToRemove
    const removedIndicesInContour = [];
    removedPoints.forEach(rp => {
        const found = pathToRemove.find(p => {
            const dist = Math.sqrt(Math.pow(p.point.x - rp.x, 2) + Math.pow(p.point.y - rp.y, 2));
            return dist < 0.5;
        });
        if (!found) {
            errors.push(`Удаляемая точка ${rp.num} (${rp.x.toFixed(2)}, ${rp.y.toFixed(2)}) не найдена в удаляемом сегменте`);
        } else {
            removedIndicesInContour.push(found.idx);
        }
    });
    
    // Проверяем нет ли "забытых" точек
    pathToRemove.forEach(p => {
        const isRemoved = removedPoints.some(rp => {
            const dist = Math.sqrt(Math.pow(p.point.x - rp.x, 2) + Math.pow(p.point.y - rp.y, 2));
            return dist < 0.5;
        });
        if (!isRemoved) {
            errors.push(`Точка (${p.point.x.toFixed(2)}, ${p.point.y.toFixed(2)}) находится в удаляемом сегменте, но НЕ отмечена как удаляемая`);
        }
    });
    
    // Собираем результирующий контур
    let resultContour = [];
    
    // Начинаем с первой точки стыковки
    resultContour.push({ ...startJunction.point, type: 'junction' });
    
    // Добавляем новые точки
    newPoints.forEach(np => {
        resultContour.push({ ...np, type: 'new' });
    });
    
    // Добавляем вторую точку стыковки
    resultContour.push({ ...endJunction.point, type: 'junction' });
    
    // Добавляем сохраняемый путь
    let keptPoints = pathToKeep.map(p => ({ ...p.point, type: 'kept' }));
    if (needReverse) {
        keptPoints.reverse();
    }
    resultContour.push(...keptPoints);
    
    // Замыкаем контур
    const first = resultContour[0];
    const last = resultContour[resultContour.length - 1];
    if (Math.abs(first.x - last.x) > 0.01 || Math.abs(first.y - last.y) > 0.01) {
        resultContour.push({ ...first, type: 'closing' });
    }
    
    // Проверка замкнутости
    const finalFirst = resultContour[0];
    const finalLast = resultContour[resultContour.length - 1];
    const isClosed = Math.abs(finalFirst.x - finalLast.x) < 0.01 && 
                     Math.abs(finalFirst.y - finalLast.y) < 0.01;
    
    if (!isClosed) {
        errors.push('Результирующий контур не замкнут!');
    }
    
    return {
        resultContour,
        errors,
        appliedChanges: {
            startJunction,
            endJunction,
            pathToRemove: pathToRemove.map(p => p.point),
            pathToKeep: keptPoints,
            removedIndices: removedIndicesInContour
        }
    };
}

async function checkRelatedParcelBoundary(specifyRelatedParcel, mainParcelCadNumber) {
    const modal = document.getElementById('relatedParcelModal');
    const infoDiv = document.getElementById('relatedParcelInfo');
    
    modal.style.display = 'flex';
    infoDiv.innerHTML = `<div style="display:flex; align-items:center; justify-content:center; gap:12px; padding:20px; color:var(--text-secondary);">
        <div class="loader"></div>
        <span>Загрузка данных из ЕГРН...</span>
    </div>`;
    
    try {
        // Извлекаем данные из XML
        const xmlData = extractSpecifyRelatedParcelData(specifyRelatedParcel);
        
        if (!xmlData.cadNumber) {
            throw new Error('Не удалось определить кадастровый номер смежного участка');
        }
        
        // Определяем МСК
        const mskSystem = detectMskSystem(xmlData.cadNumber);
        if (!mskSystem) {
            throw new Error('Не удалось определить систему координат для региона');
        }
        
        // Загружаем контур смежного ЗУ из ЕГРН
        infoDiv.innerHTML = `<div style="display:flex; align-items:center; justify-content:center; gap:12px; padding:20px; color:var(--text-secondary);">
            <div class="loader"></div>
            <span>Загрузка смежного ЗУ ${xmlData.cadNumber}...</span>
        </div>`;
        
        const relatedContours = await fetchEgrnCoordinates(xmlData.cadNumber);
        if (!relatedContours || relatedContours.length === 0) {
            throw new Error(`Контур смежного ЗУ ${xmlData.cadNumber} не найден в ЕГРН`);
        }
        
        // Загружаем контур основного ЗУ
        await delay(500);
        infoDiv.innerHTML = `<div style="display:flex; align-items:center; justify-content:center; gap:12px; padding:20px; color:var(--text-secondary);">
            <div class="loader"></div>
            <span>Загрузка основного ЗУ ${mainParcelCadNumber}...</span>
        </div>`;
        
        let mainContours = null;
        try {
            mainContours = await fetchEgrnCoordinates(mainParcelCadNumber);
        } catch (e) {
            console.warn('Не удалось загрузить основной ЗУ:', e);
        }
        
        // Применяем изменения
        const egrnContour = relatedContours[0]; // Берём первый контур
        const { resultContour, errors, appliedChanges } = applyBorderChangesToContour(
            egrnContour,
            xmlData.junctionPoints,
            xmlData.removedPoints,
            xmlData.newPoints
        );
        
        // Сохраняем данные для отрисовки
        relatedParcelCheckData = {
            xmlData,
            egrnContour,
            mainContours,
            resultContour,
            errors,
            appliedChanges,
            mskSystem,
            mainParcelCadNumber
        };
        
        // Рисуем схему
        drawRelatedParcelSchema();
        
    } catch (error) {
        console.error('Ошибка проверки смежного ЗУ:', error);
        infoDiv.innerHTML = `<div class="related-parcel-status error">
            <i class="fas fa-exclamation-circle"></i>
            <span>Ошибка: ${error.message}</span>
        </div>`;
    }
}

function drawRelatedParcelSchema() {
    const canvas = document.getElementById('relatedParcelCanvas');
    const ctx = canvas.getContext('2d');
    const infoDiv = document.getElementById('relatedParcelInfo');

    if (!relatedParcelCheckData) {
        infoDiv.innerHTML = '<div style="color:var(--error-color); text-align:center; padding:20px;">Нет данных для отображения</div>';
        return;
    }

    const { xmlData, egrnContour, mainContours, resultContour, errors, appliedChanges, mainParcelCadNumber } = relatedParcelCheckData;

    const allPoints = [];
    egrnContour.forEach(p => allPoints.push(p));
    if (mainContours) {
        mainContours.forEach(c => c.forEach(p => allPoints.push(p)));
    }
    if (resultContour) {
        resultContour.forEach(p => allPoints.push(p));
    }
    xmlData.newPoints.forEach(p => allPoints.push(p));
    xmlData.junctionPoints.forEach(p => allPoints.push(p));

    if (allPoints.length === 0) {
        infoDiv.innerHTML = '<div style="color:var(--error-color); text-align:center; padding:20px;">Нет координат для отображения</div>';
        return;
    }

    const container = canvas.parentElement;
    const maxWidth = container.clientWidth - 32;
    const maxHeight = container.clientHeight - 32;

    let minGeoX = Infinity, maxGeoX = -Infinity, minGeoY = Infinity, maxGeoY = -Infinity;
    allPoints.forEach(p => {
        minGeoX = Math.min(minGeoX, p.x);
        maxGeoX = Math.max(maxGeoX, p.x);
        minGeoY = Math.min(minGeoY, p.y);
        maxGeoY = Math.max(maxGeoY, p.y);
    });

    const dataWidth = (maxGeoY - minGeoY) || 1;
    const dataHeight = (maxGeoX - minGeoX) || 1;
    const dataAspect = dataWidth / dataHeight;

    let displayWidth, displayHeight;
    
    displayHeight = maxHeight;
    displayWidth = displayHeight * dataAspect;

    if (displayWidth > maxWidth) {
        displayWidth = maxWidth;
        displayHeight = displayWidth / dataAspect;
    }

    const dpr = window.devicePixelRatio || 1;
    canvas.width = displayWidth * dpr;
    canvas.height = displayHeight * dpr;
    canvas.style.width = displayWidth + 'px';
    canvas.style.height = displayHeight + 'px';
    ctx.scale(dpr, dpr);
    ctx.clearRect(0, 0, displayWidth, displayHeight);

    const padding = 50;
    const scaleMultiplier = 0.95; 
    const effectiveWidth = displayWidth - 2 * padding;
    const effectiveHeight = displayHeight - 2 * padding;
    const scale = Math.min(effectiveWidth / dataWidth, effectiveHeight / dataHeight) * scaleMultiplier;
    const offsetX_canvas = padding + (effectiveWidth - dataWidth * scale) / 2;
    const offsetY_canvas = padding + (effectiveHeight - dataHeight * scale) / 2;

    const toCanvas = (point) => ({
        x: offsetX_canvas + (point.y - minGeoY) * scale,
        y: offsetY_canvas + (maxGeoX - point.x) * scale
    });

    const getContourCenter = (contour) => {
        if (!contour || contour.length === 0) return null;
        let sumX = 0, sumY = 0;
        contour.forEach(p => { sumX += p.x; sumY += p.y; });
        return { x: sumX / contour.length, y: sumY / contour.length };
    };

    if (mainContours && mainContours.length > 0) {
        ctx.setLineDash([]);
        ctx.strokeStyle = 'rgba(100, 116, 139, 0.6)';
        ctx.fillStyle = 'rgba(100, 116, 139, 0.1)';
        ctx.lineWidth = 2;

        mainContours.forEach(contour => {
            if (contour.length < 2) return;
            ctx.beginPath();
            contour.forEach((p, i) => {
                const cp = toCanvas(p);
                if (i === 0) ctx.moveTo(cp.x, cp.y);
                else ctx.lineTo(cp.x, cp.y);
            });
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
        });

        if (mainParcelCadNumber && mainContours[0]) {
            const center = getContourCenter(mainContours[0]);
            if (center) {
                const cp = toCanvas(center);
                ctx.font = 'bold 11px Arial';
                ctx.fillStyle = 'rgba(100, 116, 139, 0.8)';
                ctx.textAlign = 'center';
                ctx.fillText(mainParcelCadNumber, cp.x, cp.y);
            }
        }
    }

    ctx.setLineDash([6, 4]);
    ctx.strokeStyle = '#f59e0b';
    ctx.lineWidth = 2;
    ctx.beginPath();
    egrnContour.forEach((p, i) => {
        const cp = toCanvas(p);
        if (i === 0) ctx.moveTo(cp.x, cp.y);
        else ctx.lineTo(cp.x, cp.y);
    });
    const firstEgrn = toCanvas(egrnContour[0]);
    ctx.lineTo(firstEgrn.x, firstEgrn.y);
    ctx.stroke();
    ctx.setLineDash([]);

    const relatedCenter = getContourCenter(egrnContour);
    if (relatedCenter && xmlData.cadNumber) {
        const cp = toCanvas(relatedCenter);
        ctx.font = 'bold 11px Arial';
        ctx.fillStyle = '#b45309';
        ctx.textAlign = 'center';
        ctx.fillText(xmlData.cadNumber, cp.x, cp.y - 8);
        ctx.font = '10px Arial';
        ctx.fillStyle = '#92400e';
        ctx.fillText('(смежный)', cp.x, cp.y + 6);
    }

    if (appliedChanges && appliedChanges.pathToRemove && appliedChanges.pathToRemove.length > 0) {
        ctx.strokeStyle = '#ef4444';
        ctx.lineWidth = 3;
        ctx.beginPath();

        const startCp = toCanvas(appliedChanges.startJunction.point);
        ctx.moveTo(startCp.x, startCp.y);

        appliedChanges.pathToRemove.forEach(p => {
            const cp = toCanvas(p);
            ctx.lineTo(cp.x, cp.y);
        });

        const endCp = toCanvas(appliedChanges.endJunction.point);
        ctx.lineTo(endCp.x, endCp.y);
        ctx.stroke();

        ctx.strokeStyle = '#ef4444';
        ctx.lineWidth = 2;
        appliedChanges.pathToRemove.forEach(p => {
            const cp = toCanvas(p);
            ctx.beginPath();
            ctx.moveTo(cp.x - 5, cp.y - 5);
            ctx.lineTo(cp.x + 5, cp.y + 5);
            ctx.moveTo(cp.x + 5, cp.y - 5);
            ctx.lineTo(cp.x - 5, cp.y + 5);
            ctx.stroke();
        });
    }

    if (xmlData.newPoints.length > 0) {
        ctx.strokeStyle = '#10b981';
        ctx.lineWidth = 3;
        ctx.beginPath();

        if (xmlData.junctionPoints.length > 0) {
            const startCp = toCanvas(xmlData.junctionPoints[0]);
            ctx.moveTo(startCp.x, startCp.y);
        }

        xmlData.newPoints.forEach(p => {
            const cp = toCanvas(p);
            ctx.lineTo(cp.x, cp.y);
        });

        if (xmlData.junctionPoints.length > 1) {
            const endCp = toCanvas(xmlData.junctionPoints[xmlData.junctionPoints.length - 1]);
            ctx.lineTo(endCp.x, endCp.y);
        }
        ctx.stroke();

        ctx.fillStyle = '#10b981';
        xmlData.newPoints.forEach((p, i) => {
            const cp = toCanvas(p);
            ctx.beginPath();
            ctx.arc(cp.x, cp.y, 4, 0, 2 * Math.PI);
            ctx.fill();

            ctx.font = '9px Arial';
            ctx.fillStyle = '#065f46';
            ctx.textAlign = 'left';
            ctx.fillText(`н${p.num}`, cp.x + 6, cp.y - 4);
            ctx.fillStyle = '#10b981';
        });
    }

    ctx.fillStyle = '#3b82f6';
    ctx.strokeStyle = '#1d4ed8';
    ctx.lineWidth = 2;
    xmlData.junctionPoints.forEach((p, i) => {
        const cp = toCanvas(p);
        ctx.beginPath();
        ctx.arc(cp.x, cp.y, 7, 0, 2 * Math.PI);
        ctx.fill();
        ctx.stroke();

        ctx.font = 'bold 10px Arial';
        ctx.fillStyle = '#1e40af';
        ctx.textAlign = 'left';
        ctx.fillText(`С${i + 1}`, cp.x + 9, cp.y + 3);
        ctx.fillStyle = '#3b82f6';
    });

    if (resultContour && errors.length === 0) {
        ctx.strokeStyle = '#2563eb';
        ctx.lineWidth = 2;
        ctx.setLineDash([]);
        ctx.beginPath();
        resultContour.forEach((p, i) => {
            const cp = toCanvas(p);
            if (i === 0) ctx.moveTo(cp.x, cp.y);
            else ctx.lineTo(cp.x, cp.y);
        });
        ctx.stroke();
    }

    if (errors.length > 0) {
        ctx.strokeStyle = '#ef4444';
        ctx.lineWidth = 3;
        ctx.setLineDash([4, 4]);

        if (resultContour && resultContour.length > 1) {
            const lastP = toCanvas(resultContour[resultContour.length - 1]);
            const firstP = toCanvas(resultContour[0]);

            ctx.beginPath();
            ctx.arc(lastP.x, lastP.y, 12, 0, 2 * Math.PI);
            ctx.stroke();
            ctx.beginPath();
            ctx.arc(firstP.x, firstP.y, 12, 0, 2 * Math.PI);
            ctx.stroke();
        }
        ctx.setLineDash([]);
    }

    const hasErrors = errors.length > 0;

    let statusHtml = hasErrors
        ? `<div class="related-parcel-status error"><i class="fas fa-times-circle"></i><span>Обнаружены ошибки в границах смежного ЗУ</span></div>`
        : `<div class="related-parcel-status success"><i class="fas fa-check-circle"></i><span>Контур смежного ЗУ корректен — замкнут успешно</span></div>`;

    let detailsHtml = `<div class="related-parcel-details">
        <div class="related-parcel-detail-item">
            <div class="label">Смежный ЗУ</div>
            <div class="value">${xmlData.cadNumber}</div>
        </div>
        <div class="related-parcel-detail-item">
            <div class="label">Точек в ЕГРН</div>
            <div class="value">${egrnContour.length}</div>
        </div>
        <div class="related-parcel-detail-item">
            <div class="label">Точек стыковки</div>
            <div class="value">${xmlData.junctionPoints.length}</div>
        </div>
        <div class="related-parcel-detail-item">
            <div class="label">Удаляемых точек</div>
            <div class="value" style="color:#ef4444;">${xmlData.removedPoints.length}</div>
        </div>
        <div class="related-parcel-detail-item">
            <div class="label">Новых точек</div>
            <div class="value" style="color:#10b981;">${xmlData.newPoints.length}</div>
        </div>
        <div class="related-parcel-detail-item">
            <div class="label">Итого в контуре</div>
            <div class="value">${resultContour ? resultContour.length : '—'}</div>
        </div>
    </div>`;

    let errorsHtml = '';
    if (hasErrors) {
        errorsHtml = `<div class="related-parcel-errors">
            <div class="error-title"><i class="fas fa-exclamation-triangle"></i> Найденные ошибки:</div>
            <ul>${errors.map(e => `<li>${e}</li>`).join('')}</ul>
        </div>`;
    }

    infoDiv.innerHTML = statusHtml + detailsHtml + errorsHtml;
}

function closeRelatedParcelModal() {
    const modal = document.getElementById('relatedParcelModal');
    modal.style.display = 'none';
    relatedParcelCheckData = null;
}


    function setupEventListeners() {
        dropArea.addEventListener('click', () => fileInput.click());
        fileInput.addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (file) handleFile(file);
        });
        ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(e => {
            document.body.addEventListener(e, (evt) => { evt.preventDefault(); evt.stopPropagation(); }, false);
            dropSection.addEventListener(e, (evt) => { evt.preventDefault(); evt.stopPropagation(); }, false);
        });
        ['dragenter', 'dragover'].forEach(e => {
            dropSection.addEventListener(e, () => dropSection.classList.add('dragover'), false);
        });
        ['dragleave', 'drop'].forEach(e => {
            dropSection.addEventListener(e, () => dropSection.classList.remove('dragover'), false);
        });
        dropSection.addEventListener('drop', (e) => {
            const file = e.dataTransfer.files[0];
            if (file) handleFile(file);
        }, false);
        document.addEventListener('paste', handlePaste);
        pasteButton.addEventListener('click', async () => {
            try {
                const text = await navigator.clipboard.readText();
                if (text) processPastedXml(text); else showError('Буфер обмена пуст.');
            } catch (err) {
                console.error('Ошибка чтения из буфера обмена:', err);
                showError('Не удалось прочитать данные из буфера обмена. Проверьте разрешения в браузере.');
            }
        });
        
     


        printButton.addEventListener('click', () => window.print());
        docsButton.addEventListener('click', openDocsModal);
        docsModalCloseButtons.forEach(btn => btn.addEventListener('click', closeDocsModal));
        docsModal.addEventListener('click', (e) => { if (e.target === docsModal) closeDocsModal(); });
        saveDocsListBtn.addEventListener('click', () => {
            const list = docsListTextarea.value.trim();
            localStorage.setItem(DOCS_LIST_KEY, list);
            closeDocsModal();
            if (lastXmlDoc && lastXmlText) {
                const validationSection = document.querySelector('.validation-section .section-content');
                if (validationSection) {
                    validationSection.innerHTML = runValidation(lastXmlDoc, lastXmlText);
                }
            }
        });
        aiModalCloseBtn.addEventListener('click', closeAiModal);
        aiCheckModal.addEventListener('click', (event) => { if (event.target === aiCheckModal) closeAiModal(); });
        aiModalMinimizeBtn.addEventListener('click', () => aiCheckModal.classList.toggle('minimized'));
        document.getElementById('oksSchemaModalClose').addEventListener('click', closeOksSchemaModal);
        document.getElementById('oksSchemaModal').addEventListener('click', (e) => {
            if (e.target.id === 'oksSchemaModal') closeOksSchemaModal();
        });
        document.body.addEventListener('click', function(event) {
            const copyCoordsBtn = event.target.closest('.copy-coords-btn');
            const aiCheckBtn = event.target.closest('.ai-check-btn');
            const contradictionCheckBtn = event.target.closest('#contradictionCheckBtn');
            const aiCopyBtn = event.target.closest('#aiCopyBtn');
            const checkOksEgrnBtn = event.target.closest('.check-oks-egrn-btn');
            
const checkRelatedBtn = event.target.closest('.check-related-btn');
if (checkRelatedBtn) {
    event.preventDefault();
    const cadNumber = checkRelatedBtn.dataset.relatedCadNumber;
    const mainCadNumber = checkRelatedBtn.dataset.mainCadNumber;
    
    // Проверяем есть ли уже загруженные данные для этого участка
    if (relatedParcelCheckData && relatedParcelCheckData.xmlData?.cadNumber === cadNumber) {
        // Данные уже есть - просто открываем модалку
        const modal = document.getElementById('relatedParcelModal');
        modal.style.display = 'flex';
        setTimeout(() => drawRelatedParcelSchema(), 50);
        return;
    }
    
    // Данных нет - загружаем
    const specifyRelatedParcels = All(lastXmlDoc, 'SpecifyRelatedParcel');
    const targetParcel = Array.from(specifyRelatedParcels).find(
        el => el.getAttribute('CadastralNumber') === cadNumber
    );
    
    if (targetParcel) {
        checkRelatedParcelBoundary(targetParcel, mainCadNumber);
    } else {
        alert('Не удалось найти данные смежного участка в XML');
    }
    return;
}
            const checkZuBtn = event.target.closest('.check-zu-btn');
            
           

document.getElementById('relatedParcelModalClose').addEventListener('click', closeRelatedParcelModal);
document.getElementById('relatedParcelModal').addEventListener('click', (e) => {
    if (e.target.id === 'relatedParcelModal') closeRelatedParcelModal();
});


if (checkZuBtn) {
    event.preventDefault();
    const zuNumbers = JSON.parse(checkZuBtn.dataset.zuNumbers || '[]');
    checkZuForTechPlan(zuNumbers, checkZuBtn);
    return;
}

            if (checkOksEgrnBtn) {
                event.preventDefault();
                const oksNumbers = JSON.parse(checkOksEgrnBtn.dataset.oksNumbers || '[]');
                checkOksInEgrn(oksNumbers, checkOksEgrnBtn);
                return;
            }
            if (copyCoordsBtn) {
                event.preventDefault();
                const sectionContainer = copyCoordsBtn.closest('.section');
                const coordTables = sectionContainer?.querySelectorAll('.coord-table tbody');
                if (!coordTables || coordTables.length === 0) { 
                    alert('Ошибка: таблицы координат не найдены!'); 
                    return; 
                }
                let coordsToCopy = '';
                coordTables.forEach(tbody => {
                    const rows = tbody.querySelectorAll('tr');
                    let pointsAddedInThisContour = false;
                    rows.forEach(row => { 
                        const cells = row.querySelectorAll('td'); 
                        if (cells.length >= 3) { 
                            const val1 = cells[1].textContent.trim(); 
                            const val2 = cells[2].textContent.trim(); 
                            if (val1 && val2 && val1 !== '—' && !val1.includes(',')) {
                                coordsToCopy += `${val1}\t${val2}\n`; 
                                pointsAddedInThisContour = true;
                            }
                        } 
                    });
                    if (pointsAddedInThisContour) {
                        coordsToCopy += '\n';
                    }
                });
                coordsToCopy = coordsToCopy.trim();
                if (!coordsToCopy) { 
                    alert('Нет координат для копирования.'); 
                    return; 
                }
                if (navigator.clipboard) { 
                    navigator.clipboard.writeText(coordsToCopy).then(() => { 
                        const originalHtml = copyCoordsBtn.innerHTML;
                        copyCoordsBtn.innerHTML = `${sectionIcons.successIcon} Скопировано`;
                        setTimeout(() => {
                             copyCoordsBtn.innerHTML = originalHtml;
                             window.open('схема.html', '_blank'); 
                        }, 500);
                    }).catch(err => { 
                        console.error('Ошибка при копировании в буфер обмена:', err); 
                        alert('Не удалось скопировать координаты.'); 
                    }); 
                } else { 
                    alert('Ваш браузер не поддерживает безопасное копирование в буфер обмена.'); 
                }
            }
            if (aiCheckBtn) {
                const conclusionText = aiCheckBtn.dataset.conclusionText;
                checkConclusionWithAI(conclusionText);
            }
            if (contradictionCheckBtn) {
                performContradictionAnalysis();
            }
            if (aiCopyBtn) {
                const correctedTextElement = aiCheckResultDisplay.querySelector('.ai-corrected-text'); 
                if (!correctedTextElement) return;
                const textToCopy = correctedTextElement.textContent;
                navigator.clipboard.writeText(textToCopy).then(() => { 
                    const buttonSpan = aiCopyBtn.querySelector('span'); 
                    const originalText = buttonSpan.textContent; 
                    buttonSpan.textContent = 'Скопировано'; 
                    aiCopyBtn.disabled = true; 
                    setTimeout(() => { 
                        buttonSpan.textContent = originalText; 
                        aiCopyBtn.disabled = false; 
                    }, 2000); 
                }).catch(err => { 
                    alert('Не удалось скопировать текст.'); 
                    console.error('Copy error:', err); 
                });
            }
        });
    }

    function cleanXmlString(xmlString) {
        const lastBracketIndex = xmlString.lastIndexOf('>');
        if (lastBracketIndex === -1) return xmlString;
        return xmlString.substring(0, lastBracketIndex + 1).trim();
    }
    
    function processPastedXml(pastedText) {
        const xmlStartIndex = pastedText.indexOf('<');
        if (xmlStartIndex === -1) { showError('В буфере обмена не найден текст, похожий на XML.'); return; }
        let textToParse = pastedText.substring(xmlStartIndex);
        let cleanedText = textToParse.replace(/<\?\s+xml/i, '<?xml');
        cleanedText = cleanedText.replace(/^[+-]\s*/gm, '');
        cleanedText = cleanXmlString(cleanedText);
        fileNameDisplay.innerHTML = `<strong>Вставлено из буфера обмена</strong>`;
        showStatus('Обработка XML из буфера обмена...', true);
        setTimeout(() => parseXmlContent(cleanedText), 50);
    }

    function handlePaste(event) {
        const pastedText = (event.clipboardData || window.clipboardData).getData('text');
        if (!pastedText || pastedText.trim() === '') return;
        if (pastedText.trim().startsWith('<')) {
           event.preventDefault();
           processPastedXml(pastedText);
        }
    }

    function openDocsModal() {
        docsListTextarea.value = localStorage.getItem(DOCS_LIST_KEY) || '';
        docsModal.style.display = 'flex';
    }

    function closeDocsModal() {
        docsModal.style.display = 'none';
    }

    function handleFile(file) {
        fileNameDisplay.innerHTML = `Выбран файл: <strong>${file.name}</strong>`;
        showStatus('Обработка файла...', true);
        const fileExtension = file.name.split('.').pop().toLowerCase();
        if (fileExtension === 'zip') handleZipFile(file);
        else if (fileExtension === 'xml') handleXmlFile(file);
        else showError('Неподдерживаемый тип файла. Пожалуйста, выберите .xml или .zip файл.');
    }

    function handleXmlFile(file) {
        const reader = new FileReader();
        reader.onload = e => parseXmlContent(e.target.result);
        reader.onerror = e => showError('Не удалось прочитать файл.', e);
        reader.readAsText(file, 'UTF-8');
    }

    function handleZipFile(file) {
        JSZip.loadAsync(file).then(zip => {
            const xmlFileName = Object.keys(zip.files).find(name => !zip.files[name].dir && name.toLowerCase().endsWith('.xml'));
            if (!xmlFileName) throw new Error('XML файл не найден в архиве.');
            return zip.files[xmlFileName].async('string');
        }).then(parseXmlContent).catch(err => showError('Ошибка при обработке ZIP архива: ' + err.message));
    }

    function parseXmlContent(xmlString) {
        try {
            const parser = new DOMParser();
            const xmlDoc = parser.parseFromString(xmlString, "application/xml");
            if (E(xmlDoc, "parsererror")) throw new Error("Не удалось разобрать XML. Файл поврежден или имеет неверный формат.");
            lastXmlDoc = xmlDoc;
            lastXmlText = xmlString;
            displayData(xmlDoc, xmlString);
        } catch (err) {
            showError(err.message);
        } finally {
            loader.classList.add('hidden');
        }
    }
    
    function displayData(xmlDoc, xmlText) {
        const isSurveyPlan = !!E(xmlDoc, 'NewParcel, SpecifyParcel, FormParcels');
        const isInspectionAct = xmlDoc.documentElement.tagName === 'InspectionAct';
        const isTechPlan = xmlDoc.documentElement.tagName === 'TP';
        if (isTechPlan) {
            displayTechPlanData(xmlDoc, xmlText);
        } else if (isSurveyPlan) {
            displaySurveyPlanData(xmlDoc, xmlText);
        } else if (isInspectionAct) {
            displayInspectionActData(xmlDoc, xmlText);
        } else {
            showError('Файл успешно прочитан, но его тип не определен (не является Межевым планом, Техническим планом или Актом обследования).');
        }
    }
    
 function displayTechPlanData(xmlDoc, xmlText) {
    let mainHtml = '';
    let sidebarHtml = '';
    let sectionsFound = 0;
    
    // Определяем тип объекта: здание, сооружение, помещение и т.д.
    const building = E(xmlDoc, 'NewBuilding, ExistBuilding');
    const construction = E(xmlDoc, 'NewConstruction, ExistConstruction');
    const flat = E(xmlDoc, 'NewFlat, ExistFlat');
    const room = E(xmlDoc, 'NewRoom, ExistRoom');
    const uncompleted = E(xmlDoc, 'NewUncompleted, ExistUncompleted');
    
    const mainObject = building || construction || flat || room || uncompleted;
    
    if (!mainObject) {
        showError('Не удалось определить тип объекта в техническом плане');
        return;
    }
    
    // Определяем тип объекта для заголовка
    let objectType = 'Объект';
    let objectIcon = sectionIcons.newParcel;
    if (building) {
        objectType = mainObject.tagName.includes('New') ? 'Образуемое здание' : 'Существующее здание';
        objectIcon = '<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M6 22V4a2 2 0 0 1 2-2h8a2 2 0 0 1 2 2v18Z"/><path d="M6 12H4a2 2 0 0 0-2 2v6a2 2 0 0 0 2 2h2"/><path d="M18 9h2a2 2 0 0 1 2 2v9a2 2 0 0 1-2 2h-2"/><path d="M10 6h4"/><path d="M10 10h4"/><path d="M10 14h4"/><path d="M10 18h4"/></svg>';
    } else if (construction) {
        objectType = mainObject.tagName.includes('New') ? 'Образуемое сооружение' : 'Существующее сооружение';
        objectIcon = '<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M2 20a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2V8l-7 5V8l-7 5V4a2 2 0 0 0-2-2H4a2 2 0 0 0-2 2Z"/></svg>';
    } else if (flat) {
        objectType = mainObject.tagName.includes('New') ? 'Образуемое помещение' : 'Существующее помещение';
        objectIcon = '<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="m3 9 9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z"/><polyline points="9 22 9 12 15 12 15 22"/></svg>';
    } else if (room) {
        objectType = mainObject.tagName.includes('New') ? 'Образуемая комната' : 'Существующая комната';
    } else if (uncompleted) {
        objectType = 'Объект незавершенного строительства';
    }
    
    // === ОСНОВНАЯ ИНФОРМАЦИЯ ОБ ОБЪЕКТЕ ===
    sectionsFound++;
    
    const cadNumber = A(mainObject, 'CadastralNumber') || T(mainObject, 'CadastralNumber');
    const cadBlock = T(mainObject, 'CadastralBlock');
    const objectName = T(mainObject, 'Name, ObjectName');
    const purpose = T(mainObject, 'Purpose, AssignationBuilding, AssignationName');
    const purposeCode = A(E(mainObject, 'Purpose, AssignationBuilding'), 'Code');
    const floors = T(mainObject, 'Floors > Floors');
    const undergroundFloors = T(mainObject, 'Floors > Underground');
    const yearBuilt = T(mainObject, 'YearBuilt, YearUsed');
    const yearCommissioning = T(mainObject, 'YearCommissioning');
    
    // Площадь
    let areaValue = T(mainObject, 'Area > Area, Areas > Area > Area');
    let areaInaccuracy = T(mainObject, 'Area > Inaccuracy, Areas > Area > Inaccuracy');
    
    // Для сооружений может быть длина вместо площади
    const length = T(mainObject, 'Length, KeyParameters > Length');
    const depth = T(mainObject, 'Depth, KeyParameters > Depth');
    const height = T(mainObject, 'Height, KeyParameters > Height');
    const volume = T(mainObject, 'Volume, KeyParameters > Volume');
    
    let mainInfoHtml = `<div class="info-grid">`;
    
    if (cadNumber && cadNumber !== '—') {
        mainInfoHtml += `<div class="info-card"><div class="info-label">Кадастровый номер</div><div class="info-value"><code>${cadNumber}</code></div></div>`;
    }
    
    mainInfoHtml += `<div class="info-card"><div class="info-label">Кадастровый квартал</div><div class="info-value">${cadBlock}</div></div>`;
    
    if (objectName && objectName !== '—') {
        mainInfoHtml += `<div class="info-card" style="grid-column: 1 / -1;"><div class="info-label">Наименование</div><div class="info-value">${objectName}</div></div>`;
    }
    
    if (purpose && purpose !== '—') {
        mainInfoHtml += `<div class="info-card" style="grid-column: 1 / -1;"><div class="info-label">Назначение</div><div class="info-value">${purpose}${purposeCode && purposeCode !== '—' ? ` <code>${purposeCode}</code>` : ''}</div></div>`;
    }
    
    if (areaValue && areaValue !== '—') {
        mainInfoHtml += `<div class="info-card"><div class="info-label">Площадь, кв.м.</div><div class="info-value">${areaValue}${areaInaccuracy && areaInaccuracy !== '—' ? ` (±${areaInaccuracy})` : ''}</div></div>`;
    }
    
    if (length && length !== '—') {
        mainInfoHtml += `<div class="info-card"><div class="info-label">Протяженность, м</div><div class="info-value">${length}</div></div>`;
    }
    
    if (depth && depth !== '—') {
        mainInfoHtml += `<div class="info-card"><div class="info-label">Глубина, м</div><div class="info-value">${depth}</div></div>`;
    }
    
    if (height && height !== '—') {
        mainInfoHtml += `<div class="info-card"><div class="info-label">Высота, м</div><div class="info-value">${height}</div></div>`;
    }
    
    if (volume && volume !== '—') {
        mainInfoHtml += `<div class="info-card"><div class="info-label">Объем, куб.м.</div><div class="info-value">${volume}</div></div>`;
    }
    
    if (floors && floors !== '—') {
        mainInfoHtml += `<div class="info-card"><div class="info-label">Этажность</div><div class="info-value">${floors}${undergroundFloors && undergroundFloors !== '—' ? ` (подземных: ${undergroundFloors})` : ''}</div></div>`;
    }
    
    if (yearBuilt && yearBuilt !== '—') {
        mainInfoHtml += `<div class="info-card"><div class="info-label">Год постройки</div><div class="info-value">${yearBuilt}</div></div>`;
    }
    
    if (yearCommissioning && yearCommissioning !== '—') {
        mainInfoHtml += `<div class="info-card"><div class="info-label">Год ввода в эксплуатацию</div><div class="info-value">${yearCommissioning}</div></div>`;
    }
    
    mainInfoHtml += `</div>`;
    
    // Адрес
    const addressEl = E(mainObject, 'Address, ObjectAddress');
    if (addressEl) {
        mainInfoHtml += `<div class="subsection"><div class="subsection-title">Адрес</div><div class="address-display">${getFullAddress(addressEl)}</div>`;
        const fias = T(addressEl, 'FIAS');
        if (fias && fias !== '—') {
            mainInfoHtml += `<div class="info-grid" style="margin-top: 12px;"><div class="info-card"><div class="info-label">FIAS</div><div class="info-value">${fias}</div></div></div>`;
        }
        mainInfoHtml += `</div>`;
    }
    
    // Земельные участки (ParentCadastralNumbers)
    const parentCadNumbers = Array.from(All(mainObject, 'ParentCadastralNumbers CadastralNumber')).map(n => n.textContent.trim());
    if (parentCadNumbers.length > 0) {
        mainInfoHtml += `
            <div class="subsection">
                <div class="subsection-title" style="display:flex; align-items:center; justify-content:space-between; flex-wrap:wrap; gap:8px;">
                    <span>Земельные участки под объектом</span>
                    <button class="check-zu-btn" data-zu-numbers='${JSON.stringify(parentCadNumbers)}'>
                        <i class="fas fa-clipboard-check"></i>
                        <span class="btn-text">Проверить в ЕГРН</span>
                    </button>
                </div>
                <div class="info-grid zu-list-container">
                    ${parentCadNumbers.map(kn => `<div class="info-card zu-item" data-cad-number="${kn}"><div class="info-value">${kn}</div><div class="zu-address" style="font-size:0.85em; color:var(--text-secondary); margin-top:4px;"></div></div>`).join('')}
                </div>
                <div class="zu-check-status" style="margin-top:12px;"></div>
            </div>`;
    }
    
    // Контуры объекта
    const contours = All(mainObject, 'Contours > Contour, Contours > NewContour, EntitySpatial');
    if (contours.length > 0) {
        let hasCoords = false;
        contours.forEach(contour => {
            const contourNum = A(contour, 'NumberRecord') || A(contour, 'Definition') || '';
            let contourArea = T(contour, 'Area > Area');
            const entitySpatial = contour.tagName === 'EntitySpatial' ? contour : E(contour, 'EntitySpatial');
            
            if (entitySpatial) {
                hasCoords = true;
                const ordinates = All(entitySpatial, 'Ordinate');
                if (ordinates.length > 0) {
                    mainInfoHtml += `<div class="subsection"><div class="subsection-title">Контур ${contourNum}${contourArea && contourArea !== '—' ? ` (площадь: ${contourArea} кв.м.)` : ''}</div>${createSpatialDataHtml(entitySpatial)}</div>`;
                }
            }
        });
        
        // Если контуров нет, но есть EntitySpatial напрямую
        if (!hasCoords) {
            const directEntitySpatial = E(mainObject, 'EntitySpatial');
            if (directEntitySpatial) {
                mainInfoHtml += `<div class="subsection"><div class="subsection-title">Координаты</div>${createSpatialDataHtml(directEntitySpatial)}</div>`;
                hasCoords = true;
            }
        }
        
        mainHtml += `<div class="section">
            <div class="section-header">
                ${objectIcon}
                <h3 class="section-title">${objectType}</h3>
                ${hasCoords ? `<button class="header-button copy-coords-btn" title="Скопировать координаты">${sectionIcons.copyXY}</button>` : ''}
            </div>
            <div class="section-content" style="padding:16px">${mainInfoHtml}</div>
        </div>`;
    } else {
        mainHtml += `<div class="section">
            <div class="section-header">
                ${objectIcon}
                <h3 class="section-title">${objectType}</h3>
            </div>
            <div class="section-content" style="padding:16px">${mainInfoHtml}</div>
        </div>`;
    }
    
    // === ОБЩАЯ ИНФОРМАЦИЯ О КАДАСТРОВЫХ РАБОТАХ ===
    const generalWorks = E(xmlDoc, 'GeneralCadastralWorks');
    const reasonText = T(xmlDoc, 'GeneralCadastralWorks > Reason');
    if (generalWorks || reasonText !== '—') {
        sectionsFound++;
        let generalInfoContent = '';
        
        const dateCadastral = A(generalWorks, 'DateCadastral');
        if (dateCadastral) {
            generalInfoContent += `<div class="info-card"><div class="info-label">Дата кадастровых работ</div><div class="info-value">${dateCadastral}</div></div>`;
        }
        
        if (reasonText !== '—') {
            generalInfoContent += `<div class="info-card" style="grid-column: 1 / -1;"><div class="info-label">Основание для работ</div><div class="info-value">${reasonText}</div></div>`;
        }
        
        if (generalInfoContent) {
            sidebarHtml += `<div class="section"><div class="section-header">${sectionIcons.generalInfo}<h3 class="section-title">Общая информация</h3></div><div class="section-content" style="padding:16px"><div class="info-grid">${generalInfoContent}</div></div></div>`;
        }
    }
    
    // === УЧАСТНИКИ РАБОТ ===
    const contractor = E(xmlDoc, 'Contractor');
    const client = E(xmlDoc, 'Client');
    if (contractor || client) {
        sectionsFound++;
        let participantsHtml = `<div class="section"><div class="section-header">${sectionIcons.participants}<h3 class="section-title">Участники работ</h3></div><div class="section-content" style="padding:16px">`;
        
        if (contractor) {
            const cadWork = E(contractor, 'AgreementCadWork');
            participantsHtml += `<div class="subsection" style="margin-top:0;"><div class="subsection-title">Кадастровый инженер</div><div class="info-grid">
                <div class="info-card"><div class="info-label">ФИО</div><div class="info-value">${T(contractor, 'FamilyName')} ${T(contractor, 'FirstName')} ${T(contractor, 'Patronymic')}</div></div>
                <div class="info-card"><div class="info-label">№ в реестре</div><div class="info-value">${T(contractor, 'CadastralEngineerRegistryNumber')}${T(contractor, 'DateEntering') !== '—' ? ` (от ${T(contractor, 'DateEntering')})` : ''}</div></div>
                <div class="info-card"><div class="info-label">СНИЛС</div><div class="info-value">${T(contractor, 'SNILS')}</div></div>
                <div class="info-card" style="grid-column: 1 / -1;"><div class="info-label">Контакты</div><div class="info-value">Тел: ${T(contractor, 'Telephone')}, Email: ${T(contractor, 'Email')}</div></div>
                <div class="info-card" style="grid-column: 1 / -1;"><div class="info-label">СРО</div><div class="info-value">${T(contractor, 'SelfRegulatoryOrganization')}</div></div>`;
            
            if (cadWork) {
                participantsHtml += `<div class="info-card" style="grid-column: 1 / -1;"><div class="info-label">Договор</div><div class="info-value">${T(cadWork, 'Name')} №${T(cadWork, 'NumberAgreement')} от ${T(cadWork, 'DateAgreement')}</div></div>`;
            }
            participantsHtml += `</div></div>`;
        }
        
        if (client) {
            const org = E(client, 'Organization');
            const gov = E(client, 'Governance');
            const person = E(client, 'Person');
            const clientEntity = org || gov;
            
            participantsHtml += `<div class="subsection"><div class="subsection-title">Заказчик</div><div class="info-grid">`;
            
            if (clientEntity) {
                participantsHtml += `<div class="info-card" style="grid-column: 1 / -1;"><div class="info-label">Наименование</div><div class="info-value">${T(clientEntity, 'Name')}</div></div>
                    <div class="info-card"><div class="info-label">ИНН</div><div class="info-value">${T(clientEntity, 'INN')}</div></div>
                    <div class="info-card"><div class="info-label">ОГРН</div><div class="info-value">${T(clientEntity, 'OGRN')}</div></div>`;
            } else if (person) {
                participantsHtml += `<div class="info-card"><div class="info-label">ФИО</div><div class="info-value">${T(person, 'FamilyName')} ${T(person, 'FirstName')} ${T(person, 'Patronymic')}</div></div>
                    <div class="info-card"><div class="info-label">СНИЛС</div><div class="info-value">${T(person, 'SNILS')}</div></div>`;
            } else {
                participantsHtml += `<div class="info-card"><div class="info-label">ФИО</div><div class="info-value">${T(client, 'FamilyName')} ${T(client, 'FirstName')} ${T(client, 'Patronymic')}</div></div>
                    <div class="info-card"><div class="info-label">СНИЛС</div><div class="info-value">${T(client, 'SNILS')}</div></div>`;
            }
            participantsHtml += `</div></div>`;
        }
        
        participantsHtml += `</div></div>`;
        sidebarHtml += participantsHtml;
    }
    
    // === ИСХОДНЫЕ ДАННЫЕ ===
    const inputData = E(xmlDoc, 'InputData');
    if (inputData) {
        sectionsFound++;
        let inputDataHtml = `<div class="section"><div class="section-header">${sectionIcons.inputData}<h3 class="section-title">Исходные данные</h3></div><div class="section-content" style="padding:16px">`;
        
        const documents = All(inputData, 'Documents > Document');
        if (documents.length > 0) {
            inputDataHtml += `<div class="subsection" style="margin-top:0;"><div class="subsection-title">Документы</div><table class="data-table"><thead><tr><th class="left-align">Наименование</th><th class="no-wrap">№</th><th class="no-wrap">Дата</th></tr></thead><tbody>${Array.from(documents).map(doc => `<tr><td class="left-align">${T(doc, 'Name')}</td><td class="no-wrap">${T(doc, 'Number')}</td><td class="no-wrap">${T(doc, 'Date')}</td></tr>`).join('')}</tbody></table></div>`;
        }
        
        const geoBases = All(inputData, 'GeodesicBases > GeodesicBase');
        if (geoBases.length > 0) {
            inputDataHtml += `<div class="subsection"><div class="subsection-title">Геодезическая основа</div><table class="data-table"><thead><tr><th class="left-align">Пункт</th><th>Класс</th><th>X</th><th>Y</th></tr></thead><tbody>${Array.from(geoBases).map(base => `<tr><td class="left-align">${T(base, 'PName')} (${T(base, 'PKind')})</td><td>${T(base, 'PKlass')}</td><td>${T(base, 'OrdX')}</td><td>${T(base, 'OrdY')}</td></tr>`).join('')}</tbody></table></div>`;
        }
        
        const meanSurvey = E(inputData, 'MeansSurvey > MeanSurvey');
        if (meanSurvey) {
            inputDataHtml += `<div class="subsection"><div class="subsection-title">Средства измерений</div><div class="info-grid">
                <div class="info-card" style="grid-column: 1 / -1;"><div class="info-label">Прибор</div><div class="info-value">${T(meanSurvey, 'Name')}</div></div>
                <div class="info-card"><div class="info-label">Номер</div><div class="info-value">${T(meanSurvey, 'Number')}</div></div>
                <div class="info-card"><div class="info-label">Поверка</div><div class="info-value">${T(meanSurvey, 'CertificateVerification')}</div></div>
            </div></div>`;
        }
        
        inputDataHtml += `</div></div>`;
        sidebarHtml += inputDataHtml;
    }
    
    // === ЗАКЛЮЧЕНИЕ ===
    const conclusion = E(xmlDoc, 'Conclusion');
    if (conclusion && conclusion.textContent.trim()) {
        sectionsFound++;
        mainHtml += `<div class="section">
            <div class="section-header">
                ${sectionIcons.conclusion}
                <h3 class="section-title">Заключение кадастрового инженера</h3>
                <button class="header-button ai-check-btn" data-conclusion-text="${escapeHtml(conclusion.textContent.trim())}" title="Проверить заключение с помощью ИИ">
                    <i class="fas fa-atom"></i>
                </button>
            </div>
            <div class="section-content" style="padding:16px">
                <div class="conclusion-text">${conclusion.textContent.trim()}</div>
            </div>
        </div>`;
    }
    
    // === ГРАФИЧЕСКИЕ РАЗДЕЛЫ ===
    const graphicFiles = [
        { title: 'Схема геодезических построений', file: A(E(xmlDoc, 'SchemeGeodesicPlotting'), 'Name') || A(E(xmlDoc, 'SchemeGeodesicConstructions'), 'Name') },
        { title: 'Схема расположения объекта', file: A(E(xmlDoc, 'SchemeDisposition'), 'Name') || A(E(xmlDoc, 'LocationPlan'), 'Name') },
        { title: 'Чертеж контура', file: A(E(xmlDoc, 'DiagramContour > AppliedFile'), 'Name') },
        { title: 'План этажа', file: A(E(xmlDoc, 'FloorPlan > AppliedFile'), 'Name') }
    ].filter(f => f.file && f.file !== '—');
    
    if (graphicFiles.length > 0) {
        sectionsFound++;
        mainHtml += `<div class="section"><div class="section-header">${sectionIcons.graphics}<h3 class="section-title">Графические разделы</h3></div><div class="section-content" style="padding:16px"><table class="data-table"><thead><tr><th class="left-align">Наименование раздела</th><th class="left-align">Имя файла</th></tr></thead><tbody>${graphicFiles.map(f => `<tr><td class="left-align">${f.title}</td><td class="left-align"><span class="file-name">${f.file}</span></td></tr>`).join('')}</tbody></table></div></div>`;
    }
    
    // === ПРИЛОЖЕНИЯ ===
    const appendixFiles = All(xmlDoc, 'Appendix > AppliedFiles');
    if (appendixFiles.length > 0) {
        sectionsFound++;
        mainHtml += `<div class="section"><div class="section-header">${sectionIcons.appendix}<h3 class="section-title">Приложения</h3></div><div class="section-content" style="padding:16px"><table class="data-table"><thead><tr><th>№</th><th class="left-align">Наименование</th><th class="left-align">Имя файла</th></tr></thead><tbody>${Array.from(appendixFiles).map(f => `<tr><td>${T(f, 'NumberAppendix')}</td><td class="left-align">${T(f, 'NameAppendix')}</td><td class="left-align"><span class="file-name">${A(E(f, 'AppliedFile'), 'Name')}</span></td></tr>`).join('')}</tbody></table></div></div>`;
    }
    
    // === ВАЛИДАЦИЯ ===
    const validationHtml = runTechPlanValidation(xmlDoc, xmlText);
    if (validationHtml) {
        mainHtml += `<div class="section validation-section"><div class="section-header">${sectionIcons.validation}<h3 class="section-title">Проверка технического плана</h3></div><div class="section-content" style="padding:16px">${validationHtml}</div></div>`;
    }
    
    if (sectionsFound > 0) {
        mainColumn.innerHTML = mainHtml;
        sidebarColumn.innerHTML = sidebarHtml;
        resultsContainer.classList.remove('hidden');
        statusContainer.classList.add('hidden');
        printButtonContainer.classList.remove('hidden');
        messageArea.innerHTML = '';
    } else {
        showError('Файл успешно прочитан, но в нем не найдено известных разделов технического плана.');
    }
}

function runTechPlanValidation(xmlDoc, xmlText) {
    let messages = [];
    
    const today = new Date();
    const currentDateString = `${today.getFullYear()}-${String(today.getMonth() + 1).padStart(2, '0')}-${String(today.getDate()).padStart(2, '0')}`;
    
    const generalWorksEl = E(xmlDoc, 'GeneralCadastralWorks');
    if (generalWorksEl) {
        const cadWorkDate = A(generalWorksEl, 'DateCadastral');
        if (cadWorkDate && cadWorkDate !== currentDateString) {
            messages.push(`<div class="validation-message validation-warning">${sectionIcons.warningIcon} <strong>Предупреждение:</strong> Дата кадастровых работ (${cadWorkDate}) не является текущей датой.</div>`);
        }
    }
    
    // Проверка дат
    const dateWarnings = [];
    const foundDates = new Set();
    const dateRegex = /(?:\b(\d{2})\.(\d{2})\.(\d{4})\b)|(?:\b(\d{4})-(\d{2})-(\d{2})\b)/g;
    const minDate = new Date(1990, 0, 1);
    const currentDate = new Date();
    currentDate.setHours(23, 59, 59, 999);
    let match;
    
    while ((match = dateRegex.exec(xmlText)) !== null) {
        const fullMatch = match[0];
        if (foundDates.has(fullMatch)) continue;
        foundDates.add(fullMatch);
        
        let day, month, year, parsedDate;
        if (match[1]) {
            day = parseInt(match[1], 10);
            month = parseInt(match[2], 10);
            year = parseInt(match[3], 10);
        } else {
            year = parseInt(match[4], 10);
            month = parseInt(match[5], 10);
            day = parseInt(match[6], 10);
        }
        
        parsedDate = new Date(year, month - 1, day);
        if (parsedDate.getFullYear() !== year || parsedDate.getMonth() !== month - 1 || parsedDate.getDate() !== day) continue;
        
        if (parsedDate < minDate) dateWarnings.push(`"${fullMatch}"`);
        else if (parsedDate > currentDate) dateWarnings.push(`"${fullMatch}" (будущая дата)`);
    }
    
    if (dateWarnings.length > 0) {
        messages.push(`<div class="validation-message validation-warning">${sectionIcons.warningIcon} <strong>Предупреждение о датах:</strong> Найдены даты за пределами допустимого диапазона (01.01.1990 - сегодня): ${dateWarnings.join(', ')}.</div>`);
    }
    
    // Все кадастровые номера
    const knRegex = /\d{2}:\d{2}:\d{6,7}:\d+/g;
    const blockRegex = /\d{2}:\d{2}:\d{6,7}/;
    let allNumbers = new Set((xmlText.match(knRegex) || []));
    All(xmlDoc, 'CadastralBlock').forEach(b => allNumbers.add(b.textContent.trim()));
    const quarters = new Map();
    
    allNumbers.forEach(num => {
        const match = num.match(blockRegex);
        if (match) {
            const quarter = match[0];
            if (!quarters.has(quarter)) quarters.set(quarter, []);
            quarters.get(quarter).push(num);
        }
    });
    
    const colors = ['#1d4ed8', '#b91c1c', '#c2410c', '#15803d', '#86198f'];
    let colorIndex = 0;
    const quarterColors = new Map();
    for (const q of quarters.keys()) {
        quarterColors.set(q, colors[colorIndex % colors.length]);
        colorIndex++;
    }
    
    if (quarters.size > 1) {
        messages.push(`<div class="validation-message validation-warning">${sectionIcons.warningIcon} <strong>Предупреждение:</strong> Найдены объекты из разных кадастровых кварталов.</div>`);
    }
    
    let numberListHtml = '<ul id="cadastralNumbersList">';
    quarters.forEach((numbers, quarter) => {
        const color = quarterColors.get(quarter);
        numbers.sort().forEach(num => {
            numberListHtml += `<li style="border-color:${color}; color:${color};">${num}</li>`;
        });
    });
    numberListHtml += '</ul>';
    messages.push(`<div class="subsection" style="margin-top:0"><div class="subsection-title">Все кадастровые номера в документе</div>${numberListHtml}</div>`);
    
    // Проверка на несоответствия (AI)
    const contradictionHtml = `
        <div class="subsection">
            <div class="subsection-title" style="display:flex; align-items:center; gap: 8px;">
                ${sectionIcons.contradiction}
                <span>Проверка данных</span>
            </div>
            <button id="contradictionCheckBtn" class="print-btn contradiction-btn">
                <i class="fas fa-balance-scale-right"></i>
                <span>Найти несоответствия</span>
            </button>
            <div id="contradictionAnalysisResult" style="margin-top: 16px;"></div>
        </div>
    `;
    messages.push(contradictionHtml);
    
    return messages.length > 0 ? messages.join('') : '';
}

    function displayInspectionActData(xmlDoc, xmlText) {
        let mainHtml = '';
        let sidebarHtml = '';
        let sectionsFound = 0;
        const objectTypes = { '002001002000': 'Здание', '002001003000': 'Сооружение', '002001004000': 'Помещение', '002001005000': 'Машино-место', '002001006000': 'Объект незавершенного строительства', '002001008000': 'Единый недвижимый комплекс', '002001009000': 'Предприятие как имущественный комплекс' };
        const rightTypes = { '1': 'Права зарегистрированы', '2': 'Права не зарегистрированы' };
        const contractor = E(xmlDoc, 'Contractor');
        const client = E(xmlDoc, 'Client');
        if (contractor || client) {
            sectionsFound++;
            let participantsHtml = `<div class="section"><div class="section-header">${sectionIcons.participants}<h3 class="section-title">Участники работ</h3></div><div class="section-content" style="padding:16px">`;
            if (contractor) {
                const cadWork = E(contractor, 'AgreementCadWork');
                participantsHtml += `<div class="subsection" style="margin-top:0;"><div class="subsection-title">Кадастровый инженер</div><div class="info-grid"><div class="info-card"><div class="info-label">ФИО</div><div class="info-value">${T(contractor, 'FamilyName')} ${T(contractor, 'FirstName')} ${T(contractor, 'Patronymic')}</div></div><div class="info-card"><div class="info-label">№ в реестре</div><div class="info-value">${T(contractor, 'CadastralEngineerRegistryNumber')} (от ${T(contractor, 'DateEntering')})</div></div><div class="info-card"><div class="info-label">СНИЛС</div><div class="info-value">${T(contractor, 'SNILS')}</div></div><div class="info-card" style="grid-column: 1 / -1;"><div class="info-label">Контакты</div><div class="info-value">Тел: ${T(contractor, 'Telephone')}, Email: ${T(contractor, 'Email')}</div></div><div class="info-card" style="grid-column: 1 / -1;"><div class="info-label">СРО</div><div class="info-value">${T(contractor, 'SelfRegulatoryOrganization')}</div></div><div class="info-card" style="grid-column: 1 / -1;"><div class="info-label">Договор</div><div class="info-value">${T(cadWork, 'Name')} №${T(cadWork, 'NumberAgreement')} от ${T(cadWork, 'DateAgreement')}</div></div></div></div>`;
            }
            if (client) {
                participantsHtml += `<div class="subsection"><div class="subsection-title">Заказчик</div><div class="info-grid">`;
                if(E(client, 'Governance')) {
                     participantsHtml += `<div class="info-card" style="grid-column: 1 / -1;"><div class="info-label">Наименование</div><div class="info-value">${T(client, 'Governance > Name')}</div></div>`;
                } else if (E(client, 'Person')) {
                     participantsHtml += `<div class="info-card"><div class="info-label">ФИО</div><div class="info-value">${T(client, 'FamilyName')} ${T(client, 'FirstName')} ${T(client, 'Patronymic')}</div></div><div class="info-card"><div class="info-label">СНИЛС</div><div class="info-value">${T(client, 'SNILS')}</div></div>`;
                }
                participantsHtml += `</div></div>`;
            }
            participantsHtml += `</div></div>`;
            sidebarHtml += participantsHtml;
        }
        const objectEl = E(xmlDoc, 'Object');
        if (objectEl) {
            sectionsFound++;
            const objectType = T(objectEl, 'ObjectType');
            const rightType = T(objectEl, 'RightRegisteredUnregistered');
            let objectInfoContent = `
                <div class="info-card"><div class="info-label">Кадастровый номер</div><div class="info-value"><code>${T(objectEl, 'CadastralNumber')}</code></div></div>
                <div class="info-card"><div class="info-label">Тип объекта</div><div class="info-value">${objectTypes[objectType] || `Неизвестный тип (${objectType})`}</div></div>
                <div class="info-card"><div class="info-label">Регистрация прав</div><div class="info-value">${rightTypes[rightType] || 'Не указано'}</div></div>
                <div class="info-card"><div class="info-label">Дата прекращения существования</div><div class="info-value">${T(objectEl, 'DateTermination')}</div></div>
            `;
            mainHtml += `<div class="section"><div class="section-header">${sectionIcons.newParcel}<h3 class="section-title">Сведения об объекте обследования</h3></div><div class="section-content" style="padding:16px"><div class="info-grid">${objectInfoContent}</div></div></div>`;
        }
        const documents = All(xmlDoc, 'Documents > Document');
        if (documents.length > 0) {
            sectionsFound++;
            let docsHtml = `<div class="section"><div class="section-header">${sectionIcons.inputData}<h3 class="section-title">Документы-основания</h3></div><div class="section-content" style="padding:16px">`;
            docsHtml += `<table class="data-table"><thead><tr><th class="left-align">Наименование</th><th class="no-wrap">№</th><th class="no-wrap">Дата</th><th class="left-align">Имя файла</th></tr></thead><tbody>`;
            documents.forEach(doc => {
                const appliedFileEl = E(doc, 'AppliedFile');
                const fileName = appliedFileEl ? A(appliedFileEl, 'Name') : '—';
                docsHtml += `<tr><td class="left-align">${T(doc, 'Name')}</td><td class="no-wrap">${T(doc, 'Number')}</td><td class="no-wrap">${T(doc, 'Date')}</td><td class="left-align"><span class="file-name">${fileName}</span></td></tr>`;
            });
            docsHtml += `</tbody></table></div></div>`;
            mainHtml += docsHtml;
        }
        const conclusion = E(xmlDoc, 'Conclusion');
        if (conclusion && conclusion.textContent.trim()) {
            sectionsFound++;
            mainHtml += `<div class="section"><div class="section-header">${sectionIcons.conclusion}<h3 class="section-title">Заключение кадастрового инженера</h3><button class="header-button ai-check-btn" data-conclusion-text="${escapeHtml(conclusion.textContent.trim())}" title="Проверить заключение с помощью ИИ"><i class="fas fa-atom"></i></button></div><div class="section-content" style="padding:16px"><div class="conclusion-text">${conclusion.textContent.trim()}</div></div></div>`;
        }
        if (sectionsFound > 0) {
            mainColumn.innerHTML = mainHtml;
            sidebarColumn.innerHTML = sidebarHtml;
            resultsContainer.classList.remove('hidden');
            statusContainer.classList.add('hidden');
            printButtonContainer.classList.remove('hidden');
            messageArea.innerHTML = '';
        } else {
            showError('Файл Акта обследования прочитан, но в нем не найдено данных для отображения.');
        }
    }
    
    function createSpatialDataHtml(entitySpatial) {
        if (!entitySpatial) return '';
        let spatialHtml = '';
        let tableContent = '';
        const ordinates = All(entitySpatial, 'SpatialElement Ordinate, SpelementUnit > Ordinate, SpelementUnit > NewOrdinate');
        ordinates.forEach(ord => {
            const pointName = `${A(ord, 'PointPref') || ''}${A(ord, 'NumGeopoint')}`;
            const methodCode = A(ord, 'GeopointOpred');
            const methodName = geopointMethods[methodCode] || (methodCode !== '—' ? methodCode : '—');
            if (pointName && pointName !== '—') {
                tableContent += `<tr>
                    <td>${pointName}</td>
                    <td>${A(ord, 'X')}</td>
                    <td>${A(ord, 'Y')}</td>
                    <td class="left-align" style="font-size: 0.85em;">${methodName}</td>
                    <td class="left-align">${A(ord, 'GeopointZacrep')}</td>
                    <td>${A(ord, 'DeltaGeopoint')}</td>
                </tr>`;
            }
        });
        if (tableContent) {
             spatialHtml += `<div class="subsection" id="main-coord-section"><div class="subsection-title">Координаты характерных точек</div><table class="data-table coord-table"><thead><tr><th>Обозначение</th><th>X</th><th>Y</th><th class="left-align">Метод определения</th><th class="left-align">Метод закрепления</th><th>Погрешность, м</th></tr></thead><tbody>${tableContent}</tbody></table></div>`;
        }
        const borders = All(entitySpatial, 'Borders > Border');
        if (borders.length > 0) {
             spatialHtml += `<div class="subsection"><div class="subsection-title">Длины линий</div><table class="data-table lengths-table"><thead><tr><th>Участок</th><th>Длина, м</th></tr></thead><tbody>${Array.from(borders).map(b => `<tr><td>${A(b,'Point1')}-${A(b,'Point2')}</td><td>${T(b,'Edge > Length') || T(b, 'Length')}</td></tr>`).join('')}</tbody></table></div>`;
        }
        return spatialHtml;
    }

       function displaySurveyPlanData(xmlDoc, xmlText) {
        let mainHtml = '';
        let sidebarHtml = '';
        let sectionsFound = 0;
        const formParcels = E(xmlDoc, 'FormParcels');
        const reasonText = T(xmlDoc, 'GeneralCadastralWorks > Reason');
        if (formParcels || reasonText !== '—') {
            sectionsFound++;
            let generalInfoContent = '';
            if (formParcels) {
                const method = A(formParcels, 'Method');
                generalInfoContent += `<div class="info-card"><div class="info-label">Способ образования ЗУ</div><div class="info-value">${planTypes[method] || `Неизвестный (${method})`}</div></div>`;
            }
            if (reasonText !== '—') {
                generalInfoContent += `<div class="info-card" style="grid-column: 1 / -1;"><div class="info-label">Основание для работ</div><div class="info-value">${reasonText}</div></div>`;
            }
            sidebarHtml += `<div class="section"><div class="section-header">${sectionIcons.generalInfo}<h3 class="section-title">Общая информация</h3></div><div class="section-content" style="padding:16px"><div class="info-grid">${generalInfoContent}</div></div></div>`;
        }
        const contractor = E(xmlDoc, 'Contractor');
        const client = E(xmlDoc, 'Client');
        if (contractor || client) {
            sectionsFound++;
            let participantsHtml = `<div class="section"><div class="section-header">${sectionIcons.participants}<h3 class="section-title">Участники работ</h3></div><div class="section-content" style="padding:16px">`;
            if (contractor) {
                const cadWork = E(contractor, 'AgreementCadWork');
                participantsHtml += `<div class="subsection" style="margin-top:0;"><div class="subsection-title">Кадастровый инженер</div><div class="info-grid"><div class="info-card"><div class="info-label">ФИО</div><div class="info-value">${T(contractor, 'FamilyName')} ${T(contractor, 'FirstName')} ${T(contractor, 'Patronymic')}</div></div><div class="info-card"><div class="info-label">№ в реестре</div><div class="info-value">${T(contractor, 'CadastralEngineerRegistryNumber')} (от ${T(contractor, 'DateEntering')})</div></div><div class="info-card"><div class="info-label">СНИЛС</div><div class="info-value">${T(contractor, 'SNILS')}</div></div><div class="info-card" style="grid-column: 1 / -1;"><div class="info-label">Контакты</div><div class="info-value">Тел: ${T(contractor, 'Telephone')}, Email: ${T(contractor, 'Email')}</div></div><div class="info-card" style="grid-column: 1 / -1;"><div class="info-label">СРО</div><div class="info-value">${T(contractor, 'SelfRegulatoryOrganization')}</div></div><div class="info-card" style="grid-column: 1 / -1;"><div class="info-label">Договор</div><div class="info-value">${T(cadWork, 'Name')} №${T(cadWork, 'NumberAgreement')} от ${T(cadWork, 'DateAgreement')}</div></div></div></div>`;
            }
            if (client) {
                const org = E(client, 'Organization');
                const gov = E(client, 'Governance');
                const clientOrgEntity = org || gov;
                participantsHtml += `<div class="subsection"><div class="subsection-title">Заказчик</div><div class="info-grid">`;
                if (clientOrgEntity) {
                    participantsHtml += `<div class="info-card" style="grid-column: 1 / -1;"><div class="info-label">Наименование</div><div class="info-value">${T(clientOrgEntity, 'Name')}</div></div><div class="info-card"><div class="info-label">ИНН</div><div class="info-value">${T(clientOrgEntity, 'INN')}</div></div><div class="info-card"><div class="info-label">ОГРН</div><div class="info-value">${T(clientOrgEntity, 'OGRN')}</div></div>`;
                } else {
                    participantsHtml += `<div class="info-card"><div class="info-label">ФИО</div><div class="info-value">${T(client, 'FamilyName')} ${T(client, 'FirstName')} ${T(client, 'Patronymic')}</div></div><div class="info-card"><div class="info-label">СНИЛС</div><div class="info-value">${T(client, 'SNILS')}</div></div>`;
                }
                participantsHtml += `</div></div>`;
            }
            participantsHtml += `</div></div>`;
            sidebarHtml += participantsHtml;
        }
        const inputData = E(xmlDoc, 'InputData');
        if (inputData) {
            sectionsFound++;
            let inputDataHtml = `<div class="section"><div class="section-header">${sectionIcons.inputData}<h3 class="section-title">Исходные данные</h3></div><div class="section-content" style="padding:16px">`;
            const documents = All(inputData, 'Documents > Document');
            if (documents.length > 0) {
                inputDataHtml += `<div class="subsection" style="margin-top:0;"><div class="subsection-title">Документы</div><table class="data-table"><thead><tr><th class="left-align">Наименование</th><th class="no-wrap">№</th><th class="no-wrap">Дата</th></tr></thead><tbody>${Array.from(documents).map(doc => `<tr><td class="left-align">${T(doc, 'Name')}</td><td class="no-wrap">${T(doc, 'Number')}</td><td class="no-wrap">${T(doc, 'Date')}</td></tr>`).join('')}</tbody></table></div>`;
            }
            const geoBases = All(inputData, 'GeodesicBases > GeodesicBase');
            if (geoBases.length > 0) {
                inputDataHtml += `<div class="subsection"><div class="subsection-title">Геодезическая основа</div><table class="data-table"><thead><tr><th class="left-align">Пункт</th><th>Класс</th><th>X</th><th>Y</th></tr></thead><tbody>${Array.from(geoBases).map(base => `<tr><td class="left-align">${T(base, 'PName')} (${T(base, 'PKind')})</td><td>${T(base, 'PKlass')}</td><td>${T(base, 'OrdX')}</td><td>${T(base, 'OrdY')}</td></tr>`).join('')}</tbody></table></div>`;
            }
            const meanSurvey = E(inputData, 'MeansSurvey > MeanSurvey');
            if (meanSurvey) {
                inputDataHtml += `<div class="subsection"><div class="subsection-title">Средства измерений</div><div class="info-grid"><div class="info-card" style="grid-column: 1 / -1;"><div class="info-label">Прибор</div><div class="info-value">${T(meanSurvey, 'Name')}</div></div><div class="info-card"><div class="info-label">Номер</div><div class="info-value">${T(meanSurvey, 'Number')}</div></div><div class="info-card"><div class="info-label">Поверка</div><div class="info-value">${T(meanSurvey, 'CertificateVerification')}</div></div></div></div>`;
            }
            inputDataHtml += `</div></div>`;
            sidebarHtml += inputDataHtml;
        }
        const newParcels = All(xmlDoc, 'NewParcel');
        for (const newParcel of newParcels) {
            sectionsFound++;
            const categoryCode = A(E(newParcel, 'Category'), 'Category');
            const categoryName = landCategories[categoryCode] || 'Категория не определена';
            let areaVal = '—';
            let areaInacc = '—';
            const directAreaNode = Array.from(newParcel.children).find(el => el.tagName === 'Area');
            if (directAreaNode) {
                areaVal = T(directAreaNode, 'Area');
                areaInacc = T(directAreaNode, 'Inaccuracy');
            } else {
                areaVal = T(newParcel, 'Area > Area');
                areaInacc = T(newParcel, 'Area > Inaccuracy');
            }
            let sectionContent = `<div class="info-grid">
                <div class="info-card"><div class="info-label">Кадастровый квартал</div><div class="info-value">${T(newParcel, 'CadastralBlock')}</div></div>
                <div class="info-card"><div class="info-label">Площадь, кв.м.</div><div class="info-value">${areaVal} (±${areaInacc})</div></div>
                <div class="info-card"><div class="info-label">Категория земель</div><div class="info-value">${categoryName} <code>${categoryCode}</code></div></div>
                <div class="info-card"><div class="info-label">Вид разрешенного использования</div><div class="info-value">${A(E(newParcel, 'PermittedUseEstablished, PermittedUsesLand > PermittedUseEstablished'), 'ByDocument')}</div></div>
                <div class="info-card"><div class="info-label">Обеспечение доступа</div><div class="info-value">${T(newParcel, 'ProvidingPassCadastralNumbers > Other, ProvidingPassCadastralNumbers > CadastralNumber')}</div></div>
            </div>`;
            const prevRedist = E(newParcel, 'PrevWithRedistributed');
            if (prevRedist) {
                let redistRows = '';
                All(prevRedist, 'PrevWithRedistribute').forEach(item => {
                    const kn = T(item, 'CadastralNumber');
                    const block = T(item, 'CadastralBlock');
                    const sourceName = kn !== '—' ? kn : (block !== '—' ? `Квартал ${block}` : '—');
                    let sourceArea = '—';
                    for (let child of item.children) {
                        if (child.tagName === 'Area') {
                            sourceArea = T(child, 'Area');
                            break;
                        }
                    }
                    const partName = T(item, 'IncludedPart > Definition');
                    const partArea = T(item, 'IncludedPart > Area > Area');
                    redistRows += `<tr><td class="left-align">${sourceName}</td><td>${sourceArea}</td><td>${partName}</td><td>${partArea}</td></tr>`;
                });
                if (redistRows) {
                    sectionContent += `<div class="subsection"><div class="subsection-title">Сведения о перераспределении</div><table class="data-table"><thead><tr><th class="left-align">Источник образования (ЗУ или Квартал)</th><th>Площадь источника, м²</th><th>Обозначение части</th><th>Площадь части, м²</th></tr></thead><tbody>${redistRows}</tbody></table></div>`;
                }
            }
            if (T(newParcel, 'Area > Formula') !== '—') {
                sectionContent += `<div class="subsection"><div class="subsection-title">Формула погрешности</div><div class="conclusion-text">${T(newParcel, 'Area > Formula')}</div></div>`;
            }
         if (All(newParcel, 'ObjectsRealty CadastralNumber').length > 0) {
    const oksNumbers = Array.from(All(newParcel, 'ObjectsRealty CadastralNumber')).map(node => node.textContent.trim());
    sectionContent += `
        <div class="subsection">
            <div class="subsection-title" style="display:flex; align-items:center; justify-content:space-between; flex-wrap:wrap; gap:8px;">
                <span>ОКС на участке</span>
                <button class="check-oks-egrn-btn" data-oks-numbers='${JSON.stringify(oksNumbers)}'>
                    <i class="fas fa-clipboard-check"></i>
                    <span class="btn-text">Проверить в ЕГРН</span>
                </button>
            </div>
            <div class="info-grid oks-list-container">
                ${oksNumbers.map(kn => `<div class="info-card oks-item" data-cad-number="${kn}"><div class="info-value">${kn}</div><div class="oks-address" style="font-size:0.85em; color:var(--text-secondary); margin-top:4px;"></div></div>`).join('')}
            </div>
            <div class="oks-check-status" style="margin-top:12px;"></div>
        </div>`;
}
            const prevCadastralNumbers = All(newParcel, 'PrevCadastralNumbers > CadastralNumber');
            if (prevCadastralNumbers.length > 0) {
                sectionContent += `<div class="subsection"><div class="subsection-title">Исходные земельные участки</div><div class="info-grid">${Array.from(prevCadastralNumbers).map(node => `<div class="info-card"><div class="info-value">${node.textContent}</div></div>`).join('')}</div></div>`;
            }
            if (E(newParcel, 'Address')) {
                sectionContent += `<div class="subsection"><div class="subsection-title">Адрес</div><div class="address-display">${getFullAddress(E(newParcel, 'Address'))}</div><div class="info-grid" style="margin-top: 16px;"><div class="info-card"><div class="info-label">FIAS</div><div class="info-value">${T(E(newParcel, 'Address'), 'FIAS')}</div></div></div></div>`;
            }
            const entitySpatial = E(newParcel, 'EntitySpatial');
            if (entitySpatial) {
                sectionContent += createSpatialDataHtml(entitySpatial);
            }
            const hasCoords = !!entitySpatial;
            mainHtml += `<div class="section"><div class="section-header">${sectionIcons.newParcel}<h3 class="section-title">Сведения об образуемом участке (${A(newParcel, 'Definition')})</h3>${hasCoords ? `<button class="header-button copy-coords-btn" title="Скопировать координаты и открыть схему">${sectionIcons.copyXY}</button>` : ''}</div><div class="section-content" style="padding:16px">${sectionContent}</div></div>`;
        }
        const specifiedParcels = All(xmlDoc, 'SpecifyParcel > ExistParcel');
        for (const parcel of specifiedParcels) {
            sectionsFound++;
            const cadNum = A(parcel, 'CadastralNumber');
            const categoryCode = A(E(parcel, 'Category'), 'Category');
            const categoryName = landCategories[categoryCode] || 'Категория не определена';
            let sectionContent = `<div class="info-grid">
                <div class="info-card"><div class="info-label">Кадастровый номер</div><div class="info-value"><code>${cadNum}</code></div></div>
                <div class="info-card"><div class="info-label">Кадастровый квартал</div><div class="info-value">${T(parcel, 'CadastralBlock')}</div></div>
                ${categoryCode && categoryCode !== '—' ? `<div class="info-card"><div class="info-label">Категория земель</div><div class="info-value">${categoryName} <code>${categoryCode}</code></div></div>` : ''}
                <div class="info-card"><div class="info-label">Уточненная площадь, кв.м.</div><div class="info-value">${T(parcel, 'Area > Area')} (погрешность ±${T(parcel, 'Area > Inaccuracy')})</div></div>
                <div class="info-card"><div class="info-label">Площадь по ЕГРН, кв.м.</div><div class="info-value">${T(parcel, 'AreaInGKN')}</div></div>
                <div class="info-card"><div class="info-label">Разница площадей, кв.м.</div><div class="info-value">${T(parcel, 'DeltaArea')}</div></div>
                <div class="info-card" style="grid-column: 1 / -1;"><div class="info-label">Обеспечение доступа</div><div class="info-value">${T(parcel, 'ProvidingPassCadastralNumbers > Other')}</div></div>
            </div>`;
            if (T(parcel, 'Area > Formula') !== '—') {
                sectionContent += `<div class="subsection"><div class="subsection-title">Формула погрешности</div><div class="conclusion-text">${T(parcel, 'Area > Formula')}</div></div>`;
            }
         if (All(parcel, 'ObjectsRealty CadastralNumber').length > 0) {
    const oksNumbers = Array.from(All(parcel, 'ObjectsRealty CadastralNumber')).map(node => node.textContent.trim());
    sectionContent += `
        <div class="subsection">
            <div class="subsection-title" style="display:flex; align-items:center; justify-content:space-between; flex-wrap:wrap; gap:8px;">
                <span>ОКС на участке</span>
                <button class="check-oks-egrn-btn" data-oks-numbers='${JSON.stringify(oksNumbers)}'>
                    <i class="fas fa-clipboard-check"></i>
                    <span class="btn-text">Проверить в ЕГРН</span>
                </button>
            </div>
            <div class="info-grid oks-list-container">
                ${oksNumbers.map(kn => `<div class="info-card oks-item" data-cad-number="${kn}"><div class="info-value">${kn}</div><div class="oks-address" style="font-size:0.85em; color:var(--text-secondary); margin-top:4px;"></div></div>`).join('')}
            </div>
            <div class="oks-check-status" style="margin-top:12px;"></div>
        </div>`;
}
            const entitySpatial = E(parcel, 'EntitySpatial');
            if (entitySpatial) {
                sectionContent += createSpatialDataHtml(entitySpatial);
            }
            mainHtml += `<div class="section">
                <div class="section-header">
                    ${sectionIcons.newParcel}
                    <h3 class="section-title">Сведения об уточняемом участке</h3>
                    <button class="header-button copy-coords-btn" title="Скопировать координаты и открыть схему">${sectionIcons.copyXY}</button>
                </div>
                <div class="section-content" style="padding:16px">${sectionContent}</div>
            </div>`;
        }
        const approxParcels = All(xmlDoc, 'SpecifyParcelApproximal > ExistParcel');
        for (const parcel of approxParcels) {
            sectionsFound++;
            const cadNum = A(parcel, 'CadastralNumber');
            const categoryCode = A(E(parcel, 'Category'), 'Category');
            const categoryName = landCategories[categoryCode] || 'Категория не определена';
            let sectionContent = `<div class="info-grid">
                <div class="info-card"><div class="info-label">Кадастровый номер</div><div class="info-value"><code>${cadNum}</code></div></div>
                <div class="info-card"><div class="info-label">Кадастровый квартал</div><div class="info-value">${T(parcel, 'CadastralBlock')}</div></div>
                ${categoryCode && categoryCode !== '—' ? `<div class="info-card"><div class="info-label">Категория земель</div><div class="info-value">${categoryName} <code>${categoryCode}</code></div></div>` : ''}
                <div class="info-card"><div class="info-label">Уточненная площадь, кв.м.</div><div class="info-value">${T(parcel, 'Area > Area')} (погрешность ±${T(parcel, 'Area > Inaccuracy')})</div></div>
                <div class="info-card"><div class="info-label">Площадь по ЕГРН, кв.м.</div><div class="info-value">${T(parcel, 'AreaInGKN')}</div></div>
                <div class="info-card"><div class="info-label">Разница площадей, кв.м.</div><div class="info-value">${T(parcel, 'DeltaArea')}</div></div>
                <div class="info-card" style="grid-column: 1 / -1;"><div class="info-label">Обеспечение доступа</div><div class="info-value">${T(parcel, 'ProvidingPassCadastralNumbers > Other')}</div></div>
            </div>`;
            if (T(parcel, 'Area > Formula') !== '—') {
                sectionContent += `<div class="subsection"><div class="subsection-title">Формула погрешности</div><div class="conclusion-text">${T(parcel, 'Area > Formula')}</div></div>`;
            }
            if (All(parcel, 'ObjectsRealty CadastralNumber').length > 0) {
                sectionContent += `<div class="subsection"><div class="subsection-title">ОКС на участке</div><div class="info-grid">${Array.from(All(parcel, 'ObjectsRealty CadastralNumber')).map(node => `<div class="info-card"><div class="info-value">${node.textContent}</div></div>`).join('')}</div></div>`;
            }
            const contours = All(parcel, 'Contours > ExistContour, Contours > NewContour, Contours > Contour');
            if (contours.length > 0) {
                contours.forEach(contour => {
                    const contourNum = A(contour, 'NumberRecord') || A(contour, 'Definition') || '';
                    const contourArea = T(contour, 'Area > Area');
                    const entitySpatial = E(contour, 'EntitySpatial');
                    sectionContent += `<div class="subsection"><div class="subsection-title">Контур ${contourNum}${contourArea !== '—' ? ` (площадь: ${contourArea} кв.м.)` : ''}</div>${entitySpatial ? createSpatialDataHtml(entitySpatial) : ''}</div>`;
                });
            } else {
                const entitySpatial = E(parcel, 'EntitySpatial');
                if (entitySpatial) {
                    sectionContent += createSpatialDataHtml(entitySpatial);
                }
            }
            mainHtml += `<div class="section">
                <div class="section-header">
                    ${sectionIcons.newParcel}
                    <h3 class="section-title">Смежный земельный участок с площадью: ${cadNum}</h3>
                    <button class="header-button copy-coords-btn" title="Скопировать координаты и открыть схему">${sectionIcons.copyXY}</button>
                </div>
                <div class="section-content" style="padding:16px">${sectionContent}</div>
            </div>`;
        }
        const specifyRelatedParcels = All(xmlDoc, 'SpecifyRelatedParcel');
        specifyRelatedParcels.forEach(specifyRelatedParcel => {
            sectionsFound++;
            const relatedCadNum = A(specifyRelatedParcel, 'CadastralNumber');
            let relatedContentHtml = '';
            const contours = All(specifyRelatedParcel, 'Contours > NewContour, Contours > Contour');
            if (contours.length > 0) {
                contours.forEach(cnt => {
                    const definition = A(cnt, 'Definition');
                    const entSpatial = E(cnt, 'EntitySpatial');
                    if (entSpatial) {
                        relatedContentHtml += `<div class="subsection"><div class="subsection-title">Контур ${definition}</div>${createSpatialDataHtml(entSpatial)}</div>`;
                    }
                });
            } else {
                const entSpatial = E(specifyRelatedParcel, 'EntitySpatial');
                if (entSpatial) {
                    relatedContentHtml += createSpatialDataHtml(entSpatial);
                } else {
                    const allBorderSpatial = E(specifyRelatedParcel, 'AllBorder > EntitySpatial');
                    if (allBorderSpatial) {
                        relatedContentHtml += createSpatialDataHtml(allBorderSpatial);
                    }
                }
            }
            if (!relatedContentHtml) {
                let tableContent = '';
                All(specifyRelatedParcel, 'ChangeBorder').forEach(ch => {
                    const oldOrd = E(ch, 'OldOrdinate');
                    const newOrd = E(ch, 'NewOrdinate');
                    const oldPointName = oldOrd ? (A(oldOrd, 'NumGeopoint') || '—') : '—';
                    const newPointName = newOrd ? ((A(newOrd, 'PointPref') || '') + A(newOrd, 'NumGeopoint')) : '—';
                    const displayPointName = newPointName !== '—' ? newPointName : oldPointName;
                    tableContent += `<tr>
                        <td>${displayPointName}</td>
                        <td>${oldOrd ? `${A(oldOrd, 'X')}, ${A(oldOrd, 'Y')}` : '—'}</td>
                        <td>${newOrd ? `${A(newOrd, 'X')}, ${A(newOrd, 'Y')}` : '—'}</td>
                        <td class="left-align">${newOrd ? `Δ=${A(newOrd, 'DeltaGeopoint')} м, ${A(newOrd, 'GeopointZacrep')}` : 'Точка удалена'}</td>
                    </tr>`;
                });
                if (tableContent) {
                    relatedContentHtml += `<div class="subsection"><div class="subsection-title">Изменение частей границы</div><table class="data-table coord-table"><thead><tr><th>Точка</th><th>Старые коорд. (X, Y)</th><th>Новые коорд. (X, Y)</th><th class="left-align">Примечание</th></tr></thead><tbody>${tableContent}</tbody></table></div>`;
                }
            }
            if (relatedContentHtml) {
                const randomId = 'rel_' + Math.floor(Math.random() * 1000000);
               const mainParcelCadNum = E(xmlDoc, 'SpecifyParcel > ExistParcel')?.getAttribute('CadastralNumber') || 
                          E(xmlDoc, 'NewParcel')?.querySelector('CadastralBlock')?.textContent?.trim() || '';

mainHtml += `
<div class="section">
    <div class="section-header">
        ${sectionIcons.relatedParcel}
        <h3 class="section-title">Уточнение смежного участка: ${relatedCadNum}</h3>
        <button class="check-related-btn" 
                data-related-cad-number="${relatedCadNum}" 
                data-main-cad-number="${mainParcelCadNum}">
            <i class="fas fa-draw-polygon"></i>
            <span>Проверить границы</span>
        </button>
        <button class="header-button copy-coords-btn" title="Скопировать координаты">${sectionIcons.copyXY}</button>
    </div>
    <div class="section-content" style="padding:16px">
        <div class="info-card" style="margin-bottom: 12px; background: #fff8e1; border-color: #ffe0b2;">
            <div class="info-value">Координаты смежного земельного участка</div>
        </div>
        <button class="print-btn" style="padding: 8px 16px; font-size: 0.9rem;" onclick="document.getElementById('${randomId}').classList.toggle('hidden'); this.textContent = this.textContent.includes('Раскрыть') ? 'Скрыть координаты' : 'Раскрыть список координат';">
            Раскрыть список координат
        </button>
        <div id="${randomId}" class="hidden" style="margin-top: 16px;">
            ${relatedContentHtml}
        </div>
    </div>
</div>`;
            }
        });
        const conclusion = E(xmlDoc, 'Conclusion');
        if (conclusion && conclusion.textContent.trim()) {
            sectionsFound++;
            mainHtml += `<div class="section"><div class="section-header">${sectionIcons.conclusion}<h3 class="section-title">Заключение кадастрового инженера</h3><button class="header-button ai-check-btn" data-conclusion-text="${escapeHtml(conclusion.textContent.trim())}" title="Проверить заключение с помощью ИИ"><i class="fas fa-atom"></i></button></div><div class="section-content" style="padding:16px"><div class="conclusion-text">${conclusion.textContent.trim()}</div></div></div>`;
        }
        const graphicFiles = [
            { title: 'Схема геодезических построений', file: A(E(xmlDoc, 'SchemeGeodesicPlotting'), 'Name') },
            { title: 'Схема расположения ЗУ', file: A(E(xmlDoc, 'SchemeDisposition'), 'Name') },
            { title: 'Чертеж земельного участка', file: A(E(xmlDoc, 'DiagramParcelsSubParcels > AppliedFile'), 'Name') },
            { title: 'Акт согласования границ', file: A(E(xmlDoc, 'AgreementDocument > AppliedFile'), 'Name') }
        ].filter(f => f.file !== '—');
        if (graphicFiles.length > 0) {
            sectionsFound++;
            mainHtml += `<div class="section"><div class="section-header">${sectionIcons.graphics}<h3 class="section-title">Графические разделы</h3></div><div class="section-content" style="padding:16px"><table class="data-table"><thead><tr><th class="left-align">Наименование раздела</th><th class="left-align">Имя файла</th></tr></thead><tbody>${graphicFiles.map(f => `<tr><td class="left-align">${f.title}</td><td class="left-align"><span class="file-name">${f.file}</span></td></tr>`).join('')}</tbody></table></div></div>`;
        }
        const appendixFiles = All(xmlDoc, 'Appendix > AppliedFiles');
        if (appendixFiles.length > 0) {
            sectionsFound++;
            mainHtml += `<div class="section"><div class="section-header">${sectionIcons.appendix}<h3 class="section-title">Приложения</h3></div><div class="section-content" style="padding:16px"><table class="data-table"><thead><tr><th>№</th><th class="left-align">Наименование</th><th class="left-align">Имя файла</th></tr></thead><tbody>${Array.from(appendixFiles).map(f => `<tr><td>${T(f, 'NumberAppendix')}</td><td class="left-align">${T(f, 'NameAppendix')}</td><td class="left-align"><span class="file-name">${A(E(f, 'AppliedFile'), 'Name')}</span></td></tr>`).join('')}</tbody></table></div></div>`;
        }
        const validationHtml = runValidation(xmlDoc, xmlText);
        if (validationHtml) {
            mainHtml += `<div class="section validation-section"><div class="section-header">${sectionIcons.validation}<h3 class="section-title">Проверка межевого плана</h3></div><div class="section-content" style="padding:16px">${validationHtml}</div></div>`;
        }
        if (sectionsFound > 0) {
            mainColumn.innerHTML = mainHtml;
            sidebarColumn.innerHTML = sidebarHtml;
            resultsContainer.classList.remove('hidden');
            statusContainer.classList.add('hidden');
            printButtonContainer.classList.remove('hidden');
            messageArea.innerHTML = '';
        } else {
            showError('Файл успешно прочитан, но в нем не найдено известных разделов межевого плана. Возможно, это XML другого типа.');
        }
    }

    function runValidation(xmlDoc, xmlText) {
        let messages = [];
        const requiredDocsList = (localStorage.getItem(DOCS_LIST_KEY) || '').trim();
        if (requiredDocsList) {
            const requiredDocs = requiredDocsList.split('\n').map(d => d.trim().toLowerCase()).filter(Boolean);
            const foundDocs = [];
            [A(E(xmlDoc, 'SchemeGeodesicPlotting'), 'Name'), A(E(xmlDoc, 'SchemeDisposition'), 'Name'), A(E(xmlDoc, 'DiagramParcelsSubParcels > AppliedFile'), 'Name'), A(E(xmlDoc, 'AgreementDocument > AppliedFile'), 'Name')].forEach(file => { if (file && file !== '—') foundDocs.push({ type: 'file', text: file }); });
            All(xmlDoc, 'InputData Documents Document').forEach(doc => { const name = T(doc, 'Name'); if (name && name !== '—') foundDocs.push({ type: 'docName', text: name }); });
            All(xmlDoc, 'Appendix > AppliedFiles').forEach(f => { const name = T(f, 'NameAppendix'); const file = A(E(f, 'AppliedFile'), 'Name'); if (name && name !== '—') foundDocs.push({ type: 'docName', text: name }); if (file && file !== '—') foundDocs.push({ type: 'file', text: file }); });
            const searchableDocsText = foundDocs.map(item => item.text.toLowerCase());
            let docCheckHtml = `<div class="subsection"><div class="subsection-title">Проверка обязательных документов</div><ul class="doc-check-list">`;
            requiredDocs.forEach(reqDoc => {
                let foundMatch = null; const matchIndex = searchableDocsText.findIndex(searchableText => searchableText.includes(reqDoc));
                if (matchIndex !== -1) { foundMatch = foundDocs[matchIndex].text; }
                if (foundMatch) { docCheckHtml += `<li><i class="fas fa-check-circle"></i> ${escapeHtml(reqDoc)} - <span style="color:var(--success-color)">Найден</span> <span style="color: var(--text-secondary); font-size: 0.9em;">(${escapeHtml(foundMatch)})</span></li>`; }
                else { docCheckHtml += `<li><i class="fas fa-times-circle"></i> ${escapeHtml(reqDoc)} - <span style="color:var(--error-color)">Не найден</span></li>`; }
            });
            docCheckHtml += `</ul></div>`; messages.push(docCheckHtml);
        }
        const today = new Date(); const currentDateString = `${today.getFullYear()}-${String(today.getMonth() + 1).padStart(2, '0')}-${String(today.getDate()).padStart(2, '0')}`;
        const generalWorksEl = E(xmlDoc, 'GeneralCadastralWorks');
        if (generalWorksEl) { const cadWorkDate = A(generalWorksEl, 'DateCadastral'); if (cadWorkDate && cadWorkDate !== currentDateString) { messages.push(`<div class="validation-message validation-warning">${sectionIcons.warningIcon} <strong>Предупреждение:</strong> Дата кадастровых работ (${cadWorkDate}) не является текущей датой.</div>`); } }
        const allDocuments = All(xmlDoc, 'InputData Documents Document');
        for (const doc of allDocuments) { if (T(doc, 'Name') === 'Сведения о геодезической основе') { const docDate = T(doc, 'Date'); if (docDate && docDate !== currentDateString) { messages.push(`<div class="validation-message validation-warning">${sectionIcons.warningIcon} <strong>Предупреждение:</strong> Дата в документе "Сведения о геодезической основе" (${docDate}) не является текущей датой.</div>`); } break; } }
        const geoBasePoints = All(xmlDoc, 'GeodesicBases GeodesicBase ConditionPoint');
        let geoDateMismatch = false;
        for (const point of geoBasePoints) { const pointDate = A(point, 'AsOfDate'); if (pointDate && pointDate !== currentDateString) { geoDateMismatch = true; break; } }
        if (geoDateMismatch) { messages.push(`<div class="validation-message validation-warning">${sectionIcons.warningIcon} <strong>Предупреждение:</strong> Одна или несколько дат состояния пунктов геодезической основы не являются текущей датой.</div>`); }
        let usedAnalytical = false;
        let usedSatellite = false;
        const allOrdinates = All(xmlDoc, 'Ordinate');
        for (const ord of allOrdinates) {
            const m = A(ord, 'GeopointOpred');
            if (m === '692006000000') usedAnalytical = true;
            if (m === '692005000000') usedSatellite = true;
        }
        let hasGeoBaseDates = false;
        for (const point of geoBasePoints) { 
            const d = A(point, 'AsOfDate');
            if (d && d !== '—') {
                hasGeoBaseDates = true;
                break;
            } 
        }
        if (usedSatellite && !hasGeoBaseDates) {
             messages.push(`<div class="validation-message validation-error">${sectionIcons.errorIcon} <strong>Ошибка метода:</strong> Использован "Метод спутниковых геодезических измерений", но отсутствуют сведения о дате состояния пунктов геодезической основы (AsOfDate).</div>`);
        }
        if (usedAnalytical && !usedSatellite && hasGeoBaseDates) {
             messages.push(`<div class="validation-message validation-warning">${sectionIcons.warningIcon} <strong>Предупреждение:</strong> Использован только "Аналитический метод", но заполнены даты состояния пунктов геодезической основы. При аналитическом методе пункты ГГС обычно не обследуются.</div>`);
        }
        const inputDocuments = All(xmlDoc, 'InputData Documents Document');
        inputDocuments.forEach(doc => {
            const docName = T(doc, 'Name');
            const docNumber = T(doc, 'Number');
            const docDate = T(doc, 'Date');
            const appliedFile = E(doc, 'AppliedFile');
            const fileName = appliedFile ? A(appliedFile, 'Name') : null;
            if (!fileName || fileName === '—') return;
            const fileNameOnly = fileName.includes('\\') ? fileName.split('\\').pop() : fileName;
            if (docNumber && docNumber !== '—' && docNumber.toLowerCase() !== 'б/н') {
                const normalizedDocNumber = docNumber.trim();
                const containsAsWholeWord = (text, word) => {
                    const lowerText = text.toLowerCase();
                    const lowerWord = word.toLowerCase();
                    let index = lowerText.indexOf(lowerWord);
                    while (index !== -1) {
                        const beforeChar = index > 0 ? lowerText[index - 1] : ' ';
                        const afterChar = index + lowerWord.length < lowerText.length ? lowerText[index + lowerWord.length] : ' ';
                        const isWordChar = (c) => /[a-zA-Zа-яА-ЯёЁ0-9]/.test(c);
                        if (!isWordChar(beforeChar) && !isWordChar(afterChar)) {
                            return true;
                        }
                        index = lowerText.indexOf(lowerWord, index + 1);
                    }
                    return false;
                };
                if (!containsAsWholeWord(fileNameOnly, normalizedDocNumber)) {
                    const normalizeStr = (str) => str.replace(/[\u2010-\u2015\u2212\uFE58\uFE63\uFF0D—–]/g, '-').replace(/\s+/g, ' ').trim();
                    const normalizedFileName = normalizeStr(fileNameOnly);
                    const normalizedNumber = normalizeStr(normalizedDocNumber);
                    if (!containsAsWholeWord(normalizedFileName, normalizedNumber)) {
                        const fileNameWithoutDates = fileNameOnly.replace(/\b\d{2}\.\d{2}\.\d{4}\b/g, '');
                        const numbersInFileName = fileNameWithoutDates.match(/\d{2,}/g);
                        const foundNumbersText = numbersInFileName && numbersInFileName.length > 0 ? ` (числа в файле: <strong>${numbersInFileName.join(', ')}</strong>)` : '';
                        messages.push(`<div class="validation-message validation-warning">${sectionIcons.warningIcon} <strong>Несоответствие номера:</strong> В документе "${escapeHtml(docName)}" указан номер <strong>${escapeHtml(docNumber)}</strong>, но в имени файла "<span class="file-name">${escapeHtml(fileNameOnly)}</span>" он не найден${foundNumbersText}.</div>`);
                    }
                }
            }
            if (docDate && docDate !== '—') {
                const dateInFileNameMatch = fileNameOnly.match(/\b(\d{2})\.(\d{2})\.(\d{4})\b/);
                if (dateInFileNameMatch) {
                    const fileDay = dateInFileNameMatch[1];
                    const fileMonth = dateInFileNameMatch[2];
                    const fileYear = dateInFileNameMatch[3];
                    const fileDateNormalized = `${fileYear}-${fileMonth}-${fileDay}`;
                    if (fileDateNormalized !== docDate) {
                        const docDateFormatted = docDate.split('-').reverse().join('.');
                        const fileDateFormatted = `${fileDay}.${fileMonth}.${fileYear}`;
                        messages.push(`<div class="validation-message validation-warning">${sectionIcons.warningIcon} <strong>Несоответствие даты:</strong> В документе "${escapeHtml(docName)}" указана дата <strong>${docDateFormatted}</strong>, но в имени файла "<span class="file-name">${escapeHtml(fileNameOnly)}</span>" указана дата <strong>${fileDateFormatted}</strong>.</div>`);
                    }
                }
            }
        });
        const dateWarnings = []; const foundDates = new Set(); const dateRegex = /(?:\b(\d{2})\.(\d{2})\.(\d{4})\b)|(?:\b(\d{4})-(\d{2})-(\d{2})\b)/g; const minDate = new Date(1990, 0, 1); const currentDate = new Date(); currentDate.setHours(23, 59, 59, 999); let match;
        while ((match = dateRegex.exec(xmlText)) !== null) {
            const fullMatch = match[0]; if (foundDates.has(fullMatch)) continue; foundDates.add(fullMatch);
            let day, month, year, parsedDate;
            if (match[1]) { day = parseInt(match[1], 10); month = parseInt(match[2], 10); year = parseInt(match[3], 10); } else { year = parseInt(match[4], 10); month = parseInt(match[5], 10); day = parseInt(match[6], 10); }
            parsedDate = new Date(year, month - 1, day); if (parsedDate.getFullYear() !== year || parsedDate.getMonth() !== month - 1 || parsedDate.getDate() !== day) continue;
            if (parsedDate < minDate) dateWarnings.push(`"${fullMatch}"`); else if (parsedDate > currentDate) dateWarnings.push(`"${fullMatch}" (будущая дата)`);
        }
        if (dateWarnings.length > 0) { messages.push(`<div class="validation-message validation-warning">${sectionIcons.warningIcon} <strong>Предупреждение о датах:</strong> Найдены даты за пределами допустимого диапазона (01.01.1990 - сегодня): ${dateWarnings.join(', ')}.</div>`); }
        const knRegex = /\d{2}:\d{2}:\d{6,7}:\d+/g; const blockRegex = /\d{2}:\d{2}:\d{6,7}/; let allNumbers = new Set((xmlText.match(knRegex) || [])); All(xmlDoc, 'CadastralBlock').forEach(b => allNumbers.add(b.textContent.trim())); const quarters = new Map();
        allNumbers.forEach(num => { const match = num.match(blockRegex); if (match) { const quarter = match[0]; if (!quarters.has(quarter)) quarters.set(quarter, []); quarters.get(quarter).push(num); } });
        const colors = ['#1d4ed8', '#b91c1c', '#c2410c', '#15803d', '#86198f']; let colorIndex = 0; const quarterColors = new Map(); for (const q of quarters.keys()) { quarterColors.set(q, colors[colorIndex % colors.length]); colorIndex++; }
        if (quarters.size > 1) { messages.push(`<div class="validation-message validation-warning">${sectionIcons.warningIcon} <strong>Предупреждение:</strong> Найдены объекты из разных кадастровых кварталов.</div>`); }
        let numberListHtml = '<ul id="cadastralNumbersList">'; quarters.forEach((numbers, quarter) => { const color = quarterColors.get(quarter); numbers.sort().forEach(num => { numberListHtml += `<li style="border-color:${color}; color:${color};">${num}</li>`; }); }); numberListHtml += '</ul>'; messages.push(`<div class="subsection" style="margin-top:0"><div class="subsection-title">Все кадастровые номера в документе</div>${numberListHtml}</div>`);
        const mainParcel = E(xmlDoc, 'NewParcel') || E(xmlDoc, 'ExistParcel');
        if (mainParcel) {
            const categoryCode = A(E(mainParcel, 'Category'), 'Category'); 
            const requiredMt = accuracyStandards[categoryCode]; 
            let area = 0;
            let statedAreaInaccuracy = 0;
            const directAreaNode = Array.from(mainParcel.children).find(el => el.tagName === 'Area');
            if (directAreaNode) {
                area = parseFloat(T(directAreaNode, 'Area'));
                statedAreaInaccuracy = parseFloat(T(directAreaNode, 'Inaccuracy'));
            } else {
                 area = parseFloat(T(mainParcel, 'Area > Area'));
                 statedAreaInaccuracy = parseFloat(T(mainParcel, 'Area > Inaccuracy'));
            }
            const ordinates = Array.from(All(mainParcel, 'EntitySpatial > SpatialElement > SpelementUnit > NewOrdinate, EntitySpatial > SpatialElement > SpelementUnit > Ordinate'));
            if (ordinates.length > 0) {
                const accuracies = new Set(); let allFixingsFilled = true;
                ordinates.forEach(ord => { const delta = A(ord, 'DeltaGeopoint'); if(delta && delta !== '—') accuracies.add(parseFloat(delta)); if(A(ord, 'GeopointZacrep') === '—') allFixingsFilled = false; });
                if (!allFixingsFilled) { messages.push(`<div class="validation-message validation-warning">${sectionIcons.warningIcon} <strong>Предупреждение:</strong> Не для всех точек указан метод закрепления на местности.</div>`);}
                if (accuracies.size > 1) { messages.push(`<div class="validation-message validation-warning">${sectionIcons.warningIcon} <strong>Предупреждение:</strong> У точек главного участка разные значения погрешности (${Array.from(accuracies).join(', ')}).</div>`); }
                const actualMt = accuracies.size > 0 ? accuracies.values().next().value : null;
                if (requiredMt && actualMt) { if (actualMt !== requiredMt) { messages.push(`<div class="validation-message validation-error">${sectionIcons.errorIcon} <strong>Ошибка Mt:</strong> Указанная погрешность точек <strong>${actualMt}</strong> не соответствует нормативу <strong>${requiredMt}</strong> для категории "${landCategories[categoryCode]}".</div>`); } else { messages.push(`<div class="validation-message validation-success">${sectionIcons.successIcon} <strong>Проверка Mt:</strong> Погрешность точек <strong>${actualMt}</strong> соответствует нормативу для данной категории земель.</div>`); } } else if (!requiredMt) { messages.push(`<div class="validation-message validation-warning">${sectionIcons.warningIcon} <strong>Проверка Mt:</strong> Не удалось определить норматив погрешности, так как категория земель не указана</div>`); }
                if (area && actualMt && statedAreaInaccuracy) { 
                    const calculatedAreaInaccuracy = Math.round(3.5 * actualMt * Math.sqrt(area)); 
                    if (calculatedAreaInaccuracy !== statedAreaInaccuracy) { 
                        messages.push(`<div class="validation-message validation-error">${sectionIcons.errorIcon} <strong>Ошибка ΔP:</strong> Расчетная погрешность площади <strong>(${calculatedAreaInaccuracy} м²)</strong> не совпадает с указанной в XML <strong>(${statedAreaInaccuracy} м²)</strong>.</div>`); 
                    } else { 
                        messages.push(`<div class="validation-message validation-success">${sectionIcons.successIcon} <strong>Проверка ΔP:</strong> Расчетная погрешность площади <strong>(${calculatedAreaInaccuracy} м²)</strong> совпадает с указанной в XML</div>`); 
                    } 
                }
            }
        }
        const contradictionHtml = `
            <div class="subsection">
                <div class="subsection-title" style="display:flex; align-items:center; gap: 8px;">
                    ${sectionIcons.contradiction}
                    <span>Проверка данных</span>
                </div>
                <button id="contradictionCheckBtn" class="print-btn contradiction-btn">
                    <i class="fas fa-balance-scale-right"></i>
                    <span>Найти несоответствия</span>
                </button>
                <div id="contradictionAnalysisResult" style="margin-top: 16px;"></div>
            </div>
        `;
        messages.push(contradictionHtml);
        return messages.length > 0 ? messages.join('') : '';
    }

    function openAiModal() { aiCheckModal.style.display = 'flex'; }
    function closeAiModal() { aiCheckModal.style.display = 'none'; aiCheckResultDisplay.innerHTML = ''; }

    async function checkConclusionWithAI(conclusionText) {
        if (!conclusionText) { alert("Текст заключения пуст. Проверка невозможна."); return; }
        openAiModal();
        aiCheckResultDisplay.innerHTML = `<div class="ai-spinner"><div class="loader"></div><span>Анализирую текст...</span></div>`;
        const systemPrompt = `Ты — эксперт-помощник кадастрового инженера в России. Твоя задача — проанализировать "Заключение кадастрового инженера" из межевого плана. Проверь текст на: 1. **Полноту:** Упомянуты ли основания для работ (договор, проект), исходные документы, способ образования/уточнения, кадастровые номера? 2. **Ясность и однозначность:** Формулировки должны быть четкими, без двусмысленности. 3. **Корректность терминологии:** Правильно ли используются кадастровые термины. 4. **Логичность:** Обоснованы ли выполненные действия (например, почему площадь изменилась, как обеспечен доступ). 5. **Орфографию и грамматику.** Верни ответ СТРОГО в формате JSON с тремя полями: - "is_correct": boolean (true, если текст идеален и не требует правок, иначе false). - "feedback": string (детальный, но краткий анализ на русском языке, с пунктами по существу дела, можно использовать Markdown для списков). - "corrected_text": string (улучшенная версия заключения. Если правок нет, верни исходный текст). Не добавляй никаких комментариев или объяснений вне JSON.`;
        const userPrompt = `${systemPrompt}\n\nТекст для проверки:\n---\n${conclusionText}`;
        let apiUrl, requestBody; 
        const modelId = "gemini-3-flash-preview";
        if (PROXY_MODE === 1) { 
            apiUrl = `${MAPRUAPP_PROXY_BASE_URL}/ai/api/v1/chat/completions`; 
            requestBody = { model: modelId, messages: [{ role: "user", content: userPrompt }], max_tokens: 8192, response_format: { type: "json_object" } }; 
        } else { 
            aiCheckResultDisplay.innerHTML = `<div class="ai-result-error">Режим прокси не настроен.</div>`; 
            return; 
        }
        try {
            const response = await fetch(apiUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(requestBody) });
            const data = await response.json(); if (!response.ok) { throw new Error(`Ошибка API (${response.status}): ${data?.error?.message || `Статус ${response.status}`}`); }
            let aiResponseText = data.choices?.[0]?.message?.content; if (!aiResponseText) { throw new Error('Не удалось получить ответ от ИИ (пустое поле content).'); }
            let parsedResponse; try { const cleanedText = aiResponseText.trim().replace(/^```json\s*|\s*```$/g, ''); parsedResponse = JSON.parse(cleanedText); } catch (e) { console.error("AI Response (raw):", aiResponseText); throw new Error("Ответ ИИ имеет неверную структуру JSON."); }
            let resultHtml = '';
            if (parsedResponse.is_correct) { resultHtml = `<div class="ai-result-success"><i class="fas fa-check-circle"></i> <strong>Вердикт ИИ:</strong> Заключение составлено хорошо. Замечаний нет.</div>`; }
            else { resultHtml += `<h4><i class="fas fa-lightbulb"></i> Анализ ИИ:</h4><div class="ai-feedback">${escapeHtml(parsedResponse.feedback)}</div>`; if (parsedResponse.corrected_text && parsedResponse.corrected_text !== conclusionText) { resultHtml += `<h4><i class="fas fa-magic-wand-sparkles"></i> Предложенная редакция:</h4><pre class="ai-corrected-text">${escapeHtml(parsedResponse.corrected_text)}</pre><button class="ai-copy-button" id="aiCopyBtn"><i class="fas fa-copy"></i><span>Копировать исправленный текст</span></button>`; } }
            aiCheckResultDisplay.innerHTML = resultHtml;
        } catch (error) { console.error('Ошибка при проверке заключения с ИИ:', error); aiCheckResultDisplay.innerHTML = `<div class="ai-result-error"><strong>Произошла ошибка:</strong> ${error.message}</div>`; }
    }

    function extractDataDigest(xmlDoc) {
        let digestParts = [];
        const mainParcel = E(xmlDoc, 'NewParcel, SpecifyParcel > ExistParcel');
        if (mainParcel) {
            const parcelType = mainParcel.tagName === 'NewParcel' ? `ОБРАЗУЕМЫЙ УЧАСТОК (${A(mainParcel, 'Definition') || ''})` : `УТОЧНЯЕМЫЙ УЧАСТОК (${A(mainParcel, 'CadastralNumber') || ''})`;
            let parcelInfo = `[${parcelType}]\n`;
            parcelInfo += `Квартал: ${T(mainParcel, 'CadastralBlock')}\n`;
            parcelInfo += `Площадь: ${T(mainParcel, 'Area > Area')} (±${T(mainParcel, 'Area > Inaccuracy')})\n`;
            parcelInfo += `Адрес: ${getFullAddress(E(mainParcel, 'Address'))}\n`;
            parcelInfo += `Формула погрешности: ${T(mainParcel, 'Area > Formula')}\n`;
            digestParts.push(parcelInfo);
            const oksNodes = All(mainParcel, 'ObjectsRealty CadastralNumber');
            if (oksNodes.length > 0) {
                let oksInfo = '[ОКС НА УЧАСТКЕ]\n';
                oksInfo += `Номера ОКС: ${Array.from(oksNodes).map(node => node.textContent.trim()).join(', ')}\n`;
                digestParts.push(oksInfo);
            }
        }
        const agreementCadWork = E(xmlDoc, 'AgreementCadWork');
        if (agreementCadWork) {
            const contractName = T(agreementCadWork, 'Name');
            const contractNumber = T(agreementCadWork, 'NumberAgreement');
            const contractDate = T(agreementCadWork, 'DateAgreement');
            digestParts.push(`[ДОГОВОР НА ВЫПОЛНЕНИЕ КАДАСТРОВЫХ РАБОТ]\nНаименование: ${contractName}\nНомер договора: ${contractNumber}\nДата договора: ${contractDate}\n`);
        }
        const reasonText = T(xmlDoc, 'GeneralCadastralWorks > Reason');
        if (reasonText !== '—') {
            digestParts.push(`[ОСНОВАНИЕ ДЛЯ РАБОТ]\nТекст: ${reasonText}\n`);
        }
        const conclusionText = T(xmlDoc, 'Conclusion');
        if (conclusionText !== '—') {
            digestParts.push(`[ЗАКЛЮЧЕНИЕ ИНЖЕНЕРА]\nТекст: ${conclusionText}\n`);
        }
        const inputDocs = All(xmlDoc, 'InputData Documents Document');
        if (inputDocs.length > 0) {
            let docsInfo = '[ИСХОДНЫЕ ДОКУМЕНТЫ]\n';
            inputDocs.forEach(doc => {
                docsInfo += `- Наименование: ${T(doc, 'Name')}, Номер: ${T(doc, 'Number')}, Дата: ${T(doc, 'Date')}\n`;
            });
            digestParts.push(docsInfo);
        }
        const appendixDocs = All(xmlDoc, 'Appendix > AppliedFiles');
        if (appendixDocs.length > 0) {
            let appendixInfo = '[ПРИЛОЖЕНИЯ]\n';
            appendixDocs.forEach(doc => {
                 const name = T(doc, 'NameAppendix');
                 const fileName = A(E(doc, 'AppliedFile'), 'Name');
                 appendixInfo += `- Наименование: ${name}, Имя файла: ${fileName}\n`;
            });
            digestParts.push(appendixInfo);
        }
        return digestParts.join('\n');
    }

    async function performContradictionAnalysis() {
        const resultContainer = document.getElementById('contradictionAnalysisResult');
        if (!lastXmlDoc) {
            resultContainer.innerHTML = `<div class="error-message">Сначала загрузите XML файл.</div>`;
            return;
        }
        resultContainer.innerHTML = `<div style="display:flex; align-items:center; gap: 12px; justify-content:center; padding: 10px; color: var(--text-secondary);"><div class="loader"></div><span>Анализ документа на наличие противоречий...</span></div>`;
        const dataDigest = extractDataDigest(lastXmlDoc);
        if (!dataDigest) {
            resultContainer.innerHTML = `<div class="validation-message validation-warning">${sectionIcons.warningIcon} Недостаточно данных в XML для проведения анализа.</div>`;
            return;
        }
        const systemPrompt = `Ты — внимательный и педантичный эксперт-аудитор кадастровых данных. Твоя задача — найти значимые смысловые расхождения в ключевых параметрах документа. Противоречие — это когда адрес указывает на разные места, площади не совпадают, номера документов или кадастровые кварталы разные. Что считать НЕЗНАЧИТЕЛЬНЫМ (игнорировать): - Разный формат дат ('16.07.2025' и '2025-07-16'). - Разный формат площади, если числовое значение совпадает ('29' и '29 кв.м.'). - Небольшие различия в тексте, не меняющие смысл ('Респ. 16' и 'Республика Татарстан, Нурлатский...'). Твой отчет должен содержать ТОЛЬКО реальные ошибки. Если данные полностью совпадают по смыслу, не включай их в ответ. Если противоречий нет, верни пустой массив []. Твой ответ должен быть СТРОГО в формате JSON-массива с ключами на АНГЛИЙСКОМ языке ("parameter", "value1", "source1", "value2", "source2", "comment").`;
        const userPrompt = `${systemPrompt}\n\n[ДАННЫЕ ДЛЯ АНАЛИЗА]\n${dataDigest}`;
        let apiUrl, requestBody; 
        const modelId = "gemini-2.5-flash-lite";
        if (PROXY_MODE === 1) {
            apiUrl = `${MAPRUAPP_PROXY_BASE_URL}/ai/api/v1/chat/completions`;
            requestBody = { model: modelId, messages: [{ role: "user", content: userPrompt }], max_tokens: 8192, response_format: { type: "json_object" } };
        } else {
            resultContainer.innerHTML = `<div class="error-message">Режим прокси не настроен.</div>`;
            return;
        }
        try {
            const response = await fetch(apiUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(requestBody) });
            const data = await response.json(); if (!response.ok) { throw new Error(`Ошибка API (${response.status}): ${data?.error?.message || `Статус ${response.status}`}`); }
            let aiResponseText = data.choices?.[0]?.message?.content; if (!aiResponseText) { throw new Error('Не удалось получить ответ от ИИ (пустое поле content).'); }
            let parsedResponse;
            try {
                const cleanedText = aiResponseText.trim().replace(/^```json\s*|\s*```$/g, '');
                if (cleanedText === '{}' || cleanedText === '') {
                    parsedResponse = [];
                } else {
                    parsedResponse = JSON.parse(cleanedText);
                }
            } catch (e) { console.error("AI Response (raw):", aiResponseText); throw new Error("Ответ ИИ имеет неверную структуру JSON."); }
            displayContradictionResults(parsedResponse);
        } catch (error) {
            console.error('Ошибка при анализе противоречий:', error);
            resultContainer.innerHTML = `<div class="error-message"><strong>Произошла ошибка:</strong> ${error.message}</div>`;
        }
    }

    function displayContradictionResults(resultsArray) {
        const resultContainer = document.getElementById('contradictionAnalysisResult');
        if (!Array.isArray(resultsArray)) {
            resultContainer.innerHTML = `<div class="error-message">Получен некорректный ответ от ИИ (не является массивом).</div>`;
            return;
        }
        if (resultsArray.length === 0) {
            resultContainer.innerHTML = `<div class="validation-message validation-success">${sectionIcons.successIcon} <strong>Несоответствий не найдено.</strong> Все ключевые данные в документе согласованы.</div>`;
            return;
        }
        const firstItem = resultsArray[0];
        const requiredKeys = ['parameter', 'value1', 'source1', 'value2', 'source2', 'comment'];
        const hasRequiredKeys = requiredKeys.every(key => key in firstItem);
        if (!hasRequiredKeys) {
            resultContainer.innerHTML = `<div class="error-message"><strong>Ошибка формата ответа ИИ.</strong> Модель вернула данные с неверными ключами. Попробуйте еще раз.</div>`;
            console.error("Неверный формат от ИИ:", firstItem);
            return;
        }
        let tableHtml = `<table class="contradiction-table">
            <thead>
                <tr>
                    <th>Параметр</th>
                    <th>Источник 1</th>
                    <th>Источник 2</th>
                    <th>Комментарий</th>
                </tr>
            </thead>
            <tbody>`;
        resultsArray.forEach(item => {
            tableHtml += `
                <tr>
                    <td>${escapeHtml(item.parameter)}</td>
                    <td>
                        <span class="source-label">${escapeHtml(item.source1)}</span>
                        <div>${escapeHtml(item.value1)}</div>
                    </td>
                    <td>
                        <span class="source-label">${escapeHtml(item.source2)}</span>
                        <div>${escapeHtml(item.value2)}</div>
                    </td>
                    <td>${escapeHtml(item.comment)}</td>
                </tr>`;
        });
        tableHtml += `</tbody></table>`;
        resultContainer.innerHTML = tableHtml;
    }

    setupEventListeners();
});
</script>
</body>
</html>