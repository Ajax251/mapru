<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Схема XML</title>
    <link rel="stylesheet" href="webfonts/all.min.css">
    <script src="webfonts/jszip.min.js"></script>
    <script src="webfonts/xlsx.full.min.js"></script>
    <link rel="icon" href="https://img.icons8.com/?size=100&id=kIMMKsK2yzqd&format=png&color=000000" type="image/png">
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <style>
body {
    font-family: Arial, sans-serif;
    line-height: 1.6;
    margin: 0;
    background-color: #f0f0f0;
    overflow: hidden;
}

#kptSchemeContainer {
    position: fixed;
    left: 20%;
    top: 0;
    width: 80%;
    height: 100vh;
    background: white;
    z-index: 999;
}

#kptSchemeCanvas {
    width: 100%;
    height: 100%;
    cursor: default;
}

#infoPanel {
    position: fixed;
    top: 0;
    left: 0;
    width: 20%;
    height: 100vh;
    background-color: #f8f8f8;
    border-right: 1px solid #ddd;
    overflow-y: auto;
    z-index: 1000;
    padding: 20px;
    user-select: none;
    box-shadow: 2px 0 10px rgba(0,0,0,0.1);
}



#addObjectBtn:hover {
    background-color: #354f9e;
    transform: scale(1.1);
    box-shadow: 0 6px 12px rgba(0, 0, 0, 0.3);
}

#addObjectBtn:active {
    transform: scale(0.95);
}

#infoPanel .file-input-wrapper {
    margin-top: 0;
    margin-bottom: 20px;
}

.file-input-wrapper {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    text-align: center;
    width: 100%;
}

#selectedParcelInfo h3 {
    text-align: center;
    font-size: 1.2em;
    margin-bottom: 10px;
    color: #336699;
    border-bottom: 2px solid #336699;
    padding-bottom: 5px;
    font-weight: bold;
}

#coordsDialog {
    display: none;
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: 400px;
    background-color: white;
    border-radius: 10px;
    box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
    z-index: 2000;
    padding: 20px;
    opacity: 0;
    transition: opacity 0.3s ease;
}

@keyframes fadeIn {
    from { opacity: 0; }
    to { opacity: 1; }
}

#coordsDialog h3 {
    margin: 0 0 15px;
    font-size: 18px;
    color: #333;
}

#coordsInput {
    width: 100%;
    height: 150px;
    padding: 8px;
    border: 1px solid #ccc;
    border-radius: 4px;
    box-sizing: border-box;
    resize: vertical;
    font-size: 14px;
    margin-bottom: 15px;
    transition: border-color 0.3s;
}

#coordsInput:focus {
    border-color: #4a69bd;
    box-shadow: 0 0 5px rgba(74, 105, 189, 0.5);
    outline: none;
}

.dialog-buttons {
    display: flex;
    justify-content: space-between;
    gap: 10px;
}

#importCoordsBtn, #importFromFileBtn, #closeDialogBtn {
    background-color: #4a69bd;
    color: white;
    border: none;
    padding: 10px 15px;
    border-radius: 5px;
    cursor: pointer;
    transition: all 0.3s;
    flex: 1;
    font-size: 14px;
    position: relative;
    overflow: hidden;
}

#importCoordsBtn:hover, #importFromFileBtn:hover {
    background-color: #354f9e;
    transform: translateY(-2px);
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
}

#importCoordsBtn:active, #importFromFileBtn:active,
#closeDialogBtn:active {
    transform: translateY(1px);
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
}

#closeDialogBtn {
    background-color: #dc3545;
}

#closeDialogBtn:hover {
    background-color: #c82333;
    transform: translateY(-2px);
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
}

.button::after {
    content: '';
    position: absolute;
    top: 50%;
    left: 50%;
    width: 5px;
    height: 5px;
    background: rgba(255, 255, 255, 0.5);
    opacity: 0;
    border-radius: 100%;
    transform: scale(1, 1) translate(-50%);
    transform-origin: 50% 50%;
}

.button:focus:not(:active)::after {
    animation: ripple 1s ease-out;
}

@keyframes ripple {
    0% {
        transform: scale(0, 0);
        opacity: 0.5;
    }
    20% {
        transform: scale(25, 25);
        opacity: 0.3;
    }
    100% {
        opacity: 0;
        transform: scale(40, 40);
    }
}

#dialogOverlay {
    display: none;
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.5);
    z-index: 1999;
    backdrop-filter: blur(2px);
    opacity: 1;
    transition: opacity 0.3s;
}

.file-input-wrapper input[type="file"] {
    position: absolute;
    left: -9999px;
}

.file-input-wrapper label {
    display: inline-block;
    padding: 10px 20px;
    background-color: #4CAF50;
    color: white;
    cursor: pointer;
    border-radius: 5px;
    font-size: 16px;
    transition: all 0.3s ease;
    transform: translateY(-50px);
    opacity: 0;
    animation: dropIn 0.5s forwards;
    user-select: none;
    box-shadow: 0 2px 5px rgba(0,0,0,0.2);
}

@keyframes dropIn {
    0% {
        transform: translateY(-50px);
        opacity: 0;
    }
    100% {
        transform: translateY(0);
        opacity: 1;
    }
}

.file-input-wrapper label:hover {
    background-color: #45a049;
    transform: translateY(-2px);
    box-shadow: 0 4px 8px rgba(0,0,0,0.3);
}

.file-input-wrapper label:active {
    transform: translateY(1px);
    box-shadow: 0 1px 3px rgba(0,0,0,0.2);
}

.button-group {
    display: flex;
    flex-wrap: wrap;
    gap: 10px;
    margin-top: 10px;
}

.button {
    padding: 10px 15px;
    color: white;
    border: none;
    border-radius: 5px;
    cursor: pointer;
    font-size: 14px;
    transition: all 0.3s;
    display: flex;
    align-items: center;
    justify-content: center;
    background-color: #4a69bd;
    box-shadow: 0 2px 5px rgba(0,0,0,0.2);
    position: relative;
    overflow: hidden;
}

.button:hover {
    background-color: #354f9e;
    transform: translateY(-2px);
    box-shadow: 0 4px 8px rgba(0,0,0,0.3);
}

.button:active {
    transform: translateY(1px);
    box-shadow: 0 1px 3px rgba(0,0,0,0.2);
}

.button i {
    margin-right: 8px;
}

#overlappingParcelsList {
    list-style: none;
    padding: 0;
    margin-top: 10px;
}

#overlappingParcelsList li {
    padding: 8px 12px;
    border: 1px solid #ddd;
    margin-bottom: 5px;
    border-radius: 4px;
    background-color: #fff;
    cursor: pointer;
    transition: all 0.2s;
    position: relative;
    overflow: hidden;
}

#overlappingParcelsList li:hover {
    background-color: #f0f0f0;
    transform: translateX(5px);
    box-shadow: 0 2px 5px rgba(0,0,0,0.1);
}

#overlappingParcelsList li:before {
    content: '';
    position: absolute;
    left: 0;
    top: 0;
    height: 100%;
    width: 3px;
    background-color: #4a69bd;
    transform: scaleY(0);
    transition: transform 0.2s;
}

#overlappingParcelsList li:hover:before {
    transform: scaleY(1);
}

#tooltip {
    position: absolute;
    padding: 8px 12px;
    border-radius: 4px;
    font-size: 12px;
    pointer-events: none;
    z-index: 1001;
    display: none;
    box-shadow: 0 2px 10px rgba(0,0,0,0.2);
    font-weight: bold;
}

.notification {
    position: fixed;
    top: 20px;
    right: 20px;
    padding: 15px 20px;
    border-radius: 5px;
    color: white;
    font-size: 14px;
    z-index: 9999;
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
    transform: translateX(120%);
    transition: transform 0.3s ease;
    max-width: 300px;
      border: 1px solid rgba(0, 0, 0, 0.1);
    text-shadow: 0 0 2px rgba(0, 0, 0, 0.5);
}

.notification.info {
    background-color: #3498db;
}

.notification.show {
    transform: translateX(0);
}

.notification.success {
    background-color: #4CAF50;
}

.notification.error {
    background-color: #F44336;
}

.notification.warning {
    background-color: #FF9800;
}

.notification i {
    margin-right: 10px;
}

#loaderContainer {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.5);
    display: none;
    justify-content: center;
    align-items: center;
    z-index: 9999;
}

.loader {
    border: 5px solid #f3f3f3;
    border-top: 5px solid #3498db;
    border-radius: 50%;
    width: 50px;
    height: 50px;
    animation: spin 2s linear infinite;
}

@keyframes spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
}

table {
    width: 100%;
    border-collapse: collapse;
    margin-top: 20px;
    box-shadow: 0 0 20px rgba(0, 0, 0, 0.1);
    animation: fadeInUp 0.5s;
}

@keyframes fadeInUp {
    from {
        opacity: 0;
        transform: translateY(20px);
    }
    to {
        opacity: 1;
        transform: translateY(0);
    }
}

td, th {
    border: 1px solid #ddd;
    padding: 12px;
    text-align: left;
    transition: background-color 0.3s;
}

tr:nth-child(even) {
    background-color: #f8f8f8;
}

tr:nth-child(odd) {
    background-color: #ffffff;
}

tr:hover {
    background-color: #f0f0f0;
    box-shadow: 0 0 10px rgba(0, 0, 255, 0.2);
}

.copyable {
    cursor: pointer;
    transition: color 0.3s;
    user-select: none;
}

.copyable:hover {
    color: #4a69bd;
}

.flash {
    animation: flash 1s;
}
@keyframes flash {
    0%, 100% { background-color: inherit; }
    50% { background-color: #00FF7F; }
}

.clickable {
    cursor: pointer;
    color: black;
    transition: color 0.3s;
}

.coordinates-table {
    width: 100%;
    border-collapse: collapse;
    margin-top: 10px;
    display: block;
    animation: fadeIn 0.5s;
}

.coordinates-table th, .coordinates-table td {
    border: 1px solid #ddd;
    padding: 8px;
    text-align: center;
}

.coordinates-table th {
    background-color: #f2f2f2;
}

#gridInfoPanel {
    position: absolute;
    bottom: 20px;
    left: 100px;
    background-color: rgba(255, 255, 255, 0.85);
    padding: 8px 12px;
    border-radius: 5px;
    font-size: 12px;
    box-shadow: 0 2px 5px rgba(0,0,0,0.2);
    z-index: 1000;
    display: flex;
    align-items: center;
    transition: opacity 0.3s;
    opacity: 0.8;
    color: royalblue;
}

#gridInfoPanel i {
    margin-right: 5px;
    color: royalblue;
}

#gridInfoPanel:hover {
    opacity: 1;
}

.section-title {
    background-color: #4a69bd;
    color: white;
    padding: 8px 12px;
    border-radius: 4px;
    margin-top: 15px;
    margin-bottom: 10px;
    font-weight: bold;
    position: relative;
    overflow: hidden;
}

.section-title::after {
    content: '';
    position: absolute;
    top: 0;
    left: -100%;
    width: 100%;
    height: 100%;
    background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
    animation: shine 2s infinite;
}

@keyframes shine {
    0% {
        left: -100%;
    }
    20% {
        left: 100%;
    }
    100% {
        left: 100%;
    }
}

#showCoordinatesBtn {
    margin-top: 15px;
    width: 100%;
    padding: 10px;
    background-color: #4a69bd;
    color: white;
    border: none;
    border-radius: 5px;
    cursor: pointer;
    transition: all 0.3s;
    display: flex;
    align-items: center;
    justify-content: center;
    box-shadow: 0 2px 4px rgba(0,0,0,0.2);
}

#showCoordinatesBtn:hover {
    background-color: #354f9e;
    transform: translateY(-2px);
    box-shadow: 0 4px 8px rgba(0,0,0,0.3);
}

#showCoordinatesBtn:active {
    transform: translateY(1px);
    box-shadow: 0 1px 2px rgba(0,0,0,0.2);
}

#showCoordinatesBtn i {
    margin-right: 8px;
}

.coordinates-table {
    width: 100%;
    border-collapse: collapse;
    margin-top: 15px;
    animation: fadeIn 0.3s ease;
}

@keyframes fadeIn {
    from { opacity: 0; transform: translateY(-10px); }
    to { opacity: 1; transform: translateY(0); }
}

#overlappingParcelsContainer {
    margin-top: 15px;
}

.panel-container {
    display: flex;
    flex-direction: column;
    height: 100%;
}

.panel-section {
    padding-bottom: 15px;
    border-bottom: 1px solid #ddd;
}

.panel-section:last-child {
    border-bottom: none;
}

.coordinate-row {
    cursor: pointer;
    transition: background-color 0.3s;
}

.coordinate-row:hover {
    background-color: #f0f8ff;
}

.coordinate-row.selected-coordinate {
    background-color: #ffebee !important;
    border-left: 3px solid #f44336;
    font-weight: bold;
}

#cursorInfoPanel {
    position: absolute;
    bottom: 20px;
    left: 250px;
    background-color: rgba(255, 255, 255, 0.85);
    padding: 8px 12px;
    border-radius: 5px;
    font-size: 12px;
    box-shadow: 0 2px 5px rgba(0,0,0,0.2);
    z-index: 1000;
    display: flex;
    align-items: center;
    pointer-events: none;
    transition: opacity 0.3s;
    opacity: 0.8;
    color: royalblue;
}

#cursorInfoPanel i {
    margin-right: 5px;
    color: royalblue;
}

#cursorInfoPanel:hover {
    opacity: 1;
}

#togglePointsBtn:hover {
    background-color: #c0392b;
    transform: scale(1.1);
    box-shadow: 0 6px 12px rgba(0, 0, 0, 0.3);
}

#togglePointsBtn:active {
    transform: scale(0.95);
}

#buildingsBtn:hover {
    background-color: #7f8c8d;
    transform: scale(1.1);
    box-shadow: 0 6px 12px rgba(0, 0, 0, 0.3);
}

#addObjectBtn {
    position: absolute;
    bottom: 20px;
    right: 20px;
    background-color: #4a69bd;
    color: white;
    border: none;
    padding: 10px;
    border-radius: 50%;
    cursor: pointer;
    transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
    width: 50px;
    height: 50px;
    font-size: 18px;
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 1000;
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
}

#togglePointsBtn {
    position: absolute;
    bottom: 80px;
    right: 20px;
    background-color: #e74c3c;
    color: white;
    border: none;
    padding: 10px;
    border-radius: 50%;
    cursor: pointer;
    transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
    width: 50px;
    height: 50px;
    font-size: 18px;
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 1000;
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
}

#rulerBtn {
    position: absolute;
    bottom: 140px;
    right: 20px;
    background-color: #3498db;
    color: white;
    border: none;
    padding: 10px;
    border-radius: 50%;
    cursor: pointer;
    transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
    width: 50px;
    height: 50px;
    font-size: 18px;
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 1000;
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
}

#buildingsBtn {
    position: absolute;
    bottom: 200px;
    right: 20px;
    background-color: #95a5a6;
    color: white;
    border: none;
    padding: 10px;
    border-radius: 50%;
    cursor: pointer;
    transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
    width: 50px;
    height: 50px;
    font-size: 18px;
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 1000;
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
}


#zonesBtn { /* New button for zones */
    position: absolute;
    bottom: 260px; /* Position above buildingsBtn */
    right: 20px;
    background-color: #f39c12; /* Orange color for zones */
    color: white;
    border: none;
    padding: 10px;
    border-radius: 50%;
    cursor: pointer;
    transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
    width: 50px;
    height: 50px;
    font-size: 18px;
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 1000;
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
}
#zonesBtn:hover {
    background-color: #e67e22; /* Darker orange on hover */
    transform: scale(1.1);
    box-shadow: 0 6px 12px rgba(0, 0, 0, 0.3);
}
#zonesBtn:active {
    transform: scale(0.95);
}
#zonesBtn.active {
    background-color: #d35400; /* Darker orange when active */
}


#buildingsBtn:active {
    transform: scale(0.95);
}

#buildingsBtn.active {
    background-color: #3498db;
}

#rulerBtn:hover {
    background-color: #2980b9;
    transform: scale(1.1);
    box-shadow: 0 6px 12px rgba(0, 0, 0, 0.3);
}

#rulerBtn:active {
    transform: scale(0.95);
}

#rulerBtn.active {
    background-color: #27ae60;
}

#measurementPanel {
    position: absolute;
    bottom: 20px;
    left: 40px;
    background-color: rgba(255, 255, 255, 0.9);
    padding: 10px 15px;
    border-radius: 5px;
    box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
    font-size: 14px;
    max-width: 300px;
    display: none;
    z-index: 1100;
}

#measurementPanel.active {
    display: block;
    animation: fadeIn 0.3s;
}

.measurement-title {
    font-weight: bold;
    margin-bottom: 8px;
    color: #2c3e50;
    display: flex;
    align-items: center;
}

.measurement-title i {
    margin-right: 5px;
    color: #3498db;
}

.measurement-coordinates {
    margin-bottom: 8px;
    padding-left: 10px;
    border-left: 3px solid #3498db;
    font-family: monospace;
}

.measurement-distance {
    font-weight: bold;
    color: #e74c3c;
    font-size: 16px;
    text-align: center;
    margin-top: 8px;
    padding: 5px;
    background-color: rgba(231, 76, 60, 0.1);
    border-radius: 3px;
}

#resetMeasurementBtn {
    background-color: #3498db;
    color: white;
    border: none;
    padding: 5px 10px;
    border-radius: 3px;
    margin-top: 8px;
    cursor: pointer;
    width: 100%;
    transition: background-color 0.3s;
}

#resetMeasurementBtn:hover {
    background-color: #2980b9;
}

#loaderContainer {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(173, 216, 230, 0.9);
    display: none;
    justify-content: center;
    align-items: center;
    z-index: 10000;
    backdrop-filter: blur(3px);
    flex-direction: column;
}

.spinner-container {
    width: 80px;
    height: 80px;
    position: relative;
}

.spinner-ring {
    position: absolute;
    width: 100%;
    height: 100%;
    border-radius: 50%;
    border: 6px solid transparent;
    border-top-color: #3498db;
    animation: spin 1.2s cubic-bezier(0.5, 0, 0.5, 1) infinite;
    box-sizing: border-box;
}

.spinner-ring:before,
.spinner-ring:after {
    content: '';
    position: absolute;
    border-radius: 50%;
    border: 6px solid transparent;
    box-sizing: border-box;
}

.spinner-ring:before {
    top: -6px;
    left: -6px;
    right: -6px;
    bottom: -6px;
    border-top-color: #2980b9;
    animation: spin 2s cubic-bezier(0.5, 0, 0.5, 1) infinite;
}

.spinner-ring:after {
    top: 6px;
    left: 6px;
    right: 6px;
    bottom: 6px;
    border-top-color: #6ab7e2;
    animation: spin 0.8s cubic-bezier(0.5, 0, 0.5, 1) infinite;
}

@keyframes spin {
    0% {
        transform: rotate(0deg);
    }
    100% {
        transform: rotate(360deg);
    }
}

.loading-text {
    color: #2c3e50;
    font-size: 18px;
    font-weight: bold;
    margin-top: 30px;
    letter-spacing: 1px;
    text-shadow: 0 1px 2px rgba(255, 255, 255, 0.5);
    animation: pulse 1.5s ease infinite;
    text-align: center;
    line-height: 1.5;
    min-height: 50px;
}

@keyframes pulse {
    0%, 100% { opacity: 0.7; }
    50% { opacity: 1; }
}

#listBtn {
    position: absolute;
    bottom: 320px; /* Adjusted to accommodate zonesBtn */
    right: 20px;
    background-color: #9b59b6;
    color: white;
    border: none;
    padding: 10px;
    border-radius: 50%;
    cursor: pointer;
    transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
    width: 50px;
    height: 50px;
    font-size: 18px;
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 1000;
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
}

#listBtn:hover {
    background-color: #8e44ad;
    transform: scale(1.1);
    box-shadow: 0 6px 12px rgba(0, 0, 0, 0.3);
}

#listBtn:active {
    transform: scale(0.95);
}

#listDialog {
    display: none;
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: 600px;
    max-width: 90vw;
    height: 70vh;
    background-color: white;
    border-radius: 10px;
    box-shadow: 0 4px 25px rgba(0, 0, 0, 0.3);
    z-index: 2001;
    flex-direction: column;
    animation: fadeInScale 0.3s ease-out;
}

.list-dialog-content {
    flex: 1;
    display: flex;
    flex-direction: column;
    overflow: hidden;
}

@keyframes fadeInScale {
    0% { opacity: 0; transform: translate(-50%, -50%) scale(0.9); }
    100% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
}

.list-dialog-header {
    padding: 15px 20px;
    border-bottom: 1px solid #eee;
    display: flex;
    justify-content: space-between;
    align-items: center;
}

.list-dialog-header h3 {
    margin: 0;
    color: #2c3e50;
    font-size: 18px;
}

.close-btn {
    background: none;
    border: none;
    color: #7f8c8d;
    font-size: 20px;
    cursor: pointer;
    transition: color 0.3s;
}

.close-btn:hover {
    color: #e74c3c;
}

.list-dialog-content {
    flex: 1;
    display: flex;
    flex-direction: column;
    overflow: hidden;
    padding: 0;
}

.search-container {
    padding: 15px;
    position: relative;
    border-bottom: 1px solid #eee;
}

#searchInput {
    width: 90%;
    padding: 10px 35px 10px 15px;
    border: 1px solid #ddd;
    border-radius: 5px;
    font-size: 14px;
    transition: border-color 0.3s;
}

#searchInput:focus {
    border-color: #9b59b6;
    outline: none;
    box-shadow: 0 0 5px rgba(155, 89, 182, 0.3);
}

#clearSearchBtn {
    position: absolute;
    right: 25px;
    top: 50%;
    transform: translateY(-50%);
    background: none;
    border: none;
    color: #aaa;
    cursor: pointer;
    font-size: 14px;
    display: none;
}

#clearSearchBtn:hover {
    color: #e74c3c;
}

.list-tabs {
    display: flex;
    border-bottom: 1px solid #eee;
}

.tab-btn {
    flex: 1;
    padding: 12px;
    background: none;
    border: none;
    border-bottom: 3px solid transparent;
    cursor: pointer;
    font-size: 14px;
    color: #7f8c8d;
    transition: all 0.3s;
}

.tab-btn.active {
    color: #9b59b6;
    border-bottom-color: #9b59b6;
    font-weight: bold;
}

.tab-btn:hover:not(.active) {
    background-color: #f9f9f9;
    color: #2c3e50;
}

.tab-content {
    display: none;
    flex: 1;
    overflow: hidden;
}

.tab-content.active {
    display: flex;
    flex-direction: column;
}

.list-container {
    flex: 1;
    overflow-y: auto;
    padding: 10px;
}

.list-item {
    padding: 12px 15px;
    border-bottom: 1px solid #eee;
    cursor: pointer;
    transition: background-color 0.2s, transform 0.2s;
    display: flex;
    justify-content: space-between;
    align-items: center;
}

.list-item:hover {
    background-color: #f5f8fa;
}

.list-item.selected {
    background-color: #e8f0fe;
    border-left: 3px solid #9b59b6;
    font-weight: bold;
}

.list-item-number {
    font-weight: normal;
    color: #2c3e50;
}

.list-item-type {
    font-size: 12px;
    color: #7f8c8d;
    margin-left: 10px;
    background-color: #f0f0f0;
    padding: 3px 6px;
    border-radius: 3px;
}

.list-item-actions {
    display: flex;
    gap: 5px;
    opacity: 0;
    transition: opacity 0.2s;
}

.list-item:hover .list-item-actions {
    opacity: 1;
}

.list-action-btn {
    background: none;
    border: none;
    color: #7f8c8d;
    cursor: pointer;
    padding: 3px;
    border-radius: 3px;
    transition: all 0.2s;
}

.list-action-btn:hover {
    background-color: #eee;
    color: #2c3e50;
}

.list-action-btn.copy:hover {
    color: #3498db;
}

.list-action-btn.center:hover {
    color: #27ae60;
}

.empty-list {
    padding: 40px 20px;
    text-align: center;
    color: #7f8c8d;
    font-style: italic;
}

.count-badge {
    display: inline-block;
    background-color: #9b59b6;
    color: white;
    padding: 2px 8px;
    border-radius: 10px;
    font-size: 12px;
    margin-left: 10px;
}

.list-action-btn.map:hover {
    color: #3498db;
}

.list-action-btn.coords:hover {
    color: #9b59b6;
}

.list-dialog-footer {
    display: flex;
    justify-content: space-around;
    padding: 12px 15px;
    border-top: 1px solid #eee;
    background-color: #f9f9f9;
    border-radius: 0 0 10px 10px;
}

.list-footer-btn {
    display: flex;
    align-items: center;
    justify-content: center;
    background-color: #fff;
    border: 1px solid #ddd;
    padding: 8px 12px;
    border-radius: 5px;
    cursor: pointer;
    color: #2c3e50;
    transition: all 0.2s;
    font-size: 14px;
}

.list-footer-btn:hover {
    background-color: #f0f0f0;
    border-color: #bbb;
    transform: translateY(-2px);
    box-shadow: 0 2px 5px rgba(0,0,0,0.1);
}

.list-footer-btn:active {
    transform: translateY(0);
}

.list-footer-btn i {
    margin-right: 8px;
    font-size: 16px;
}

#saveListBtn i {
    color: #27ae60;
}

#saveCoordsBtn i {
    color: #e67e22;
}

#openAllOnMapBtn i {
    color: #3498db;
}

#openOnMapBtn {
    margin-top: 10px;
    width: 100%;
    padding: 10px;
    background-color: #3498db;
    color: white;
    border: none;
    border-radius: 5px;
    cursor: pointer;
    transition: all 0.3s;
    display: flex;
    align-items: center;
    justify-content: center;
    box-shadow: 0 2px 4px rgba(0,0,0,0.2);
}

#openOnMapBtn:hover {
    background-color: #2980b9;
    transform: translateY(-2px);
    box-shadow: 0 4px 8px rgba(0,0,0,0.3);
}

#openOnMapBtn:active {
    transform: translateY(1px);
    box-shadow: 0 1px 2px rgba(0,0,0,0.2);
}

#openOnMapBtn i {
    margin-right: 8px;
}

#showCoordinatesBtn {
    margin-bottom: 10px;
}

#openAllOnSchemeBtn i {
    color: #e67e22;
}

.button-row {
    display: flex;
    align-items: stretch;
    gap: 5px;
    width: 100%;
    justify-content: center;
}

#fileInputLabel {
    flex-grow: 1;
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 10px 20px;
    box-sizing: border-box;
}

.button-small-icon {
    padding: 10px;
    width: auto;
    min-width: 40px;
    flex-grow: 0;
    flex-shrink: 0;
    background-color: #4CAF50;
    display: flex;
    align-items: center;
    justify-content: center;
    box-sizing: border-box;
}

.button-small-icon:hover {
    background-color: #45a049;
    transform: translateY(-2px);
    box-shadow: 0 4px 8px rgba(0,0,0,0.3);
}

.button-small-icon:active {
    transform: translateY(1px);
    box-shadow: 0 1px 3px rgba(0,0,0,0.2);
}

.button-small-icon i {
    margin-right: 0;
    font-size: 16px;
}

#fileInputLabel:hover {
    background-color: #45a049;
    transform: translateY(-2px);
    box-shadow: 0 4px 8px rgba(0,0,0,0.3);
}

#fileInputLabel:active {
    transform: translateY(1px);
    box-shadow: 0 1px 3px rgba(0,0,0,0.2);
}

.list-item-selectable {}

.list-item-selection {
    display: flex;
    align-items: center;
    flex-grow: 1;
}

.list-item-selection input[type="checkbox"] {
    margin-right: 10px;
    cursor: pointer;
}

.list-item-selection label {
    cursor: pointer;
    display: flex;
    align-items: center;
    flex-grow: 1;
}

.list-item-selection label .list-item-number {}
.list-item-selection label .list-item-type {
   margin-left: 8px;
}

.list-item-selectable .list-item-actions {
    display: none !important;
}

#copyCoordsBtn {
    margin-top: 10px;
    width: 100%;
    padding: 10px;
    background-color: #f39c12;
    color: white;
    border: none;
    border-radius: 5px;
    cursor: pointer;
    transition: all 0.3s;
    display: flex;
    align-items: center;
    justify-content: center;
    box-shadow: 0 2px 4px rgba(0,0,0,0.2);
}

#copyCoordsBtn:hover {
    background-color: #e67e22;
    transform: translateY(-2px);
    box-shadow: 0 4px 8px rgba(0,0,0,0.3);
}

#copyCoordsBtn:active {
    transform: translateY(1px);
    box-shadow: 0 1px 2px rgba(0,0,0,0.2);
}

#copyCoordsBtn i {
    margin-right: 8px;
}

#openSchemeBtn {
    margin-bottom: 10px;
}
#openOnMapBtn {
    margin-bottom: 10px;
}
#showCoordinatesBtn {
    margin-bottom: 10px;
}

#quarterSelectDialog {}

#quarterSelectDialog .list-dialog-content {
     padding: 15px;
     display: flex;
     flex-direction: column;
}

#quarterFileList {
    display: flex;
    flex-direction: column;
    gap: 10px;
    width: 100%;
}

.quarter-list-item {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 10px 12px;
    border: 1px solid #e0e0e0;
    border-radius: 6px;
    transition: background-color 0.2s ease-in-out;
    background-color: #fff;
}

.quarter-list-item:hover {
    background-color: #f5f7fa;
}

.quarter-file-name {
    flex-grow: 1;
    margin-right: 15px;
    font-size: 14px;
    color: #2c3e50;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
}

.quarter-item-actions {
    display: flex;
    gap: 8px;
    flex-shrink: 0;
}

.button.icon-button {
    padding: 8px 10px;
    font-size: 14px;
    line-height: 1;
    border: none;
    border-radius: 5px;
    cursor: pointer;
    transition: background-color 0.2s, transform 0.1s;
    color: white;
    display: inline-flex;
    align-items: center;
    justify-content: center;
}

.button.icon-button:hover {
    transform: translateY(-1px);
}
.button.icon-button:active {
     transform: translateY(0px);
}

.open-kpt-btn {
    background-color: #2ecc71;
}
.open-kpt-btn:hover {
    background-color: #27ae60;
}

.download-kpt-btn {
    background-color: #3498db;
}
.download-kpt-btn:hover {
    background-color: #2980b9;
}

#quarterDialogStatus {
    margin-top: 15px;
    text-align: center;
    color: grey;
    font-style: italic;
    font-size: 13px;
    height: 1.5em;
}

#fileInfoPanel {
    background-color: rgba(255, 255, 255, 0.85);
    padding: 8px 12px;
    border-radius: 5px;
    font-size: 12px;
    box-shadow: 0 -2px 5px rgba(0,0,0,0.1);
    display: flex;
    align-items: center;
    transition: opacity 0.3s;
    opacity: 0.8;
    color: royalblue;
    margin-top: 15px;
    border-top: 1px solid #ddd;
}

#fileInfoPanel i {
    margin-right: 8px;
    color: royalblue;
}

#fileInfoPanel:hover {
    opacity: 1;
}

#fileDetailsText {
    font-weight: normal;
}


/* Zone Selection Dialog Specific Styles */
#zoneSelectionListContainer .list-item {
    display: flex;
    align-items: center;
    padding: 10px 12px;
    border-bottom: 1px solid #f0f0f0;
    cursor: pointer;
    transition: background-color 0.2s;
}
#zoneSelectionListContainer .list-item:hover {
    background-color: #f5f8fa;
}
#zoneSelectionListContainer .list-item input[type="checkbox"] {
    margin-right: 12px;
    cursor: pointer;
    transform: scale(1.1);
}
#zoneSelectionListContainer .list-item label { /* Used for the text part if you wrap it */
    flex-grow: 1;
    display: flex;
    flex-direction: column; /* For two lines of text */
    cursor: pointer;
}
#zoneSelectionListContainer .list-item-name { /* For RegNumbBorder */
    font-weight: 500;
    color: #2c3e50;
}
#zoneSelectionListContainer .list-item-type { /* For TypeZoneValue */
    font-size: 0.85em;
    color: #7f8c8d;
    margin-top: 2px;
}
#zoneSelectionDialog .empty-list {
    padding: 30px 20px;
    text-align: center;
    color: #7f8c8d;
    font-style: italic;
}

/* Ensure footer buttons are styled (can reuse .list-footer-btn if already defined well) */
#zoneSelectionDialog .list-dialog-footer .list-footer-btn {
    padding: 8px 15px;
    font-size: 14px;
    border-radius: 5px;
    cursor: pointer;
    transition: all 0.2s;
}
#zoneSelectionDialog .list-dialog-footer .list-footer-btn:hover {
    opacity: 0.85;
    transform: translateY(-1px);
}

#geoeditorDialog {
    display: none;
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%) scale(0.95); /* Initial smaller scale */
    width: 350px; /* Adjusted width */
    background-color: white;
    border-radius: 10px;
    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.25);
    z-index: 2010; /* Ensure it's high */
    padding: 25px;
    opacity: 0;
    transition: opacity 0.25s ease-out, transform 0.25s ease-out; /* Smoother transition */
    text-align: center;
}
#geoeditorDialog.show {
    opacity: 1;
    transform: translate(-50%, -50%) scale(1); /* Scale to full size */
}
#geoeditorDialog h3 {
    margin: 0 0 20px;
    font-size: 20px;
    color: #2c3e50;
}
.geoeditor-buttons {
    display: flex;
    flex-direction: column; /* Stack buttons vertically */
    gap: 12px; /* Space between buttons */
}
.geoeditor-buttons .button { /* Re-use .button style but make it full width */
    width: 100%;
    box-sizing: border-box; /* Ensure padding doesn't expand width */
}

.button-row-flex {
    display: flex;
    gap: 5px; /* Consistent with other button-row */
    margin-top: 10px; /* Spacing for the row */
}

.button-row-flex .button {
    flex: 1; /* Distribute space equally */
    margin-top: 0 !important; /* Remove individual top margin */
}


.json-filters {
    display: flex;
    gap: 8px;
    align-items: center;
    margin-left: 10px; /* Space from filename */
    font-size: 13px;
    flex-shrink: 0; /* CRITICAL: Prevent filters container from shrinking */
    /* overflow: hidden; /* Remove if previously set here */
    /* white-space: nowrap; /* Remove if previously set here */
}

.json-filters label {
    display: flex;
    align-items: center;
    cursor: pointer;
    padding: 3px 5px;
    border-radius: 3px;
    transition: background-color 0.2s;
    user-select: none;
    white-space: nowrap; /* Ensure label text (e.g., "Сооруж.") does not wrap */
}

.json-filters input[type="checkbox"] {
    margin-right: 4px;
    vertical-align: middle;
}

.quarter-list-item .quarter-file-name {
    flex-grow: 1; /* Allows filename to take available space */
    flex-shrink: 1; /* Allows filename to shrink when space is limited */
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
    margin-right: 10px; /* Space before filters or action buttons */
    min-width: 50px; /* A small minimum width for the filename before it's completely hidden */
    /* title attribute on fileNameSpan in JS will show full name on hover */
}

/* Ensure quarter-list-item itself is a flex container (it should be already) */
.quarter-list-item {
    display: flex;
    justify-content: space-between; /* This helps position filename/filters and actions */
    align-items: center;
    padding: 10px 12px;
    border: 1px solid #e0e0e0;
    border-radius: 6px;
    transition: background-color 0.2s ease-in-out;
    background-color: #fff;
}
.quarter-list-item:hover {
    background-color: #f5f7fa;
}

.quarter-item-actions {
    flex-shrink: 0; /* Prevent action buttons from shrinking */
    display: flex; /* If not already, to ensure buttons align nicely */
    gap: 8px; /* If not already, for spacing between buttons */
}


    </style>
</head>
<body>

<div id="infoPanel">
    <div class="panel-section">
        <div class="file-input-wrapper">
            <div class="button-row">
                <label for="fileInput" id="fileInputLabel" class="button">
                    <i class="fas fa-file-import"></i> Открыть XML
                </label>
                <input type="file" id="fileInput" accept=".xml,.zip">
                <button id="openAndSelectBtn" class="button button-small-icon" title="Открыть и выбрать">
                        <i class="fas fa-filter"></i>
                </button>
                  <button id="uploadKptBtn" class="button button-small-icon" title="Загрузить КПТ в базу данных">
                        <i class="fas fa-upload"></i>
                </button>
            </div>
        </div>
    </div>

    <div class="panel-section">
        <div id="selectedParcelInfo">
        </div>
        <div id="coordinatesTableContainer">
        </div>
    </div>

    <div class="panel-section">
     <div class="section-title" style="display: none;">
        <i class="fas fa-exchange-alt"></i> Пересечения
        </div>
        <div id="overlappingParcelsContainer">
            <ul id="overlappingParcelsList">
            </ul>
        </div>
    </div>

    <div class="panel-section">
        <div id="fileInfoPanel" style="display: none;">
            <i class="fas fa-file-alt"></i>
            <span id="fileDetailsText"></span>
        </div>
    </div>

</div>

<div id="kptSchemeContainer">
    <canvas id="kptSchemeCanvas"></canvas>
    <button id="addObjectBtn" class="button" title="Добавить объект">
        <i class="fas fa-thumbtack"></i>
    </button>
    <button id="togglePointsBtn" class="button" title="Показать/скрыть точки">
        <i class="fas fa-map-marker-alt"></i>
    </button>
    <!-- listBtn position might need adjustment if zonesBtn is visually disruptive -->
    <button id="listBtn" class="button" title="Список объектов">
        <i class="fas fa-list"></i>
    </button>
    <!-- NEW BUTTON FOR ZONES -->
    <button id="zonesBtn" class="button" title="Показать/скрыть Зоны/ЗОУИТ">
        <i class="fas fa-layer-group"></i> <!-- Example icon, choose appropriate -->
    </button>
    <button id="buildingsBtn" class="button" title="Показать/скрыть ОКС">
        <i class="fas fa-home"></i>
    </button>
    <button id="rulerBtn" class="button" title="Измерить расстояние">
        <i class="fas fa-ruler"></i>
    </button>

<div id="measurementPanel">
    <div class="measurement-title">
        <i class="fas fa-ruler"></i> Измерение расстояния
    </div>
    <div class="measurement-coordinates" id="measurementCoordinates">
        Точка 1: Выберите на карте<br>
        Точка 2: Выберите на карте
    </div>
    <div class="measurement-distance" id="measurementDistance">
        Расстояние: -
    </div>
    <button id="resetMeasurementBtn">Сбросить</button>
</div>

    <div id="gridInfoPanel">
        <i class="fas fa-th"></i>
        <span id="gridStepText"></span>
    </div>
    

<div id="cursorInfoPanel">
    <i class="fas fa-mouse-pointer"></i>
    <span id="cursorCoordinates">X: 0.00, Y: 0.00</span>
</div>

</div>
<div id="output" style="display: none;"></div>

<div id="tooltip"></div>

<div id="dialogOverlay"></div>
<div id="coordsDialog">
    <h3>Добавить объект</h3>
    <textarea id="coordsInput" placeholder="Вставьте координаты..."></textarea>
    <div class="dialog-buttons">
        <button id="importCoordsBtn" class="button">
            <i class="fas fa-map-marker-alt"></i> Добавить на карту
        </button>
        <button id="importFromFileBtn" class="button">
            <i class="fas fa-file-upload"></i> Открыть файл
        </button>
        <button id="closeDialogBtn" class="button">
            <i class="fas fa-times"></i> Закрыть
        </button>
    </div>
</div>

<div id="loaderContainer">
  <div class="spinner-container">
    <div class="spinner-ring"></div>
  </div>
  <div class="loading-text"></div>
</div>


<div id="listDialog">
    <div class="list-dialog-header">
        <h3>Список объектов</h3> <!-- Changed title slightly -->
        <button id="closeListBtn" class="close-btn"><i class="fas fa-times"></i></button>
    </div>
    <div class="list-dialog-content">
        <div class="search-container">
            <input type="text" id="searchInput" placeholder="Поиск...">
            <button id="clearSearchBtn"><i class="fas fa-times-circle"></i></button>
        </div>
        <div class="list-tabs">
            <button class="tab-btn active" data-tab="parcels">Земельные участки</button>
            <button class="tab-btn" data-tab="buildings">ОКС</button>
            <!-- NEW TAB FOR ZONES -->
            <button class="tab-btn" data-tab="zones">Зоны</button>
        </div>
        <div class="tab-content active" id="parcelsTab">
            <div class="list-container" id="parcelsList"></div>
        </div>
        <div class="tab-content" id="buildingsTab">
            <div class="list-container" id="buildingsList"></div>
        </div>
        <!-- NEW TAB CONTENT FOR ZONES -->
        <div class="tab-content" id="zonesTab">
            <div class="list-container" id="zonesListContainer"></div> <!-- Changed id -->
        </div>
    </div>
    <div class="list-dialog-footer">
        <button id="saveListBtn" class="list-footer-btn" title="Сохранить список номеров">
            <i class="fas fa-file-csv"></i>
            <span>Сохранить список</span>
        </button>
        <button id="saveCoordsBtn" class="list-footer-btn" title="Сохранить координаты в CSV">
            <i class="fas fa-file-export"></i>
            <span>Сохранить координаты</span>
        </button>
        <button id="openAllOnMapBtn" class="list-footer-btn" title="Открыть на карте (МСК16 1/2)">
            <i class="fas fa-map-marked-alt"></i>
            <span>Карта</span>
        </button>
        <button id="openAllOnSchemeBtn" class="list-footer-btn" title="Открыть Cхему">
            <i class="fas fa-project-diagram"></i>
            <span>Схема</span>
        </button>
    </div>
</div>

<div id="quarterSelectDialogOverlay" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.6); z-index: 2002; backdrop-filter: blur(3px);"></div>
<div id="quarterSelectDialog" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 500px; max-width: 90vw; max-height: 80vh; background-color: white; border-radius: 10px; box-shadow: 0 5px 20px rgba(0, 0, 0, 0.3); z-index: 2003; flex-direction: column; animation: fadeInScale 0.3s ease-out;">
    <div class="list-dialog-header" style="border-bottom: 1px solid #eee; padding: 15px 20px;">
        <h3 id="quarterDialogTitle" style="margin: 0; color: #2c3e50; font-size: 18px;">Найденные КПТ</h3>
        <button id="closeQuarterDialogBtn" class="close-btn" style="font-size: 22px;"><i class="fas fa-times"></i></button>
    </div>
    <div class="list-dialog-content" style="flex: 1; overflow-y: auto; padding: 15px;">
        <div id="quarterFileList" style="display: flex; flex-direction: column; gap: 10px;">
        </div>
         <div id="quarterDialogStatus" style="margin-top: 15px; text-align: center; color: grey; font-style: italic;"></div>
    </div>
</div>

<div id="objectSelectionDialogOverlay" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.6); z-index: 2004; backdrop-filter: blur(3px);"></div>
<div id="objectSelectionDialog" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 450px; max-width: 90vw; background-color: white; border-radius: 10px; box-shadow: 0 5px 20px rgba(0, 0, 0, 0.3); z-index: 2005; flex-direction: column; animation: fadeInScale 0.3s ease-out;">
    <div class="list-dialog-header" style="border-bottom: 1px solid #eee; padding: 15px 20px;">
        <h3 id="selectionDialogTitle" style="margin: 0; color: #2c3e50; font-size: 18px;">Выберите объект</h3>
        <button id="closeSelectionDialogBtn" class="close-btn" style="font-size: 22px;"><i class="fas fa-times"></i></button>
    </div>
    <div class="list-dialog-content" style="flex-grow: 1; overflow-y: auto; padding: 0;">
        <div id="selectableObjectsList" class="list-container" style="padding: 10px 0;">
            <!-- Список объектов для выбора будет вставлен сюда -->
            <!-- Пример элемента:
            <div class="list-item" data-type="parcel" data-identifier="16:XX:XXXXXX:YY">
                <span class="list-item-number">ЗУ: 16:XX:XXXXXX:YY</span>
            </div>
             -->
        </div>
    </div>
    <div id="selectionDialogStatus" style="padding: 10px 20px; text-align: center; color: grey; font-style: italic; font-size: 13px; border-top: 1px solid #eee;">
        Кликните для выбора
    </div>
</div>

<!-- Zone Selection Dialog -->
<div id="zoneSelectionDialogOverlay" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.6); z-index: 2006; backdrop-filter: blur(3px);"></div>
<div id="zoneSelectionDialog" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 550px; max-width: 90vw; max-height: 80vh; background-color: white; border-radius: 10px; box-shadow: 0 5px 20px rgba(0, 0, 0, 0.3); z-index: 2007; flex-direction: column; animation: fadeInScale 0.3s ease-out;">
    <div class="list-dialog-header" style="border-bottom: 1px solid #eee; padding: 15px 20px;">
        <h3 style="margin: 0; color: #2c3e50; font-size: 18px;">Выберите Зоны/ЗОУИТ для отображения</h3>
        <button id="closeZoneSelectionDialogBtn" class="close-btn" style="font-size: 22px;"><i class="fas fa-times"></i></button>
    </div>
    <div class="list-dialog-content" style="flex: 1; display: flex; flex-direction: column; overflow: hidden; padding:0;">
        <div class="search-container" style="padding: 10px 15px; border-bottom: 1px solid #eee;">
            <input type="text" id="zoneSearchInput" placeholder="Поиск по номеру или типу..." style="width: calc(100% - 40px); padding: 8px 10px; border: 1px solid #ddd; border-radius: 5px;">
            <button id="clearZoneSearchBtn" style="position: absolute; right: 20px; top: 50%; transform: translateY(-50%); background: none; border: none; color: #aaa; cursor: pointer; font-size: 14px; display: none;"><i class="fas fa-times-circle"></i></button>
        </div>
        <div class="list-container" id="zoneSelectionListContainer" style="flex: 1; overflow-y: auto; padding: 10px;">
            <!-- Zone items will be populated here -->
        </div>
    </div>
    <div class="list-dialog-footer" style="display: flex; justify-content: space-between; padding: 12px 15px; border-top: 1px solid #eee; background-color: #f9f9f9;">
        <div>
            <button id="zoneSelectAllBtn" class="list-footer-btn" style="margin-right: 10px;">Выделить все</button>
            <button id="zoneDeselectAllBtn" class="list-footer-btn">Снять все</button>
        </div>
        <div>
            <button id="zoneCancelSelectionBtn" class="list-footer-btn" style="background-color: #e74c3c; color: white; border-color: #d43f3a; margin-right:10px">Отмена</button>
            <button id="zoneApplySelectionBtn" class="list-footer-btn" style="background-color: #27ae60; color: white; border-color: #25a25a;">Применить</button>
        </div>
    </div>
</div>

<!-- Geoeditor Dialog -->
<div id="geoeditorDialogOverlay" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.6); z-index: 2009; backdrop-filter: blur(3px);"></div>
<div id="geoeditorDialog" style="z-index: 2010;"> <!-- z-index добавлен здесь -->
    <h3><i class="fas fa-drafting-compass" style="margin-right: 10px;"></i>Георедактор</h3>
    <div class="geoeditor-buttons">
        <button id="geoeditorSelectedBtn" class="button"><i class="fas fa-object-ungroup"></i> Выбранный объект</button>
        <button id="geoeditorAdjacentBtn" class="button"><i class="fas fa-vector-square"></i> Смежные участки</button>
        <button id="geoeditorAllVisibleBtn" class="button"><i class="fas fa-layer-group"></i> Все видимые объекты</button>
    </div>
    <button id="closeGeoeditorDialogBtn" class="button" style="background-color: #dc3545; margin-top: 20px; width: 100%;">
        <i class="fas fa-times"></i> Закрыть
    </button>
</div>

   <script>
    let allContours = [];
    let scale = 1;
    let offsetX = 0;
    let offsetY = 0;
    let isDragging = false;
    let startX, startY;
    let selectedCadastralNumber = null;
    let importedContours = [];
    let minX, minY, maxX, maxY;
    let selectedPoints = [];

    let lastOffsetX = 0;
    let lastOffsetY = 0;

    let filteredParcels = [];
    let filteredBuildings = [];
    let filteredZones = []; // New: For filtered zones/ZOUITs
    let commonLandLinksMap = {};

    let isSelectiveLoadMode = false;
    let rawXmlContentForSelection = null;
    let selectableNumbersCache = [];

    let isGridVisible = true;
    let highlightedIsolatedParcels = new Set();
    let selectedImportedObjectIndex = -1;
    let showPoints = true;

    const savedShowPoints = localStorage.getItem('showPoints');
    if (savedShowPoints !== null) {
        showPoints = savedShowPoints === 'true';
    }

    const togglePointsBtn = document.getElementById('togglePointsBtn');
    if (togglePointsBtn) {
        togglePointsBtn.style.backgroundColor = showPoints ? '#e74c3c' : '#7f8c8d';
    }

    let rulerMode = false;
    let rulerPoints = [];
    let highlightImportedForScreenshot = false;

    let showBuildings = false;
    let buildingsContours = [];
    let selectedBuildingNumber = null;

    let showZones = false; // New: For toggling zone visibility
    let zonesAndTerritoriesContours = []; // New: To store zone/ZOUIT contours
    let selectedZoneOrTerritoryRegNumber = null; // New: To store selected zone/ZOUIT registration number

    let isDoubleClickMode = false;
    let isUnifiedLandUse = false;
    
      let visibleZoneRegNumbers = new Set();
    let initialZoneSelectionApplied = false; // To track if default selections have been applied once.
    
    let activeNotifications = []; // Array to keep track of currently displayed notifications
const NOTIFICATION_HEIGHT = 60; // Approximate height of a notification + margin
const NOTIFICATION_MARGIN_TOP = 10; // Margin between notifications

    const canvas = document.getElementById('kptSchemeCanvas'); // Define canvas globally

    const transformCoord = (x, y) => {
        // Ensure canvas is defined before accessing its height
        if (!canvas) return [0,0]; // Or handle error appropriately
        return [
            offsetX + (y - minY) * scale,
            canvas.height - (offsetY + (x - minX) * scale)
        ];
    };

    const inverseTransformCoord = (canvasX, canvasY) => {
        // Ensure canvas is defined
        if (!canvas) return {x:0, y:0}; // Or handle error
        const y = minY + (canvasX - offsetX) / scale;
        const x = minX + (canvas.height - canvasY - offsetY) / scale;
        return { x: x, y: y };
    };

    function isCommonLandFormat(cadNumber) {
        if (!cadNumber) return false;
        const commonLandRegex = /^\d{2}:\d{2}:0{6,7}:\d+$/;
        return commonLandRegex.test(cadNumber);
    }
    
    const objectSelectionDialog = document.getElementById('objectSelectionDialog');
const objectSelectionDialogOverlay = document.getElementById('objectSelectionDialogOverlay');
const selectableObjectsList = document.getElementById('selectableObjectsList');
const closeSelectionDialogBtn = document.getElementById('closeSelectionDialogBtn');
const selectionDialogTitle = document.getElementById('selectionDialogTitle');

const STORAGE_API_URL = 'https://mapruapp.ru/storage';
const BUCKET_NAME = 'kpt';    
    
        // --- Geoeditor Dialog Logic ---
    const geoeditorDialog = document.getElementById('geoeditorDialog');
    const geoeditorDialogOverlay = document.getElementById('geoeditorDialogOverlay');
    const geoeditorSelectedBtn = document.getElementById('geoeditorSelectedBtn');
    const geoeditorAdjacentBtn = document.getElementById('geoeditorAdjacentBtn');
    const geoeditorAllVisibleBtn = document.getElementById('geoeditorAllVisibleBtn');
    const closeGeoeditorDialogBtn = document.getElementById('closeGeoeditorDialogBtn');

    function openGeoeditorDialog() {
        if (geoeditorDialog && geoeditorDialogOverlay) {
            geoeditorDialogOverlay.style.opacity = '0'; // Start overlay faded
            geoeditorDialogOverlay.style.display = 'block';

            geoeditorDialog.style.opacity = '0';
            geoeditorDialog.style.transform = 'translate(-50%, -50%) scale(0.95)'; // Start smaller
            geoeditorDialog.style.display = 'block';


            // Force a reflow, then apply target styles for transition
            void geoeditorDialog.offsetWidth; // Reflow

            geoeditorDialogOverlay.style.opacity = '1'; // Fade in overlay
            geoeditorDialog.style.opacity = '1';
            geoeditorDialog.style.transform = 'translate(-50%, -50%) scale(1)'; // Scale to full
        }
    }

    function closeGeoeditorDialog() {
        if (geoeditorDialog && geoeditorDialogOverlay) {
            geoeditorDialogOverlay.style.opacity = '0';
            geoeditorDialog.style.opacity = '0';
            geoeditorDialog.style.transform = 'translate(-50%, -50%) scale(0.95)';

            setTimeout(() => {
                geoeditorDialog.style.display = 'none';
                geoeditorDialogOverlay.style.display = 'none';
            }, 250); // Match transition duration from CSS
        }
    }

    if (closeGeoeditorDialogBtn) {
        closeGeoeditorDialogBtn.addEventListener('click', closeGeoeditorDialog);
    }
    if (geoeditorDialogOverlay) {
        geoeditorDialogOverlay.addEventListener('click', closeGeoeditorDialog);
    }
    if (geoeditorDialog) {
        geoeditorDialog.addEventListener('click', (e) => e.stopPropagation());
    }


    function formatCoordinatesForGeoeditor(objects) {
        let outputText = "";
        objects.forEach((obj, index) => {
            if (index > 0) {
                outputText += "\n\n"; // Two empty lines between objects
            }
            outputText += obj.identifier + "\n";
            obj.contours.forEach((contour, contourIndex) => {
                if (contourIndex > 0) {
                    outputText += "\n"; // One empty line between contours of the same object
                }
                contour.forEach(point => {
                    outputText += `${point.x.toFixed(2)}\t${point.y.toFixed(2)}\n`;
                });
            });
        });
        // Remove trailing newline if any
        if (outputText.endsWith("\n")) {
            outputText = outputText.slice(0, -1);
        }
        return outputText;
    }


    if (geoeditorSelectedBtn) {
        geoeditorSelectedBtn.addEventListener('click', function() {
            let selectedObject = null;
            let identifier = "";

            if (selectedCadastralNumber) {
                selectedObject = allContours.find(p => p.cadastralNumber === selectedCadastralNumber);
                identifier = selectedCadastralNumber;
            } else if (selectedBuildingNumber) {
                selectedObject = buildingsContours.find(b => b.cadastralNumber === selectedBuildingNumber);
                identifier = selectedBuildingNumber;
            } else if (selectedZoneOrTerritoryRegNumber) {
                selectedObject = zonesAndTerritoriesContours.find(z => z.regNumbBorder === selectedZoneOrTerritoryRegNumber);
                identifier = selectedZoneOrTerritoryRegNumber;
            } else if (selectedImportedObjectIndex !== -1) {
                const importedContour = importedContours[selectedImportedObjectIndex];
                 // For imported, the 'object' is just the contour array.
                 // We need to wrap it to match the structure expected by formatCoordinatesForGeoeditor
                if (importedContour) {
                    selectedObject = { contours: [importedContour] }; // Wrap it
                }
                identifier = `Объект #${selectedImportedObjectIndex + 1}`;
            }

            if (selectedObject) {
                const formattedText = formatCoordinatesForGeoeditor([{ identifier: identifier, contours: selectedObject.contours }]);
                copyToClipboard(formattedText);
                window.open('editor.html', '_blank');
                showNotification('Координаты выбранного объекта скопированы.', 'success', 'check-circle');
                closeGeoeditorDialog();
            } else {
                showNotification('Нет выбранного объекта для копирования.', 'warning', 'exclamation-triangle');
            }
        });
    }

    if (geoeditorAdjacentBtn) {
        geoeditorAdjacentBtn.addEventListener('click', function() {
            const objectsToCopy = [];
            let mainSelectedObject = null;
            let mainIdentifier = "";

            // 1. Get the main selected object
            if (selectedCadastralNumber) {
                mainSelectedObject = allContours.find(p => p.cadastralNumber === selectedCadastralNumber);
                mainIdentifier = selectedCadastralNumber;
            } else if (selectedBuildingNumber) {
                mainSelectedObject = buildingsContours.find(b => b.cadastralNumber === selectedBuildingNumber);
                mainIdentifier = selectedBuildingNumber;
            } else if (selectedZoneOrTerritoryRegNumber) {
                mainSelectedObject = zonesAndTerritoriesContours.find(z => z.regNumbBorder === selectedZoneOrTerritoryRegNumber);
                mainIdentifier = selectedZoneOrTerritoryRegNumber;
            } else if (selectedImportedObjectIndex !== -1) {
                const importedContour = importedContours[selectedImportedObjectIndex];
                if (importedContour) {
                     mainSelectedObject = { contours: [importedContour] };
                }
                mainIdentifier = `Объект #${selectedImportedObjectIndex + 1}`;
            }

            if (!mainSelectedObject) {
                showNotification('Сначала выберите основной объект.', 'warning', 'exclamation-triangle');
                return;
            }
            objectsToCopy.push({ identifier: mainIdentifier, contours: mainSelectedObject.contours });

            // 2. Find adjacent parcels (only KPT parcels can be adjacent in this logic)
            // This logic assumes adjacents are primarily KPT parcels.
            // If imported objects should also have adjacents, the logic in getAdjacentParcelsForImported would need to be used.
            const mainSelectedPointsFlat = mainSelectedObject.contours.flat();
            const adjacentCadNumbers = new Set();

            allContours.forEach(parcel => {
                if (parcel.cadastralNumber === mainIdentifier) return; // Skip self if it's a KPT parcel
                if (!parcel.contours) return;

                const parcelPointsFlat = parcel.contours.flat();
                for (const sp of mainSelectedPointsFlat) {
                    for (const pp of parcelPointsFlat) {
                        if (Math.abs(sp.x - pp.x) < 1e-6 && Math.abs(sp.y - pp.y) < 1e-6) {
                            adjacentCadNumbers.add(parcel.cadastralNumber);
                            break;
                        }
                    }
                    if (adjacentCadNumbers.has(parcel.cadastralNumber)) break;
                }
            });

            adjacentCadNumbers.forEach(adjCadNum => {
                const adjParcel = allContours.find(p => p.cadastralNumber === adjCadNum);
                if (adjParcel && adjParcel.contours) {
                    objectsToCopy.push({ identifier: adjParcel.cadastralNumber, contours: adjParcel.contours });
                }
            });


            if (objectsToCopy.length > 0) {
                const formattedText = formatCoordinatesForGeoeditor(objectsToCopy);
                copyToClipboard(formattedText);
                window.open('editor.html', '_blank');
                showNotification(`Координаты выбранного и ${adjacentCadNumbers.size} смежных скопированы.`, 'success', 'check-circle');
                closeGeoeditorDialog();
            } else {
                showNotification('Не найдено смежных участков для копирования.', 'info', 'info-circle');
            }
        });
    }

    if (geoeditorAllVisibleBtn) {
        geoeditorAllVisibleBtn.addEventListener('click', function() {
            const objectsToCopy = [];

            // 1. KPT Parcels
            allContours.forEach(parcel => {
                if (parcel.contours && parcel.contours.length > 0) {
                     objectsToCopy.push({ identifier: parcel.cadastralNumber, contours: parcel.contours });
                }
            });

            // 2. Imported Objects
            importedContours.forEach((contour, index) => {
                if (contour && contour.length > 0) {
                    objectsToCopy.push({ identifier: `Объект #${index + 1}`, contours: [contour] });
                }
            });

            // 3. Buildings (if visible)
            if (showBuildings) {
                buildingsContours.forEach(building => {
                    if (building.contours && building.contours.length > 0) {
                        objectsToCopy.push({ identifier: building.cadastralNumber, contours: building.contours });
                    }
                });
            }

            // 4. Zones (if visible and selected in zone dialog)
            if (showZones) {
                zonesAndTerritoriesContours.forEach(zone => {
                    if (visibleZoneRegNumbers.has(zone.regNumbBorder) && zone.contours && zone.contours.length > 0) {
                         objectsToCopy.push({ identifier: zone.regNumbBorder, contours: zone.contours });
                    }
                });
            }

            if (objectsToCopy.length > 0) {
                const formattedText = formatCoordinatesForGeoeditor(objectsToCopy);
                copyToClipboard(formattedText);
                window.open('editor.html', '_blank');
                showNotification(`Координаты ${objectsToCopy.length} видимых объектов скопированы.`, 'success', 'check-circle');
                closeGeoeditorDialog();
            } else {
                showNotification('Нет видимых объектов для копирования.', 'warning', 'exclamation-triangle');
            }
        });
    }

    // --- End Geoeditor Dialog Logic ---
    
function showObjectSelectionDialog(objects, clickX, clickY) {
    selectableObjectsList.innerHTML = ''; 

    if (!objects || objects.length === 0) {
        console.warn("showObjectSelectionDialog_called_with_no_objects");
        return;
    }

    selectionDialogTitle.textContent = `Объекты в точке (${clickX.toFixed(2)}, ${clickY.toFixed(2)})`;

    objects.forEach(obj => {
        const listItem = document.createElement('div');
        listItem.className = 'list-item';
        listItem.dataset.identifier = obj.identifier; 
        listItem.dataset.type = obj.type;

        let displayText = '';
        switch (obj.type) {
            case 'parcel':
                displayText = `ЗУ: ${obj.identifier}`;
                if (obj.parcelObject && obj.parcelObject.isDeclaredArea) displayText += " (декл.)";
                if (obj.parcelObject && obj.parcelObject.isIsolatedParcel) displayText += " (обособ.)";
                break;
            case 'building':
                displayText = `ОКС: ${obj.identifier}`;
                if (obj.buildingObject && obj.buildingObject.record) {
                    const bType = getElementValue(obj.buildingObject.record, 'object > common_data > type > value');
                    if (bType) displayText += ` (${bType.substring(0,15)})`;
                }
                break;
            case 'zone':
                let zoneTypeDisplay = '(Зона)';
                if (obj.zoneObject) {
                    if (obj.zoneObject.zoneSubType === 'quarter_boundary') {
                        zoneTypeDisplay = '(Граница квартала)';
                    } else if (obj.zoneObject.zoneSubType === 'municipal_boundary') {
                        zoneTypeDisplay = '(Муниципальное образо)';
                    } else if (obj.zoneObject.zoneSubType === 'inhabited_locality') {
                        zoneTypeDisplay = '(Населенный пункт)';
                    } else if (obj.zoneObject.typeZoneValue) {
                        zoneTypeDisplay = `(${obj.zoneObject.typeZoneValue.substring(0, 20)}...)`;
                    }
                }
                displayText = `Зона: ${obj.identifier} ${zoneTypeDisplay}`;
                break;
            default:
                displayText = `Объект: ${obj.identifier}`;
        }

        const numberSpan = document.createElement('span');
        numberSpan.className = 'list-item-number';
        numberSpan.textContent = displayText;
        listItem.appendChild(numberSpan);

        listItem.addEventListener('click', function() {
            const identifierToSelect = this.dataset.identifier;
            // --- ДОБАВЛЕНА СТРОКА ДЛЯ ЛОГИРОВАНИЯ ---
            console.log(`[DEBUG] Клик в диалоге. Выбран идентификатор: ${identifierToSelect}`);
            closeObjectSelectionDialog();
            findAndSelectByCadastralNumber(identifierToSelect);
        });
        
        selectableObjectsList.appendChild(listItem);
    });

    objectSelectionDialog.style.display = 'flex';
    objectSelectionDialogOverlay.style.display = 'block';
}

function closeObjectSelectionDialog() {
    // objectSelectionDialog.style.opacity = '0';
    // objectSelectionDialogOverlay.style.opacity = '0';
    // setTimeout(() => {
        objectSelectionDialog.style.display = 'none';
        objectSelectionDialogOverlay.style.display = 'none';
    // }, 300); // Соответствует transition-duration
}

if(closeSelectionDialogBtn) {
    closeSelectionDialogBtn.addEventListener('click', closeObjectSelectionDialog);
}
if(objectSelectionDialogOverlay) {
    objectSelectionDialogOverlay.addEventListener('click', closeObjectSelectionDialog);
}
if(objectSelectionDialog){
    objectSelectionDialog.addEventListener('click', (e) => e.stopPropagation());
}


    function extractBuildingCoordinatesFromXML(record) {
        const result = [];
        const contours = record.querySelectorAll("contour");
        if (contours.length > 0) {
            contours.forEach(contour => {
                const spatialElement = contour.querySelector("entity_spatial");
                if (spatialElement) {
                    const contourCoords = [];
                    const ordinates = spatialElement.querySelectorAll("ordinate");
                    for (let i = 0; i < ordinates.length; i++) {
                         const xElement = ordinates[i].querySelector("x");
                        const yElement = ordinates[i].querySelector("y");
                        if (xElement && yElement) {
                            const x = parseFloat(xElement.textContent);
                            const y = parseFloat(yElement.textContent);
                             if (!isNaN(x) && !isNaN(y)) {
                                contourCoords.push({ x, y });
                            }
                        }
                    }
                    if (contourCoords.length > 0) {
                        result.push(contourCoords);
                    }
                }
            });
        } else {
            const spatialElements = record.querySelectorAll("entity_spatial");
            spatialElements.forEach((spatialElement) => {
                const contourCoords = [];
                const ordinates = spatialElement.querySelectorAll("ordinate");
                for (let i = 0; i < ordinates.length; i++) {
                     const xElement = ordinates[i].querySelector("x");
                    const yElement = ordinates[i].querySelector("y");
                    if (xElement && yElement) {
                        const x = parseFloat(xElement.textContent);
                        const y = parseFloat(yElement.textContent);
                         if (!isNaN(x) && !isNaN(y)) {
                            contourCoords.push({ x, y });
                        }
                    }
                }
                if (contourCoords.length > 0) {
                    result.push(contourCoords);
                }
            });
        }
        return result;
    }

function extractBuildingData(buildingItemFromGlobalArray) { // buildingItemFromGlobalArray is an item from buildingsContours
    if (!buildingItemFromGlobalArray || !buildingItemFromGlobalArray.record) return null;

    if (buildingItemFromGlobalArray.isParsedFromJson) {
        const jsonDataItem = buildingItemFromGlobalArray.record; // .record holds the original JSON object
        let typeDisplay = jsonDataItem.type;
        if (jsonDataItem.type === 'building') typeDisplay = 'Здание (JSON)';
        else if (jsonDataItem.type === 'construction') typeDisplay = 'Сооружение (JSON)';

        return {
            cadNumber: jsonDataItem.id,
            objectType: typeDisplay,
            address: 'Нет данных',
            areaString: 'Нет данных',
            permittedUse: 'Нет данных',
            formattedCadastralValue: 'Нет данных',
            isBuilding: jsonDataItem.type === 'building',
            isConstruction: jsonDataItem.type === 'construction'
            // record: jsonDataItem // Keep for consistency if needed elsewhere, though not strictly necessary for display here
        };
    } else { // XML Path
        const record = buildingItemFromGlobalArray.record; // .record holds the XML Element
        const isBuildRecord = record.tagName === 'build_record';
        const isConstructionRecord = record.tagName === 'construction_record';
        let cadNumber, objectType, address, areaValue = '', purpose = '', cadastralValue = '';

        if (isBuildRecord) {
            cadNumber = getElementValue(record, 'object > common_data > cad_number');
            objectType = getElementValue(record, 'object > common_data > type > value');
            address = getElementValue(record, 'address_location > address > readable_address');
            const areaElement = record.querySelector('params > area');
            areaValue = areaElement ? getElementValue(areaElement, 'value') : '';
            purpose = getElementValue(record, 'params > purpose > value');
            cadastralValue = getElementValue(record, 'cost > value');
        } else if (isConstructionRecord) {
            cadNumber = getElementValue(record, 'object > common_data > cad_number');
            objectType = getElementValue(record, 'object > common_data > type > value');
            address = getElementValue(record, 'address_location > address > readable_address');
            purpose = getElementValue(record, 'params > purpose'); // Might be just text node
            const baseParameter = record.querySelector('params > base_parameters > base_parameter');
            if (baseParameter) {
                if (baseParameter.querySelector('area')) areaValue = getElementValue(baseParameter, 'area');
                else if (baseParameter.querySelector('extension')) areaValue = `Протяженность: ${getElementValue(baseParameter, 'extension')}`;
                else if (baseParameter.querySelector('depth')) areaValue = `Глубина: ${getElementValue(baseParameter, 'depth')}`;
                else if (baseParameter.querySelector('volume')) areaValue = `Объем: ${getElementValue(baseParameter, 'volume')}`;
                else if (baseParameter.querySelector('height')) areaValue = `Высота: ${getElementValue(baseParameter, 'height')}`;
                else if (baseParameter.querySelector('built_up_area')) areaValue = `Площадь застройки: ${getElementValue(baseParameter, 'built_up_area')}`;
            }
            cadastralValue = getElementValue(record, 'cost > value');
        }
        const formattedCadastralValue = cadastralValue ? parseFloat(cadastralValue).toLocaleString('ru-RU') + ' руб.' : 'Нет данных';
        return { cadNumber, objectType, address, areaString: areaValue ? `${areaValue}` : 'Нет данных', permittedUse: purpose || 'Нет данных', formattedCadastralValue, isBuilding: isBuildRecord, isConstruction: isConstructionRecord };
    }
}
    
    function parseSpecialClipboardFormat(clipboardText) {
    if (!clipboardText || typeof clipboardText !== 'string') return null;
    const lines = clipboardText.trim().split('\n').map(line => line.trim());
    if (lines.length < 2) return null; // Must have at least quarter line and one coordinate line

    const firstLine = lines[0];
    // Regex for XX:XX:XXXXXX or XX:XX:XXXXXXX (cadastral quarter)
    // OR a full cadastral number XX:XX:XXXXXX:YY or XX:XX:XXXXXXX:YY
    const quarterOrCadastralRegex = /^\d{2}:\d{2}:(\d{6}|\d{7})(:(\d+))?$/;
    const match = firstLine.match(quarterOrCadastralRegex);

    if (!match) return null; // First line is not a valid quarter or cadastral number format

    const quarterPart = `${match[0].split(':').slice(0,3).join(':')}`; // Extracts "XX:XX:XXXXXX"
    const firstLineIsFullCadastral = isValidCadastralNumber(firstLine); // Check if the first line is a complete ZU number

    const coordinateLines = lines.slice(1);
    const coordinatesData = [];
    let validCoordinatesFound = false;

    for (const line of coordinateLines) {
        // Match X<tab_or_spaces>Y, allowing for potential extra spaces
        const coordMatch = line.match(/^(-?\d+(\.\d+)?)\s+(-?\d+(\.\d+)?)$/);
        if (coordMatch && coordMatch.length >= 4) {
            const x = parseFloat(coordMatch[1]);
            const y = parseFloat(coordMatch[3]);
            if (!isNaN(x) && !isNaN(y)) {
                // Ensure dot as decimal separator for consistency
                coordinatesData.push(`${x.toString().replace(',', '.')}\t${y.toString().replace(',', '.')}`);
                validCoordinatesFound = true;
            } else {
                // Invalid number parsing within coordinate block
                return null;
            }
        } else if (line !== "") {
            // Non-empty line that doesn't match coordinate format
            return null;
        }
    }

    if (!validCoordinatesFound) return null; // No valid coordinates found after the first line

    return {
        quarter: quarterPart,
        coordinatesText: coordinatesData.join('\n'),
        // Pass the full first line to potentially select it if it's a complete KN
        cadastralToSelect: firstLineIsFullCadastral ? firstLine : null
    };
}

function showPersistentMessageDialog(title, message, type = 'info') {
    // Remove any existing persistent dialog first
    const existingDialog = document.getElementById('persistentMessageDialog');
    if (existingDialog) {
        existingDialog.remove();
    }
    const existingOverlay = document.getElementById('persistentMessageDialogOverlay');
    if (existingOverlay) {
        existingOverlay.remove();
    }

    const overlay = document.createElement('div');
    overlay.id = 'persistentMessageDialogOverlay';
    overlay.style.position = 'fixed';
    overlay.style.top = '0';
    overlay.style.left = '0';
    overlay.style.width = '100%';
    overlay.style.height = '100%';
    overlay.style.backgroundColor = 'rgba(0, 0, 0, 0.6)';
    overlay.style.zIndex = '2050'; // High z-index
    overlay.style.display = 'flex';
    overlay.style.justifyContent = 'center';
    overlay.style.alignItems = 'center';

    const dialog = document.createElement('div');
    dialog.id = 'persistentMessageDialog';
    dialog.style.backgroundColor = 'white';
    dialog.style.padding = '25px';
    dialog.style.borderRadius = '10px';
    dialog.style.boxShadow = '0 5px 20px rgba(0, 0, 0, 0.3)';
    dialog.style.maxWidth = '450px';
    dialog.style.width = '90%';
    dialog.style.textAlign = 'center';
    dialog.style.animation = 'fadeInScale 0.3s ease-out'; // Reuse existing animation

    let iconHtml = '';
    if (type === 'warning') {
        iconHtml = '<i class="fas fa-exclamation-triangle" style="color: #f39c12; font-size: 24px; margin-bottom: 10px;"></i>';
    } else if (type === 'error') {
        iconHtml = '<i class="fas fa-times-circle" style="color: #e74c3c; font-size: 24px; margin-bottom: 10px;"></i>';
    } else { // info
        iconHtml = '<i class="fas fa-info-circle" style="color: #3498db; font-size: 24px; margin-bottom: 10px;"></i>';
    }

    dialog.innerHTML = `
        <div style="margin-bottom: 15px;">${iconHtml}</div>
        <h3 style="margin-top: 0; margin-bottom: 15px; color: #2c3e50; font-size: 18px;">${title}</h3>
        <p style="margin-bottom: 25px; color: #555; line-height: 1.6;">${message}</p>
        <button id="closePersistentMessageBtn" class="button" style="padding: 10px 20px; background-color: #4a69bd; min-width: 100px;">OK</button>
    `;

    overlay.appendChild(dialog);
    document.body.appendChild(overlay);

    const closeButton = document.getElementById('closePersistentMessageBtn');
    const closeDialog = () => {
        if (document.body.contains(overlay)) {
            document.body.removeChild(overlay);
        }
    };
    closeButton.addEventListener('click', closeDialog);
    overlay.addEventListener('click', (e) => { // Close on overlay click
        if (e.target === overlay) {
            closeDialog();
        }
    });
}


async function loadKptForQuarterAndProcess(quarterToLoad, coordinatesTextToProcess, cadastralToSelectAfterKptLoad) {
    const formattedQuarterForSupabase = quarterToLoad.replace(/:/g, '_');
    const loaderContainer = document.getElementById('loaderContainer');
    updateLoaderProgress(0, 1, `Поиск КПТ для квартала ${quarterToLoad}...`);
    if (loaderContainer) loaderContainer.style.display = 'flex';

    let kptFileToLoad = null;

    try {
        if (!supabaseInitializationPromise) initializeSupabase();
        await supabaseInitializationPromise;
        if (!supabase) {
            // Using showPersistentMessageDialog for critical init errors too
            showPersistentMessageDialog(
                'Ошибка инициализации',
                'Клиент базы данных не инициализирован. Невозможно выполнить операции с базой данных.',
                'error'
            );
            if (loaderContainer) loaderContainer.style.display = 'none';
            return false;
        }

        const { data: fileList, error: listError } = await supabase.storage
            .from(BUCKET_NAME)
            .list(null, { limit: 200, offset: 0, search: formattedQuarterForSupabase });

        if (listError) throw new Error(`Не удалось получить список файлов для квартала ${quarterToLoad}: ${listError.message}`);

        const matchingFiles = fileList ? fileList.filter(file => file.name.startsWith(formattedQuarterForSupabase)) : [];

        if (matchingFiles.length > 0) {
            kptFileToLoad = findLatestKptFile(matchingFiles);
        } else {
            // *** MODIFIED HERE: Use persistent dialog instead of showNotification ***
            showPersistentMessageDialog(
                'КПТ не найден',
                `Кадастровый план территории для квартала <strong>${quarterToLoad}</strong> не найден. Координаты из буфера обмена будут добавлены на пустую схему. Вы можете загрузить КПТ в базу данных.`,
                'warning'
            );
            if (loaderContainer) loaderContainer.style.display = 'none';
            return false; // KPT not found
        }
    } catch (error) {
        showPersistentMessageDialog( // Also use persistent for search errors
            'Ошибка поиска КПТ',
            `При поиске КПТ для квартала ${quarterToLoad} в базе данных произошла ошибка: <br><small>${error.message}</small>`,
            'error'
        );
        if (loaderContainer) loaderContainer.style.display = 'none';
        return false;
    }

    if (kptFileToLoad) {
        try {
            updateLoaderProgress(0, 1, `Загрузка КПТ ${kptFileToLoad.name}...`);
            const { data: blob, error: downloadError } = await supabase.storage.from(BUCKET_NAME).download(kptFileToLoad.name);
            if (downloadError) throw new Error(`Не удалось загрузить файл КПТ ${kptFileToLoad.name}: ${downloadError.message}`);
            if (!blob) throw new Error('Не удалось получить содержимое файла КПТ от Supabase.');

            const zipFileObject = new File([blob], kptFileToLoad.name, { type: 'application/zip' });

            await new Promise(async (resolveProcessZip, rejectProcessZip) => {
                const reader = new FileReader();
                reader.onprogress = function(e) { if (e.lengthComputable) updateLoaderProgress(e.loaded, blob.size, 'Чтение ZIP-архива'); };
                reader.onload = function(e) {
                    const zipContent = e.target.result;
                    updateLoaderProgress(blob.size, blob.size, 'Обработка содержимого архива');
                    try {
                        JSZip.loadAsync(zipContent).then(zip => {
                            let xmlFile = Object.values(zip.files).find(fileEntry => fileEntry.name.toLowerCase().endsWith('.xml') && !fileEntry.dir);
                            if (xmlFile) {
                                updateLoaderProgress(blob.size, blob.size, 'Извлечение XML из архива');
                                return xmlFile.async('string').then(xmlContent => ({ content: xmlContent, fileName: xmlFile.name, size: new Blob([xmlContent]).size }));
                            } else {
                                throw new Error('XML-файл не найден в архиве ZIP.');
                            }
                        })
                        .then(async result => {
                            if (result && result.content) {
                                const xmlSize = result.size;
                                updateLoaderProgress(xmlSize, xmlSize, 'Анализ XML...');
                                try {
                                    await processXMLContent(result.content, result.fileName, cadastralToSelectAfterKptLoad);
                                    showNotification(`КПТ ${result.fileName} успешно загружен.`, 'success', 'check-circle');
                                    processImportedCoordinates(coordinatesTextToProcess);
                                    showNotification('Координаты из буфера обмена добавлены.', 'success', 'paste');
                                    resolveProcessZip(true);
                                } catch (xmlError) {
                                    rejectProcessZip(new Error('Ошибка при обработке XML из архива: ' + xmlError.message));
                                }
                            } else {
                                rejectProcessZip(new Error('Не удалось извлечь XML из ZIP-архива.'));
                            }
                        })
                        .catch(zipProcessError => {
                            rejectProcessZip(new Error('Ошибка при обработке ZIP-файла: ' + zipProcessError.message));
                        });
                    } catch (zipReadError) {
                        rejectProcessZip(new Error('Ошибка при распаковке ZIP-файла: ' + zipReadError.message));
                    }
                };
                reader.onerror = function() {
                    rejectProcessZip(new Error('Ошибка при чтении ZIP-файла'));
                };
                reader.readAsArrayBuffer(zipFileObject);
            });
            if (loaderContainer) loaderContainer.style.display = 'none';
            return true;
        } catch (error) {
             showPersistentMessageDialog( // Use persistent for KPT open errors
                'Ошибка открытия КПТ',
                `При открытии файла КПТ ${kptFileToLoad.name} произошла ошибка: <br><small>${error.message}</small>`,
                'error'
            );
            if (loaderContainer) loaderContainer.style.display = 'none';
            return false;
        }
    }
    return false; // Should ideally not be reached if kptFileToLoad was null
}


    // New function to extract coordinates for Zones and Territories
    function extractZoneOrTerritoryCoordinatesFromXML(record) {
        const result = [];
        // Adjusted selector based on the provided example XML structure
        const contours = record.querySelectorAll("b_contours_location > contours > contour");
        contours.forEach(contour => {
            const spatialElements = contour.querySelectorAll("entity_spatial > spatials_elements > spatial_element");
            spatialElements.forEach(spatialElement => {
                const coordinates = [];
                const ordinates = spatialElement.querySelectorAll("ordinates > ordinate");
                ordinates.forEach(ordinate => {
                    const xElement = ordinate.querySelector("x");
                    const yElement = ordinate.querySelector("y");
                    const ordNmbElement = ordinate.querySelector("ord_nmb"); // Order number
                    const deltaElement = ordinate.querySelector("delta_geopoint"); // Inaccuracy

                    if (xElement && xElement.textContent.trim() !== '' &&
                        yElement && yElement.textContent.trim() !== '' &&
                        ordNmbElement && ordNmbElement.textContent.trim() !== '') { // Ensure ordNmb is present

                        const x = parseFloat(xElement.textContent);
                        const y = parseFloat(yElement.textContent);
                        const ordNmb = parseInt(ordNmbElement.textContent);
                        const delta = deltaElement ? parseFloat(deltaElement.textContent) : 0; // Default delta to 0 if not present

                        coordinates.push({ x, y, ordNmb, delta });
                    }
                });
                if (coordinates.length > 0) result.push(coordinates);
            });
        });
        return result;
    }
    
   async function handleSchemeOnKptClick() {
    if (selectedImportedObjectIndex === -1) {
        showNotification('Для этой функции должен быть выбран созданный на схеме объект.', 'warning', 'exclamation-triangle');
        return;
    }

    // 1. Установить флаг для подсветки красным
    highlightImportedForScreenshot = true;

    // 2. Перерисовать холст с красной подсветкой
    const adjacentParcels = getAdjacentParcelsForSelected(selectedCadastralNumber);
    const adjacentParcelsForImported = getAdjacentParcelsForImported();
    redraw(adjacentParcels, adjacentParcelsForImported, true);

    // Небольшая задержка, чтобы браузер успел отрисовать кадр перед копированием
    setTimeout(() => {
        const canvasEl = document.getElementById('kptSchemeCanvas');
        if (!canvasEl) {
            highlightImportedForScreenshot = false; // Сбросить флаг при ошибке
            return;
        }

        try {
            canvasEl.toBlob(async (blob) => {
                if (blob) {
                    try {
                        await navigator.clipboard.write([
                            new ClipboardItem({ 'image/png': blob })
                        ]);
                        showNotification('Схема скопирована, открывается vsemap.ru...', 'success', 'check-circle');
                        window.open('https://vsemap.ru/image', '_blank'); // <<< ДОБАВЛЕНА ЭТА СТРОКА
                    } catch (err) {
                        console.error('Ошибка копирования в буфер обмена:', err);
                        showNotification('Ошибка копирования изображения.', 'error', 'exclamation-circle');
                    }
                } else {
                    showNotification('Не удалось создать изображение для копирования.', 'error', 'exclamation-circle');
                }

                // 4. Сбросить флаг и перерисовать обратно в нормальные цвета
                highlightImportedForScreenshot = false;
                redraw(adjacentParcels, adjacentParcelsForImported, true);

            }, 'image/png');
        } catch (e) {
            console.error('Ошибка toBlob:', e);
            showNotification('Ошибка создания изображения.', 'error', 'exclamation-circle');
            // Сбросить флаг при ошибке
            highlightImportedForScreenshot = false;
            redraw(adjacentParcels, adjacentParcelsForImported, true);
        }
    }, 100); // 100мс задержки
}

    // New function to extract data for Zones and Territories
 function extractZoneOrTerritoryData(record) {
    // Приоритетная проверка: это узел кадастрового квартала?
    if (record.tagName === 'cadastral_block') {
        const quarterNumber = getElementValue(record, 'cadastral_number');
        // Возвращаем объект с корректной структурой, заполненный данными квартала
        return {
            regNumbBorder: quarterNumber,
            typeZoneValue: 'Граница квартала',
            typeZoneCode: '', 
            typeBoundaryValue: 'Граница кадастрового квартала',
            typeBoundaryCode: '',
            number: '',
            index: '',
            nameByDoc: '',
            description: '',
            other: '',
            zoneSubType: 'quarter_boundary', 
            record: record
        };
    }
    
    // Если это не квартал, то работает старая логика для обычных зон
    let regNumbBorder, typeZoneValue, typeZoneCode, typeBoundaryValue, typeBoundaryCode, number, index, nameByDoc, description, other, zoneSubType;

    regNumbBorder = getElementValue(record, 'b_object > reg_numb_border');
    typeZoneValue = getElementValue(record, 'type_zone > value');
    typeZoneCode = getElementValue(record, 'type_zone > code');
    typeBoundaryValue = getElementValue(record, 'b_object > type_boundary > value');
    typeBoundaryCode = getElementValue(record, 'b_object > type_boundary > code');
    number = getElementValue(record, 'number');
    index = getElementValue(record, 'index');
    nameByDoc = getElementValue(record, 'name_by_doc');
    description = getElementValue(record, 'description');
    other = getElementValue(record, 'other');

    if (typeZoneValue) {
        const lowerTypeZoneValue = typeZoneValue.toLowerCase().trim();
        if (lowerTypeZoneValue.includes('территориальная зона')) {
            zoneSubType = 'territorial_zone';
        } else if (lowerTypeZoneValue.includes('охранная зона') || lowerTypeZoneValue.includes('санитарно-защитная') || lowerTypeZoneValue.includes('особых условий использования территорий') || lowerTypeZoneValue.includes('зоуит')) {
            zoneSubType = 'restricted_use_zone';
        } else if (record.tagName === 'municipal_boundary_record') {
             zoneSubType = 'municipal_boundary';
             typeZoneValue = 'Муниципальное образование';
        } else if (record.tagName === 'inhabited_locality_boundary_record') {
             zoneSubType = 'inhabited_locality';
             typeZoneValue = 'Населенный пункт';
        } else {
            zoneSubType = 'other_zone';
        }
    } else if (record.tagName === 'municipal_boundary_record') {
         zoneSubType = 'municipal_boundary';
         typeZoneValue = 'Муниципальное образование';
    } else if (record.tagName === 'inhabited_locality_boundary_record') {
         zoneSubType = 'inhabited_locality';
         typeZoneValue = 'Населенный пункт';
    } else {
        zoneSubType = 'unknown_zone';
    }
 
    return {
        regNumbBorder, typeZoneValue, typeZoneCode, typeBoundaryValue, typeBoundaryCode,
        number, index, nameByDoc, description, other, zoneSubType, record
    };
}


    document.getElementById('rulerBtn').addEventListener('click', function() {
        rulerMode = !rulerMode;
        if (rulerMode) {
            this.classList.add('active');
            document.getElementById('measurementPanel').classList.add('active');
            showNotification('Режим измерения включен. Выберите две точки на карте.', 'info', 'ruler');
        } else {
            this.classList.remove('active');
            document.getElementById('measurementPanel').classList.remove('active');
            showNotification('Режим измерения выключен', 'info', 'times');
        }
        rulerPoints = [];
        updateMeasurementPanel();
        const adjacentParcels = getAdjacentParcelsForSelected(selectedCadastralNumber);
        const adjacentParcelsForImported = getAdjacentParcelsForImported();
        redraw(adjacentParcels, adjacentParcelsForImported, true);
    });

    document.getElementById('resetMeasurementBtn').addEventListener('click', function() {
        rulerPoints = [];
        updateMeasurementPanel();
        const adjacentParcels = getAdjacentParcelsForSelected(selectedCadastralNumber);
        const adjacentParcelsForImported = getAdjacentParcelsForImported();
        redraw(adjacentParcels, adjacentParcelsForImported, true);
    });
    
    
    function getGenericCoordinatesText(geometry) {
        let coordsText = '';
        if (!geometry) return coordsText;

        let contoursToProcess = [];

        if (Array.isArray(geometry) && geometry.length > 0 && geometry[0] && typeof geometry[0].x === 'number') {
            // It's a single contour (array of points) - typical for an imported object from importedContours
            contoursToProcess.push(geometry);
        } else if (geometry.contours && Array.isArray(geometry.contours)) {
            // It's an object with a 'contours' property (like KPT parcels/buildings/zones)
            contoursToProcess = geometry.contours;
        }


        contoursToProcess.forEach((contour, contourIndex) => {
            if (contourIndex > 0 && coordsText.length > 0 && !coordsText.endsWith('\n\n')) {
                 // Add an empty line if there are multiple contours and text already exists
                 coordsText += '\n';
            }
            if (Array.isArray(contour)) {
                contour.forEach(point => {
                    if (point && typeof point.x === 'number' && typeof point.y === 'number') {
                        coordsText += `${point.x.toFixed(2)}\t${point.y.toFixed(2)}\n`;
                    }
                });
            }
        });
         // Remove trailing newline if it exists
        if (coordsText.endsWith('\n')) {
            coordsText = coordsText.slice(0, -1);
        }
        return coordsText;
    }


    function updateMeasurementPanel() {
        const coordsElement = document.getElementById('measurementCoordinates');
        const distanceElement = document.getElementById('measurementDistance');
        if (rulerPoints.length === 0) {
            coordsElement.innerHTML = 'Точка 1: Выберите на карте<br>Точка 2: Выберите на карте';
            distanceElement.textContent = 'Расстояние: -';
        } else if (rulerPoints.length === 1) {
            coordsElement.innerHTML = `Точка 1: X=${rulerPoints[0].x.toFixed(2)}, Y=${rulerPoints[0].y.toFixed(2)}<br>Точка 2: Выберите на карте`;
            distanceElement.textContent = 'Расстояние: -';
        } else if (rulerPoints.length === 2) {
            coordsElement.innerHTML = `Точка 1: X=${rulerPoints[0].x.toFixed(2)}, Y=${rulerPoints[0].y.toFixed(2)}<br>Точка 2: X=${rulerPoints[1].x.toFixed(2)}, Y=${rulerPoints[1].y.toFixed(2)}`;
            const distance = calculateDistance(rulerPoints[0], rulerPoints[1]);
            distanceElement.textContent = `Расстояние: ${distance.toFixed(2)} м`;
        }
    }

    function calculateDistance(point1, point2) {
        const dx = point2.x - point1.x;
        const dy = point2.y - point1.y;
        return Math.sqrt(dx * dx + dy * dy);
    }

    function getElementValue(element, tagName) {
        if (!element) return '';
        const parts = tagName.split('>');
        let currentElement = element;
        for (let part of parts) {
            currentElement = currentElement.querySelector(part);
            if (!currentElement) return '';
        }
        return currentElement.textContent.trim();
    }

    function extractCoordinatesFromXML(landRecord) {
        const result = [];
        const contoursLocation = landRecord.querySelector("contours_location");
        if (contoursLocation) {
            const spatialElements = contoursLocation.querySelectorAll(":scope > spatial_element");
            let foundByOldMethod = false;
            spatialElements.forEach((spatialElement) => {
                const contour = [];
                const ordinates = spatialElement.getElementsByTagName("ordinate");
                for (let i = 0; i < ordinates.length; i++) {
                    const xElement = ordinates[i].getElementsByTagName("x")[0];
                    const yElement = ordinates[i].getElementsByTagName("y")[0];
                    const deltaElement = ordinates[i].getElementsByTagName("delta_geopoint")[0];
                    if (xElement && yElement) {
                        const x = parseFloat(xElement.textContent);
                        const y = parseFloat(yElement.textContent);
                        const delta = deltaElement ? parseFloat(deltaElement.textContent) : null;
                        if (!isNaN(x) && !isNaN(y)) {
                            contour.push({ x, y, delta });
                            foundByOldMethod = true;
                        }
                    }
                }
                if (contour.length > 0) result.push(contour);
            });
            if (result.length === 0 || !foundByOldMethod) {
                const allSpatialElements = contoursLocation.querySelectorAll("spatial_element");
                allSpatialElements.forEach((spatialElement) => {
                    const contour = [];
                    const ordinates = spatialElement.querySelectorAll("ordinate");
                    ordinates.forEach(ordinate => {
                        const xElement = ordinate.querySelector("x");
                        const yElement = ordinate.querySelector("y");
                        const deltaElement = ordinate.querySelector("delta_geopoint");
                        if (xElement && yElement) {
                            const x = parseFloat(xElement.textContent);
                            const y = parseFloat(yElement.textContent);
                            const delta = deltaElement ? parseFloat(deltaElement.textContent) : null;
                            if (!isNaN(x) && !isNaN(y)) contour.push({ x, y, delta });
                        }
                    });
                    if (contour.length > 0) result.push(contour);
                });
            }
            if (result.length === 0) {
                const allOrdinates = contoursLocation.querySelectorAll("ordinate");
                let currentContour = [];
                allOrdinates.forEach(ordinate => {
                    const xElement = ordinate.querySelector("x");
                    const yElement = ordinate.querySelector("y");
                    const deltaElement = ordinate.querySelector("delta_geopoint");
                    if (xElement && yElement) {
                        const x = parseFloat(xElement.textContent);
                        const y = parseFloat(yElement.textContent);
                        const delta = deltaElement ? parseFloat(deltaElement.textContent) : null;
                        if (!isNaN(x) && !isNaN(y)) currentContour.push({ x, y, delta });
                    }
                });
                if (currentContour.length > 0) result.push(currentContour);
            }
        }
        if (result.length === 0 && contoursLocation) {
            const allX = landRecord.querySelectorAll("x");
            const allY = landRecord.querySelectorAll("y");
            if (allX.length > 0 && allY.length > 0) {
            } else {
            }
        }
        return result;
    }

    function getAreaInfo(landRecord) {
        const areaElement = landRecord.querySelector('params > area');
        const areaValue = getElementValue(areaElement, 'value');
        const inaccuracy = getElementValue(areaElement, 'inaccuracy');
        let areaString = '';
        let isDeclaredArea = false;
        if (areaValue) {
            if (inaccuracy) areaString = `Уточненная площадь: ${areaValue} +/- ${inaccuracy}`;
            else { areaString = `Декларированная площадь: ${areaValue}`; isDeclaredArea = true; }
        }
        return { areaString, isDeclaredArea };
    }

    function extractContours_UnifiedLandUse(xmlDoc) {
        const contourElements = xmlDoc.querySelectorAll('contour');
        const maxCoordinateDifference = 100000;
        let extractedContours = [];
        contourElements.forEach((contourElement, index) => {
            const cadNumber = getElementValue(contourElement, 'cad_number');
            if (!cadNumber) return;
            const spatialElement = contourElement.querySelector("entity_spatial");
            if (!spatialElement) return;
            const contour = [];
            const ordinates = spatialElement.querySelectorAll("ordinate");
            for (let i = 0; i < ordinates.length; i++) {
                const x = parseFloat(ordinates[i].querySelector("x").textContent);
                const y = parseFloat(ordinates[i].querySelector("y").textContent);
                 if (!isNaN(x) && !isNaN(y)) contour.push({ x, y });
            }
            if (contour.length > 0) {
                const areaInfo = extractAreaFromSpecialNotes(xmlDoc, cadNumber);
                   let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
                    contour.forEach(point => { minX = Math.min(minX, point.x); minY = Math.min(minY, point.y); maxX = Math.max(maxX, point.x); maxY = Math.max(maxY, point.y); });
                   const diffX = maxX - minX; const diffY = maxY - minY;
                   if(diffX <= maxCoordinateDifference && diffY <= maxCoordinateDifference){
                        extractedContours.push({ parcelIndex: index, cadastralNumber: cadNumber, contours: [contour], isDeclaredArea: false, area: areaInfo.area || 0, areaString: areaInfo.areaString || '' });
                   } else { showNotification(`В XML контур ${cadNumber} имеет координаты за пределами допустимого диапазона и проигнорирован`,'warning', 'exclamation-triangle') }
            }
        });
        if (extractedContours.length === 0) { showNotification('В XML не найдено контуров в допустимом диапазоне координат для ЕЗ', 'error', 'exclamation-circle'); return []; }
        return extractedContours;
    }

    function extractAreaFromSpecialNotes(xmlDoc, cadastralNumber) {
        const specialNotes = xmlDoc.querySelector('special_notes');
        if (!specialNotes) return { area: 0, areaString: '' };
        const text = specialNotes.textContent;
        const escapedCadNumber = cadastralNumber.replace(/\./g, '\\.');
        const areaPattern = new RegExp(escapedCadNumber + '\\s*-\\s*(\\d+(?:[.,]\\d+)?)\\s*кв\\.м', 'i');
        const match = text.match(areaPattern);
        if (match && match[1]) {
            const areaText = match[1].replace(',', '.');
            const area = parseFloat(areaText);
            return { area: area, areaString: `Площадь: ${area} кв.м` };
        }
        return { area: 0, areaString: '' };
    }

    function askUserAboutCoordinates(message) {
        return new Promise((resolve) => {
            const modalOverlay = document.createElement('div');
            modalOverlay.style.position = 'fixed'; modalOverlay.style.top = '0'; modalOverlay.style.left = '0'; modalOverlay.style.width = '100%'; modalOverlay.style.height = '100%'; modalOverlay.style.backgroundColor = 'rgba(0, 0, 0, 0.5)'; modalOverlay.style.zIndex = '10001'; modalOverlay.style.display = 'flex'; modalOverlay.style.justifyContent = 'center'; modalOverlay.style.alignItems = 'center';
            const modalContent = document.createElement('div');
            modalContent.style.backgroundColor = 'white'; modalContent.style.padding = '20px'; modalContent.style.borderRadius = '10px'; modalContent.style.maxWidth = '500px'; modalContent.style.boxShadow = '0 4px 15px rgba(0, 0, 0, 0.2)'; modalContent.style.textAlign = 'center';
            modalContent.innerHTML = `
                <h3 style="margin-top:0;color:#2c3e50;margin-bottom:15px;"><i class="fas fa-exclamation-triangle" style="color:#f39c12;margin-right:10px;"></i>Внимание</h3>
                <p style="margin-bottom:20px;">${message}</p>
                <div style="display:flex;justify-content:center;gap:15px;">
                    <button id="ignoreBtn" style="padding:8px 15px;background-color:#305CDE;color:white;border:none;border-radius:5px;cursor:pointer;">Игнорировать ошибочные и продолжить</button>
                    <button id="loadAllBtn" style="padding:8px 15px;background-color:#FF2C2C;color:white;border:none;border-radius:5px;cursor:pointer;">Все равно загрузить все координаты</button>
                </div>
            `;
            modalOverlay.appendChild(modalContent); document.body.appendChild(modalOverlay);
            document.getElementById('ignoreBtn').addEventListener('click', function() { document.body.removeChild(modalOverlay); resolve(false); });
            document.getElementById('loadAllBtn').addEventListener('click', function() { document.body.removeChild(modalOverlay); resolve(true); });
        });
    }

    async function extractAllContours(xmlContent) {
        const parser = new DOMParser();
        const xmlDoc = parser.parseFromString(xmlContent, "text/xml");
        const maxCoordinateDifference = 100000;
        let extractedContours = [];
        let hasOutOfRangeCoordinates = false;
        let loadAllCoordinates = false;

        if (isUnifiedLandUse) {
            const contourElements = xmlDoc.querySelectorAll('contour');
            const allContoursUnified = []; const validContoursUnified = [];
            contourElements.forEach((contourElement, index) => {
                const cadNumber = getElementValue(contourElement, 'cad_number'); if (!cadNumber) return;
                const spatialElement = contourElement.querySelector("entity_spatial"); if (!spatialElement) return;
                const contour = [];
                const ordinates = spatialElement.querySelectorAll("ordinate");
                for (let i = 0; i < ordinates.length; i++) {
                    const xElem = ordinates[i].querySelector("x"); const yElem = ordinates[i].querySelector("y");
                    if (xElem && yElem) { const x = parseFloat(xElem.textContent); const y = parseFloat(yElem.textContent); if (!isNaN(x) && !isNaN(y)) contour.push({ x, y }); }
                }
                if (contour.length > 0) {
                    let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
                    contour.forEach(point => { minX = Math.min(minX, point.x); minY = Math.min(minY, point.y); maxX = Math.max(maxX, point.x); maxY = Math.max(maxY, point.y); });
                    const diffX = maxX - minX; const diffY = maxY - minY;
                    const contourData = { parcelIndex: index, cadastralNumber: cadNumber, contours: [contour], isDeclaredArea: false, area: 0, areaString: '', isValid: diffX <= maxCoordinateDifference && diffY <= maxCoordinateDifference };
                    const areaInfo = extractAreaFromSpecialNotes(xmlDoc, cadNumber); if (areaInfo && areaInfo.area) { contourData.area = areaInfo.area; contourData.areaString = areaInfo.areaString; }
                    allContoursUnified.push(contourData);
                    if (contourData.isValid) validContoursUnified.push(contourData); else hasOutOfRangeCoordinates = true;
                }
            });
            if (hasOutOfRangeCoordinates && validContoursUnified.length > 0) loadAllCoordinates = await askUserAboutCoordinates('В XML некоторые контуры ЕЗ имеют координаты за пределами допустимого диапазона. Что делать?');
            extractedContours = loadAllCoordinates ? allContoursUnified : validContoursUnified;
        } else {
            const landRecords = xmlDoc.querySelectorAll('land_record');
            const allParcelsKPT = []; const validParcelsKPT = [];
            Array.from(landRecords).forEach((record, index) => {
                let contours = extractCoordinatesFromXML(record); if (contours.length === 0) return;
                const validatedContours = []; const allRecordContours = [];
                contours.forEach(contour => {
                    if (contour.length === 0) return;
                    let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
                    contour.forEach(point => { minX = Math.min(minX, point.x); minY = Math.min(minY, point.y); maxX = Math.max(maxX, point.x); maxY = Math.max(maxY, point.y); });
                    const diffX = maxX - minX; const diffY = maxY - minY;
                    allRecordContours.push(contour);
                    if (diffX <= maxCoordinateDifference && diffY <= maxCoordinateDifference) validatedContours.push(contour); else hasOutOfRangeCoordinates = true;
                });
                const cadastralNumber = getElementValue(record, 'object > common_data > cad_number');
                const isDeclaredArea = getAreaInfo(record).isDeclaredArea;
                if (allRecordContours.length > 0) allParcelsKPT.push({ parcelIndex: index, cadastralNumber: cadastralNumber, contours: allRecordContours, isDeclaredArea: isDeclaredArea });
                if (validatedContours.length > 0) validParcelsKPT.push({ parcelIndex: index, cadastralNumber: cadastralNumber, contours: validatedContours, isDeclaredArea: isDeclaredArea });
            });
            if (hasOutOfRangeCoordinates && validParcelsKPT.length > 0) loadAllCoordinates = await askUserAboutCoordinates('В XML некоторые участки КПТ имеют контуры с координатами за пределами допустимого диапазона. Что делать?');
            extractedContours = loadAllCoordinates ? allParcelsKPT : validParcelsKPT;
        }
        if (extractedContours.length === 0) { if (xmlContent.length > 100) showNotification('В XML не найдено валидных контуров ЗУ.', 'error', 'exclamation-circle'); return []; }
        return extractedContours;
    }

   function extractData(sourceElement) { // sourceElement is an item from allContours
    if (!sourceElement) return null;

    if (sourceElement.isParsedFromJson && sourceElement.record) {
        const jsonDataItem = sourceElement.record; // This is the original object from JSON's "objects" array
        let typeDisplay = 'Земельный участок (JSON)'; // Assuming only parcels reach here via JSON through allContours

        return {
            cadNumber: jsonDataItem.id,
            objectType: typeDisplay,
            address: 'Нет данных',
            includedObjects: '', // JSON doesn't have this
            areaString: 'Нет данных', // JSON doesn't have this
            permittedUse: 'Нет данных', // JSON doesn't have this
            formattedCadastralValue: 'Нет данных', // JSON doesn't have this
            category: 'Нет данных', // JSON doesn't have this
            isDeclaredArea: false, // Default for this JSON format
            isUnifiedLandUse: false, // By assumption for this JSON type
            isIsolatedParcel: false, // Default for this JSON format
            commonLandCadNumber: null // Default for this JSON format
        };
    } else if (isUnifiedLandUse && sourceElement.tagName === 'contour') {
        // ... existing XML EUL logic ...
        // (Ensure sourceElement.record logic is correctly handled if EUL sourceElement is from allContours)
        const cadNumber = getElementValue(sourceElement, 'cad_number'); if (!cadNumber) return null;
            const parser = new DOMParser(); const xmlDoc = parser.parseFromString(window.xmlContent || '<root/>', "text/xml"); // Ensure window.xmlContent is set
            const mainCadNumber = getElementValue(xmlDoc, 'extract_about_property_land > object > common_data > cad_number');
            const objectType = "Единое землепользование";
            const address = getElementValue(xmlDoc, 'extract_about_property_land > address_location > address > readable_address') || 'Нет данных';
            const areaInfo = extractAreaFromSpecialNotes(xmlDoc, cadNumber); const areaString = areaInfo.areaString || 'Нет данных';
            const cadastralValue = getElementValue(xmlDoc, 'extract_about_property_land > cost > value') || '';
            const formattedCadastralValue = cadastralValue ? parseFloat(cadastralValue).toLocaleString('ru-RU') + ' руб.' : 'Нет данных';
            const category = getElementValue(xmlDoc, 'extract_about_property_land > params > category > type > value') || 'Нет данных';
            const permittedUse = getElementValue(xmlDoc, 'extract_about_property_land > params > permitted_use > permitted_use_established > by_document') || 'Нет данных';
            return { cadNumber, mainCadNumber, objectType, address, includedObjects: '', areaString: areaString, permittedUse, formattedCadastralValue, category, isDeclaredArea: false, isUnifiedLandUse: true, isIsolatedParcel: false, commonLandCadNumber: null };
    } else if (!isUnifiedLandUse && sourceElement.tagName === 'land_record') {
        // ... existing XML KPT logic ...
        const landRecord = sourceElement; // sourceElement is the XML <land_record> element
            const cadNumber = getElementValue(landRecord, 'object > common_data > cad_number'); if (!cadNumber) return null;
            const commonLandCadNumber = getElementValue(landRecord, 'cad_links > common_land > common_land_cad_number > cad_number');
            const isIsolatedParcel = !!commonLandCadNumber;
            let objectType; if (isIsolatedParcel) objectType = "Обособленный участок"; else objectType = getElementValue(landRecord, 'object > common_data > type > value');
            const address = getElementValue(landRecord, 'address_location > address > readable_address');
            const includedObjects = Array.from(landRecord.querySelectorAll('cad_links > included_objects > included_object > cad_number')).map(el => el.textContent.trim()).filter(cn => cn);
            const areaInfo = getAreaInfo(landRecord); const areaString = areaInfo.areaString;
            const permittedUse = getElementValue(landRecord, 'params > permitted_use > permitted_use_established > by_document');
            const cadastralValue = getElementValue(landRecord, 'cost > value');
            const formattedCadastralValue = cadastralValue ? parseFloat(cadastralValue).toLocaleString('ru-RU') + ' руб.' : 'Нет данных';
            const category = getElementValue(landRecord, 'category > type > value');
            return { cadNumber, objectType, address, includedObjects: includedObjects.join(', '), areaString, permittedUse, formattedCadastralValue, category, isDeclaredArea: areaInfo.isDeclaredArea, isUnifiedLandUse: false, isIsolatedParcel: isIsolatedParcel, commonLandCadNumber: commonLandCadNumber };
    }
    return null;
}

    async function extractBuildingsFromXML(xmlContent) {
        const parser = new DOMParser(); const xmlDoc = parser.parseFromString(xmlContent, "text/xml");
        const buildRecords = xmlDoc.querySelectorAll('build_record'); const constructionRecords = xmlDoc.querySelectorAll('construction_record');
        const maxCoordinateDifference = 100000;
        let buildingsData = []; let allBuildingsData = []; let hasOutOfRangeCoordinates = false; let loadAllCoordinates = false;
        function processBuildingRecords(records, type, storeAll = false) {
            const result = [];
            records.forEach(record => {
                const cadNumber = getElementValue(record, 'object > common_data > cad_number'); let contours = extractBuildingCoordinatesFromXML(record); if (contours.length === 0) return;
                const validContours = []; const allRecordContours = [];
                contours.forEach(contour => {
                    if (contour.length === 0) return;
                    let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
                    contour.forEach(point => { minX = Math.min(minX, point.x); minY = Math.min(minY, point.y); maxX = Math.max(maxX, point.x); maxY = Math.max(maxY, point.y); });
                    const diffX = maxX - minX; const diffY = maxY - minY;
                    allRecordContours.push(contour);
                    if (diffX <= maxCoordinateDifference && diffY <= maxCoordinateDifference) validContours.push(contour); else hasOutOfRangeCoordinates = true;
                });
                if (validContours.length > 0) result.push({ cadastralNumber: cadNumber, contours: validContours, type: type, record: record });
                if (storeAll && allRecordContours.length > 0) allBuildingsData.push({ cadastralNumber: cadNumber, contours: allRecordContours, type: type, record: record });
            });
            return result;
        }
        buildingsData = processBuildingRecords(buildRecords, 'building', true);
        buildingsData = buildingsData.concat(processBuildingRecords(constructionRecords, 'construction', true));
        if (hasOutOfRangeCoordinates && buildingsData.length > 0) loadAllCoordinates = await askUserAboutCoordinates('В XML некоторые ОКС имеют контуры с координатами за пределами допустимого диапазона. Что делать?');
        return loadAllCoordinates ? allBuildingsData : buildingsData;
    }

 async function extractZonesAndTerritoriesFromXML(xmlContent) {
    const parser = new DOMParser();
    const xmlDoc = parser.parseFromString(xmlContent, "text/xml");
    
    // Существующий селектор для зон и границ
    const zoneRecords = xmlDoc.querySelectorAll('zones_and_territories_record, municipal_boundaries > municipal_boundary_record, inhabited_locality_boundaries > inhabited_locality_boundary_record');
    
    // НОВЫЙ селектор для границ кварталов
    const quarterRecords = xmlDoc.querySelectorAll('cadastral_blocks > cadastral_block');

    const maxCoordinateDifference = 100000;
    let zonesData = [];
    let allZonesData = [];
    let hasOutOfRangeCoordinates = false;
    let loadAllCoordinates = false;
    
    // Вспомогательная функция для извлечения координат границы квартала
    function extractQuarterBoundaryCoordinates(record) {
        const result = [];
        const spatialElement = record.querySelector("spatial_data > entity_spatial > spatials_elements > spatial_element");
        if (spatialElement) {
            const coordinates = [];
            const ordinates = spatialElement.querySelectorAll("ordinates > ordinate");
            ordinates.forEach(ordinate => {
                const xElement = ordinate.querySelector("x");
                const yElement = ordinate.querySelector("y");
                if (xElement && yElement) {
                    const x = parseFloat(xElement.textContent);
                    const y = parseFloat(yElement.textContent);
                    if (!isNaN(x) && !isNaN(y)) {
                        coordinates.push({ x, y });
                    }
                }
            });
            if (coordinates.length > 0) {
                result.push(coordinates);
            }
        }
        return result;
    }

    function processRecords(records, isQuarter = false) {
        const result = [];
        records.forEach(record => {
            let details, regNumb, contours;

            if (isQuarter) {
                regNumb = getElementValue(record, 'cadastral_number');
                if (!regNumb) return;
                contours = extractQuarterBoundaryCoordinates(record);
                details = {
                    regNumbBorder: regNumb,
                    typeZoneValue: 'Граница квартала',
                    zoneSubType: 'quarter_boundary',
                    record: record
                };
            } else {
                details = extractZoneOrTerritoryData(record);
                regNumb = details.regNumbBorder;
                if (!regNumb) return;
                contours = extractZoneOrTerritoryCoordinatesFromXML(record);
            }

            if (contours.length === 0) return;

            const validContours = [];
            const allRecordContours = [];
            contours.forEach(contour => {
                if (contour.length === 0) return;
                let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
                contour.forEach(point => { minX = Math.min(minX, point.x); minY = Math.min(minY, point.y); maxX = Math.max(maxX, point.x); maxY = Math.max(maxY, point.y); });
                const diffX = maxX - minX; const diffY = maxY - minY;
                allRecordContours.push(contour);
                if (diffX <= maxCoordinateDifference && diffY <= maxCoordinateDifference) {
                    validContours.push(contour);
                } else {
                    hasOutOfRangeCoordinates = true;
                }
            });

            const finalObject = {
                regNumbBorder: details.regNumbBorder,
                typeZoneValue: details.typeZoneValue,
                zoneSubType: details.zoneSubType,
                record: details.record
            };

            if (validContours.length > 0) {
                result.push({ ...finalObject, contours: validContours });
            }
            if (allRecordContours.length > 0) {
                allZonesData.push({ ...finalObject, contours: allRecordContours });
            }
        });
        return result;
    }

    // Обрабатываем зоны и границы
    let processedZones = processRecords(zoneRecords, false);
    // Обрабатываем кварталы
    let processedQuarters = processRecords(quarterRecords, true);
    
    // Объединяем результаты
    zonesData = [...processedZones, ...processedQuarters];
    // allZonesData уже заполнилась внутри processRecords

    if (hasOutOfRangeCoordinates && zonesData.length > 0) {
        loadAllCoordinates = await askUserAboutCoordinates(
            'В XML некоторые зоны/территории/кварталы имеют контуры с координатами за пределами допустимого диапазона. Что делать?'
        );
    }
    
    return loadAllCoordinates ? allZonesData : zonesData;
}

    let cadastralBlockNumber = '';

    function updateDocumentTitle(xmlContent) {
        const parser = new DOMParser(); const xmlDoc = parser.parseFromString(xmlContent, "text/xml");
        const isUnifiedLandUseFile = determineDocumentTypeFromString(xmlContent);
        let titlePrefix = ''; cadastralBlockNumber = '';
        if (isUnifiedLandUseFile) {
            const mainCadNumber = getElementValue(xmlDoc, 'extract_about_property_land > object > common_data > cad_number');
            if (mainCadNumber) { titlePrefix = mainCadNumber; cadastralBlockNumber = mainCadNumber; }
            else { const firstCadNumberElem = xmlDoc.querySelector('cad_number'); if (firstCadNumberElem) { titlePrefix = firstCadNumberElem.textContent.trim(); cadastralBlockNumber = titlePrefix; } else titlePrefix = "Единое землепользование"; }
        } else {
            let cadastralNumberElement = xmlDoc.querySelector('cadastral_blocks > cadastral_block > cadastral_number');
            if (cadastralNumberElement) { const cadastralNumber = cadastralNumberElement.textContent.trim(); const parts = cadastralNumber.split(':'); if (parts.length >= 3) { titlePrefix = parts.slice(0, 3).join(':'); cadastralBlockNumber = titlePrefix + ':'; } }
             if (!titlePrefix) { cadastralNumberElement = xmlDoc.querySelector('land_record object > common_data > cad_number'); if (cadastralNumberElement) { const cadastralNumber = cadastralNumberElement.textContent.trim(); const parts = cadastralNumber.split(':'); if (parts.length >= 3) { titlePrefix = parts.slice(0, 3).join(':'); cadastralBlockNumber = titlePrefix + ':'; } } }
             if (!titlePrefix) { // Attempt to get title from zones if available
                cadastralNumberElement = xmlDoc.querySelector('zones_and_territories_record > b_object > reg_numb_border');
                if (cadastralNumberElement) {
                    titlePrefix = cadastralNumberElement.textContent.trim();
                    // cadastralBlockNumber might not be directly applicable for zones, but we can set prefix
                }
             }
             if (!titlePrefix) titlePrefix = "Схема КПТ";
        }
        let dateFormation = '';
        let dateFormationElem = xmlDoc.querySelector('extract_cadastral_plan_territory > KPT > details_statement > date_formation');
        if (!dateFormationElem) dateFormationElem = xmlDoc.querySelector('KPT > details_statement > date_formation');
        if (!dateFormationElem) dateFormationElem = xmlDoc.querySelector('extract_about_property_land > details_statement > group_top_requisites > date_formation');
         if (!dateFormationElem) dateFormationElem = xmlDoc.querySelector('date_formation'); // Generic fallback
        if (dateFormationElem) { const rawDate = dateFormationElem.textContent.trim(); const parts = rawDate.split('-'); if (parts.length === 3) dateFormation = `${parts[2]}.${parts[1]}.${parts[0]}`; else dateFormation = rawDate; }
        let finalTitle = "Схема XML";
        if (titlePrefix && dateFormation) finalTitle = `${titlePrefix} - ${dateFormation}`;
        else if (titlePrefix) finalTitle = titlePrefix;
        else if (dateFormation) finalTitle = `от ${dateFormation}`;
        document.title = finalTitle;
    }

    function determineDocumentType(xmlDoc) {
        const rootElement = xmlDoc.documentElement;
        if (rootElement && rootElement.tagName === 'extract_cadastral_plan_territory') return false;
        if (xmlDoc.querySelector('cadastral_blocks') || xmlDoc.querySelector('cadastral_block')) return false;
        // Check for zone-specific root or characteristic elements if they are distinct for zone-only KPTs
        if (xmlDoc.querySelector('zones_and_territories_record') && !xmlDoc.querySelector('land_record') && !xmlDoc.querySelector('build_record')) return false; // Could be a KPT with only zones

        const valueElements = xmlDoc.querySelectorAll('value');
        for (const elem of valueElements) { if (elem.textContent && elem.textContent.trim() === "Единое землепользование") return true; }
        if (xmlDoc.querySelector('contour') && !xmlDoc.querySelector('contours_location') && !xmlDoc.querySelector('b_contours_location')) return true; // EUL specific
        return false; // Default to KPT (which can contain ZU, OKS, Zones)
    }

    function determineDocumentTypeFromString(xmlContent) {
        const hasExtractTag = xmlContent.includes("<extract_about_property_land");
        const hasValueTag = xmlContent.includes("<value>Единое землепользование</value>");
        if (hasExtractTag && hasValueTag) return true;
        // If it's not EUL, it's considered KPT-like (can contain ZU, OKS, Zones)
        else return false;
    }

    function flashElement(element, duration = 500, flashColor = '#00FF7F') {
        if (!element) return;
        const originalBgColor = element.style.backgroundColor;
        element.style.transition = 'background-color 0.1s ease-out';
        element.style.backgroundColor = flashColor;
        setTimeout(() => {
            element.style.backgroundColor = originalBgColor;
            setTimeout(() => { element.style.transition = ''; }, 150);
        }, duration / 2);
    }
    
    
       function updateZonesButtonVisualState() {
        const zonesButton = document.getElementById('zonesBtn');
        if (zonesButton) {
            if (showZones && visibleZoneRegNumbers.size > 0) {
                zonesButton.classList.add('active');
                zonesButton.style.backgroundColor = '#d35400'; // Active color (darker orange)
            } else {
                zonesButton.classList.remove('active');
                zonesButton.style.backgroundColor = '#f39c12'; // Default color (orange)
                if (visibleZoneRegNumbers.size === 0 && showZones) {
                     showZones = false; // Turn off if no zones are selected to be visible
                }
            }
        }
    }

          async function processXMLContent(xmlContent, fileName, cadNumberToSelectAfterLoad = null)  {
        window.xmlContent = xmlContent;
        commonLandLinksMap = {}; // Reset common land links
        const parser = new DOMParser();
        const xmlDoc = parser.parseFromString(xmlContent, "text/xml");
        isUnifiedLandUse = determineDocumentTypeFromString(xmlContent); // Determine type early

        // Populate commonLandLinksMap for KPT files
        if (!isUnifiedLandUse) {
            const landRecords = xmlDoc.querySelectorAll('land_record');
            landRecords.forEach(record => {
                const commonLandLink = getElementValue(record, 'cad_links > common_land > common_land_cad_number > cad_number');
                const isolatedParcelCadNum = getElementValue(record, 'object > common_data > cad_number');
                if (commonLandLink && isolatedParcelCadNum) {
                    if (!commonLandLinksMap[commonLandLink]) {
                        commonLandLinksMap[commonLandLink] = [];
                    }
                    commonLandLinksMap[commonLandLink].push(isolatedParcelCadNum);
                }
            });
        }

        // Reset selections and states
        selectedCadastralNumber = null;
        selectedBuildingNumber = null;
          visibleZoneRegNumbers.clear();       // NEW: Clear visible zones set
        initialZoneSelectionApplied = false; // NEW: Reset default application flag
        updateZonesButtonVisualState();      // NEW: Update button state
        selectedZoneOrTerritoryRegNumber = null;
        selectedImportedObjectIndex = -1;
        highlightedIsolatedParcels.clear();
        selectedCoordinate = null;
        selectedPoints = [];
        rulerPoints = [];
        rulerMode = false;
        const rulerBtnElement = document.getElementById('rulerBtn');
        if (rulerBtnElement) rulerBtnElement.classList.remove('active');
        const measurementPanelElement = document.getElementById('measurementPanel');
        if (measurementPanelElement) measurementPanelElement.classList.remove('active');
        updateMeasurementPanel();

        // --- Extract Contours (Parcels, Buildings, Zones) ---
        try {
            allContours = await extractAllContours(xmlContent); // Земельные участки
            // Add extra parcel data (isolated, declared, record link)
            if (!isUnifiedLandUse) {
                allContours.forEach(parcel => {
                    const landRecord = Array.from(xmlDoc.querySelectorAll('land_record')).find(r => getElementValue(r, 'object > common_data > cad_number') === parcel.cadastralNumber);
                    if (landRecord) {
                        const commonLandLinkNum = getElementValue(landRecord, 'cad_links > common_land > common_land_cad_number > cad_number');
                        parcel.isIsolatedParcel = !!commonLandLinkNum;
                        parcel.commonLandCadNumber = commonLandLinkNum || null;
                        const areaInfo = getAreaInfo(landRecord);
                        parcel.isDeclaredArea = areaInfo.isDeclaredArea;
                        if (!parcel.record) parcel.record = landRecord; // Link record if not already set
                    } else {
                         // Ensure defaults if record not found (might happen with filtering)
                         parcel.isIsolatedParcel = false;
                         parcel.commonLandCadNumber = null;
                    }
                });
            } else {
                 // Link contour element for EUL
                 allContours.forEach(parcel => {
                     if(!parcel.record){
                         const contourElement = Array.from(xmlDoc.querySelectorAll('contour')).find(c => getElementValue(c, 'cad_number') === parcel.cadastralNumber);
                         if(contourElement) parcel.record = contourElement;
                     }
                 });
            }
        } catch (error) {
            showNotification("Ошибка при извлечении контуров ЗУ: " + error.message, "error", "exclamation-circle");
            allContours = [];
        }

        try {
            buildingsContours = await extractBuildingsFromXML(xmlContent); // ОКС
        } catch (error) {
            showNotification("Ошибка при извлечении контуров ОКС: " + error.message, "error", "exclamation-circle");
            buildingsContours = [];
        }

        try {
             zonesAndTerritoriesContours = await extractZonesAndTerritoriesFromXML(xmlContent); // Зоны/Территории
             // Add subtype and other details after extraction if needed
             zonesAndTerritoriesContours.forEach(zone => {
                 if (zone.record && (!zone.typeZoneValue || !zone.zoneSubType)) {
                     const details = extractZoneOrTerritoryData(zone.record);
                     zone.typeZoneValue = details.typeZoneValue;
                     zone.zoneSubType = details.zoneSubType;
                     // Copy other relevant details if necessary
                 }
             });
        } catch (error) {
            showNotification("Ошибка при извлечении контуров зон/территорий: " + error.message, "error", "exclamation-circle");
            zonesAndTerritoriesContours = [];
        }
        // --- End Extract Contours ---


        // Update UI elements
        document.getElementById('fileInputLabel').textContent = fileName || 'Выберите файл';
        updateDocumentTitle(xmlContent); // Update browser tab title
        initCadastralInput(); // Initialize or update the search input
        displayParcelInfo(null); // Clear the main info panel initially
        const overlappingParcelsListEl = document.getElementById('overlappingParcelsList');
        if (overlappingParcelsListEl) overlappingParcelsListEl.innerHTML = ''; // Clear overlap list
         // Hide overlap section title initially
        const overlappingContainer = document.getElementById('overlappingParcelsContainer');
        if (overlappingContainer && overlappingContainer.parentElement) {
             const sectionTitle = overlappingContainer.parentElement.querySelector('.section-title');
             if(sectionTitle) sectionTitle.style.display = 'none';
        }


        const canvasEl = document.getElementById('kptSchemeCanvas');
        if (!canvasEl) {
            showNotification("Ошибка: Не найден элемент для отрисовки схемы.", "error", "times-circle");
            return;
        }
        const ctx = canvasEl.getContext('2d');

        // Draw the scheme (this will call redraw with preserveTransform=false initially)
        if (allContours.length > 0 || buildingsContours.length > 0 || zonesAndTerritoriesContours.length > 0 || importedContours.length > 0) {
             drawKPTScheme(); // This calculates initial scale/offset via redraw
        } else {
            // Clear canvas if no data
            ctx.clearRect(0, 0, canvasEl.width, canvasEl.height);
            ctx.fillStyle = 'white';
            ctx.fillRect(0, 0, canvasEl.width, canvasEl.height);
        }

        // --- Update File Info Panel ---
        let fileInfoPanel = document.getElementById('fileInfoPanel');
        const fileDetailsTextInPanel = fileInfoPanel ? fileInfoPanel.querySelector('#fileDetailsText') : null;

        if (fileInfoPanel && fileDetailsTextInPanel) {
            let registrationNumber = '';
            let dateFormation = '';
            let line1 = ''; // String for the first line (RegNum + Date)
            let line2 = ''; // String for the second line (Area)

            // Attempt to extract Registration Number
            let regNumberElem = xmlDoc.querySelector('extract_cadastral_plan_territory > KPT > details_statement > registration_number') ||
                                xmlDoc.querySelector('KPT > details_statement > registration_number') ||
                                xmlDoc.querySelector('extract_about_property_land > details_statement > group_top_requisites > registration_number') ||
                                xmlDoc.querySelector('registration_number');
            if (regNumberElem) {
                registrationNumber = regNumberElem.textContent.trim();
            }

            // Attempt to extract Date Formation
            let dateFormationElem = xmlDoc.querySelector('extract_cadastral_plan_territory > KPT > details_statement > date_formation') ||
                                  xmlDoc.querySelector('KPT > details_statement > date_formation') ||
                                  xmlDoc.querySelector('extract_about_property_land > details_statement > group_top_requisites > date_formation') ||
                                  xmlDoc.querySelector('date_formation');
            if (dateFormationElem) {
                const rawDate = dateFormationElem.textContent.trim();
                if (rawDate) {
                    const parts = rawDate.split('-');
                    dateFormation = (parts.length === 3) ? `${parts[2]}.${parts[1]}.${parts[0]}` : rawDate;
                }
            }

            // Construct Line 1
            if (registrationNumber && dateFormation) {
                line1 = `${registrationNumber} от ${dateFormation}`;
            } else if (registrationNumber) {
                line1 = registrationNumber;
            } else if (dateFormation) {
                line1 = `Дата: ${dateFormation}`;
            }

            // Attempt to extract Quarter Area (only if not EUL) and construct Line 2 with conversions
            if (!isUnifiedLandUse) {
                const quarterAreaElem = xmlDoc.querySelector('cadastral_blocks > cadastral_block > area_quarter > area');
                const quarterUnitElem = xmlDoc.querySelector('cadastral_blocks > cadastral_block > area_quarter > unit');

                if (quarterAreaElem) {
                    const quarterAreaValueStr = quarterAreaElem.textContent.trim();
                    const isHectares = quarterUnitElem && quarterUnitElem.textContent.trim() === '059';

                    if (quarterAreaValueStr) {
                        if (isHectares) {
                            // Parse the number, handle potential comma decimal separator
                            const quarterAreaHa = parseFloat(quarterAreaValueStr.replace(',', '.'));
                            if (!isNaN(quarterAreaHa)) {
                                const quarterAreaM2 = quarterAreaHa * 10000;
                                const quarterAreaKm2 = quarterAreaHa / 100;

                                // Format numbers for Russian locale
                                // Hectares: Use original string format or reformat if needed
                                const haStr = quarterAreaHa.toLocaleString('ru-RU', { minimumFractionDigits: 2, maximumFractionDigits: 4 }); // Adjust precision as needed
                                // Square Meters: Integer with separators
                                const m2Str = Math.round(quarterAreaM2).toLocaleString('ru-RU');
                                // Square Kilometers: 4 decimal places
                                const km2Str = quarterAreaKm2.toLocaleString('ru-RU', { minimumFractionDigits: 4, maximumFractionDigits: 4 });

                                // Construct the multi-unit string
                                line2 = `Площадь квартала: ${haStr} га | ${m2Str} кв.м. | ${km2Str} кв. км.`;
                            } else {
                                // Parsing failed, show original value with note
                                line2 = `Площадь квартала: ${quarterAreaValueStr}${isHectares ? ' га' : ''} (ошибка конвертации)`;
                            }
                        } else {
                            // Unit is not hectares or not specified, just show original value and unit if available
                             let unitText = quarterUnitElem ? ` (ед. ${quarterUnitElem.textContent.trim()})` : '';
                             line2 = `Площадь квартала: ${quarterAreaValueStr}${unitText}`;
                        }
                    }
                }
            }
            // --- End Area Extraction ---

            // Combine the lines with <br> if both exist
            let fullTextToDisplayHTML = '';
            if (line1 && line2) {
                fullTextToDisplayHTML = `${line1}<br>${line2}`;
            } else if (line1) {
                fullTextToDisplayHTML = line1;
            } else if (line2) {
                fullTextToDisplayHTML = line2;
            } else {
                fullTextToDisplayHTML = 'Информация о документе не найдена';
            }

            // Update the panel content using innerHTML
            fileDetailsTextInPanel.innerHTML = fullTextToDisplayHTML;
            fileInfoPanel.style.display = 'flex';

            // Re-attach listener to the new node
            const oldFileInfoPanel = fileInfoPanel;
            fileInfoPanel = oldFileInfoPanel.cloneNode(true); // Clone to ensure fresh node for listener
            oldFileInfoPanel.parentNode.replaceChild(fileInfoPanel, oldFileInfoPanel);

             // Get the text content *after* setting innerHTML for copying
             const textToCopy = fileDetailsTextInPanel.textContent || fileDetailsTextInPanel.innerText || '';

            if (line1 || line2) { // Add listener only if there is info
                const handleDblClick = function() {
                    // Copy the text version without HTML breaks
                    copyToClipboard(textToCopy.replace(/\s+/g, ' ').trim()); // Clean up extra spaces from potential line breaks
                    flashElement(this);
                };
                fileInfoPanel.addEventListener('dblclick', handleDblClick);
                fileInfoPanel.style.cursor = 'pointer';
                fileInfoPanel.title = 'Двойной клик для копирования';
            } else {
                fileInfoPanel.style.cursor = 'default';
                fileInfoPanel.removeAttribute('title');
            }
        }
        // --- End Update File Info Panel ---


        // Scroll info panel to top
        const infoPanel = document.getElementById('infoPanel');
        if (infoPanel) infoPanel.scrollTop = 0;

        // Automatically select object if requested
        if (cadNumberToSelectAfterLoad) {
            setTimeout(() => {
                const selectedSuccessfully = findAndSelectByCadastralNumber(cadNumberToSelectAfterLoad);
                if (!selectedSuccessfully) {
                    showNotification(`Не удалось автоматически выбрать объект ${cadNumberToSelectAfterLoad} после загрузки КПТ.`, 'warning', 'exclamation-triangle');
                }
            }, 300); // Delay slightly to ensure rendering is complete
        }
    }

    function generateCoordsCSV(items, itemType = 'parcel') {
        let coordsCSV = '';
        if (!items || items.length === 0) return coordsCSV;
        let previousIdentifier = null;

        items.forEach(item => {
            if (!item) return;
            const currentIdentifier = itemType === 'zone' ? item.regNumbBorder : item.cadastralNumber;
            if (!currentIdentifier) return;

            if (previousIdentifier !== null && currentIdentifier !== previousIdentifier) {
                 if (coordsCSV.length > 0 && !coordsCSV.endsWith('\n\n')) coordsCSV += '\n';
            }
            const commonLandNumber = (itemType === 'parcel' && item.commonLandCadNumber) ? item.commonLandCadNumber : '';

            if (item.contours && Array.isArray(item.contours)) {
                item.contours.forEach(contour => {
                    if (Array.isArray(contour)) {
                        contour.forEach(point => {
                            if (point && typeof point.x === 'number' && typeof point.y === 'number') {
                                const xStr = point.x.toFixed(2).replace('.', ',');
                                const yStr = point.y.toFixed(2).replace('.', ',');
                                coordsCSV += `${currentIdentifier};${xStr};${yStr};${commonLandNumber}\n`;
                            }
                        });
                    }
                });
            }
            previousIdentifier = currentIdentifier;
        });
        if (coordsCSV.endsWith('\n')) coordsCSV = coordsCSV.slice(0, -1);
        return coordsCSV;
    }


    function generateCombinedCoordsText(items) {
        let coordsText = ''; if (!items || items.length === 0) return coordsText;
        items.forEach((item) => {
            if (item.contours && Array.isArray(item.contours)) {
                item.contours.forEach((contour) => {
                     if (coordsText.length > 0) coordsText += '\n';
                    if (Array.isArray(contour)) { contour.forEach(point => { if (point && typeof point.x === 'number' && typeof point.y === 'number') coordsText += `${point.x.toFixed(2)}\t${point.y.toFixed(2)}\n`; }); }
                });
            }
        });
        if (coordsText.endsWith('\n')) coordsText = coordsText.slice(0, -1);
        return coordsText;
    }

function initCadastralInput() {
    const infoDiv = document.getElementById('selectedParcelInfo');
    let inputContainer = infoDiv.querySelector('.cadastral-input-container'); let cadastralInput;
    if (!inputContainer) {
        inputContainer = document.createElement('div'); inputContainer.className = 'cadastral-input-container';
        cadastralInput = document.createElement('input'); cadastralInput.type = 'text'; cadastralInput.id = 'cadastralInput'; cadastralInput.className = 'cadastral-input';
        inputContainer.appendChild(cadastralInput); infoDiv.insertBefore(inputContainer, infoDiv.firstChild);
    } else {
        cadastralInput = inputContainer.querySelector('#cadastralInput');
        if (!cadastralInput) { cadastralInput = document.createElement('input'); cadastralInput.type = 'text'; cadastralInput.id = 'cadastralInput'; cadastralInput.className = 'cadastral-input'; inputContainer.appendChild(cadastralInput); }
    }
    
    let initialInputValue = '';
    if (selectedCadastralNumber) initialInputValue = selectedCadastralNumber;
    else if (selectedBuildingNumber) initialInputValue = selectedBuildingNumber;
    else if (selectedZoneOrTerritoryRegNumber) initialInputValue = selectedZoneOrTerritoryRegNumber;
    else if (selectedImportedObjectIndex !== -1) initialInputValue = `Объект #${selectedImportedObjectIndex + 1}`;

    cadastralInput.value = initialInputValue;
    cadastralInput.placeholder = cadastralBlockNumber || 'Введите номер объекта';

    const newCadastralInput = cadastralInput.cloneNode(true); cadastralInput.parentNode.replaceChild(newCadastralInput, cadastralInput); cadastralInput = newCadastralInput;

    cadastralInput.addEventListener('focus', function() {
        if (this.value === '' && cadastralBlockNumber) {
            const blockParts = cadastralBlockNumber.split(':');
            if (blockParts.length === 3 || (blockParts.length === 4 && blockParts[3] === '')) { 
                this.value = cadastralBlockNumber;
                setTimeout(() => {
                    this.selectionStart = this.selectionEnd = this.value.length;
                }, 0);
            }
        }
    });
    cadastralInput.addEventListener('input', function() { formatCadastralNumber(this); });

  cadastralInput.addEventListener('keydown', async function(e) {
        if (e.key === 'Enter') {
            e.preventDefault(); const value = this.value.trim();
            let currentSelection = selectedCadastralNumber || selectedBuildingNumber; // Не учитываем selectedZoneOrTerritoryRegNumber
            if (selectedImportedObjectIndex !== -1) { // Если выбран импортированный, считаем "текущим" его
                currentSelection = `Объект #${selectedImportedObjectIndex + 1}`;
            }


            if (value === '') return;

            if (isQuarterOrBlockFormat(value)) { 
                let quarterToSearch = value;
                if (quarterToSearch.endsWith(':')) {
                    quarterToSearch = quarterToSearch.slice(0, -1);
                }
                const formattedQuarter = quarterToSearch.replace(/:/g, '_');
                await searchAndShowQuarterFiles(formattedQuarter);
            } else if (isValidCadastralNumber(value)) { 
                const enteredQuarterParts = value.split(':');
                const isStandardCadastral = !isUnifiedLandUseFormat(value);
                const enteredQuarter = isStandardCadastral && enteredQuarterParts.length >=3 ? enteredQuarterParts.slice(0, 3).join(':') : null;

                const currentLoadedQuarter = cadastralBlockNumber ? cadastralBlockNumber.slice(0, -1) : null;
                const noKptDataLoaded = allContours.length === 0 && buildingsContours.length === 0; 

                if (isStandardCadastral && (noKptDataLoaded || (enteredQuarter && currentLoadedQuarter && enteredQuarter !== currentLoadedQuarter))) {
                    if (enteredQuarterParts.length >= 3) {
                        const quarterToSearchForKPT = enteredQuarterParts.slice(0, 3).join(':');
                        const formattedQuarterForKPT = quarterToSearchForKPT.replace(/:/g, '_');
                        const loaderContainer = document.getElementById('loaderContainer');
                        updateLoaderProgress(0, 1, `Поиск КПТ для квартала ${quarterToSearchForKPT}...`);
                        if (loaderContainer) loaderContainer.style.display = 'flex';
                        try {
                            if (!supabaseInitializationPromise) initializeSupabase(); await supabaseInitializationPromise;
                            if (!supabase) { showNotification('Ошибка: Клиент базы данных не инициализирован.', 'error', 'database'); if (loaderContainer) loaderContainer.style.display = 'none'; return; }

                            const { data: fileList, error: listError } = await supabase.storage.from(BUCKET_NAME).list(null, { limit: 200, offset: 0, search: formattedQuarterForKPT });
                            if (listError) throw new Error(`Не удалось получить список файлов: ${listError.message}`);
                            const matchingFiles = fileList ? fileList.filter(file => file.name.startsWith(formattedQuarterForKPT)) : [];

                            if (matchingFiles.length > 0) {
                                const latestFile = findLatestKptFile(matchingFiles);
                                if (latestFile) {
                                    await handleOpenKpt(latestFile.name, value);
                                } else {
                                    if (loaderContainer) loaderContainer.style.display = 'none';
                                    showNotification(`Не удалось определить последний КПТ для квартала ${quarterToSearchForKPT}.`, 'warning', 'exclamation-triangle');
                                }
                            } else {
                                if (loaderContainer) loaderContainer.style.display = 'none';
                                showNotification(`КПТ для квартала ${quarterToSearchForKPT} не найдены в базе.`, 'warning', 'folder-open');
                                 if (value !== currentSelection) findAndSelectByCadastralNumber(value);
                            }
                        } catch (error) {
                            if (loaderContainer) loaderContainer.style.display = 'none';
                            showNotification(`Ошибка автозагрузки КПТ: ${error.message}`, 'error', 'exclamation-circle');
                            if (value !== currentSelection) findAndSelectByCadastralNumber(value);
                        }
                    } else {
                         if (value !== currentSelection) findAndSelectByCadastralNumber(value);
                    }
                } else {
                    if (value !== currentSelection) {
                        findAndSelectByCadastralNumber(value);
                    }
                }
            } else {
                showNotification('Некорректный формат кадастрового номера или квартала/блока', 'warning', 'exclamation-triangle');
            }
        }
    });
    cadastralInput.addEventListener('blur', function() {
        const value = this.value.trim();
        let currentSelection = selectedCadastralNumber || selectedBuildingNumber; 
        if (selectedImportedObjectIndex !== -1) {
            currentSelection = `Объект #${selectedImportedObjectIndex + 1}`;
        }

        if (value !== '' && value !== currentSelection) {
            if (isQuarterOrBlockFormat(value)) {
                // Ничего не делаем при потере фокуса, если это квартал
            } else if (isValidCadastralNumber(value)) {
                if (allContours.length > 0 || buildingsContours.length > 0 || importedContours.length > 0) { 
                    findAndSelectByCadastralNumber(value);
                }
            } else {
                showNotification('Некорректный формат кадастрового номера или квартала/блока', 'warning', 'exclamation-triangle');
                if (currentSelection) {
                    this.value = currentSelection;
                } else {
                    const blockParts = cadastralBlockNumber.split(':');
                     if (cadastralBlockNumber && (blockParts.length === 3 || (blockParts.length === 4 && blockParts[3] === ''))) {
                        this.value = cadastralBlockNumber;
                    } else {
                         this.value = '';
                    }
                }
            }
        } else if (value === '' && !currentSelection && cadastralBlockNumber) {
            const blockParts = cadastralBlockNumber.split(':');
            if (blockParts.length === 3 || (blockParts.length === 4 && blockParts[3] === '')) {
                // this.value = cadastralBlockNumber; // Опционально: восстанавливать
            }
        }
    });
}
    
     function isUnifiedLandUseFormat(cadNumber) {
        if (!cadNumber) return false;
        // Примерный паттерн для ЕЗП, где квартальная часть может состоять из нулей
        // XX:XX:0000000:YY или XX:XX:000000:YY
        const eulRegex = /^\d{2}:\d{2}:0{6,7}:\d+$/;
        return eulRegex.test(cadNumber);
    }

    function isQuarterFormat(value) { return /^\d{2}:\d{2}:$/.test(value.trim()); }
  
   

  async function searchAndShowQuarterFiles(quarterPrefix) {
    const loaderContainer = document.getElementById('loaderContainer');
    try {
        updateLoaderProgress(0, 1, `Поиск КПТ для квартала ${quarterPrefix.replace(/_/g, ':')}...`);
        if (loaderContainer) loaderContainer.style.display = 'flex';

        const response = await fetch(`${STORAGE_API_URL}/${BUCKET_NAME}?search=${quarterPrefix}`);
        if (!response.ok) {
            throw new Error(`Ошибка сети: ${response.statusText}`);
        }
        const fileList = await response.json();
        
        const matchingFiles = fileList ? fileList.filter(file => file.name.startsWith(quarterPrefix)) : [];
        if (matchingFiles.length === 0) {
            showNotification(`Не найден КПТ для квартала ${quarterPrefix.replace(/_/g, ':')}. <br>Вы можете загрузить КПТ в базу данных.`, 'warning', 'folder-open');
            if (loaderContainer) loaderContainer.style.display = 'none';
        } else {
            if (loaderContainer) loaderContainer.style.display = 'none';
            displayQuarterFilesDialog(matchingFiles, quarterPrefix.replace(/_/g, ':'));
        }
    } catch (error) {
        showNotification(`Ошибка поиска файлов: ${error.message}`, 'error', 'exclamation-circle');
        if (loaderContainer) loaderContainer.style.display = 'none';
    }
}
      function displayQuarterFilesDialog(files, quarterNumber) {
        const dialog = document.getElementById('quarterSelectDialog'); const overlay = document.getElementById('quarterSelectDialogOverlay'); const fileListDiv = document.getElementById('quarterFileList'); const title = document.getElementById('quarterDialogTitle'); const statusDiv = document.getElementById('quarterDialogStatus');
        title.textContent = `Найденные КПТ для квартала ${quarterNumber}`; fileListDiv.innerHTML = ''; statusDiv.textContent = '';
        files.sort((a, b) => b.name.localeCompare(a.name));
        if (files.length === 0) fileListDiv.innerHTML = '<p style="text-align:center; color: grey; margin-top: 20px;">Файлы не найдены.</p>';
        else {
            files.forEach(file => {
                const itemDiv = document.createElement('div'); itemDiv.className = 'quarter-list-item';
                const fileNameSpan = document.createElement('span'); fileNameSpan.className = 'quarter-file-name'; fileNameSpan.textContent = file.name;
                fileNameSpan.title = file.name; // Add title for full name on hover

                itemDiv.appendChild(fileNameSpan); // Add filename first

                const isJsonZip = file.name.toLowerCase().endsWith('.json.zip');
                if (isJsonZip) {
                    const filtersDiv = document.createElement('div');
                    filtersDiv.className = 'json-filters';
                    filtersDiv.dataset.forFile = file.name; // Link filters to the file

                    const types = [
                        { label: 'ЗУ', value: 'parcel' },
                        { label: 'ОКС', value: 'building' },
                        { label: 'Сооруж.', value: 'construction', title: 'Сооружение' } // Short label, full title
                    ];

                    types.forEach(typeInfo => {
                        const label = document.createElement('label');
                        if (typeInfo.title) label.title = typeInfo.title;
                        const checkbox = document.createElement('input');
                        checkbox.type = 'checkbox';
                        checkbox.dataset.typefilter = typeInfo.value;
                        checkbox.checked = true; // Default to checked
                        // checkbox.dataset.filename = file.name; // Redundant if filtersDiv has data-for-file
                        label.appendChild(checkbox);
                        label.appendChild(document.createTextNode(` ${typeInfo.label}`));
                        filtersDiv.appendChild(label);
                    });
                    itemDiv.appendChild(filtersDiv);
                }


                const buttonsDiv = document.createElement('div'); buttonsDiv.className = 'quarter-item-actions';
                const openBtn = document.createElement('button'); openBtn.className = 'button icon-button open-kpt-btn'; openBtn.dataset.filename = file.name; openBtn.title = 'Открыть'; openBtn.innerHTML = '<i class="fas fa-folder-open"></i>';
                openBtn.onclick = (e) => {
                    e.stopPropagation();
                    let filters = null;
                    if (isJsonZip) {
                        filters = getJsonFiltersForFile(file.name);
                        if (filters.size === 0) {
                            showNotification('Не выбраны типы объектов для загрузки из JSON.ZIP. Загрузка отменена.', 'warning', 'filter');
                            return;
                        }
                    }
                    // Pass null for cadNumberToSelectAfterLoad initially for quarter dialog opens
                    handleOpenKpt(file.name, null, filters);
                };

                const downloadBtn = document.createElement('button'); downloadBtn.className = 'button icon-button download-kpt-btn'; downloadBtn.dataset.filename = file.name; downloadBtn.title = 'Скачать'; downloadBtn.innerHTML = '<i class="fas fa-download"></i>'; downloadBtn.onclick = (e) => { e.stopPropagation(); handleDownloadKpt(file.name); };

                buttonsDiv.appendChild(openBtn); buttonsDiv.appendChild(downloadBtn);
                itemDiv.appendChild(buttonsDiv); // Add buttons last
                fileListDiv.appendChild(itemDiv);
            });
        }
        dialog.style.display = 'flex'; overlay.style.display = 'block';
        document.getElementById('closeQuarterDialogBtn').onclick = closeQuarterDialog; overlay.onclick = closeQuarterDialog;
        dialog.onclick = (e) => e.stopPropagation(); // Prevent closing when clicking inside dialog
    }

    function closeQuarterDialog() { document.getElementById('quarterSelectDialog').style.display = 'none'; document.getElementById('quarterSelectDialogOverlay').style.display = 'none'; }

    async function handleDownloadKpt(fileName) {
        if (!supabase) { showNotification('Ошибка: Клиент базы данных не инициализирован.', 'error', 'database'); return; }
        const statusDiv = document.getElementById('quarterDialogStatus'); statusDiv.textContent = `Генерация ссылки для скачивания ${fileName}...`; statusDiv.style.color = 'grey';
        try {
            const { data, error } = await supabase.storage.from(BUCKET_NAME).createSignedUrl(fileName, 3600);
            if (error) throw new Error(`Не удалось создать ссылку: ${error.message}`);
            if (!data || !data.signedUrl) throw new Error('Не удалось получить URL для скачивания от Supabase.');
            statusDiv.textContent = `Скачивание ${fileName}...`; statusDiv.style.color = 'green';
            const link = document.createElement('a'); link.href = data.signedUrl; link.download = fileName; document.body.appendChild(link); link.click(); document.body.removeChild(link);
            setTimeout(() => { statusDiv.textContent = ''; }, 2000);
        } catch (error) { statusDiv.textContent = `Ошибка скачивания: ${error.message}`; statusDiv.style.color = 'red'; showNotification(`Ошибка скачивания ${fileName}: ${error.message}`, 'error', 'exclamation-circle'); }
    }

    function findLatestKptFile(files) {
        if (!files || files.length === 0) return null;
        const sortedFiles = [...files].sort((a, b) => {
            const dateA = a.name.match(/(\d{4}-\d{2}-\d{2})/); const dateB = b.name.match(/(\d{4}-\d{2}-\d{2})/);
            if (dateA && dateB) return dateB[1].localeCompare(dateA[1]);
            return b.name.localeCompare(a.name);
        });
        return sortedFiles[0];
    }

     async function handleOpenKpt(fileName, cadNumberToSelectAfterLoad = null, jsonTypeFilters = null) {
    const loaderContainer = document.getElementById('loaderContainer');
    updateLoaderProgress(0, 1, `Загрузка файла ${fileName}...`);
    loaderContainer.style.display = 'flex';

    try {
        const response = await fetch(`${STORAGE_API_URL}/${BUCKET_NAME}/${fileName}`);
        if (!response.ok) {
            throw new Error(`Не удалось загрузить файл: ${response.statusText}`);
        }
        const blob = await response.blob();
        
        const downloadedFileObject = new File([blob], fileName, { type: blob.type || 'application/zip' });
        const fileNameLower = fileName.toLowerCase();
        
        if (fileNameLower.endsWith('.json.zip')) {
            await processJsonZipFromSupabase(downloadedFileObject, blob.size, cadNumberToSelectAfterLoad, jsonTypeFilters);
        } else if (fileNameLower.endsWith('.zip')) {
            await processXmlZipFromSupabase(downloadedFileObject, blob.size, cadNumberToSelectAfterLoad);
        } else {
            throw new Error(`Неподдерживаемый тип файла из базы: ${fileName}. Ожидался .zip или .json.zip`);
        }
    } catch (error) {
        showNotification(`Ошибка открытия файла ${fileName} из базы: ${error.message}`, 'error', 'exclamation-circle');
        if (loaderContainer) loaderContainer.style.display = 'none';
    }
}
    
    
    async function processJsonZipFromSupabase(file, fileSize, cadNumberToSelectAfterLoad = null, jsonTypeFilters = null) {
    const loaderContainer = document.getElementById('loaderContainer');
    updateLoaderProgress(0, fileSize, 'Распаковка JSON.ZIP из базы...');
    try {
        const zip = await JSZip.loadAsync(await file.arrayBuffer());
        let jsonFileEntry = Object.values(zip.files).find(
            f => f.name.match(/\d{2}_\d{2}_\d{6,7} \d{4}[_-]\d{2}[_-]\d{2}\.json$/i) && !f.dir
        );
        if (!jsonFileEntry) {
           jsonFileEntry = Object.values(zip.files).find(f => f.name.toLowerCase().endsWith('.json') && !f.dir);
        }

        if (jsonFileEntry) {
            updateLoaderProgress(fileSize, fileSize, 'Извлечение JSON из архива...');
            const jsonContentString = await jsonFileEntry.async('string');

            updateLoaderProgress(fileSize, fileSize, 'Обработка JSON...');
             setTimeout(async () => {
                try {
                    await handleJsonString(jsonContentString, jsonFileEntry.name, jsonTypeFilters); // Pass jsonTypeFilters
                     if (cadNumberToSelectAfterLoad) {
                        setTimeout(() => {
                            const selectedSuccessfully = findAndSelectByCadastralNumber(cadNumberToSelectAfterLoad);
                            if (!selectedSuccessfully) {
                                showNotification(`Не удалось автоматически выбрать объект ${cadNumberToSelectAfterLoad} после загрузки JSON.`, 'warning', 'exclamation-triangle');
                            }
                        }, 300);
                    }
                } catch (error) {
                    showNotification('Ошибка при обработке JSON из базы: ' + error.message, 'error', 'exclamation-circle');
                } finally {
                    if (loaderContainer) loaderContainer.style.display = 'none';
                }
            }, 800);

        } else {
            throw new Error('JSON-файл с ожидаемым именем не найден в архиве JSON.ZIP из базы.');
        }
    } catch (error) {
        if (loaderContainer) loaderContainer.style.display = 'none';
        showNotification('Ошибка при обработке JSON.ZIP из базы: ' + error.message, 'error', 'exclamation-circle');
    }
}

    async function processXmlZipFromSupabase(file, fileSize, cadNumberToSelectAfterLoad = null) {
        const reader = new FileReader();
        const loaderContainer = document.getElementById('loaderContainer');
        updateLoaderProgress(0, fileSize, 'Чтение XML ZIP-архива из базы...'); // Update text

        // Using a promise to make it awaitable in handleOpenKpt
        return new Promise((resolve, reject) => {
            reader.onprogress = function(e) {
                if (e.lengthComputable) updateLoaderProgress(e.loaded, fileSize, 'Чтение XML ZIP-архива');
            };
            reader.onload = function(e) {
                const zipContent = e.target.result;
                updateLoaderProgress(fileSize, fileSize, 'Обработка содержимого XML архива');
                try {
                    JSZip.loadAsync(zipContent).then(zip => {
                        let xmlFile = Object.values(zip.files).find(fileEntry => fileEntry.name.toLowerCase().endsWith('.xml') && !fileEntry.dir);
                        if (xmlFile) {
                            updateLoaderProgress(fileSize, fileSize, 'Извлечение XML из архива');
                            return xmlFile.async('string').then(xmlContent => ({ content: xmlContent, fileName: xmlFile.name, size: new Blob([xmlContent]).size }));
                        } else {
                            if (loaderContainer) loaderContainer.style.display = 'none';
                            reject(new Error('XML-файл не найден в архиве ZIP из базы.'));
                            return null; // Or Promise.reject(...)
                        }
                    })
                    .then(async result => {
                        if (result && result.content) {
                            const xmlSize = result.size;
                            updateLoaderProgress(xmlSize, xmlSize, 'Анализ XML');
                            setTimeout(async () => { // UI update delay
                                try {
                                    // If processXMLContent is not async, you might not need await here
                                    await processXMLContent(result.content, result.fileName, cadNumberToSelectAfterLoad);
                                    resolve(); // Resolve the promise on success
                                } catch (error) {
                                    showNotification('Ошибка при обработке XML из архива: ' + error.message, 'error', 'exclamation-circle');
                                    reject(error);
                                } finally {
                                    if (loaderContainer) loaderContainer.style.display = 'none';
                                }
                            }, 800);
                        } else if (result === null) {
                            // Already handled error if xmlFile was not found.
                        }
                    })
                    .catch(error => {
                        if (loaderContainer) loaderContainer.style.display = 'none';
                        showNotification('Ошибка при обработке XML ZIP-файла: ' + error.message, 'error', 'exclamation-circle');
                        reject(error);
                    });
                } catch (error) {
                    if (loaderContainer) loaderContainer.style.display = 'none';
                    showNotification('Ошибка при распаковке XML ZIP-файла: ' + error.message, 'error', 'exclamation-circle');
                    reject(error);
                }
            };
            reader.onerror = function() {
                if (loaderContainer) loaderContainer.style.display = 'none';
                showNotification('Ошибка при чтении XML ZIP-файла из базы', 'error', 'exclamation-circle');
                reject(new Error('Ошибка чтения файла из FileReader'));
            };
            reader.readAsArrayBuffer(file);
        });
    }

    function isPointInPolygon(point, polygon) {
        if (polygon.length < 3) return false; let inside = false;
        for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
            const xi = polygon[i].x, yi = polygon[i].y, xj = polygon[j].x, yj = polygon[j].y;
            const intersect = ((yi > point.y) !== (yj > point.y)) && (point.x < (xj - xi) * (point.y - yi) / (yj - yi) + xi);
            if (intersect) inside = !inside;
        }
        return inside;
    }
    
    
        function adjustColorOpacity(color, opacity) {
        if (color.startsWith('#')) { const r = parseInt(color.slice(1, 3), 16), g = parseInt(color.slice(3, 5), 16), b = parseInt(color.slice(5, 7), 16); return `rgba(${r}, ${g}, ${b}, ${opacity})`; }
        else if (color.startsWith('rgb')) return color.replace(/rgb\(/, 'rgba(').replace(/\)/, `, ${opacity})`);
        else return color;
    }

    function getContourCentroid(contour) {
        if (!contour || contour.length === 0) return { x: 0, y: 0 };
        let sumX = 0, sumY = 0; for (let point of contour) { sumX += point.x; sumY += point.y; }
        return { x: sumX / contour.length, y: sumY / contour.length };
    }

    function getShortCadastralNumber(fullCadastralNumber) {
        if (!fullCadastralNumber) return '';
        const parts = fullCadastralNumber.split(':');
        const hasSixOrSevenZeros = parts.length >= 3 && /^0{6,7}$/.test(parts[2]);
        return hasSixOrSevenZeros ? fullCadastralNumber : ':' + parts.pop();
    }
    function getShortZoneNumber(fullRegNumber) {
        if (!fullRegNumber) return '';
        const parts = fullRegNumber.split(/[.:-]/);
        return parts.length > 1 ? '.' + parts.pop() : fullRegNumber;
    }


    function addStyles() {
        const styleElement = document.createElement('style');
        styleElement.textContent = `
            .cadastral-input-container { position: relative; margin-bottom: 15px; padding: 0; }
            .cadastral-input { width: 100%; padding: 10px; font-size: 16px; font-weight: bold; border: 2px solid #336699; border-radius: 5px; background-color: #f8f8f8; color: #336699; box-sizing: border-box; transition: all 0.3s; text-align: center; }
            .cadastral-input:focus { outline: none; border-color: #4a69bd; box-shadow: 0 0 8px rgba(74, 105, 189, 0.5); background-color: white; }
            .cadastral-input-label { position: absolute; top: -10px; left: 10px; padding: 0 5px; font-size: 12px; color: #336699; background-color: white; border-radius: 3px; }
            .cadastral-input-hint { display: block; margin-top: 5px; font-size: 12px; color: #666; font-style: italic; text-align: center; }
            #openSchemeBtn { margin-top: 10px; width: 100%; padding: 10px; background-color: #2ecc71; color: white; border: none; border-radius: 5px; cursor: pointer; transition: all 0.3s; display: flex; align-items: center; justify-content: center; box-shadow: 0 2px 4px rgba(0,0,0,0.2); }
            #openSchemeBtn:hover { background-color: #27ae60; transform: translateY(-2px); box-shadow: 0 4px 8px rgba(0,0,0,0.3); }
            #openSchemeBtn:active { transform: translateY(1px); box-shadow: 0 1px 2px rgba(0,0,0,0.2); }
            #openSchemeBtn i { margin-right: 8px; }
            #openOnMapBtn { margin-bottom: 10px; }
            #showCoordinatesBtn { margin-bottom: 10px; }
        `;
        document.head.appendChild(styleElement);
    }
    addStyles();

    const sevenDigitsRegions = ['24', '63', '66', '77', '78', '91'];


    function formatCadastralNumber(input) {
        let value = input.value.replace(/[^\d]/g, ''); // Оставляем только цифры
        let formatted = '';
        let originalLength = value.length;

        // Форматируем по частям, добавляя двоеточия
        // 1. Регион (XX)
        if (originalLength > 0) {
            formatted += value.substring(0, Math.min(2, originalLength));
        }
        // 2. Район (:XX)
        if (originalLength > 2) {
            formatted += ':' + value.substring(2, Math.min(4, originalLength));
        }
        // 3. Квартал (:XXXXXX или :XXXXXXX)
        const firstTwoDigits = value.substring(0, 2);
        const isSevenDigitsRegion = sevenDigitsRegions.includes(firstTwoDigits);
        const кварталMaxLength = isSevenDigitsRegion ? 7 : 6;

        if (originalLength > 4) {
            formatted += ':' + value.substring(4, Math.min(4 + кварталMaxLength, originalLength));
        }
        // 4. Номер участка (:YYYY...)
        if (originalLength > (4 + кварталMaxLength)) {
            formatted += ':' + value.substring(4 + кварталMaxLength);
        }

        input.value = formatted;
    }



    function isQuarterOrBlockFormat(value) {
        if (!value) return false; const trimmedValue = value.trim();
        const pattern = /^(\d{2}:\d{2}:|\d{2}:\d{2}:\d{6,7}:?)$/; return pattern.test(trimmedValue);
    }

    function isValidCadastralNumber(text) {
        if (!text) return false;
        const firstTwoDigits = text.slice(0, 2); const isSevenDigits = sevenDigitsRegions.includes(firstTwoDigits);
        const digitsAfterSecondColon = isSevenDigits ? 7 : 6;
        const pattern = new RegExp(`^\\d{2}:\\d{2}:\\d{${digitsAfterSecondColon}}:\\d+$`); return pattern.test(text);
    }

function displayParcelInfo(parcelData) {
    const infoDiv = document.getElementById('selectedParcelInfo');
    const coordinatesTableContainer = document.getElementById('coordinatesTableContainer');

    // Clear previous content (table and buttons, but preserve input field structure)
    const existingTable = infoDiv.querySelector('table');
    if (existingTable) existingTable.remove();

    const buttonsToRemove = infoDiv.querySelectorAll('button.button, .button-row-flex'); // Select all buttons and the flex row
    buttonsToRemove.forEach(btn => {
        if (btn.id !== 'cadastralInput') { // Don't remove the input field if it's somehow a button
             btn.remove();
        }
    });
    coordinatesTableContainer.innerHTML = ''; // Clear coordinates table

    // Update the main input field
    let currentSelectionDisplayValue = '';
    if (parcelData) { // KPT Parcel
        currentSelectionDisplayValue = parcelData.cadNumber;
    } else if (selectedImportedObjectIndex !== -1) { // Imported Object
        currentSelectionDisplayValue = `Объект #${selectedImportedObjectIndex + 1}`;
    } else if (selectedCadastralNumber) { // KPT parcel selected but parcelData not passed (e.g. from list click)
        currentSelectionDisplayValue = selectedCadastralNumber;
    } else if (selectedBuildingNumber) { // KPT Building
        currentSelectionDisplayValue = selectedBuildingNumber; // This state usually handled by displayBuildingInfo
    } else if (selectedZoneOrTerritoryRegNumber) { // KPT Zone
        currentSelectionDisplayValue = selectedZoneOrTerritoryRegNumber; // Handled by displayZoneOrTerritoryInfo
    }


    const cadastralInput = document.getElementById('cadastralInput');
    if (cadastralInput) {
        cadastralInput.value = currentSelectionDisplayValue;
        cadastralInput.placeholder = cadastralBlockNumber || 'Введите номер объекта';
    } else {
        initCadastralInput(); // Fallback if input wasn't initialized
        const newInput = document.getElementById('cadastralInput');
        if (newInput) {
            newInput.value = currentSelectionDisplayValue;
            newInput.placeholder = cadastralBlockNumber || 'Введите номер объекта';
        }
    }

    if (parcelData) { // KPT Parcel selected
        let tableHTML = `<table>`;
        tableHTML += `<tr><td>Тип объекта</td><td class="copyable">${parcelData.objectType || 'Нет данных'}</td></tr>`;
        if (!parcelData.isUnifiedLandUse && parcelData.isIsolatedParcel && parcelData.commonLandCadNumber) {
            tableHTML += `<tr><td>Единое землепользование</td><td class="copyable clickable" data-cadnum="${parcelData.commonLandCadNumber}">${parcelData.commonLandCadNumber}</td></tr>`;
        } else if (parcelData.isUnifiedLandUse && parcelData.mainCadNumber) {
            tableHTML += `<tr><td>Единое землепользование</td><td class="copyable clickable" data-cadnum="${parcelData.mainCadNumber}">${parcelData.mainCadNumber}</td></tr>`;
            tableHTML += `<tr><td>Контур</td><td class="copyable">${parcelData.cadNumber}</td></tr>`;
        }
        tableHTML += `<tr><td>Адрес</td><td class="copyable">${parcelData.address || 'Нет данных'}</td></tr>`;
        if (!parcelData.isIsolatedParcel && parcelData.includedObjects) {
            tableHTML += `<tr><td>ОКС</td><td class="copyable">${parcelData.includedObjects}</td></tr>`;
        }
        tableHTML += `
            <tr><td>Площадь</td><td class="copyable">${parcelData.areaString || 'Нет данных'}</td></tr>
            <tr><td>Разрешенное использование</td><td class="copyable">${parcelData.permittedUse || 'Нет данных'}</td></tr>
            <tr><td>Кадастровая стоимость</td><td class="copyable">${parcelData.formattedCadastralValue}</td></tr>
            <tr><td>Категория</td><td class="copyable">${parcelData.category || 'Нет данных'}</td></tr>
        </table>
        <button id="showCoordinatesBtn" class="button"><i class="fas fa-map-marker-alt"></i> Показать координаты</button>
        <button id="openOnMapBtn" class="button"><i class="fas fa-map"></i> <span>Открыть на карте</span></button>
        <button id="openSchemeBtn" class="button"><i class="fas fa-project-diagram"></i> Открыть схему</button>
        <button id="copyCoordsBtn" class="button"><i class="fas fa-copy"></i> Копировать координаты</button>
        <div class="button-row-flex">
            <button id="openGeoeditorBtn" class="button"><i class="fas fa-drafting-compass"></i> Георедактор</button>
            
             <button id="schemeOnKptBtn" class="button"><i class="fas fa-file-image"></i> Схема на кпт</button>
            <button id="egrnBtn" class="button"><i class="fas fa-external-link-alt"></i> ЕГРН</button>
        </div>
        `;
        const tempDiv = document.createElement('div'); tempDiv.innerHTML = tableHTML; while (tempDiv.firstChild) infoDiv.appendChild(tempDiv.firstChild);
        const openMapBtn = document.getElementById('openOnMapBtn');
        if (openMapBtn) { const openMapBtnTextSpan = openMapBtn.querySelector('span'); const currentCadNum = parcelData.cadNumber; const isTatarstanRegion = currentCadNum && currentCadNum.startsWith('16:'); if (openMapBtnTextSpan) openMapBtnTextSpan.textContent = isTatarstanRegion ? 'Открыть на карте координаты' : 'Открыть на карте кадастровый номер'; }
        const rows = infoDiv.querySelectorAll('table tr');
        rows.forEach(row => { const copyableCell = row.querySelector('.copyable'); if (copyableCell) { row.addEventListener('dblclick', function() { const textToCopy = copyableCell.textContent; if (textToCopy && textToCopy !== 'Нет данных') copyToClipboard(textToCopy); }); if (copyableCell.classList.contains('clickable')) { copyableCell.style.textDecoration = 'underline'; copyableCell.style.color = '#336699'; copyableCell.addEventListener('click', function() { const cadNumToSelect = this.dataset.cadnum; if (cadNumToSelect) findAndSelectByCadastralNumber(cadNumToSelect); }); } } });
        const selectedParcelGeometry = allContours.find(p => p.cadastralNumber === parcelData.cadNumber);
        if (selectedParcelGeometry && selectedParcelGeometry.contours && selectedParcelGeometry.contours.length > 0) {
         selectedPoints = [];
            selectedParcelGeometry.contours.forEach((contour, contourIndex) => {
                if (Array.isArray(contour)) {
                    contour.forEach((point, pointIndex) => {
                        if(point && typeof point.x === 'number' && typeof point.y === 'number') {
                            selectedPoints.push({
                                contour: contourIndex + 1,
                                point: point.ord_nmb !== undefined ? point.ord_nmb : pointIndex + 1, // Use ord_nmb if available
                                x: point.x,
                                y: point.y,
                                delta: point.delta
                            });
                        }
                    });
                }
            });
            document.getElementById('showCoordinatesBtn')?.addEventListener('click', function() { const isVisible = coordinatesTableContainer.querySelector('.coordinates-table') !== null; if (isVisible) { coordinatesTableContainer.innerHTML = ''; this.innerHTML = '<i class="fas fa-map-marker-alt"></i> Показать координаты'; } else { displayCoordinatesTable(selectedPoints); this.innerHTML = '<i class="fas fa-times"></i> Скрыть координаты'; } redraw(getAdjacentParcelsForSelected(selectedCadastralNumber), getAdjacentParcelsForImported(), true, showPoints, showPoints); });
            document.getElementById('openOnMapBtn')?.addEventListener('click', function() { let textToCopy, notificationMessage; const currentCadNum = parcelData.cadNumber; const isTatarstan = currentCadNum && currentCadNum.startsWith('16:'); if (isTatarstan) { textToCopy = getGenericCoordinatesText(selectedParcelGeometry); if (textToCopy) notificationMessage = 'Координаты скопированы, открывается карта'; else { showNotification('Не удалось получить координаты для карты.', 'warning', 'exclamation-triangle'); return; } } else { textToCopy = currentCadNum; notificationMessage = `Кадастровый номер ${currentCadNum} скопирован, открывается карта`; } if (textToCopy) { copyToClipboard(textToCopy); window.open('map.html', '_blank'); showNotification(notificationMessage, 'success', 'map-marked-alt'); } });
            document.getElementById('openSchemeBtn')?.addEventListener('click', function() { const coordsText = getGenericCoordinatesText(selectedParcelGeometry); if (coordsText) { copyToClipboard(coordsText); window.open('схема.html', '_blank'); showNotification('Координаты скопированы, открывается схема', 'success', 'project-diagram'); } else showNotification('Не удалось получить координаты для схемы.', 'warning', 'exclamation-triangle'); });
            document.getElementById('openGeoeditorBtn')?.addEventListener('click', function() { openGeoeditorDialog(); }); // NEW Event Listener
            document.getElementById('schemeOnKptBtn')?.addEventListener('click', handleSchemeOnKptClick);
            document.getElementById('copyCoordsBtn')?.addEventListener('click', function() { const coordsText = getGenericCoordinatesText(selectedParcelGeometry); if (coordsText) copyToClipboard(coordsText); else showNotification('Не удалось получить координаты для копирования', 'warning', 'exclamation-triangle'); });
            document.getElementById('egrnBtn')?.addEventListener('click', function() {
                if (parcelData.cadNumber) {
                    copyToClipboard(parcelData.cadNumber);

                    window.open('zu.html', '_blank');

                    showNotification(`Кадастровый номер ${parcelData.cadNumber} скопирован, открывается ЕГРН`, 'success', 'external-link-alt');
                } else {
                    showNotification('Не удалось получить кадастровый номер.', 'warning', 'exclamation-triangle');
                }
            });
        } else {
            document.getElementById('showCoordinatesBtn')?.remove();
            document.getElementById('openOnMapBtn')?.remove();
            document.getElementById('openSchemeBtn')?.remove();
            document.getElementById('openGeoeditorBtn')?.remove(); // NEW: Remove if no geometry
            document.getElementById('copyCoordsBtn')?.remove();
            document.getElementById('egrnBtn')?.remove();
        }

    } else if (selectedImportedObjectIndex !== -1) {
        const importedObjectContour = importedContours[selectedImportedObjectIndex];
        if (importedObjectContour && importedObjectContour.length > 0) {
            const buttonsHTML = `
                <button id="showCoordinatesBtn" class="button"><i class="fas fa-map-marker-alt"></i> Показать координаты</button>
                <button id="openOnMapBtn" class="button"><i class="fas fa-map"></i> <span>Открыть на карте</span></button>
                <button id="openSchemeBtn" class="button"><i class="fas fa-project-diagram"></i> Открыть схему</button>
                <button id="copyCoordsBtn" class="button"><i class="fas fa-copy"></i> Копировать координаты</button>
                <div class="button-row-flex">
                    <button id="openGeoeditorBtn" class="button"><i class="fas fa-drafting-compass"></i> Георедактор</button>
                     <button id="schemeOnKptBtn" class="button"><i class="fas fa-file-image"></i> Схема на кпт</button>
                    <button id="egrnBtn" class="button" style="display:none;"><i class="fas fa-external-link-alt"></i> ЕГРН</button> <!-- EGRN typically needs cad number, so hide for generic imported -->
                </div>
            `;
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = buttonsHTML;
            while (tempDiv.firstChild) {
                infoDiv.appendChild(tempDiv.firstChild);
            }

            selectedPoints = [];
            importedObjectContour.forEach((point, pointIndex) => {
                if (point && typeof point.x === 'number' && typeof point.y === 'number') {
                    selectedPoints.push({ contour: 1, point: pointIndex + 1, x: point.x, y: point.y, delta: null });
                }
            });

            document.getElementById('showCoordinatesBtn')?.addEventListener('click', function() {
                const isVisible = coordinatesTableContainer.querySelector('.coordinates-table') !== null;
                if (isVisible) {
                    coordinatesTableContainer.innerHTML = '';
                    this.innerHTML = '<i class="fas fa-map-marker-alt"></i> Показать координаты';
                } else {
                    displayCoordinatesTable(selectedPoints);
                    this.innerHTML = '<i class="fas fa-times"></i> Скрыть координаты';
                }
                 redraw(getAdjacentParcelsForSelected(selectedCadastralNumber), getAdjacentParcelsForImported(), true, showPoints, showPoints);
            });

            const openMapBtn = document.getElementById('openOnMapBtn');
            if (openMapBtn) {
                const openMapBtnTextSpan = openMapBtn.querySelector('span');
                if (openMapBtnTextSpan) openMapBtnTextSpan.textContent = 'Открыть на карте координаты';
                openMapBtn.addEventListener('click', function() {
                    const coordsText = getGenericCoordinatesText(importedObjectContour);
                    if (coordsText) {
                        copyToClipboard(coordsText);
                        window.open('map.html', '_blank');
                        showNotification('Координаты скопированы, открывается карта', 'success', 'map-marked-alt');
                    } else {
                        showNotification('Не удалось получить координаты для карты.', 'warning', 'exclamation-triangle');
                    }
                });
            }
            document.getElementById('openSchemeBtn')?.addEventListener('click', function() {
                const coordsText = getGenericCoordinatesText(importedObjectContour);
                if (coordsText) {
                    copyToClipboard(coordsText);
                    window.open('схема.html', '_blank');
                    showNotification('Координаты скопированы, открывается схема', 'success', 'project-diagram');
                } else {
                    showNotification('Не удалось получить координаты для схемы.', 'warning', 'exclamation-triangle');
                }
            });
            document.getElementById('openGeoeditorBtn')?.addEventListener('click', function() { openGeoeditorDialog(); }); // NEW Event Listener
            document.getElementById('schemeOnKptBtn')?.addEventListener('click', handleSchemeOnKptClick);
            document.getElementById('copyCoordsBtn')?.addEventListener('click', function() {
                const coordsText = getGenericCoordinatesText(importedObjectContour);
                if (coordsText) {
                    copyToClipboard(coordsText);
                } else {
                    showNotification('Не удалось получить координаты для копирования', 'warning', 'exclamation-triangle');
                }
            });
        }
    }
}

function displayBuildingInfo(buildingData) {
    const infoDiv = document.getElementById('selectedParcelInfo'); const coordinatesTableContainer = document.getElementById('coordinatesTableContainer');
    const existingTable = infoDiv.querySelector('table'); if (existingTable) existingTable.remove();
    const existingButtons = infoDiv.querySelectorAll('button.button, .button-row-flex'); existingButtons.forEach(btn => btn.remove());
    coordinatesTableContainer.innerHTML = '';
    const cadastralInput = document.getElementById('cadastralInput');
    if (cadastralInput) { cadastralInput.value = buildingData ? buildingData.cadNumber : (selectedCadastralNumber || selectedBuildingNumber || selectedZoneOrTerritoryRegNumber || ''); cadastralInput.placeholder = cadastralBlockNumber || 'Введите номер объекта'; }
    else { initCadastralInput(); const newInput = document.getElementById('cadastralInput'); if (newInput) { newInput.value = buildingData ? buildingData.cadNumber : (selectedCadastralNumber || selectedBuildingNumber || selectedZoneOrTerritoryRegNumber || ''); newInput.placeholder = cadastralBlockNumber || 'Введите номер объекта'; } }
    if (buildingData) {
        const tableHTML = `<table><tr><td>Тип объекта</td><td class="copyable">${buildingData.objectType}</td></tr><tr><td>Адрес</td><td class="copyable">${buildingData.address}</td></tr><tr><td>Характеристика</td><td class="copyable">${buildingData.areaString}</td></tr><tr><td>Назначение</td><td class="copyable">${buildingData.permittedUse}</td></tr><tr><td>Кадастровая стоимость</td><td class="copyable">${buildingData.formattedCadastralValue}</td></tr></table>
        <button id="showCoordinatesBtn" class="button"><i class="fas fa-map-marker-alt"></i> Показать координаты</button>
        <button id="openOnMapBtn" class="button"><i class="fas fa-map"></i> <span>Открыть на карте</span></button>
        <button id="openSchemeBtn" class="button"><i class="fas fa-project-diagram"></i> Открыть схему</button>
        <button id="copyCoordsBtn" class="button"><i class="fas fa-copy"></i> Копировать координаты</button>
        <div class="button-row-flex">
            <button id="openGeoeditorBtn" class="button"><i class="fas fa-drafting-compass"></i> Георедактор</button>
                        <button id="schemeOnKptBtn" class="button"><i class="fas fa-file-image"></i> Схема на кпт</button>
            <button id="egrnBtn" class="button"><i class="fas fa-external-link-alt"></i> ЕГРН</button>
        </div>`;
        const tempDiv = document.createElement('div'); tempDiv.innerHTML = tableHTML; while (tempDiv.firstChild) infoDiv.appendChild(tempDiv.firstChild);
        const openMapBtn = document.getElementById('openOnMapBtn'); if (openMapBtn) { const openMapBtnTextSpan = openMapBtn.querySelector('span'); const currentCadNum = buildingData.cadNumber; const isTatarstanRegion = currentCadNum && currentCadNum.startsWith('16:'); if (openMapBtnTextSpan) openMapBtnTextSpan.textContent = isTatarstanRegion ? 'Открыть на карте координаты' : 'Открыть на карте кадастровый номер'; }
        const rows = infoDiv.querySelectorAll('table tr'); rows.forEach(row => { const copyableCell = row.querySelector('.copyable'); if (copyableCell) { row.addEventListener('dblclick', function() { const textToCopy = copyableCell.textContent; if (textToCopy && textToCopy !== 'Нет данных') copyToClipboard(textToCopy); }); } });
        const selectedBuilding = buildingsContours.find(b => b.cadastralNumber === buildingData.cadNumber);
        if (selectedBuilding && selectedBuilding.contours && selectedBuilding.contours.length > 0) {
         selectedPoints = [];
            selectedBuilding.contours.forEach((contour, contourIndex) => {
                if (Array.isArray(contour)) {
                    contour.forEach((point, pointIndex) => {
                        if(point && typeof point.x === 'number' && typeof point.y === 'number') {
                             selectedPoints.push({
                                contour: contourIndex + 1,
                                point: point.ord_nmb !== undefined ? point.ord_nmb : pointIndex + 1, // Use ord_nmb
                                x: point.x,
                                y: point.y,
                                delta: point.delta // delta might be null for JSON buildings
                            });
                        }
                    });
                }
            });
            document.getElementById('showCoordinatesBtn')?.addEventListener('click', function() { const isVisible = coordinatesTableContainer.querySelector('.coordinates-table') !== null; if (isVisible) { /*showPoints = false;*/ coordinatesTableContainer.innerHTML = ''; this.innerHTML = '<i class="fas fa-map-marker-alt"></i> Показать координаты'; } else { /*showPoints = true;*/ displayCoordinatesTable(selectedPoints); this.innerHTML = '<i class="fas fa-times"></i> Скрыть координаты'; } redraw(getAdjacentParcelsForSelected(selectedCadastralNumber), getAdjacentParcelsForImported(), true, showPoints, showPoints); });
            document.getElementById('openOnMapBtn')?.addEventListener('click', function() { let textToCopy, notificationMessage; const currentCadNum = buildingData.cadNumber; const isTatarstan = currentCadNum && currentCadNum.startsWith('16:'); if (isTatarstan) { textToCopy = getGenericCoordinatesText(selectedBuilding); if (textToCopy) notificationMessage = 'Координаты скопированы, открывается карта'; else { showNotification('Не удалось получить координаты для карты.', 'warning', 'exclamation-triangle'); return; } } else { textToCopy = currentCadNum; notificationMessage = `Кадастровый номер ${currentCadNum} скопирован, открывается карта`; } if (textToCopy) { copyToClipboard(textToCopy); window.open('map.html', '_blank'); showNotification(notificationMessage, 'success', 'map-marked-alt'); } });
            document.getElementById('openSchemeBtn')?.addEventListener('click', function() { const coordsText = getGenericCoordinatesText(selectedBuilding); if (coordsText) { copyToClipboard(coordsText); window.open('схема.html', '_blank'); showNotification('Координаты скопированы, открывается схема', 'success', 'project-diagram'); } else showNotification('Не удалось получить координаты для схемы.', 'warning', 'exclamation-triangle'); });
            document.getElementById('openGeoeditorBtn')?.addEventListener('click', function() { openGeoeditorDialog(); }); // NEW Event Listener
            document.getElementById('schemeOnKptBtn')?.addEventListener('click', handleSchemeOnKptClick);
            document.getElementById('copyCoordsBtn')?.addEventListener('click', function() { const coordsText = getGenericCoordinatesText(selectedBuilding); if (coordsText) copyToClipboard(coordsText); else showNotification('Не удалось получить координаты для копирования', 'warning', 'exclamation-triangle'); });
            document.getElementById('egrnBtn')?.addEventListener('click', function() {
                if (buildingData.cadNumber) {
                    copyToClipboard(buildingData.cadNumber);
                    window.open('zu.html', '_blank');
                    showNotification(`Кадастровый номер ${buildingData.cadNumber} скопирован, открывается ЕГРН`, 'success', 'external-link-alt');
                } else {
                    showNotification('Не удалось получить кадастровый номер.', 'warning', 'exclamation-triangle');
                }
            });
        } else {
            document.getElementById('showCoordinatesBtn')?.remove();
            document.getElementById('openOnMapBtn')?.remove();
            document.getElementById('openSchemeBtn')?.remove();
            document.getElementById('openGeoeditorBtn')?.remove(); // NEW: Remove if no geometry
            document.getElementById('copyCoordsBtn')?.remove();
            document.getElementById('egrnBtn')?.remove();
        }
    } else {
         const egrnBtn = document.getElementById('egrnBtn');
         const geoBtn = document.getElementById('openGeoeditorBtn');
        if(egrnBtn && egrnBtn.parentElement.classList.contains('button-row-flex')) egrnBtn.parentElement.remove();
        else if (egrnBtn) egrnBtn.remove();
        if(geoBtn && geoBtn.parentElement.classList.contains('button-row-flex')) geoBtn.parentElement.remove();
        else if (geoBtn) geoBtn.remove();

    }
}

// New function to display Zone/Territory Info
function displayZoneOrTerritoryInfo(zoneData) {
    const infoDiv = document.getElementById('selectedParcelInfo');
    const coordinatesTableContainer = document.getElementById('coordinatesTableContainer');
    
    // Полная очистка перед отображением новой информации
    const existingTable = infoDiv.querySelector('table');
    if (existingTable) existingTable.remove();
    const existingButtons = infoDiv.querySelectorAll('button.button, .button-row-flex');
    existingButtons.forEach(btn => btn.remove());
    coordinatesTableContainer.innerHTML = '';

    // Обновление поля ввода
    const cadastralInput = document.getElementById('cadastralInput');
    if (cadastralInput) {
        cadastralInput.value = zoneData ? zoneData.regNumbBorder : '';
        cadastralInput.placeholder = cadastralBlockNumber || 'Введите номер объекта';
    } else {
        initCadastralInput();
        const newInput = document.getElementById('cadastralInput');
        if (newInput) {
            newInput.value = zoneData ? zoneData.regNumbBorder : '';
            newInput.placeholder = cadastralBlockNumber || 'Введите номер объекта';
        }
    }

    if (zoneData) {
        // Формирование таблицы с данными из ПЕРЕДАННОГО объекта zoneData
        const tableHTML = `
            <table>
                <tr><td>Номер регистрации</td><td class="copyable">${zoneData.regNumbBorder || 'Нет данных'}</td></tr>
                <tr><td>Тип границы</td><td class="copyable">${zoneData.typeBoundaryValue || (zoneData.zoneSubType === 'quarter_boundary' ? 'Граница кадастрового квартала' : 'Нет данных')}</td></tr>
                <tr><td>Тип зоны</td><td class="copyable">${zoneData.typeZoneValue || 'Нет данных'} ${zoneData.typeZoneCode ? `(${zoneData.typeZoneCode})` : ''}</td></tr>
                ${zoneData.number ? `<tr><td>Номер зоны</td><td class="copyable">${zoneData.number}</td></tr>` : ''}
                ${zoneData.index ? `<tr><td>Индекс зоны</td><td class="copyable">${zoneData.index}</td></tr>` : ''}
                ${zoneData.nameByDoc ? `<tr><td>Наименование по документу</td><td class="copyable">${zoneData.nameByDoc}</td></tr>` : ''}
                ${zoneData.description ? `<tr><td>Описание зоны</td><td class="copyable">${zoneData.description}</td></tr>` : ''}
                ${zoneData.other ? `<tr><td>Дополнительная информация</td><td class="copyable">${zoneData.other}</td></tr>` : ''}
            </table>
            <button id="showCoordinatesBtn" class="button"><i class="fas fa-map-marker-alt"></i> Показать координаты</button>
            <button id="openOnMapBtn" class="button"><i class="fas fa-map"></i> <span>Открыть на карте</span></button>
            <button id="openSchemeBtn" class="button"><i class="fas fa-project-diagram"></i> Открыть схему</button>
            <button id="copyCoordsBtn" class="button"><i class="fas fa-copy"></i> Копировать координаты</button>
            <div class="button-row-flex">
                 <button id="openGeoeditorBtn" class="button"><i class="fas fa-drafting-compass"></i> Георедактор</button>
                  <button id="schemeOnKptBtn" class="button"><i class="fas fa-file-image"></i> Схема на кпт</button>
                 <button id="egrnBtn" class="button"><i class="fas fa-external-link-alt"></i> ЕГРН</button>
            </div>`;
        
        const tempDiv = document.createElement('div');
        tempDiv.innerHTML = tableHTML;
        while (tempDiv.firstChild) infoDiv.appendChild(tempDiv.firstChild);

        // Настройка кнопки "Открыть на карте"
        const openMapBtn = document.getElementById('openOnMapBtn');
        if (openMapBtn) {
            const openMapBtnTextSpan = openMapBtn.querySelector('span');
            const currentRegNum = zoneData.regNumbBorder;
            const isTatarstan = currentRegNum && currentRegNum.startsWith('16');
            if (openMapBtnTextSpan) openMapBtnTextSpan.textContent = isTatarstan ? 'Открыть на карте координаты' : 'Открыть на карте номер зоны';
        }

        // Добавление обработчиков для копирования по двойному клику
        const rows = infoDiv.querySelectorAll('table tr');
        rows.forEach(row => {
            const copyableCell = row.querySelector('.copyable');
            if (copyableCell) {
                row.addEventListener('dblclick', function() {
                    const textToCopy = copyableCell.textContent;
                    if (textToCopy && textToCopy !== 'Нет данных') copyToClipboard(textToCopy);
                });
            }
        });

        // Поиск геометрии для кнопок
        const selectedZoneGeometry = zonesAndTerritoriesContours.find(z => z.regNumbBorder === zoneData.regNumbBorder);

        if (selectedZoneGeometry && selectedZoneGeometry.contours && selectedZoneGeometry.contours.length > 0) {
            selectedPoints = [];
            selectedZoneGeometry.contours.forEach((contour, contourIndex) => {
                if (Array.isArray(contour)) {
                    contour.forEach((point, pointIndex) => {
                        if (point && typeof point.x === 'number' && typeof point.y === 'number') selectedPoints.push({
                            contour: contourIndex + 1,
                            point: point.ord_nmb !== undefined ? point.ord_nmb : pointIndex + 1,
                            x: point.x,
                            y: point.y,
                            delta: point.delta
                        });
                    });
                }
            });
            
            // --- НАЧАЛО ИСПРАВЛЕНИЯ ОШИБКИ ---
            // Везде, где была `selectedZone`, теперь используется `selectedZoneGeometry`
            
            document.getElementById('showCoordinatesBtn')?.addEventListener('click', function() { const isVisible = coordinatesTableContainer.querySelector('.coordinates-table') !== null; if (isVisible) { coordinatesTableContainer.innerHTML = ''; this.innerHTML = '<i class="fas fa-map-marker-alt"></i> Показать координаты'; } else { displayCoordinatesTable(selectedPoints); this.innerHTML = '<i class="fas fa-times"></i> Скрыть координаты'; } redraw(getAdjacentParcelsForSelected(selectedCadastralNumber), getAdjacentParcelsForImported(), true, showPoints, showPoints); });
            
            document.getElementById('openOnMapBtn')?.addEventListener('click', function() { let textToCopy, notificationMessage; const currentRegNum = zoneData.regNumbBorder; const isTatarstan = currentRegNum && currentRegNum.startsWith('16'); if (isTatarstan) { textToCopy = getGenericCoordinatesText(selectedZoneGeometry); if (textToCopy) notificationMessage = 'Координаты скопированы, открывается карта'; else { showNotification('Не удалось получить координаты для карты.', 'warning', 'exclamation-triangle'); return; } } else { textToCopy = currentRegNum; notificationMessage = `Номер зоны/территории ${currentRegNum} скопирован, открывается карта`; } if (textToCopy) { copyToClipboard(textToCopy); window.open('map.html', '_blank'); showNotification(notificationMessage, 'success', 'map-marked-alt'); } });
            
            document.getElementById('openSchemeBtn')?.addEventListener('click', function() { const coordsText = getGenericCoordinatesText(selectedZoneGeometry); if (coordsText) { copyToClipboard(coordsText); window.open('схема.html', '_blank'); showNotification('Координаты скопированы, открывается схема', 'success', 'project-diagram'); } else showNotification('Не удалось получить координаты для схемы.', 'warning', 'exclamation-triangle'); });
            
            document.getElementById('openGeoeditorBtn')?.addEventListener('click', function() { openGeoeditorDialog(); });
            
            document.getElementById('schemeOnKptBtn')?.addEventListener('click', handleSchemeOnKptClick);
            
            document.getElementById('copyCoordsBtn')?.addEventListener('click', function() { const coordsText = getGenericCoordinatesText(selectedZoneGeometry); if (coordsText) copyToClipboard(coordsText); else showNotification('Не удалось получить координаты для копирования', 'warning', 'exclamation-triangle'); });
            
            document.getElementById('egrnBtn')?.addEventListener('click', function() {
                if (zoneData.regNumbBorder) {
                    copyToClipboard(zoneData.regNumbBorder);
                    window.open('zu.html', '_blank');
                    showNotification(`Номер зоны/территории ${zoneData.regNumbBorder} скопирован, открывается ЕГРН`, 'success', 'external-link-alt');
                } else {
                    showNotification('Не удалось получить номер регистрации.', 'warning', 'exclamation-triangle');
                }
            });
            // --- КОНЕЦ ИСПРАВЛЕНИЯ ОШИБКИ ---

        } else {
             // Если геометрии нет, удаляем все кнопки, которые с ней работают
             document.getElementById('showCoordinatesBtn')?.remove();
             document.getElementById('openOnMapBtn')?.remove();
             document.getElementById('openSchemeBtn')?.remove();
             document.getElementById('openGeoeditorBtn')?.remove();
             document.getElementById('copyCoordsBtn')?.remove();
             document.getElementById('egrnBtn')?.remove();
        }
    } else {
        // Если вообще нет данных, удаляем кнопки георедактора и ЕГРН, если они вдруг остались
        const egrnBtn = document.getElementById('egrnBtn');
        const geoBtn = document.getElementById('openGeoeditorBtn');
        if (egrnBtn && egrnBtn.parentElement.classList.contains('button-row-flex')) egrnBtn.parentElement.remove();
        else if (egrnBtn) egrnBtn.remove();
        if (geoBtn && geoBtn.parentElement.classList.contains('button-row-flex')) geoBtn.parentElement.remove();
        else if (geoBtn) geoBtn.remove();
    }
}

    function findAndSelectParcelByCadastralNumber(cadastralNumber) { // This specifically finds ZU
        const foundParcel = allContours.find(p => p.cadastralNumber === cadastralNumber);
        if (foundParcel) {
            selectedCadastralNumber = cadastralNumber; selectedBuildingNumber = null; selectedZoneOrTerritoryRegNumber = null;
            const parser = new DOMParser(); const xmlDoc = parser.parseFromString(window.xmlContent, "text/xml");
            if (isUnifiedLandUse) { const contourElement = Array.from(xmlDoc.querySelectorAll('contour')).find(r => getElementValue(r, 'cad_number') === cadastralNumber); if (contourElement) { const parcelData = extractData(contourElement); displayParcelInfo(parcelData); } }
            else { const landRecord = Array.from(xmlDoc.querySelectorAll('land_record')).find(r => getElementValue(r, 'object > common_data > cad_number') === cadastralNumber); if (landRecord) { const parcelData = extractData(landRecord); displayParcelInfo(parcelData); } }
            const adjacentParcels = getAdjacentParcelsForSelected(selectedCadastralNumber); const adjacentParcelsForImported = getAdjacentParcelsForImported();
            centerOnSelectedParcel(foundParcel); redraw(adjacentParcels, adjacentParcelsForImported, true); return true;
        } return false;
    }
    
       function openZoneSelectionDialog() {
        if (!zonesAndTerritoriesContours || zonesAndTerritoriesContours.length === 0) {
            showNotification('Нет доступных зон/ЗОУИТ для выбора в текущем файле.', 'info', 'layer-group');
            return;
        }

        const dialog = document.getElementById('zoneSelectionDialog');
        const overlay = document.getElementById('zoneSelectionDialogOverlay');
        const listContainer = document.getElementById('zoneSelectionListContainer');
        const searchInput = document.getElementById('zoneSearchInput');
        searchInput.value = ''; // Clear search
        document.getElementById('clearZoneSearchBtn').style.display = 'none';


        if (!initialZoneSelectionApplied) {
            visibleZoneRegNumbers.clear();
            zonesAndTerritoriesContours.forEach(zone => {
                if (zone.zoneSubType !== 'territorial_zone') {
                    visibleZoneRegNumbers.add(zone.regNumbBorder);
                }
            });
            initialZoneSelectionApplied = true;
        }

        populateZoneSelectionList(); // Initial population

        dialog.style.display = 'flex';
        overlay.style.display = 'block';
    }

    function closeZoneSelectionDialog() {
        document.getElementById('zoneSelectionDialog').style.display = 'none';
        document.getElementById('zoneSelectionDialogOverlay').style.display = 'none';
    }

    function populateZoneSelectionList(filterText = '') {
        const listContainer = document.getElementById('zoneSelectionListContainer');
        listContainer.innerHTML = '';
        const lowerFilter = filterText.toLowerCase();

        const filteredAndSortedZones = zonesAndTerritoriesContours
            .filter(zone => {
                const typeMatch = zone.typeZoneValue ? zone.typeZoneValue.toLowerCase().includes(lowerFilter) : false;
                const numberMatch = zone.regNumbBorder.toLowerCase().includes(lowerFilter);
                return typeMatch || numberMatch;
            })
            .sort((a,b) => a.regNumbBorder.localeCompare(b.regNumbBorder));

        if (filteredAndSortedZones.length === 0) {
            listContainer.innerHTML = '<div class="empty-list">Зоны не найдены по вашему запросу</div>';
            return;
        }

        filteredAndSortedZones.forEach((zone, index) => {
            const listItem = document.createElement('div');
            listItem.className = 'list-item';
            const checkboxId = `zone-sel-check-${index}`;
            const isChecked = visibleZoneRegNumbers.has(zone.regNumbBorder);

            let displayType = zone.typeZoneValue || 'Неизвестный тип';
            if (zone.zoneSubType === 'territorial_zone') displayType = `Территориальная: ${displayType}`;
            else if (zone.zoneSubType === 'restricted_use_zone') displayType = `ЗОУИТ: ${displayType}`;
            else if (zone.zoneSubType === 'municipal_boundary') displayType = `МО: ${displayType}`;
            else if (zone.zoneSubType === 'inhabited_locality') displayType = `НП: ${displayType}`;


            listItem.innerHTML = `
                <input type="checkbox" id="${checkboxId}" data-regnumb="${zone.regNumbBorder}" ${isChecked ? 'checked' : ''}>
                <label for="${checkboxId}">
                    <span class="list-item-name">${zone.regNumbBorder}</span>
                    <span class="list-item-type">${displayType}</span>
                </label>
            `;
            listItem.addEventListener('click', function(e) {
                if (e.target.type !== 'checkbox') {
                    const cb = this.querySelector('input[type="checkbox"]');
                    cb.checked = !cb.checked;
                    // Manually trigger change event for consistency if needed, or handle logic directly
                    handleZoneCheckboxChange(cb);
                }
            });
             listItem.querySelector('input[type="checkbox"]').addEventListener('change', function() {
                handleZoneCheckboxChange(this);
            });
            listContainer.appendChild(listItem);
        });
    }
    
      function handleZoneCheckboxChange(checkboxElement) {
        const regNumb = checkboxElement.dataset.regnumb;
        if (checkboxElement.checked) {
            visibleZoneRegNumbers.add(regNumb);
        } else {
            visibleZoneRegNumbers.delete(regNumb);
        }
    }


function centerOnImportedObject(importedIndex) {
    const canvasEl = document.getElementById('kptSchemeCanvas');
    if (!canvasEl || importedIndex < 0 || importedIndex >= importedContours.length) return;

    const importedObjectContour = importedContours[importedIndex];
    if (!importedObjectContour || importedObjectContour.length === 0) return;

    let objectMinX = Infinity, objectMinY = Infinity, objectMaxX = -Infinity, objectMaxY = -Infinity;
    importedObjectContour.forEach(point => {
        objectMinX = Math.min(objectMinX, point.x);
        objectMinY = Math.min(objectMinY, point.y);
        objectMaxX = Math.max(objectMaxX, point.x);
        objectMaxY = Math.max(objectMaxY, point.y);
    });

    if (!isFinite(objectMinX) || !isFinite(objectMinY) || !isFinite(objectMaxX) || !isFinite(objectMaxY)) return;

    const centerX = (objectMinX + objectMaxX) / 2;
    const centerY = (objectMinY + objectMaxY) / 2;

    const objectWidth = objectMaxX - objectMinX;
    const objectHeight = objectMaxY - objectMinY;

    // Determine a suitable scale, similar to centerOnSelectedParcel/Building
    // Add a small padding if the object is very small or a point/line
    const paddedWidth = objectWidth > 1 ? objectWidth : 50; // Min effective width for scaling
    const paddedHeight = objectHeight > 1 ? objectHeight : 50; // Min effective height

    const scaleX = (canvasEl.width * 0.8) / paddedHeight; // Note: canvas width for Y data, height for X data
    const scaleY = (canvasEl.height * 0.8) / paddedWidth;
    let newScale = Math.min(scaleX, scaleY);

    const maxScale = 10; // Allow more zoom for potentially small imported objects
    if (newScale > maxScale) newScale = maxScale;
    if (newScale <= 0 || !isFinite(newScale)) newScale = scale; // Fallback to current scale if calculation is odd

    scale = newScale;

    // Recalculate minX, minY for the entire dataset if needed for transformCoord,
    // or assume they are up-to-date from a recent full redraw/bounds calculation.
    // For simplicity, we'll assume minX/minY (global bounds) are correct.
    // If not, they would need to be updated to ensure transformCoord works correctly.
    // However, the centering logic mainly uses the object's own center.

    offsetX = canvasEl.width / 2 - (centerY - minY) * scale;
    offsetY = canvasEl.height / 2 - (centerX - minX) * scale; // Corrected: (centerX - minX)

    const adjacentParcels = getAdjacentParcelsForSelected(selectedCadastralNumber);
    const adjacentParcelsForImported = getAdjacentParcelsForImported(); // This will be updated if called after adding to importedContours
    redraw(adjacentParcels, adjacentParcelsForImported, true);
}


    function isQuarterNumberFormat(identifier) {
        if (!identifier) return false;
        // Проверяет формат XX:XX:XXXXXX или XX:XX:XXXXXXX (без последнего номера участка)
        const quarterRegex = /^\d{2}:\d{2}:(\d{6}|\d{7})$/;
        return quarterRegex.test(identifier);
    }
    

async function findAndSelectByCadastralNumber(identifier) {
    // "Тотальная зачистка": перед ЛЮБЫМ новым выбором, принудительно сбрасываем ВСЕ состояния
    selectedCadastralNumber = null;
    selectedBuildingNumber = null;
    selectedZoneOrTerritoryRegNumber = null;
    selectedImportedObjectIndex = -1;
    highlightedIsolatedParcels.clear();

    let objectFound = false;
    
    // ПРИОРИТЕТНАЯ ПРОВЕРКА: это номер квартала?
    if (isQuarterNumberFormat(identifier)) {
        const foundQuarterBoundary = zonesAndTerritoriesContours.find(z =>
            z.zoneSubType === 'quarter_boundary' && z.regNumbBorder === identifier
        );

        if (foundQuarterBoundary) {
            selectedZoneOrTerritoryRegNumber = identifier;
            if (!showZones) {
                showZones = true;
                const zonesButton = document.getElementById('zonesBtn');
                if(zonesButton) {
                    zonesButton.classList.add('active');
                    zonesButton.style.backgroundColor = '#d35400';
                }
            }
            if (!visibleZoneRegNumbers.has(identifier)) {
                visibleZoneRegNumbers.add(identifier);
            }
            updateZonesButtonVisualState();

            const zoneData = extractZoneOrTerritoryData(foundQuarterBoundary.record);
            displayZoneOrTerritoryInfo(zoneData);
            centerOnSelectedZoneOrTerritory(foundQuarterBoundary);
            objectFound = true; 
        }
    }
    
    // Если приоритетный поиск не нашел квартал, запускаем общий поиск.
    if (!objectFound) {
        const foundParcelObject = allContours.find(p => p.cadastralNumber === identifier);
        const foundBuildingObject = buildingsContours.find(b => b.cadastralNumber === identifier);
        const foundZoneObject = zonesAndTerritoriesContours.find(z => z.regNumbBorder === identifier && z.zoneSubType !== 'quarter_boundary');

        if (identifier && identifier.startsWith('imported_')) {
            const importedIndexStr = identifier.split('_')[1];
            const importedIndex = parseInt(importedIndexStr, 10);
            if (!isNaN(importedIndex) && importedIndex >= 0 && importedIndex < importedContours.length) {
                selectedImportedObjectIndex = importedIndex;
                displayParcelInfo(null);
                const cadastralInput = document.getElementById('cadastralInput');
                if (cadastralInput) {
                    cadastralInput.value = `Объект #${selectedImportedObjectIndex + 1}`;
                }
                showNotification(`Выбран импортированный объект #${selectedImportedObjectIndex + 1}`, 'info', 'thumbtack');
                centerOnImportedObject(selectedImportedObjectIndex);
                objectFound = true;
            }
        } else if (foundParcelObject) {
            selectedCadastralNumber = identifier;
            let parcelData = null;
            if (foundParcelObject.isParsedFromJson && foundParcelObject.record) { 
                parcelData = extractData(foundParcelObject); 
            } else if (foundParcelObject.record) { 
                parcelData = extractData(foundParcelObject.record); 
            } else if (window.xmlContent) { 
                const parser = new DOMParser(); 
                const xmlDoc = parser.parseFromString(window.xmlContent, "text/xml"); 
                let sourceElementForData = null; 
                if (isUnifiedLandUse) { 
                    sourceElementForData = Array.from(xmlDoc.querySelectorAll('contour')).find(c => getElementValue(c, 'cad_number') === identifier); 
                } else { 
                    sourceElementForData = Array.from(xmlDoc.querySelectorAll('land_record')).find(r => getElementValue(r, 'object > common_data > cad_number') === identifier); 
                } 
                if (sourceElementForData) { 
                    parcelData = extractData(sourceElementForData); 
                }
            }
            displayParcelInfo(parcelData || { cadNumber: identifier, objectType: 'Земельный участок (данные неполные)' });
            centerOnSelectedParcel(foundParcelObject);
            objectFound = true;

        } else if (foundBuildingObject) {
            selectedBuildingNumber = identifier;
            if (!showBuildings) {
                showBuildings = true;
                const buildingsButton = document.getElementById('buildingsBtn');
                if (buildingsButton) { buildingsButton.classList.add('active'); buildingsButton.style.backgroundColor = '#3498db'; }
            }
            const buildingData = extractBuildingData(foundBuildingObject);
            displayBuildingInfo(buildingData);
            centerOnSelectedBuilding(foundBuildingObject);
            objectFound = true;

        } else if (foundZoneObject && foundZoneObject.record) {
            selectedZoneOrTerritoryRegNumber = identifier;
            if (!showZones) { 
                showZones = true; 
                const zonesButton = document.getElementById('zonesBtn'); 
                if (zonesButton) { 
                    zonesButton.classList.add('active'); 
                    zonesButton.style.backgroundColor = '#d35400'; 
                } 
            }
            if (!visibleZoneRegNumbers.has(identifier)) { 
                visibleZoneRegNumbers.add(identifier);
            }
            updateZonesButtonVisualState();
            const zoneData = extractZoneOrTerritoryData(foundZoneObject.record);
            displayZoneOrTerritoryInfo(zoneData);
            centerOnSelectedZoneOrTerritory(foundZoneObject);
            objectFound = true;

        } else if (!isUnifiedLandUse && isCommonLandFormat(identifier)) {
             if (commonLandLinksMap[identifier] && commonLandLinksMap[identifier].length > 0) {
                commonLandLinksMap[identifier].forEach(linkedKN => highlightedIsolatedParcels.add(linkedKN));
                displayCommonLandInfo(identifier, highlightedIsolatedParcels); 
                objectFound = true;
            }
        }
    } 

    if (objectFound) {
        const adjacentParcels = getAdjacentParcelsForSelected(selectedCadastralNumber);
        const adjacentParcelsForImported = getAdjacentParcelsForImported();
        redraw(adjacentParcels, adjacentParcelsForImported, true);
    } else {
        displayParcelInfo(null);
        showNotification(`Объект с идентификатором ${identifier} не найден`, 'error', 'exclamation-circle');
        const adjacentParcels = getAdjacentParcelsForSelected(null);
        const adjacentParcelsForImported = getAdjacentParcelsForImported();
        redraw(adjacentParcels, adjacentParcelsForImported, true);
    }
    
    return objectFound;
}


function getJsonFiltersForFile(fileName) {
    let selectedTypes = new Set(); // Start with empty set; if checkboxes found, only checked ones are added.
                                 // If no checkboxes are found for the file (e.g. not a JSON file, or UI error), it means load all relevant types.
    const container = document.querySelector(`.quarter-list-item .json-filters[data-for-file="${CSS.escape(fileName)}"]`);

    if (container) {
        const filterCheckboxes = container.querySelectorAll('input[type="checkbox"]');
        if (filterCheckboxes.length > 0) {
            filterCheckboxes.forEach(cb => {
                if (cb.checked) {
                    selectedTypes.add(cb.dataset.typefilter);
                }
            });
             // If after checking, no types are selected (e.g., user unchecked all),
             // it might be desirable to load nothing or default to all.
             // For now, if user unchecks all, it will load nothing of these types.
        } else {
             // No checkboxes found in the container, default to all for safety, though this path shouldn't be hit if UI is correct
            selectedTypes.add('parcel');
            selectedTypes.add('building');
            selectedTypes.add('construction');
        }
    } else {
        // No filter container for this file implies it's not a JSON file needing this specific filter,
        // or it's a direct open. For JSONs opened via quarterSelectDialog, this shouldn't happen.
        // Default to all if this function is somehow called for a non-JSON or UI is broken.
        selectedTypes.add('parcel');
        selectedTypes.add('building');
        selectedTypes.add('construction');
    }
    return selectedTypes;
}

    function displayCommonLandInfo(commonLandNumber, linkedParcelNumbers) {
        const infoDiv = document.getElementById('selectedParcelInfo'); const coordinatesTableContainer = document.getElementById('coordinatesTableContainer');
        infoDiv.innerHTML = ''; coordinatesTableContainer.innerHTML = '';
        infoDiv.innerHTML = `<div class="cadastral-input-container"><input type="text" id="cadastralInput" class="cadastral-input" value="${commonLandNumber}" placeholder="Единое землепользование" readonly></div>`;
        let infoHTML = `<div style="padding: 10px; border: 1px solid #ddd; margin-top: 10px; border-radius: 4px; background-color: #f9f9f9;"><p style="margin: 0; font-weight: bold; color: #333;">Единое землепользование:</p><p style="margin: 5px 0; font-size: 1.1em; color: indigo;">${commonLandNumber}</p><p style="margin: 0; color: #555;">Найдено <strong style="color: indigo;">${linkedParcelNumbers.size}</strong> связанных обособленных участков (выделены на карте).</p></div>`;
        infoDiv.innerHTML += infoHTML;
    }

    let selectedCoordinate = null;

    function displayCoordinatesTable(points) {
        const container = document.getElementById('coordinatesTableContainer'); if (!points || points.length === 0) { container.innerHTML = ''; return; }
        let tableHtml = `<table class="coordinates-table"><thead><tr><th>№ контура</th><th>№ точки</th><th>X</th><th>Y</th><th>Δ</th></tr></thead><tbody>`;
             points.forEach(point => {
            tableHtml += `<tr class="coordinate-row" data-x="${point.x}" data-y="${point.y}"><td>${point.contour}</td><td>${point.point}</td><td class="copyable">${point.x.toFixed(2)}</td><td class="copyable">${point.y.toFixed(2)}</td><td>${point.delta !== null && !isNaN(point.delta) ? point.delta.toFixed(1) : '-'}</td></tr>`;
        });
        tableHtml += `</tbody></table>`; container.innerHTML = tableHtml;
        const coordinateRows = container.querySelectorAll('.coordinate-row');
        coordinateRows.forEach(row => {
            row.addEventListener('dblclick', function() { const x = this.getAttribute('data-x'); const y = this.getAttribute('data-y'); copyToClipboard(`${x}, ${y}`); });
            row.addEventListener('mouseenter', function() { const x = parseFloat(this.getAttribute('data-x')); const y = parseFloat(this.getAttribute('data-y')); this.style.backgroundColor = '#ffebee'; temporaryHighlightPoint(x, y); });
            row.addEventListener('mouseleave', function() { this.style.backgroundColor = ''; redraw(getAdjacentParcelsForSelected(selectedCadastralNumber), getAdjacentParcelsForImported(), true); });
            row.addEventListener('click', function() {
                coordinateRows.forEach(r => r.classList.remove('selected-coordinate')); this.classList.add('selected-coordinate');
                const x = parseFloat(this.getAttribute('data-x')); const y = parseFloat(this.getAttribute('data-y'));
                selectedCoordinate = { x, y }; redraw(getAdjacentParcelsForSelected(selectedCadastralNumber), getAdjacentParcelsForImported(), true); selectPoint(x, y);
            });
        });
    }

    function temporaryHighlightPoint(x, y) {
        const canvasEl = document.getElementById('kptSchemeCanvas'); // Use consistent var name
        if (!canvasEl) return;
        const ctx = canvasEl.getContext('2d');
        const [pointX, pointY] = transformCoord(x, y); ctx.save(); ctx.setTransform(1, 0, 0, 1, 0, 0);
        ctx.beginPath(); ctx.arc(pointX, pointY, 6, 0, Math.PI * 2); ctx.fillStyle = 'rgba(255, 0, 0, 0.7)'; ctx.fill(); ctx.lineWidth = 1.5; ctx.strokeStyle = 'white'; ctx.stroke(); ctx.restore();
    }

    function highlightPoint(x, y) {
        const canvasEl = document.getElementById('kptSchemeCanvas'); // Use consistent var name
        if (!canvasEl) return;
        const ctx = canvasEl.getContext('2d');
        redraw(getAdjacentParcelsForSelected(selectedCadastralNumber), getAdjacentParcelsForImported(), true);
        const [pointX, pointY] = transformCoord(x, y); ctx.save(); ctx.setTransform(1, 0, 0, 1, 0, 0);
        ctx.beginPath(); ctx.arc(pointX, pointY, 6, 0, Math.PI * 2); ctx.fillStyle = 'rgba(255, 0, 0, 0.7)'; ctx.fill(); ctx.lineWidth = 1; ctx.strokeStyle = 'white'; ctx.stroke(); ctx.restore();
    }

    function selectPoint(x, y) {
        const canvasEl = document.getElementById('kptSchemeCanvas'); // Use consistent var name
        if (!canvasEl) return;
        const ctx = canvasEl.getContext('2d');
        const [pointX, pointY] = transformCoord(x, y);
        let size = 8, opacity = 1, pulseCount = 0;
        function pulse() {
            if (pulseCount > 3) return; ctx.save(); ctx.setTransform(1, 0, 0, 1, 0, 0);
            ctx.beginPath(); ctx.arc(pointX, pointY, 8, 0, Math.PI * 2); ctx.fillStyle = 'rgba(255, 0, 0, 0.8)'; ctx.strokeStyle = 'white'; ctx.lineWidth = 2; ctx.fill(); ctx.stroke();
            ctx.beginPath(); ctx.arc(pointX, pointY, size, 0, Math.PI * 2); ctx.strokeStyle = `rgba(255, 0, 0, ${opacity})`; ctx.lineWidth = 3; ctx.stroke(); ctx.restore();
            size += 3; opacity -= 0.15;
            if (opacity <= 0.1) { size = 8; opacity = 1; pulseCount++; }
            if (pulseCount < 3) requestAnimationFrame(pulse); else redraw(getAdjacentParcelsForSelected(selectedCadastralNumber), getAdjacentParcelsForImported(), true);
        }
        pulse();
    }

    function copyToClipboard(text) { navigator.clipboard.writeText(text).then(() => { showNotification(`Скопировано: ${text}`, 'success', 'check-circle'); }).catch(err => { showNotification('Ошибка при копировании', 'error', 'exclamation-circle'); }); }

    function getAdjacentParcelsForSelected(selectedCadastralNumber) {
        const adjacentParcels = new Set();
        if (selectedCadastralNumber) {
            const selectedParcel = allContours.find(p => p.cadastralNumber === selectedCadastralNumber);
            if (selectedParcel) {
                const selectedPointsFlat = selectedParcel.contours.flat();
                allContours.forEach(parcel => {
                    if (parcel.cadastralNumber !== selectedCadastralNumber) {
                        const parcelPointsFlat = parcel.contours.flat();
                        for (const sp of selectedPointsFlat) { for (const pp of parcelPointsFlat) { if (Math.abs(sp.x - pp.x) < 1e-6 && Math.abs(sp.y - pp.y) < 1e-6) { adjacentParcels.add(parcel.cadastralNumber); break; } } if (adjacentParcels.has(parcel.cadastralNumber)) break; }
                    }
                });
            }
        }
        return adjacentParcels;
    }

    function getAdjacentParcelsForImported() {
        const adjacentParcelsForImported = new Set();
        if (importedContours.length > 0) {
            const importedPointsFlat = importedContours.flat();
            allContours.forEach(parcel => {
                const parcelPointsFlat = parcel.contours.flat();
                for (const ip of importedPointsFlat) { for (const pp of parcelPointsFlat) { if (Math.abs(ip.x - pp.x) < 1e-6 && Math.abs(ip.y - pp.y) < 1e-6) { adjacentParcelsForImported.add(parcel.cadastralNumber); break; } } if (adjacentParcelsForImported.has(parcel.cadastralNumber)) break; }
            });
        }
        return adjacentParcelsForImported;
    }

    function updateCursorInfo(x, y) { const cursorCoordinates = document.getElementById('cursorCoordinates'); if (cursorCoordinates) cursorCoordinates.textContent = `X: ${x.toFixed(2)}, Y: ${y.toFixed(2)}`; }

    function handleClick(e) {
        const canvasEl = e.target; // Get canvas from event
        if (!canvasEl) return;
        const rect = canvasEl.getBoundingClientRect(); const canvasClickX = e.clientX - rect.left; const canvasClickY = e.clientY - rect.top;
        const dataClickPoint = inverseTransformCoord(canvasClickX, canvasClickY); const clickX = dataClickPoint.x; const clickY = dataClickPoint.y;
        if (rulerMode) {
            if (rulerPoints.length < 2) {
                rulerPoints.push({x: clickX, y: clickY}); updateMeasurementPanel();
                const adjacentParcels = getAdjacentParcelsForSelected(selectedCadastralNumber); const adjacentParcelsForImported = getAdjacentParcelsForImported();
                redraw(adjacentParcels, adjacentParcelsForImported, true, showPoints, showPoints);
                if (rulerPoints.length === 1) showNotification('Добавлена первая точка измерения. Выберите вторую точку.', 'info', 'ruler');
                else if (rulerPoints.length === 2) { const distance = calculateDistance(rulerPoints[0], rulerPoints[1]); showNotification(`Расстояние: ${distance.toFixed(2)} м`, 'success', 'ruler'); }
            }
            return;
        }
    }

  function drawKPTScheme() {
        const canvasEl = document.getElementById('kptSchemeCanvas');
        if (!canvasEl) {
            console.error("Canvas element #kptSchemeCanvas not found in drawKPTScheme");
            return;
        }
        const ctx = canvasEl.getContext('2d');
        const tooltip = document.getElementById('tooltip');

        canvasEl.width = canvasEl.offsetWidth;
        canvasEl.height = canvasEl.offsetHeight;

        // Важное изменение: теперь начальный расчет границ и масштаба происходит в redraw, если preserveTransform=false
        // allContours - это земельные участки
        if (!allContours.length && !importedContours.length && !zonesAndTerritoriesContours.length && !buildingsContours.length) return;

        // Вызываем redraw с preserveTransform = false, чтобы он рассчитал начальный масштаб на основе ЗУ
        const adjacentParcels = getAdjacentParcelsForSelected(selectedCadastralNumber);
        const adjacentParcelsForImported = getAdjacentParcelsForImported();
        redraw(adjacentParcels, adjacentParcelsForImported, false); // preserveTransform = false

        // Удаление и добавление слушателей событий остается здесь
        canvasEl.removeEventListener('mousedown', handleMouseDown);
        canvasEl.removeEventListener('mousemove', handleMouseMove);
        canvasEl.removeEventListener('mouseup', handleMouseUp);
        canvasEl.removeEventListener('wheel', handleWheel);
        canvasEl.removeEventListener('click', handleClick);
        canvasEl.removeEventListener('dblclick', handleDoubleClick);
        canvasEl.removeEventListener('mouseout', handleMouseOut);

        canvasEl.addEventListener('mousedown', handleMouseDown);
        canvasEl.addEventListener('mousemove', handleMouseMove);
        canvasEl.addEventListener('mouseup', handleMouseUp);
        canvasEl.addEventListener('wheel', handleWheel);
        canvasEl.addEventListener('click', handleClick);
        canvasEl.addEventListener('dblclick', handleDoubleClick);
        canvasEl.addEventListener('mouseout', handleMouseOut);

        function handleMouseDown(e) { isDragging = true; startX = e.clientX; startY = e.clientY; lastOffsetX = offsetX; lastOffsetY = offsetY; }
        function handleMouseMove(e) {
            const rect = canvasEl.getBoundingClientRect(); const canvasMouseX = e.clientX - rect.left; const canvasMouseY = e.clientY - rect.top;
            const dataMousePoint = inverseTransformCoord(canvasMouseX, canvasMouseY); const mouseX = dataMousePoint.x; const mouseY = dataMousePoint.y;
            updateCursorInfo(mouseX, mouseY);
            if (isDragging) { const deltaX = e.clientX - startX; const deltaY = e.clientY - startY; offsetX = lastOffsetX + deltaX; offsetY = lastOffsetY - deltaY; const newAdjacentParcels = getAdjacentParcelsForSelected(selectedCadastralNumber); const newAdjacentParcelsForImported = getAdjacentParcelsForImported(); redraw(newAdjacentParcels, newAdjacentParcelsForImported, true, showPoints, showPoints); }
            const pointRadius = 19 / scale; let foundPoint = null;
            importedContours.forEach((contour, contourIndex) => { contour.forEach((point, index) => { const dx = point.x - mouseX; const dy = point.y - mouseY; if (Math.sqrt(dx * dx + dy * dy) < pointRadius) { let pointColor = 'orange'; let isInsideOtherParcel = false; for (const parcel of allContours) { if (adjacentParcelsForImported.has(parcel.cadastralNumber)) continue; for (const parcelContour of parcel.contours) { if (isPointInPolygon(point, parcelContour)) { let onBoundary = false; for (let i = 0; i < parcelContour.length; i++) { const p1 = parcelContour[i]; const p2 = parcelContour[(i + 1) % parcelContour.length]; if (isPointOnSegment(point, p1, p2)) { onBoundary = true; break; } } if (!onBoundary) { isInsideOtherParcel = true; break; } } } if (isInsideOtherParcel) break; } if (isInsideOtherParcel) pointColor = 'red'; else if (adjacentParcelsForImported.size > 0) { let isCommon = false; for (const adjCadastral of adjacentParcelsForImported) { const adjParcel = allContours.find(p => p.cadastralNumber === adjCadastral); for (const adjContour of adjParcel.contours) { for (const adjPoint of adjContour) { if (Math.abs(adjPoint.x - point.x) < 1e-6 && Math.abs(adjPoint.y - point.y) < 1e-6) { isCommon = true; break; } } if (isCommon) break; } if (isCommon) break; } if (isCommon) pointColor = 'green'; } foundPoint = { index, x: point.x, y: point.y, color: pointColor }; } }); });
            if (!foundPoint) { allContours.forEach(parcel => { const isSelected = parcel.cadastralNumber === selectedCadastralNumber; const isAdjacentToSelected = adjacentParcels.has(parcel.cadastralNumber); const isAdjacentToImported = adjacentParcelsForImported.has(parcel.cadastralNumber); if (isSelected || isAdjacentToSelected || isAdjacentToImported) { parcel.contours.forEach((contour, contourIndex) => { contour.forEach((point, index) => { const dx = point.x - mouseX; const dy = point.y - mouseY; if (Math.sqrt(dx * dx + dy * dy) < pointRadius) { let pointColor = null; if (isSelected) { pointColor = 'blue'; let isInsideOtherParcel = false; for (const otherParcel of allContours) { if (otherParcel.cadastralNumber === parcel.cadastralNumber) continue; for (const otherContour of otherParcel.contours) { if (isPointInPolygon(point, otherContour)) { let onBoundary = false; for (let i = 0; i < otherContour.length; i++) { const p1 = otherContour[i]; const p2 = otherContour[(i + 1) % otherContour.length]; if (isPointOnSegment(point, p1, p2)) { onBoundary = true; break; } } if (!onBoundary) { isInsideOtherParcel = true; break; } } } if (isInsideOtherParcel) break; } if (isInsideOtherParcel) pointColor = 'red'; else if (adjacentParcels.size > 0) { let isCommon = false; for (const adjCadastral of adjacentParcels) { const adjParcel = allContours.find(p => p.cadastralNumber === adjCadastral); for (const adjContour of adjParcel.contours) { for (const adjPoint of adjContour) { if (Math.abs(adjPoint.x - point.x) < 1e-6 && Math.abs(adjPoint.y - point.y) < 1e-6) { isCommon = true; break; } } if (isCommon) break; } if (isCommon) break; } if (isCommon) pointColor = 'green'; } } else if (isAdjacentToSelected || isAdjacentToImported) { pointColor = 'black'; let isCommonWithSelected = false; let isCommonWithImported = false; if (isAdjacentToSelected && selectedCadastralNumber) { const selectedParcel = allContours.find(p => p.cadastralNumber === selectedCadastralNumber); for (const selContour of selectedParcel.contours) { for (const selPoint of selContour) { if (Math.abs(selPoint.x - point.x) < 1e-6 && Math.abs(selPoint.y - point.y) < 1e-6) { isCommonWithSelected = true; break; } } if (isCommonWithSelected) break; } } if (isAdjacentToImported && importedContours.length > 0) { for (const impContour of importedContours) { for (const impPoint of impContour) { if (Math.abs(impPoint.x - point.x) < 1e-6 && Math.abs(impPoint.y - point.y) < 1e-6) { isCommonWithImported = true; break; } } if (isCommonWithImported) break; } } if (isCommonWithSelected || isCommonWithImported) pointColor = 'green'; } foundPoint = { index, x: point.x, y: point.y, color: pointColor }; } }); }); } }); }
            if (!foundPoint && showZones && zonesAndTerritoriesContours) {
                zonesAndTerritoriesContours.forEach(zone => {
                    const isSelectedZone = zone.regNumbBorder === selectedZoneOrTerritoryRegNumber;
                    if (isSelectedZone) { // Only show tooltips for points of the selected zone
                        zone.contours.forEach((contour) => {
                            contour.forEach((point, index) => {
                                const dx = point.x - mouseX; const dy = point.y - mouseY;
                                if (Math.sqrt(dx * dx + dy * dy) < pointRadius) {
                                    foundPoint = { index: point.ordNmb !== undefined ? point.ordNmb : index + 1 , x: point.x, y: point.y, color: '#d35400' };
                                }
                            });
                        });
                    }
                });
            }
            if (foundPoint) { tooltip.style.display = 'block'; tooltip.textContent = `Точка ${foundPoint.index}.  ${foundPoint.x.toFixed(2)}\t${foundPoint.y.toFixed(2)}`; tooltip.style.left = `${e.clientX + 10}px`; tooltip.style.top = `${e.clientY + 10}px`; tooltip.style.backgroundColor = getColorWithOpacity(foundPoint.color, 0.8); tooltip.style.color = 'white'; }
            else tooltip.style.display = 'none';
        }
        function handleMouseUp() { isDragging = false; }
        function handleWheel(e) {
            e.preventDefault(); const zoom = e.deltaY < 0 ? 1.1 : 0.9; const rect = canvasEl.getBoundingClientRect();
            const mouseX = e.clientX - rect.left; const mouseY = e.clientY - rect.top; const prevScale = scale;
            offsetX = mouseX - (mouseX - offsetX) * zoom; offsetY = mouseY - (mouseY - offsetY) * zoom; scale *= zoom;
            if (Math.abs(scale - prevScale) > 1e-6) { const newAdjacentParcels = getAdjacentParcelsForSelected(selectedCadastralNumber); const newAdjacentParcelsForImported = getAdjacentParcelsForImported(); redraw(newAdjacentParcels, newAdjacentParcelsForImported, true, showPoints, showPoints); }
        }
        function handleMouseOut() { tooltip.style.display = 'none'; }
    
        canvasEl.removeEventListener('mousedown', handleMouseDown); canvasEl.removeEventListener('mousemove', handleMouseMove); canvasEl.removeEventListener('mouseup', handleMouseUp); canvasEl.removeEventListener('wheel', handleWheel); canvasEl.removeEventListener('click', handleClick); canvasEl.removeEventListener('dblclick', handleDoubleClick); canvasEl.removeEventListener('mouseout', handleMouseOut);
        canvasEl.addEventListener('mousedown', handleMouseDown); canvasEl.addEventListener('mousemove', handleMouseMove); canvasEl.addEventListener('mouseup', handleMouseUp); canvasEl.addEventListener('wheel', handleWheel); canvasEl.addEventListener('click', handleClick); canvasEl.addEventListener('dblclick', handleDoubleClick); canvasEl.addEventListener('mouseout', handleMouseOut);
    }

    function determineGridStep() {
        const possibleSteps = [0.01, 0.05, 0.1, 0.5, 1, 5, 10, 50, 100, 200, 500, 1000, 2000, 5000, 10000]; const optimalSize = 70;
        for (let i = 0; i < possibleSteps.length; i++) { const step = possibleSteps[i]; const pixelSize = step * scale; if (pixelSize >= optimalSize || i === possibleSteps.length - 1) return step; }
        return 1;
    }

    function drawGrid(ctx, gridStep) {
        if(!canvas) return; // Guard against undefined canvas
        ctx.save(); ctx.setTransform(1, 0, 0, 1, 0, 0);
        ctx.strokeStyle = 'rgba(150, 150, 150, 0.7)'; ctx.lineWidth = 0.5;
        const startX = Math.floor(minY / gridStep) * gridStep; const startY = Math.floor(minX / gridStep) * gridStep;
        const endX = Math.ceil(maxY / gridStep) * gridStep; const endY = Math.ceil(maxX / gridStep) * gridStep;
        for (let yGrid = startX; yGrid <= endX; yGrid += gridStep) {
            const [startCanvasX, startCanvasY] = transformCoord(minX, yGrid); const [endCanvasX, endCanvasY] = transformCoord(maxX, yGrid);
            ctx.beginPath(); ctx.moveTo(startCanvasX, startCanvasY); ctx.lineTo(endCanvasX, endCanvasY); ctx.stroke();
            if (gridStep >= 1) { ctx.fillStyle = 'rgba(100, 100, 100, 0.8)'; ctx.font = '10px Arial'; ctx.textAlign = 'left'; ctx.textBaseline = 'middle'; const valueText = Number.isInteger(yGrid) ? yGrid.toString() : yGrid.toFixed(2); ctx.fillText(valueText, startCanvasX + 5, startCanvasY); }
        }
        for (let xGrid = startY; xGrid <= endY; xGrid += gridStep) {
            const [startCanvasX, startCanvasY] = transformCoord(xGrid, minY); const [endCanvasX, endCanvasY] = transformCoord(xGrid, maxY);
            ctx.beginPath(); ctx.moveTo(startCanvasX, startCanvasY); ctx.lineTo(endCanvasX, endCanvasY); ctx.stroke();
            if (gridStep >= 1) { ctx.fillStyle = 'rgba(100, 100, 100, 0.8)'; ctx.font = '10px Arial'; ctx.textAlign = 'center'; ctx.textBaseline = 'top'; const valueText = Number.isInteger(xGrid) ? xGrid.toString() : xGrid.toFixed(2); ctx.fillText(valueText, startCanvasX, startCanvasY + 5); }
        }
        updateGridInfo(gridStep); ctx.restore();
    }

    function updateGridInfo(gridStep) { const gridInfoText = document.getElementById('gridStepText'); let stepText; if (gridStep < 1) stepText = `${gridStep * 100} см`; else stepText = `${gridStep} м`; gridInfoText.textContent = ` ${stepText}`; }

 function handleDoubleClick(e) {
    e.preventDefault();
    const canvasEl = e.target; if(!canvasEl) return;
    const rect = canvasEl.getBoundingClientRect();
    const canvasClickX = e.clientX - rect.left;
    const canvasClickY = e.clientY - rect.top;
    const dataClickPoint = inverseTransformCoord(canvasClickX, canvasClickY);
    const clickX = dataClickPoint.x;
    const clickY = dataClickPoint.y;

    if (rulerMode) return;

    let clickedObjects = [];

    // 1. Check Imported Objects
    if (importedContours.length > 0) {
        for (let i = importedContours.length - 1; i >= 0; i--) {
            const contour = importedContours[i];
            if (!contour || contour.length === 0) continue;
            const isSinglePoint = contour.length === 1 || (contour.length === 2 && Math.abs(contour[0].x - contour[1].x) < 1e-6 && Math.abs(contour[0].y - contour[1].y) < 1e-6);
            const isPolygon = contour.length >= 3 && checkIfClosedContour(contour);
            const lineClickThreshold = 5 / scale;
            let hit = false;
            if (isPolygon && isPointInPolygon({ x: clickX, y: clickY }, contour)) { hit = true; }
            else if (isSinglePoint) { const point = contour[0]; const pointRadius = 10 / scale; const dx = point.x - clickX; const dy = point.y - clickY; if (Math.sqrt(dx * dx + dy * dy) < pointRadius) { hit = true; } }
            else if (contour.length >= 2) { for (let j = 0; j < contour.length - 1; j++) { const p1 = contour[j]; const p2 = contour[j + 1]; if (distanceToLine(clickX, clickY, p1.x, p1.y, p2.x, p2.y) < lineClickThreshold) { hit = true; break; } } }
            if (hit) {
                clickedObjects.push({ type: 'imported', identifier: `imported_${i}`, importedIndex: i, object: contour }); // Добавляем объект для сортировки, если понадобится
            }
        }
    }

    // 2. Check Zones/Territories (if visible)
    if (showZones && zonesAndTerritoriesContours) {
        for (let i = zonesAndTerritoriesContours.length - 1; i >= 0; i--) {
            const zone = zonesAndTerritoriesContours[i];
            if (!zone || !zone.contours) continue;
            for (const contour of zone.contours) {
                if (!contour || contour.length < 3 || !checkIfClosedContour(contour)) continue; // Check for valid polygon
                if (isPointInPolygon({ x: clickX, y: clickY }, contour)) {
                    clickedObjects.push({ type: 'zone', identifier: zone.regNumbBorder, zoneObject: zone, area: calculateContourArea(contour) });
                    break; // Found in one contour of this zone, move to next zone
                }
            }
        }
    }

    // 3. Check Buildings (if visible)
    if (showBuildings && buildingsContours) {
        for (let i = buildingsContours.length - 1; i >= 0; i--) {
            const building = buildingsContours[i];
            if (!building || !building.contours) continue;
            for (const contour of building.contours) {
                if (!contour || contour.length === 0) continue;
                const isClosed = checkIfClosedContour(contour);
                const lineClickThreshold = 5 / scale;
                let hit = false;
                if (isClosed && contour.length >= 3 && isPointInPolygon({ x: clickX, y: clickY }, contour)) { hit = true; }
                else if (!isClosed && contour.length >= 2) { // Check for line
                    for (let j = 0; j < contour.length - 1; j++) { const p1 = contour[j]; const p2 = contour[j + 1]; if (distanceToLine(clickX, clickY, p1.x, p1.y, p2.x, p2.y) < lineClickThreshold) { hit = true; break; } }
                }
                if (hit) {
                    clickedObjects.push({ type: 'building', identifier: building.cadastralNumber, buildingObject: building, area: isClosed ? calculateContourArea(contour) : Infinity }); // Infinity for lines to be last
                    break;
                }
            }
        }
    }

    // 4. Check Land Parcels (always check these last if multiple layers)
    if (allContours) {
        let foundParcelsUnderClick = [];
        for (let i = 0; i < allContours.length; i++) {
            const parcel = allContours[i];
            if (!parcel || !parcel.contours) continue;
            for (const contour of parcel.contours) {
                if (contour.length >= 3 && isPointInPolygon({ x: clickX, y: clickY }, contour)) {
                    foundParcelsUnderClick.push({ parcelObject: parcel, area: calculateContourArea(contour) });
                    break; // Found in one contour of this parcel
                }
            }
        }
        if (foundParcelsUnderClick.length > 0) {
            foundParcelsUnderClick.sort((a, b) => a.area - b.area); // Smallest area first
            // Add only the smallest parcel at the click point, or all if that's preferred
            clickedObjects.push({ type: 'parcel', identifier: foundParcelsUnderClick[0].parcelObject.cadastralNumber, parcelObject: foundParcelsUnderClick[0].parcelObject, area: foundParcelsUnderClick[0].area });
        }
    }

    // --- Process Clicked Objects ---
    if (clickedObjects.length === 0) { // Clicked on empty space
        selectedCadastralNumber = null; selectedBuildingNumber = null; selectedZoneOrTerritoryRegNumber = null; selectedImportedObjectIndex = -1; highlightedIsolatedParcels.clear();
        displayParcelInfo(null);
        redraw(new Set(), getAdjacentParcelsForImported(), true, false, false);
    } else if (clickedObjects.length === 1) { // Only one object found
        const obj = clickedObjects[0];
        findAndSelectByCadastralNumber(obj.identifier); // This function already handles different types
    } else { // Multiple objects found
        // Sort by area (smallest first), then by type priority (e.g., imported, parcel, building, zone)
        clickedObjects.sort((a, b) => {
            const areaA = a.area !== undefined ? a.area : (a.type === 'imported' ? -1 : Infinity); // Imported objects or lines first
            const areaB = b.area !== undefined ? b.area : (b.type === 'imported' ? -1 : Infinity);
            if (areaA !== areaB) return areaA - areaB;

            const typePriority = { 'imported': 0, 'parcel': 1, 'building': 2, 'zone': 3 };
            return (typePriority[a.type] || 99) - (typePriority[b.type] || 99);
        });
        showObjectSelectionDialog(clickedObjects, clickX, clickY);
    }
}
    
    function centerOnSelectedParcel(parcel) {
        const canvasEl = document.getElementById('kptSchemeCanvas');
        if (!canvasEl || !parcel || !parcel.contours || parcel.contours.length === 0) return;
        let parcelMinX = Infinity, parcelMinY = Infinity, parcelMaxX = -Infinity, parcelMaxY = -Infinity;
        parcel.contours.forEach(contour => { contour.forEach(point => { parcelMinX = Math.min(parcelMinX, point.x); parcelMinY = Math.min(parcelMinY, point.y); parcelMaxX = Math.max(parcelMaxX, point.x); parcelMaxY = Math.max(parcelMaxY, point.y); }); });
        const centerX = (parcelMinX + parcelMaxX) / 2; const centerY = (parcelMinY + parcelMaxY) / 2;
        const scaleX = (canvasEl.width * 0.8) / (parcelMaxY - parcelMinY); const scaleY = (canvasEl.height * 0.8) / (parcelMaxX - parcelMinX);
        scale = Math.min(scaleX, scaleY); const maxScale = 5; if (scale > maxScale) scale = maxScale;
        offsetX = canvasEl.width/2 - (centerY - minY) * scale; offsetY = canvasEl.height/2 - (centerX - minX) * scale;
    }

    function centerOnSelectedBuilding(building) {
        const canvasEl = document.getElementById('kptSchemeCanvas');
        if (!canvasEl || !building || !building.contours || building.contours.length === 0) return;
        let buildingMinX = Infinity, buildingMinY = Infinity, buildingMaxX = -Infinity, buildingMaxY = -Infinity;
        building.contours.forEach(contour => { contour.forEach(point => { buildingMinX = Math.min(buildingMinX, point.x); buildingMinY = Math.min(buildingMinY, point.y); buildingMaxX = Math.max(buildingMaxX, point.x); buildingMaxY = Math.max(buildingMaxY, point.y); }); });
        const centerX = (buildingMinX + buildingMaxX) / 2; const centerY = (buildingMinY + buildingMaxY) / 2;
        const buildingWidth = buildingMaxX - buildingMinX; const buildingHeight = buildingMaxY - buildingMinY;
        const isTinyOrLinear = (buildingWidth < 5 || buildingHeight < 5); const areaMultiplier = isTinyOrLinear ? 0.3 : 0.8;
        const scaleX = (canvasEl.width * areaMultiplier) / buildingHeight; const scaleY = (canvasEl.height * areaMultiplier) / buildingWidth;
        scale = Math.min(scaleX, scaleY); const maxScale = isTinyOrLinear ? 10 : 5; if (scale > maxScale) scale = maxScale;
        offsetX = canvasEl.width/2 - (centerY - minY) * scale; offsetY = canvasEl.height/2 - (centerX - minX) * scale;
    }

    function centerOnSelectedZoneOrTerritory(zone) {
        const canvasEl = document.getElementById('kptSchemeCanvas');
        if (!canvasEl || !zone || !zone.contours || zone.contours.length === 0) return;
        let zoneMinX = Infinity, zoneMinY = Infinity, zoneMaxX = -Infinity, zoneMaxY = -Infinity;
        zone.contours.forEach(contour => { contour.forEach(point => { zoneMinX = Math.min(zoneMinX, point.x); zoneMinY = Math.min(zoneMinY, point.y); zoneMaxX = Math.max(zoneMaxX, point.x); zoneMaxY = Math.max(zoneMaxY, point.y); }); });
        const centerX = (zoneMinX + zoneMaxX) / 2; const centerY = (zoneMinY + zoneMaxY) / 2;
        // const zoneWidth = zoneMaxX - zoneMinX; const zoneHeight = zoneMaxY - zoneMinY; // Not directly used for scaling logic here
        const areaMultiplier = 0.8;
        const scaleX = (canvasEl.width * areaMultiplier) / (zoneMaxY - zoneMinY); // Use actual height/width for scaling
        const scaleY = (canvasEl.height * areaMultiplier) / (zoneMaxX - zoneMinX);
        scale = Math.min(scaleX, scaleY); const maxScale = 5; if (scale > maxScale) scale = maxScale;
        offsetX = canvasEl.width/2 - (centerY - minY) * scale; offsetY = canvasEl.height/2 - (centerX - minX) * scale;
    }

    function distanceToLine(x, y, x1, y1, x2, y2) {
        const A = x - x1, B = y - y1, C = x2 - x1, D = y2 - y1; const dot = A * C + B * D; const len_sq = C * C + D * D;
        let param = -1; if (len_sq != 0) param = dot / len_sq;
        let xx, yy;
        if (param < 0) { xx = x1; yy = y1; } else if (param > 1) { xx = x2; yy = y2; } else { xx = x1 + param * C; yy = y1 + param * D; }
        const dx = x - xx, dy = y - yy; return Math.sqrt(dx * dx + dy * dy);
    }

    document.getElementById('togglePointsBtn').addEventListener('click', function() {
        showPoints = !showPoints; this.style.backgroundColor = showPoints ? '#e74c3c' : '#7f8c8d';
        const adjacentParcels = getAdjacentParcelsForSelected(selectedCadastralNumber); const adjacentParcelsForImported = getAdjacentParcelsForImported();
        redraw(adjacentParcels, adjacentParcelsForImported, true, showPoints, showPoints);
        showNotification(showPoints ? 'Точки включены' : 'Точки отключены', 'info', showPoints ? 'eye' : 'eye-slash');
        localStorage.setItem('showPoints', showPoints);
    });

function redraw(adjacentParcels, adjacentParcelsForImported, preserveTransform = false, showAdjacents = true, showPointsFlag = true) {
        const canvasEl = document.getElementById('kptSchemeCanvas');
        if (!canvasEl) {
            console.error("Canvas element not found in redraw().");
            return;
        }
        const ctx = canvasEl.getContext('2d');

        canvasEl.width = canvasEl.offsetWidth;
        canvasEl.height = canvasEl.offsetHeight;

        ctx.setTransform(1, 0, 0, 1, 0, 0);
        ctx.clearRect(0, 0, canvasEl.width, canvasEl.height);
        ctx.fillStyle = 'white';
        ctx.fillRect(0, 0, canvasEl.width, canvasEl.height);

        if (!allContours.length && !importedContours.length && !buildingsContours.length && !zonesAndTerritoriesContours.length) return;

        if (!preserveTransform) {
            let pointsForBoundsCalculation = [];
            if (allContours.length > 0) {
                allContours.forEach(p => p.contours.forEach(c => pointsForBoundsCalculation.push(...c)));
            } else {
                 importedContours.forEach(c => pointsForBoundsCalculation.push(...c));
                 buildingsContours.forEach(b => b.contours.forEach(c => pointsForBoundsCalculation.push(...c)));
                 zonesAndTerritoriesContours.forEach(z => z.contours.forEach(c => pointsForBoundsCalculation.push(...c)));
            }

            if (pointsForBoundsCalculation.length > 0) {
                 const validXs = pointsForBoundsCalculation.map(p => p.x).filter(isFinite);
                 const validYs = pointsForBoundsCalculation.map(p => p.y).filter(isFinite);
                 if(validXs.length > 0 && validYs.length > 0){
                     minX = Math.min(...validXs); minY = Math.min(...validYs); maxX = Math.max(...validXs); maxY = Math.max(...validYs);
                     const width = (maxX - minX) || 1; const height = (maxY - minY) || 1;
                     const scaleX = canvasEl.width / height * 0.9; const scaleY = canvasEl.height / width * 0.9;
                     scale = Math.min(scaleX, scaleY); scale = Math.max(1e-6, Math.min(scale, 50));
                     if (!isFinite(scale) || scale <=0) scale = 1;
                     offsetX = (canvasEl.width - (maxY - minY) * scale) / 2;
                     offsetY = (canvasEl.height - (maxX - minX) * scale) / 2;
                 } else { scale = 1; minX = 0; minY = 0; maxX = canvasEl.width; maxY = canvasEl.height; offsetX = 0; offsetY = 0; }
            } else { scale = 1; minX = 0; minY = 0; maxX = canvasEl.width; maxY = canvasEl.height; offsetX = 0; offsetY = 0; }
         }

        if (isGridVisible) { const gridStep = determineGridStep(); drawGrid(ctx, gridStep); }

        // Draw Parcels (allContours)
        allContours.forEach(parcel => {
            const isSelectedXMLParcel = parcel.cadastralNumber === selectedCadastralNumber;
            const isAdjacentToSelectedXML = isSelectedXMLParcel ? false : (adjacentParcels.has(parcel.cadastralNumber) && showAdjacents);
            const isHighlightedCommonLandParcel = highlightedIsolatedParcels.has(parcel.cadastralNumber);

            parcel.contours.forEach(contour => {
                if (contour.length < 2) return;
                let contourPath = new Path2D();
                contour.forEach((point, index) => { const [canvasX, canvasY] = transformCoord(point.x, point.y); if (index === 0) contourPath.moveTo(canvasX, canvasY); else contourPath.lineTo(canvasX, canvasY); });
                const isClosed = checkIfClosedContour(contour);
                if (isClosed && contour.length > 2) contourPath.closePath();

                ctx.save();
                ctx.setTransform(1, 0, 0, 1, 0, 0);

                let parcelStrokeColor;
                let parcelLineWidth = 1.5;
                let parcelFillStyle = null;

                const isPreciseContour = contour.length > 0 && contour.every(point => point && point.delta === 0.1);
                let baseColor = parcel.isDeclaredArea ? 'red' : (isPreciseContour ? '#00FF00' : 'green');

                if (isHighlightedCommonLandParcel) {
                    parcelStrokeColor = 'indigo';
                    parcelLineWidth = 2.0;
                } else if (isSelectedXMLParcel) {
                    parcelStrokeColor = baseColor;
                    parcelLineWidth = 2.0;
                    parcelFillStyle = 'rgba(173, 216, 230, 0.5)';
                } else if (selectedImportedObjectIndex !== -1) {
                    parcelStrokeColor = adjustColorOpacity(baseColor, 0.9);
                    parcelLineWidth = 1.5;
                    parcelFillStyle = null;
                } else if (isAdjacentToSelectedXML && !selectedZoneOrTerritoryRegNumber && !selectedBuildingNumber) {
                    parcelStrokeColor = baseColor;
                    parcelFillStyle = 'rgba(144, 238, 144, 0.5)';
                } else if ( (selectedZoneOrTerritoryRegNumber || selectedBuildingNumber || (highlightedIsolatedParcels.size > 0 && !isHighlightedCommonLandParcel)) && !isSelectedXMLParcel ) {
                    parcelStrokeColor = adjustColorOpacity(baseColor, 0.5);
                    parcelLineWidth = 1.2;
                    parcelFillStyle = parcel.isDeclaredArea ? 'rgba(255, 0, 0, 0.05)' : 'rgba(0, 128, 0, 0.02)';
                } else {
                    parcelStrokeColor = baseColor;
                }

                if (parcelFillStyle && isClosed && contour.length > 2) {
                    ctx.fillStyle = parcelFillStyle;
                    ctx.fill(contourPath);
                }
                ctx.strokeStyle = parcelStrokeColor;
                ctx.lineWidth = parcelLineWidth;
                ctx.stroke(contourPath);
                ctx.restore();
            });
        });


                 if (showZones && zonesAndTerritoriesContours && zonesAndTerritoriesContours.length > 0 && visibleZoneRegNumbers.size > 0) {
            zonesAndTerritoriesContours.forEach(zone => {
                if (visibleZoneRegNumbers.has(zone.regNumbBorder)) {
                    const isSelectedZone = zone.regNumbBorder === selectedZoneOrTerritoryRegNumber;

                    let zoneStrokeOpacityCurrent = 1.0;
                    let zoneFillOpacityCurrent = isSelectedZone ? 0.4 : 0.15;
                    let zoneLineWidthCurrent = isSelectedZone ? 2.5 : 1.5;
                    let zonePointColorAlphaCurrent = 1.0;

                    if (selectedImportedObjectIndex !== -1 && !isSelectedZone) {
                        zoneStrokeOpacityCurrent = 0.9;
                        zoneFillOpacityCurrent = 0.1;
                        zoneLineWidthCurrent = 1.5;
                        zonePointColorAlphaCurrent = 0;
                    } else if ((selectedCadastralNumber || selectedBuildingNumber || highlightedIsolatedParcels.size > 0) && !isSelectedZone) {
                        zoneStrokeOpacityCurrent = 0.5;
                        zoneFillOpacityCurrent = 0.05;
                        zoneLineWidthCurrent = 1.0;
                        zonePointColorAlphaCurrent = 0;
                    }

                    let zoneBaseColorRGB = '243, 156, 18'; // Default orange
                    let useLineDash = false;

                    if (zone.zoneSubType === 'territorial_zone') zoneBaseColorRGB = '46, 204, 113';
                    else if (zone.zoneSubType === 'restricted_use_zone') zoneBaseColorRGB = '231, 76, 60';
                    else if (zone.zoneSubType === 'municipal_boundary') zoneBaseColorRGB = '142, 68, 173';
                    else if (zone.zoneSubType === 'inhabited_locality') zoneBaseColorRGB = '52, 152, 219';
                    else if (zone.zoneSubType === 'quarter_boundary') {
                        zoneBaseColorRGB = '127, 140, 141'; // Grey color
                        useLineDash = true;
                    }

                    const zonePointColor = `rgba(${zoneBaseColorRGB}, ${isSelectedZone ? zonePointColorAlphaCurrent : 0.7 * zonePointColorAlphaCurrent})`;

                    zone.contours.forEach(contour => {
                        if (contour.length < 1) return; // Пропускаем пустые контуры
                        
                        let contourPath = new Path2D();
                        contour.forEach((point, index) => { 
                            const [canvasX, canvasY] = transformCoord(point.x, point.y); 
                            if (index === 0) {
                                contourPath.moveTo(canvasX, canvasY);
                            } else {
                                contourPath.lineTo(canvasX, canvasY);
                            }
                        });

                        const isClosed = checkIfClosedContour(contour); 
                        if (isClosed && contour.length > 2) {
                            contourPath.closePath();
                        }

                        ctx.save();
                        ctx.setTransform(1, 0, 0, 1, 0, 0);

                        if (useLineDash) {
                            ctx.setLineDash([10, 5]);
                        }

                        if (isClosed) {
                            ctx.fillStyle = `rgba(${zoneBaseColorRGB}, ${zoneFillOpacityCurrent})`;
                            ctx.fill(contourPath);
                        }
                        ctx.strokeStyle = `rgba(${zoneBaseColorRGB}, ${zoneStrokeOpacityCurrent})`;
                        ctx.lineWidth = zoneLineWidthCurrent;
                        ctx.stroke(contourPath);
                        ctx.restore(); // restore сбросит setLineDash автоматически

                        // Тут можно добавить логику отрисовки точек для зон, если нужно
                    });
                }
            });
        }

        const shouldDrawXmlPoints = showPointsFlag && (selectedCadastralNumber || adjacentParcels.size > 0 || highlightedIsolatedParcels.size > 0) && selectedImportedObjectIndex === -1 && !selectedZoneOrTerritoryRegNumber;
        if (shouldDrawXmlPoints) {
            allContours.forEach(parcel => {
                const isSelected = parcel.cadastralNumber === selectedCadastralNumber; const isAdjacentToSelected = adjacentParcels.has(parcel.cadastralNumber) && showAdjacents; const isAdjacentToImported = adjacentParcelsForImported.has(parcel.cadastralNumber); const isHighlightedCommon = highlightedIsolatedParcels.has(parcel.cadastralNumber);
                if (isSelected || isAdjacentToSelected || isAdjacentToImported || isHighlightedCommon) {
                     parcel.contours.forEach(contour => {
                         contour.forEach((point) => {
                               const [canvasX, canvasY] = transformCoord(point.x, point.y); let pointColor = null;
                               if (isHighlightedCommon) {
                                   pointColor = 'indigo';
                               } else if (isSelected) {
                                   pointColor = 'blue';
                                   let isInsideOtherParcel = false;
                                   for (const otherParcel of allContours) {
                                       if (otherParcel.cadastralNumber === parcel.cadastralNumber) continue;
                                       for (const otherContour of otherParcel.contours) {
                                           if (isPointInPolygon(point, otherContour)) {
                                               let onBoundary = false;
                                               for (let k = 0; k < otherContour.length; k++) {
                                                   const p1 = otherContour[k];
                                                   const p2 = otherContour[(k + 1) % otherContour.length];
                                                   if (isPointOnSegment(point, p1, p2)) {
                                                       onBoundary = true;
                                                       break;
                                                   }
                                               }
                                               if (!onBoundary) {
                                                   isInsideOtherParcel = true;
                                                   break;
                                               }
                                           }
                                       }
                                       if (isInsideOtherParcel) break;
                                   }
                                   if (isInsideOtherParcel) {
                                       pointColor = 'red';
                                   } else if (adjacentParcels.size > 0 || adjacentParcelsForImported.size > 0) {
                                       let isCommon = false;
                                       for (const adjCadastral of adjacentParcels) {
                                           const adjParcel = allContours.find(p => p.cadastralNumber === adjCadastral);
                                           if(adjParcel){
                                               for (const adjContour of adjParcel.contours) {
                                                   for (const adjPoint of adjContour) {
                                                       if (Math.abs(adjPoint.x - point.x) < 1e-6 && Math.abs(adjPoint.y - point.y) < 1e-6) {
                                                           isCommon = true; break;
                                                       }
                                                   }
                                                   if (isCommon) break;
                                               }
                                           }
                                           if (isCommon) break;
                                       }
                                       if (!isCommon && adjacentParcelsForImported.size > 0) {
                                           for (const impContour of importedContours) {
                                               for (const impPoint of impContour) {
                                                   if (Math.abs(impPoint.x - point.x) < 1e-6 && Math.abs(impPoint.y - point.y) < 1e-6) {
                                                       isCommon = true; break;
                                                   }
                                               }
                                               if (isCommon) break;
                                           }
                                       }
                                       if (isCommon) {
                                           pointColor = 'green';
                                       }
                                   }
                               }
                               else if (isAdjacentToSelected || isAdjacentToImported) { pointColor = 'black'; let isCommonWithSelected = false; let isCommonWithImported = false; if (isAdjacentToSelected && selectedCadastralNumber) { const selectedParcel = allContours.find(p => p.cadastralNumber === selectedCadastralNumber); if (selectedParcel) { for (const selContour of selectedParcel.contours) { for (const selPoint of selContour) { if (Math.abs(selPoint.x - point.x) < 1e-6 && Math.abs(selPoint.y - point.y) < 1e-6) { isCommonWithSelected = true; break; } } if (isCommonWithSelected) break; } } } if (isAdjacentToImported && importedContours.length > 0) { for (const impContour of importedContours) { for (const impPoint of impContour) { if (Math.abs(impPoint.x - point.x) < 1e-6 && Math.abs(impPoint.y - point.y) < 1e-6) { isCommonWithImported = true; break; } } if (isCommonWithImported) break; } } if (isCommonWithSelected || isCommonWithImported) pointColor = 'green'; }
                               if (pointColor) { ctx.save(); ctx.setTransform(1, 0, 0, 1, 0, 0); ctx.fillStyle = pointColor; ctx.beginPath(); ctx.arc(canvasX, canvasY, 4, 0, Math.PI * 2); ctx.closePath(); ctx.fill(); ctx.restore(); }
                        });
                    });
                }
            });
        }

         if (showBuildings && buildingsContours && buildingsContours.length > 0) {
            buildingsContours.forEach(building => {
                const isSelectedBuilding = building.cadastralNumber === selectedBuildingNumber;

                // ... (opacity and line width logic remains similar)
                let buildingStrokeOpacity = 1.0;
                let buildingFillOpacity = isSelectedBuilding ? 0.3 : 0.2;
                let buildingLineWidth = isSelectedBuilding ? 3 : 2;
                let buildingPointColorAlpha = 1.0;

                if (selectedImportedObjectIndex !== -1 && !isSelectedBuilding) { /* ... dimming logic ... */ }
                else if ((highlightedIsolatedParcels.size > 0 || selectedZoneOrTerritoryRegNumber || selectedCadastralNumber) && !isSelectedBuilding) { /* ... dimming logic ... */ }
                
                const buildingPointColor = `rgba(52, 152, 219, ${isSelectedBuilding ? buildingPointColorAlpha : 0.7 * buildingPointColorAlpha})`;


                building.contours.forEach(contour => {
                     if (contour.length < 1) return;
                     let contourPath = new Path2D();
                     contour.forEach((point, index) => { const [canvasX, canvasY] = transformCoord(point.x, point.y); if (index === 0) contourPath.moveTo(canvasX, canvasY); else contourPath.lineTo(canvasX, canvasY); });

                     const isClosed = checkIfClosedContour(contour);
                     if (isClosed && contour.length > 2) contourPath.closePath(); // Close path only for polygons

                     ctx.save();
                     ctx.setTransform(1, 0, 0, 1, 0, 0);

                     let currentStrokeStyle = `rgba(52, 152, 219, ${buildingStrokeOpacity})`; // Default blue for buildings
                     let currentFillStyle = `rgba(52, 152, 219, ${buildingFillOpacity})`;

                     if (building.isParsedFromJson && building.record && building.record.type === 'construction') {
                         // Specific styling for "construction" type from JSON
                         currentStrokeStyle = `rgba(255, 19, 240, ${buildingStrokeOpacity})`; // Magenta for linear construction
                         if (isClosed && contour.length > 2) { // If construction is unexpectedly closed, fill it
                            ctx.fillStyle = `rgba(255, 19, 240, ${buildingFillOpacity * 0.5})`; // Dimmer fill
                            ctx.fill(contourPath);
                         }
                     } else if (isClosed && contour.length > 2) { // Regular building (XML or JSON "building" type)
                        ctx.fillStyle = currentFillStyle;
                        ctx.fill(contourPath);
                     }
                     // For XML "construction" that might not be linear (e.g., if they can be polygons in some KPTs)
                     // This part might need refinement if XML constructions can be polygons and need different styling.
                     // The existing XML extraction for construction already pushes to buildingsContours.
                     // The `building.type` from XML is 'construction', so if we need to distinguish:
                     else if (!building.isParsedFromJson && building.type === 'construction' && !isClosed) {
                        // Potentially style XML linear constructions differently if needed
                        // For now, they fall into the default blue if they are not parsed from JSON "construction"
                     }


                     ctx.strokeStyle = currentStrokeStyle;
                     ctx.lineWidth = buildingLineWidth;
                     ctx.stroke(contourPath);
                     ctx.restore();

                     if (showPointsFlag && isSelectedBuilding && buildingPointColorAlpha > 0) {
                        // ... point drawing logic (no change needed here for JSON specifically, uses buildingPointColor)
                        contour.forEach((point) => {
                            const [canvasX, canvasY] = transformCoord(point.x, point.y);
                            ctx.save(); ctx.setTransform(1, 0, 0, 1, 0, 0);
                            ctx.fillStyle = buildingPointColor;
                            ctx.beginPath(); ctx.arc(canvasX, canvasY, 3, 0, Math.PI * 2); ctx.closePath(); ctx.fill();
                            ctx.restore();
                        });
                     }
                });
            });
        }

        importedContours.forEach((contour, index) => {
             if (contour.length < 1) return;
             const isSelectedImported = (index === selectedImportedObjectIndex);
             const makeDimImported = (selectedCadastralNumber || selectedBuildingNumber || selectedZoneOrTerritoryRegNumber || highlightedIsolatedParcels.size > 0) && !isSelectedImported;

             const importedOpacity = makeDimImported ? 0.7 : 1.0;
             const importedFillOpacity = makeDimImported ? 0.15 : (isSelectedImported ? 0.5 : 0.2);
             const importedLineWidth = isSelectedImported ? 3 : 2;


             const isClosed = checkIfClosedContour(contour);
             const isSinglePoint = contour.length === 1 || (contour.length === 2 && Math.abs(contour[0].x - contour[1].x) < 1e-6 && Math.abs(contour[0].y - contour[1].y) < 1e-6);
             let contourPath = new Path2D();
             if (isSinglePoint) {
                  const [canvasX, canvasY] = transformCoord(contour[0].x, contour[0].y); ctx.save(); ctx.setTransform(1, 0, 0, 1, 0, 0);
                  const baseCrosshairColor = isSelectedImported ? '255, 0, 0' : '0, 0, 255';
                  const crosshairColor = `rgba(${baseCrosshairColor}, ${importedOpacity})`;
                  const crosshairFill = `rgba(255, 165, 0, ${importedFillOpacity})`;
                  const currentLineWidth = isSelectedImported ? 3 : 2;
                  ctx.beginPath(); ctx.arc(canvasX, canvasY, 10, 0, Math.PI * 2); ctx.fillStyle = crosshairFill; ctx.fill();
                  ctx.beginPath(); ctx.arc(canvasX, canvasY, 10, 0, Math.PI * 2); ctx.strokeStyle = crosshairColor; ctx.lineWidth = currentLineWidth / 2; ctx.stroke();
                  ctx.beginPath(); ctx.moveTo(canvasX - 15, canvasY); ctx.lineTo(canvasX + 15, canvasY); ctx.moveTo(canvasX, canvasY - 15); ctx.lineTo(canvasX, canvasY + 15); ctx.strokeStyle = crosshairColor; ctx.lineWidth = currentLineWidth; ctx.stroke(); ctx.restore();
             } else {
                  contour.forEach((point, pIndex) => { const [canvasX, canvasY] = transformCoord(point.x, point.y); if (pIndex === 0) contourPath.moveTo(canvasX, canvasY); else contourPath.lineTo(canvasX, canvasY); });
                  if (isClosed && contour.length > 2) contourPath.closePath();
                  ctx.save(); ctx.setTransform(1, 0, 0, 1, 0, 0);
                  let strokeColor = isSelectedImported ? `rgba(255, 0, 0, ${importedOpacity})` : `rgba(0, 0, 255, ${importedOpacity})`;
                  let fillColor = isSelectedImported ? `rgba(255, 165, 0, ${importedFillOpacity})` : `rgba(255, 165, 0, ${importedFillOpacity * 0.7})`;
                  ctx.lineWidth = importedLineWidth;
                  if (isClosed) { ctx.fillStyle = fillColor; ctx.fill(contourPath); }
                  ctx.strokeStyle = strokeColor; ctx.stroke(contourPath); ctx.restore();
             }
            if (showPointsFlag && isSelectedImported && !isSinglePoint ) {
                const pointRadius = 4; const labelFontSize = 10; const labelOffsetX = 5; const labelOffsetY = -5;
                const adjacentXmlParcels = allContours.filter(p => adjacentParcelsForImported.has(p.cadastralNumber));

                contour.forEach((point, pointIndex) => {
                    if (isClosed && pointIndex === contour.length - 1 && contour.length > 1) return;
                    const [canvasX, canvasY] = transformCoord(point.x, point.y);

                    let pointColor = 'blue'; // Default: unique point of imported object
                    let isStrictlyInsideKPT = false;
                    let isCommonWithKPT = false;

                    for (const kptParcel of allContours) { // Check against all KPT parcels
                        for (const kptContour of kptParcel.contours) {
                            // Check for common point
                            for (const kptPoint of kptContour) {
                                if (Math.abs(kptPoint.x - point.x) < 1e-6 && Math.abs(kptPoint.y - point.y) < 1e-6) {
                                    isCommonWithKPT = true;
                                    break;
                                }
                            }
                            if (isCommonWithKPT) break;

                            // Check if strictly inside (only if not common)
                            if (kptContour.length >= 3 && checkIfClosedContour(kptContour) && isPointInPolygon(point, kptContour)) {
                                let onKPTBoundary = false;
                                for (let k = 0; k < kptContour.length; k++) {
                                    const p1 = kptContour[k];
                                    const p2 = kptContour[(k + 1) % kptContour.length];
                                    if (isPointOnSegment(point, p1, p2)) {
                                        onKPTBoundary = true;
                                        break;
                                    }
                                }
                                if (!onKPTBoundary) {
                                    isStrictlyInsideKPT = true;
                                    break;
                                }
                            }
                        }
                        if (isCommonWithKPT || isStrictlyInsideKPT) break; // Prioritize these checks
                    }

                    if (isCommonWithKPT) {
                        pointColor = 'green';
                    } else if (isStrictlyInsideKPT) {
                        pointColor = 'red';
                    }
                    
                        if (highlightImportedForScreenshot) { // <<< НОВОЕ УСЛОВИЕ
        pointColor = 'red';
    }
                    // else it remains 'blue'

                    ctx.save(); ctx.setTransform(1, 0, 0, 1, 0, 0); ctx.fillStyle = pointColor; ctx.beginPath(); ctx.arc(canvasX, canvasY, pointRadius, 0, Math.PI * 2); ctx.closePath(); ctx.fill();
                    ctx.fillStyle = pointColor; ctx.font = `${labelFontSize}px Arial`; ctx.textAlign = 'left'; ctx.textBaseline = 'bottom'; ctx.strokeStyle = 'white'; ctx.lineWidth = 2;
                    ctx.strokeText(`н${pointIndex + 1}`, canvasX + labelOffsetX, canvasY + labelOffsetY); ctx.fillText(`н${pointIndex + 1}`, canvasX + labelOffsetX, canvasY + labelOffsetY); ctx.restore();
                });
            }
        });

        if (scale > 0.05) {
             const allLabels = []; const fontSize = 12; const labelBuffer = 5; const occupiedSpaces = [];
             allContours.forEach(parcel => { if(!parcel || !parcel.contours || parcel.contours.length === 0 || !parcel.contours[0] || parcel.contours[0].length === 0) return; const centroid = getContourCentroid(parcel.contours[0]); const [labelX, labelY] = transformCoord(centroid.x, centroid.y); const shortCadNumber = getShortCadastralNumber(parcel.cadastralNumber); const area = calculateContourArea(parcel.contours[0]); const isSelectedParcel = parcel.cadastralNumber === selectedCadastralNumber; const isHighlightedCommon = highlightedIsolatedParcels.has(parcel.cadastralNumber); allLabels.push({ text: shortCadNumber, x: labelX, y: labelY, area: area, isSelected: isSelectedParcel, isHighlightedCommon: isHighlightedCommon, isBuilding: false, isZone: false, color: isHighlightedCommon ? 'indigo' : (isSelectedParcel ? 'blue' : 'black') }); });
             if (showBuildings && buildingsContours && buildingsContours.length > 0) { buildingsContours.forEach(building => { if(!building || !building.contours || building.contours.length === 0 || !building.contours[0] || building.contours[0].length === 0) return; let labelCentroid; const mainContour = building.contours[0]; const isClosedBuilding = checkIfClosedContour(mainContour); if (isClosedBuilding && mainContour.length >=3) labelCentroid = getContourCentroid(mainContour); else if (mainContour.length >= 1) labelCentroid = mainContour.length > 1 ? { x: (mainContour[0].x + mainContour[mainContour.length-1].x) / 2, y: (mainContour[0].y + mainContour[mainContour.length-1].y) / 2 } : mainContour[0]; else return; const [labelX, labelY] = transformCoord(labelCentroid.x, labelCentroid.y); const shortCadNumber = getShortCadastralNumber(building.cadastralNumber); const area = isClosedBuilding ? calculateContourArea(mainContour) : 50; const isSelectedBuilding = building.cadastralNumber === selectedBuildingNumber; let color = isClosedBuilding ? (isSelectedBuilding ? '#2980b9' : '#3498db') : '#FF13F0'; allLabels.push({ text: shortCadNumber, x: labelX, y: labelY, area: area, isSelected: isSelectedBuilding, isHighlightedCommon: false, isBuilding: true, isZone: false, color: color }); }); }
                if (showZones && zonesAndTerritoriesContours && zonesAndTerritoriesContours.length > 0 && visibleZoneRegNumbers.size > 0) {
                 zonesAndTerritoriesContours.forEach(zone => {
                    if (!visibleZoneRegNumbers.has(zone.regNumbBorder)) return;
                    if(!zone || !zone.contours || zone.contours.length === 0 || !zone.contours[0] || zone.contours[0].length === 0) return;
                    const centroid = getContourCentroid(zone.contours[0]);
                    const [labelX, labelY] = transformCoord(centroid.x, centroid.y);
                    const shortRegNumber = getShortZoneNumber(zone.regNumbBorder);
                    const area = calculateContourArea(zone.contours[0]);
                    const isSelectedZone = zone.regNumbBorder === selectedZoneOrTerritoryRegNumber;

                    let currentLabelColor = '#f39c12';
                    if (zone.zoneSubType === 'territorial_zone') {
                        currentLabelColor = isSelectedZone ? '#2ecc71' : '#27ae60';
                    } else if (zone.zoneSubType === 'restricted_use_zone') {
                        currentLabelColor = isSelectedZone ? '#e74c3c' : '#c0392b';
                    } else if (zone.zoneSubType === 'municipal_boundary') {
                        currentLabelColor = isSelectedZone ? '#9b59b6' : '#8e44ad';
                    } else if (zone.zoneSubType === 'inhabited_locality') {
                        currentLabelColor = isSelectedZone ? '#3498db' : '#2980b9';
                    } else if (zone.zoneSubType === 'quarter_boundary') { 
                    } else if (isSelectedZone) {
                        currentLabelColor = '#e67e22';
                    }
                    allLabels.push({ text: shortRegNumber, x: labelX, y: labelY, area: area, isSelected: isSelectedZone, isHighlightedCommon: false, isBuilding: false, isZone: true, color: currentLabelColor });
                });
            }

            if (allLabels.length > 0) {
                allLabels.sort((a, b) => { if (a.isHighlightedCommon !== b.isHighlightedCommon) return a.isHighlightedCommon ? -1 : 1; if (a.isSelected !== b.isSelected) return a.isSelected ? -1 : 1; return b.area - a.area; });

                const baseLabelOpacity = 1.0;
                const dimmedLabelOpacityForKPTContext = 0.85;
                const generalDimmedLabelOpacity = 0.6;


                allLabels.forEach(label => {
                    ctx.save(); ctx.setTransform(1, 0, 0, 1, 0, 0); ctx.font = `${fontSize}px Arial`;
                    const textWidth = ctx.measureText(label.text).width; const textHeight = fontSize;
                    const labelRect = { x: label.x - textWidth / 2 - labelBuffer, y: label.y - textHeight / 2 - labelBuffer, width: textWidth + 2 * labelBuffer, height: textHeight + 2 * labelBuffer };
                    let collides = false; for (const space of occupiedSpaces) { if (checkRectCollision(labelRect, space)) { collides = true; break; } }

                    if (!collides) {
                        let currentLabelOpacity = baseLabelOpacity;

                        if (label.isSelected || label.isHighlightedCommon) {
                            currentLabelOpacity = baseLabelOpacity;
                        } else if (selectedImportedObjectIndex !== -1) {
                             currentLabelOpacity = dimmedLabelOpacityForKPTContext;
                        } else if (selectedCadastralNumber || selectedBuildingNumber || selectedZoneOrTerritoryRegNumber || highlightedIsolatedParcels.size > 0) {
                            currentLabelOpacity = generalDimmedLabelOpacity;
                        }

                        ctx.globalAlpha = currentLabelOpacity;
                        ctx.fillStyle = label.color;
                        ctx.strokeStyle = 'white'; ctx.lineWidth = 3; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                        ctx.strokeText(label.text, label.x, label.y); ctx.fillText(label.text, label.x, label.y);
                        occupiedSpaces.push(labelRect);
                    }
                    ctx.restore();
                });
            }
        }

        if (selectedCoordinate) {
             let drawSelectedCoord = false;
             if (highlightedIsolatedParcels.size > 0) { for (const cadNum of highlightedIsolatedParcels) { const parcel = allContours.find(p => p.cadastralNumber === cadNum); if (parcel) { for(const contour of parcel.contours) { for(const pt of contour) { if (Math.abs(pt.x - selectedCoordinate.x) < 1e-6 && Math.abs(pt.y - selectedCoordinate.y) < 1e-6) { drawSelectedCoord = true; break; } } if(drawSelectedCoord) break; } } if(drawSelectedCoord) break; } }
             else if (selectedImportedObjectIndex !== -1) { const selectedImpContour = importedContours[selectedImportedObjectIndex]; if (selectedImpContour) { for(const pt of selectedImpContour) { if (Math.abs(pt.x - selectedCoordinate.x) < 1e-6 && Math.abs(pt.y - selectedCoordinate.y) < 1e-6) { drawSelectedCoord = true; break; } } } }
             else if (selectedCadastralNumber) { const parcel = allContours.find(p => p.cadastralNumber === selectedCadastralNumber); if (parcel) { for(const contour of parcel.contours) { for(const pt of contour) { if (Math.abs(pt.x - selectedCoordinate.x) < 1e-6 && Math.abs(pt.y - selectedCoordinate.y) < 1e-6) { drawSelectedCoord = true; break; } } if(drawSelectedCoord) break; } } }
             else if (selectedBuildingNumber) { const building = buildingsContours.find(b => b.cadastralNumber === selectedBuildingNumber); if (building) { for(const contour of building.contours) { for(const pt of contour) { if (Math.abs(pt.x - selectedCoordinate.x) < 1e-6 && Math.abs(pt.y - selectedCoordinate.y) < 1e-6) { drawSelectedCoord = true; break; } } if(drawSelectedCoord) break; } } }
             else if (selectedZoneOrTerritoryRegNumber) { const zone = zonesAndTerritoriesContours.find(z => z.regNumbBorder === selectedZoneOrTerritoryRegNumber); if (zone) { for(const contour of zone.contours) { for(const pt of contour) { if (Math.abs(pt.x - selectedCoordinate.x) < 1e-6 && Math.abs(pt.y - selectedCoordinate.y) < 1e-6) { drawSelectedCoord = true; break; } } if(drawSelectedCoord) break; } } }


             if (drawSelectedCoord) {
                 const [canvasX, canvasY] = transformCoord(selectedCoordinate.x, selectedCoordinate.y); ctx.save(); ctx.setTransform(1, 0, 0, 1, 0, 0);
                 ctx.fillStyle = 'rgba(255, 0, 0, 0.8)'; ctx.strokeStyle = 'white'; ctx.lineWidth = 2;
                 ctx.beginPath(); ctx.arc(canvasX, canvasY, 6, 0, Math.PI * 2); ctx.fill(); ctx.stroke(); ctx.restore();
             } else { selectedCoordinate = null; const tableRows = document.querySelectorAll('.coordinate-row.selected-coordinate'); tableRows.forEach(row => row.classList.remove('selected-coordinate')); }
         }

        if (rulerMode && rulerPoints.length > 0) {
             ctx.save(); ctx.setTransform(1, 0, 0, 1, 0, 0); ctx.strokeStyle = '#e74c3c'; ctx.fillStyle = '#e74c3c'; ctx.lineWidth = 2; ctx.font = 'bold 12px Arial';
             const [p1x, p1y] = transformCoord(rulerPoints[0].x, rulerPoints[0].y); ctx.beginPath(); ctx.arc(p1x, p1y, 5, 0, Math.PI*2); ctx.fill();
             if (rulerPoints.length === 2) { const [p2x, p2y] = transformCoord(rulerPoints[1].x, rulerPoints[1].y); ctx.beginPath(); ctx.arc(p2x, p2y, 5, 0, Math.PI*2); ctx.fill(); ctx.beginPath(); ctx.moveTo(p1x, p1y); ctx.lineTo(p2x, p2y); ctx.stroke(); const distance = calculateDistance(rulerPoints[0], rulerPoints[1]); const midX = (p1x + p2x) / 2; const midY = (p1y + p2y) / 2; ctx.fillStyle = 'white'; ctx.fillRect(midX - 25, midY - 10, 50, 20); ctx.fillStyle = '#e74c3c'; ctx.textAlign = 'center'; ctx.fillText(distance.toFixed(2) + 'м', midX, midY + 5); }
             ctx.restore();
         }
    }


    function checkIfClosedContour(contour) { if (contour.length < 3) return false; const firstPoint = contour[0]; const lastPoint = contour[contour.length - 1]; return Math.abs(firstPoint.x - lastPoint.x) < 1e-6 && Math.abs(firstPoint.y - lastPoint.y) < 1e-6; }
    function getColorWithOpacity(color, opacity) { switch (color) { case 'orange': return `rgba(255, 165, 0, ${opacity})`; case 'blue': return `rgba(0, 0, 255, ${opacity})`; case 'red': return `rgba(255, 0, 0, ${opacity})`; case 'green': return `rgba(0, 128, 0, ${opacity})`; default: return `rgba(0, 0, 0, ${opacity})`; } }
    function checkRectCollision(rect1, rect2) { return (rect1.x < rect2.x + rect2.width && rect1.x + rect1.width > rect2.x && rect1.y < rect2.y + rect2.height && rect1.y + rect1.height > rect2.y); }
    function calculateContourArea(contour) { let area = 0; for (let i = 0; i < contour.length; i++) { const j = (i + 1) % contour.length; area += contour[i].x * contour[j].y; area -= contour[j].x * contour[i].y; } return Math.abs(area / 2); }
    function formatFileSize(bytes) { if (bytes < 1024) return bytes + ' B'; else if (bytes < 1048576) return (bytes / 1024).toFixed(1) + ' KB'; else return (bytes / 1048576).toFixed(1) + ' MB'; }
    function updateLoaderProgress(current, total, text = '') { const loaderText = document.querySelector('.loading-text'); const formattedCurrent = formatFileSize(current); const formattedTotal = formatFileSize(total); if (text) loaderText.innerHTML = `${text}<br>${formattedCurrent} из ${formattedTotal}`; else loaderText.textContent = `${formattedCurrent} из ${formattedTotal}`; }
    function simulateLoading(fileSize, onProgress, onComplete, duration = 3000) { const steps = 30; const interval = duration / steps; let progress = 0; const timer = setInterval(() => { progress += fileSize / steps; if (progress > fileSize) progress = fileSize; onProgress(progress, fileSize); if (progress >= fileSize) { clearInterval(timer); setTimeout(onComplete, 500); } }, interval); return timer; }

        document.getElementById('fileInput').addEventListener('change', async function(event) {
        const file = event.target.files[0];
        if (!file) {
            isSelectiveLoadMode = false; // Reset if no file selected
            return;
        }
        event.target.value = null; // Reset file input to allow re-selection of the same file

        const loaderContainer = document.getElementById('loaderContainer');
        loaderContainer.style.display = 'flex';
        const fileSize = file.size;
        const fileNameLower = file.name.toLowerCase();
        let processingText = 'Чтение файла...';

        if (fileNameLower.endsWith('.xml')) processingText = 'Чтение XML-файла';
        else if (fileNameLower.endsWith('.json.zip')) processingText = 'Чтение JSON.ZIP архива';
        else if (fileNameLower.endsWith('.zip')) processingText = 'Чтение ZIP-архива (XML)';

        updateLoaderProgress(0, fileSize, processingText);

        const handleFileContent = async (content, fileNameFromArchive, fileType) => {
            // rawXmlContentForSelection is used for XML selective load.
            // For JSON, selective load means loading all content from that specific JSON file.
            if (fileType === 'xml') {
                rawXmlContentForSelection = content;
                if (isSelectiveLoadMode) {
                    updateLoaderProgress(fileSize, fileSize, 'Анализ XML для выбора');
                    try {
                        const allNumbers = await extractAllCadastralNumbersFromXML(content);
                        if (allNumbers.length > 0) showSelectionDialog(allNumbers, fileNameFromArchive);
                        else {
                            showNotification('В XML файле не найдено номеров для выбора.', 'warning', 'exclamation-triangle');
                            isSelectiveLoadMode = false; rawXmlContentForSelection = null; loaderContainer.style.display = 'none';
                        }
                    } catch (error) {
                        showNotification('Ошибка при анализе XML для выбора: ' + error.message, 'error', 'exclamation-circle');
                        isSelectiveLoadMode = false; rawXmlContentForSelection = null; loaderContainer.style.display = 'none';
                    }
                } else {
                    updateLoaderProgress(fileSize, fileSize, 'Обработка XML');
                    setTimeout(async () => {
                        try { await processXMLContent(content, fileNameFromArchive); }
                        catch (error) { showNotification('Ошибка при обработке XML: ' + error.message, 'error', 'exclamation-circle'); }
                        finally { loaderContainer.style.display = 'none'; }
                    }, 800);
                }
            } else if (fileType === 'json') {
                updateLoaderProgress(fileSize, fileSize, 'Обработка JSON');
                setTimeout(async () => {
                    try {
                        await handleJsonString(content, fileNameFromArchive); // 'content' is jsonString here
                        if (isSelectiveLoadMode) {
                             showNotification('Все объекты из JSON файла загружены.', 'success', 'check-circle');
                             // Reset selective mode flags for JSON as it loads everything from the selected file.
                             isSelectiveLoadMode = false;
                             rawXmlContentForSelection = null;
                             selectableNumbersCache = [];
                        }
                    } catch (error) {
                        showNotification('Ошибка при обработке JSON: ' + error.message, 'error', 'exclamation-circle');
                        if (isSelectiveLoadMode) { isSelectiveLoadMode = false; rawXmlContentForSelection = null; selectableNumbersCache = []; }
                    } finally {
                        loaderContainer.style.display = 'none';
                    }
                }, 800);
            }
        };

        setTimeout(async () => { // Brief delay for loader to show
            try {
                if (fileNameLower.endsWith('.xml')) {
                    const reader = new FileReader();
                    reader.onprogress = (e) => { if (e.lengthComputable) updateLoaderProgress(e.loaded, e.total, 'Чтение XML'); };
                    reader.onload = (e) => handleFileContent(e.target.result, file.name, 'xml');
                    reader.onerror = () => { loaderContainer.style.display = 'none'; showNotification('Ошибка при чтении XML-файла', 'error', 'exclamation-circle'); isSelectiveLoadMode = false; rawXmlContentForSelection = null; };
                    reader.readAsText(file);
                } else if (fileNameLower.endsWith('.json.zip')) {
                    updateLoaderProgress(0, fileSize, 'Распаковка JSON.ZIP');
                    try {
                        const zip = await JSZip.loadAsync(await file.arrayBuffer());
                        // Corrected regex for internal JSON: allows YYYY_MM_DD or YYYY-MM-DD
                        let jsonFileEntry = Object.values(zip.files).find(
                            f => f.name.match(/\d{2}_\d{2}_\d{6,7} \d{4}[_-]\d{2}[_-]\d{2}\.json$/i) && !f.dir
                        );
                        if (!jsonFileEntry) { // Fallback if specific pattern is not found
                           jsonFileEntry = Object.values(zip.files).find(f => f.name.toLowerCase().endsWith('.json') && !f.dir);
                        }

                        if (jsonFileEntry) {
                            updateLoaderProgress(fileSize, fileSize, 'Извлечение JSON из архива');
                            const jsonContentString = await jsonFileEntry.async('string');
                            handleFileContent(jsonContentString, jsonFileEntry.name, 'json');
                        } else {
                            throw new Error('JSON-файл с ожидаемым форматом имени (*.json) не найден в архиве JSON.ZIP.');
                        }
                    } catch (error) {
                        loaderContainer.style.display = 'none';
                        showNotification('Ошибка при обработке JSON.ZIP: ' + error.message, 'error', 'exclamation-circle');
                        isSelectiveLoadMode = false; rawXmlContentForSelection = null;
                    }
                } else if (fileNameLower.endsWith('.zip')) { // For ZIP archives containing XML
                    updateLoaderProgress(0, fileSize, 'Распаковка ZIP (XML)');
                    try {
                        const zip = await JSZip.loadAsync(await file.arrayBuffer());
                        let xmlFileEntry = Object.values(zip.files).find(f => f.name.toLowerCase().endsWith('.xml') && !f.dir);
                        if (xmlFileEntry) {
                            updateLoaderProgress(fileSize, fileSize, 'Извлечение XML из архива');
                            const xmlContent = await xmlFileEntry.async('string');
                            handleFileContent(xmlContent, xmlFileEntry.name, 'xml');
                        } else {
                            throw new Error('XML-файл не найден в архиве ZIP.');
                        }
                    } catch (error) {
                        loaderContainer.style.display = 'none';
                        showNotification('Ошибка при обработке ZIP-файла: ' + error.message, 'error', 'exclamation-circle');
                        isSelectiveLoadMode = false; rawXmlContentForSelection = null;
                    }
                } else {
                    loaderContainer.style.display = 'none';
                    showNotification('Пожалуйста, выберите файл XML, ZIP или JSON.ZIP.', 'warning', 'exclamation-triangle');
                    isSelectiveLoadMode = false; rawXmlContentForSelection = null;
                }
            } catch (error) {
                loaderContainer.style.display = 'none';
                showNotification('Ошибка при обработке файла: ' + error.message, 'error', 'exclamation-circle');
                isSelectiveLoadMode = false; rawXmlContentForSelection = null;
            }
        }, 100);
    });
    
    
    document.getElementById('buildingsBtn').addEventListener('click', function() {
        showBuildings = !showBuildings;
        if (showBuildings) { this.classList.add('active'); this.style.backgroundColor = '#3498db'; showNotification('Отображение ОКС включено', 'info', 'home'); }
        else { this.classList.remove('active'); this.style.backgroundColor = '#95a5a6'; showNotification('Отображение ОКС отключено', 'info', 'home'); if (selectedBuildingNumber) { selectedBuildingNumber = null; displayParcelInfo(null); } }
        const adjacentParcels = getAdjacentParcelsForSelected(selectedCadastralNumber); const adjacentParcelsForImported = getAdjacentParcelsForImported(); redraw(adjacentParcels, adjacentParcelsForImported);
    });

 document.getElementById('zonesBtn').addEventListener('click', function() {
        openZoneSelectionDialog();
    });

   document.getElementById('importCoordsBtn').addEventListener('click', function() {
    let input = document.getElementById('coordsInput').value; if (!input.trim()) { alert('Введите координаты.'); return; }
    const processedInput = input.replace(/,/g, '.'); processImportedCoordinates(processedInput); updateOverlappingParcelsList(); closeCoordinateDialog();
    });
    document.getElementById('importFromFileBtn').addEventListener('click', importFile);
    function closeCoordinateDialog() { const coordsDialogEl = document.getElementById('coordsDialog'); const dialogOverlayEl = document.getElementById('dialogOverlay'); if(coordsDialogEl && dialogOverlayEl) {coordsDialogEl.style.opacity = '0'; dialogOverlayEl.style.opacity = '0'; setTimeout(() => { coordsDialogEl.style.display = 'none'; dialogOverlayEl.style.display = 'none'; }, 300); } }
    function importFile() {
        const fileInput = document.createElement('input'); fileInput.type = 'file'; fileInput.accept = '.xml,.zip,.dxf,.mif,.csv,.txt';
        fileInput.onchange = function(e) {
            const file = e.target.files[0]; if (!file) return;
            const extension = file.name.split('.').pop().toLowerCase(); const reader = new FileReader();
            reader.onload = function(event) {
                const content = event.target.result; let coordinates;
                switch (extension) { case 'xml': coordinates = extractCoordinatesFromXMLContent(content, true); break; case 'zip': handleZipFile(file, false); return; case 'dxf': coordinates = extractCoordinatesFromDXF(content, true); break; case 'mif': coordinates = extractCoordinatesFromMIF(content, true); break; case 'csv': case 'txt': coordinates = extractCoordinatesFromText(content, true); break; default: alert('Неподдерживаемый формат файла'); return; }
                if (coordinates && coordinates.length > 0) { document.getElementById('coordsInput').value = coordinates.join('\n'); processImportedCoordinates(coordinates.join('\n')); updateOverlappingParcelsList(); closeCoordinateDialog(); } else alert('Не удалось найти координаты в файле');
            };
            reader.onerror = function() { alert('Ошибка при чтении файла'); };
            if (extension === 'zip') reader.readAsArrayBuffer(file); else reader.readAsText(file, 'UTF-8');
        };
        fileInput.click();
    }
    
async function handleJsonString(jsonString, fileName, selectedTypes = null) {
    // const loaderContainer = document.getElementById('loaderContainer'); // Loader is handled by caller
    try {
        const jsonData = JSON.parse(jsonString);

        // Reset global arrays and flags
        allContours = [];
        buildingsContours = [];
        zonesAndTerritoriesContours = [];
        importedContours = [];

        isUnifiedLandUse = false;
        commonLandLinksMap = {};

        cadastralBlockNumber = jsonData.cadastral_quarter_from_xml ? jsonData.cadastral_quarter_from_xml + ':' : '';

        let loadedParcelCount = 0;
        let loadedBuildingCount = 0;
        let loadedConstructionCount = 0;

        jsonData.objects.forEach((obj, index) => {
            if (!obj.id || !obj.type || !obj.contours) {
                console.warn("Skipping malformed object in JSON:", obj);
                return;
            }

            // NEW FILTERING LOGIC
            // If selectedTypes is provided (i.e., not null from quarterSelectDialog) and this object's type isn't in the set, skip it.
            // If selectedTypes is null (e.g. direct file open), this condition is false, and all objects are processed.
            if (selectedTypes && !selectedTypes.has(obj.type)) {
                return;
            }

            const internalContours = obj.contours.map(contour =>
                contour.map(point => ({
                    x: point.x,
                    y: point.y,
                    delta: point.delta !== undefined ? point.delta : null,
                    ord_nmb: point.ord_nmb
                }))
            );

            const internalObjectBase = {
                cadastralNumber: obj.id,
                contours: internalContours,
                isParsedFromJson: true,
                record: { ...obj },
                type: obj.type
            };

            if (obj.type === 'parcel') {
                const parcelObject = {
                    ...internalObjectBase,
                    parcelIndex: index,
                    isDeclaredArea: false,
                    isIsolatedParcel: false,
                    commonLandCadNumber: null
                };
                allContours.push(parcelObject);
                loadedParcelCount++;
            } else if (obj.type === 'building') {
                buildingsContours.push(internalObjectBase);
                loadedBuildingCount++;
            } else if (obj.type === 'construction') {
                 // Still add to buildingsContours as they share drawing logic,
                 // but styling can differentiate them based on obj.type or internalObjectBase.type.
                buildingsContours.push(internalObjectBase);
                loadedConstructionCount++;
            }
        });

        // Reset selections and UI state
        selectedCadastralNumber = null;
        selectedBuildingNumber = null;
        selectedZoneOrTerritoryRegNumber = null;
        selectedImportedObjectIndex = -1;
        highlightedIsolatedParcels.clear();
        selectedCoordinate = null;
        selectedPoints = [];
        rulerPoints = [];
        rulerMode = false;
        document.getElementById('rulerBtn')?.classList.remove('active');
        document.getElementById('measurementPanel')?.classList.remove('active');
        updateMeasurementPanel();

        document.getElementById('fileInputLabel').textContent = fileName || 'Выберите файл';

        let dateFromFile = '';
        const dateMatch = fileName.match(/(\d{4})[_-](\d{2})[_-](\d{2})\.json$/i);
        if (dateMatch) {
            dateFromFile = `${dateMatch[3]}.${dateMatch[2]}.${dateMatch[1]}`;
        }
        let titlePrefix = jsonData.cadastral_quarter_from_xml || "Схема JSON";
        document.title = dateFromFile ? `${titlePrefix} от ${dateFromFile}` : titlePrefix;

        initCadastralInput();
        displayParcelInfo(null);
        document.getElementById('overlappingParcelsList').innerHTML = '';
        const overlappingContainer = document.getElementById('overlappingParcelsContainer');
        if (overlappingContainer && overlappingContainer.parentElement) {
            const sectionTitle = overlappingContainer.parentElement.querySelector('.section-title');
            if (sectionTitle) sectionTitle.style.display = 'none';
        }
         const coordinatesTableContainer = document.getElementById('coordinatesTableContainer');
        if(coordinatesTableContainer) coordinatesTableContainer.innerHTML = '';


        const fileInfoPanel = document.getElementById('fileInfoPanel');
        const fileDetailsTextInPanel = fileInfoPanel ? fileInfoPanel.querySelector('#fileDetailsText') : null;
        if (fileInfoPanel && fileDetailsTextInPanel) {
            let line1 = `Квартал: ${jsonData.cadastral_quarter_from_xml || 'Не указан'}`;
            if (dateFromFile) line1 += ` от ${dateFromFile}`;
            
            let loadedCounts = [];
            if (loadedParcelCount > 0) loadedCounts.push(`ЗУ: ${loadedParcelCount}`);
            if (loadedBuildingCount > 0) loadedCounts.push(`ОКС: ${loadedBuildingCount}`);
            if (loadedConstructionCount > 0) loadedCounts.push(`Сооруж: ${loadedConstructionCount}`);
            const loadedCountsString = loadedCounts.length > 0 ? loadedCounts.join(', ') : 'нет';

            const line2 = `JSON файл содержит только координаты. Всего объектов в файле: ${jsonData.total_objects_extracted || 'N/A'}. Загружено на схему: ${loadedCountsString}.`;
            const line3 = `Исходный XML для JSON: ${jsonData.source_xml_name_in_zip || 'Не указан'}`;

            fileDetailsTextInPanel.innerHTML = `${line1}<br>${line2}<br>${line3}`;
            fileInfoPanel.style.display = 'flex';

            const oldFileInfoPanel = fileInfoPanel;
            const newFileInfoPanelInstance = oldFileInfoPanel.cloneNode(true);
            oldFileInfoPanel.parentNode.replaceChild(newFileInfoPanelInstance, oldFileInfoPanel);
            if(newFileInfoPanelInstance.querySelector('#fileDetailsText').textContent.trim()) {
                 newFileInfoPanelInstance.addEventListener('dblclick', function() {
                    copyToClipboard(this.querySelector('#fileDetailsText').textContent.replace(/\s+/g, ' ').trim());
                    flashElement(this);
                });
                newFileInfoPanelInstance.style.cursor = 'pointer';
                newFileInfoPanelInstance.title = 'Двойной клик для копирования';
            } else {
                newFileInfoPanelInstance.style.cursor = 'default';
                newFileInfoPanelInstance.removeAttribute('title');
            }
        }


        if (allContours.length > 0 || buildingsContours.length > 0) {
            drawKPTScheme();
        } else {
            const canvasEl = document.getElementById('kptSchemeCanvas');
            if (canvasEl) {
                const ctx = canvasEl.getContext('2d');
                ctx.clearRect(0, 0, canvasEl.width, canvasEl.height);
                ctx.fillStyle = 'white';
                ctx.fillRect(0, 0, canvasEl.width, canvasEl.height);
            }
            if (selectedTypes && jsonData.objects.length > 0) { // If filters were active and resulted in no objects
                 showNotification('Выбранные типы объектов не содержат графики для отображения из этого JSON файла.', 'warning', 'filter');
            } else {
                 showNotification('В JSON файле нет объектов с графикой для отображения.', 'warning', 'exclamation-triangle');
            }
        }

        showBuildings = buildingsContours.length > 0;
        const buildingsButton = document.getElementById('buildingsBtn');
        if (buildingsButton) {
            if (showBuildings) {
                buildingsButton.classList.add('active'); buildingsButton.style.backgroundColor = '#3498db';
            } else {
                buildingsButton.classList.remove('active'); buildingsButton.style.backgroundColor = '#95a5a6';
            }
        }
        showZones = false;
        visibleZoneRegNumbers.clear();
        initialZoneSelectionApplied = false;
        updateZonesButtonVisualState();

    } catch (error) {
        console.error("Error processing JSON string:", error);
        showNotification('Ошибка формата JSON или обработки данных: ' + error.message, 'error', 'exclamation-circle');
    }
}

function processImportedCoordinates(input) {
        function parseCoordinates(text) {
            let coordinates = []; const lines = text.split('\n'); let currentContour = []; let lastLineHadCoordinates = false;
            for (let line of lines) {
                line = line.trim();
                if (line === '') { if (currentContour.length > 0) { if (currentContour.length === 1) currentContour.push({...currentContour[0]}); coordinates.push(...currentContour.map(p => `${p.x.toFixed(2)}\t${p.y.toFixed(2)}`)); coordinates.push(''); currentContour = []; } lastLineHadCoordinates = false; continue; }
                const coordMatch = line.match(/^(-?\d+(\.\d+)?)\s*[\s\t;]\s*(-?\d+(\.\d+)?)/);
                if (coordMatch && coordMatch.length >= 4) { let x = parseFloat(coordMatch[1]); let y = parseFloat(coordMatch[3]); if (!isNaN(x) && !isNaN(y)) { if (x > y && text.includes('ЕГРН') && !text.includes('<X>')) {[x,y] = [y,x];} currentContour.push({x, y}); lastLineHadCoordinates = true; } else { if (lastLineHadCoordinates && currentContour.length > 0) { if (currentContour.length === 1) currentContour.push({...currentContour[0]}); coordinates.push(...currentContour.map(p => `${p.x.toFixed(2)}\t${p.y.toFixed(2)}`)); coordinates.push(''); currentContour = []; } lastLineHadCoordinates = false; } }
                else { if (lastLineHadCoordinates && currentContour.length > 0) { if (currentContour.length === 1) currentContour.push({...currentContour[0]}); coordinates.push(...currentContour.map(p => `${p.x.toFixed(2)}\t${p.y.toFixed(2)}`)); coordinates.push(''); currentContour = []; } lastLineHadCoordinates = false; }
            }
            if (currentContour.length > 0) { if (currentContour.length === 1) currentContour.push({...currentContour[0]}); coordinates.push(...currentContour.map(p => `${p.x.toFixed(2)}\t${p.y.toFixed(2)}`)); }
            if (coordinates.length > 0 && coordinates[coordinates.length - 1] === '') coordinates.pop();
            if (text.includes('<entity_spatial>')) coordinates = extractCoordinatesEntitySpatial(text); else if (text.includes('SpatialElement')) coordinates = extractCoordinatesNewContour(text);
            return coordinates;
        }
        const parsedCoords = parseCoordinates(input);
        if (parsedCoords.length > 0) {
            // importedContours = []; // Clear previous if not appending, or manage multiple imported objects
            let newContoursAddedThisCall = [];
            let currentContour = [];
            parsedCoords.forEach(coordStr => {
                if (coordStr === '') {
                    if (currentContour.length > 0) {
                        if (currentContour.length === 1) currentContour.push({...currentContour[0]});
                        importedContours.push(currentContour);
                        newContoursAddedThisCall.push(currentContour);
                        currentContour = [];
                    }
                } else {
                    const [xStr, yStr] = coordStr.split('\t');
                    const x = parseFloat(xStr);
                    const y = parseFloat(yStr);
                    if (!isNaN(x) && !isNaN(y)) currentContour.push({x, y});
                }
            });
            if (currentContour.length > 0) {
                if (currentContour.length === 1) currentContour.push({...currentContour[0]});
                importedContours.push(currentContour);
                newContoursAddedThisCall.push(currentContour);
            }

            // Update global bounds to include new imported contours for initial zoom/pan
            const allPointsForBounds = [];
            allContours.forEach(parcel => parcel.contours.forEach(c => allPointsForBounds.push(...c)));
            importedContours.forEach(contour => allPointsForBounds.push(...contour)); // Include ALL imported
            buildingsContours.forEach(building => building.contours.forEach(c => allPointsForBounds.push(...c)));
            zonesAndTerritoriesContours.forEach(zone => zone.contours.forEach(c => allPointsForBounds.push(...c)));

            const canvasEl = document.getElementById('kptSchemeCanvas');
            if (allPointsForBounds.length > 0 && canvasEl) {
                const validXs = allPointsForBounds.map(p => p.x).filter(isFinite);
                const validYs = allPointsForBounds.map(p => p.y).filter(isFinite);
                if(validXs.length > 0 && validYs.length > 0){
                    minX = Math.min(...validXs); minY = Math.min(...validYs); maxX = Math.max(...validXs); maxY = Math.max(...validYs);
                }
                // Scale and offset will be determined by centerOnImportedObject or redraw if not centering
            }

            // Select and center on the last added imported object/contour
            if (newContoursAddedThisCall.length > 0) {
                const lastAddedIndex = importedContours.length - 1; // Index of the very last contour in the global array
                selectedImportedObjectIndex = lastAddedIndex;
                displayParcelInfo(null); // Clear KPT info
                const cadastralInput = document.getElementById('cadastralInput');
                if (cadastralInput) {
                    cadastralInput.value = `Объект #${selectedImportedObjectIndex + 1}`;
                }
                centerOnImportedObject(lastAddedIndex); // This will also call redraw
            } else {
                // Fallback redraw if no new contours were effectively added (e.g. empty input)
                // or if we don't want to center.
                const adjacentParcels = getAdjacentParcelsForSelected(selectedCadastralNumber);
                const adjacentParcelsForImported = getAdjacentParcelsForImported();
                redraw(adjacentParcels, adjacentParcelsForImported, false, showPoints, showPoints); // false to re-calculate bounds
            }

            updateOverlappingParcelsList();
            const totalPointsAdded = newContoursAddedThisCall.reduce((sum, contour) => sum + contour.length, 0);
            showNotification(`Добавлен объект с ${totalPointsAdded} точками`, 'success', 'check-circle');
        } else {
             alert('Не удалось распознать координаты.');
        }
        const overlappingContainer = document.getElementById('overlappingParcelsContainer');
        if (overlappingContainer && overlappingContainer.parentElement) {
            const sectionTitle = overlappingContainer.parentElement.querySelector('.section-title');
            if (sectionTitle) sectionTitle.style.display = 'block';
        }
    }

    function extractCoordinatesFromXMLContent(text, swapXY = false) { const coordinates = []; const contours = text.split('</entity_spatial>'); contours.forEach((contour) => { const regex = /<x>(\d+(?:\.\d+)?)<\/x>\s*<y>(\d+(?:\.\d+)?)<\/y>/g; let matches; let currentContour = []; while ((matches = regex.exec(contour)) !== null) { let x = parseFloat(matches[1]); let y = parseFloat(matches[2]); if (swapXY) { if (x > y) [x, y] = [y, x]; } currentContour.push(`${x.toFixed(2)}\t${y.toFixed(2)}`); } if (currentContour.length > 0) { if (coordinates.length > 0) coordinates.push(''); coordinates.push(...currentContour); } }); return coordinates.length > 0 ? coordinates : extractCoordinatesFromXMLType2(text, swapXY); }
    function extractCoordinatesFromXMLType2(text, swapXY = false) { const coordinates = []; text = text.replace(/<SpecifyRelatedParcel[\s\S]*?<\/SpecifyRelatedParcel>/g, ''); const regex2 = /X="(\d+(?:\.\d+)?)"[^>]+Y="(\d+(?:\.\d+)?)"[^>]+/g; let matches2 = Array.from(text.matchAll(regex2)); if (matches2.length > 0) { const contours = text.split('</SpatialElement>'); contours.forEach((contour) => { const contourMatches = Array.from(contour.matchAll(regex2)); let currentContour = []; contourMatches.forEach(match => { let x = parseFloat(match[1]); let y = parseFloat(match[2]); if (swapXY) [x, y] = [y, x]; currentContour.push(`${x.toFixed(2)}\t${y.toFixed(2)}`); }); if (currentContour.length > 0) { if (coordinates.length > 0) coordinates.push(''); coordinates.push(...currentContour); } }); } return coordinates; }
    function handleZipFile(file, isAppend = false) { const reader = new FileReader(); reader.onload = function(event) { const zipData = event.target.result; JSZip.loadAsync(zipData).then(function(zip) { let xmlFile = null; for (let fileName in zip.files) { if (fileName.toLowerCase().endsWith('.xml')) { xmlFile = zip.files[fileName]; break; } } if (xmlFile) { xmlFile.async("string").then(function(xmlContent) { const coordinates = extractCoordinatesFromXMLContent(xmlContent, true); if (coordinates && coordinates.length > 0) { if (isAppend) appendCoordinates(coordinates); else { document.getElementById('coordsInput').value = coordinates.join('\n'); processImportedCoordinates(coordinates.join('\n')); updateOverlappingParcelsList(); closeCoordinateDialog(); } } else alert('Не удалось найти координаты в XML файле внутри архива'); }); } else alert('XML файл не найден в архиве'); }).catch(function(err) { alert('Ошибка при разархивации ZIP файла'); }); }; reader.readAsArrayBuffer(file); }
    function extractCoordinatesFromDXF(dxfContent, swapXY = false) { const lines = dxfContent.split('\n'); const coordinates = []; let currentContour = []; let isReadingCoords = false; let isClosed = false; let x, y; for (let i = 0; i < lines.length; i++) { const line = lines[i].trim(); if (line === 'LWPOLYLINE') { isReadingCoords = true; isClosed = false; if (currentContour.length > 0) { coordinates.push(...currentContour); if (coordinates.length > 0) coordinates.push(''); currentContour = []; } } else if (line === 'SEQEND') { isReadingCoords = false; if (currentContour.length > 0) { coordinates.push(...currentContour); if (isClosed && currentContour.length > 1) coordinates.push(currentContour[0]); if (coordinates.length > 0) coordinates.push(''); currentContour = []; } } else if (isReadingCoords) { if (line === '70') isClosed = parseInt(lines[++i].trim()) === 1; else if (line === '10') x = parseFloat(lines[++i].trim()); else if (line === '20') { y = parseFloat(lines[++i].trim()); if (x !== undefined && y !== undefined) { if (swapXY) { if (x > y) [x, y] = [y, x]; } currentContour.push(`${x.toFixed(2)}\t${y.toFixed(2)}`); x = y = undefined; } } } } if (currentContour.length > 0) coordinates.push(...currentContour); while (coordinates.length > 0 && coordinates[coordinates.length - 1] === '') coordinates.pop(); return coordinates; }
    function extractCoordinatesFromMIF(mifContent, swapXY = false) { const lines = mifContent.split('\n'); const coordinates = []; let currentContour = []; let isDataSection = false; for (let i = 0; i < lines.length; i++) { const line = lines[i].trim(); if (line === 'Data') { isDataSection = true; continue; } if (!isDataSection) continue; if (line.startsWith('Region') || line.startsWith('PLINE')) { if (currentContour.length > 0) { coordinates.push(...currentContour); coordinates.push(''); currentContour = []; } continue; } const coords = line.split(/,\s*|\s+/).map(coord => parseFloat(coord.trim())); if (coords.length === 2 && !isNaN(coords[0]) && !isNaN(coords[1])) { let [x, y] = coords; if (swapXY) { if (x > y) [x, y] = [y, x]; } currentContour.push(`${x.toFixed(2)}\t${y.toFixed(2)}`); } } if (currentContour.length > 0) coordinates.push(...currentContour); while (coordinates.length > 0 && coordinates[coordinates.length - 1] === '') coordinates.pop(); return coordinates; }
    function extractCoordinatesFromText(content, swapXY = false) { const lines = content.split('\n'); const coordinates = []; const numberRegex = /[-+]?[0-9]*[.,]?[0-9]+/g; let lastLineHadCoordinates = false; for (let line of lines) { line = line.trim(); const numbers = line.match(numberRegex); const potentialCoords = numbers ? numbers.map(n => parseFloat(n.replace(',', '.'))).filter(n => Math.abs(n) >= 10000) : []; if (potentialCoords.length >= 2) { let [x, y] = potentialCoords[0] < potentialCoords[1] ? [potentialCoords[0], potentialCoords[1]] : [potentialCoords[1], potentialCoords[0]]; if (swapXY) { if (x > y) [x, y] = [y, x]; } coordinates.push(`${x.toFixed(2)}\t${y.toFixed(2)}`); lastLineHadCoordinates = true; } else if (lastLineHadCoordinates) { coordinates.push(''); lastLineHadCoordinates = false; } } while (coordinates.length > 0 && coordinates[coordinates.length - 1] === '') coordinates.pop(); if (coordinates.length === 0) coordinates = importGeo(content, swapXY); if (coordinates.length === 0) return extractCoordinatesFromTextWithDescription(content, swapXY); return coordinates; }
    function extractCoordinatesEntitySpatial(text, swapXY = false) { const coordinates = []; const contours = text.split('</entity_spatial>'); contours.forEach((contour) => { const regex = /<x>(\d+(?:\.\d+)?)<\/x>\s*<y>(\d+(?:\.\d+)?)<\/y>/g; let matches; let currentContour = []; while ((matches = regex.exec(contour)) !== null) { let x = parseFloat(matches[1]); let y = parseFloat(matches[2]); if (swapXY) { if (x > y) [x, y] = [y, x]; } currentContour.push(`${x.toFixed(2)}\t${y.toFixed(2)}`); } if (currentContour.length > 0) { if (coordinates.length > 0) coordinates.push(''); coordinates.push(...currentContour); } }); return coordinates; }
    function extractCoordinatesNewContour(text, swapXY = false) { const coordinates = []; const contours = text.split('</NewContour>'); contours.forEach((contour) => { const regex = /X="(\d+(?:\.\d+)?)"[^>]+Y="(\d+(?:\.\d+))"/g; let matches; let currentContour = []; while ((matches = regex.exec(contour)) !== null) { let x = parseFloat(matches[1]); let y = parseFloat(matches[2]); if (swapXY) { if (x > y) [x, y] = [y, x]; } currentContour.push(`${x.toFixed(2)}\t${y.toFixed(2)}`); } if (currentContour.length > 0) { if (coordinates.length > 0) coordinates.push(''); coordinates.push(...currentContour); } }); return coordinates; }
    function searchInTabs(text, swapXY = false) { const coordinates = []; const lines = text.split('\n'); let currentContour = []; let previousLineHadCoords = false; for (let line of lines) { line = line.trim(); if (!line) continue; const parts = line.split(/[\t\s]+/); let possibleNumbers = parts.map(part => { const num = parseFloat(part.replace(',', '.')); return !isNaN(num) && Math.abs(num) >= 10000 ? num : null; }).filter(num => num !== null); if (possibleNumbers.length >= 2) { let x = possibleNumbers[0]; let y = possibleNumbers[1]; if (swapXY) { if (x > y) [x, y] = [y, x]; } currentContour.push(`${x.toFixed(2)}\t${y.toFixed(2)}`); previousLineHadCoords = true; } else if (previousLineHadCoords && currentContour.length > 0) { coordinates.push(...currentContour); coordinates.push(''); currentContour = []; previousLineHadCoords = false; } } if (currentContour.length > 0) coordinates.push(...currentContour); if (coordinates.length > 0 && coordinates[coordinates.length - 1] === '') coordinates.pop(); return coordinates; }
    function importGeo(text, swapXY = false) { const lines = text.split('\n'); const coordinates = []; const separators = /[,;\t]/; let currentContour = []; for (let line of lines) { line = line.trim(); if (!line) { if (currentContour.length > 0) { coordinates.push(...currentContour); coordinates.push(''); currentContour = []; } continue; } const parts = line.split(separators); let foundCoords = []; for (let part of parts) { const num = parseFloat(part.replace(',', '.')); if (!isNaN(num) && Math.abs(num) >= 10000) { foundCoords.push(num); if (foundCoords.length === 2) break; } } if (foundCoords.length === 2) { let [x, y] = foundCoords[0] < foundCoords[1] ? [foundCoords[0], foundCoords[1]] : [foundCoords[1], foundCoords[0]]; if (swapXY) { if (x > y) [x, y] = [y, x]; } currentContour.push(`${x.toFixed(2)}\t${y.toFixed(2)}`); } } if (currentContour.length > 0) coordinates.push(...currentContour); if (coordinates.length > 0 && coordinates[coordinates.length - 1] === '') coordinates.pop(); return coordinates; }
    function extractCoordinatesFromTextWithDescription(text, swapXY = false) { const lines = text.split('\n'); const coordinates = []; let currentContour = []; let previousLineHadCoords = false; const numberRegex = /[-+]?[0-9]*[.,]?[0-9]+/g; for (let line of lines) { line = line.trim(); if (!line) { if (previousLineHadCoords && currentContour.length > 0) { coordinates.push(...currentContour); coordinates.push(''); currentContour = []; } previousLineHadCoords = false; continue; } const numbers = line.match(numberRegex); const potentialCoords = numbers ? numbers.map(n => parseFloat(n.replace(',', '.'))).filter(n => Math.abs(n) >= 10000) : []; if (potentialCoords.length >= 2) { let [x, y] = potentialCoords[0] < potentialCoords[1] ? [potentialCoords[0], potentialCoords[1]] : [potentialCoords[1], potentialCoords[0]]; if (swapXY) { if (x > y) [x, y] = [y, x]; } currentContour.push(`${x.toFixed(2)}\t${y.toFixed(2)}`); previousLineHadCoords = true; } else if (previousLineHadCoords && currentContour.length > 0) { coordinates.push(...currentContour); coordinates.push(''); currentContour = []; previousLineHadCoords = false; } } if (currentContour.length > 0) coordinates.push(...currentContour); if (coordinates.length > 0 && coordinates[coordinates.length - 1] === '') coordinates.pop(); return coordinates; }
    function isPointOnSegment(point, p1, p2) { const dxc = point.x - p1.x; const dyc = point.y - p1.y; const dxl = p2.x - p1.x; const dyl = p2.y - p1.y; const cross = dxc * dyl - dyc * dxl; if (Math.abs(cross) > 1e-6) return false; if (Math.abs(dxl) >= Math.abs(dyl)) return dxl > 0 ? p1.x <= point.x && point.x <= p2.x : p2.x <= point.x && point.x <= p1.x; else return dyl > 0 ? p1.y <= point.y && point.y <= p2.y : p2.y <= point.y && point.y <= p1.y; }
    function polygonsIntersect(poly1, poly2) { function getAxes(poly) { const axes = []; for (let i = 0; i < poly.length; i++) { const p1 = poly[i]; const p2 = poly[(i + 1) % poly.length]; const edge = { x: p2.x - p1.x, y: p2.y - p1.y }; const normal = { x: -edge.y, y: edge.x }; axes.push(normal); } return axes; } function project(poly, axis) { let min = Infinity, max = -Infinity; for (const point of poly) { const projection = point.x * axis.x + point.y * axis.y; min = Math.min(min, projection); max = Math.max(max, projection); } return { min, max }; } function overlap(proj1, proj2) { return proj1.max >= proj2.min && proj2.max >= proj1.min; } const axes1 = getAxes(poly1); const axes2 = getAxes(poly2); for (const axis of axes1) { const proj1 = project(poly1, axis); const proj2 = project(poly2, axis); if (!overlap(proj1, proj2)) return false; } for (const axis of axes2) { const proj1 = project(poly1, axis); const proj2 = project(poly2, axis); if (!overlap(proj1, proj2)) return false; } return true; }
    function polygonsJustTouch(poly1, poly2) { for (const p1 of poly1) { for (const p2 of poly2) { if (Math.abs(p1.x - p2.x) < 1e-6 && Math.abs(p1.y - p2.y) < 1e-6) return true; } } for (let i = 0; i < poly1.length; i++) { const p1_start = poly1[i]; const p1_end = poly1[(i + 1) % poly1.length]; for (let j = 0; j < poly2.length; j++) { const p2_start = poly2[j]; const p2_end = poly2[(j + 1) % poly2.length]; if (segmentsCoincide(p1_start, p1_end, p2_start, p2_end)) return true; } } return false; }
    function segmentsCoincide(p1_start, p1_end, p2_start, p2_end) { function onSegment(p, q, r) { if (q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) && q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y)) return true; return false; } function orientation(p, q, r) { let val = (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y); if (Math.abs(val) < 1e-6) return 0; return (val > 0) ? 1 : 2; } let o1 = orientation(p1_start, p1_end, p2_start); let o2 = orientation(p1_start, p1_end, p2_end); let o3 = orientation(p2_start, p2_end, p1_start); let o4 = orientation(p2_start, p2_end, p1_end); if (o1 == 0 && onSegment(p1_start, p2_start, p1_end)) return true; if (o2 == 0 && onSegment(p1_start, p2_end, p1_end)) return true; if (o3 == 0 && onSegment(p2_start, p1_start, p2_end)) return true; if (o4 == 0 && onSegment(p2_start, p1_end, p2_end)) return true; return false; }
    function lineIntersectsPolygon(line, polygon) { for (let i = 0; i < polygon.length; i++) { const p1 = polygon[i]; const p2 = polygon[(i + 1) % polygon.length]; if (lineSegmentsIntersect(line[0], line[1], p1, p2)) return true; } return false; }
    function lineSegmentsIntersect(p1, p2, q1, q2) { function orientation(p, q, r) { let val = (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y); return Math.abs(val) < 1e-6 ? 0 : (val > 0 ? 1 : 2); } let o1 = orientation(p1, p2, q1); let o2 = orientation(p1, p2, q2); let o3 = orientation(q1, q2, p1); let o4 = orientation(q1, q2, p2); if (o1 != o2 && o3 != o4) return true; if (o1 == 0 && onSegment(p1, q1, p2)) return true; if (o2 == 0 && onSegment(p1, q2, p2)) return true; if (o3 == 0 && onSegment(q1, p1, q2)) return true; if (o4 == 0 && onSegment(q1, p2, q2)) return true; return false; function onSegment(p, q, r) { return q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) && q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y); } }

function arePolygonsEffectivelyIdentical(poly1, poly2, tolerance = 1e-5) {
    if (poly1.length !== poly2.length) return false;
    if (poly1.length === 0) return true; // Both empty, considered identical

    // Check for a direct match (same starting point, same order)
    let directMatch = true;
    for (let i = 0; i < poly1.length; i++) {
        if (Math.abs(poly1[i].x - poly2[i].x) > tolerance ||
            Math.abs(poly1[i].y - poly2[i].y) > tolerance) {
            directMatch = false;
            break;
        }
    }
    if (directMatch) return true;

    // Check for a match with poly2 reversed (same starting point for poly1, poly2's end point)
    let reverseMatch = true;
    for (let i = 0; i < poly1.length; i++) {
        if (Math.abs(poly1[i].x - poly2[poly1.length - 1 - i].x) > tolerance ||
            Math.abs(poly1[i].y - poly2[poly1.length - 1 - i].y) > tolerance) {
            reverseMatch = false;
            break;
        }
    }
    if (reverseMatch) return true;
    
    // More complex: Check for cyclic shifts if needed, but for "all coordinates match"
    // one of the above should typically cover it if the data is consistent.
    // If polygons can start at different vertices but are otherwise identical:
    if (poly1.length > 2) { // Only try cyclic for actual polygons
        for (let offset = 0; offset < poly1.length; offset++) {
            // Forward shifted poly2
            let cyclicForwardMatch = true;
            for (let i = 0; i < poly1.length; i++) {
                if (Math.abs(poly1[i].x - poly2[(i + offset) % poly1.length].x) > tolerance ||
                    Math.abs(poly1[i].y - poly2[(i + offset) % poly1.length].y) > tolerance) {
                    cyclicForwardMatch = false;
                    break;
                }
            }
            if (cyclicForwardMatch) return true;

            // Reversed poly2, then cyclically shifted
            let cyclicReverseMatch = true;
            for (let i = 0; i < poly1.length; i++) {
                 // poly2_reversed_shifted_point = poly2[ (poly1.length - 1 - i + offset) % poly1.length ] - this is tricky to get right.
                 // simpler: poly2_reversed_point = poly2[poly1.length - 1 - ((i + offset) % poly1.length)]
                 // Correct logic for reversed and shifted: poly2[ (poly1.length - 1 - i + offset + poly1.length) % poly1.length ]
                 // To match poly1[i] with reversed and shifted poly2:
                 // poly1[i] vs poly2[ (offset - i + poly1.length) % poly1.length ] for poly2_reversed (then shifted by offset)
                 // It's poly2_reversed[(i+offset)%N]. poly2_reversed[k] = poly2[N-1-k].
                 // So poly2[N-1 - ((i+offset)%N)]
                const poly2ReversedIndex = (poly1.length - 1 - i + poly1.length) % poly1.length; // Index for simple reverse
                const poly2ReversedShiftedIndex = (poly2ReversedIndex + offset + poly1.length) % poly1.length; // Then shift it

                if (Math.abs(poly1[i].x - poly2[poly2ReversedShiftedIndex].x) > tolerance ||
                    Math.abs(poly1[i].y - poly2[poly2ReversedShiftedIndex].y) > tolerance) {
                    // This cyclic reverse check is still complex to get perfectly right with indexing.
                    // For now, let's rely on the direct and simple reverse.
                    // If this becomes an issue, a canonical representation of polygons is better.
                }
            }
            // if (cyclicReverseMatch) return true; // Temporarily disable complex cyclic reverse
        }
    }


    return false;
}

function findOverlappingParcels() {
    const overlappingParcels = new Set();
    if (importedContours.length === 0 || allContours.length === 0) return [];

    importedContours.forEach(importedPolygonPoints => { // importedPolygonPoints is already an array of {x,y}
        // Check if the imported contour itself is a valid closed polygon for area-based checks
        const isImportedClosedPolygon = importedPolygonPoints.length >= 3 && checkIfClosedContour(importedPolygonPoints);

        allContours.forEach(parcel => {
            parcel.contours.forEach(existingPolygonPoints => { // existingPolygonPoints is from parcel.contours
                const isExistingClosedPolygon = existingPolygonPoints.length >= 3 && checkIfClosedContour(existingPolygonPoints);

                if (isImportedClosedPolygon && isExistingClosedPolygon) {
                    // Both are closed polygons, perform polygon intersection tests
                    if (polygonsIntersect(existingPolygonPoints, importedPolygonPoints)) {
                        if (arePolygonsEffectivelyIdentical(existingPolygonPoints, importedPolygonPoints)) {
                            overlappingParcels.add(parcel.cadastralNumber);
                        } else {
                            const justTouching = polygonsJustTouch(existingPolygonPoints, importedPolygonPoints);
                            if (!justTouching) { // If they intersect and are NOT just touching, it's a clear overlap
                                overlappingParcels.add(parcel.cadastralNumber);
                            } else {
                                // They are just touching but not identical. Check for partial overlap / containment.
                                let hasPointStrictlyInside = false;
                                // Check if any point of importedPolygonPoints is strictly inside existingPolygonPoints
                                for (const point of importedPolygonPoints) {
                                    if (isPointInPolygon(point, existingPolygonPoints)) {
                                        let onBoundary = false;
                                        for (let i = 0; i < existingPolygonPoints.length; i++) {
                                            const p1 = existingPolygonPoints[i];
                                            const p2 = existingPolygonPoints[(i + 1) % existingPolygonPoints.length];
                                            if (isPointOnSegment(point, p1, p2)) { onBoundary = true; break; }
                                        }
                                        if (!onBoundary) { hasPointStrictlyInside = true; break; }
                                    }
                                }
                                // If not found, check if any point of existingPolygonPoints is strictly inside importedPolygonPoints
                                if (!hasPointStrictlyInside) {
                                    for (const point of existingPolygonPoints) {
                                        if (isPointInPolygon(point, importedPolygonPoints)) {
                                            let onBoundary = false;
                                            for (let i = 0; i < importedPolygonPoints.length; i++) {
                                                const p1 = importedPolygonPoints[i];
                                                const p2 = importedPolygonPoints[(i + 1) % importedPolygonPoints.length];
                                                if (isPointOnSegment(point, p1, p2)) { onBoundary = true; break; }
                                            }
                                            if (!onBoundary) { hasPointStrictlyInside = true; break; }
                                        }
                                    }
                                }

                                if (hasPointStrictlyInside) {
                                    overlappingParcels.add(parcel.cadastralNumber);
                                }
                            }
                        }
                    }
                } else if (!isImportedClosedPolygon && importedPolygonPoints.length >= 2 && isExistingClosedPolygon) {
                    // Imported is a line, existing is a polygon
                    if (lineIntersectsPolygon(importedPolygonPoints, existingPolygonPoints)) {
                        overlappingParcels.add(parcel.cadastralNumber);
                    }
                }
                // Other cases (e.g., imported is polygon, existing is line, or both are lines) can be added if needed
            });
        });
    });
    return Array.from(overlappingParcels);
}

    function updateOverlappingParcelsList() {
        const listElement = document.getElementById('overlappingParcelsList'); listElement.innerHTML = '';
        const overlappingParcels = findOverlappingParcels();
        if (overlappingParcels.length > 0) { const titleElement = document.createElement('div'); titleElement.className = 'section-title'; titleElement.innerHTML = `<i class="fas fa-exclamation-triangle"></i> Найдено ${overlappingParcels.length} пересечений`; listElement.appendChild(titleElement); overlappingParcels.forEach(cadastralNumber => { const listItem = document.createElement('li'); listItem.textContent = cadastralNumber; listItem.addEventListener('click', () => { highlightParcel(cadastralNumber); }); listItem.addEventListener('dblclick', function() { copyToClipboard(this.textContent); }); listElement.appendChild(listItem); }); }
        else if (importedContours.length > 0) { const listItem = document.createElement('li'); listItem.textContent = "Нет пересекающихся участков"; listItem.style.color = "#4CAF50"; listItem.style.fontStyle = "italic"; listElement.appendChild(listItem); }
    }

    async function extractAllCadastralNumbersFromXML(xmlContent) {
        return new Promise((resolve) => {
            setTimeout(() => {
                const parser = new DOMParser(); const xmlDoc = parser.parseFromString(xmlContent, "text/xml"); const numbers = []; const processedNumbers = new Set();
                const isUnified = xmlContent.includes("<value>Единое землепользование</value>");
                if (isUnified) { const contours = xmlDoc.querySelectorAll('contour'); contours.forEach(contour => { const cadNumber = getElementValue(contour, 'cad_number'); if (cadNumber && !processedNumbers.has(cadNumber)) { numbers.push({ cadastralNumber: cadNumber, type: 'parcel' }); processedNumbers.add(cadNumber); } }); }
                else { const landRecords = xmlDoc.querySelectorAll('land_record'); landRecords.forEach(record => { const cadNumber = getElementValue(record, 'object > common_data > cad_number'); if (cadNumber && !processedNumbers.has(cadNumber)) { numbers.push({ cadastralNumber: cadNumber, type: 'parcel' }); processedNumbers.add(cadNumber); } }); }
                const buildRecords = xmlDoc.querySelectorAll('build_record'); buildRecords.forEach(record => { const cadNumber = getElementValue(record, 'object > common_data > cad_number'); if (cadNumber && !processedNumbers.has(cadNumber)) { numbers.push({ cadastralNumber: cadNumber, type: 'building' }); processedNumbers.add(cadNumber); } });
                const constructionRecords = xmlDoc.querySelectorAll('construction_record'); constructionRecords.forEach(record => { const cadNumber = getElementValue(record, 'object > common_data > cad_number'); if (cadNumber && !processedNumbers.has(cadNumber)) { numbers.push({ cadastralNumber: cadNumber, type: 'construction' }); processedNumbers.add(cadNumber); } });
                const zoneRecords = xmlDoc.querySelectorAll('zones_and_territories_record, municipal_boundaries > municipal_boundary_record, inhabited_locality_boundaries > inhabited_locality_boundary_record');
                zoneRecords.forEach(record => { const regNumbBorder = getElementValue(record, 'b_object > reg_numb_border'); if (regNumbBorder && !processedNumbers.has(regNumbBorder)) { numbers.push({ cadastralNumber: regNumbBorder, type: 'zone' }); processedNumbers.add(regNumbBorder); } });
                resolve(numbers);
            }, 50);
        });
    }

    function showSelectionDialog(availableNumbers, sourceFileName) {
        const listDialog = document.getElementById('listDialog'); const dialogOverlay = document.getElementById('dialogOverlay');
        const parcelsContainer = document.getElementById('parcelsList'); const buildingsContainer = document.getElementById('buildingsList'); const zonesContainer = document.getElementById('zonesListContainer'); // New
        const searchInput = document.getElementById('searchInput'); const loaderContainer = document.getElementById('loaderContainer');
        const listDialogFooter = document.querySelector('#listDialog .list-dialog-footer');
        const parcelsTabBtn = document.querySelector('.tab-btn[data-tab="parcels"]'); const buildingsTabBtn = document.querySelector('.tab-btn[data-tab="buildings"]'); const zonesTabBtn = document.querySelector('.tab-btn[data-tab="zones"]'); // New
        selectableNumbersCache = [...availableNumbers];
        parcelsContainer.innerHTML = ''; buildingsContainer.innerHTML = ''; zonesContainer.innerHTML = ''; // Clear zones
        searchInput.value = ''; document.getElementById('clearSearchBtn').style.display = 'none';
        let loadSelectedBtn = document.getElementById('loadSelectedBtn'); let toggleSelectAllBtn = document.getElementById('toggleSelectAllBtn');
        if (loadSelectedBtn) loadSelectedBtn.remove(); if (toggleSelectAllBtn) toggleSelectAllBtn.remove();
        loadSelectedBtn = document.createElement('button'); loadSelectedBtn.id = 'loadSelectedBtn'; loadSelectedBtn.className = 'list-footer-btn'; loadSelectedBtn.innerHTML = '<i class="fas fa-check-circle" style="color:#27ae60;"></i> Загрузить выбранные'; loadSelectedBtn.style.order = 1;
        toggleSelectAllBtn = document.createElement('button'); toggleSelectAllBtn.id = 'toggleSelectAllBtn'; toggleSelectAllBtn.className = 'list-footer-btn'; toggleSelectAllBtn.innerHTML = '<i class="far fa-square-check"></i> Выбрать все'; toggleSelectAllBtn.dataset.state = 'none-selected'; toggleSelectAllBtn.style.order = 0;
        Array.from(listDialogFooter.children).forEach(btn => btn.style.display = 'none'); listDialogFooter.appendChild(toggleSelectAllBtn); listDialogFooter.appendChild(loadSelectedBtn);
        loadSelectedBtn.addEventListener('click', async () => {
            const selectedNumbers = getSelectedNumbersFromDialog(); if (selectedNumbers.length === 0) { showNotification('Не выбрано ни одного объекта для загрузки.', 'warning', 'exclamation-triangle'); return; }
            listDialog.style.display = 'none'; dialogOverlay.style.display = 'none'; loaderContainer.style.display = 'flex'; updateLoaderProgress(0, 1, 'Загрузка выбранных объектов...');
            setTimeout(async () => {
                try { await processFilteredXMLContent(rawXmlContentForSelection, selectedNumbers, sourceFileName); showNotification(`Загружено ${selectedNumbers.length} выбранных объектов`, 'success', 'check-circle'); }
                catch (error) { showNotification('Ошибка при загрузке выбранных объектов: ' + error.message, 'error', 'exclamation-circle'); }
                finally { isSelectiveLoadMode = false; rawXmlContentForSelection = null; selectableNumbersCache = []; loaderContainer.style.display = 'none'; loadSelectedBtn.remove(); toggleSelectAllBtn.remove(); Array.from(listDialogFooter.children).forEach(btn => btn.style.display = 'flex'); }
            }, 100);
        });
        toggleSelectAllBtn.addEventListener('click', () => { const currentState = toggleSelectAllBtn.dataset.state; const activeTabContent = document.querySelector('.tab-content.active'); const checkboxes = activeTabContent.querySelectorAll('input[type="checkbox"]'); const selectAll = currentState === 'none-selected'; checkboxes.forEach(cb => cb.checked = selectAll); updateToggleAllButtonState(); });
        const parcels = selectableNumbersCache.filter(n => n.type === 'parcel' || n.type === 'common_land');
        const buildings = selectableNumbersCache.filter(n => n.type === 'building' || n.type === 'construction');
        const zones = selectableNumbersCache.filter(n => n.type === 'zone'); // New
        populateSelectionList(parcelsContainer, parcels, 'parcel', false); populateSelectionList(buildingsContainer, buildings, 'building', false); populateSelectionList(zonesContainer, zones, 'zone', false); // New
        parcelsTabBtn.textContent = `Земельные участки (${parcels.length})`; buildingsTabBtn.textContent = `ОКС (${buildings.length})`; zonesTabBtn.textContent = `Зоны (${zones.length})`; // New
        listDialog.addEventListener('change', (event) => { if (event.target.type === 'checkbox') updateToggleAllButtonState(); });
        searchInput.addEventListener('input', updateToggleAllButtonState); parcelsTabBtn.addEventListener('click', updateToggleAllButtonState); buildingsTabBtn.addEventListener('click', updateToggleAllButtonState); zonesTabBtn.addEventListener('click', updateToggleAllButtonState); // New
        listDialog.style.display = 'flex'; dialogOverlay.style.display = 'block'; loaderContainer.style.display = 'none';
        if (parcels.length > 0) parcelsTabBtn.click(); else if (buildings.length > 0) buildingsTabBtn.click(); else if (zones.length > 0) zonesTabBtn.click(); // New
        updateToggleAllButtonState();
    }

    function updateToggleAllButtonState() {
        const toggleSelectAllBtn = document.getElementById('toggleSelectAllBtn'); if (!toggleSelectAllBtn) return;
        const activeTabContent = document.querySelector('.tab-content.active'); if (!activeTabContent) return;
        const checkboxes = activeTabContent.querySelectorAll('.list-item-selection input[type="checkbox"]'); const totalVisible = checkboxes.length; const totalChecked = activeTabContent.querySelectorAll('.list-item-selection input[type="checkbox"]:checked').length;
        if (totalVisible === 0) { toggleSelectAllBtn.innerHTML = '<i class="far fa-square-check"></i> Выбрать все'; toggleSelectAllBtn.dataset.state = 'none-selected'; toggleSelectAllBtn.disabled = true; }
        else if (totalChecked === totalVisible) { toggleSelectAllBtn.innerHTML = '<i class="far fa-check-square"></i> Снять все'; toggleSelectAllBtn.dataset.state = 'all-selected'; toggleSelectAllBtn.disabled = false; }
        else { toggleSelectAllBtn.innerHTML = '<i class="far fa-square-check"></i> Выбрать все'; toggleSelectAllBtn.dataset.state = 'none-selected'; toggleSelectAllBtn.disabled = false; }
    }

    function populateSelectionList(container, items, typePrefix, checkedSet) {
        container.innerHTML = '';
        if (!Array.isArray(items) || items.length === 0) { container.innerHTML = `<div class="empty-list">${typePrefix === 'parcel' ? 'ЗУ не найдены' : (typePrefix === 'building' ? 'ОКС не найдены' : 'Зоны не найдены')}</div>`; return; }
        const sortedItems = [...items].sort((a, b) => { const numA = a && a.cadastralNumber ? a.cadastralNumber : ''; const numB = b && b.cadastralNumber ? b.cadastralNumber : ''; return numA.localeCompare(numB); });
        sortedItems.forEach((item, index) => {
            if (!item || !item.cadastralNumber || typeof item.cadastralNumber !== 'string') return; // cadastralNumber is used as identifier
            const listItem = document.createElement('div'); listItem.className = 'list-item list-item-selectable'; const checkboxId = `${typePrefix}-checkbox-${index}`;
            const isChecked = checkedSet && checkedSet.has(item.cadastralNumber) ? 'checked' : '';
            let displayType = '';
            if (item.type === 'parcel') displayType = 'ЗУ'; else if (item.type === 'common_land') displayType = 'ЕЗ'; else if (item.type === 'building') displayType = 'Здание'; else if (item.type === 'construction') displayType = 'Сооружение'; else if (item.type === 'zone') displayType = 'Зона/Терр.';
            const idDisplay = item.cadastralNumber; // Use cadastralNumber (which is regNumbBorder for zones)
            listItem.innerHTML = `<div class="list-item-selection"><input type="checkbox" id="${checkboxId}" data-cadnum="${idDisplay}" ${isChecked}><label for="${checkboxId}" class="list-item-info"><span class="list-item-number">${idDisplay}</span>${displayType ? `<span class="list-item-type">${displayType}</span>` : ''}</label></div><div class="list-item-actions" style="visibility: hidden;"></div>`;
            container.appendChild(listItem);
        });
    }

    function getSelectedNumbersFromDialog() { const selectedNumbers = []; document.querySelectorAll('#listDialog input[type="checkbox"]:checked').forEach(checkbox => { selectedNumbers.push(checkbox.dataset.cadnum); }); return selectedNumbers; }

    async function processFilteredXMLContent(xmlContent, selectedNumbers, fileName) {
        const cleanup = () => { isSelectiveLoadMode = false; rawXmlContentForSelection = null; selectableNumbersCache = []; };
        try {
            if (!xmlContent || !selectedNumbers || selectedNumbers.length === 0) { cleanup(); return; }
            const selectedSet = new Set(selectedNumbers); const parser = new DOMParser(); const xmlDoc = parser.parseFromString(xmlContent, "text/xml");
            isUnifiedLandUse = determineDocumentTypeFromString(xmlContent); commonLandLinksMap = {};
            allContours = []; buildingsContours = []; zonesAndTerritoriesContours = [];
            if (isUnifiedLandUse) { const contourElements = xmlDoc.querySelectorAll('contour'); contourElements.forEach((contourElement, index) => { const cadNumber = getElementValue(contourElement, 'cad_number'); if (cadNumber && selectedSet.has(cadNumber)) { const spatialElement = contourElement.querySelector("entity_spatial"); if (spatialElement) { const contourCoords = []; const ordinates = spatialElement.querySelectorAll("ordinate"); for (let i = 0; i < ordinates.length; i++) { const xElem = ordinates[i].querySelector("x"); const yElem = ordinates[i].querySelector("y"); if (xElem && yElem) { const x = parseFloat(xElem.textContent); const y = parseFloat(yElem.textContent); if (!isNaN(x) && !isNaN(y)) contourCoords.push({ x, y }); } } if (contourCoords.length > 0) { const areaInfo = extractAreaFromSpecialNotes(xmlDoc, cadNumber); allContours.push({ parcelIndex: index, cadastralNumber: cadNumber, contours: [contourCoords], isDeclaredArea: false, area: areaInfo.area || 0, areaString: areaInfo.areaString || '', record: contourElement }); } } } }); }
            else { const landRecords = xmlDoc.querySelectorAll('land_record'); landRecords.forEach((record, index) => { const cadNumber = getElementValue(record, 'object > common_data > cad_number'); if (cadNumber && selectedSet.has(cadNumber)) { let contours = extractCoordinatesFromXML(record); if (contours.length > 0) { const areaInfo = getAreaInfo(record); const commonLandLinkNum = getElementValue(record, 'cad_links > common_land > common_land_cad_number > cad_number'); allContours.push({ parcelIndex: index, cadastralNumber: cadNumber, contours: contours, isDeclaredArea: areaInfo.isDeclaredArea, isIsolatedParcel: !!commonLandLinkNum, commonLandCadNumber: commonLandLinkNum, record: record }); if (commonLandLinkNum) { if (!commonLandLinksMap[commonLandLinkNum]) commonLandLinksMap[commonLandLinkNum] = []; commonLandLinksMap[commonLandLinkNum].push(cadNumber); } } } const commonLandNumber = getElementValue(record, 'cad_links > common_land > common_land_cad_number > cad_number'); if (commonLandNumber && selectedSet.has(commonLandNumber)) { const isolatedParcelCadNum = getElementValue(record, 'object > common_data > cad_number'); if(isolatedParcelCadNum) { if (!commonLandLinksMap[commonLandNumber]) commonLandLinksMap[commonLandNumber] = []; if (!commonLandLinksMap[commonLandNumber].includes(isolatedParcelCadNum)) commonLandLinksMap[commonLandNumber].push(isolatedParcelCadNum); } } }); }
            const buildRecords = xmlDoc.querySelectorAll('build_record'); buildRecords.forEach(record => { const cadNumber = getElementValue(record, 'object > common_data > cad_number'); if (cadNumber && selectedSet.has(cadNumber)) { let contours = extractBuildingCoordinatesFromXML(record); if (contours.length > 0) buildingsContours.push({ cadastralNumber: cadNumber, contours: contours, type: 'building', record: record }); } });
            const constructionRecords = xmlDoc.querySelectorAll('construction_record'); constructionRecords.forEach(record => { const cadNumber = getElementValue(record, 'object > common_data > cad_number'); if (cadNumber && selectedSet.has(cadNumber)) { let contours = extractBuildingCoordinatesFromXML(record); if (contours.length > 0) buildingsContours.push({ cadastralNumber: cadNumber, contours: contours, type: 'construction', record: record }); } });
            const zoneRecordsAll = xmlDoc.querySelectorAll('zones_and_territories_record, municipal_boundaries > municipal_boundary_record, inhabited_locality_boundaries > inhabited_locality_boundary_record'); // Get all potential zone records
            zoneRecordsAll.forEach(record => { const regNumbBorder = getElementValue(record, 'b_object > reg_numb_border'); if (regNumbBorder && selectedSet.has(regNumbBorder)) { let contours = extractZoneOrTerritoryCoordinatesFromXML(record); if (contours.length > 0) zonesAndTerritoriesContours.push({ regNumbBorder: regNumbBorder, contours: contours, type: 'zone_or_territory', record: record }); } }); // Store zones

            selectedCadastralNumber = null; selectedBuildingNumber = null; selectedZoneOrTerritoryRegNumber = null; selectedImportedObjectIndex = -1; highlightedIsolatedParcels.clear(); selectedCoordinate = null; selectedPoints = []; rulerPoints = []; rulerMode = false;
              visibleZoneRegNumbers.clear();       // NEW
        initialZoneSelectionApplied = false; // NEW
        showZones = false;                   // NEW: Ensure zones are off by default for filtered content
        updateZonesButtonVisualState(); 
            document.getElementById('rulerBtn')?.classList.remove('active'); document.getElementById('measurementPanel')?.classList.remove('active'); updateMeasurementPanel();
            document.getElementById('fileInputLabel').textContent = fileName || 'Выберите файл'; updateDocumentTitle(xmlContent); initCadastralInput(); displayParcelInfo(null); document.getElementById('overlappingParcelsList').innerHTML = '';
            const canvasEl = document.getElementById('kptSchemeCanvas');
            if (!canvasEl) {
                cleanup();
                showNotification("Ошибка: Не найден холст для отрисовки.", "error");
                return;
            }
            const ctx = canvasEl.getContext('2d');
            if (allContours.length > 0 || buildingsContours.length > 0 || zonesAndTerritoriesContours.length > 0 || importedContours.length > 0) drawKPTScheme();
            else { ctx.clearRect(0, 0, canvasEl.width, canvasEl.height); ctx.fillStyle = 'white'; ctx.fillRect(0, 0, canvasEl.width, canvasEl.height); showNotification('Выбранные объекты не содержат графики для отображения.', 'warning', 'exclamation-triangle'); }
            document.getElementById('infoPanel')?.scrollTo(0, 0); cleanup();
        } catch (error) { cleanup(); throw error; }
    }

    function highlightParcel(cadastralNumber) { // This is for ZU, might need a generic highlightObject
        selectedCadastralNumber = cadastralNumber; selectedBuildingNumber = null; selectedZoneOrTerritoryRegNumber = null; selectedImportedObjectIndex = -1; highlightedIsolatedParcels.clear();
        const foundParcelObject = allContours.find(p => p.cadastralNumber === cadastralNumber);
        let parcelData = null; let sourceElementForData = null;
        if (foundParcelObject && foundParcelObject.record) sourceElementForData = foundParcelObject.record;
        else if (window.xmlContent) { const parser = new DOMParser(); const xmlDoc = parser.parseFromString(window.xmlContent, "text/xml"); if (isUnifiedLandUse) sourceElementForData = Array.from(xmlDoc.querySelectorAll('contour')).find(c => getElementValue(c, 'cad_number') === cadastralNumber); else sourceElementForData = Array.from(xmlDoc.querySelectorAll('land_record')).find(r => getElementValue(r, 'object > common_data > cad_number') === cadastralNumber); }
        if (sourceElementForData) { parcelData = extractData(sourceElementForData); displayParcelInfo(parcelData); }
        else displayParcelInfo({ cadNumber: cadastralNumber, objectType: 'Земельный участок (данные неполные)' });
        const adjacentParcels = getAdjacentParcelsForSelected(selectedCadastralNumber); const adjacentParcelsForImported = getAdjacentParcelsForImported();
        redraw(adjacentParcels, adjacentParcelsForImported, true);
    }

    const addObjectBtn = document.getElementById('addObjectBtn');
    const coordsDialog = document.getElementById('coordsDialog');
    const dialogOverlay = document.getElementById('dialogOverlay');
    const closeDialogBtn = document.getElementById('closeDialogBtn');

    if (addObjectBtn && coordsDialog && dialogOverlay && closeDialogBtn) {
        addObjectBtn.addEventListener('click', () => { coordsDialog.style.display = 'block'; coordsDialog.style.opacity = '0'; dialogOverlay.style.display = 'block'; void coordsDialog.offsetWidth; coordsDialog.style.opacity = '1'; document.getElementById('coordsInput').focus(); });
        closeDialogBtn.addEventListener('click', () => { closeCoordinateDialog(); });
        dialogOverlay.addEventListener('click', () => { closeCoordinateDialog(); });
        coordsDialog.addEventListener('click', (e) => { e.stopPropagation(); });
    }

    document.getElementById('listBtn').addEventListener('click', function() {
        const listDialog = document.getElementById('listDialog'); listDialog.style.display = 'flex'; dialogOverlay.style.display = 'block';
        populateParcelsList(); populateBuildingsList(); populateZonesList(); // Populate new zones list
        const firstTabWithContent = document.querySelector('#parcelsList:not(:empty)') ? 'parcels' :
                                 document.querySelector('#buildingsList:not(:empty)') ? 'buildings' :
                                 document.querySelector('#zonesListContainer:not(:empty)') ? 'zones' : 'parcels'; // Check zones too
        const tabButton = document.querySelector(`.tab-btn[data-tab="${firstTabWithContent}"]`);
        if (tabButton) tabButton.click();
    });
    document.getElementById('closeListBtn').addEventListener('click', function() {
        const listDialog = document.getElementById('listDialog'); const dialogOverlay = document.getElementById('dialogOverlay'); const listDialogFooter = document.querySelector('#listDialog .list-dialog-footer');
        listDialog.style.display = 'none'; dialogOverlay.style.display = 'none';
        if (isSelectiveLoadMode) { const loadSelectedBtn = document.getElementById('loadSelectedBtn'); const toggleSelectAllBtn = document.getElementById('toggleSelectAllBtn'); if (loadSelectedBtn) loadSelectedBtn.remove(); if (toggleSelectAllBtn) toggleSelectAllBtn.remove(); Array.from(listDialogFooter.children).forEach(btn => btn.style.display = 'flex'); isSelectiveLoadMode = false; rawXmlContentForSelection = null; selectableNumbersCache = []; }
    });
    document.querySelectorAll('.tab-btn').forEach(btn => { btn.addEventListener('click', function() { document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active')); document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active')); this.classList.add('active'); const tabId = this.getAttribute('data-tab') + 'Tab'; const tabContent = document.getElementById(tabId); if (tabContent) tabContent.classList.add('active'); }); });
    document.getElementById('searchInput').addEventListener('input', function() { const searchTerm = this.value.trim().toLowerCase(); document.getElementById('clearSearchBtn').style.display = searchTerm ? 'block' : 'none'; filterLists(searchTerm); });
    document.getElementById('clearSearchBtn').addEventListener('click', function() { document.getElementById('searchInput').value = ''; document.getElementById('clearSearchBtn').style.display = 'none'; filterLists(''); });

    function getCheckedNumbersFromDOM() { const checkedSet = new Set(); document.querySelectorAll('#listDialog .list-item-selection input[type="checkbox"]:checked').forEach(checkbox => { if (checkbox.dataset && checkbox.dataset.cadnum) checkedSet.add(checkbox.dataset.cadnum); }); return checkedSet; }

    function filterLists(searchTerm) {
        const lowerSearchTerm = searchTerm.trim().toLowerCase(); const searchInput = document.getElementById('searchInput'); const clearSearchBtn = document.getElementById('clearSearchBtn');
        const parcelsContainer = document.getElementById('parcelsList'); const buildingsContainer = document.getElementById('buildingsList'); const zonesContainer = document.getElementById('zonesListContainer');
        if (clearSearchBtn) clearSearchBtn.style.display = lowerSearchTerm ? 'block' : 'none';
        const originallyCheckedSet = getCheckedNumbersFromDOM();
        let parcelsToDisplay = [], buildingsToDisplay = [], zonesToDisplay = [];
        let sourceParcels = [], sourceBuildings = [], sourceZones = [];

        if (isSelectiveLoadMode) {
            sourceParcels = selectableNumbersCache.filter(n => n.type === 'parcel' || n.type === 'common_land');
            sourceBuildings = selectableNumbersCache.filter(n => n.type === 'building' || n.type === 'construction');
            sourceZones = selectableNumbersCache.filter(n => n.type === 'zone');
        } else {
            sourceParcels = allContours; sourceBuildings = buildingsContours; sourceZones = zonesAndTerritoriesContours;
        }

        const finalParcelsToShow = new Map(); const finalBuildingsToShow = new Map(); const finalZonesToShow = new Map();
        if (!lowerSearchTerm) {
            sourceParcels.forEach(item => finalParcelsToShow.set(item.cadastralNumber, item));
            sourceBuildings.forEach(item => finalBuildingsToShow.set(item.cadastralNumber, item));
            sourceZones.forEach(item => finalZonesToShow.set(item.regNumbBorder, item));
            if (!isSelectiveLoadMode) { filteredParcels = [...allContours]; filteredBuildings = [...buildingsContours]; filteredZones = [...zonesAndTerritoriesContours]; }
        } else {
            const textFilteredParcels = sourceParcels.filter(item => item && item.cadastralNumber && typeof item.cadastralNumber === 'string' && item.cadastralNumber.toLowerCase().includes(lowerSearchTerm));
            const textFilteredBuildings = sourceBuildings.filter(item => item && item.cadastralNumber && typeof item.cadastralNumber === 'string' && item.cadastralNumber.toLowerCase().includes(lowerSearchTerm));
            const textFilteredZones = sourceZones.filter(item => item && item.regNumbBorder && typeof item.regNumbBorder === 'string' && item.regNumbBorder.toLowerCase().includes(lowerSearchTerm)); // Filter zones by regNumbBorder
            textFilteredParcels.forEach(item => finalParcelsToShow.set(item.cadastralNumber, item));
            textFilteredBuildings.forEach(item => finalBuildingsToShow.set(item.cadastralNumber, item));
            textFilteredZones.forEach(item => finalZonesToShow.set(item.regNumbBorder, item));
            originallyCheckedSet.forEach(id => {
                if (!finalParcelsToShow.has(id)) { const originalItem = sourceParcels.find(p => p.cadastralNumber === id); if (originalItem) finalParcelsToShow.set(id, originalItem); }
                if (!finalBuildingsToShow.has(id)) { const originalItem = sourceBuildings.find(b => b.cadastralNumber === id); if (originalItem) finalBuildingsToShow.set(id, originalItem); }
                if (!finalZonesToShow.has(id)) { const originalItem = sourceZones.find(z => z.regNumbBorder === id); if (originalItem) finalZonesToShow.set(id, originalItem); }
            });
            if (!isSelectiveLoadMode && !isUnifiedLandUse && isCommonLandFormat(lowerSearchTerm) && commonLandLinksMap[lowerSearchTerm]) { const linkedKNs = commonLandLinksMap[lowerSearchTerm]; if (linkedKNs) { linkedKNs.forEach(linkedKN => { if (!finalParcelsToShow.has(linkedKN)){ const linkedParcel = allContours.find(p => p.cadastralNumber === linkedKN); if (linkedParcel) finalParcelsToShow.set(linkedKN, linkedParcel); } }); } }
            if (!isSelectiveLoadMode) { filteredParcels = Array.from(finalParcelsToShow.values()); filteredBuildings = Array.from(finalBuildingsToShow.values()); filteredZones = Array.from(finalZonesToShow.values()); }
        }
        parcelsToDisplay = Array.from(finalParcelsToShow.values()); buildingsToDisplay = Array.from(finalBuildingsToShow.values()); zonesToDisplay = Array.from(finalZonesToShow.values());
        populateSelectionList(parcelsContainer, parcelsToDisplay, 'parcel', originallyCheckedSet);
        populateSelectionList(buildingsContainer, buildingsToDisplay, 'building', originallyCheckedSet);
        populateSelectionList(zonesContainer, zonesToDisplay, 'zone', originallyCheckedSet);
        document.querySelector('.tab-btn[data-tab="parcels"]').textContent = `Земельные участки (${parcelsToDisplay.length})`;
        document.querySelector('.tab-btn[data-tab="buildings"]').textContent = `ОКС (${buildingsToDisplay.length})`;
        document.querySelector('.tab-btn[data-tab="zones"]').textContent = `Зоны (${zonesToDisplay.length})`;
        updateToggleAllButtonState();
    }

    function populateParcelsList() {
        const parcelsContainer = document.getElementById('parcelsList');
        parcelsContainer.innerHTML = ''; // Clear previous list

        const searchIsActive = document.getElementById('searchInput').value.trim() !== '';
        const parcelsToDisplay = searchIsActive ? filteredParcels : allContours; // allContours can now contain XML or JSON sourced parcels
        const parcelCount = parcelsToDisplay.length;

        document.querySelector('.tab-btn[data-tab="parcels"]').textContent = `Земельные участки (${parcelCount})`;

        if (parcelCount === 0) {
            parcelsContainer.innerHTML = '<div class="empty-list">Земельные участки не найдены</div>';
            return;
        }

        const sortedParcels = [...parcelsToDisplay].sort((a, b) => {
            const numA = a && a.cadastralNumber ? a.cadastralNumber : '';
            const numB = b && b.cadastralNumber ? b.cadastralNumber : '';
            return numA.localeCompare(numB);
        });

        sortedParcels.forEach(parcel => {
            if (!parcel || !parcel.cadastralNumber) return; // Skip if no cadastral number (should not happen)

            const listItem = document.createElement('div');
            listItem.className = 'list-item';

            const isCurrentlySelected = parcel.cadastralNumber === selectedCadastralNumber;
            const isHighlightedCommon = highlightedIsolatedParcels.has(parcel.cadastralNumber);

            if (isCurrentlySelected || isHighlightedCommon) {
                listItem.classList.add('selected');
            }

            let parcelTypeDisplay = 'ЗУ'; // Default
            if (parcel.isParsedFromJson) {
                parcelTypeDisplay = 'ЗУ (JSON)';
            } else if (isUnifiedLandUse) { // XML EUL specific
                parcelTypeDisplay = 'Контур ЕЗ (XML)';
            } else { // XML KPT specific
                if (parcel.isIsolatedParcel) parcelTypeDisplay = 'Обособленный (XML)';
                else if (parcel.isDeclaredArea) parcelTypeDisplay = 'Декларированный (XML)';
                else parcelTypeDisplay = 'Уточненный (XML)';
            }


            listItem.innerHTML = `
                <div class="list-item-info">
                    <span class="list-item-number">${parcel.cadastralNumber}</span>
                    <span class="list-item-type">${parcelTypeDisplay}</span>
                </div>
                <div class="list-item-actions">
                    <button class="list-action-btn map" title="Кадастровый номер на карте">
                        <i class="fas fa-map"></i>
                    </button>
                    <button class="list-action-btn coords" title="Координаты на карте">
                        <i class="fas fa-draw-polygon"></i>
                    </button>
                    <button class="list-action-btn copy" title="Копировать кадастровый номер">
                        <i class="fas fa-copy"></i>
                    </button>
                    <button class="list-action-btn center" title="Центрировать на карте">
                        <i class="fas fa-crosshairs"></i>
                    </button>
                </div>
            `;

            listItem.addEventListener('click', async function(e) {
                if (e.target.closest('.list-action-btn')) return;

                await findAndSelectByCadastralNumber(parcel.cadastralNumber); // This handles displayParcelInfo & redraw

                // Update selection visual in list
                document.querySelectorAll('#parcelsList .list-item').forEach(itemElement => {
                    const itemNumberElement = itemElement.querySelector('.list-item-number');
                    if (itemNumberElement) {
                        const itemNumber = itemNumberElement.textContent;
                        const shouldBeSelected = (itemNumber === selectedCadastralNumber) || highlightedIsolatedParcels.has(itemNumber);
                        if (shouldBeSelected) itemElement.classList.add('selected');
                        else itemElement.classList.remove('selected');
                    }
                });
                document.querySelectorAll('#buildingsList .list-item, #zonesListContainer .list-item').forEach(itemElement => {
                    itemElement.classList.remove('selected');
                });
            });

            listItem.querySelector('.list-action-btn.map').addEventListener('click', function(e) {
                e.stopPropagation();
                copyToClipboard(parcel.cadastralNumber);
                window.open('map.html', '_blank');
            });

            listItem.querySelector('.list-action-btn.coords').addEventListener('click', function(e) {
                e.stopPropagation();
                const coordsText = getGenericCoordinatesText(parcel);
                if (coordsText) {
                    copyToClipboard(coordsText);
                    window.open('map.html', '_blank');
                } else {
                    showNotification("Не удалось получить координаты для этого участка.", "warning", "exclamation-triangle");
                }
            });

            listItem.querySelector('.list-action-btn.copy').addEventListener('click', function(e) {
                e.stopPropagation();
                copyToClipboard(parcel.cadastralNumber);
            });

            listItem.querySelector('.list-action-btn.center').addEventListener('click', function(e) {
                e.stopPropagation();
                centerOnSelectedParcel(parcel); // Assumes parcel structure has contours
                const adjacentParcels = getAdjacentParcelsForSelected(parcel.cadastralNumber);
                const adjacentParcelsForImported = getAdjacentParcelsForImported();
                redraw(adjacentParcels, adjacentParcelsForImported, true);
            });
            parcelsContainer.appendChild(listItem);
        });
    }
    
        function populateBuildingsList() {
        const buildingsContainer = document.getElementById('buildingsList');
        buildingsContainer.innerHTML = ''; // Clear previous list

        const searchIsActive = document.getElementById('searchInput').value.trim() !== '';
        const buildingsToDisplay = searchIsActive ? filteredBuildings : buildingsContours; // buildingsContours can now contain XML or JSON sourced OKS
        const buildingCount = buildingsToDisplay.length;

        document.querySelector('.tab-btn[data-tab="buildings"]').textContent = `ОКС (${buildingCount})`;

        if (buildingCount === 0) {
            buildingsContainer.innerHTML = '<div class="empty-list">Объекты капитального строительства не найдены</div>';
            return;
        }

        const sortedBuildings = [...buildingsToDisplay].sort((a, b) => {
            const numA = a && a.cadastralNumber ? a.cadastralNumber : '';
            const numB = b && b.cadastralNumber ? b.cadastralNumber : '';
            return numA.localeCompare(numB);
        });

        sortedBuildings.forEach(building => {
            if (!building || !building.cadastralNumber) return; // Skip if no cadastral number

            const listItem = document.createElement('div');
            listItem.className = 'list-item';
            if (building.cadastralNumber === selectedBuildingNumber) {
                listItem.classList.add('selected');
            }

            let buildingTypeLabel = 'ОКС'; // Default
            if (building.isParsedFromJson && building.record && building.record.type) {
                 buildingTypeLabel = building.record.type === 'building' ? 'Здание (JSON)' : 'Сооружение (JSON)';
            } else if (building.type) { // From XML, `building.type` was set during extraction
                 buildingTypeLabel = building.type === 'building' ? 'Здание (XML)' : 'Сооружение (XML)';
            }

            listItem.innerHTML = `
                <div class="list-item-info">
                    <span class="list-item-number">${building.cadastralNumber}</span>
                    <span class="list-item-type">${buildingTypeLabel}</span>
                </div>
                <div class="list-item-actions">
                    <button class="list-action-btn map" title="Кадастровый номер на карте">
                        <i class="fas fa-map"></i>
                    </button>
                    <button class="list-action-btn coords" title="Координаты на карте">
                        <i class="fas fa-draw-polygon"></i>
                    </button>
                    <button class="list-action-btn copy" title="Копировать кадастровый номер">
                        <i class="fas fa-copy"></i>
                    </button>
                    <button class="list-action-btn center" title="Центрировать на карте">
                        <i class="fas fa-crosshairs"></i>
                    </button>
                </div>
            `;

            listItem.addEventListener('click', async function(e) {
                if (e.target.closest('.list-action-btn')) return;

                const currentBuildingCadNum = building.cadastralNumber;

                if (!showBuildings) {
                    showBuildings = true;
                    const buildingsButton = document.getElementById('buildingsBtn');
                    if (buildingsButton) {
                        buildingsButton.classList.add('active');
                        buildingsButton.style.backgroundColor = '#3498db';
                    }
                }

                selectedCadastralNumber = null;
                selectedBuildingNumber = currentBuildingCadNum;
                selectedZoneOrTerritoryRegNumber = null;
                selectedImportedObjectIndex = -1;
                highlightedIsolatedParcels.clear();

                const buildingData = extractBuildingData(building); // Pass the whole item from buildingsContours
                displayBuildingInfo(buildingData);

                // Update selection visual in list
                document.querySelectorAll('#buildingsList .list-item').forEach(item => item.classList.remove('selected'));
                this.classList.add('selected');
                document.querySelectorAll('#parcelsList .list-item, #zonesListContainer .list-item').forEach(item => item.classList.remove('selected'));

                const adjacentParcels = getAdjacentParcelsForSelected(selectedCadastralNumber);
                const adjacentParcelsForImported = getAdjacentParcelsForImported();
                redraw(adjacentParcels, adjacentParcelsForImported, true);
            });

            listItem.querySelector('.list-action-btn.map').addEventListener('click', function(e) {
                e.stopPropagation();
                copyToClipboard(building.cadastralNumber);
                window.open('map.html', '_blank');
            });

            listItem.querySelector('.list-action-btn.coords').addEventListener('click', function(e) {
                e.stopPropagation();
                const coordsText = getGenericCoordinatesText(building);
                if (coordsText) {
                    copyToClipboard(coordsText);
                    window.open('map.html', '_blank');
                } else {
                    showNotification("Не удалось получить координаты для этого ОКС.", "warning", "exclamation-triangle");
                }
            });

            listItem.querySelector('.list-action-btn.copy').addEventListener('click', function(e) {
                e.stopPropagation();
                copyToClipboard(building.cadastralNumber);
            });

            listItem.querySelector('.list-action-btn.center').addEventListener('click', function(e) {
                e.stopPropagation();
                centerOnSelectedBuilding(building); // Assumes building structure has contours
                const adjacentParcels = getAdjacentParcelsForSelected(selectedCadastralNumber);
                const adjacentParcelsForImported = getAdjacentParcelsForImported();
                redraw(adjacentParcels, adjacentParcelsForImported, true);
            });
            buildingsContainer.appendChild(listItem);
        });
    }

    // New function to populate zones/territories list
     function populateZonesList() {
        const zonesContainer = document.getElementById('zonesListContainer'); zonesContainer.innerHTML = '';
        const zones = document.getElementById('searchInput').value.trim() ? filteredZones : zonesAndTerritoriesContours;
        if (zones.length === 0) { zonesContainer.innerHTML = '<div class="empty-list">Зоны и территории не найдены</div>'; document.querySelector('.tab-btn[data-tab="zones"]').textContent = `Зоны (0)`; return; }
        document.querySelector('.tab-btn[data-tab="zones"]').textContent = `Зоны (${zones.length})`;
        const sortedZones = [...zones].sort((a, b) => a.regNumbBorder.localeCompare(b.regNumbBorder));
          sortedZones.forEach(zone => {
            const listItem = document.createElement('div');
            listItem.className = 'list-item';
            if (zone.regNumbBorder === selectedZoneOrTerritoryRegNumber) {
                listItem.classList.add('selected');
            }

            let displayZoneTypeInList = zone.typeZoneValue || 'Зона/Территория';
             if (zone.zoneSubType === 'territorial_zone') displayZoneTypeInList = 'Терр. зона: ' + zone.typeZoneValue;
             else if (zone.zoneSubType === 'restricted_use_zone') displayZoneTypeInList = 'ЗОУИТ: ' + zone.typeZoneValue;
             else if (zone.zoneSubType === 'municipal_boundary') displayZoneTypeInList = 'МО: ' + zone.typeZoneValue;
             else if (zone.zoneSubType === 'inhabited_locality') displayZoneTypeInList = 'НП: ' + zone.typeZoneValue;


            listItem.innerHTML = `
                <div class="list-item-info">
                    <span class="list-item-number">${zone.regNumbBorder}</span>
                    <span class="list-item-type">${displayZoneTypeInList}</span>
                </div>
                <div class="list-item-actions">
                    <button class="list-action-btn map" title="Номер зоны на карте">
                        <i class="fas fa-map"></i>
                    </button>
                    <button class="list-action-btn coords" title="Координаты на карте">
                        <i class="fas fa-draw-polygon"></i>
                    </button>
                    <button class="list-action-btn copy" title="Копировать номер зоны">
                        <i class="fas fa-copy"></i>
                    </button>
                    <button class="list-action-btn center" title="Центрировать на карте">
                        <i class="fas fa-crosshairs"></i>
                    </button>
                </div>
            `;
            listItem.addEventListener('click', async function(e) {
                if (e.target.closest('.list-action-btn')) return;
                const currentZoneRegNum = zone.regNumbBorder;

                if (!showZones) {
                    showZones = true;
                    const zonesButton = document.getElementById('zonesBtn');
                    if (zonesButton) {
                        zonesButton.classList.add('active');
                        zonesButton.style.backgroundColor = '#d35400'; // Active color for zones
                    }
                }
                 // Ensure this specific zone is in visibleZoneRegNumbers
                if (!visibleZoneRegNumbers.has(currentZoneRegNum)) {
                    visibleZoneRegNumbers.add(currentZoneRegNum);
                }


                selectedCadastralNumber = null;
                selectedBuildingNumber = null;
                selectedZoneOrTerritoryRegNumber = currentZoneRegNum;
                selectedImportedObjectIndex = -1;
                highlightedIsolatedParcels.clear();

                const zoneData = extractZoneOrTerritoryData(zone.record);
                displayZoneOrTerritoryInfo(zoneData);

                document.querySelectorAll('#zonesListContainer .list-item').forEach(item => item.classList.remove('selected'));
                this.classList.add('selected');
                document.querySelectorAll('#parcelsList .list-item, #buildingsList .list-item').forEach(item => item.classList.remove('selected'));

                const adjacentParcels = getAdjacentParcelsForSelected(null); // No parcel selected
                const adjacentParcelsForImported = getAdjacentParcelsForImported();
                redraw(adjacentParcels, adjacentParcelsForImported, true);
            });

            listItem.querySelector('.list-action-btn.map').addEventListener('click', function(e) {
                e.stopPropagation();
                copyToClipboard(zone.regNumbBorder);
                window.open('map.html', '_blank');
            });
            listItem.querySelector('.list-action-btn.coords').addEventListener('click', function(e) {
                e.stopPropagation();
                const coordsText = getGenericCoordinatesText(zone); // Use generic function
                if (coordsText) {
                    copyToClipboard(coordsText);
                    window.open('map.html', '_blank');
                } else {
                     showNotification("Не удалось получить координаты для этой зоны.", "warning", "exclamation-triangle");
                }
            });
            listItem.querySelector('.list-action-btn.copy').addEventListener('click', function(e) {
                e.stopPropagation();
                copyToClipboard(zone.regNumbBorder);
            });
            listItem.querySelector('.list-action-btn.center').addEventListener('click', function(e) {
                e.stopPropagation();
                centerOnSelectedZoneOrTerritory(zone);
                const adjacentParcels = getAdjacentParcelsForSelected(null);
                const adjacentParcelsForImported = getAdjacentParcelsForImported();
                redraw(adjacentParcels, adjacentParcelsForImported, true);
            });
            zonesContainer.appendChild(listItem);
        });
    }


    function getParcelCoordinatesText(parcel) { let coordsText = ''; parcel.contours.forEach((contour, contourIndex) => { if (contourIndex > 0) coordsText += '\n'; contour.forEach(point => { coordsText += `${point.x}\t${point.y}\n`; }); }); return coordsText; }
    function getBuildingCoordinatesText(building) { let coordsText = ''; building.contours.forEach((contour, contourIndex) => { if (contourIndex > 0) coordsText += '\n'; contour.forEach(point => { coordsText += `${point.x}\t${point.y}\n`; }); }); return coordsText; }
    function getZoneOrTerritoryCoordinatesText(zone) { let coordsText = ''; zone.contours.forEach((contour, contourIndex) => { if (contourIndex > 0) coordsText += '\n'; contour.forEach(point => { coordsText += `${point.x}\t${point.y}\n`; }); }); return coordsText; }

    document.getElementById('openAllOnSchemeBtn').addEventListener('click', function() {
        const searchIsActive = document.getElementById('searchInput').value.trim() !== '';
        const activeTab = document.querySelector('.list-tabs .tab-btn.active');
        const activeTabType = activeTab ? activeTab.getAttribute('data-tab') : 'parcels';
        let itemsToProcess, itemTypeName = '';
        if (activeTabType === 'parcels') { itemsToProcess = searchIsActive ? filteredParcels : allContours; itemTypeName = searchIsActive ? 'отфильтрованных ЗУ' : 'всех ЗУ'; }
        else if (activeTabType === 'buildings') { itemsToProcess = searchIsActive ? filteredBuildings : buildingsContours; itemTypeName = searchIsActive ? 'отфильтрованных ОКС' : 'всех ОКС'; }
        else if (activeTabType === 'zones') { itemsToProcess = searchIsActive ? filteredZones : zonesAndTerritoriesContours; itemTypeName = searchIsActive ? 'отфильтрованных зон' : 'всех зон'; }
        else { showNotification('Ошибка: Не удалось определить активную вкладку.', 'error', 'exclamation-circle'); return; }
        if (itemsToProcess.length === 0) { showNotification(`Нет координат ${itemTypeName} для копирования в схему.`, 'warning', 'exclamation-triangle'); return; }
        const allCoordsText = generateCombinedCoordsText(itemsToProcess);
        if (allCoordsText) { copyToClipboard(allCoordsText); window.open('схема.html', '_blank'); showNotification(`Координаты ${itemTypeName} скопированы, открывается схема`, 'success', 'project-diagram'); }
        else showNotification(`Не удалось получить координаты ${itemTypeName}.`, 'error', 'exclamation-circle');
    });
    document.getElementById('saveListBtn').addEventListener('click', function() {
        const searchIsActive = document.getElementById('searchInput').value.trim() !== '';
        const activeTab = document.querySelector('.list-tabs .tab-btn.active');
        const activeTabType = activeTab ? activeTab.getAttribute('data-tab') : 'parcels';
        let itemsToProcess, fileSuffix = '', itemTypeName = '';
        if (activeTabType === 'parcels') { itemsToProcess = searchIsActive ? filteredParcels : allContours; fileSuffix = searchIsActive ? '_фильтр_зу' : '_зу'; itemTypeName = searchIsActive ? 'отфильтрованных ЗУ' : 'всех ЗУ'; }
        else if (activeTabType === 'buildings') { itemsToProcess = searchIsActive ? filteredBuildings : buildingsContours; fileSuffix = searchIsActive ? '_фильтр_окс' : '_окс'; itemTypeName = searchIsActive ? 'отфильтрованных ОКС' : 'всех ОКС'; }
        else if (activeTabType === 'zones') { itemsToProcess = searchIsActive ? filteredZones : zonesAndTerritoriesContours; fileSuffix = searchIsActive ? '_фильтр_зон' : '_зон'; itemTypeName = searchIsActive ? 'отфильтрованных зон' : 'всех зон'; }
        else { showNotification('Ошибка: Не удалось определить активную вкладку.', 'error', 'exclamation-circle'); return; }
        if (!itemsToProcess || itemsToProcess.length === 0) { showNotification(`Нет ${itemTypeName} для сохранения списка.`, 'warning', 'exclamation-triangle'); return; }
        let listCSV = ''; itemsToProcess.forEach(item => { const identifier = activeTabType === 'zones' ? item.regNumbBorder : item.cadastralNumber; if (identifier) listCSV += `${identifier}\n`; });
        saveAsFile(listCSV, `список_номеров${fileSuffix}.csv`); showNotification(`Список ${itemTypeName} сохранен`, 'success', 'check-circle');
    });
    document.getElementById('saveCoordsBtn').addEventListener('click', function() {
        const searchIsActive = document.getElementById('searchInput').value.trim() !== '';
        const activeTab = document.querySelector('.list-tabs .tab-btn.active');
        const activeTabType = activeTab ? activeTab.getAttribute('data-tab') : 'parcels';
        let itemsToProcess, fileSuffix = '', itemTypeName = '';
        if (activeTabType === 'parcels') { itemsToProcess = searchIsActive ? filteredParcels : allContours; fileSuffix = '_зу'; itemTypeName = searchIsActive ? 'отфильтрованных ЗУ' : 'всех ЗУ'; }
        else if (activeTabType === 'buildings') { itemsToProcess = searchIsActive ? filteredBuildings : buildingsContours; fileSuffix = '_окс'; itemTypeName = searchIsActive ? 'отфильтрованных ОКС' : 'всех ОКС'; }
        else if (activeTabType === 'zones') { itemsToProcess = searchIsActive ? filteredZones : zonesAndTerritoriesContours; fileSuffix = '_зон'; itemTypeName = searchIsActive ? 'отфильтрованных зон' : 'всех зон'; }
        else { showNotification('Ошибка: Не удалось определить активную вкладку.', 'error', 'exclamation-circle'); return; }
        if (itemsToProcess.length === 0) { showNotification(`Нет ${itemTypeName} для сохранения координат.`, 'warning', 'exclamation-triangle'); return; }
        const coordsCSV = generateCoordsCSV(itemsToProcess, activeTabType); // Pass itemType
        if (coordsCSV) { saveAsFile(coordsCSV, `координаты${fileSuffix}.csv`); showNotification(`Координаты ${itemTypeName} сохранены`, 'success', 'check-circle'); }
        else showNotification(`Не удалось сгенерировать CSV с координатами ${itemTypeName}.`, 'error', 'exclamation-circle');
    });
    document.getElementById('openAllOnMapBtn').addEventListener('click', function() {
        const searchIsActive = document.getElementById('searchInput').value.trim() !== '';
        const activeTab = document.querySelector('.list-tabs .tab-btn.active');
        const activeTabType = activeTab ? activeTab.getAttribute('data-tab') : 'parcels';
        let itemsToProcess, itemTypeName = '';
        if (activeTabType === 'parcels') { itemsToProcess = searchIsActive ? filteredParcels : allContours; itemTypeName = searchIsActive ? 'отфильтрованных ЗУ' : 'всех ЗУ'; }
        else if (activeTabType === 'buildings') { itemsToProcess = searchIsActive ? filteredBuildings : buildingsContours; itemTypeName = searchIsActive ? 'отфильтрованных ОКС' : 'всех ОКС'; }
        else if (activeTabType === 'zones') { itemsToProcess = searchIsActive ? filteredZones : zonesAndTerritoriesContours; itemTypeName = searchIsActive ? 'отфильтрованных зон' : 'всех зон'; }
        else { showNotification('Ошибка: Не удалось определить активную вкладку.', 'error', 'exclamation-circle'); return; }
        if (itemsToProcess.length === 0) { showNotification(`Нет координат ${itemTypeName} для копирования на карту.`, 'warning', 'exclamation-triangle'); return; }
        const allCoordsText = generateCombinedCoordsText(itemsToProcess);
        if (allCoordsText) { copyToClipboard(allCoordsText); window.open('map.html', '_blank'); showNotification(`Координаты ${itemTypeName} скопированы, открывается карта`, 'success', 'map-marked-alt'); }
        else showNotification(`Не удалось получить координаты ${itemTypeName}.`, 'error', 'exclamation-circle');
    });
    function saveAsFile(content, filename) { const blob = new Blob([content], { type: 'text/csv;charset=utf-8;' }); const link = document.createElement('a'); const url = URL.createObjectURL(blob); link.setAttribute('href', url); link.setAttribute('download', filename); link.style.visibility = 'hidden'; document.body.appendChild(link); link.click(); document.body.removeChild(link); }

    const uploadKptBtn = document.getElementById('uploadKptBtn');
if (uploadKptBtn) {
    uploadKptBtn.addEventListener('click', function() {
        const zipFileInput = document.createElement('input');
        zipFileInput.type = 'file';
        zipFileInput.accept = '.zip';
        zipFileInput.style.display = 'none';
        
        zipFileInput.onchange = async (event) => {
            const file = event.target.files[0];
            if (!file) {
                if (document.body.contains(zipFileInput)) document.body.removeChild(zipFileInput);
                return;
            }
            
            const loaderContainer = document.getElementById('loaderContainer');
            const fileName = file.name;
            const validNameRegex = /^\d{2}_\d{2}_\d{6,7} \d{4}-\d{2}-\d{2}\.zip$/i;
            if (!validNameRegex.test(fileName)) {
                alert(`Неверный формат имени файла: "${fileName}"\nОжидается формат "XX_XX_XXXXXX ГГГГ-ММ-ДД.zip" или "XX_XX_XXXXXXX ГГГГ-ММ-ДД.zip`);
                if (document.body.contains(zipFileInput)) document.body.removeChild(zipFileInput);
                return;
            }
            
            const MAX_FILE_SIZE_MB = 10;
            const MAX_FILE_SIZE_BYTES = MAX_FILE_SIZE_MB * 1024 * 1024;
            if (file.size > MAX_FILE_SIZE_BYTES) {
                alert(`Ошибка: Размер файла (${formatFileSize(file.size)}) превышает лимит в ${MAX_FILE_SIZE_MB} MB.`);
                if (document.body.contains(zipFileInput)) document.body.removeChild(zipFileInput);
                return;
            }
            
            loaderContainer.style.display = 'flex';
            updateLoaderProgress(0, file.size, `Проверка архива ${fileName}...`);
            
            try {
                const zip = await JSZip.loadAsync(await file.arrayBuffer());
                let xmlCount = 0, sigCount = 0, otherFileCount = 0, directoryCount = 0;
                let xmlFileName = null;
                
                for (const fileNameInZip in zip.files) {
                    const fileEntry = zip.files[fileNameInZip];
                    if (fileEntry.dir) {
                        directoryCount++;
                        break;
                    }
                    const lowerFileName = fileNameInZip.toLowerCase();
                    if (lowerFileName.startsWith('__macosx/') || lowerFileName.endsWith('/.ds_store')) continue;
                    if (lowerFileName.endsWith('.xml')) {
                        xmlCount++;
                        xmlFileName = fileNameInZip;
                    } else if (lowerFileName.endsWith('.sig')) {
                        sigCount++;
                    } else {
                        otherFileCount++;
                    }
                }
                
                let errorMessage = null;
                if (directoryCount > 0) errorMessage = `Ошибка: Архив не должен содержать папок.`;
                else if (xmlCount !== 1) errorMessage = `Ошибка: Архив должен содержать ровно один XML файл (найдено ${xmlCount}).`;
                else if (sigCount > 1) errorMessage = `Ошибка: Архив может содержать не более одного SIG файла (найдено ${sigCount}).`;
                else if (otherFileCount > 0) {
                    let isSigMatchedToXml = false;
                    if (xmlFileName && sigCount === 0 && otherFileCount === 1) {
                        const xmlBaseName = xmlFileName.substring(0, xmlFileName.lastIndexOf('.'));
                        for (const fn in zip.files) {
                            if (!zip.files[fn].dir && !fn.toLowerCase().endsWith('.xml') && !fn.toLowerCase().startsWith('__macosx/') && !fn.toLowerCase().endsWith('/.ds_store')) {
                                const otherBaseName = fn.substring(0, fn.lastIndexOf('.'));
                                if (xmlBaseName.toLowerCase() === otherBaseName.toLowerCase()) {
                                    isSigMatchedToXml = true;
                                    otherFileCount = 0;
                                    sigCount = 1;
                                    break;
                                }
                            }
                        }
                    }
                    if (!isSigMatchedToXml && otherFileCount > 0) errorMessage = `Ошибка: Архив содержит ${otherFileCount} недопустимых файлов (разрешены только .xml и .sig).`;
                }
                
                if (errorMessage) {
                    loaderContainer.style.display = 'none';
                    alert(errorMessage);
                } else {
                    updateLoaderProgress(file.size, file.size, `Проверка завершена. Загрузка...`);
                    await new Promise(resolve => setTimeout(resolve, 500));
                    loaderContainer.style.display = 'none';
                    await uploadKptToLocalServer(file);
                }
            } catch (error) {
                loaderContainer.style.display = 'none';
                alert(`Ошибка при проверке архива: ${error.message}`);
            } finally {
                if (document.body.contains(zipFileInput)) document.body.removeChild(zipFileInput);
            }
        };
        document.body.appendChild(zipFileInput);
        zipFileInput.click();
    });
}

async function uploadKptToLocalServer(file) {
    const loaderContainer = document.getElementById('loaderContainer');
    const originalButton = document.getElementById('uploadKptBtn');

    if (originalButton) originalButton.disabled = true;
    loaderContainer.style.display = 'flex';
    updateLoaderProgress(0, file.size, `Загрузка ${file.name} на сервер...`);

    const formData = new FormData();
    formData.append('file', file, file.name);

    try {
        const response = await fetch(`${STORAGE_API_URL}/${BUCKET_NAME}/upload`, {
            method: 'POST',
            body: formData,
        });
        
        const responseData = await response.json();

        if (!response.ok) {
            throw new Error(responseData.error || `Ошибка сервера: ${response.statusText}`);
        }
        
        showNotification(`Файл "${file.name}" успешно загружен!`, 'success', 'check-circle');

    } catch (err) {
        showNotification(`Ошибка загрузки: ${err.message || err}`, 'error', 'exclamation-circle');
    } finally {
        loaderContainer.style.display = 'none';
        if (originalButton) originalButton.disabled = false;
    }
}


function repositionNotifications() {
    activeNotifications.forEach((notification, index) => {
        notification.style.top = `${20 + index * (NOTIFICATION_HEIGHT + NOTIFICATION_MARGIN_TOP)}px`;
    });
}

function showNotification(message, type = 'info', icon = 'info') {
    const notification = document.createElement('div');
    notification.className = `notification ${type}`;
    notification.innerHTML = `<i class="fas fa-${icon}"></i> ${message}`;
    document.body.appendChild(notification);

    // Calculate initial position
    const topPosition = 20 + activeNotifications.length * (NOTIFICATION_HEIGHT + NOTIFICATION_MARGIN_TOP);
    notification.style.top = `${topPosition}px`;
    notification.style.right = `20px`; // Keep it on the right

    activeNotifications.push(notification);

    // Trigger the show animation
    setTimeout(() => {
        notification.classList.add('show');
    }, 100); // Short delay to allow CSS transition

    // Set timeout to hide and remove the notification
    const notificationId = Symbol(); // Unique ID for this notification instance
    notification.dataset.notificationId = notificationId.toString();


    setTimeout(() => {
        notification.classList.remove('show');
        // Wait for hide animation to complete before removing from DOM and array
        setTimeout(() => {
            // Remove the specific notification from the array
            activeNotifications = activeNotifications.filter(n => n.dataset.notificationId !== notification.dataset.notificationId);
            if (document.body.contains(notification)) { // Check if it's still in DOM
                notification.remove();
            }
            repositionNotifications(); // Reposition remaining notifications
        }, 500); // This duration should match your CSS transition for hiding
    }, 4000); // Increased display duration to 4 seconds (was 3 seconds)
}

    const openAndSelectBtn = document.getElementById('openAndSelectBtn');
    if (openAndSelectBtn) { openAndSelectBtn.addEventListener('click', function() { isSelectiveLoadMode = true; document.getElementById('fileInput').click(); }); }

   document.getElementById('closeZoneSelectionDialogBtn').addEventListener('click', closeZoneSelectionDialog);
    document.getElementById('zoneSelectionDialogOverlay').addEventListener('click', closeZoneSelectionDialog);
    document.getElementById('zoneSelectionDialog').addEventListener('click', e => e.stopPropagation());


    document.getElementById('zoneSearchInput').addEventListener('input', function() {
        populateZoneSelectionList(this.value);
        document.getElementById('clearZoneSearchBtn').style.display = this.value ? 'block' : 'none';
    });
    document.getElementById('clearZoneSearchBtn').addEventListener('click', function() {
        document.getElementById('zoneSearchInput').value = '';
        populateZoneSelectionList('');
        this.style.display = 'none';
    });

    document.getElementById('zoneSelectAllBtn').addEventListener('click', function() {
        const checkboxes = document.querySelectorAll('#zoneSelectionListContainer input[type="checkbox"]');
        checkboxes.forEach(cb => {
            cb.checked = true;
            visibleZoneRegNumbers.add(cb.dataset.regnumb);
        });
    });

    document.getElementById('zoneDeselectAllBtn').addEventListener('click', function() {
        const checkboxes = document.querySelectorAll('#zoneSelectionListContainer input[type="checkbox"]');
        checkboxes.forEach(cb => {
            cb.checked = false;
            visibleZoneRegNumbers.delete(cb.dataset.regnumb);
        });
    });

    document.getElementById('zoneApplySelectionBtn').addEventListener('click', function() {
        showZones = visibleZoneRegNumbers.size > 0; // Set showZones based on whether any zones are selected
        updateZonesButtonVisualState();
        const adjacentParcels = getAdjacentParcelsForSelected(selectedCadastralNumber);
        const adjacentParcelsForImported = getAdjacentParcelsForImported();
        redraw(adjacentParcels, adjacentParcelsForImported, true);
        closeZoneSelectionDialog();
        if (showZones) {
            showNotification(`Отображение ${visibleZoneRegNumbers.size} зон применено.`, 'success', 'check-circle');
        } else {
            showNotification('Все зоны скрыты.', 'info', 'eye-slash');
        }
    });

    document.getElementById('zoneCancelSelectionBtn').addEventListener('click', function() {
        // Revert visibleZoneRegNumbers to state before dialog was opened (if complex state management is needed)
        // For now, just close. The actual `visibleZoneRegNumbers` would have been updated by checkboxes.
        // To truly cancel, you'd need to store its state on dialog open.
        // Let's assume the user wants to keep current checkbox changes even on cancel for simplicity now.
        // Or, restore from initial state if `initialZoneSelectionApplied` was just set.
        closeZoneSelectionDialog();
    });




function isValidClipboardCadastralOrQuarter(text) {
    if (!text) return false;
    const trimmedText = text.trim();

    // Check for full parcel number (isValidCadastralNumber already handles 6 or 7 digit quarters)
    if (isValidCadastralNumber(trimmedText)) {
        return true;
    }

    // Check for quarter/block format (6 or 7 digits in the third segment, optional trailing colon)
    // Example: 16:56:010120 or 63:35:0101208 or 16:56:010120:
    const quarterBlockRegex = /^\d{2}:\d{2}:(\d{6}|\d{7}):?$/;
    if (quarterBlockRegex.test(trimmedText)) {
        return true;
    }
    return false;
}



    document.addEventListener('DOMContentLoaded', async () => {
    const canvasEl = document.getElementById('kptSchemeCanvas');
    if (canvasEl) {
        canvasEl.width = canvasEl.offsetWidth;
        canvasEl.height = canvasEl.offsetHeight;
    } else {
        console.error("Canvas element #kptSchemeCanvas not found on DOMContentLoaded!");
        showPersistentMessageDialog("Критическая ошибка", "Холст для схемы не найден. Пожалуйста, перезагрузите страницу или обратитесь к администратору.", "error");
        return;
    }
    updateZonesButtonVisualState();
    initCadastralInput();

    try {
        const clipboardText = await navigator.clipboard.readText();
        const parsedSpecialFormat = parseSpecialClipboardFormat(clipboardText);

        if (parsedSpecialFormat) {
            const { quarter, coordinatesText, cadastralToSelect } = parsedSpecialFormat;
            showNotification(`Обнаружены данные в буфере для квартала ${quarter}. Загрузка КПТ...`, 'info', 'paste');

            const kptAndCoordsProcessed = await loadKptForQuarterAndProcess(quarter, coordinatesText, cadastralToSelect);

            if (!kptAndCoordsProcessed) {
                // KPT loading failed or KPT not found.
                // The loadKptForQuarterAndProcess function shows a persistent dialog for "KPT not found".
                // If it returned false for other reasons (e.g. download error after finding it), a persistent dialog was also shown.
                // So, we just add coordinates here if it failed.
                // The showNotification below is now redundant as the persistent dialog covers the "KPT not found" case.
                // showNotification(`КПТ для квартала ${quarter} не загружен или при загрузке произошла ошибка. Координаты из буфера будут добавлены на текущую схему.`, 'warning', 'folder-open');
                processImportedCoordinates(coordinatesText);
            }
        } else {
            const trimmedClipboardText = clipboardText.trim();
            if (isValidClipboardCadastralOrQuarter(trimmedClipboardText)) {
                const cadastralInput = document.getElementById('cadastralInput');
                if (cadastralInput) {
                    cadastralInput.value = trimmedClipboardText;
                    formatCadastralNumber(cadastralInput);
                    const enterEvent = new KeyboardEvent('keydown', {
                        key: 'Enter',
                        bubbles: true,
                        cancelable: true
                    });
                    cadastralInput.dispatchEvent(enterEvent);
                    showNotification(`Объект/квартал ${trimmedClipboardText} из буфера обмена обработан.`, 'info', 'paste');
                }
            }
        }
    } catch (err) {
        if (err.name !== 'NotFoundError' && err.name !== 'NotAllowedError' &&
            !err.message.toLowerCase().includes('permission denied') &&
            !err.message.toLowerCase().includes('clipboard is empty') &&
            !err.message.toLowerCase().includes('document is not focused')) {
            console.warn('Не удалось прочитать буфер обмена при загрузке страницы:', err);
        }
    }

    const gridInfoPanel = document.getElementById('gridInfoPanel');
    let gridInfoPanelIcon = null;
    if (gridInfoPanel) {
        gridInfoPanelIcon = gridInfoPanel.querySelector('i');
        gridInfoPanel.style.cursor = 'pointer';
        gridInfoPanel.setAttribute('title', 'Показать/скрыть сетку');
        gridInfoPanel.addEventListener('click', function() {
            isGridVisible = !isGridVisible;
            if (isGridVisible) {
                gridInfoPanel.style.opacity = '0.8';
                if (gridInfoPanelIcon) gridInfoPanelIcon.className = 'fas fa-th';
            } else {
                gridInfoPanel.style.opacity = '0.5';
                if (gridInfoPanelIcon) gridInfoPanelIcon.className = 'fas fa-eye-slash';
            }
            const adjacentParcels = getAdjacentParcelsForSelected(selectedCadastralNumber);
            const adjacentParcelsForImported = getAdjacentParcelsForImported();
            redraw(adjacentParcels, adjacentParcelsForImported, true, showPoints, showPoints);
        });
    }
});


   
</script>



</body>
</html>