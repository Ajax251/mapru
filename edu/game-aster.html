<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NEBULA RUNNER - Space Flight Simulator</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            overflow: hidden;
            background: #000;
            font-family: 'Courier New', monospace;
            cursor: none;
        }

        #canvas-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        /* –û–±—â–∏–µ —Å—Ç–∏–ª–∏ –¥–ª—è —ç–∫—Ä–∞–Ω–æ–≤ */
        .screen-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            cursor: default; /* –ö—É—Ä—Å–æ—Ä –≤–∏–¥–µ–Ω –Ω–∞ —ç–∫—Ä–∞–Ω–∞—Ö */
        }

        #start-screen {
            background: radial-gradient(ellipse at center, #0a0a1a 0%, #000 100%);
            cursor: pointer;
        }

        #start-screen h1 {
            font-size: 4rem;
            color: #0ff;
            text-shadow: 0 0 20px #0ff, 0 0 40px #0ff, 0 0 60px #08f;
            letter-spacing: 0.5rem;
            margin-bottom: 2rem;
            animation: pulse 2s infinite;
        }

        #start-screen p {
            font-size: 1.2rem;
            color: #888;
            animation: blink 1.5s infinite;
        }

        #start-screen .controls-info {
            margin-top: 2rem;
            color: #0aa;
            font-size: 0.9rem;
            text-align: center;
            line-height: 2;
        }

        .key {
            display: inline-block;
            background: rgba(0, 255, 255, 0.2);
            border: 1px solid #0ff;
            padding: 2px 8px;
            border-radius: 3px;
            margin: 0 3px;
        }

        /* –≠–∫—Ä–∞–Ω –ø–∞—É–∑—ã */
        #pause-screen {
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(5px);
            display: none;
            z-index: 2000;
        }

        #pause-screen h2 {
            font-size: 3rem;
            color: #ffaa00;
            text-shadow: 0 0 20px #ffaa00;
            letter-spacing: 0.5rem;
            margin-bottom: 1rem;
        }

        #pause-screen p {
            color: #fff;
            font-size: 1.2rem;
            animation: blink 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.8; transform: scale(1.02); }
        }

        @keyframes blink {
            0%, 50%, 100% { opacity: 1; }
            25%, 75% { opacity: 0.3; }
        }

        #hud {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 100;
            display: none;
        }

        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 6px;
            height: 6px;
            background: rgba(0, 255, 255, 0.9);
            border-radius: 50%;
            box-shadow: 0 0 8px #0ff, 0 0 16px #0ff;
        }

        #stats-left {
            position: absolute;
            top: 20px;
            left: 20px;
            padding: 20px;
            background: linear-gradient(135deg, rgba(0, 20, 40, 0.85) 0%, rgba(0, 10, 20, 0.7) 100%);
            border: 1px solid rgba(0, 255, 255, 0.4);
            border-radius: 5px;
            min-width: 220px;
        }

        #stats-left::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 2px;
            background: linear-gradient(90deg, transparent, #0ff, transparent);
        }

        .stat-label {
            font-size: 0.7rem;
            color: #0aa;
            letter-spacing: 2px;
            margin-bottom: 5px;
        }

        .stat-value {
            font-size: 1.6rem;
            color: #0ff;
            text-shadow: 0 0 10px #0ff;
            margin-bottom: 12px;
        }

        .bar-container {
            width: 100%;
            height: 10px;
            background: rgba(0, 0, 0, 0.6);
            border: 1px solid rgba(0, 255, 255, 0.4);
            border-radius: 5px;
            overflow: hidden;
            margin-bottom: 5px;
        }

        .bar-fill {
            height: 100%;
            transition: width 0.2s ease;
        }

        #health-bar {
            background: linear-gradient(90deg, #f00, #ff0, #0f0);
            width: 100%;
        }

        #shield-bar {
            background: linear-gradient(90deg, #08f, #0ff);
            width: 100%;
        }

        #stats-right {
            position: absolute;
            top: 20px;
            right: 20px;
            padding: 20px;
            background: linear-gradient(135deg, rgba(0, 20, 40, 0.85) 0%, rgba(0, 10, 20, 0.7) 100%);
            border: 1px solid rgba(0, 255, 255, 0.4);
            border-radius: 5px;
            text-align: right;
            min-width: 200px;
        }

        #stats-right::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 2px;
            background: linear-gradient(90deg, transparent, #0ff, transparent);
        }

        #speed-gauge {
            position: relative;
            width: 160px;
            height: 80px;
            margin: 10px auto 0;
            overflow: hidden;
        }

        #speed-arc {
            position: absolute;
            width: 160px;
            height: 160px;
            border: 4px solid transparent;
            border-top-color: #0ff;
            border-radius: 50%;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.5);
        }

        #speed-needle {
            position: absolute;
            bottom: 0;
            left: 50%;
            width: 3px;
            height: 65px;
            background: linear-gradient(to top, #f00, #ff0);
            transform-origin: bottom center;
            transform: rotate(-90deg);
            transition: transform 0.15s ease;
            box-shadow: 0 0 10px #f00;
        }

        .control-hint {
            font-size: 0.6rem;
            color: #088;
            margin-top: 8px;
            line-height: 1.5;
        }

        #warning {
            position: absolute;
            bottom: 120px;
            left: 50%;
            transform: translateX(-50%);
            padding: 12px 35px;
            background: rgba(255, 0, 0, 0.25);
            border: 2px solid #f00;
            color: #f00;
            font-size: 1.3rem;
            letter-spacing: 3px;
            display: none;
            animation: warningFlash 0.4s infinite;
        }

        @keyframes warningFlash {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.4; }
        }

        #damage-vignette {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.1s ease;
            z-index: 99;
        }

        #bottom-info {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 50px;
            padding: 15px 35px;
            background: linear-gradient(135deg, rgba(0, 20, 40, 0.85) 0%, rgba(0, 10, 20, 0.7) 100%);
            border: 1px solid rgba(0, 255, 255, 0.4);
            border-radius: 5px;
        }

        .bottom-stat {
            text-align: center;
        }

        .bottom-stat .stat-label {
            font-size: 0.6rem;
        }

        .bottom-stat .stat-value {
            font-size: 1.3rem;
            margin-bottom: 0;
        }

        #game-over {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.92);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1001;
            cursor: pointer;
        }

        #game-over h1 {
            font-size: 4rem;
            color: #f00;
            text-shadow: 0 0 30px #f00, 0 0 60px #f00;
            margin-bottom: 2rem;
        }

        #game-over .final-score {
            font-size: 2.2rem;
            color: #0ff;
            margin-bottom: 1rem;
        }

        #game-over p {
            font-size: 1.1rem;
            color: #888;
        }

        #scanlines {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            background: repeating-linear-gradient(
                0deg,
                rgba(0, 0, 0, 0.08) 0px,
                rgba(0, 0, 0, 0.08) 1px,
                transparent 1px,
                transparent 3px
            );
            z-index: 101;
            opacity: 0.4;
        }
    </style>
</head>
<body>
    <div id="canvas-container"></div>
    
    <div id="start-screen" class="screen-overlay">
        <h1>NEBULA RUNNER</h1>
        <p>[ CLICK TO ENGAGE ]</p>
        <div class="controls-info">
            <div><span class="key">W</span> / <span class="key">A</span> / <span class="key">S</span> / <span class="key">D</span> ‚Äî –î–≤–∏–∂–µ–Ω–∏–µ –∫–æ—Ä–∞–±–ª—è</div>
            <div><span class="key">‚Üë</span> / <span class="key">‚Üì</span> ‚Äî –¢—è–≥–∞ (—Å–∫–æ—Ä–æ—Å—Ç—å)</div>
            <div><span class="key">SHIFT</span> ‚Äî –£—Å–∫–æ—Ä–µ–Ω–∏–µ (–±—É—Å—Ç)</div>
            <div><span class="key">ESC</span> ‚Äî –ü–∞—É–∑–∞</div>
            <div><span class="key">üñ±Ô∏è –ú—ã—à—å</span> ‚Äî –û–±–∑–æ—Ä –∫–∞–º–µ—Ä—ã</div>
        </div>
    </div>

    <div id="pause-screen" class="screen-overlay">
        <h2>PAUSED</h2>
        <p>[ CLICK TO RESUME ]</p>
        <div class="controls-info">
            <div>–ù–∞–∂–º–∏—Ç–µ <span class="key">ESC</span> –¥–ª—è –ø—Ä–æ–¥–æ–ª–∂–µ–Ω–∏—è</div>
        </div>
    </div>

    <div id="hud">
        <div id="crosshair"></div>

        <div id="stats-left">
            <div class="stat-label">HULL INTEGRITY</div>
            <div class="bar-container">
                <div class="bar-fill" id="health-bar"></div>
            </div>
            <div class="stat-value" id="health-value">100%</div>
            
            <div class="stat-label">SHIELD CHARGE</div>
            <div class="bar-container">
                <div class="bar-fill" id="shield-bar"></div>
            </div>
            <div class="stat-value" id="shield-value">100%</div>
        </div>

        <div id="stats-right">
            <div class="stat-label">VELOCITY (KM/S)</div>
            <div class="stat-value" id="speed-value">0</div>
            <div id="speed-gauge">
                <div id="speed-arc"></div>
                <div id="speed-needle"></div>
            </div>
            <div class="control-hint">‚Üë/‚Üì —Ç—è–≥–∞ | SHIFT –±—É—Å—Ç</div>
        </div>

        <div id="bottom-info">
            <div class="bottom-stat">
                <div class="stat-label">DISTANCE</div>
                <div class="stat-value" id="distance-value">0 KM</div>
            </div>
            <div class="bottom-stat">
                <div class="stat-label">TIME</div>
                <div class="stat-value" id="time-value">00:00</div>
            </div>
            <div class="bottom-stat">
                <div class="stat-label">SCORE</div>
                <div class="stat-value" id="score-value">0</div>
            </div>
        </div>

        <div id="warning">‚ö† COLLISION WARNING ‚ö†</div>
    </div>

    <div id="damage-vignette"></div>
    <div id="scanlines"></div>

    <div id="game-over" class="screen-overlay">
        <h1>SHIP DESTROYED</h1>
        <div class="final-score">FINAL SCORE: <span id="final-score">0</span></div>
        <p>[ CLICK TO RESTART ]</p>
    </div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        // ========================================
        // GAME STATE
        // ========================================
        const GameState = {
            health: 100,
            shield: 100,
            speed: 120,
            targetSpeed: 120,
            maxSpeed: 800,
            minSpeed: 30,
            distance: 0,
            score: 0,
            startTime: 0,
            pauseStartTime: 0, // –ß—Ç–æ–±—ã –ø—Ä–∞–≤–∏–ª—å–Ω–æ —Å—á–∏—Ç–∞—Ç—å –≤—Ä–µ–º—è –ø–æ—Å–ª–µ –ø–∞—É–∑—ã
            totalPausedTime: 0,
            isPlaying: false,
            isPaused: false,
            isGameOver: false,
            isBoosting: false
        };

        // Ship position (actual physical position in space)
        const ShipState = {
            x: 0,
            y: 0,
            targetX: 0,
            targetY: 0,
            maxOffset: 150,  // Max distance from center
            moveSpeed: 250   // Movement speed
        };

        // Input state
        const InputState = {
            moveUp: false,      // W
            moveDown: false,    // S
            moveLeft: false,    // A
            moveRight: false,   // D
            thrustUp: false,    // Arrow Up
            thrustDown: false,  // Arrow Down
            boost: false        // Shift
        };

        // ========================================
        // THREE.JS SETUP
        // ========================================
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000015, 0.00025);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 10000);
        camera.position.set(0, 0, 0);

        const renderer = new THREE.WebGLRenderer({ 
            antialias: true,
            powerPreference: "high-performance"
        });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.4;
        container.appendChild(renderer.domElement);

        // Ship group (camera follows this)
        const shipGroup = new THREE.Group();
        scene.add(shipGroup);
        shipGroup.add(camera);

        // ========================================
        // POST-PROCESSING
        // ========================================
        const composer = new EffectComposer(renderer);
        const renderPass = new RenderPass(scene, camera);
        composer.addPass(renderPass);

        const bloomPass = new UnrealBloomPass(
            new THREE.Vector2(window.innerWidth, window.innerHeight),
            0.7, 0.4, 0.85
        );
        composer.addPass(bloomPass);

        // ========================================
        // LIGHTING
        // ========================================
        const sunLight = new THREE.DirectionalLight(0xffffff, 2.5);
        sunLight.position.set(100, 80, 100);
        scene.add(sunLight);

        const fillLight = new THREE.DirectionalLight(0x4488ff, 0.8);
        fillLight.position.set(-60, -30, -60);
        scene.add(fillLight);

        const backLight = new THREE.DirectionalLight(0xff6644, 0.4);
        backLight.position.set(0, 20, -100);
        scene.add(backLight);

        const ambientLight = new THREE.AmbientLight(0x223344, 0.6);
        scene.add(ambientLight);

        // ========================================
        // STARFIELD
        // ========================================
        function createStarfield() {
            const starCount = 18000;
            const positions = new Float32Array(starCount * 3);
            const colors = new Float32Array(starCount * 3);
            const sizes = new Float32Array(starCount);

            for (let i = 0; i < starCount; i++) {
                const radius = 1200 + Math.random() * 4500;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);

                positions[i * 3] = radius * Math.sin(phi) * Math.cos(theta);
                positions[i * 3 + 1] = radius * Math.sin(phi) * Math.sin(theta);
                positions[i * 3 + 2] = radius * Math.cos(phi);

                const temp = Math.random();
                if (temp < 0.55) {
                    colors[i * 3] = 1; colors[i * 3 + 1] = 1; colors[i * 3 + 2] = 1;
                } else if (temp < 0.75) {
                    colors[i * 3] = 0.7; colors[i * 3 + 1] = 0.85; colors[i * 3 + 2] = 1;
                } else if (temp < 0.9) {
                    colors[i * 3] = 1; colors[i * 3 + 1] = 0.9; colors[i * 3 + 2] = 0.7;
                } else {
                    colors[i * 3] = 1; colors[i * 3 + 1] = 0.5; colors[i * 3 + 2] = 0.3;
                }

                sizes[i] = Math.random() < 0.93 ? 1 + Math.random() * 2.5 : 4 + Math.random() * 6;
            }

            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));

            const material = new THREE.ShaderMaterial({
                uniforms: { time: { value: 0 } },
                vertexShader: `
                    attribute float size;
                    attribute vec3 color;
                    varying vec3 vColor;
                    uniform float time;
                    void main() {
                        vColor = color;
                        vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                        float twinkle = sin(time * 2.5 + position.x * 0.015 + position.y * 0.015) * 0.35 + 0.65;
                        gl_PointSize = size * twinkle * (180.0 / -mvPosition.z);
                        gl_Position = projectionMatrix * mvPosition;
                    }
                `,
                fragmentShader: `
                    varying vec3 vColor;
                    void main() {
                        vec2 center = gl_PointCoord - vec2(0.5);
                        float dist = length(center);
                        float alpha = 1.0 - smoothstep(0.0, 0.5, dist);
                        float glow = exp(-dist * 4.5) * 0.5;
                        gl_FragColor = vec4(vColor * (alpha + glow), alpha + glow * 0.4);
                    }
                `,
                transparent: true,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });

            const stars = new THREE.Points(geometry, material);
            scene.add(stars);
            return { mesh: stars, material };
        }

        const starfield = createStarfield();

        // ========================================
        // NEBULA
        // ========================================
        function createNebula() {
            const count = 70;
            const positions = new Float32Array(count * 3);
            const colors = new Float32Array(count * 3);
            const sizes = new Float32Array(count);

            for (let i = 0; i < count; i++) {
                positions[i * 3] = (Math.random() - 0.5) * 5500;
                positions[i * 3 + 1] = (Math.random() - 0.5) * 3500;
                positions[i * 3 + 2] = -1200 - Math.random() * 4500;

                const c = Math.random();
                if (c < 0.35) {
                    colors[i * 3] = 0.85; colors[i * 3 + 1] = 0.25; colors[i * 3 + 2] = 0.65;
                } else if (c < 0.7) {
                    colors[i * 3] = 0.25; colors[i * 3 + 1] = 0.45; colors[i * 3 + 2] = 0.95;
                } else {
                    colors[i * 3] = 0.2; colors[i * 3 + 1] = 0.85; colors[i * 3 + 2] = 0.75;
                }
                sizes[i] = 350 + Math.random() * 700;
            }

            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));

            const material = new THREE.ShaderMaterial({
                uniforms: { time: { value: 0 } },
                vertexShader: `
                    attribute float size;
                    attribute vec3 color;
                    varying vec3 vColor;
                    void main() {
                        vColor = color;
                        vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                        gl_PointSize = size * (700.0 / -mvPosition.z);
                        gl_Position = projectionMatrix * mvPosition;
                    }
                `,
                fragmentShader: `
                    varying vec3 vColor;
                    void main() {
                        vec2 center = gl_PointCoord - vec2(0.5);
                        float dist = length(center);
                        float alpha = exp(-dist * dist * 9.0) * 0.1;
                        gl_FragColor = vec4(vColor, alpha);
                    }
                `,
                transparent: true,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });

            const nebula = new THREE.Points(geometry, material);
            scene.add(nebula);
            return { mesh: nebula, material };
        }

        const nebula = createNebula();

        // ========================================
        // SPACE DUST
        // ========================================
        function createSpaceDust() {
            const count = 2500;
            const positions = new Float32Array(count * 3);

            for (let i = 0; i < count; i++) {
                positions[i * 3] = (Math.random() - 0.5) * 350;
                positions[i * 3 + 1] = (Math.random() - 0.5) * 350;
                positions[i * 3 + 2] = Math.random() * -700;
            }

            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

            const material = new THREE.ShaderMaterial({
                uniforms: { speed: { value: 1.0 } },
                vertexShader: `
                    uniform float speed;
                    varying float vAlpha;
                    void main() {
                        vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                        float stretch = 1.0 + speed * 0.012;
                        gl_PointSize = 2.0 * stretch * (70.0 / -mvPosition.z);
                        gl_Position = projectionMatrix * mvPosition;
                        vAlpha = smoothstep(700.0, 25.0, -mvPosition.z);
                    }
                `,
                fragmentShader: `
                    varying float vAlpha;
                    void main() {
                        vec2 center = gl_PointCoord - vec2(0.5);
                        float dist = length(center);
                        float alpha = (1.0 - dist * 2.0) * vAlpha * 0.65;
                        gl_FragColor = vec4(0.75, 0.88, 1.0, alpha);
                    }
                `,
                transparent: true,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });

            const dust = new THREE.Points(geometry, material);
            shipGroup.add(dust); // Attach to ship so it moves with player
            return { mesh: dust, geometry, material };
        }

        const spaceDust = createSpaceDust();

        // ========================================
        // ASTEROID TEXTURE GENERATION
        // ========================================
        function generateAsteroidTexture(size = 512) {
            const canvas = document.createElement('canvas');
            canvas.width = size;
            canvas.height = size;
            const ctx = canvas.getContext('2d');

            function hash(x, y) {
                const n = Math.sin(x * 127.1 + y * 311.7) * 43758.5453;
                return n - Math.floor(n);
            }

            function smoothNoise(x, y) {
                const ix = Math.floor(x), iy = Math.floor(y);
                const fx = x - ix, fy = y - iy;
                const ux = fx * fx * (3 - 2 * fx), uy = fy * fy * (3 - 2 * fy);
                const a = hash(ix, iy), b = hash(ix + 1, iy);
                const c = hash(ix, iy + 1), d = hash(ix + 1, iy + 1);
                return a + (b - a) * ux + (c - a) * uy + (a - b - c + d) * ux * uy;
            }

            function fbm(x, y, octaves = 6) {
                let value = 0, amplitude = 0.5, frequency = 1;
                for (let i = 0; i < octaves; i++) {
                    value += amplitude * smoothNoise(x * frequency, y * frequency);
                    amplitude *= 0.5;
                    frequency *= 2;
                }
                return value;
            }

            const imageData = ctx.createImageData(size, size);
            for (let y = 0; y < size; y++) {
                for (let x = 0; x < size; x++) {
                    const nx = x / size * 8, ny = y / size * 8;
                    let n = fbm(nx, ny, 6);
                    const crater = fbm(nx * 2 + 100, ny * 2 + 100, 4);
                    if (crater > 0.62) n *= 0.55;
                    const ridge = Math.abs(fbm(nx * 3, ny * 3, 3) - 0.5) * 2;
                    n = n * 0.7 + ridge * 0.3;
                    const baseGray = 55 + n * 130;
                    const variation = fbm(nx * 4 + 50, ny * 4 + 50, 3) * 45 - 22;
                    const r = Math.min(255, Math.max(0, baseGray + variation + 18));
                    const g = Math.min(255, Math.max(0, baseGray + variation + 5));
                    const b = Math.min(255, Math.max(0, baseGray + variation - 8));
                    const i = (y * size + x) * 4;
                    imageData.data[i] = r;
                    imageData.data[i + 1] = g;
                    imageData.data[i + 2] = b;
                    imageData.data[i + 3] = 255;
                }
            }
            ctx.putImageData(imageData, 0, 0);
            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            return texture;
        }

        function generateNormalMap(size = 512) {
            const canvas = document.createElement('canvas');
            canvas.width = size;
            canvas.height = size;
            const ctx = canvas.getContext('2d');

            function hash(x, y) {
                const n = Math.sin(x * 127.1 + y * 311.7) * 43758.5453;
                return n - Math.floor(n);
            }

            function smoothNoise(x, y) {
                const ix = Math.floor(x), iy = Math.floor(y);
                const fx = x - ix, fy = y - iy;
                const ux = fx * fx * (3 - 2 * fx), uy = fy * fy * (3 - 2 * fy);
                const a = hash(ix, iy), b = hash(ix + 1, iy);
                const c = hash(ix, iy + 1), d = hash(ix + 1, iy + 1);
                return a + (b - a) * ux + (c - a) * uy + (a - b - c + d) * ux * uy;
            }

            function fbm(x, y, octaves = 5) {
                let value = 0, amplitude = 0.5, frequency = 1;
                for (let i = 0; i < octaves; i++) {
                    value += amplitude * smoothNoise(x * frequency, y * frequency);
                    amplitude *= 0.5;
                    frequency *= 2;
                }
                return value;
            }

            const heightMap = new Float32Array(size * size);
            for (let y = 0; y < size; y++) {
                for (let x = 0; x < size; x++) {
                    heightMap[y * size + x] = fbm(x / size * 8, y / size * 8, 5);
                }
            }

            const imageData = ctx.createImageData(size, size);
            const strength = 2.2;
            for (let y = 0; y < size; y++) {
                for (let x = 0; x < size; x++) {
                    const x1 = (x - 1 + size) % size, x2 = (x + 1) % size;
                    const y1 = (y - 1 + size) % size, y2 = (y + 1) % size;
                    const dX = (heightMap[y * size + x2] - heightMap[y * size + x1]) * strength;
                    const dY = (heightMap[y2 * size + x] - heightMap[y1 * size + x]) * strength;
                    const i = (y * size + x) * 4;
                    imageData.data[i] = Math.floor((dX + 1) * 0.5 * 255);
                    imageData.data[i + 1] = Math.floor((dY + 1) * 0.5 * 255);
                    imageData.data[i + 2] = 255;
                    imageData.data[i + 3] = 255;
                }
            }
            ctx.putImageData(imageData, 0, 0);
            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            return texture;
        }

        const asteroidTexture = generateAsteroidTexture(512);
        const asteroidNormalMap = generateNormalMap(512);

        // ========================================
        // ASTEROID GEOMETRY
        // ========================================
        function createAsteroidGeometry(detail = 4) {
            const geometry = new THREE.IcosahedronGeometry(1, detail);
            const positions = geometry.attributes.position;
            
            for (let i = 0; i < positions.count; i++) {
                const x = positions.getX(i);
                const y = positions.getY(i);
                const z = positions.getZ(i);
                
                const noise1 = Math.sin(x * 3.5 + y * 2.2) * Math.cos(z * 3.0) * 0.28;
                const noise2 = Math.sin(x * 7 + z * 5.5) * Math.cos(y * 6.5) * 0.14;
                const noise3 = Math.sin(y * 11 + x * 9) * Math.cos(z * 8) * 0.07;
                const noise4 = Math.sin(x * 15 + y * 13 + z * 11) * 0.035;
                
                const displacement = 1 + noise1 + noise2 + noise3 + noise4;
                positions.setXYZ(i, x * displacement, y * displacement, z * displacement);
            }
            
            geometry.computeVertexNormals();
            return geometry;
        }

        const asteroidGeometries = [
            createAsteroidGeometry(3),
            createAsteroidGeometry(4),
            createAsteroidGeometry(3),
            createAsteroidGeometry(4)
        ];

        const asteroidMaterials = [
            new THREE.MeshStandardMaterial({
                map: asteroidTexture,
                normalMap: asteroidNormalMap,
                normalScale: new THREE.Vector2(1.6, 1.6),
                roughness: 0.88,
                metalness: 0.12,
                color: 0x9a8a7a
            }),
            new THREE.MeshStandardMaterial({
                map: asteroidTexture,
                normalMap: asteroidNormalMap,
                normalScale: new THREE.Vector2(1.3, 1.3),
                roughness: 0.92,
                metalness: 0.08,
                color: 0x7a6a5a
            }),
            new THREE.MeshStandardMaterial({
                map: asteroidTexture,
                normalMap: asteroidNormalMap,
                normalScale: new THREE.Vector2(1.9, 1.9),
                roughness: 0.82,
                metalness: 0.18,
                color: 0xb5a595
            })
        ];

        // ========================================
        // ASTEROID SYSTEM
        // ========================================
        const asteroidCount = 120;
        const asteroidMeshes = [];
        const asteroids = [];

        function createAsteroid() {
            const sizeRandom = Math.random();
            let scale;
            if (sizeRandom < 0.35) {
                scale = 3 + Math.random() * 5;
            } else if (sizeRandom < 0.7) {
                scale = 8 + Math.random() * 12;
            } else if (sizeRandom < 0.9) {
                scale = 20 + Math.random() * 15;
            } else {
                scale = 35 + Math.random() * 25;
            }

            const geoIndex = Math.floor(Math.random() * asteroidGeometries.length);
            const matIndex = Math.floor(Math.random() * asteroidMaterials.length);
            
            const mesh = new THREE.Mesh(asteroidGeometries[geoIndex], asteroidMaterials[matIndex]);
            mesh.scale.setScalar(scale);
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            
            scene.add(mesh);
            asteroidMeshes.push(mesh);
            
            return {
                mesh,
                position: new THREE.Vector3(),
                rotation: new THREE.Euler(
                    Math.random() * Math.PI * 2,
                    Math.random() * Math.PI * 2,
                    Math.random() * Math.PI * 2
                ),
                rotationSpeed: new THREE.Vector3(
                    (Math.random() - 0.5) * 0.025,
                    (Math.random() - 0.5) * 0.025,
                    (Math.random() - 0.5) * 0.025
                ),
                scale,
                active: true
            };
        }

        function spawnAsteroidPosition(asteroid, initialSpawn = false) {
            const spawnZ = initialSpawn ? -200 - Math.random() * 2800 : -2500 - Math.random() * 1000;
            
            // –ù–û–í–ê–Ø –õ–û–ì–ò–ö–ê –†–ê–°–ü–†–ï–î–ï–õ–ï–ù–ò–Ø
            // –ê—Å—Ç–µ—Ä–æ–∏–¥—ã –ø–æ—è–≤–ª—è—é—Ç—Å—è —Å–ª—É—á–∞–π–Ω–æ –ø–æ –≤—Å–µ–π —à–∏—Ä–∏–Ω–µ –∏ –≤—ã—Å–æ—Ç–µ –∏–≥—Ä–æ–≤–æ–π –∑–æ–Ω—ã
            // –ó–æ–Ω–∞ –ø–æ—è–≤–ª–µ–Ω–∏—è –Ω–µ–º–Ω–æ–≥–æ —à–∏—Ä–µ, —á–µ–º –≥—Ä–∞–Ω–∏—Ü—ã –¥–≤–∏–∂–µ–Ω–∏—è –∏–≥—Ä–æ–∫–∞, —á—Ç–æ–±—ã –Ω–µ –±—ã–ª–æ –≤–∏–¥–Ω–æ "–∫—Ä–∞—ë–≤" –ø–æ—Ç–æ–∫–∞
            const fieldWidth = 500; // –®–∏—Ä–∏–Ω–∞ –ø–æ–ª—è –∞—Å—Ç–µ—Ä–æ–∏–¥–æ–≤ (–∫–æ—Ä–∞–±–ª—å –ª–µ—Ç–∞–µ—Ç –≤ –ø—Ä–µ–¥–µ–ª–∞—Ö ~300)
            const fieldHeight = 500;
            
            const offsetX = (Math.random() - 0.5) * fieldWidth;
            const offsetY = (Math.random() - 0.5) * fieldHeight;
            
            asteroid.position.set(offsetX, offsetY, spawnZ);
            
            // Randomize size on respawn
            const sizeRandom = Math.random();
            if (sizeRandom < 0.35) {
                asteroid.scale = 3 + Math.random() * 5;
            } else if (sizeRandom < 0.7) {
                asteroid.scale = 8 + Math.random() * 12;
            } else if (sizeRandom < 0.9) {
                asteroid.scale = 20 + Math.random() * 15;
            } else {
                asteroid.scale = 35 + Math.random() * 25;
            }
            
            asteroid.mesh.scale.setScalar(asteroid.scale);
            asteroid.active = true;
        }

        function initAsteroids() {
            asteroidMeshes.forEach(mesh => scene.remove(mesh));
            asteroidMeshes.length = 0;
            asteroids.length = 0;

            for (let i = 0; i < asteroidCount; i++) {
                const asteroid = createAsteroid();
                spawnAsteroidPosition(asteroid, true);
                asteroid.mesh.position.copy(asteroid.position);
                asteroid.mesh.rotation.copy(asteroid.rotation);
                asteroids.push(asteroid);
            }
        }

        initAsteroids();

        // ========================================
        // CAMERA CONTROL (View only, not movement)
        // ========================================
        const CameraControl = {
            yaw: 0,
            pitch: 0,
            roll: 0,
            targetYaw: 0,
            targetPitch: 0,
            shakeIntensity: 0,
            shakeDecay: 0.9,
            sensitivity: 0.002,
            maxPitch: Math.PI / 2.2,
            maxYaw: Math.PI / 1.8
        };

        let isPointerLocked = false;

        document.addEventListener('pointerlockchange', () => {
            isPointerLocked = document.pointerLockElement === renderer.domElement;
            // –ï—Å–ª–∏ –≤—ã—à–ª–∏ –∏–∑ –ª–æ–∫–∞ –Ω–µ —á–µ—Ä–µ–∑ ESC –≤ –º–µ–Ω—é –ø–∞—É–∑—ã (–Ω–∞–ø—Ä–∏–º–µ—Ä, alt-tab), —Å—Ç–∞–≤–∏–º –ø–∞—É–∑—É
            if (!isPointerLocked && GameState.isPlaying && !GameState.isGameOver && !GameState.isPaused) {
                togglePause();
            }
        });

        document.addEventListener('mousemove', (e) => {
            if (!isPointerLocked || !GameState.isPlaying || GameState.isPaused) return;
            
            // Mouse controls camera view only
            CameraControl.targetYaw -= e.movementX * CameraControl.sensitivity;
            CameraControl.targetPitch -= e.movementY * CameraControl.sensitivity;
            
            CameraControl.targetYaw = THREE.MathUtils.clamp(
                CameraControl.targetYaw,
                -CameraControl.maxYaw,
                CameraControl.maxYaw
            );
            CameraControl.targetPitch = THREE.MathUtils.clamp(
                CameraControl.targetPitch,
                -CameraControl.maxPitch,
                CameraControl.maxPitch
            );
        });

        // ========================================
        // KEYBOARD CONTROLS
        // ========================================
        document.addEventListener('keydown', (e) => {
            if (e.code === 'Escape') {
                if (GameState.isPlaying && !GameState.isGameOver) {
                    togglePause();
                }
                return;
            }

            if (!GameState.isPlaying || GameState.isPaused) return;
            
            switch (e.code) {
                case 'KeyW': InputState.moveUp = true; break;
                case 'KeyS': InputState.moveDown = true; break;
                case 'KeyA': InputState.moveLeft = true; break;
                case 'KeyD': InputState.moveRight = true; break;
                case 'ArrowUp': InputState.thrustUp = true; break;
                case 'ArrowDown': InputState.thrustDown = true; break;
                case 'ShiftLeft':
                case 'ShiftRight': InputState.boost = true; break;
            }
        });

        document.addEventListener('keyup', (e) => {
            switch (e.code) {
                case 'KeyW': InputState.moveUp = false; break;
                case 'KeyS': InputState.moveDown = false; break;
                case 'KeyA': InputState.moveLeft = false; break;
                case 'KeyD': InputState.moveRight = false; break;
                case 'ArrowUp': InputState.thrustUp = false; break;
                case 'ArrowDown': InputState.thrustDown = false; break;
                case 'ShiftLeft':
                case 'ShiftRight': InputState.boost = false; break;
            }
        });

        // ========================================
        // UPDATE FUNCTIONS
        // ========================================
        function updateShipMovement(delta) {
            // WASD moves the ship position
            const moveSpeed = ShipState.moveSpeed * delta;
            
            if (InputState.moveUp) ShipState.targetY += moveSpeed;
            if (InputState.moveDown) ShipState.targetY -= moveSpeed;
            if (InputState.moveLeft) ShipState.targetX -= moveSpeed;
            if (InputState.moveRight) ShipState.targetX += moveSpeed;
            
            // Clamp to boundaries
            ShipState.targetX = THREE.MathUtils.clamp(ShipState.targetX, -ShipState.maxOffset, ShipState.maxOffset);
            ShipState.targetY = THREE.MathUtils.clamp(ShipState.targetY, -ShipState.maxOffset, ShipState.maxOffset);
            
            // Smooth interpolation to target position
            const lerpSpeed = 8 * delta;
            ShipState.x += (ShipState.targetX - ShipState.x) * lerpSpeed;
            ShipState.y += (ShipState.targetY - ShipState.y) * lerpSpeed;
            
            // Update ship group position
            shipGroup.position.x = ShipState.x;
            shipGroup.position.y = ShipState.y;
        }

        function updateSpeed(delta) {
            const accel = 100;
            const decel = 80;
            const boostMult = 2.5;
            
            if (InputState.boost && InputState.thrustUp) {
                GameState.targetSpeed += accel * boostMult * delta;
                GameState.isBoosting = true;
            } else if (InputState.thrustUp) {
                GameState.targetSpeed += accel * delta;
                GameState.isBoosting = false;
            } else if (InputState.thrustDown) {
                GameState.targetSpeed -= decel * delta;
                GameState.isBoosting = false;
            } else {
                GameState.isBoosting = false;
            }
            
            GameState.targetSpeed = THREE.MathUtils.clamp(
                GameState.targetSpeed,
                GameState.minSpeed,
                GameState.maxSpeed
            );
            
            GameState.speed += (GameState.targetSpeed - GameState.speed) * delta * 4;
        }

        function updateCameraRotation(delta) {
            // Smooth camera rotation
            CameraControl.yaw += (CameraControl.targetYaw - CameraControl.yaw) * 0.08;
            CameraControl.pitch += (CameraControl.targetPitch - CameraControl.pitch) * 0.08;
            
            // Gradual return to center
            CameraControl.targetYaw *= 0.995;
            CameraControl.targetPitch *= 0.995;
            
            // Calculate roll based on horizontal movement
            const moveRollX = (ShipState.targetX - ShipState.x) * 0.008;
            CameraControl.roll += (moveRollX - CameraControl.roll) * 0.05;
            
            // Camera shake
            let shakeX = 0, shakeY = 0, shakeZ = 0;
            if (CameraControl.shakeIntensity > 0.003) {
                shakeX = (Math.random() - 0.5) * CameraControl.shakeIntensity;
                shakeY = (Math.random() - 0.5) * CameraControl.shakeIntensity;
                shakeZ = (Math.random() - 0.5) * CameraControl.shakeIntensity * 0.4;
                CameraControl.shakeIntensity *= CameraControl.shakeDecay;
            }
            
            const euler = new THREE.Euler(
                CameraControl.pitch + shakeY,
                CameraControl.yaw + shakeX,
                CameraControl.roll + shakeZ,
                'YXZ'
            );
            camera.quaternion.setFromEuler(euler);
        }

        function triggerCameraShake(intensity) {
            CameraControl.shakeIntensity = Math.max(CameraControl.shakeIntensity, intensity);
        }

        function updateSpaceDust(delta) {
            const positions = spaceDust.geometry.attributes.position;
            const dustSpeed = GameState.speed * delta * 0.55;
            
            for (let i = 0; i < positions.count; i++) {
                let z = positions.getZ(i);
                z += dustSpeed;
                
                if (z > 20) {
                    positions.setXYZ(
                        i,
                        (Math.random() - 0.5) * 350,
                        (Math.random() - 0.5) * 350,
                        -700
                    );
                } else {
                    positions.setZ(i, z);
                }
            }
            
            positions.needsUpdate = true;
            spaceDust.material.uniforms.speed.value = GameState.speed;
        }

        function updateAsteroids(delta) {
            const moveSpeed = GameState.speed * delta * 0.35;
            
            for (const asteroid of asteroids) {
                // Move asteroid toward player (world space)
                asteroid.position.z += moveSpeed;
                
                // Rotate
                asteroid.rotation.x += asteroid.rotationSpeed.x;
                asteroid.rotation.y += asteroid.rotationSpeed.y;
                asteroid.rotation.z += asteroid.rotationSpeed.z;
                
                asteroid.mesh.position.copy(asteroid.position);
                asteroid.mesh.rotation.copy(asteroid.rotation);
                
                // Reset if passed player
                if (asteroid.position.z > 200) {
                    spawnAsteroidPosition(asteroid, false);
                }
            }
        }

        // ========================================
        // COLLISION DETECTION
        // ========================================
        const playerRadius = 6;
        const nearMissTracking = new Set();

        function checkCollisions() {
            // Player world position
            const playerPos = new THREE.Vector3(ShipState.x, ShipState.y, 0);
            
            for (let i = 0; i < asteroids.length; i++) {
                const asteroid = asteroids[i];
                if (!asteroid.active) continue;
                
                // Distance from player to asteroid
                const dx = asteroid.position.x - playerPos.x;
                const dy = asteroid.position.y - playerPos.y;
                const dz = asteroid.position.z - playerPos.z;
                const distance = Math.sqrt(dx * dx + dy * dy + dz * dz);
                
                const collisionRadius = asteroid.scale + playerRadius;
                
                // Collision
                if (distance < collisionRadius) {
                    handleCollision(asteroid);
                    asteroid.active = false;
                    spawnAsteroidPosition(asteroid, false);
                    continue;
                }
                
                // Near miss
                const nearMissRadius = collisionRadius * 2.2;
                if (distance < nearMissRadius && distance > collisionRadius && !nearMissTracking.has(i)) {
                    playWhooshSound(distance);
                    nearMissTracking.add(i);
                    GameState.score += Math.floor(asteroid.scale * 3);
                }
                
                if (distance > nearMissRadius * 2.5) {
                    nearMissTracking.delete(i);
                }
            }
        }

        function handleCollision(asteroid) {
            const damage = Math.floor(asteroid.scale * 1.8 + 12);
            
            if (GameState.shield > 0) {
                const shieldDmg = Math.min(damage, GameState.shield);
                GameState.shield -= shieldDmg;
                const remaining = damage - shieldDmg;
                if (remaining > 0) GameState.health -= remaining;
            } else {
                GameState.health -= damage;
            }
            
            triggerCameraShake(0.25 + asteroid.scale * 0.012);
            showDamageVignette();
            playCollisionSound();
            
            if (GameState.health <= 0) {
                GameState.health = 0;
                gameOver();
            }
        }

        // ========================================
        // AUDIO
        // ========================================
        let audioContext, engineOsc, engineGain, engineFilter, isAudioInit = false;

        function initAudio() {
            if (isAudioInit) return;
            try {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                
                engineOsc = audioContext.createOscillator();
                engineOsc.type = 'sawtooth';
                engineOsc.frequency.setValueAtTime(45, audioContext.currentTime);
                
                const osc2 = audioContext.createOscillator();
                osc2.type = 'triangle';
                osc2.frequency.setValueAtTime(22, audioContext.currentTime);
                
                engineGain = audioContext.createGain();
                engineGain.gain.setValueAtTime(0.06, audioContext.currentTime);
                
                engineFilter = audioContext.createBiquadFilter();
                engineFilter.type = 'lowpass';
                engineFilter.frequency.setValueAtTime(140, audioContext.currentTime);
                
                engineOsc.connect(engineFilter);
                osc2.connect(engineFilter);
                engineFilter.connect(engineGain);
                engineGain.connect(audioContext.destination);
                
                engineOsc.start();
                osc2.start();
                isAudioInit = true;
            } catch (e) {}
        }

        function updateEngineSound(speed) {
            if (!isAudioInit) return;
            const ratio = speed / GameState.maxSpeed;
            engineOsc.frequency.setTargetAtTime(35 + ratio * 110, audioContext.currentTime, 0.1);
            engineFilter.frequency.setTargetAtTime(90 + ratio * 220, audioContext.currentTime, 0.1);
            engineGain.gain.setTargetAtTime(0.03 + ratio * 0.1, audioContext.currentTime, 0.1);
        }

        function playWhooshSound(dist) {
            if (!audioContext) return;
            try {
                const bufSize = audioContext.sampleRate * 0.22;
                const buffer = audioContext.createBuffer(1, bufSize, audioContext.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < bufSize; i++) {
                    data[i] = (Math.random() * 2 - 1) * Math.sin((i / bufSize) * Math.PI) * 0.18;
                }
                const source = audioContext.createBufferSource();
                source.buffer = buffer;
                const filter = audioContext.createBiquadFilter();
                filter.type = 'bandpass';
                filter.frequency.setValueAtTime(750 + Math.random() * 500, audioContext.currentTime);
                filter.Q.setValueAtTime(1.8, audioContext.currentTime);
                const gain = audioContext.createGain();
                gain.gain.setValueAtTime(Math.max(0.04, 0.18 - dist * 0.002), audioContext.currentTime);
                source.connect(filter);
                filter.connect(gain);
                gain.connect(audioContext.destination);
                source.start();
            } catch (e) {}
        }

        function playCollisionSound() {
            if (!audioContext) return;
            try {
                const osc = audioContext.createOscillator();
                osc.type = 'square';
                osc.frequency.setValueAtTime(130, audioContext.currentTime);
                osc.frequency.exponentialRampToValueAtTime(18, audioContext.currentTime + 0.45);
                const gain = audioContext.createGain();
                gain.gain.setValueAtTime(0.35, audioContext.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.45);
                const dist = audioContext.createWaveShaper();
                const curve = new Float32Array(256);
                for (let i = 0; i < 256; i++) curve[i] = Math.tanh(((i / 128) - 1) * 3);
                dist.curve = curve;
                osc.connect(dist);
                dist.connect(gain);
                gain.connect(audioContext.destination);
                osc.start();
                osc.stop(audioContext.currentTime + 0.45);
            } catch (e) {}
        }

        // ========================================
        // HUD
        // ========================================
        const healthBar = document.getElementById('health-bar');
        const healthValue = document.getElementById('health-value');
        const shieldBar = document.getElementById('shield-bar');
        const shieldValue = document.getElementById('shield-value');
        const speedValueEl = document.getElementById('speed-value');
        const speedNeedle = document.getElementById('speed-needle');
        const distanceValue = document.getElementById('distance-value');
        const timeValue = document.getElementById('time-value');
        const scoreValue = document.getElementById('score-value');
        const warningEl = document.getElementById('warning');
        const damageVignette = document.getElementById('damage-vignette');

        function updateHUD() {
            healthBar.style.width = `${GameState.health}%`;
            healthValue.textContent = `${Math.floor(GameState.health)}%`;
            
            if (GameState.health < 25) {
                healthBar.style.background = '#f00';
            } else if (GameState.health < 50) {
                healthBar.style.background = 'linear-gradient(90deg, #f00, #ff0)';
            } else {
                healthBar.style.background = 'linear-gradient(90deg, #f00, #ff0, #0f0)';
            }
            
            shieldBar.style.width = `${GameState.shield}%`;
            shieldValue.textContent = `${Math.floor(GameState.shield)}%`;
            
            speedValueEl.textContent = Math.floor(GameState.speed);
            const pct = GameState.speed / GameState.maxSpeed;
            speedNeedle.style.transform = `rotate(${-90 + pct * 180}deg)`;
            
            if (GameState.isBoosting) {
                speedValueEl.style.color = '#ff0';
                speedValueEl.style.textShadow = '0 0 25px #ff0';
            } else {
                speedValueEl.style.color = '#0ff';
                speedValueEl.style.textShadow = '0 0 10px #0ff';
            }
            
            distanceValue.textContent = `${Math.floor(GameState.distance / 100).toLocaleString()} KM`;
            
            // –†–∞—Å—Å—á–µ—Ç –≤—Ä–µ–º–µ–Ω–∏ —Å —É—á–µ—Ç–æ–º –ø–∞—É–∑
            const currentTime = Date.now();
            const elapsed = Math.floor((currentTime - GameState.startTime - GameState.totalPausedTime) / 1000);
            
            const mins = Math.floor(elapsed / 60).toString().padStart(2, '0');
            const secs = (elapsed % 60).toString().padStart(2, '0');
            timeValue.textContent = `${mins}:${secs}`;
            
            scoreValue.textContent = Math.floor(GameState.score).toLocaleString();
            
            // Warning
            let warn = false;
            const playerPos = new THREE.Vector3(ShipState.x, ShipState.y, 0);
            for (const ast of asteroids) {
                if (ast.position.z > -180 && ast.position.z < 50) {
                    const dx = ast.position.x - playerPos.x;
                    const dy = ast.position.y - playerPos.y;
                    const latDist = Math.sqrt(dx * dx + dy * dy);
                    if (latDist < ast.scale + 40) {
                        warn = true;
                        break;
                    }
                }
            }
            warningEl.style.display = warn ? 'block' : 'none';
        }

        function showDamageVignette() {
            damageVignette.style.background = 'radial-gradient(ellipse at center, transparent 25%, rgba(255, 0, 0, 0.65) 100%)';
            damageVignette.style.opacity = '1';
            setTimeout(() => { damageVignette.style.opacity = '0'; }, 180);
        }

        // ========================================
        // GAME FLOW
        // ========================================
        const startScreen = document.getElementById('start-screen');
        const pauseScreen = document.getElementById('pause-screen');
        const hud = document.getElementById('hud');
        const gameOverScreen = document.getElementById('game-over');
        const finalScoreEl = document.getElementById('final-score');

        function togglePause() {
            GameState.isPaused = !GameState.isPaused;
            
            if (GameState.isPaused) {
                GameState.pauseStartTime = Date.now();
                document.exitPointerLock();
                pauseScreen.style.display = 'flex';
                // –ü—Ä–∏–≥–ª—É—à–∞–µ–º –∑–≤—É–∫ –¥–≤–∏–≥–∞—Ç–µ–ª—è –Ω–∞ –ø–∞—É–∑–µ
                if (isAudioInit) engineGain.gain.setTargetAtTime(0, audioContext.currentTime, 0.1);
            } else {
                GameState.totalPausedTime += Date.now() - GameState.pauseStartTime;
                renderer.domElement.requestPointerLock();
                pauseScreen.style.display = 'none';
            }
        }

        function startGame() {
            startScreen.style.display = 'none';
            gameOverScreen.style.display = 'none';
            pauseScreen.style.display = 'none';
            hud.style.display = 'block';
            
            GameState.health = 100;
            GameState.shield = 100;
            GameState.speed = 120;
            GameState.targetSpeed = 120;
            GameState.distance = 0;
            GameState.score = 0;
            GameState.startTime = Date.now();
            GameState.totalPausedTime = 0;
            GameState.isPlaying = true;
            GameState.isPaused = false;
            GameState.isGameOver = false;
            GameState.isBoosting = false;
            
            ShipState.x = 0;
            ShipState.y = 0;
            ShipState.targetX = 0;
            ShipState.targetY = 0;
            shipGroup.position.set(0, 0, 0);
            
            CameraControl.yaw = 0;
            CameraControl.pitch = 0;
            CameraControl.roll = 0;
            CameraControl.targetYaw = 0;
            CameraControl.targetPitch = 0;
            CameraControl.shakeIntensity = 0;
            
            Object.keys(InputState).forEach(k => InputState[k] = false);
            nearMissTracking.clear();
            
            initAsteroids();
            renderer.domElement.requestPointerLock();
            initAudio();
            updateHUD();
        }

        function gameOver() {
            GameState.isPlaying = false;
            GameState.isGameOver = true;
            document.exitPointerLock();
            finalScoreEl.textContent = Math.floor(GameState.score).toLocaleString();
            gameOverScreen.style.display = 'flex';
        }

        startScreen.addEventListener('click', startGame);
        gameOverScreen.addEventListener('click', startGame);
        pauseScreen.addEventListener('click', togglePause);

        // ========================================
        // MAIN LOOP
        // ========================================
        const clock = new THREE.Clock();

        function updateGameState(delta) {
            if (!GameState.isPlaying || GameState.isPaused) return;
            
            updateSpeed(delta);
            GameState.distance += GameState.speed * delta;
            GameState.score += GameState.speed * delta * 0.04;
            
            if (GameState.shield < 100) {
                GameState.shield = Math.min(GameState.shield + delta * 2.5, 100);
            }
            
            updateEngineSound(GameState.speed);
        }

        function animate() {
            requestAnimationFrame(animate);
            
            const delta = Math.min(clock.getDelta(), 0.1);
            const time = clock.getElapsedTime();
            
            if (GameState.isPlaying && !GameState.isGameOver && !GameState.isPaused) {
                updateShipMovement(delta);
                updateCameraRotation(delta);
                updateGameState(delta);
                updateSpaceDust(delta);
                updateAsteroids(delta);
                checkCollisions();
                updateHUD();
            }
            
            starfield.material.uniforms.time.value = time;
            nebula.material.uniforms.time.value = time;
            
            composer.render();
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
            bloomPass.resolution.set(window.innerWidth, window.innerHeight);
        }

        window.addEventListener('resize', onWindowResize);
        animate();
    </script>
</body>
</html>