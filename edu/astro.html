<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no, maximum-scale=1.0" />
<title>–ê—Å—Ç—Ä–æ—Å—Ñ–µ—Ä–∞</title>
<link rel="icon" href="planet.png" type="image/png" />
<style>
    :root {
        --bg-color: #000510;
        --panel-bg: linear-gradient(135deg, rgba(10, 20, 40, 0.92), rgba(5, 15, 35, 0.88));
        --accent: #00e5ff;
        --accent-glow: rgba(0, 229, 255, 0.4);
        --accent-dim: rgba(0, 229, 255, 0.15);
        --gold: #ffd700;
        --text-main: #e0f7fa;
        --border: rgba(0, 229, 255, 0.4);
        --iss-color: #00ff88;
    }

    * { box-sizing: border-box; }

    body, html {
        margin: 0; padding: 0; width: 100%; height: 100%;
        background: radial-gradient(ellipse at center, #0a1628 0%, #000510 100%);
        overflow: hidden;
        font-family: 'Segoe UI', Tahoma, sans-serif;
        color: var(--text-main);
        user-select: none;
    }

    canvas { display: block; width: 100%; height: 100%; outline: none; cursor: grab; }
    canvas:active { cursor: grabbing; }

    #search-container {
        position: absolute; top: 12px; left: 50%; transform: translateX(-50%);
        width: 380px; z-index: 100;
        display: flex; flex-direction: column; gap: 5px;
    }
    #universal-search {
        width: 100%; padding: 14px 20px;
        background: var(--panel-bg);
        border: 1px solid var(--accent);
        border-radius: 25px; color: white; font-size: 14px; outline: none;
        box-shadow: 0 0 25px rgba(0, 229, 255, 0.2);
        backdrop-filter: blur(15px);
    }
    #universal-search::placeholder { color: rgba(255,255,255,0.5); }
    #universal-search:focus { box-shadow: 0 0 35px rgba(0, 229, 255, 0.4); }
    
    #search-results {
        background: var(--panel-bg);
        border-radius: 16px;
        border: 1px solid var(--accent);
        max-height: 450px;
        overflow-y: auto;
        display: none;
        box-shadow: 0 15px 40px rgba(0,0,0,0.6);
        backdrop-filter: blur(15px);
    }
    #search-results::-webkit-scrollbar { width: 6px; }
    #search-results::-webkit-scrollbar-thumb { background: var(--accent); border-radius: 3px; }
    
    .search-group-title {
        padding: 10px 18px;
        font-size: 10px;
        text-transform: uppercase;
        color: var(--gold);
        background: rgba(0,0,0,0.4);
        letter-spacing: 2px;
        font-weight: 700;
        position: sticky;
        top: 0;
    }
    .search-item {
        padding: 12px 18px;
        cursor: pointer;
        border-bottom: 1px solid rgba(255,255,255,0.05);
        font-size: 13px;
        transition: all 0.2s;
        display: flex;
        justify-content: space-between;
        align-items: center;
    }
    .search-item:hover { 
        background: rgba(0, 229, 255, 0.2); 
        color: var(--accent);
        padding-left: 22px;
    }
    .search-item-info { font-size: 10px; opacity: 0.6; text-align: right; }
    .search-item-icon { margin-right: 10px; }

    #btn-toggle-const {
        position: absolute; top: 70px; left: 12px;
        width: 44px; height: 44px;
        background: var(--panel-bg);
        border: 1px solid var(--border);
        border-radius: 10px; cursor: pointer;
        display: flex; justify-content: center; align-items: center;
        font-size: 22px; z-index: 20; 
        transition: all 0.3s ease;
        box-shadow: 0 4px 15px rgba(0,0,0,0.5);
    }
    #btn-toggle-const:hover { 
        background: var(--accent-dim); 
        color: var(--accent); 
        border-color: var(--accent);
        transform: scale(1.05);
    }

    #btn-toggle-controls {
        position: absolute; top: 12px; right: 12px;
        width: 44px; height: 44px;
        background: var(--panel-bg);
        border: 1px solid var(--border);
        border-radius: 10px; cursor: pointer;
        display: none; justify-content: center; align-items: center;
        font-size: 22px; z-index: 21; 
        transition: all 0.3s ease;
        box-shadow: 0 4px 15px rgba(0,0,0,0.5);
    }
    #btn-toggle-controls:hover { 
        background: var(--accent-dim); 
        color: var(--accent); 
        border-color: var(--accent);
        transform: scale(1.05);
    }

    #constellation-panel {
        position: absolute; top: 120px; left: 12px; bottom: 12px;
        width: 280px;
        background: var(--panel-bg);
        border: 1px solid var(--border);
        border-radius: 12px;
        display: none; flex-direction: column;
        backdrop-filter: blur(15px); 
        z-index: 19;
        box-shadow: 0 6px 30px rgba(0,0,0,0.5);
    }
    #constellation-panel.visible { display: flex; animation: slideIn 0.3s ease forwards; }
    @keyframes slideIn { from { opacity: 0; transform: translateX(-20px); } to { opacity: 1; transform: translateX(0); } }

    .panel-header { 
        padding: 12px; 
        border-bottom: 1px solid rgba(255,255,255,0.1); 
        flex-shrink: 0;
        background: rgba(0,0,0,0.2);
        border-radius: 12px 12px 0 0;
        font-size: 12px;
        color: var(--accent);
        text-align: center;
        font-weight: 600;
    }
    
    #const-list {
        flex: 1; overflow-y: auto; padding: 6px;
        scrollbar-width: thin; scrollbar-color: var(--accent) transparent;
    }
    #const-list::-webkit-scrollbar { width: 5px; }
    #const-list::-webkit-scrollbar-thumb { background: var(--accent); border-radius: 3px; }
    
    .const-item {
        padding: 10px 12px; cursor: pointer; font-size: 13px; border-radius: 6px;
        margin-bottom: 3px; transition: all 0.2s; display: flex; justify-content: space-between;
        border-left: 3px solid transparent;
        align-items: center;
    }
    .const-item:hover { background: var(--accent-dim); color: var(--accent); border-left-color: var(--accent); }
    .const-item.active { 
        background: linear-gradient(90deg, rgba(0, 229, 255, 0.3), transparent); 
        color: #fff; font-weight: 600; border-left-color: var(--accent);
        box-shadow: inset 0 0 15px rgba(0, 229, 255, 0.2);
    }
    .const-item.below-horizon {
        opacity: 0.5;
    }
    .const-item.below-horizon .const-name::after {
        content: ' ‚Üì';
        color: #ff6666;
        font-size: 11px;
    }
    .const-item-left { display: flex; flex-direction: column; }
    .const-name { }
    .latin-name { font-size: 10px; opacity: 0.5; font-style: italic; }
    .horizon-badge {
        font-size: 9px;
        padding: 2px 6px;
        border-radius: 8px;
        background: rgba(255, 100, 100, 0.3);
        color: #ff8888;
        white-space: nowrap;
    }
    .visible-badge {
        font-size: 9px;
        padding: 2px 6px;
        border-radius: 8px;
        background: rgba(100, 255, 100, 0.2);
        color: #88ff88;
        white-space: nowrap;
    }
    
    #btn-reset-view {
        margin: 10px; padding: 10px;
        background: rgba(0, 229, 255, 0.15);
        border: 1px solid var(--accent);
        color: var(--accent); cursor: pointer; border-radius: 6px;
        text-transform: uppercase; font-size: 11px; font-weight: 700;
    }
    #btn-reset-view:hover { background: var(--accent); color: #000; }

    #controls-panel {
        position: absolute; top: 12px; right: 12px;
        width: 220px;
        background: var(--panel-bg);
        border: 1px solid var(--border);
        border-radius: 12px; padding: 12px;
        backdrop-filter: blur(15px);
        box-shadow: 0 6px 30px rgba(0,0,0,0.5);
        font-size: 12px;
        max-height: calc(100vh - 140px);
        overflow-y: auto;
        z-index: 20;
    }
    .panel-title {
        font-size: 10px; font-weight: 700; color: var(--accent);
        text-transform: uppercase; letter-spacing: 1.5px; margin-bottom: 10px;
        text-align: center; padding-bottom: 8px;
        border-bottom: 1px solid rgba(0, 229, 255, 0.2);
    }
    .cam-mode-switch {
        display: flex; background: rgba(0,0,0,0.4); border-radius: 8px; padding: 3px; margin-bottom: 12px;
    }
    .cam-btn {
        flex: 1; border: none; background: transparent; color: rgba(255,255,255,0.5);
        padding: 7px 5px; font-size: 11px; cursor: pointer; border-radius: 6px; transition: all 0.2s;
    }
    .cam-btn:hover { color: white; background: rgba(255,255,255,0.1); }
    .cam-btn.active { background: var(--accent); color: #000; font-weight: 700; }
    .cam-btn:disabled { opacity: 0.3; cursor: not-allowed; }
    
    .ctrl-row {
        display: flex; justify-content: space-between; align-items: center;
        margin-bottom: 8px; font-size: 12px; padding: 6px 8px;
        background: rgba(0,0,0,0.2); border-radius: 6px;
    }
    
    .switch { position: relative; width: 38px; height: 20px; flex-shrink: 0; }
    .switch input { opacity: 0; width: 0; height: 0; }
    .slider {
        position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0;
        background-color: rgba(50, 60, 80, 0.8); border-radius: 20px; transition: .3s; 
    }
    .slider:before {
        position: absolute; content: ""; height: 14px; width: 14px;
        left: 3px; bottom: 3px; background: #fff; border-radius: 50%; transition: .3s;
    }
    input:checked + .slider { background: rgba(0, 229, 255, 0.5); }
    input:checked + .slider:before { transform: translateX(18px); background: var(--accent); }

    #info-panel {
        position: absolute; bottom: 12px; right: 12px;
        background: var(--panel-bg); border: 1px solid var(--border);
        border-radius: 10px; padding: 10px 14px;
        backdrop-filter: blur(15px); pointer-events: none;
        text-align: right; min-width: 180px;
        box-shadow: 0 4px 20px rgba(0,0,0,0.4);
        z-index: 18;
    }
    .info-title { font-weight: 600; margin-bottom: 4px; font-size: 10px; text-transform: uppercase; letter-spacing: 1px; opacity: 0.7; }
    .info-data { font-family: 'Consolas', monospace; font-size: 11px; line-height: 1.5; color: rgba(255,255,255,0.7); }
    .info-location { font-size: 12px; color: #fff; margin-bottom: 4px; font-weight: 500; }
    .val-gold { color: var(--gold); font-size: 16px; font-weight: 700; }
    #iss-data { margin-top: 6px; padding-top: 6px; border-top: 1px solid rgba(255,255,255,0.1); color: var(--iss-color); font-weight: 600; font-size: 10px; }
    
    #tooltip {
        position: absolute;
        background: linear-gradient(135deg, rgba(5, 15, 35, 0.95), rgba(10, 25, 50, 0.95));
        border: 1px solid var(--accent); border-radius: 10px; padding: 12px 16px;
        pointer-events: none; display: none; z-index: 100;
        box-shadow: 0 8px 30px rgba(0,0,0,0.6), 0 0 20px var(--accent-glow);
        backdrop-filter: blur(10px); max-width: 250px; min-width: 150px;
    }
    .tooltip-header { display: flex; align-items: center; gap: 8px; margin-bottom: 8px; padding-bottom: 8px; border-bottom: 1px solid rgba(0, 229, 255, 0.3); }
    .tooltip-icon { font-size: 20px; }
    .tooltip-name { font-size: 14px; font-weight: 700; color: #fff; }
    .tooltip-type { font-size: 10px; color: var(--accent); text-transform: uppercase; letter-spacing: 1px; }
    .tooltip-row { display: flex; justify-content: space-between; font-size: 11px; margin-bottom: 4px; color: rgba(255,255,255,0.8); }
    .tooltip-label { opacity: 0.6; }
    .tooltip-value { font-family: 'Consolas', monospace; color: var(--gold); font-weight: 600; }
    .tooltip-constellation { margin-top: 8px; padding-top: 8px; border-top: 1px solid rgba(255,255,255,0.1); font-size: 10px; color: rgba(255,255,255,0.5); }

    #zoom-indicator, #mode-indicator {
        position: absolute; bottom: 12px; left: 50%; transform: translateX(-50%);
        background: var(--panel-bg); border: 1px solid var(--border); border-radius: 15px;
        padding: 8px 20px; font-size: 12px; backdrop-filter: blur(10px);
        pointer-events: none; opacity: 0; transition: opacity 0.3s;
        text-align: center;
    }
    #zoom-indicator { bottom: 55px; }
    #zoom-indicator.visible, #mode-indicator.visible { opacity: 1; }
    
    #loading {
        position: absolute; top: 0; left: 0; width: 100%; height: 100%;
        background: radial-gradient(ellipse at center, #0a1628 0%, #000510 100%);
        display: flex; flex-direction: column; justify-content: center; align-items: center;
        z-index: 9999; transition: opacity 0.5s;
    }
    .loader-text { color: var(--accent); font-size: 16px; text-transform: uppercase; letter-spacing: 3px; margin-top: 25px; animation: pulse 1.5s ease-in-out infinite; }
    @keyframes pulse { 0%, 100% { opacity: 0.5; } 50% { opacity: 1; } }
    .loader-spinner { width: 50px; height: 50px; border: 3px solid rgba(0, 229, 255, 0.2); border-top-color: var(--accent); border-radius: 50%; animation: spin 1s linear infinite; }
    @keyframes spin { to { transform: rotate(360deg); } }

    /* –≠—Ñ—Ñ–µ–∫—Ç—ã –ø–µ—Ä–µ—Ö–æ–¥–∞ */
    #transition-overlay {
        position: fixed;
        top: 0; left: 0; width: 100%; height: 100%;
        pointer-events: none;
        z-index: 500;
        display: none;
    }
    
    #vignette {
        position: absolute;
        top: 0; left: 0; width: 100%; height: 100%;
        background: radial-gradient(ellipse at center, transparent 0%, transparent 40%, rgba(0,0,0,0) 100%);
        opacity: 0;
        transition: opacity 0.3s;
    }
    
    #speed-lines {
        position: absolute;
        top: 0; left: 0; width: 100%; height: 100%;
        overflow: hidden;
        opacity: 0;
    }
    
    .speed-line {
        position: absolute;
        background: linear-gradient(90deg, transparent, rgba(0, 229, 255, 0.8), transparent);
        height: 2px;
        transform-origin: center;
    }
    
    #transition-text {
        position: absolute;
        top: 50%; left: 50%;
        transform: translate(-50%, -50%);
        font-size: 18px;
        color: var(--accent);
        text-transform: uppercase;
        letter-spacing: 4px;
        opacity: 0;
        text-shadow: 0 0 20px var(--accent), 0 0 40px var(--accent);
        white-space: nowrap;
    }
    
    #skip-hint {
        position: absolute;
        bottom: 30px;
        left: 50%;
        transform: translateX(-50%);
        font-size: 12px;
        color: rgba(255,255,255,0.5);
        opacity: 0;
        transition: opacity 0.3s;
    }
    
    #iss-highlight {
        position: absolute;
        width: 100px; height: 100px;
        border: 2px solid var(--iss-color);
        border-radius: 50%;
        transform: translate(-50%, -50%);
        opacity: 0;
        box-shadow: 0 0 30px var(--iss-color), inset 0 0 30px rgba(0, 255, 136, 0.2);
        pointer-events: none;
    }
    
    #iss-highlight::before {
        content: 'üõ∞Ô∏è –ú–ö–°';
        position: absolute;
        top: -30px;
        left: 50%;
        transform: translateX(-50%);
        color: var(--iss-color);
        font-size: 14px;
        font-weight: bold;
        white-space: nowrap;
        text-shadow: 0 0 10px var(--iss-color);
    }

    @media (max-width: 768px) {
        #btn-toggle-controls { display: flex; }
        
        #controls-panel {
            display: none;
            top: 62px; right: 12px;
            width: calc(100vw - 24px);
            max-width: 280px;
            max-height: calc(100vh - 180px);
        }
        #controls-panel.visible { 
            display: block; 
            animation: slideIn 0.3s ease forwards; 
        }
        
        #search-container { width: calc(100vw - 80px); max-width: 320px; }
        #universal-search { padding: 12px 16px; font-size: 13px; }
        
        #constellation-panel { 
            width: calc(100vw - 24px); 
            max-width: 260px; 
            top: 62px;
        }
        
        #info-panel { 
            bottom: 8px; right: 8px; 
            padding: 8px 10px; 
            min-width: 150px; 
        }
        .info-location { font-size: 11px; }
        .val-gold { font-size: 14px; }
        
        #btn-toggle-const { top: 12px; left: 12px; }
    }

    @media (max-width: 480px) {
        #search-container { 
            width: calc(100vw - 120px); 
            left: 60px;
            transform: none;
        }
        #controls-panel { max-width: none; }
        #constellation-panel { max-width: none; }
    }
</style>
</head>
<body>

<div id="loading">
    <div class="loader-spinner"></div>
    <div class="loader-text">–ó–∞–≥—Ä—É–∑–∫–∞ –ü–ª–∞–Ω–µ—Ç–∞—Ä–∏—è...</div>
</div>

<div id="transition-overlay">
    <div id="vignette"></div>
    <div id="speed-lines"></div>
    <div id="transition-text"></div>
    <div id="skip-hint">–ù–∞–∂–º–∏—Ç–µ –¥–ª—è –ø—Ä–æ–ø—É—Å–∫–∞</div>
    <div id="iss-highlight"></div>
</div>

<div id="search-container">
    <input type="text" id="universal-search" placeholder="üîç –ü–æ–∏—Å–∫: –≥–æ—Ä–æ–¥, –∑–≤–µ–∑–¥–∞, —Å–æ–∑–≤–µ–∑–¥–∏–µ, –ø–ª–∞–Ω–µ—Ç–∞..." autocomplete="off">
    <div id="search-results"></div>
</div>

<div id="btn-toggle-const" title="–°–ø–∏—Å–æ–∫ —Å–æ–∑–≤–µ–∑–¥–∏–π">‚ò∞</div>
<div id="btn-toggle-controls" title="–ù–∞—Å—Ç—Ä–æ–π–∫–∏">‚öôÔ∏è</div>

<div id="constellation-panel">
    <div class="panel-header">üìú –í—Å–µ —Å–æ–∑–≤–µ–∑–¥–∏—è</div>
    <div id="const-list"></div>
    <button id="btn-reset-view">‚Ü∫ –°–±—Ä–æ—Å</button>
</div>

<div id="controls-panel">
    <div class="panel-title">üé• –†–µ–∂–∏–º</div>
    <div class="cam-mode-switch">
        <button class="cam-btn active" id="cam-out">üåç –°—Ñ–µ—Ä–∞ </button>
        <button class="cam-btn" id="cam-in">üëÅ –ù–∞–±–ª—é–¥–∞—Ç–µ–ª—å</button>
    </div>

    <div class="panel-title">‚öôÔ∏è –°–ª–æ–∏</div>
    <div class="ctrl-row"><span>üåê –°–µ—Ç–∫–∞</span><label class="switch"><input type="checkbox" id="chk-grid"><span class="slider"></span></label></div>
    <div class="ctrl-row"><span>‚≠ê –ó–≤–µ–∑–¥—ã</span><label class="switch"><input type="checkbox" id="chk-stars"><span class="slider"></span></label></div>
    <div class="ctrl-row"><span>‚ú® –õ–∏–Ω–∏–∏ —Å–æ–∑–≤.</span><label class="switch"><input type="checkbox" id="chk-lines"><span class="slider"></span></label></div>
    <div class="ctrl-row"><span>üè∑Ô∏è –ù–∞–∑–≤. —Å–æ–∑–≤.</span><label class="switch"><input type="checkbox" id="chk-const-names"><span class="slider"></span></label></div>
    <div class="ctrl-row"><span>‚≠ê –ù–∞–∑–≤. –∑–≤—ë–∑–¥</span><label class="switch"><input type="checkbox" id="chk-star-names"><span class="slider"></span></label></div>
    <div class="ctrl-row"><span>ü™ê –ü–ª–∞–Ω–µ—Ç—ã</span><label class="switch"><input type="checkbox" id="chk-planets"><span class="slider"></span></label></div>
    <div class="ctrl-row"><span>„Ä∞Ô∏è –¢—Ä–∞–µ–∫—Ç–æ—Ä–∏–∏</span><label class="switch"><input type="checkbox" id="chk-traj"><span class="slider"></span></label></div>
    <div class="ctrl-row"><span>üõ∞Ô∏è –ú–ö–°</span><label class="switch"><input type="checkbox" id="chk-iss"><span class="slider"></span></label></div>
    <div class="ctrl-row"><span>üèûÔ∏è –õ–∞–Ω–¥—à–∞—Ñ—Ç</span><label class="switch"><input type="checkbox" id="chk-ground"><span class="slider"></span></label></div>
</div>

<div id="info-panel">
    <div class="info-title">üìç –ù–∞–±–ª—é–¥–∞—Ç–µ–ª—å</div>
    <div class="info-location" id="location-name">–û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ...</div>
    <div class="info-data" id="loc-data">GPS...</div>
    <div class="info-data val-gold" id="time-data">--:--:--</div>
    <div class="info-data" id="iss-data" style="display:none;">üõ∞Ô∏è –ú–ö–°</div>
</div>

<div id="tooltip"></div>
<div id="zoom-indicator">üî≠ Zoom: 60¬∞</div>
<div id="mode-indicator"></div>

<script type="importmap">
{ "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js", "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/" } }
</script>
<script src="https://cdn.jsdelivr.net/npm/astronomy-engine@2.1.19/astronomy.browser.min.js"></script>
<script src="constellations.js"></script>

<script type="module">
import * as THREE from "three";
import { OrbitControls } from "three/addons/controls/OrbitControls.js";

const DEFAULT_SETTINGS = { 
    grid: true, ground: true, stars: true, lines: true, 
    constNames: false, starNames: false, planets: true, 
    traj: false, iss: true, camMode: 'out' 
};
let settings = { ...DEFAULT_SETTINGS };
let transitionFinalTheta = 0;

function loadSettings() {
    const saved = localStorage.getItem('planetarium_v10');
    if (saved) try { settings = { ...DEFAULT_SETTINGS, ...JSON.parse(saved) }; } catch (e) {}
}
function saveSettings() { localStorage.setItem('planetarium_v10', JSON.stringify(settings)); }

let scene, camera, renderer, controls, raycaster, mouse;
const SPHERE_RADIUS = 50; 
let observerLat = 55.75, observerLon = 37.61;
let locationName = '–ú–æ—Å–∫–≤–∞';
let activeConstellation = null;
let highlightedStarName = null;
let currentSunAltitude = -90;

const PLANETS = ['Mercury', 'Venus', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune'];
const PLANET_NAMES_RU = { Mercury: '–ú–µ—Ä–∫—É—Ä–∏–π', Venus: '–í–µ–Ω–µ—Ä–∞', Mars: '–ú–∞—Ä—Å', Jupiter: '–Æ–ø–∏—Ç–µ—Ä', Saturn: '–°–∞—Ç—É—Ä–Ω', Uranus: '–£—Ä–∞–Ω', Neptune: '–ù–µ–ø—Ç—É–Ω' };
const PLANET_MAG = { Mercury: 0.5, Venus: -4.0, Mars: 1.0, Jupiter: -2.0, Saturn: 0.5, Uranus: 5.5, Neptune: 7.8 };

const groups = { 
    grid: new THREE.Group(), 
    cardinals: new THREE.Group(),
    zenithNadir: new THREE.Group(),
    stars: new THREE.Group(), 
    starLabels: new THREE.Group(),
    constellations: new THREE.Group(), 
    planets: new THREE.Group(), 
    trajectories: new THREE.Group(), 
    sunMoon: new THREE.Group(), 
    iss: new THREE.Group(), 
    ground: new THREE.Group(),
    transitionParticles: new THREE.Group()
};

const constellationMap = {}; 
const constellationVisibility = {};
const allStarLabels = [];
const starPositions = {};
const planetPositions = {};
let issPosition = null;
let landscapeMesh = null;

const interactiveObjects = [];
let hoveredObject = null;

let isInsideMode = false;
let spherical = { phi: Math.PI / 2, theta: 0 };
let isMouseDown = false;
let lastMouseX = 0, lastMouseY = 0;
let currentFov = 60;
const MIN_FOV = 15, MAX_FOV = 100;
let zoomTimeout = null;
let searchTimeout = null;

let cameraAnimation = null;
let constellationAnimation = null;

// === –°–ò–°–¢–ï–ú–ê –ö–ò–ù–ï–ú–ê–¢–û–ì–†–ê–§–ò–ß–ï–°–ö–ò–• –ü–ï–†–ï–•–û–î–û–í ===
let isTransitioning = false;
let transitionProgress = 0;
let transitionStartTime = 0;
let transitionDuration = 3000;
let transitionType = null;
let transitionPath = null;
let transitionLookAtPath = null;
let canSkipTransition = false;
let transitionParticles = [];

const Easing = {
    easeInQuad: t => t * t,
    easeOutQuad: t => t * (2 - t),
    easeOutCubic: t => (--t) * t * t + 1,
    easeOutQuart: t => 1 - (--t) * t * t * t,
    easeInOutCubic: t => t < 0.5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1,
    easeInOutQuad: t => t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t,
    flightEase: t => {
        if (t < 0.15) return Easing.easeInQuad(t / 0.15) * 0.15;
        if (t < 0.85) return 0.15 + (t - 0.15) * 0.7 / 0.7;
        return 0.85 + Easing.easeOutQuart((t - 0.85) / 0.15) * 0.15;
    }
};

function createTransitionParticles() {
    while (groups.transitionParticles.children.length > 0) {
        const child = groups.transitionParticles.children[0];
        groups.transitionParticles.remove(child);
        if (child.geometry) child.geometry.dispose();
        if (child.material) child.material.dispose();
    }
    transitionParticles = [];
    
    const particleCount = 150;
    const geometry = new THREE.BufferGeometry();
    const positions = new Float32Array(particleCount * 3);
    const velocities = [];
    
    for (let i = 0; i < particleCount; i++) {
        const theta = Math.random() * Math.PI * 2;
        const phi = Math.acos(2 * Math.random() - 1);
        const r = 3 + Math.random() * 15;
        
        positions[i * 3] = r * Math.sin(phi) * Math.cos(theta);
        positions[i * 3 + 1] = r * Math.sin(phi) * Math.sin(theta);
        positions[i * 3 + 2] = r * Math.cos(phi);
        
        velocities.push({
            x: (Math.random() - 0.5) * 0.3,
            y: (Math.random() - 0.5) * 0.3,
            z: -1.5 - Math.random() * 2
        });
    }
    
    geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    
    const material = new THREE.PointsMaterial({
        color: 0x00e5ff,
        size: 0.25,
        transparent: true,
        opacity: 0,
        blending: THREE.AdditiveBlending,
        depthWrite: false
    });
    
    const particles = new THREE.Points(geometry, material);
    particles.userData.velocities = velocities;
    groups.transitionParticles.add(particles);
    transitionParticles.push(particles);
    
    return particles;
}

function updateTransitionParticles(speed, direction) {
    transitionParticles.forEach(particles => {
        const positions = particles.geometry.attributes.position.array;
        const velocities = particles.userData.velocities;
        
        for (let i = 0; i < velocities.length; i++) {
            positions[i * 3] += velocities[i].x * speed;
            positions[i * 3 + 1] += velocities[i].y * speed;
            positions[i * 3 + 2] += velocities[i].z * speed * direction;
            
            const dist = Math.sqrt(
                positions[i * 3] ** 2 + 
                positions[i * 3 + 1] ** 2 + 
                positions[i * 3 + 2] ** 2
            );
            
            if (dist > 40 || dist < 1) {
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                const r = 8 + Math.random() * 12;
                positions[i * 3] = r * Math.sin(phi) * Math.cos(theta);
                positions[i * 3 + 1] = r * Math.sin(phi) * Math.sin(theta);
                positions[i * 3 + 2] = r * Math.cos(phi) * direction;
            }
        }
        
        particles.geometry.attributes.position.needsUpdate = true;
    });
}

function createPathToInside() {
    const startPos = camera.position.clone();
    const startDist = startPos.length();
    
    const midPoint1 = startPos.clone().normalize().multiplyScalar(startDist * 1.2);
    midPoint1.y += 30;
    
    const angle = Math.atan2(startPos.x, startPos.z) + Math.PI * 0.4;
    const midPoint2 = new THREE.Vector3(
        Math.sin(angle) * SPHERE_RADIUS * 0.8,
        SPHERE_RADIUS * 0.6,
        Math.cos(angle) * SPHERE_RADIUS * 0.8
    );
    
    const midPoint3 = new THREE.Vector3(
        Math.sin(angle + 0.3) * SPHERE_RADIUS * 0.4,
        SPHERE_RADIUS * 0.3,
        Math.cos(angle + 0.3) * SPHERE_RADIUS * 0.4
    );
    
    // –§–∏–Ω–∞–ª—å–Ω–æ–µ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –≤–∑–≥–ª—è–¥–∞ ‚Äî –ø—Ä–æ–¥–æ–ª–∂–µ–Ω–∏–µ —Ç—Ä–∞–µ–∫—Ç–æ—Ä–∏–∏
    const finalLookAngle = angle + 0.5;
    const finalLookAt = new THREE.Vector3(
        Math.sin(finalLookAngle) * 50,
        10,
        Math.cos(finalLookAngle) * 50
    );
    
    const points = [
        startPos.clone(),
        midPoint1,
        midPoint2,
        midPoint3,
        new THREE.Vector3(0, 5, 0),
        new THREE.Vector3(0, 0.5, 0)
    ];
    
    const lookAtPoints = [
        new THREE.Vector3(0, 0, 0),
        new THREE.Vector3(0, 0, 0),
        new THREE.Vector3(0, 0, 0),
        finalLookAt.clone(),
        finalLookAt.clone(),
        finalLookAt.clone()
    ];
    
    return {
        path: new THREE.CatmullRomCurve3(points),
        lookAt: lookAtPoints,
        finalTheta: finalLookAngle
    };
}

function createPathToOutside() {
    const targetPos = new THREE.Vector3(0, 50, 100);
    
    const lookDir = new THREE.Vector3(
        Math.sin(spherical.phi) * Math.sin(spherical.theta),
        Math.cos(spherical.phi),
        Math.sin(spherical.phi) * Math.cos(spherical.theta)
    ).normalize();
    
    const exitAngle = Math.atan2(targetPos.x, targetPos.z);
    
    const points = [
        new THREE.Vector3(0, 0.5, 0),
        new THREE.Vector3(0, 8, 0),
        new THREE.Vector3(
            Math.sin(exitAngle - 0.5) * SPHERE_RADIUS * 0.3,
            SPHERE_RADIUS * 0.5,
            Math.cos(exitAngle - 0.5) * SPHERE_RADIUS * 0.3
        ),
        new THREE.Vector3(
            Math.sin(exitAngle - 0.3) * SPHERE_RADIUS * 0.7,
            SPHERE_RADIUS * 0.8,
            Math.cos(exitAngle - 0.3) * SPHERE_RADIUS * 0.7
        ),
        new THREE.Vector3(
            Math.sin(exitAngle) * SPHERE_RADIUS * 1.3,
            SPHERE_RADIUS * 0.9,
            Math.cos(exitAngle) * SPHERE_RADIUS * 1.3
        ),
        targetPos
    ];
    
    const lookAtPoints = [
        lookDir.clone().multiplyScalar(50),
        new THREE.Vector3(0, SPHERE_RADIUS * 0.5, 0),
        new THREE.Vector3(0, 0, 0),
        new THREE.Vector3(0, 0, 0),
        new THREE.Vector3(0, 0, 0),
        new THREE.Vector3(0, 0, 0)
    ];
    
    return {
        path: new THREE.CatmullRomCurve3(points),
        lookAt: lookAtPoints
    };
}

function interpolateLookAt(points, t) {
    const segments = points.length - 1;
    const segmentT = t * segments;
    const segmentIndex = Math.min(Math.floor(segmentT), segments - 1);
    const localT = segmentT - segmentIndex;
    
    const p1 = points[segmentIndex];
    const p2 = points[segmentIndex + 1];
    
    return new THREE.Vector3().lerpVectors(p1, p2, Easing.easeInOutQuad(localT));
}

function showTransitionOverlay(show) {
    const overlay = document.getElementById('transition-overlay');
    const skipHint = document.getElementById('skip-hint');
    
    overlay.style.display = show ? 'block' : 'none';
    
    if (show) {
        setTimeout(() => {
            skipHint.style.opacity = '1';
            canSkipTransition = true;
        }, 400);
    } else {
        skipHint.style.opacity = '0';
        canSkipTransition = false;
    }
}

function updateVignette(intensity) {
    const vignette = document.getElementById('vignette');
    const size = 35 + (1 - intensity) * 25;
    vignette.style.background = `radial-gradient(ellipse at center, 
        transparent 0%, 
        transparent ${size}%, 
        rgba(0,0,0,${intensity * 0.7}) 100%)`;
    vignette.style.opacity = intensity > 0 ? '1' : '0';
}

function updateSpeedLines(intensity, direction = 1) {
    const container = document.getElementById('speed-lines');
    container.style.opacity = intensity;
    
    if (intensity > 0.1 && container.children.length < 25) {
        for (let i = 0; i < 4; i++) {
            const line = document.createElement('div');
            line.className = 'speed-line';
            
            const angle = (Math.random() - 0.5) * 50;
            const startX = 50 + (Math.random() - 0.5) * 50;
            const startY = 50 + (Math.random() - 0.5) * 50;
            const length = 40 + Math.random() * 80;
            
            line.style.left = `${startX}%`;
            line.style.top = `${startY}%`;
            line.style.width = `${length}px`;
            line.style.transform = `rotate(${angle + (direction > 0 ? 0 : 180)}deg)`;
            line.style.opacity = Math.random() * 0.4 + 0.2;
            
            container.appendChild(line);
            
            setTimeout(() => {
                if (line.parentNode) line.parentNode.removeChild(line);
            }, 150 + Math.random() * 250);
        }
    }
}



function startTransition(type) {
    if (isTransitioning) return;
    
    isTransitioning = true;
    transitionType = type;
    transitionStartTime = Date.now();
    transitionProgress = 0;
    
    controls.enabled = false;
    document.getElementById('cam-in').disabled = true;
    document.getElementById('cam-out').disabled = true;
    
    if (type === 'toInside') {
        const pathData = createPathToInside();
        transitionPath = pathData.path;
        transitionLookAtPath = pathData.lookAt;
        transitionFinalTheta = pathData.finalTheta;
        transitionDuration = 3000;
    } else {
        const pathData = createPathToOutside();
        transitionPath = pathData.path;
        transitionLookAtPath = pathData.lookAt;
        transitionDuration = 2800;
    }
    
    createTransitionParticles();
    groups.transitionParticles.visible = true;
    showTransitionOverlay(true);
}

function skipTransition() {
    if (!isTransitioning || !canSkipTransition) return;
    transitionProgress = 0.95;
}

function updateTransition() {
    if (!isTransitioning) return;
    
    const elapsed = Date.now() - transitionStartTime;
    transitionProgress = Math.min(elapsed / transitionDuration, 1);
    
    const easedProgress = Easing.flightEase(transitionProgress);
    
    const position = transitionPath.getPoint(easedProgress);
    const lookAt = interpolateLookAt(transitionLookAtPath, easedProgress);
    
    camera.position.copy(position);
    camera.lookAt(lookAt);
    
    // –ü–ª–∞–≤–Ω—ã–µ —ç—Ñ—Ñ–µ–∫—Ç—ã –±–µ–∑ —Ç–µ–∫—Å—Ç–∞
    let vignetteIntensity = 0;
    let speedIntensity = 0;
    
    if (transitionProgress < 0.15) {
        // –°—Ç–∞—Ä—Ç
        const t = transitionProgress / 0.15;
        vignetteIntensity = t * 0.3;
        speedIntensity = t * 0.4;
    } else if (transitionProgress < 0.5) {
        // –†–∞–∑–≥–æ–Ω
        const t = (transitionProgress - 0.15) / 0.35;
        vignetteIntensity = 0.3 + t * 0.3;
        speedIntensity = 0.4 + t * 0.4;
    } else if (transitionProgress < 0.85) {
        // –û—Å–Ω–æ–≤–Ω–æ–π –ø–æ–ª—ë—Ç
        const t = (transitionProgress - 0.5) / 0.35;
        vignetteIntensity = 0.6 - t * 0.3;
        speedIntensity = 0.8 - t * 0.4;
    } else {
        // –ó–∞–º–µ–¥–ª–µ–Ω–∏–µ
        const t = (transitionProgress - 0.85) / 0.15;
        vignetteIntensity = 0.3 * (1 - t);
        speedIntensity = 0.4 * (1 - t);
    }
    
    updateVignette(vignetteIntensity);
    updateSpeedLines(speedIntensity, transitionType === 'toInside' ? 1 : -1);
    
    const particleSpeed = speedIntensity * 1.5;
    transitionParticles.forEach(p => {
        p.material.opacity = speedIntensity * 0.5;
    });
    updateTransitionParticles(particleSpeed, transitionType === 'toInside' ? 1 : -1);
    
    // FOV —ç—Ñ—Ñ–µ–∫—Ç
    const baseFov = 60;
    const fovBoost = speedIntensity * 12;
    camera.fov = baseFov + fovBoost;
    camera.updateProjectionMatrix();
    
    if (transitionProgress >= 1) {
        finishTransition();
    }
}

function finishTransition() {
    isTransitioning = false;
    
    showTransitionOverlay(false);
    groups.transitionParticles.visible = false;
    document.getElementById('speed-lines').innerHTML = '';
    
    if (transitionType === 'toInside') {
        isInsideMode = true;
        settings.camMode = 'in';
        currentFov = 60;
        camera.fov = currentFov;
        camera.updateProjectionMatrix();
        camera.position.set(0, 0.5, 0);
        
        // –ò—Å–ø–æ–ª—å–∑—É–µ–º –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –∏–∑ —Ç—Ä–∞–µ–∫—Ç–æ—Ä–∏–∏
        spherical = { phi: Math.PI / 2, theta: transitionFinalTheta };
        updateInsideCamera();
        
        if (landscapeMesh) landscapeMesh.visible = settings.ground;
        
        document.getElementById('cam-in').classList.add('active');
        document.getElementById('cam-out').classList.remove('active');
    } else {
        isInsideMode = false;
        settings.camMode = 'out';
        camera.fov = 60;
        camera.updateProjectionMatrix();
        camera.position.set(0, 50, 100);
        controls.target.set(0, 0, 0);
        controls.minDistance = 20;
        controls.maxDistance = 300;
        controls.enabled = true;
        controls.update();
        
        if (landscapeMesh) landscapeMesh.visible = false;
        
        document.getElementById('cam-in').classList.remove('active');
        document.getElementById('cam-out').classList.add('active');
    }
    
    document.getElementById('cam-in').disabled = false;
    document.getElementById('cam-out').disabled = false;
    
    saveSettings();
    applyVisibilitySettings();
}

document.addEventListener('click', (e) => {
    if (isTransitioning && canSkipTransition) {
        if (!e.target.closest('#controls-panel') && 
            !e.target.closest('#constellation-panel') &&
            !e.target.closest('#search-container')) {
            skipTransition();
        }
    }
});

document.addEventListener('keydown', (e) => {
    if (isTransitioning && canSkipTransition && (e.key === 'Escape' || e.key === ' ')) {
        skipTransition();
    }
});

function getSkyColors(sunAltitude) {
    const alt = Math.max(-18, Math.min(45, sunAltitude));
    
    const night = { bg: 0x000814, top: 0x000510, horizon: 0x0a1628 };
    const astroTwilight = { bg: 0x0a1030, top: 0x050820, horizon: 0x1a2848 };
    const nauticalTwilight = { bg: 0x152050, top: 0x0a1535, horizon: 0x2a3a68 };
    const civilTwilight = { bg: 0x2a3a70, top: 0x152050, horizon: 0x4a5a88 };
    const sunrise = { bg: 0x3a4a80, top: 0x203060, horizon: 0x6a5a70 };
    const day = { bg: 0x1a3a6a, top: 0x0a2545, horizon: 0x4a6a90 };
    
    let colors, t;
    
    if (alt < -18) colors = night;
    else if (alt < -12) { t = (alt + 18) / 6; colors = lerpColors(night, astroTwilight, t); }
    else if (alt < -6) { t = (alt + 12) / 6; colors = lerpColors(astroTwilight, nauticalTwilight, t); }
    else if (alt < 0) { t = (alt + 6) / 6; colors = lerpColors(nauticalTwilight, civilTwilight, t); }
    else if (alt < 10) { t = alt / 10; colors = lerpColors(civilTwilight, sunrise, t); }
    else if (alt < 30) { t = (alt - 10) / 20; colors = lerpColors(sunrise, day, t); }
    else colors = day;
    
    return colors;
}

function lerpColors(c1, c2, t) {
    t = Math.max(0, Math.min(1, t));
    return {
        bg: lerpColor(c1.bg, c2.bg, t),
        top: lerpColor(c1.top, c2.top, t),
        horizon: lerpColor(c1.horizon, c2.horizon, t)
    };
}

function lerpColor(color1, color2, t) {
    const r1 = (color1 >> 16) & 255, g1 = (color1 >> 8) & 255, b1 = color1 & 255;
    const r2 = (color2 >> 16) & 255, g2 = (color2 >> 8) & 255, b2 = color2 & 255;
    const r = Math.round(r1 + (r2 - r1) * t);
    const g = Math.round(g1 + (g2 - g1) * t);
    const b = Math.round(b1 + (b2 - b1) * t);
    return (r << 16) | (g << 8) | b;
}

function updateSkyBackground(sunAltitude) {
    const colors = getSkyColors(sunAltitude);
    scene.background = new THREE.Color(colors.bg);
    const bgHex = '#' + colors.bg.toString(16).padStart(6, '0');
    const topHex = '#' + colors.top.toString(16).padStart(6, '0');
    document.body.style.background = `radial-gradient(ellipse at center, ${bgHex} 0%, ${topHex} 100%)`;
}

function init() {
    if (typeof CONSTELLATIONS === 'undefined') { alert("–û—à–∏–±–∫–∞: constellations.js –Ω–µ –Ω–∞–π–¥–µ–Ω!"); return; }
    loadSettings();

    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x000814);

    camera = new THREE.PerspectiveCamera(currentFov, window.innerWidth / window.innerHeight, 0.1, 1000);
    
    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.5;
    document.body.appendChild(renderer.domElement);

    controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;

    raycaster = new THREE.Raycaster();
    raycaster.params.Sprite = { threshold: 1.5 };
    mouse = new THREE.Vector2();

    scene.add(new THREE.AmbientLight(0xffffff, 1.2));
    scene.add(new THREE.HemisphereLight(0x8888ff, 0x444422, 0.6));
    const dir = new THREE.DirectionalLight(0xffffff, 0.8);
    dir.position.set(50, 100, 50);
    scene.add(dir);

    createBackgroundStars();
    buildGrid();
    buildZenithNadir();
    buildGround();
    Object.values(groups).forEach(g => scene.add(g));
    
    groups.transitionParticles.visible = false;

    applyCameraModeInstant();
    setupCustomControls();
    setupTooltip();
    setupUniversalSearch();

    window.addEventListener('resize', onResize);
    setupUI();

    if(navigator.geolocation) {
        navigator.geolocation.getCurrentPosition(
            pos => { 
                observerLat = pos.coords.latitude; 
                observerLon = pos.coords.longitude; 
                getLocationName(observerLat, observerLon);
                updateSky(); 
            },
            () => updateSky()
        );
    } else updateSky();

    setInterval(updateSky, 60000); 
    updateISS();
    setInterval(updateISS, 5000); 
    updateClock(); 
    setInterval(updateClock, 1000);

    animate();
    setTimeout(() => { 
        document.getElementById('loading').style.opacity = '0'; 
        setTimeout(() => document.getElementById('loading').style.display = 'none', 500); 
    }, 500);
}

function buildZenithNadir() {
    const zenith = createCardinalSprite('–ó–ï–ù–ò–¢', '#00ffff', true);
    zenith.position.set(0, SPHERE_RADIUS * 1.02, 0);
    groups.zenithNadir.add(zenith);
    
    const nadir = createCardinalSprite('–ù–ê–î–ò–†', '#ff6666', true);
    nadir.position.set(0, -SPHERE_RADIUS * 1.02, 0);
    groups.zenithNadir.add(nadir);
}

function setupUniversalSearch() {
    const input = document.getElementById('universal-search');
    const results = document.getElementById('search-results');
    
    input.addEventListener('input', (e) => {
        const val = e.target.value.trim().toLowerCase();
        if (val.length < 2) { results.style.display = 'none'; return; }
        clearTimeout(searchTimeout);
        searchTimeout = setTimeout(() => performSearch(val, false), 300);
    });
    
    input.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') {
            const val = input.value.trim().toLowerCase();
            if (val.length >= 2) performSearch(val, true);
        }
    });
    
    input.addEventListener('focus', () => {
        if (input.value.length >= 2) results.style.display = 'block';
    });
    
    document.addEventListener('click', (e) => {
        if (!e.target.closest('#search-container')) results.style.display = 'none';
    });
}

async function performSearch(query, includeCity = false) {
    const results = document.getElementById('search-results');
    let html = '';
    
    const matchedConstellations = [];
    Object.keys(CONSTELLATIONS).forEach(name => {
        const data = CONSTELLATIONS[name];
        if (name.toLowerCase().includes(query) || 
            data.latin.toLowerCase().includes(query) ||
            (data.abbr && data.abbr.toLowerCase().includes(query))) {
            matchedConstellations.push({ name, latin: data.latin, visible: constellationVisibility[name] });
        }
    });
    
    if (matchedConstellations.length > 0) {
        html += `<div class="search-group-title">‚ú® –°–æ–∑–≤–µ–∑–¥–∏—è</div>`;
        matchedConstellations.forEach(c => {
            const visIcon = c.visible ? '‚Üë' : '‚Üì';
            const visColor = c.visible ? '#88ff88' : '#ff8888';
            html += `<div class="search-item" data-type="constellation" data-name="${c.name}">
                <span><span class="search-item-icon">‚ú®</span>${c.name}</span>
                <span class="search-item-info">${c.latin} <span style="color:${visColor}">${visIcon}</span></span>
            </div>`;
        });
    }
    
    const matchedStars = [];
    Object.keys(CONSTELLATIONS).forEach(constName => {
        CONSTELLATIONS[constName].stars.forEach(star => {
            if (star.name.toLowerCase().includes(query)) {
                matchedStars.push({ name: star.name, constellation: constName, mag: star.mag, bayer: star.bayer });
            }
        });
    });
    
    if (matchedStars.length > 0) {
        html += `<div class="search-group-title">‚≠ê –ó–≤—ë–∑–¥—ã</div>`;
        matchedStars.slice(0, 10).forEach(s => {
            html += `<div class="search-item" data-type="star" data-name="${s.name}" data-constellation="${s.constellation}">
                <span><span class="search-item-icon">‚≠ê</span>${s.name} ${s.bayer || ''}</span>
                <span class="search-item-info">${s.constellation}, ${s.mag.toFixed(2)}m</span>
            </div>`;
        });
    }
    
    const matchedPlanets = [];
    PLANETS.forEach(p => {
        const ruName = PLANET_NAMES_RU[p];
        if (p.toLowerCase().includes(query) || ruName.toLowerCase().includes(query)) {
            matchedPlanets.push({ en: p, ru: ruName, mag: PLANET_MAG[p] });
        }
    });
    if ('—Å–æ–ª–Ω—Ü–µ'.includes(query) || 'sun'.includes(query)) matchedPlanets.push({ en: 'Sun', ru: '–°–æ–ª–Ω—Ü–µ', mag: -26.7 });
    if ('–ª—É–Ω–∞'.includes(query) || 'moon'.includes(query)) matchedPlanets.push({ en: 'Moon', ru: '–õ—É–Ω–∞', mag: -12.7 });
    
    if (matchedPlanets.length > 0) {
        html += `<div class="search-group-title">ü™ê –ü–ª–∞–Ω–µ—Ç—ã –∏ —Å–≤–µ—Ç–∏–ª–∞</div>`;
        matchedPlanets.forEach(p => {
            const icon = p.en === 'Sun' ? '‚òÄÔ∏è' : p.en === 'Moon' ? 'üåô' : 'ü™ê';
            html += `<div class="search-item" data-type="planet" data-name="${p.en}">
                <span><span class="search-item-icon">${icon}</span>${p.ru}</span>
                <span class="search-item-info">${p.mag.toFixed(1)}m</span>
            </div>`;
        });
    }
    
    if (includeCity) {
        try {
            const response = await fetch(`https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(query)}&limit=5&accept-language=ru`);
            const cities = await response.json();
            if (cities.length > 0) {
                html += `<div class="search-group-title">üìç –ì–æ—Ä–æ–¥–∞ –∏ –º–µ—Å—Ç–∞</div>`;
                cities.forEach(city => {
                    html += `<div class="search-item" data-type="city" data-lat="${city.lat}" data-lon="${city.lon}" data-name="${city.display_name.split(',')[0]}">
                        <span><span class="search-item-icon">üìç</span>${city.display_name.split(',')[0]}</span>
                        <span class="search-item-info">${parseFloat(city.lat).toFixed(2)}¬∞, ${parseFloat(city.lon).toFixed(2)}¬∞</span>
                    </div>`;
                });
            }
        } catch (e) {}
    } else {
        html += `<div class="search-group-title" style="opacity: 0.5;">üìç –ù–∞–∂–º–∏—Ç–µ Enter –¥–ª—è –ø–æ–∏—Å–∫–∞ –≥–æ—Ä–æ–¥–æ–≤</div>`;
    }
    
    if (html) {
        results.innerHTML = html;
        results.style.display = 'block';
        results.querySelectorAll('.search-item').forEach(item => {
            item.addEventListener('click', () => handleSearchSelect(item));
        });
    } else {
        results.innerHTML = '<div style="padding: 15px; text-align: center; opacity: 0.5;">–ù–∏—á–µ–≥–æ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ</div>';
        results.style.display = 'block';
    }
}

function handleSearchSelect(item) {
    const type = item.dataset.type;
    const name = item.dataset.name;
    const input = document.getElementById('universal-search');
    const results = document.getElementById('search-results');
    
    results.style.display = 'none';
    
    switch(type) {
        case 'constellation':
            input.value = name;
            selectConstellation(name);
            break;
        case 'star':
            input.value = name;
            highlightedStarName = name;
            navigateToStar(name, true);
            break;
        case 'planet':
            input.value = PLANET_NAMES_RU[name] || name;
            navigateToPosition(planetPositions[name]);
            break;
        case 'city':
            const lat = parseFloat(item.dataset.lat);
            const lon = parseFloat(item.dataset.lon);
            input.value = name;
            setLocation(lat, lon, name);
            break;
    }
}

function navigateToStar(starName, withZoom = false) {
    const pos = starPositions[starName];
    if (!pos) return;
    
    highlightedStarName = starName;

    allStarLabels.forEach(label => {
        if (label.userData.starName === starName) {
            label.visible = true;
            label.scale.set(label.userData.baseScale?.x * 1.5 || label.scale.x, label.userData.baseScale?.y * 1.5 || label.scale.y, 1);
        } else {
            if(label.userData.baseScale) label.scale.copy(label.userData.baseScale);
        }
    });

    navigateToPosition(pos, () => {
        if (withZoom && isInsideMode) {
            const targetFov = 20;
            const startFov = currentFov;
            const duration = 800;
            const startTime = Date.now();
            
            const zoomAnim = () => {
                const elapsed = Date.now() - startTime;
                const t = Math.min(elapsed / duration, 1);
                const ease = 1 - Math.pow(1 - t, 3);
                
                currentFov = startFov + (targetFov - startFov) * ease;
                camera.fov = currentFov;
                camera.updateProjectionMatrix();
                
                if (t < 1) requestAnimationFrame(zoomAnim);
            };
            zoomAnim();
        }
    });
    
    const indicator = document.getElementById('mode-indicator');
    indicator.innerHTML = `‚≠ê ${starName}`;
    indicator.classList.add('visible');
    setTimeout(() => indicator.classList.remove('visible'), 3000);
}

function navigateToPosition(pos, onComplete = null) {
    if (!pos || isTransitioning) return;
    
    const normalized = pos.clone().normalize();
    const targetTheta = Math.atan2(normalized.x, normalized.z);
    const targetPhi = Math.acos(Math.max(-1, Math.min(1, normalized.y)));
    
    if (isInsideMode) {
        animateCameraInside(targetTheta, targetPhi, onComplete);
    } else {
        const targetCamPos = normalized.clone().multiplyScalar(100);
        animateCameraOutside(targetCamPos, onComplete);
    }
}

function animateCameraInside(targetTheta, targetPhi, onComplete = null) {
    const startTheta = spherical.theta;
    const startPhi = spherical.phi;
    
    let dTheta = targetTheta - startTheta;
    while (dTheta > Math.PI) dTheta -= 2 * Math.PI;
    while (dTheta < -Math.PI) dTheta += 2 * Math.PI;
    
    const duration = 1000;
    const startTime = Date.now();
    
    cameraAnimation = () => {
        const elapsed = Date.now() - startTime;
        const t = Math.min(elapsed / duration, 1);
        const easeT = 1 - Math.pow(1 - t, 3);
        
        spherical.theta = startTheta + dTheta * easeT;
        spherical.phi = startPhi + (targetPhi - startPhi) * easeT;
        
        const minPhi = 0.05;
        const maxPhi = settings.ground ? (Math.PI / 2 - 0.05) : (Math.PI - 0.05);
        spherical.phi = Math.max(minPhi, Math.min(maxPhi, spherical.phi));
        
        updateInsideCamera();
        
        if (t >= 1) {
            cameraAnimation = null;
            if (onComplete) onComplete();
        }
    };
}

function animateCameraOutside(targetPos, onComplete = null) {
    const startPos = camera.position.clone();
    const duration = 1000;
    const startTime = Date.now();
    
    cameraAnimation = () => {
        const elapsed = Date.now() - startTime;
        const t = Math.min(elapsed / duration, 1);
        const easeT = 1 - Math.pow(1 - t, 3);
        camera.position.lerpVectors(startPos, targetPos, easeT);
        controls.target.set(0, 0, 0);
        controls.update();
        if (t >= 1) {
            cameraAnimation = null;
            if (onComplete) onComplete();
        }
    };
}

function animateConstellationHighlight(constName) {
    const data = constellationMap[constName];
    if (!data) return;
    
    const duration = 2000;
    const startTime = Date.now();
    
    constellationAnimation = () => {
        const elapsed = Date.now() - startTime;
        const t = elapsed / duration;
        
        if (t >= 1) {
            constellationAnimation = null;
            data.linesGroup.children.forEach(l => {
                if (l.material) {
                    l.material.opacity = 1.0;
                    l.material.color.setHex(0x00ffff);
                }
            });
            return;
        }
        
        const pulse = Math.sin(t * Math.PI * 4) * 0.5 + 0.5;
        const color = new THREE.Color();
        color.setHSL(0.5 + pulse * 0.1, 1, 0.5 + pulse * 0.3);
        
        data.linesGroup.children.forEach(l => {
            if (l.material) {
                l.material.opacity = 0.7 + pulse * 0.3;
                l.material.color.copy(color);
            }
        });
    };
}

function setLocation(lat, lon, name) {
    observerLat = lat;
    observerLon = lon;
    locationName = name;
    document.getElementById('location-name').textContent = name;
    updateSky();
    
    const indicator = document.getElementById('mode-indicator');
    indicator.textContent = `üìç ${name}`;
    indicator.classList.add('visible');
    setTimeout(() => indicator.classList.remove('visible'), 3000);
}

async function getLocationName(lat, lon) {
    try {
        const response = await fetch(`https://nominatim.openstreetmap.org/reverse?lat=${lat}&lon=${lon}&format=json&accept-language=ru`);
        const data = await response.json();
        if (data.address) {
            locationName = data.address.city || data.address.town || data.address.village || data.address.county || data.address.state || '';
            const country = data.address.country || '';
            if (locationName && country) locationName = `${locationName}, ${country}`;
            else if (country) locationName = country;
        }
        document.getElementById('location-name').textContent = locationName || '–ú–µ—Å—Ç–æ–ø–æ–ª–æ–∂–µ–Ω–∏–µ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–æ';
    } catch (e) {
        document.getElementById('location-name').textContent = '–ú–µ—Å—Ç–æ–ø–æ–ª–æ–∂–µ–Ω–∏–µ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–æ';
    }
}

function setupTooltip() {
    const canvas = renderer.domElement;
    const tooltip = document.getElementById('tooltip');
    
    canvas.addEventListener('mousemove', (e) => {
        if (isTransitioning) return;
        
        mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
        
        raycaster.setFromCamera(mouse, camera);
        const intersects = raycaster.intersectObjects(interactiveObjects, false);
        
        if (intersects.length > 0) {
            const obj = intersects[0].object;
            if (obj.userData && obj.userData.type) {
                hoveredObject = obj;
                showTooltip(e.clientX, e.clientY, obj.userData);
                canvas.style.cursor = 'pointer';
                return;
            }
        }
        hoveredObject = null;
        tooltip.style.display = 'none';
        canvas.style.cursor = isMouseDown ? 'grabbing' : 'grab';
    });
    
    canvas.addEventListener('mouseleave', () => { tooltip.style.display = 'none'; hoveredObject = null; });
}

function showTooltip(x, y, data) {
    const tooltip = document.getElementById('tooltip');
    let icon = '‚≠ê', typeText = '–ó–≤–µ–∑–¥–∞', extraInfo = '';
    
    if (data.type === 'star') {
        icon = data.magnitude < 1 ? 'üåü' : '‚≠ê';
        extraInfo = `<div class="tooltip-row"><span class="tooltip-label">–ó–≤. –≤–µ–ª–∏—á–∏–Ω–∞:</span><span class="tooltip-value">${data.magnitude.toFixed(2)}m</span></div>
            <div class="tooltip-row"><span class="tooltip-label">RA:</span><span class="tooltip-value">${data.ra?.toFixed(2) || '‚Äî'}h</span></div>
            <div class="tooltip-row"><span class="tooltip-label">Dec:</span><span class="tooltip-value">${data.dec?.toFixed(2) || '‚Äî'}¬∞</span></div>`;
        if (data.constellation) extraInfo += `<div class="tooltip-constellation">–°–æ–∑–≤–µ–∑–¥–∏–µ: ${data.constellation}</div>`;
    } else if (data.type === 'planet') {
        icon = 'ü™ê'; typeText = '–ü–ª–∞–Ω–µ—Ç–∞';
        extraInfo = `<div class="tooltip-row"><span class="tooltip-label">–ó–≤. –≤–µ–ª–∏—á–∏–Ω–∞:</span><span class="tooltip-value">${data.magnitude?.toFixed(1) || '‚Äî'}m</span></div>
            <div class="tooltip-row"><span class="tooltip-label">–ê–∑–∏–º—É—Ç:</span><span class="tooltip-value">${data.azimuth?.toFixed(1) || '‚Äî'}¬∞</span></div>
            <div class="tooltip-row"><span class="tooltip-label">–í—ã—Å–æ—Ç–∞:</span><span class="tooltip-value">${data.altitude?.toFixed(1) || '‚Äî'}¬∞</span></div>`;
    } else if (data.type === 'sun') {
        icon = '‚òÄÔ∏è'; typeText = '–ó–≤–µ–∑–¥–∞ (–Ω–∞—à–∞)';
        extraInfo = `<div class="tooltip-row"><span class="tooltip-label">–ó–≤. –≤–µ–ª–∏—á–∏–Ω–∞:</span><span class="tooltip-value">-26.7m</span></div>
            <div class="tooltip-row"><span class="tooltip-label">–ê–∑–∏–º—É—Ç:</span><span class="tooltip-value">${data.azimuth?.toFixed(1)}¬∞</span></div>
            <div class="tooltip-row"><span class="tooltip-label">–í—ã—Å–æ—Ç–∞:</span><span class="tooltip-value">${data.altitude?.toFixed(1)}¬∞</span></div>`;
    } else if (data.type === 'moon') {
        icon = 'üåô'; typeText = '–°–ø—É—Ç–Ω–∏–∫ –ó–µ–º–ª–∏';
        extraInfo = `<div class="tooltip-row"><span class="tooltip-label">–ó–≤. –≤–µ–ª–∏—á–∏–Ω–∞:</span><span class="tooltip-value">~-12.7m</span></div>
            <div class="tooltip-row"><span class="tooltip-label">–ê–∑–∏–º—É—Ç:</span><span class="tooltip-value">${data.azimuth?.toFixed(1)}¬∞</span></div>
            <div class="tooltip-row"><span class="tooltip-label">–í—ã—Å–æ—Ç–∞:</span><span class="tooltip-value">${data.altitude?.toFixed(1)}¬∞</span></div>`;
    } else if (data.type === 'iss') {
        icon = 'üõ∞Ô∏è'; typeText = '–ö–æ—Å–º–∏—á–µ—Å–∫–∞—è —Å—Ç–∞–Ω—Ü–∏—è';
        extraInfo = `<div class="tooltip-row"><span class="tooltip-label">–ê–∑–∏–º—É—Ç:</span><span class="tooltip-value">${data.azimuth?.toFixed(1)}¬∞</span></div>
            <div class="tooltip-row"><span class="tooltip-label">–í—ã—Å–æ—Ç–∞:</span><span class="tooltip-value">${data.altitude?.toFixed(1)}¬∞</span></div>
            <div class="tooltip-row"><span class="tooltip-label">–û—Ä–±–∏—Ç–∞:</span><span class="tooltip-value">~408 –∫–º</span></div>`;
    }
    
    tooltip.innerHTML = `<div class="tooltip-header"><span class="tooltip-icon">${icon}</span>
        <div><div class="tooltip-name">${data.name || '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ'}</div><div class="tooltip-type">${typeText}</div></div>
        </div>${extraInfo}`;
    
    let left = x + 15, top = y + 15;
    if (left + 250 > window.innerWidth) left = x - 260;
    if (top + 200 > window.innerHeight) top = y - 200;
    tooltip.style.left = left + 'px';
    tooltip.style.top = top + 'px';
    tooltip.style.display = 'block';
}

function setupCustomControls() {
    const canvas = renderer.domElement;
    
    canvas.addEventListener('mousedown', (e) => {
        if (!isInsideMode || isTransitioning) return;
        isMouseDown = true;
        lastMouseX = e.clientX;
        lastMouseY = e.clientY;
        canvas.style.cursor = 'grabbing';
    });
    
    canvas.addEventListener('mousemove', (e) => {
        if (!isInsideMode || !isMouseDown || isTransitioning) return;
        
        const deltaX = e.clientX - lastMouseX;
        const deltaY = e.clientY - lastMouseY;
        
        spherical.theta -= deltaX * 0.004;
        spherical.phi += deltaY * 0.004;
        
        const minPhi = 0.05;
        const maxPhi = settings.ground ? (Math.PI / 2 - 0.05) : (Math.PI - 0.05);
        spherical.phi = Math.max(minPhi, Math.min(maxPhi, spherical.phi));
        
        lastMouseX = e.clientX;
        lastMouseY = e.clientY;
        updateInsideCamera();
    });
    
    canvas.addEventListener('mouseup', () => { isMouseDown = false; canvas.style.cursor = 'grab'; });
    canvas.addEventListener('mouseleave', () => { isMouseDown = false; });
    
    canvas.addEventListener('wheel', (e) => {
        if (!isInsideMode || isTransitioning) return;
        e.preventDefault();
        
        const delta = e.deltaY > 0 ? 3 : -3;
        currentFov = Math.max(MIN_FOV, Math.min(MAX_FOV, currentFov + delta));
        camera.fov = currentFov;
        camera.updateProjectionMatrix();
        
        const indicator = document.getElementById('zoom-indicator');
        indicator.textContent = `üî≠ Zoom: ${currentFov.toFixed(0)}¬∞`;
        indicator.classList.add('visible');
        clearTimeout(zoomTimeout);
        zoomTimeout = setTimeout(() => indicator.classList.remove('visible'), 1500);
    }, { passive: false });
    
    let touchStartDist = 0;
    canvas.addEventListener('touchstart', (e) => {
        if (!isInsideMode || isTransitioning) return;
        if (e.touches.length === 1) {
            isMouseDown = true;
            lastMouseX = e.touches[0].clientX;
            lastMouseY = e.touches[0].clientY;
        } else if (e.touches.length === 2) {
            touchStartDist = Math.hypot(e.touches[0].clientX - e.touches[1].clientX, e.touches[0].clientY - e.touches[1].clientY);
        }
    });
    
    canvas.addEventListener('touchmove', (e) => {
        if (!isInsideMode || isTransitioning) return;
        e.preventDefault();
        if (e.touches.length === 1 && isMouseDown) {
            const deltaX = e.touches[0].clientX - lastMouseX;
            const deltaY = e.touches[0].clientY - lastMouseY;
            spherical.theta -= deltaX * 0.004;
            spherical.phi += deltaY * 0.004;
            const minPhi = 0.05;
            const maxPhi = settings.ground ? (Math.PI / 2 - 0.05) : (Math.PI - 0.05);
            spherical.phi = Math.max(minPhi, Math.min(maxPhi, spherical.phi));
            lastMouseX = e.touches[0].clientX;
            lastMouseY = e.touches[0].clientY;
            updateInsideCamera();
        } else if (e.touches.length === 2) {
            const dist = Math.hypot(e.touches[0].clientX - e.touches[1].clientX, e.touches[0].clientY - e.touches[1].clientY);
            const delta = (touchStartDist - dist) * 0.1;
            currentFov = Math.max(MIN_FOV, Math.min(MAX_FOV, currentFov + delta));
            camera.fov = currentFov;
            camera.updateProjectionMatrix();
            touchStartDist = dist;
        }
    }, { passive: false });
    
    canvas.addEventListener('touchend', () => { isMouseDown = false; });
}

function updateInsideCamera() {
    const x = Math.sin(spherical.phi) * Math.sin(spherical.theta);
    const y = Math.cos(spherical.phi);
    const z = Math.sin(spherical.phi) * Math.cos(spherical.theta);
    camera.position.set(0, 0.5, 0);
    camera.lookAt(x * 100, y * 100 + 0.5, z * 100);
}

function createBackgroundStars() {
    const geo = new THREE.BufferGeometry();
    const verts = [], colors = [];
    for (let i = 0; i < 5000; i++) {
        const theta = Math.random() * Math.PI * 2;
        const phi = Math.acos(2 * Math.random() - 1);
        const r = 180 + Math.random() * 120;
        verts.push(r * Math.sin(phi) * Math.cos(theta), r * Math.sin(phi) * Math.sin(theta), r * Math.cos(phi));
        const b = 0.3 + Math.random() * 0.5;
        colors.push(b, b, b * 1.1);
    }
    geo.setAttribute('position', new THREE.Float32BufferAttribute(verts, 3));
    geo.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
    scene.add(new THREE.Points(geo, new THREE.PointsMaterial({ size: 0.5, vertexColors: true, transparent: true, opacity: 0.8 })));
}

function applyCameraModeInstant() {
    const btnIn = document.getElementById('cam-in');
    const btnOut = document.getElementById('cam-out');

    if (settings.camMode === 'in') {
        isInsideMode = true;
        controls.enabled = false;
        currentFov = 60;
        camera.fov = currentFov;
        camera.updateProjectionMatrix();
        spherical = { phi: Math.PI / 2, theta: 0 };
        updateInsideCamera();
        if(landscapeMesh) landscapeMesh.visible = settings.ground;
        btnIn.classList.add('active');
        btnOut.classList.remove('active');
    } else {
        isInsideMode = false;
        controls.enabled = true;
        camera.fov = 60;
        camera.updateProjectionMatrix();
        camera.position.set(0, 50, 100);
        controls.target.set(0, 0, 0);
        controls.minDistance = 20;
        controls.maxDistance = 300;
        controls.minPolarAngle = 0.1;
        controls.maxPolarAngle = Math.PI - 0.1;
        controls.update();
        if(landscapeMesh) landscapeMesh.visible = false;
        btnIn.classList.remove('active');
        btnOut.classList.add('active');
    }
}

function createLandscapeTexture() {
    const canvas = document.createElement('canvas');
    canvas.width = 2048; canvas.height = 256;
    const ctx = canvas.getContext('2d');
    const grad = ctx.createLinearGradient(0, 0, 0, 256);
    grad.addColorStop(0, 'rgba(0,0,0,0)');
    grad.addColorStop(0.4, 'rgba(5,15,30,0.5)');
    grad.addColorStop(0.6, 'rgba(5,15,30,0.9)');
    grad.addColorStop(1, '#000000');
    ctx.fillStyle = grad;
    ctx.fillRect(0, 0, 2048, 256);
    ctx.fillStyle = '#000000';
    ctx.beginPath();
    ctx.moveTo(0, 256);
    for(let x = 0; x <= 2048; x += 3) {
        const hill = Math.sin(x * 0.003) * 35 + Math.sin(x * 0.008) * 20;
        const tree = Math.random() > 0.8 ? Math.random() * 20 : 0;
        ctx.lineTo(x, 155 + hill - tree);
    }
    ctx.lineTo(2048, 256); ctx.lineTo(0, 256); ctx.fill();
    const tex = new THREE.CanvasTexture(canvas);
    tex.wrapS = THREE.RepeatWrapping;
    tex.repeat.set(3, 1);
    return tex;
}

function buildGround() {
    const disk = new THREE.Mesh(new THREE.CircleGeometry(SPHERE_RADIUS * 1.1, 64), new THREE.MeshBasicMaterial({ color: 0x020810, transparent: true, opacity: 0.95, side: THREE.DoubleSide }));
    disk.rotation.x = -Math.PI / 2; disk.position.y = -0.5;
    groups.ground.add(disk);

    const grid = new THREE.PolarGridHelper(SPHERE_RADIUS, 12, 6, 64, 0x0066aa, 0x003366);
    grid.material.opacity = 0.25; grid.material.transparent = true;
    groups.ground.add(grid);

    const cyl = new THREE.Mesh(
        new THREE.CylinderGeometry(SPHERE_RADIUS * 0.99, SPHERE_RADIUS * 0.99, 15, 64, 1, true),
        new THREE.MeshBasicMaterial({ map: createLandscapeTexture(), transparent: true, side: THREE.BackSide, depthWrite: false })
    );
    cyl.position.y = 4; cyl.renderOrder = 10;
    landscapeMesh = cyl;
    groups.ground.add(cyl);

    groups.ground.add(new THREE.Mesh(
        new THREE.SphereGeometry(SPHERE_RADIUS * 0.98, 32, 16, 0, Math.PI * 2, Math.PI / 2, Math.PI / 2),
        new THREE.MeshBasicMaterial({ color: 0x000408, side: THREE.DoubleSide })
    ));
}

function sphericalToCartesian(r, az, alt) {
    const altR = THREE.MathUtils.degToRad(alt), azR = THREE.MathUtils.degToRad(az);
    return new THREE.Vector3(r * Math.cos(altR) * Math.sin(azR), r * Math.sin(altR), -r * Math.cos(altR) * Math.cos(azR));
}

function createStarLabelSprite(text) {
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    const fontSize = 36;
    ctx.font = `${fontSize}px Arial`;
    const w = ctx.measureText(text).width + 16;
    canvas.width = w; canvas.height = fontSize + 12;
    ctx.font = `${fontSize}px Arial`;
    ctx.textAlign = 'center'; 
    ctx.textBaseline = 'middle';
    ctx.shadowColor = 'rgba(0,0,0,0.9)';
    ctx.shadowBlur = 4;
    ctx.fillStyle = '#aaccff';
    ctx.fillText(text, w / 2, canvas.height / 2);
    const mat = new THREE.SpriteMaterial({ map: new THREE.CanvasTexture(canvas), depthTest: false, depthWrite: false, transparent: true });
    const sprite = new THREE.Sprite(mat);
    sprite.scale.set(w * 0.015, (fontSize + 12) * 0.015, 1);
    return sprite;
}

function createCardinalSprite(text, color, isZenithNadir = false) {
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    const fontSize = isZenithNadir ? 48 : 96;
    ctx.font = `bold ${fontSize}px Arial`;
    const w = ctx.measureText(text).width + 60;
    canvas.width = w; canvas.height = fontSize + 60;
    ctx.font = `bold ${fontSize}px Arial`;
    ctx.textAlign = 'center'; 
    ctx.textBaseline = 'middle';
    const glowColors = [color, color, '#ffffff'];
    const glowSizes = [30, 20, 10];
    glowColors.forEach((c, i) => {
        ctx.shadowColor = c;
        ctx.shadowBlur = glowSizes[i];
        ctx.fillStyle = i === glowColors.length - 1 ? '#ffffff' : color;
        ctx.fillText(text, w / 2, canvas.height / 2);
    });
    ctx.shadowBlur = 0;
    ctx.strokeStyle = 'rgba(0,0,0,0.5)';
    ctx.lineWidth = 2;
    ctx.strokeText(text, w / 2, canvas.height / 2);
    ctx.fillStyle = '#ffffff';
    ctx.fillText(text, w / 2, canvas.height / 2);
    const mat = new THREE.SpriteMaterial({ map: new THREE.CanvasTexture(canvas), depthTest: false, depthWrite: false, transparent: true, blending: THREE.AdditiveBlending });
    const sprite = new THREE.Sprite(mat);
    const scale = isZenithNadir ? 0.02 : 0.03;
    sprite.scale.set(w * scale, (fontSize + 60) * scale, 1);
    sprite.renderOrder = 999;
    return sprite;
}

function createGlowTextSprite(text, color, scale = 1) {
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    ctx.font = `bold 48px Arial`;
    const w = ctx.measureText(text).width + 30;
    canvas.width = w; canvas.height = 78;
    ctx.font = `bold 48px Arial`;
    ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
    ctx.shadowColor = color; ctx.shadowBlur = 15;
    ctx.fillStyle = color;
    ctx.fillText(text, w / 2, 39);
    ctx.fillText(text, w / 2, 39);
    const mat = new THREE.SpriteMaterial({ map: new THREE.CanvasTexture(canvas), depthTest: false, depthWrite: false, transparent: true });
    const sprite = new THREE.Sprite(mat);
    sprite.scale.set(0.018 * w * scale, 0.018 * 78 * scale, 1);
    return sprite;
}

function createStarSprite(color, magnitude) {
    const size = Math.max(0.3, Math.min(1.8, 2.0 - magnitude * 0.4));
    const canvas = document.createElement('canvas');
    canvas.width = 64; canvas.height = 64;
    const ctx = canvas.getContext('2d');
    const grad = ctx.createRadialGradient(32, 32, 0, 32, 32, 32);
    grad.addColorStop(0, '#ffffff');
    grad.addColorStop(0.1, color);
    grad.addColorStop(0.4, color);
    grad.addColorStop(0.7, 'rgba(100,150,255,0.1)');
    grad.addColorStop(1, 'rgba(0,0,0,0)');
    ctx.fillStyle = grad;
    ctx.fillRect(0, 0, 64, 64);
    if (magnitude < 2) {
        ctx.strokeStyle = 'rgba(255,255,255,0.3)';
        ctx.lineWidth = 1;
        for (let i = 0; i < 4; i++) {
            const a = (i * Math.PI) / 2;
            ctx.beginPath(); 
            ctx.moveTo(32 + Math.cos(a) * 4, 32 + Math.sin(a) * 4);
            ctx.lineTo(32 + Math.cos(a) * 16, 32 + Math.sin(a) * 16); 
            ctx.stroke();
        }
    }
    const mat = new THREE.SpriteMaterial({ map: new THREE.CanvasTexture(canvas), blending: THREE.AdditiveBlending, depthTest: true, depthWrite: false, transparent: true });
    const sprite = new THREE.Sprite(mat);
    sprite.scale.set(size, size, 1);
    return sprite;
}

function createPlanetSprite(magnitude) {
    const size = Math.max(0.3, Math.min(1.2, 1.5 - magnitude * 0.15));
    const canvas = document.createElement('canvas');
    canvas.width = 64; canvas.height = 64;
    const ctx = canvas.getContext('2d');
    const grad = ctx.createRadialGradient(32, 32, 2, 32, 32, 30);
    grad.addColorStop(0, '#ffffff');
    grad.addColorStop(0.2, '#ffeeaa');
    grad.addColorStop(0.4, 'rgba(255, 200, 0, 0.5)');
    grad.addColorStop(1, 'rgba(0,0,0,0)');
    ctx.fillStyle = grad;
    ctx.fillRect(0, 0, 64, 64);
    const mat = new THREE.SpriteMaterial({ map: new THREE.CanvasTexture(canvas), blending: THREE.AdditiveBlending, depthTest: true, depthWrite: false, transparent: true });
    const sprite = new THREE.Sprite(mat);
    sprite.scale.set(size, size, 1);
    return sprite;
}

function createISSModel() {
    const g = new THREE.Group();
    const bodyMat = new THREE.MeshPhongMaterial({ color: 0xffffff, emissive: 0x00ff88, emissiveIntensity: 1.0 });
    const solarMat = new THREE.MeshPhongMaterial({ color: 0x00ffaa, emissive: 0x00ff66, emissiveIntensity: 0.8, side: THREE.DoubleSide });
    const body = new THREE.Mesh(new THREE.CylinderGeometry(0.5, 0.5, 5, 12), bodyMat);
    body.rotation.z = Math.PI / 2; g.add(body);
    g.add(new THREE.Mesh(new THREE.BoxGeometry(0.8, 10, 0.5), bodyMat));
    [[1.8, 4], [-1.8, 4], [1.8, -4], [-1.8, -4]].forEach(([x, y]) => {
        const p = new THREE.Mesh(new THREE.BoxGeometry(2.5, 5, 0.1), solarMat);
        p.position.set(x, y, 0); g.add(p);
    });
    g.add(new THREE.PointLight(0x00ff88, 3, 30));
    g.scale.set(0.5, 0.5, 0.5);
    return g;
}

function buildGrid() {
    const r = SPHERE_RADIUS;
    const mat = new THREE.LineBasicMaterial({ color: 0x22aaff, transparent: true, opacity: 0.3 });

    for(let alt = -80; alt <= 80; alt += 20) {
        if (alt === 0) continue;
        const pts = []; 
        for(let az = 0; az <= 360; az += 5) pts.push(sphericalToCartesian(r, az, alt));
        groups.grid.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints(pts), mat));
    }
    for(let az = 0; az < 360; az += 30) {
        const pts = []; 
        for(let alt = -90; alt <= 90; alt += 5) pts.push(sphericalToCartesian(r, az, alt));
        groups.grid.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints(pts), mat));
    }

    const horizonGeo = new THREE.TorusGeometry(r, 0.25, 8, 128);
    horizonGeo.rotateX(Math.PI / 2); 
    groups.grid.add(new THREE.Mesh(horizonGeo, new THREE.MeshBasicMaterial({ color: 0x00e5ff, opacity: 0.8, transparent: true })));
    groups.grid.add(new THREE.Mesh(new THREE.SphereGeometry(0.6, 16, 16), new THREE.MeshBasicMaterial({ color: 0x00e5ff })));

    const crossMat = new THREE.LineBasicMaterial({ color: 0x00e5ff, opacity: 0.5, transparent: true });
    [0, 90, 180, 270].forEach(az => {
        groups.grid.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0, 0, 0), sphericalToCartesian(r, az, 0)]), crossMat));
    });

    [{ t: '–°', a: 0, c: '#ff4444' }, { t: '–í', a: 90, c: '#ffaa00' }, { t: '–Æ', a: 180, c: '#ff4444' }, { t: '–ó', a: 270, c: '#ffaa00' }].forEach(d => {
        const s = createCardinalSprite(d.t, d.c);
        s.position.copy(sphericalToCartesian(r * 1.05, d.a, 2));
        groups.cardinals.add(s);
    });
}

function updateClock() {
    const now = new Date();
    const offset = Math.round(observerLon / 15);
    const utcTime = now.getTime() + (now.getTimezoneOffset() * 60000);
    const localTime = new Date(utcTime + (offset * 3600000));
    const timeStr = localTime.toLocaleTimeString('ru-RU', { hour: '2-digit', minute: '2-digit', second: '2-digit' });
    const sign = offset >= 0 ? '+' : '';
    const el = document.getElementById('time-data');
    if (el) el.innerHTML = `${timeStr}<div style="font-size: 10px; color: rgba(255,255,255,0.5); font-weight: 400; line-height: 1.2; margin-top: -2px;">–ì–µ–æ. –≤—Ä–µ–º—è (UTC${sign}${offset})</div>`;
}

function updateSky() {
    const now = new Date();
    document.getElementById('loc-data').innerText = `${observerLat.toFixed(2)}¬∞ / ${observerLon.toFixed(2)}¬∞`;

    const observer = new Astronomy.Observer(observerLat, observerLon, 0);

    interactiveObjects.length = 0;
    allStarLabels.length = 0;
    for (const key in starPositions) delete starPositions[key];
    for (const key in planetPositions) delete planetPositions[key];
    for (const key in constellationVisibility) delete constellationVisibility[key];
    
    ['stars', 'starLabels', 'constellations', 'planets', 'trajectories', 'sunMoon'].forEach(k => {
        const g = groups[k];
        while(g.children.length) { 
            const o = g.children[0]; g.remove(o); 
            if(o.geometry) o.geometry.dispose(); 
            if(o.material) { if(o.material.map) o.material.map.dispose(); o.material.dispose(); }
        }
    });
    for (const key in constellationMap) delete constellationMap[key];

    const starPosCache = {};

    Object.keys(CONSTELLATIONS).forEach(cName => {
        const cData = CONSTELLATIONS[cName];
        const cLines = new THREE.Group();
        const cLabels = new THREE.Group();
        const cStarLabelsGroup = new THREE.Group();
        let starCount = 0;
        let mainStarPos = null;
        let maxAltitude = -90;

        cData.stars.forEach((star, idx) => {
            const hor = Astronomy.Horizon(now, observer, star.ra, star.dec, 'normal');
            const pos = sphericalToCartesian(SPHERE_RADIUS, hor.azimuth, hor.altitude);
            starPosCache[star.name] = pos;
            starPositions[star.name] = pos.clone();
            if (idx === 0) mainStarPos = pos.clone();
            if (hor.altitude > maxAltitude) maxAltitude = hor.altitude;
            
            const col = star.mag < 1 ? '#ffffee' : star.mag < 2 ? '#ffffff' : '#ddeeff';
            const sprite = createStarSprite(col, star.mag);
            sprite.position.copy(pos);
            sprite.userData = { type: 'star', name: star.name, magnitude: star.mag, ra: star.ra, dec: star.dec, constellation: cName };
            groups.stars.add(sprite);
            interactiveObjects.push(sprite);

            const label = createStarLabelSprite(star.name);
            const dir = pos.clone().normalize();
            const up = new THREE.Vector3(0, 1, 0);
            const right = new THREE.Vector3().crossVectors(up, dir).normalize();
            if (right.length() < 0.1) right.set(1, 0, 0);
            const offset = right.multiplyScalar(1.2).add(up.multiplyScalar(0.8));
            label.position.copy(pos.clone().add(offset));
            label.visible = false;
            label.userData = { constellation: cName, starName: star.name, baseScale: label.scale.clone() };
            cStarLabelsGroup.add(label);
            allStarLabels.push(label);
            starCount++;
        });

        constellationVisibility[cName] = maxAltitude > 0;
        if (mainStarPos) constellationMap[cName] = { mainStarPos: mainStarPos.clone() };

        if(cData.lines) {
            const points = [];
            cData.lines.forEach(pair => {
                const p1 = starPosCache[pair[0]], p2 = starPosCache[pair[1]];
                if(p1 && p2) points.push(p1.clone(), p2.clone());
            });
            if(points.length) {
                const seg = new THREE.LineSegments(new THREE.BufferGeometry().setFromPoints(points), new THREE.LineBasicMaterial({ color: 0xaa66ff, opacity: 0.6, transparent: true }));
                seg.visible = settings.lines;
                cLines.add(seg);
            }
        }

        if(starCount && mainStarPos) {
            const labelPos = mainStarPos.clone().normalize().multiplyScalar(SPHERE_RADIUS * 1.08);
            const cl = createGlowTextSprite(cName, '#cc99ff', 1.3);
            cl.position.copy(labelPos);
            cl.visible = settings.constNames;
            cLabels.add(cl);
        }

        groups.constellations.add(cLines);
        groups.constellations.add(cLabels);
        groups.starLabels.add(cStarLabelsGroup);
        
        if (constellationMap[cName]) {
            constellationMap[cName].linesGroup = cLines;
            constellationMap[cName].constLabelGroup = cLabels;
            constellationMap[cName].starLabelsGroup = cStarLabelsGroup;
        }
    });

    buildConstellationList();

    PLANETS.forEach(p => {
        try {
            const eq = Astronomy.Equator(p, now, observer, false, true);
            const hor = Astronomy.Horizon(now, observer, eq.ra, eq.dec, 'normal');
            const pos = sphericalToCartesian(SPHERE_RADIUS, hor.azimuth, hor.altitude);
            const mag = PLANET_MAG[p] || 1;
            planetPositions[p] = pos.clone();
            const sprite = createPlanetSprite(mag);
            sprite.position.copy(pos);
            sprite.userData = { type: 'planet', name: PLANET_NAMES_RU[p] || p, magnitude: mag, azimuth: hor.azimuth, altitude: hor.altitude };
            groups.planets.add(sprite);
            interactiveObjects.push(sprite);
            const label = createGlowTextSprite(PLANET_NAMES_RU[p] || p, '#ffdd00', 0.9);
            label.position.copy(pos.clone().add(new THREE.Vector3(0, 2.5, 0)));
            groups.planets.add(label);
        } catch(e) {}
    });

    try {
        const sunEq = Astronomy.Equator('Sun', now, observer, false, true);
        const sunHor = Astronomy.Horizon(now, observer, sunEq.ra, sunEq.dec, 'normal');
        const sunPos = sphericalToCartesian(SPHERE_RADIUS, sunHor.azimuth, sunHor.altitude);
        planetPositions['Sun'] = sunPos.clone();
        currentSunAltitude = sunHor.altitude;
        
        const sunCanvas = document.createElement('canvas');
        sunCanvas.width = 128; sunCanvas.height = 128;
        const sCtx = sunCanvas.getContext('2d');
        const sGrad = sCtx.createRadialGradient(64, 64, 10, 64, 64, 60);
        sGrad.addColorStop(0, '#ffffff');
        sGrad.addColorStop(0.2, '#fff0aa');
        sGrad.addColorStop(0.5, '#ffaa00');
        sGrad.addColorStop(1, 'rgba(255, 100, 0, 0)');
        sCtx.fillStyle = sGrad;
        sCtx.fillRect(0,0,128,128);

        const sunSprite = new THREE.Sprite(new THREE.SpriteMaterial({ map: new THREE.CanvasTexture(sunCanvas), blending: THREE.AdditiveBlending, depthTest: true, depthWrite: false, transparent: true }));
        sunSprite.scale.set(7, 7, 1);
        sunSprite.position.copy(sunPos);
        sunSprite.userData = { type: 'sun', name: '–°–æ–ª–Ω—Ü–µ', azimuth: sunHor.azimuth, altitude: sunHor.altitude };
        groups.sunMoon.add(sunSprite);
        interactiveObjects.push(sunSprite);
        
        const sunLabel = createGlowTextSprite('–°–æ–ª–Ω—Ü–µ', '#ffcc00', 1.3);
        sunLabel.position.copy(sunPos.clone().add(new THREE.Vector3(0, 4, 0)));
        groups.sunMoon.add(sunLabel);
        
        updateSkyBackground(sunHor.altitude);
    } catch(e) {
        updateSkyBackground(-90);
    }

    try {
        const moonEq = Astronomy.Equator('Moon', now, observer, false, true);
        const moonHor = Astronomy.Horizon(now, observer, moonEq.ra, moonEq.dec, 'normal');
        const moonPos = sphericalToCartesian(SPHERE_RADIUS, moonHor.azimuth, moonHor.altitude);
        planetPositions['Moon'] = moonPos.clone();
        
        const canvas = document.createElement('canvas');
        canvas.width = 64; canvas.height = 64;
        const ctx = canvas.getContext('2d');
        ctx.shadowColor = '#ffffff';
        ctx.shadowBlur = 10;
        ctx.fillStyle = '#ffffee';
        ctx.beginPath();
        ctx.arc(32, 32, 20, 0, Math.PI * 2);
        ctx.fill();
        ctx.globalCompositeOperation = 'destination-out';
        ctx.beginPath();
        ctx.arc(40, 32, 18, 0, Math.PI * 2);
        ctx.fill();

        const moonSprite = new THREE.Sprite(new THREE.SpriteMaterial({ map: new THREE.CanvasTexture(canvas), blending: THREE.AdditiveBlending, depthTest: true, depthWrite: false, transparent: true }));
        moonSprite.scale.set(3.5, 3.5, 1);
        moonSprite.position.copy(moonPos);
        moonSprite.userData = { type: 'moon', name: '–õ—É–Ω–∞', azimuth: moonHor.azimuth, altitude: moonHor.altitude };
        groups.sunMoon.add(moonSprite);
        interactiveObjects.push(moonSprite);
        
        const moonLabel = createGlowTextSprite('–õ—É–Ω–∞', '#ffffff', 1.0);
        moonLabel.position.copy(moonPos.clone().add(new THREE.Vector3(0, 2.5, 0)));
        groups.sunMoon.add(moonLabel);
    } catch(e) {}

    try {
        drawTrajectory('Sun', 0xffaa00, now, observer);
        drawTrajectory('Moon', 0xaaaaff, now, observer);
    } catch(e) {}

    applyVisibilitySettings();
    if (activeConstellation && constellationMap[activeConstellation]) highlightConstellation(activeConstellation);
}

function drawTrajectory(body, color, date, obs) {
    const pts = []; 
    const d = new Date(date); 
    d.setHours(0, 0, 0, 0);
    for(let i = 0; i <= 24; i += 0.16) {
        try {
            const t = new Date(d.getTime() + i * 3600000);
            const eq = Astronomy.Equator(body, t, obs, false, true);
            const h = Astronomy.Horizon(t, obs, eq.ra, eq.dec, 'normal');
            pts.push(sphericalToCartesian(SPHERE_RADIUS, h.azimuth, h.altitude));
        } catch(e) {}
    }
    if(pts.length > 1) groups.trajectories.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints(pts), new THREE.LineBasicMaterial({ color, opacity: 0.6, transparent: true })));
}

function getTopo(obsLat, obsLon, satLat, satLon, satAltKm) {
    const R = 6371, D2R = Math.PI / 180, R2D = 180 / Math.PI;
    const lat1 = obsLat * D2R, lon1 = obsLon * D2R, lat2 = satLat * D2R, lon2 = satLon * D2R;
    const r1 = R, r2 = R + satAltKm;
    const x1 = r1 * Math.cos(lat1) * Math.cos(lon1), y1 = r1 * Math.cos(lat1) * Math.sin(lon1), z1 = r1 * Math.sin(lat1);
    const x2 = r2 * Math.cos(lat2) * Math.cos(lon2), y2 = r2 * Math.cos(lat2) * Math.sin(lon2), z2 = r2 * Math.sin(lat2);
    const dx = x2 - x1, dy = y2 - y1, dz = z2 - z1;
    const sl = Math.sin(lat1), cl = Math.cos(lat1), slo = Math.sin(lon1), clo = Math.cos(lon1);
    const e = -slo * dx + clo * dy, n = -sl * clo * dx - sl * slo * dy + cl * dz, u = cl * clo * dx + cl * slo * dy + sl * dz;
    let az = Math.atan2(e, n) * R2D; if(az < 0) az += 360;
    return { az, alt: Math.asin(u / Math.sqrt(e*e + n*n + u*u)) * R2D, visible: u > 0 };
}

async function updateISS() {
    if(!settings.iss) { groups.iss.visible = false; document.getElementById('iss-data').style.display = 'none'; return; }
    try {
        const resp = await fetch('https://api.wheretheiss.at/v1/satellites/25544');
        if(!resp.ok) throw new Error();
        const data = await resp.json();
        while(groups.iss.children.length) groups.iss.remove(groups.iss.children[0]);
        
        const topo = getTopo(observerLat, observerLon, data.latitude, data.longitude, data.altitude);
        const pos = sphericalToCartesian(SPHERE_RADIUS * 0.95, topo.az, topo.alt);
        issPosition = pos.clone();
        
        const model = createISSModel();
        model.position.copy(pos);
        model.lookAt(0, 0, 0);
        model.userData = { type: 'iss', name: '–ú–ö–° (ISS)', azimuth: topo.az, altitude: topo.alt };
        groups.iss.add(model);
        interactiveObjects.push(model);
        
        const label = createGlowTextSprite('üõ∞Ô∏è –ú–ö–°', '#00ff88', 1.0);
        label.position.copy(pos.clone().multiplyScalar(1.15));
        groups.iss.add(label);
        
        groups.iss.visible = true;
        const issDiv = document.getElementById('iss-data');
        issDiv.style.display = 'block';
        issDiv.innerHTML = topo.visible 
            ? `üõ∞Ô∏è Az:${topo.az.toFixed(0)}¬∞ Alt:${topo.alt.toFixed(0)}¬∞ <span style="color:#00ff88">‚óè</span>` 
            : `üõ∞Ô∏è Az:${topo.az.toFixed(0)}¬∞ Alt:${topo.alt.toFixed(0)}¬∞ <span style="color:#666">‚óã</span>`;
        
        if(!topo.visible) model.traverse(c => { if(c.material) { c.material.opacity = 0.4; c.material.transparent = true; }});
    } catch (e) { document.getElementById('iss-data').innerHTML = 'üõ∞Ô∏è –ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö'; }
}

function buildConstellationList() {
    const list = document.getElementById('const-list');
    list.innerHTML = '';
    Object.keys(CONSTELLATIONS).sort().forEach(name => {
        const isVisible = constellationVisibility[name];
        const div = document.createElement('div');
        div.className = 'const-item' + (isVisible ? '' : ' below-horizon');
        div.dataset.name = name;
        div.innerHTML = `<div class="const-item-left"><span class="const-name">${name}</span><span class="latin-name">${CONSTELLATIONS[name].latin}</span></div><span class="${isVisible ? 'visible-badge' : 'horizon-badge'}">${isVisible ? '‚Üë' : '‚Üì'}</span>`;
        div.onclick = () => toggleConstellation(name);
        list.appendChild(div);
    });
}

function toggleConstellation(name) {
    if (activeConstellation === name) resetView();
    else selectConstellation(name);
}

function selectConstellation(name) {
    highlightedStarName = null;
    const isVisible = constellationVisibility[name];
    const data = constellationMap[name];
    
    activeConstellation = name;
    document.querySelectorAll('.const-item').forEach(el => el.classList.toggle('active', el.dataset.name === name));
    highlightConstellation(name);
    
    if (data && data.mainStarPos) {
        if (!isVisible && settings.ground && isInsideMode) {
            const indicator = document.getElementById('mode-indicator');
            indicator.innerHTML = `‚ö†Ô∏è ${name} ‚Äî –Ω–∏–∂–µ –≥–æ—Ä–∏–∑–æ–Ω—Ç–∞<br><small>–û—Ç–∫–ª—é—á–∏—Ç–µ –ª–∞–Ω–¥—à–∞—Ñ—Ç –¥–ª—è –ø—Ä–æ—Å–º–æ—Ç—Ä–∞</small>`;
            indicator.classList.add('visible');
            setTimeout(() => indicator.classList.remove('visible'), 4000);
        } else {
            navigateToPosition(data.mainStarPos, () => animateConstellationHighlight(name));
        }
    }
    
    const el = document.querySelector(`.const-item[data-name="${name}"]`);
    if (el) el.scrollIntoView({ behavior: 'smooth', block: 'center' });
}

function highlightConstellation(name) {
    Object.entries(constellationMap).forEach(([cName, obj]) => {
        const isSelected = cName === name;
        if (obj.linesGroup) {
            obj.linesGroup.children.forEach(l => { 
                if(l.material) { 
                    l.material.opacity = isSelected ? 1.0 : 0.15; 
                    l.material.color.setHex(isSelected ? 0x00ffff : 0x6644aa); 
                    l.visible = true;
                }
            });
        }
        if (obj.constLabelGroup) obj.constLabelGroup.children.forEach(lbl => lbl.visible = isSelected || settings.constNames);
        if (obj.starLabelsGroup) {
            obj.starLabelsGroup.children.forEach(lbl => {
                const isHighlightedStar = highlightedStarName && lbl.userData.starName === highlightedStarName;
                lbl.visible = isSelected || isHighlightedStar || settings.starNames;
            });
        }
    });
}

function resetView() {
    activeConstellation = null;
    highlightedStarName = null;
    document.querySelectorAll('.const-item').forEach(el => el.classList.remove('active'));
    Object.values(constellationMap).forEach(obj => {
        if (obj.linesGroup) obj.linesGroup.children.forEach(l => { if(l.material) { l.material.opacity = 0.6; l.material.color.setHex(0xaa66ff); l.visible = settings.lines; }});
        if (obj.constLabelGroup) obj.constLabelGroup.children.forEach(lbl => lbl.visible = settings.constNames);
        if (obj.starLabelsGroup) obj.starLabelsGroup.children.forEach(lbl => lbl.visible = settings.starNames);
    });
}

function applyVisibilitySettings() {
    groups.grid.visible = settings.grid;
    groups.cardinals.visible = true;
    groups.zenithNadir.visible = true;
    groups.stars.visible = settings.stars;
    if (!activeConstellation) {
        Object.values(constellationMap).forEach(c => {
            if (c.linesGroup) c.linesGroup.children.forEach(l => l.visible = settings.lines);
            if (c.constLabelGroup) c.constLabelGroup.children.forEach(lbl => lbl.visible = settings.constNames);
            if (c.starLabelsGroup) c.starLabelsGroup.children.forEach(lbl => lbl.visible = settings.starNames);
        });
    }
    groups.planets.visible = settings.planets;
    groups.trajectories.visible = settings.traj;
    groups.iss.visible = settings.iss;
    const groundVisible = settings.ground && isInsideMode;
    if(landscapeMesh) landscapeMesh.visible = groundVisible;
    groups.ground.children.forEach(c => { if(c !== landscapeMesh) c.visible = settings.ground; });
}

document.getElementById('btn-toggle-const').onclick = () => {
    const panel = document.getElementById('constellation-panel');
    panel.classList.toggle('visible');
    if (panel.classList.contains('visible') && window.innerWidth <= 768) {
        document.getElementById('controls-panel').classList.remove('visible');
        document.getElementById('info-panel').style.display = 'block';
    }
};

document.getElementById('btn-toggle-controls').onclick = () => {
    const panel = document.getElementById('controls-panel');
    const infoPanel = document.getElementById('info-panel');
    panel.classList.toggle('visible');
    if (panel.classList.contains('visible')) {
        infoPanel.style.display = 'none';
        if (window.innerWidth <= 768) document.getElementById('constellation-panel').classList.remove('visible');
    } else {
        infoPanel.style.display = 'block';
    }
};

document.addEventListener('click', (e) => {
    if (window.innerWidth <= 768 && !isTransitioning) {
        const controlsPanel = document.getElementById('controls-panel');
        const infoPanel = document.getElementById('info-panel');
        if (!e.target.closest('#controls-panel') && !e.target.closest('#btn-toggle-controls')) {
            if (controlsPanel.classList.contains('visible')) {
                controlsPanel.classList.remove('visible');
                infoPanel.style.display = 'block';
            }
        }
        if (!e.target.closest('#constellation-panel') && !e.target.closest('#btn-toggle-const')) {
            document.getElementById('constellation-panel').classList.remove('visible');
        }
    }
});

document.getElementById('btn-reset-view').onclick = resetView;

function setupUI() {
    const bind = (id, key, callback) => {
        const el = document.getElementById(id);
        if(!el) return;
        el.checked = settings[key];
        el.onchange = (e) => { settings[key] = e.target.checked; saveSettings(); applyVisibilitySettings(); if(callback) callback(); };
    };
    
    bind('chk-grid', 'grid');
    bind('chk-stars', 'stars');
    bind('chk-lines', 'lines');
    bind('chk-const-names', 'constNames');
    bind('chk-star-names', 'starNames');
    bind('chk-planets', 'planets');
    bind('chk-traj', 'traj');
    bind('chk-iss', 'iss', updateISS);
    bind('chk-ground', 'ground');
    
    document.getElementById('cam-out').onclick = () => {
        if (isTransitioning || !isInsideMode) return;
        startTransition('toOutside');
    };
    
    document.getElementById('cam-in').onclick = () => {
        if (isTransitioning || isInsideMode) return;
        startTransition('toInside');
    };
}

function onResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
}

function animate() {
    requestAnimationFrame(animate);
    if (isTransitioning) updateTransition();
    if (cameraAnimation) cameraAnimation();
    if (constellationAnimation) constellationAnimation();
    if (!isInsideMode && !isTransitioning) controls.update();
    groups.iss.children.forEach(c => { if(c.type === 'Group') c.rotation.z += 0.008; });
    renderer.render(scene, camera);
}

init();
</script>
</body>
</html>