<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no, maximum-scale=1.0" />
<link rel="icon" href="worldwide.png" type="image/png" />
<title>–ó–µ–º–ª—è 3D</title>
<style>
:root {
    --glass-bg: rgba(200, 230, 255, 0.15);
    --glass-border: rgba(120, 200, 255, 0.35);
    --glass-highlight: rgba(255, 255, 255, 0.15);
    --neon-cyan: #4fc3f7;
    --neon-blue: #29b6f6;
    --neon-light: #81d4fa;
    --gold: #ffd54f;
    --red-ui: #ff7043;
    --text-main: #e3f2fd;
    --text-muted: #90caf9;
    --panel-bg: rgba(30, 60, 90, 0.45);
    --accent-glow: rgba(79, 195, 247, 0.4);
}

html, body {
    width: 100%; height: 100%; margin: 0; padding: 0; overflow: hidden;
    background: linear-gradient(135deg, #0a1628 0%, #1a3a5c 50%, #0d2137 100%);
    font-family: "Segoe UI", "Roboto", system-ui, sans-serif;
    touch-action: none;
}

canvas { display: block; width: 100%; height: 100%; outline: none; }

#loading {
    position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
    color: var(--neon-light); letter-spacing: 3px; font-size: 14px;
    pointer-events: none; text-transform: uppercase; font-weight: 600;
    user-select: none; white-space: nowrap; z-index: 10;
    text-shadow: 0 0 20px var(--accent-glow), 0 0 40px var(--accent-glow);
    animation: pulse 2s infinite;
}
@keyframes pulse { 0% { opacity: 0.6; } 50% { opacity: 1; } 100% { opacity: 0.6; } }

.panel-glass {
    background: var(--panel-bg);
    backdrop-filter: blur(20px);
    -webkit-backdrop-filter: blur(20px);
    border: 1px solid var(--glass-border);
    border-radius: 20px;
    box-shadow: 
        0 8px 32px rgba(0, 0, 0, 0.3),
        0 0 40px rgba(79, 195, 247, 0.1),
        inset 0 1px 0 var(--glass-highlight);
    color: var(--text-main);
    transition: transform 0.4s cubic-bezier(0.2, 0.8, 0.2, 1), opacity 0.4s;
}

#ui {
    position: absolute; bottom: 20px; right: 20px; width: 280px;
    padding: 0; display: flex; flex-direction: column; z-index: 5;
}

.ui-header {
    background: linear-gradient(180deg, rgba(79, 195, 247, 0.2) 0%, rgba(30, 60, 90, 0.3) 100%);
    padding: 20px 20px 15px 20px;
    border-bottom: 1px solid var(--glass-border);
    text-align: center;
    border-radius: 20px 20px 0 0;
}

#time-now {
    font-size: 32px; font-weight: 300; letter-spacing: 1px;
    color: #fff; 
    text-shadow: 0 0 15px var(--accent-glow), 0 2px 4px rgba(0,0,0,0.3);
    font-variant-numeric: tabular-nums; line-height: 1; margin-bottom: 4px;
}

#date-now {
    font-size: 11px; color: var(--neon-light); text-transform: uppercase;
    letter-spacing: 4px; font-weight: 700; opacity: 0.9;
    text-shadow: 0 0 10px var(--accent-glow);
}

.ui-controls { 
    padding: 15px 20px; 
    display: flex; 
    flex-direction: column; 
    gap: 12px;
    background: rgba(20, 50, 80, 0.3);
}

.row { 
    display: flex; 
    justify-content: space-between; 
    align-items: center; 
    font-size: 14px; 
    font-weight: 500; 
    letter-spacing: 0.5px;
    color: var(--text-main);
}

.switch { position: relative; width: 44px; height: 24px; flex: 0 0 auto; }
.switch input { opacity: 0; width: 0; height: 0; }
.slider {
    position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0;
    background-color: rgba(100, 180, 255, 0.15); 
    border-radius: 34px; 
    transition: .3s;
    border: 1px solid rgba(100, 180, 255, 0.3);
}
.slider:before {
    position: absolute; content: ""; height: 16px; width: 16px; left: 3px; bottom: 3px;
    background: linear-gradient(135deg, #b3e5fc 0%, #4fc3f7 100%);
    border-radius: 50%; transition: .3s;
    box-shadow: 0 2px 8px rgba(0,0,0,0.3);
}
input:checked + .slider { 
    background-color: rgba(79, 195, 247, 0.35); 
    border-color: var(--neon-cyan);
    box-shadow: 0 0 15px var(--accent-glow);
}
input:checked + .slider:before { 
    transform: translateX(20px); 
    background: linear-gradient(135deg, #fff 0%, #4fc3f7 100%);
    box-shadow: 0 0 12px var(--neon-cyan); 
}

#data {
    font-family: "Consolas", "Monaco", monospace; 
    font-size: 11px; 
    color: var(--neon-light);
    margin: 5px 20px 20px 20px; 
    padding-top: 12px;
    border-top: 1px solid rgba(100, 180, 255, 0.2); 
    line-height: 1.7; 
    min-height: 72px;
}

#moonInfo {
    position: absolute; top: 20px; left: 20px; width: 260px;
    padding: 20px; display: none; z-index: 5;
}

.moonTitle {
    font-size: 13px; font-weight: 700; color: var(--gold); text-align: center; margin-bottom: 15px;
    text-transform: uppercase; letter-spacing: 3px; 
    text-shadow: 0 0 15px rgba(255, 213, 79, 0.4);
}

#moonPhase {
    width: 140px; height: 140px; margin: 0 auto 15px auto; border-radius: 50%; overflow: hidden;
    box-shadow: 0 0 30px rgba(255, 255, 255, 0.1), 0 0 60px rgba(79, 195, 247, 0.1);
    border: 1px solid rgba(255, 255, 255, 0.15); 
    background: #0a1628;
}

#moonData {
    font-family: "Consolas", monospace; font-size: 11px; color: var(--text-main); line-height: 1.6;
    text-align: center; min-height: 76px;
}
.phaseName { font-size: 13px; color: var(--gold); font-weight: 700; margin-bottom: 6px; }

#btn-sky-view {
    margin-top: 15px;
    width: 100%;
    padding: 12px 15px;
    background: linear-gradient(135deg, rgba(255, 213, 79, 0.25) 0%, rgba(255, 183, 77, 0.15) 100%);
    border: 1px solid var(--gold);
    color: var(--gold);
    border-radius: 12px;
    font-size: 12px;
    font-weight: 600;
    letter-spacing: 1px;
    text-transform: uppercase;
    cursor: pointer;
    transition: all 0.3s ease;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 8px;
}
#btn-sky-view:hover {
    background: linear-gradient(135deg, rgba(255, 213, 79, 0.4) 0%, rgba(255, 183, 77, 0.25) 100%);
    box-shadow: 0 0 25px rgba(255, 213, 79, 0.4);
    transform: translateY(-2px);
}

#btn-clear-cache {
    position: absolute; bottom: 20px; left: 20px; width: 48px; height: 48px;
    background: var(--panel-bg); 
    border: 1px solid rgba(255, 112, 67, 0.4);
    color: var(--red-ui); 
    border-radius: 50%; 
    cursor: pointer; 
    z-index: 100;
    display: flex; justify-content: center; align-items: center;
    backdrop-filter: blur(12px); 
    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
    transition: all 0.3s;
}
#btn-clear-cache:hover {
    background: rgba(255, 112, 67, 0.2); 
    border-color: var(--red-ui);
    box-shadow: 0 0 25px rgba(255, 112, 67, 0.4); 
    transform: rotate(90deg);
}

#btn-exit-iss {
    position: absolute; bottom: 40px; left: 50%; transform: translateX(-50%) translateY(100px);
    background: var(--panel-bg); 
    border: 1px solid var(--red-ui); 
    color: var(--red-ui);
    padding: 14px 32px; 
    border-radius: 30px; 
    font-size: 13px; 
    font-weight: 700; 
    letter-spacing: 2px;
    cursor: pointer; 
    z-index: 20; 
    backdrop-filter: blur(12px); 
    text-transform: uppercase;
    transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275); 
    opacity: 0; 
    pointer-events: none;
    box-shadow: 0 0 20px rgba(255, 112, 67, 0.2);
}
#btn-exit-iss:hover { 
    background: var(--red-ui); 
    color: white; 
    box-shadow: 0 0 35px rgba(255, 112, 67, 0.6); 
}
#btn-exit-iss.visible { 
    transform: translateX(-50%) translateY(0); 
    opacity: 1; 
    pointer-events: auto; 
}

.iss-hint {
    position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
    color: var(--neon-light); font-size: 11px; text-transform: uppercase; letter-spacing: 1.5px;
    opacity: 0; transition: opacity 0.3s; pointer-events: none; z-index: 8; font-weight: 600;
    text-shadow: 0 0 15px var(--accent-glow); 
    background: var(--panel-bg);
    padding: 8px 16px; 
    border-radius: 8px; 
    border: 1px solid var(--glass-border);
    backdrop-filter: blur(8px);
}

#btn-exit-moon {
    position: absolute; bottom: 40px; left: 50%; transform: translateX(-50%) translateY(100px);
    background: var(--panel-bg); 
    border: 1px solid var(--gold); 
    color: var(--gold);
    padding: 14px 32px; 
    border-radius: 30px; 
    font-size: 13px; 
    font-weight: 700; 
    letter-spacing: 2px;
    cursor: pointer; 
    z-index: 20; 
    backdrop-filter: blur(12px); 
    text-transform: uppercase;
    transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275); 
    opacity: 0; 
    pointer-events: none;
    box-shadow: 0 0 20px rgba(255, 213, 79, 0.2);
}
#btn-exit-moon:hover { 
    background: var(--gold); 
    color: #1a3a5c; 
    box-shadow: 0 0 35px rgba(255, 213, 79, 0.6); 
}
#btn-exit-moon.visible { 
    transform: translateX(-50%) translateY(0); 
    opacity: 1; 
    pointer-events: auto; 
}

.iss-hud {
    position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
    width: 80%; height: 80%; pointer-events: none; z-index: 4;
    display: none; font-family: "Consolas", "Monaco", monospace;
}

.iss-hud::before {
    content: ''; position: absolute; top: 0; left: 0; right: 0; bottom: 0;
    border: 1px solid rgba(79, 195, 247, 0.15);
    background:
        linear-gradient(90deg, rgba(79, 195, 247, 0.1) 1px, transparent 1px) 50% 50% / 20% 100% no-repeat,
        linear-gradient(rgba(79, 195, 247, 0.1) 1px, transparent 1px) 50% 50% / 100% 20% no-repeat;
    mask-image: radial-gradient(circle, transparent 30%, black 100%);
    -webkit-mask-image: radial-gradient(circle, transparent 30%, black 100%);
}

.hud-corner {
    position: absolute; width: 40px; height: 40px;
    border: 2px solid var(--neon-cyan); opacity: 0.7;
    box-shadow: 0 0 15px var(--accent-glow);
}
.hc-tl { top: 0; left: 0; border-right: 0; border-bottom: 0; }
.hc-tr { top: 0; right: 0; border-left: 0; border-bottom: 0; }
.hc-bl { bottom: 0; left: 0; border-right: 0; border-top: 0; }
.hc-br { bottom: 0; right: 0; border-left: 0; border-top: 0; }

.hud-panel {
    position: absolute; 
    background: var(--panel-bg);
    border: 1px solid var(--neon-cyan); 
    padding: 12px 18px;
    color: var(--neon-light); 
    font-size: 12px; 
    line-height: 1.6;
    backdrop-filter: blur(8px); 
    text-shadow: 0 0 8px var(--accent-glow);
    border-radius: 12px;
}
.hp-left { 
    top: 50%; left: 20px; transform: translateY(-50%); 
    text-align: left; 
    border-left: 4px solid var(--neon-cyan); 
    border-radius: 0 12px 12px 0;
}
.hp-right { 
    top: 50%; right: 20px; transform: translateY(-50%); 
    text-align: right; 
    border-right: 4px solid var(--neon-cyan); 
    border-radius: 12px 0 0 12px;
}
.hp-bottom { 
    bottom: 40px; left: 50%; transform: translateX(-50%); 
    text-align: center; 
    border-bottom: 4px solid var(--neon-cyan); 
    width: 300px;
    border-radius: 12px 12px 0 0;
}

.hud-value { font-size: 18px; font-weight: 700; color: #fff; }
.hud-label { font-size: 10px; color: var(--text-muted); text-transform: uppercase; letter-spacing: 1px; }
.hud-warn { color: var(--red-ui); text-shadow: 0 0 10px rgba(255, 112, 67, 0.6); }

.panel-toggle {
    position: absolute;
    width: 48px; height: 48px;
    background: var(--panel-bg);
    border: 1px solid var(--glass-border);
    backdrop-filter: blur(12px);
    -webkit-backdrop-filter: blur(12px);
    border-radius: 50%;
    display: none;
    justify-content: center;
    align-items: center;
    cursor: pointer;
    z-index: 100;
    color: var(--neon-cyan);
    font-size: 20px;
    box-shadow: 0 4px 20px rgba(0,0,0,0.4), 0 0 20px var(--accent-glow);
    transition: all 0.3s ease;
    user-select: none;
}
.panel-toggle:active { transform: scale(0.9); }

#ui-toggle { bottom: 20px; right: 20px; }
#moon-toggle { top: 20px; left: 20px; }

#sky-modal {
    position: fixed;
    top: 0; left: 0; right: 0; bottom: 0;
    background: linear-gradient(135deg, #0a1628 0%, #1a3a5c 50%, #0d2137 100%);
    z-index: 1000;
    display: none;
    flex-direction: column;
    align-items: center;
    justify-content: center;
}

#sky-modal.visible {
    display: flex;
}

#sky-container {
    width: 95%;
    height: 85%;
    border-radius: 20px;
    overflow: hidden;
    border: 1px solid var(--glass-border);
    box-shadow: 0 0 60px var(--accent-glow), inset 0 0 30px rgba(0, 0, 0, 0.3);
    position: relative;
}

#sky-canvas {
    width: 100%;
    height: 100%;
}

#sky-close {
    position: absolute;
    top: 20px;
    right: 20px;
    width: 50px;
    height: 50px;
    background: rgba(255, 112, 67, 0.2);
    border: 2px solid var(--red-ui);
    border-radius: 50%;
    color: var(--red-ui);
    font-size: 24px;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.3s;
    z-index: 1001;
}
#sky-close:hover {
    background: var(--red-ui);
    color: white;
    box-shadow: 0 0 25px rgba(255, 112, 67, 0.5);
}

#sky-info {
    position: absolute;
    bottom: 20px;
    left: 50%;
    transform: translateX(-50%);
    background: var(--panel-bg);
    backdrop-filter: blur(16px);
    border: 1px solid var(--glass-border);
    border-radius: 20px;
    padding: 0;
    color: white;
    font-family: "Consolas", monospace;
    z-index: 1001;
    min-width: 320px;
    box-shadow: 0 10px 40px rgba(0,0,0,0.4), 0 0 30px var(--accent-glow);
}

.sky-info-container {
    display: flex;
    flex-direction: row;
    align-items: stretch;
}

.celestial-box {
    flex: 1;
    padding: 15px 20px;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    min-width: 140px;
}

.cb-divider {
    width: 1px;
    background: linear-gradient(to bottom, transparent, var(--glass-border), transparent);
}

.cb-header {
    font-size: 14px;
    font-weight: 700;
    margin-bottom: 8px;
    text-transform: uppercase;
    letter-spacing: 1.5px;
    color: var(--neon-cyan);
    text-shadow: 0 0 12px var(--accent-glow);
}

.cb-coords {
    font-size: 12px;
    line-height: 1.6;
    color: #fff;
    white-space: nowrap;
    text-align: center;
    margin-bottom: 6px;
}

.cb-status {
    font-size: 11px;
    font-weight: 600;
}

.cb-times {
    margin-top: 8px;
    padding-top: 8px;
    border-top: 1px solid rgba(255, 255, 255, 0.15);
    font-size: 11px;
    color: var(--text-muted);
    font-family: "Consolas", monospace;
    letter-spacing: 0px;
    white-space: nowrap;
}
.cb-times span {
    color: #fff;
    font-weight: 600;
}

#sky-location-info {
    position: absolute;
    top: 20px;
    left: 20px;
    background: var(--panel-bg);
    backdrop-filter: blur(16px);
    border: 1px solid var(--glass-border);
    border-radius: 16px;
    padding: 16px 20px;
    color: white;
    font-family: "Consolas", monospace;
    font-size: 11px;
    z-index: 1001;
    min-width: 220px;
    box-shadow: 0 8px 30px rgba(0,0,0,0.3), 0 0 20px var(--accent-glow);
}

#sky-location-info .loc-title {
    color: var(--neon-cyan);
    font-weight: 700;
    margin-bottom: 8px;
    text-transform: uppercase;
    letter-spacing: 1px;
    font-size: 12px;
    text-shadow: 0 0 10px var(--accent-glow);
}



.celestial-buttons {
    margin-top: 12px;
    padding-top: 12px;
    border-top: 1px solid rgba(79, 195, 247, 0.3);
    display: flex;
    gap: 8px;
}

.celestial-buttons {
    margin-top: 12px;
    padding-top: 12px;
    border-top: 1px solid rgba(79, 195, 247, 0.3);
    display: flex;
    gap: 8px;
}

.celestial-btn {
    width: 36px;
    height: 36px;
    padding: 0;
    background: linear-gradient(135deg, rgba(79, 195, 247, 0.15) 0%, rgba(41, 182, 246, 0.1) 100%);
    border: 1px solid var(--neon-cyan);
    color: var(--neon-cyan);
    border-radius: 10px;
    font-size: 16px;
    cursor: pointer;
    transition: all 0.3s ease;
    display: flex;
    align-items: center;
    justify-content: center;
}

.celestial-btn:hover {
    background: linear-gradient(135deg, rgba(79, 195, 247, 0.3) 0%, rgba(41, 182, 246, 0.2) 100%);
    box-shadow: 0 0 20px var(--accent-glow);
    transform: translateY(-2px);
}

.celestial-btn.active {
    background: linear-gradient(135deg, var(--neon-cyan) 0%, var(--neon-blue) 100%);
    color: #0a1628;
}

.celestial-btn.planets {
    border-color: var(--gold);
    color: var(--gold);
}

.celestial-btn.planets:hover {
    box-shadow: 0 0 20px rgba(255, 213, 79, 0.4);
}

.celestial-btn.planets.active {
    background: linear-gradient(135deg, var(--gold) 0%, #ffb74d 100%);
    color: #1a3a5c;
}


#sky-search-wrapper {
    position: absolute;
    top: 20px;
    left: 50%;
    transform: translateX(-50%);
    width: 300px;
    z-index: 1002;
    display: flex;
    flex-direction: column;
    gap: 5px;
}

#city-input {
    width: 100%;
    padding: 14px 20px;
    background: var(--panel-bg);
    border: 1px solid var(--neon-cyan);
    border-radius: 25px;
    color: white;
    font-family: inherit;
    font-size: 14px;
    outline: none;
    box-shadow: 0 0 20px var(--accent-glow);
    transition: all 0.3s;
}

#city-input:focus {
    border-color: var(--neon-light);
    box-shadow: 0 0 30px var(--accent-glow);
}

#city-input::placeholder {
    color: var(--text-muted);
}

#search-results {
    background: rgba(240, 248, 255, 0.98);
    border-radius: 16px;
    overflow: hidden;
    margin-top: 8px;
    box-shadow: 0 10px 40px rgba(0,0,0,0.3);
    border: 1px solid var(--neon-cyan);
    max-height: 250px;
    overflow-y: auto;
}

.search-item {
    padding: 14px 18px;
    cursor: pointer;
    font-size: 14px;
    color: #1a3a5c;
    background: rgba(255, 255, 255, 0.95);
    border-bottom: 1px solid rgba(79, 195, 247, 0.2);
    transition: all 0.2s ease;
    font-weight: 500;
}

.search-item:hover {
    background: linear-gradient(135deg, var(--neon-cyan) 0%, var(--neon-blue) 100%);
    color: #ffffff;
}

.search-item:last-child {
    border-bottom: none;
}

.search-item.planet {
    background: linear-gradient(135deg, rgba(255, 213, 79, 0.1) 0%, rgba(255, 255, 255, 0.95) 100%);
}

.search-item.planet:hover {
    background: linear-gradient(135deg, var(--gold) 0%, #ffb74d 100%);
    color: #1a3a5c;
}

.search-item.star {
    background: linear-gradient(135deg, rgba(129, 212, 250, 0.1) 0%, rgba(255, 255, 255, 0.95) 100%);
}

.search-item.star:hover {
    background: linear-gradient(135deg, var(--neon-cyan) 0%, var(--neon-blue) 100%);
    color: #ffffff;
}

#search-results::-webkit-scrollbar {
    width: 8px;
}
#search-results::-webkit-scrollbar-track {
    background: rgba(79, 195, 247, 0.1);
}
#search-results::-webkit-scrollbar-thumb {
    background: var(--neon-cyan);
    border-radius: 4px;
}

.weather-section {
    margin-top: 12px;
    padding-top: 12px;
    border-top: 1px solid rgba(79, 195, 247, 0.3);
}

.weather-title {
    color: var(--gold);
    font-weight: 700;
    font-size: 11px;
    text-transform: uppercase;
    letter-spacing: 1px;
    margin-bottom: 8px;
    display: flex;
    align-items: center;
    gap: 6px;
}

.weather-main {
    display: flex;
    align-items: center;
    gap: 12px;
    margin-bottom: 8px;
}

.weather-icon {
    font-size: 32px;
    filter: drop-shadow(0 0 8px var(--accent-glow));
}

.weather-temp {
    font-size: 28px;
    font-weight: 300;
    color: #fff;
    text-shadow: 0 0 10px var(--accent-glow);
}

.weather-desc {
    font-size: 12px;
    color: var(--text-main);
    text-transform: capitalize;
    margin-bottom: 8px;
}

.weather-details {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 6px 12px;
    font-size: 10px;
    color: var(--text-muted);
}

.weather-details span {
    color: #fff;
}

.weather-loading {
    color: var(--text-muted);
    font-size: 11px;
    text-align: center;
    padding: 10px;
}

@media (max-width: 1024px) {
    .panel-toggle { display: flex; }
    
    #ui.collapsed { transform: translateX(calc(100% + 30px)); opacity: 0; pointer-events: none; }
    #moonInfo.collapsed { transform: translateX(calc(-100% - 30px)); opacity: 0; pointer-events: none; }
    
    #ui { width: 260px; right: 20px; bottom: 80px; }
    .ui-header { padding: 15px; }
    #time-now { font-size: 26px; }

    #moonInfo { width: 220px; left: 20px; top: 80px; padding: 15px; }
    #moonPhase { width: 100px; height: 100px; }

    #btn-clear-cache { bottom: 20px; left: 20px; width: 44px; height: 44px; }
    #ui-toggle { bottom: 20px; right: 20px; }
    #moon-toggle { top: 20px; left: 20px; }
    
    .iss-hud { width: 98%; height: 95%; top: 50%; transform: translate(-50%, -50%); }
    .iss-hud::before { display: none; }
    
    .hud-value { font-size: 13px; line-height: 1.2; }
    .hud-label { font-size: 8px; margin-bottom: 2px; }
    
    .hp-left, .hp-right {
        position: relative; top: auto; left: auto; right: auto; transform: none;
        display: inline-block; width: 38%; margin: 10px 1%;
        border: 1px solid var(--neon-cyan); border-radius: 12px;
        background: var(--panel-bg);
        text-align: center;
        padding: 8px;
    }
    
    .hp-bottom {
        width: 90%; bottom: 80px;
        background: var(--panel-bg);
        border: 1px solid var(--neon-cyan); border-radius: 12px;
        padding: 8px;
    }
    #hud-location { font-size: 11px !important; margin-bottom: 2px !important; min-height: auto !important; }
    
    #sky-info { 
        min-width: auto; 
        width: 90%;
        padding: 10px 15px;
    }
    #sky-location-info {
        font-size: 10px;
        padding: 12px 15px;
        min-width: 180px;
    }
}

@media (max-width: 600px) {
    .sky-info-container { flex-direction: column; }
    .cb-divider { width: 100%; height: 1px; background: linear-gradient(to right, transparent, var(--glass-border), transparent); }
    #sky-info { width: 90%; min-width: auto; bottom: 60px; }
    
    #sky-location-info {
        top: 80px;
        left: 10px;
        right: 10px;
        width: auto;
    }
    
    #sky-search-wrapper {
        width: 90%;
    }
}
</style>
</head>
<body>
<div id="loading">–ó–∞–≥—Ä—É–∑–∫–∞...</div>
<div class="iss-hint" id="issHint">–î–≤–æ–π–Ω–æ–π –∫–ª–∏–∫: –°—Ç—ã–∫–æ–≤–∫–∞</div>

<div id="ui-toggle" class="panel-toggle">‚öôÔ∏è</div>
<div id="moon-toggle" class="panel-toggle" style="display:none;">üåì</div>

<div id="moonInfo" class="panel-glass">
    <div class="moonTitle">üåô –õ—É–Ω–∞</div>
    <div id="moonPhase"><canvas id="moonCanvas" width="140" height="140"></canvas></div>
    <div id="moonData">–û–∂–∏–¥–∞–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö...</div>
    <button id="btn-sky-view">
        <span>üåå</span>
        <span>–ü–ª–∞–Ω–µ—Ç–∞—Ä–∏–π</span>
    </button>
</div>

<div id="ui" class="panel-glass">
    <div class="ui-header">
        <div id="time-now">00:00:00</div>
        <div id="date-now">DD.MM.YYYY</div>
    </div>

    <div class="ui-controls">
        <div class="row">
            <span>‚òÄÔ∏è –°–æ–ª–Ω—Ü–µ</span>
            <label class="switch"><input type="checkbox" id="chk-sun" /><span class="slider"></span></label>
        </div>
        <div class="row">
            <span>üåô –õ—É–Ω–∞</span>
            <label class="switch"><input type="checkbox" id="chk-moon" /><span class="slider"></span></label>
        </div>
        <div class="row">
            <span>üåå –ì–∞–ª–∞–∫—Ç–∏–∫–∞</span>
            <label class="switch"><input type="checkbox" id="chk-galaxy" /><span class="slider"></span></label>
        </div>
        <div class="row">
            <span>‚òÅÔ∏è –û–±–ª–∞–∫–∞</span>
            <label class="switch"><input type="checkbox" id="chk-clouds" /><span class="slider"></span></label>
        </div>
        <div class="row">
            <span>üõ∞Ô∏è –ú–ö–°</span>
            <label class="switch"><input type="checkbox" id="chk-iss" /><span class="slider"></span></label>
        </div>
    </div>

    <div id="data">–ú–ö–° –≤—ã–∫–ª—é—á–µ–Ω–∞</div>
</div>

<div id="iss-hud" class="iss-hud">
    <div class="hud-corner hc-tl"></div>
    <div class="hud-corner hc-tr"></div>
    <div class="hud-corner hc-bl"></div>
    <div class="hud-corner hc-br"></div>

    <div class="hud-panel hp-left">
        <div class="hud-label">–ö–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã</div>
        <div id="hud-lat" class="hud-value">LAT 00.00</div>
        <div id="hud-lon" class="hud-value">LON 00.00</div>
        <br>
        <div class="hud-label">–í—ã—Å–æ—Ç–∞</div>
        <div id="hud-alt" class="hud-value">420 KM</div>
    </div>

    <div class="hud-panel hp-right">
        <div class="hud-label">–ë–∞—Ç–∞—Ä–µ–∏</div>
        <div id="hud-solar" class="hud-value">100%</div>
        <br>
        <div class="hud-label">–°–∫–æ—Ä–æ—Å—Ç—å</div>
        <div id="hud-vel" class="hud-value">27600</div>
    </div>

    <div class="hud-panel hp-bottom">
        <div id="hud-location" class="hud-value" style="font-size: 14px; color: var(--gold); margin-bottom: 8px; text-transform: uppercase; letter-spacing: 1px; min-height: 20px;">
            –°–∫–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ...
        </div>
        <div id="hud-status" style="font-size:10px; margin-top:5px;">STATUS OK</div>
    </div>
</div>

<button id="btn-clear-cache" title="–û—á–∏—Å—Ç–∏—Ç—å –∫—ç—à —Ç–µ–∫—Å—Ç—É—Ä">
    <svg viewBox="0 0 24 24" width="20" height="20">
        <ellipse cx="12" cy="5" rx="9" ry="3" fill="none" stroke="currentColor" stroke-width="2"></ellipse>
        <path d="M21 12c0 1.66-4 3-9 3s-9-1.34-9-3" fill="none" stroke="currentColor" stroke-width="2"></path>
        <path d="M3 5v14c0 1.66 4 3 9 3 1.2 0 2.33-.08 3.39-.23" fill="none" stroke="currentColor" stroke-width="2"></path>
        <line x1="21" y1="21" x2="17" y2="17" stroke="currentColor" stroke-width="2.5" stroke-linecap="round"></line>
        <line x1="17" y1="21" x2="21" y2="17" stroke="currentColor" stroke-width="2.5" stroke-linecap="round"></line>
    </svg>
</button>

<button id="btn-exit-iss">–û—Ç—Å—Ç—ã–∫–æ–≤–∞—Ç—å—Å—è</button>
<button id="btn-exit-moon">–í–µ—Ä–Ω—É—Ç—å—Å—è –∫ –ó–µ–º–ª–µ</button>

<div id="sky-modal">
    <div id="sky-search-wrapper">
        <input type="text" id="city-input" placeholder="üîç –ì–æ—Ä–æ–¥, –ø–ª–∞–Ω–µ—Ç–∞ –∏–ª–∏ –∑–≤–µ–∑–¥–∞" autocomplete="off">
        <div id="search-results"></div>
    </div>
    <div id="sky-container">
        <canvas id="sky-canvas"></canvas>
    </div>
    <button id="sky-close">‚úï</button>
    <div id="sky-location-info">
        <div class="loc-title">üìç –ú–µ—Å—Ç–æ–ø–æ–ª–æ–∂–µ–Ω–∏–µ</div>
        <div id="sky-user-coords">–û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ...</div>
        <div id="sky-local-time" style="margin-top:10px; color: var(--gold); font-weight:bold; font-size:14px;">
            –í—Ä–µ–º—è (–≥–µ–æ–≥—Ä.): --:--:--
        </div>
        <div class="trajectory-toggle">
            <span>üå† –¢—Ä–∞–µ–∫—Ç–æ—Ä–∏–∏ –∏ –ú–ö–°</span>
            <label class="switch"><input type="checkbox" id="chk-trajectories" /><span class="slider"></span></label>
        </div>
      
<div class="celestial-buttons">
    <button class="celestial-btn" id="btn-trajectories" title="–¢—Ä–∞–µ–∫—Ç–æ—Ä–∏–∏ –∏ –ú–ö–°">üå†</button>
    <button class="celestial-btn planets" id="btn-show-planets" title="–ü–ª–∞–Ω–µ—Ç—ã">ü™ê</button>
    <button class="celestial-btn" id="btn-show-stars" title="–ó–≤—ë–∑–¥—ã">‚≠ê</button>
</div>
        
        <div id="sky-weather" class="weather-section">
            <div class="weather-loading">üå°Ô∏è –ó–∞–≥—Ä—É–∑–∫–∞ –ø–æ–≥–æ–¥—ã...</div>
        </div>
    </div>
    <div id="sky-info">
        <div class="sky-info-container">
            <div class="celestial-box">
                <div class="cb-header">üåô –õ—É–Ω–∞</div>
                <div id="sky-moon-data" class="cb-coords">–†–∞—Å—á—ë—Ç...</div>
                <div id="sky-moon-status" class="cb-status">‚Äî</div>
                <div id="sky-moon-times" class="cb-times">
                    ‚Üë --:-- &nbsp; ‚Üì --:--
                </div>
            </div>
            <div class="cb-divider"></div>
            <div class="celestial-box">
                <div class="cb-header" style="color: var(--gold);">‚òÄÔ∏è –°–æ–ª–Ω—Ü–µ</div>
                <div id="sky-sun-data" class="cb-coords">–†–∞—Å—á—ë—Ç...</div>
                <div id="sky-sun-status" class="cb-status">‚Äî</div>
                <div id="sky-sun-times" class="cb-times">
                    ‚Üë --:-- &nbsp; ‚Üì --:--
                </div>
            </div>
        </div>
    </div>
</div>

<script type="importmap">
{
    "imports": {
        "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
    }
}
</script>
<script src="https://cdn.jsdelivr.net/npm/astronomy-engine@2.1.19/astronomy.browser.min.js"></script>
<script type="module">
    
    
import * as THREE from "three";
import { OrbitControls } from "three/addons/controls/OrbitControls.js";
import { Lensflare, LensflareElement } from 'three/addons/objects/Lensflare.js';

let lastGeoCheckTime = 0;
let userMarker = null;
let userLocation = null;

const DB_NAME = 'EarthISS_DB';
const STORE_NAME = 'textures';

const dbPromise = new Promise((resolve, reject) => {
    const request = indexedDB.open(DB_NAME, 1);
    request.onupgradeneeded = (e) => { e.target.result.createObjectStore(STORE_NAME); };
    request.onsuccess = (e) => resolve(e.target.result);
    request.onerror = (e) => reject(e);
});

const internalLoader = new THREE.TextureLoader();

function loadTextureWithCache(url) {
    const tex = new THREE.Texture();
    const image = new Image();
    image.crossOrigin = "Anonymous";
    tex.image = image;
    image.onload = () => { tex.needsUpdate = true; };

    dbPromise.then(db => {
        const tx = db.transaction(STORE_NAME, 'readonly');
        const store = tx.objectStore(STORE_NAME);
        const request = store.get(url);
        request.onsuccess = () => {
            if (request.result) {
                image.src = URL.createObjectURL(request.result);
            } else {
                fetch(url).then(res => res.blob()).then(blob => {
                    const txWrite = db.transaction(STORE_NAME, 'readwrite');
                    txWrite.objectStore(STORE_NAME).put(blob, url);
                    image.src = URL.createObjectURL(blob);
                }).catch(() => {
                    internalLoader.load(url, (t) => { tex.image = t.image; tex.needsUpdate = true; });
                });
            }
        };
    }).catch(() => {
        internalLoader.load(url, (t) => { tex.image = t.image; tex.needsUpdate = true; });
    });
    return tex;
}

const el = {
    loading: document.getElementById("loading"),
    data: document.getElementById("data"),
    ui: document.getElementById("ui"),
    timeNow: document.getElementById('time-now'),
    dateNow: document.getElementById('date-now'),
    
    chkSun: document.getElementById("chk-sun"),
    chkISS: document.getElementById("chk-iss"),
    chkMoon: document.getElementById("chk-moon"),
    chkClouds: document.getElementById("chk-clouds"),
    chkGalaxy: document.getElementById("chk-galaxy"),
    chkTrajectories: document.getElementById("chk-trajectories"),
    
    moonInfo: document.getElementById("moonInfo"),
    moonData: document.getElementById("moonData"),
    moonCanvas: document.getElementById("moonCanvas"),
    moonToggle: document.getElementById("moon-toggle"),
    
    btnExit: document.getElementById("btn-exit-iss"),
    btnExitMoon: document.getElementById("btn-exit-moon"),
    btnClear: document.getElementById("btn-clear-cache"),
    btnSkyView: document.getElementById("btn-sky-view"),
    uiToggle: document.getElementById("ui-toggle"),
    
    issHint: document.getElementById("issHint"),
    issHud: document.getElementById("iss-hud"),
    hudLat: document.getElementById("hud-lat"),
    hudLon: document.getElementById("hud-lon"),
    hudAlt: document.getElementById("hud-alt"),
    hudSolar: document.getElementById("hud-solar"),
    hudVel: document.getElementById("hud-vel"),
    hudStatus: document.getElementById("hud-status"),
    hudLocation: document.getElementById("hud-location"),
    
    skyModal: document.getElementById("sky-modal"),
    skyClose: document.getElementById("sky-close"),
    skyCanvas: document.getElementById("sky-canvas"),
    skyUserCoords: document.getElementById("sky-user-coords"),
    skyWeather: document.getElementById("sky-weather"),
    
    skyMoonData: document.getElementById("sky-moon-data"),
    skyMoonStatus: document.getElementById("sky-moon-status"),
    skySunData: document.getElementById("sky-sun-data"),
    skySunStatus: document.getElementById("sky-sun-status"),
    skySunTimes: document.getElementById("sky-sun-times"),
    skyMoonTimes: document.getElementById("sky-moon-times"),

    
};

el.cityInput = document.getElementById('city-input');
el.searchResults = document.getElementById('search-results');

    el.btnShowPlanets = document.getElementById('btn-show-planets');
el.btnShowStars = document.getElementById('btn-show-stars');
el.btnTrajectories = document.getElementById('btn-trajectories');

let skyScene, skyCamera, skyRenderer, skyControls, skyAnimationId;
let skyMoonMesh, skySunMesh, skyInitialized = false;
let skySunLight;
let targetLocationOffset = null;
let currentSkyLat = null, currentSkyLon = null;
let sunTrajectoryLine = null, moonTrajectoryLine = null;
let celestialObjects = [];

let skyIssMesh = null;       
let skyIssTrajectory = null;

const BRIGHT_STARS = [
   
    { name: "–°–∏—Ä–∏—É—Å", ra: 6.75, dec: -16.72, mag: -1.46 },
    { name: "–ö–∞–Ω–æ–ø—É—Å", ra: 6.40, dec: -52.70, mag: -0.72 },
    { name: "–¢–æ–ª–∏–º–∞–Ω (Œ± –¶–µ–Ω—Ç–∞–≤—Ä–∞)", ra: 14.66, dec: -60.83, mag: -0.27 },
    { name: "–ê—Ä–∫—Ç—É—Ä", ra: 14.26, dec: 19.18, mag: -0.05 },
    { name: "–í–µ–≥–∞", ra: 18.62, dec: 38.78, mag: 0.03 },
    { name: "–ö–∞–ø–µ–ª–ª–∞", ra: 5.28, dec: 45.99, mag: 0.08 },
    { name: "–†–∏–≥–µ–ª—å", ra: 5.24, dec: -8.20, mag: 0.13 },
    { name: "–ü—Ä–æ—Ü–∏–æ–Ω", ra: 7.66, dec: 5.22, mag: 0.38 },
    { name: "–ë–µ—Ç–µ–ª—å–≥–µ–π–∑–µ", ra: 5.92, dec: 7.41, mag: 0.50 },
    { name: "–ê—Ö–µ—Ä–Ω–∞—Ä", ra: 1.63, dec: -57.24, mag: 0.46 },
    { name: "–•–∞–¥–∞—Ä (Œ≤ –¶–µ–Ω—Ç–∞–≤—Ä–∞)", ra: 14.06, dec: -60.37, mag: 0.61 },
    { name: "–ê–ª—å—Ç–∞–∏—Ä", ra: 19.85, dec: 8.87, mag: 0.77 },
    { name: "–ê–∫—Ä—É–∫—Å (Œ± –Æ–∂.–ö—Ä–µ—Å—Ç–∞)", ra: 12.44, dec: -63.10, mag: 0.76 },
    { name: "–ê–ª—å–¥–µ–±–∞—Ä–∞–Ω", ra: 4.60, dec: 16.51, mag: 0.85 },
    { name: "–ê–Ω—Ç–∞—Ä–µ—Å", ra: 16.49, dec: -26.43, mag: 1.06 },
    { name: "–°–ø–∏–∫–∞", ra: 13.42, dec: -11.16, mag: 1.04 },
    { name: "–ü–æ–ª–ª—É–∫—Å", ra: 7.76, dec: 28.03, mag: 1.14 },
    { name: "–§–æ–º–∞–ª—å–≥–∞—É—Ç", ra: 22.96, dec: -29.62, mag: 1.16 },
    { name: "–î–µ–Ω–µ–±", ra: 20.69, dec: 45.28, mag: 1.25 },
    { name: "–ú–∏–º–æ–∑–∞ (Œ≤ –Æ–∂.–ö—Ä–µ—Å—Ç–∞)", ra: 12.80, dec: -59.69, mag: 1.25 },
    { name: "–†–µ–≥—É–ª", ra: 10.14, dec: 11.97, mag: 1.35 },
    { name: "–ê–¥–∞—Ä–∞", ra: 6.98, dec: -28.97, mag: 1.50 },
    { name: "–ö–∞—Å—Ç–æ—Ä", ra: 7.58, dec: 31.89, mag: 1.58 },
    { name: "–ì–∞–∫—Ä—É–∫—Å (Œ≥ –Æ–∂.–ö—Ä–µ—Å—Ç–∞)", ra: 12.53, dec: -57.11, mag: 1.63 },
    { name: "–®–∞—É–ª–∞", ra: 17.56, dec: -37.10, mag: 1.62 },
    

    { name: "–ë–µ–ª–ª–∞—Ç—Ä–∏–∫—Å", ra: 5.42, dec: 6.35, mag: 1.64 },
    { name: "–≠–ª—å–Ω–∞—Ç", ra: 5.44, dec: 28.61, mag: 1.65 },
    { name: "–ú–∏–∞–ø–ª–∞—Ü–∏–¥—É—Å", ra: 9.22, dec: -69.72, mag: 1.67 },
    { name: "–ê–ª—å–Ω–∏–ª–∞–º (–ü–æ—è—Å –û—Ä–∏–æ–Ω–∞)", ra: 5.60, dec: -1.20, mag: 1.69 },
    { name: "–ê–ª—å–Ω–∞–∏—Ä", ra: 22.14, dec: -46.96, mag: 1.74 },
    { name: "–ê–ª–∏–æ—Ç (–ë. –ú–µ–¥–≤–µ–¥–∏—Ü–∞)", ra: 12.90, dec: 55.96, mag: 1.77 },
    { name: "–ê–ª—å–Ω–∏—Ç–∞–∫ (–ü–æ—è—Å –û—Ä–∏–æ–Ω–∞)", ra: 5.68, dec: -1.94, mag: 1.77 },
    { name: "–î—É–±—Ö–µ (–ë. –ú–µ–¥–≤–µ–¥–∏—Ü–∞)", ra: 11.06, dec: 61.75, mag: 1.79 },
    { name: "–ú–∏—Ä—Ñ–∞–∫", ra: 3.41, dec: 49.86, mag: 1.79 },
    { name: "–í–µ–∑–µ–Ω", ra: 7.14, dec: -26.39, mag: 1.83 },
    { name: "–°–∞—Ä–≥–∞—Å", ra: 17.62, dec: -43.00, mag: 1.87 },
    { name: "–ö–∞—É—Å –ê—É—Å—Ç—Ä–∞–ª–∏—Å", ra: 18.40, dec: -34.38, mag: 1.85 },
    { name: "–ê–≤–∏–æ—Ä", ra: 8.38, dec: -59.51, mag: 1.86 },
    { name: "–ê–ª—å–∫–∞–∏–¥ (–ë. –ú–µ–¥–≤–µ–¥–∏—Ü–∞)", ra: 13.79, dec: 49.31, mag: 1.86 },
    { name: "–ú–µ–Ω–∫–∞–ª–∏–Ω–∞–Ω", ra: 5.99, dec: 44.95, mag: 1.90 },
    { name: "–ê—Ç—Ä–∏—è", ra: 16.81, dec: -69.03, mag: 1.91 },
    { name: "–ê–ª—å—Ö–µ–Ω–∞", ra: 6.63, dec: 16.39, mag: 1.93 },
    { name: "–ü–∏–∫–æ–∫", ra: 20.42, dec: -56.74, mag: 1.94 },
    { name: "–ü–æ–ª—è—Ä–Ω–∞—è –∑–≤–µ–∑–¥–∞", ra: 2.53, dec: 89.26, mag: 1.97 }, 
    { name: "–ú–∏—Ä–∑–∞–º", ra: 6.38, dec: -17.96, mag: 1.98 },
    { name: "–ê–ª—å—Ñ–∞—Ä–¥", ra: 9.46, dec: -8.66, mag: 1.98 },
    { name: "–•–∞–º–∞–ª—å", ra: 2.12, dec: 23.46, mag: 2.00 },
    { name: "–ú–∏–Ω—Ç–∞–∫–∞ (–ü–æ—è—Å –û—Ä–∏–æ–Ω–∞)", ra: 5.53, dec: -0.30, mag: 2.23 },
    { name: "–î–µ–Ω–µ–±–æ–ª–∞", ra: 11.82, dec: 14.57, mag: 2.13 },
    { name: "–ê–ª—å—Ñ–µ—Ä–∞—Ü", ra: 0.14, dec: 29.09, mag: 2.06 }
];

let planetsVisible = false;
let starsVisible = false;

function showAllPlanets() {
    if (!currentSkyLat || !currentSkyLon) return;
    
    const planetNames = ['–ú–µ—Ä–∫—É—Ä–∏–π', '–í–µ–Ω–µ—Ä–∞', '–ú–∞—Ä—Å', '–Æ–ø–∏—Ç–µ—Ä', '–°–∞—Ç—É—Ä–Ω', '–£—Ä–∞–Ω', '–ù–µ–ø—Ç—É–Ω', '–ü–ª—É—Ç–æ–Ω'];
    
    // –£–¥–∞–ª—è–µ–º —Ç–æ–ª—å–∫–æ –ø–ª–∞–Ω–µ—Ç—ã
    celestialObjects = celestialObjects.filter(obj => {
        if (obj.userData.type === 'planet') {
            skyScene.remove(obj);
            obj.traverse(child => {
                if (child.geometry) child.geometry.dispose();
                if (child.material) {
                    if (Array.isArray(child.material)) {
                        child.material.forEach(mat => mat.dispose());
                    } else {
                        child.material.dispose();
                    }
                }
            });
            return false;
        }
        return true;
    });
    
    if (planetsVisible) {
        planetsVisible = false;
        el.btnShowPlanets.classList.remove('active');
        return;
    }
    
    const now = new Date();
    const jd = getJulianDate(now);
    
    planetNames.forEach(name => {
        const position = getPlanetPosition(name, jd, currentSkyLat, currentSkyLon);
        if (position) {
            const obj = createCelestialObject(name, position.azimuth, position.altitude, 'planet');
            if (obj) {
                skyScene.add(obj);
                celestialObjects.push(obj);
            }
        }
    });
    
    planetsVisible = true;
    el.btnShowPlanets.classList.add('active');
}

function showAllStars() {
    if (!currentSkyLat || !currentSkyLon) return;
    
    // –£–¥–∞–ª—è–µ–º —Ç–æ–ª—å–∫–æ –∑–≤—ë–∑–¥—ã
    celestialObjects = celestialObjects.filter(obj => {
        if (obj.userData.type === 'star') {
            skyScene.remove(obj);
            obj.traverse(child => {
                if (child.geometry) child.geometry.dispose();
                if (child.material) {
                    if (Array.isArray(child.material)) {
                        child.material.forEach(mat => mat.dispose());
                    } else {
                        child.material.dispose();
                    }
                }
            });
            return false;
        }
        return true;
    });
    
    if (starsVisible) {
        starsVisible = false;
        el.btnShowStars.classList.remove('active');
        return;
    }
    
    const now = new Date();
    const jd = getJulianDate(now);
    
    BRIGHT_STARS.forEach(star => {
        const position = getStarPosition(star, currentSkyLat, currentSkyLon, jd);
        if (position) {
            const obj = createCelestialObject(star.name, position.azimuth, position.altitude, 'star');
            if (obj) {
                skyScene.add(obj);
                celestialObjects.push(obj);
            }
        }
    });
    
    starsVisible = true;
    el.btnShowStars.classList.add('active');
}

el.btnShowPlanets.addEventListener('click', showAllPlanets);
el.btnShowStars.addEventListener('click', showAllStars);

async function fetchWeather(lat, lon) {
    try {
        const url = `https://api.open-meteo.com/v1/forecast?latitude=${lat}&longitude=${lon}&current=temperature_2m,relative_humidity_2m,apparent_temperature,weather_code,wind_speed_10m,wind_direction_10m,pressure_msl&timezone=auto`;
        const response = await fetch(url);
        if (!response.ok) throw new Error('Weather API error');
        const data = await response.json();
        return data;
    } catch (e) {
        console.error('Weather fetch error:', e);
        return null;
    }
}

function getWeatherIcon(code) {
    const icons = {
        0: '‚òÄÔ∏è', 1: 'üå§Ô∏è', 2: '‚õÖ', 3: '‚òÅÔ∏è',
        45: 'üå´Ô∏è', 48: 'üå´Ô∏è',
        51: 'üåßÔ∏è', 53: 'üåßÔ∏è', 55: 'üåßÔ∏è',
        56: 'üå®Ô∏è', 57: 'üå®Ô∏è',
        61: 'üåßÔ∏è', 63: 'üåßÔ∏è', 65: 'üåßÔ∏è',
        66: 'üå®Ô∏è', 67: 'üå®Ô∏è',
        71: '‚ùÑÔ∏è', 73: '‚ùÑÔ∏è', 75: '‚ùÑÔ∏è',
        77: 'üå®Ô∏è',
        80: 'üå¶Ô∏è', 81: 'üå¶Ô∏è', 82: 'üå¶Ô∏è',
        85: 'üå®Ô∏è', 86: 'üå®Ô∏è',
        95: '‚õàÔ∏è',
        96: '‚õàÔ∏è', 99: '‚õàÔ∏è'
    };
    return icons[code] || 'üå°Ô∏è';
}

function getWeatherDescription(code) {
    const descriptions = {
        0: '–Ø—Å–Ω–æ', 1: '–ü—Ä–µ–∏–º. —è—Å–Ω–æ', 2: '–ü–µ—Ä–µ–º–µ–Ω–Ω–∞—è –æ–±–ª–∞—á–Ω–æ—Å—Ç—å', 3: '–ü–∞—Å–º—É—Ä–Ω–æ',
        45: '–¢—É–º–∞–Ω', 48: '–ò–∑–º–æ—Ä–æ–∑—å',
        51: '–õ—ë–≥–∫–∞—è –º–æ—Ä–æ—Å—å', 53: '–ú–æ—Ä–æ—Å—å', 55: '–°–∏–ª—å–Ω–∞—è –º–æ—Ä–æ—Å—å',
        56: '–õ–µ–¥—è–Ω–∞—è –º–æ—Ä–æ—Å—å', 57: '–°–∏–ª—å–Ω–∞—è –ª–µ–¥—è–Ω–∞—è –º–æ—Ä–æ—Å—å',
        61: '–ù–µ–±–æ–ª—å—à–æ–π –¥–æ–∂–¥—å', 63: '–î–æ–∂–¥—å', 65: '–°–∏–ª—å–Ω—ã–π –¥–æ–∂–¥—å',
        66: '–õ–µ–¥—è–Ω–æ–π –¥–æ–∂–¥—å', 67: '–°–∏–ª—å–Ω—ã–π –ª–µ–¥—è–Ω–æ–π –¥–æ–∂–¥—å',
        71: '–ù–µ–±–æ–ª—å—à–æ–π —Å–Ω–µ–≥', 73: '–°–Ω–µ–≥', 75: '–°–∏–ª—å–Ω—ã–π —Å–Ω–µ–≥',
        77: '–°–Ω–µ–∂–Ω–∞—è –∫—Ä—É–ø–∞',
        80: '–ù–µ–±–æ–ª—å—à–æ–π –ª–∏–≤–µ–Ω—å', 81: '–õ–∏–≤–µ–Ω—å', 82: '–°–∏–ª—å–Ω—ã–π –ª–∏–≤–µ–Ω—å',
        85: '–°–Ω–µ–∂–Ω—ã–π –¥—É—à', 86: '–°–∏–ª—å–Ω—ã–π —Å–Ω–µ–∂–Ω—ã–π –¥—É—à',
        95: '–ì—Ä–æ–∑–∞',
        96: '–ì—Ä–æ–∑–∞ —Å –≥—Ä–∞–¥–æ–º', 99: '–°–∏–ª—å–Ω–∞—è –≥—Ä–æ–∑–∞ —Å –≥—Ä–∞–¥–æ–º'
    };
    return descriptions[code] || '–ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö';
}

function getWindDirection(degrees) {
    const directions = ['–°', '–°–í', '–í', '–Æ–í', '–Æ', '–Æ–ó', '–ó', '–°–ó'];
    const index = Math.round(degrees / 45) % 8;
    return directions[index];
}

function displayWeather(data) {
    if (!data || !data.current) {
        el.skyWeather.innerHTML = `
            <div class="weather-title">üå°Ô∏è –ü–æ–≥–æ–¥–∞</div>
            <div class="weather-loading">–î–∞–Ω–Ω—ã–µ –Ω–µ–¥–æ—Å—Ç—É–ø–Ω—ã</div>
        `;
        return;
    }

    const current = data.current;
    const weatherCode = current.weather_code;
    const icon = getWeatherIcon(weatherCode);
    const desc = getWeatherDescription(weatherCode);
    const temp = Math.round(current.temperature_2m);
    const feelsLike = Math.round(current.apparent_temperature);
    const humidity = current.relative_humidity_2m;
    const windSpeed = current.wind_speed_10m;
    const windDir = getWindDirection(current.wind_direction_10m);
    const pressure = Math.round(current.pressure_msl);

    el.skyWeather.innerHTML = `
        <div class="weather-title">üå°Ô∏è –ü–æ–≥–æ–¥–∞ —Å–µ–π—á–∞—Å</div>
        <div class="weather-main">
            <span class="weather-icon">${icon}</span>
            <span class="weather-temp">${temp}¬∞C</span>
        </div>
        <div class="weather-desc">${desc}</div>
        <div class="weather-details">
            <div>–û—â—É—â–∞–µ—Ç—Å—è: <span>${feelsLike}¬∞C</span></div>
            <div>–í–ª–∞–∂–Ω–æ—Å—Ç—å: <span>${humidity}%</span></div>
            <div>–í–µ—Ç–µ—Ä: <span>${windSpeed} –∫–º/—á ${windDir}</span></div>
            <div>–î–∞–≤–ª–µ–Ω–∏–µ: <span>${pressure} –≥–ü–∞</span></div>
        </div>
    `;
}



function equatorialToHorizontal(ra, dec, lat, lon, jd) {
    const DEG = Math.PI / 180;
    const gmst = getGMST(jd);
    const lst = gmst + lon * DEG;
    
    let ha = lst - ra;
    
    const latRad = lat * DEG;
    const sinAlt = Math.sin(dec) * Math.sin(latRad) + 
                   Math.cos(dec) * Math.cos(latRad) * Math.cos(ha);
    const altitude = Math.asin(sinAlt) * (180 / Math.PI);
    
    const cosAz = (Math.sin(dec) - Math.sin(altitude * DEG) * Math.sin(latRad)) / 
                  (Math.cos(altitude * DEG) * Math.cos(latRad));
    let azimuth = Math.acos(Math.max(-1, Math.min(1, cosAz))) * (180 / Math.PI);
    
    if (Math.sin(ha) > 0) {
        azimuth = 360 - azimuth;
    }
    
    return { azimuth, altitude };
}

function getStarPosition(star, lat, lon, jd) {
    const raRad = star.ra * (Math.PI / 12);
    const decRad = star.dec * (Math.PI / 180);
    
    return equatorialToHorizontal(raRad, decRad, lat, lon, jd);
}

function createCelestialObject(name, azimuth, altitude, type = 'star') {
    const azRad = azimuth * Math.PI / 180;
    const altRad = altitude * Math.PI / 180;
    const r = 35; 
    
    const x = -r * Math.cos(altRad) * Math.sin(azRad);
    const y = r * Math.sin(altRad);
    const z = r * Math.cos(altRad) * Math.cos(azRad);
    
    const group = new THREE.Group();
    
    let sphereGeo, sphereMat, sphere;
    
    if(type === 'planet') {
        sphereGeo = new THREE.SphereGeometry(0.25, 16, 16);
        sphereMat = new THREE.MeshBasicMaterial({ 
            color: 0xffd54f,
            emissive: 0xffb74d
        });
        sphere = new THREE.Mesh(sphereGeo, sphereMat);
        group.add(sphere);
        
        const glowGeo = new THREE.SphereGeometry(0.5, 16, 16);
        const glowMat = new THREE.MeshBasicMaterial({
            color: 0xffd54f,
            transparent: true,
            opacity: 0.3,
            side: THREE.BackSide
        });
        const glow = new THREE.Mesh(glowGeo, glowMat);
        group.add(glow);
    } else {
        sphereGeo = new THREE.SphereGeometry(0.15, 8, 8);
        sphereMat = new THREE.MeshBasicMaterial({ 
            color: 0xffffff,
            emissive: 0xaaaaff
        });
        sphere = new THREE.Mesh(sphereGeo, sphereMat);
        group.add(sphere);
    }
    
    // --- –¢–µ–∫—Å—Ç (–∞–¥–∞–ø—Ç–∏–≤–Ω—ã–π —Ä–∞–∑–º–µ—Ä –∫–∞–Ω–≤–∞—Å–∞) ---
    const textLength = name.length;
    const canvasWidth = Math.max(512, textLength * 45);
    const canvas = document.createElement('canvas');
    canvas.width = canvasWidth;
    canvas.height = 128;
    const ctx = canvas.getContext('2d');
    
    ctx.font = 'bold 64px Arial';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    
    ctx.strokeStyle = 'rgba(0, 0, 0, 0.9)';
    ctx.lineWidth = 10;
    ctx.lineJoin = 'round';
    ctx.strokeText(name, canvasWidth / 2, 64);
    
    const labelColor = type === 'planet' ? '#ffd54f' : '#ffffff';
    ctx.shadowColor = labelColor;
    ctx.shadowBlur = 0;
    ctx.fillStyle = labelColor;
    ctx.fillText(name, canvasWidth / 2, 64);
    
    const texture = new THREE.CanvasTexture(canvas);
    
    const spriteMat = new THREE.SpriteMaterial({ 
        map: texture, 
        transparent: true,
        depthTest: false 
    });
    
    const sprite = new THREE.Sprite(spriteMat);
    sprite.position.y = type === 'planet' ? 1.5 : 1.2;
    
    // –ú–∞—Å—à—Ç–∞–± –ø—Ä–æ–ø–æ—Ä—Ü–∏–æ–Ω–∞–ª–µ–Ω —à–∏—Ä–∏–Ω–µ –∫–∞–Ω–≤–∞—Å–∞
    const scaleX = (canvasWidth / 512) * 6.0;
    sprite.scale.set(scaleX, 1.5, 1); 
    
    group.add(sprite);
    
    group.position.set(x, y, z);
    group.userData = { name, type, azimuth, altitude };
    
    return group;
}


function clearCelestialObjects() {
    celestialObjects.forEach(obj => {
        skyScene.remove(obj);
        obj.traverse(child => {
            if(child.geometry) child.geometry.dispose();
            if(child.material) {
                if(Array.isArray(child.material)) {
                    child.material.forEach(mat => mat.dispose());
                } else {
                    child.material.dispose();
                }
            }
        });
    });
    celestialObjects = [];
}

function addCelestialObject(name, lat, lon, type = 'auto') {
    if(!currentSkyLat || !currentSkyLon) return;
    
    const now = new Date();
    const jd = getJulianDate(now);
    
    let position = null;
    let objType = type;
    
  
    const planetNames = ['–º–µ—Ä–∫—É—Ä–∏–π', '–≤–µ–Ω–µ—Ä–∞', '–º–∞—Ä—Å', '—é–ø–∏—Ç–µ—Ä', '—Å–∞—Ç—É—Ä–Ω', '—É—Ä–∞–Ω', '–Ω–µ–ø—Ç—É–Ω', '–ø–ª—É—Ç–æ–Ω'];

    
    if(planetNames.includes(name.toLowerCase())) {
        position = getPlanetPosition(name, jd, currentSkyLat, currentSkyLon);
        objType = 'planet';
    } else {
        const star = BRIGHT_STARS.find(s => s.name.toLowerCase() === name.toLowerCase());
        if(star) {
            position = getStarPosition(star, currentSkyLat, currentSkyLon, jd);
            objType = 'star';
        }
    }
    
    if(!position) return null;
    
    const obj = createCelestialObject(name, position.azimuth, position.altitude, objType);
    if(obj) {
        skyScene.add(obj);
        celestialObjects.push(obj);
        
        // –í–µ–∫—Ç–æ—Ä –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏—è –Ω–∞ –æ–±—ä–µ–∫—Ç
        const starDir = new THREE.Vector3(obj.position.x, obj.position.y, obj.position.z).normalize();
        
        // –ü–æ–∑–∏—Ü–∏—è –∫–∞–º–µ—Ä—ã (—Å–º–æ—Ç—Ä–∏–º —Å–∫–≤–æ–∑—å —Ü–µ–Ω—Ç—Ä)
        const cameraTargetPos = starDir.clone().negate().multiplyScalar(0.1);

        skyControls.target.set(0, 0, 0);
        
        const startTime = performance.now();
        const duration = 1200;
        const startPos = skyCamera.position.clone();
        
        function animateCamera(time) {
            const elapsed = time - startTime;
            const progress = Math.min(elapsed / duration, 1);
            const eased = easeInOutCubic(progress);
            
            skyCamera.position.lerpVectors(startPos, cameraTargetPos, eased);
            skyControls.target.set(0, 0, 0); 
            skyControls.update();
            
            if(progress < 1) {
                requestAnimationFrame(animateCamera);
            }
        }
        
        requestAnimationFrame(animateCamera);
        
        return obj;
    }
    
    return null;
}


function createTrajectory(type, lat, lon) {
    const points = [];
    const now = new Date();
    now.setHours(0, 0, 0, 0);
    
    for(let i = 0; i < 1440; i += 15) {
        const time = new Date(now.getTime() + i * 60000);
        const jd = getJulianDate(time);
        
        let position;
        if(type === 'sun') {
            position = getSunPosition(lat, lon, time);
        } else {
            position = getMoonPosition(lat, lon, time);
        }
        
        if(position.altitude > -5) {
            const azRad = position.azimuth * Math.PI / 180;
            const altRad = position.altitude * Math.PI / 180;
            const r = 42;
            
            points.push(new THREE.Vector3(
                -r * Math.cos(altRad) * Math.sin(azRad),
                r * Math.sin(altRad),
                r * Math.cos(altRad) * Math.cos(azRad)
            ));
        }
    }
    
    if(points.length < 2) return null;
    
    const geometry = new THREE.BufferGeometry().setFromPoints(points);
    const material = new THREE.LineDashedMaterial({
        color: type === 'sun' ? 0xffd54f : 0x4fc3f7,
        dashSize: 0.5,
        gapSize: 0.3,
        transparent: true,
        opacity: 0.6,
        depthTest: false
    });
    
    const line = new THREE.Line(geometry, material);
    line.computeLineDistances();
    
    return line;
}

function updateTrajectories() {
    if(sunTrajectoryLine) {
        skyScene.remove(sunTrajectoryLine);
        sunTrajectoryLine.geometry.dispose();
        sunTrajectoryLine.material.dispose();
        sunTrajectoryLine = null;
    }
    
    if(moonTrajectoryLine) {
        skyScene.remove(moonTrajectoryLine);
        moonTrajectoryLine.geometry.dispose();
        moonTrajectoryLine.material.dispose();
        moonTrajectoryLine = null;
    }
    
    if(trajectoriesVisible && currentSkyLat !== null && currentSkyLon !== null) {
        sunTrajectoryLine = createTrajectory('sun', currentSkyLat, currentSkyLon);
        moonTrajectoryLine = createTrajectory('moon', currentSkyLat, currentSkyLon);
        
        if(sunTrajectoryLine) skyScene.add(sunTrajectoryLine);
        if(moonTrajectoryLine) skyScene.add(moonTrajectoryLine);
    }
}



function initSkyView() {
    if (skyInitialized) return;
    
    const container = document.getElementById('sky-container');
    const width = container.clientWidth;
    const height = container.clientHeight;
    
    skyScene = new THREE.Scene();
    skyScene.background = new THREE.Color(0x000510);
    
    skyCamera = new THREE.PerspectiveCamera(60, width / height, 0.1, 1000);
    skyCamera.position.set(0, 0, 0.1);
    
    skyRenderer = new THREE.WebGLRenderer({ canvas: el.skyCanvas, antialias: true });
    skyRenderer.setSize(width, height);
    skyRenderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    
    skyControls = new OrbitControls(skyCamera, skyRenderer.domElement);
    skyControls.enableZoom = true;
    skyControls.enablePan = false;
    skyControls.rotateSpeed = 0.5;
    skyControls.minDistance = 0.1;
    skyControls.maxDistance = 0.1;
    skyControls.target.set(0, 0, -1);

    skySunLight = new THREE.DirectionalLight(0xffffff, 2.5);
    skyScene.add(skySunLight);
    skyScene.add(new THREE.AmbientLight(0xffffff, 0.3));

    const starCount = 3000;
    const starsGeo = new THREE.BufferGeometry();
    const starPos = new Float32Array(starCount * 3);
    for (let i = 0; i < starCount; i++) {
        const theta = Math.random() * Math.PI * 2;
        const phi = Math.acos(2 * Math.random() - 1);
        const r = 45;
        starPos[i * 3] = -r * Math.sin(phi) * Math.cos(theta);
        starPos[i * 3 + 1] = r * Math.sin(phi) * Math.sin(theta);
        starPos[i * 3 + 2] = r * Math.cos(phi);
    }
    starsGeo.setAttribute('position', new THREE.BufferAttribute(starPos, 3));
    skyScene.add(new THREE.Points(starsGeo, new THREE.PointsMaterial({ color: 0xffffff, size: 0.15, transparent: true, opacity: 0.8 })));

    const sunGroup = new THREE.Group();
    const sunCore = new THREE.Mesh(new THREE.SphereGeometry(2.2, 32, 32), new THREE.MeshBasicMaterial({ color: 0xffffff }));
    sunGroup.add(sunCore);
    for(let i=1; i<=4; i++) {
        const glow = new THREE.Mesh(
            new THREE.SphereGeometry(2.2 + (i*1.8), 32, 32),
            new THREE.MeshBasicMaterial({ color: 0xffdd44, transparent: true, opacity: 0.5 / i, side: THREE.BackSide })
        );
        sunGroup.add(glow);
    }
    skySunMesh = sunGroup;
    skyScene.add(skySunMesh);

    const moonGeo = new THREE.SphereGeometry(2.1, 32, 32);
    const moonMat = new THREE.MeshPhongMaterial({ 
        map: loadTextureWithCache('./textures/moon-color.jpg'),
        bumpMap: loadTextureWithCache("./textures/moon-bump.jpg"),
        bumpScale: 0.05,
        shininess: 0
    });
    skyMoonMesh = new THREE.Mesh(moonGeo, moonMat);
    skyScene.add(skyMoonMesh);

    const gridMat = new THREE.LineBasicMaterial({ color: 0x4fc3f7, transparent: true, opacity: 0.3, depthWrite: false });
    const rGrid = 42;
    for (let az = 0; az < 360; az += 30) {
        const points = [];
        const azRad = az * Math.PI / 180;
        for (let alt = 0; alt <= 90; alt += 5) {
            const altRad = alt * Math.PI / 180;
            points.push(new THREE.Vector3(-rGrid * Math.cos(altRad) * Math.sin(azRad), rGrid * Math.sin(altRad), rGrid * Math.cos(altRad) * Math.cos(azRad)));
        }
        skyScene.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints(points), gridMat));
    }
    for (let alt = 0; alt <= 90; alt += 15) {
        const points = [];
        const altRad = alt * Math.PI / 180;
        for (let az = 0; az <= 360; az += 5) {
            const azRad = az * Math.PI / 180;
            points.push(new THREE.Vector3(-rGrid * Math.cos(altRad) * Math.sin(azRad), rGrid * Math.sin(altRad), rGrid * Math.cos(altRad) * Math.cos(azRad)));
        }
        skyScene.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints(points), gridMat));
    }

    const horizonPoints = [];
    for (let az = 0; az <= 360; az += 2) {
        const azRad = az * Math.PI / 180;
        horizonPoints.push(new THREE.Vector3(-rGrid * Math.sin(azRad), 0, rGrid * Math.cos(azRad)));
    }
    skyScene.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints(horizonPoints), new THREE.LineBasicMaterial({ color: 0x4fc3f7, transparent: true, opacity: 0.8 })));

    const directions = [
        { name: '–°–ï–í–ï–†', az: 0, color: '#ff6b6b' },
        { name: '–°–í', az: 45, color: '#e3f2fd' },
        { name: '–í–û–°–¢–û–ö', az: 90, color: '#ffd54f' },
        { name: '–Æ–í', az: 135, color: '#e3f2fd' },
        { name: '–Æ–ì', az: 180, color: '#81c784' },
        { name: '–Æ–ó', az: 225, color: '#e3f2fd' },
        { name: '–ó–ê–ü–ê–î', az: 270, color: '#4fc3f7' },
        { name: '–°–ó', az: 315, color: '#e3f2fd' }
    ];
    
    directions.forEach(dir => {
        const azRad = dir.az * Math.PI / 180;
        const rLabel = 43;
        
        const canvas = document.createElement('canvas');
        canvas.width = 256; canvas.height = 128;
        const ctx = canvas.getContext('2d');
        
        const fontSize = dir.name.length > 2 ? '48px' : '64px';
        ctx.font = `bold ${fontSize} Arial`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        
        ctx.strokeStyle = 'rgba(10, 22, 40, 0.9)';
        ctx.lineWidth = 10;
        ctx.strokeText(dir.name, 128, 64);
        
        ctx.shadowColor = dir.color;
        ctx.shadowBlur = 15;
        
        ctx.fillStyle = dir.color;
        ctx.fillText(dir.name, 128, 64);
        
        const texture = new THREE.CanvasTexture(canvas);
        const spriteMat = new THREE.SpriteMaterial({ 
            map: texture, 
            transparent: true,
            depthTest: false,
            renderOrder: 10
        });
        
        const sprite = new THREE.Sprite(spriteMat);
        
        sprite.position.set(
            -rLabel * Math.sin(azRad), 
            1.2, 
            rLabel * Math.cos(azRad)
        );
        
        const scaleW = dir.name.length > 2 ? 7 : 5;
        sprite.scale.set(scaleW, 3.5, 1);
        
        skyScene.add(sprite);
    });
    skyInitialized = true;
}


function getSatelliteTopo(obsLat, obsLon, satLat, satLon, satAltKm) {
    const R = 6371; // –†–∞–¥–∏—É—Å –ó–µ–º–ª–∏
    const DEG2RAD = Math.PI / 180;
    
    // –ö–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã –Ω–∞–±–ª—é–¥–∞—Ç–µ–ª—è –≤ –¥–µ–∫–∞—Ä—Ç–æ–≤–æ–π —Å–∏—Å—Ç–µ–º–µ (ECEF)
    const lat1 = obsLat * DEG2RAD;
    const lon1 = obsLon * DEG2RAD;
    const r1 = R;
    const x1 = r1 * Math.cos(lat1) * Math.cos(lon1);
    const y1 = r1 * Math.cos(lat1) * Math.sin(lon1);
    const z1 = r1 * Math.sin(lat1);

    // –ö–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã —Å–ø—É—Ç–Ω–∏–∫–∞ –≤ ECEF
    const lat2 = satLat * DEG2RAD;
    const lon2 = satLon * DEG2RAD;
    const r2 = R + satAltKm;
    const x2 = r2 * Math.cos(lat2) * Math.cos(lon2);
    const y2 = r2 * Math.cos(lat2) * Math.sin(lon2);
    const z2 = r2 * Math.sin(lat2);

    // –í–µ–∫—Ç–æ—Ä –æ—Ç –Ω–∞–±–ª—é–¥–∞—Ç–µ–ª—è –∫ —Å–ø—É—Ç–Ω–∏–∫—É
    const dx = x2 - x1;
    const dy = y2 - y1;
    const dz = z2 - z1;

    // –ü—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ –≤ —Ç–æ–ø–æ—Ü–µ–Ω—Ç—Ä–∏—á–µ—Å–∫—É—é —Å–∏—Å—Ç–µ–º—É (–í–æ—Å—Ç–æ–∫-–°–µ–≤–µ—Ä-–í–µ—Ä—Ö)
    const sinLat = Math.sin(lat1);
    const cosLat = Math.cos(lat1);
    const sinLon = Math.sin(lon1);
    const cosLon = Math.cos(lon1);

    const topS = -sinLat * cosLon * dx - sinLat * sinLon * dy + cosLat * dz; // North
    const topE = -sinLon * dx + cosLon * dy;                                 // East
    const topZ = cosLat * cosLon * dx + cosLat * sinLon * dy + sinLat * dz;  // Up

    // –ê–∑–∏–º—É—Ç –∏ –í—ã—Å–æ—Ç–∞
    const az = Math.atan2(topE, topS);
    const range = Math.sqrt(topE*topE + topS*topS + topZ*topZ);
    const alt = Math.asin(topZ / range);

    return { 
        azimuth: (az * 180 / Math.PI + 360) % 360, 
        altitude: alt * 180 / Math.PI 
    };
}


function updateSkyISS() {
    // –ï—Å–ª–∏ –ú–ö–° –Ω–µ –Ω–∞–π–¥–µ–Ω–∞, —Ç—Ä–∞–µ–∫—Ç–æ—Ä–∏–∏ –≤—ã–∫–ª—é—á–µ–Ω—ã –∏–ª–∏ –Ω–µ—Ç GPS –Ω–∞–±–ª—é–¥–∞—Ç–µ–ª—è - —É–¥–∞–ª—è–µ–º –∏ –≤—ã—Ö–æ–¥–∏–º
  if (!issHasFix || !trajectoriesVisible || currentSkyLat === null) {
        if (skyIssMesh) { skyScene.remove(skyIssMesh); skyIssMesh = null; }
        if (skyIssTrajectory) { skyScene.remove(skyIssTrajectory); skyIssTrajectory = null; }
        return;
    }
    // 1. –°—á–∏—Ç–∞–µ–º —Ç–µ–∫—É—â–µ–µ –ø–æ–ª–æ–∂–µ–Ω–∏–µ
    const topo = getSatelliteTopo(currentSkyLat, currentSkyLon, issDisplayData.lat, issDisplayData.lon, issDisplayData.alt);
    
    // –ü–µ—Ä–µ–≤–æ–¥ –≤ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã —Å—Ü–µ–Ω—ã (—Å—Ñ–µ—Ä–∞ —Ä–∞–¥–∏—É—Å–æ–º 35)
    const azRad = topo.azimuth * Math.PI / 180;
    const altRad = topo.altitude * Math.PI / 180;
    const r = 35;
    
    const x = -r * Math.cos(altRad) * Math.sin(azRad);
    const y = r * Math.sin(altRad);
    const z = r * Math.cos(altRad) * Math.cos(azRad);

    // 2. –°–æ–∑–¥–∞–µ–º –∏–ª–∏ –æ–±–Ω–æ–≤–ª—è–µ–º –ú–∞—Ä–∫–µ—Ä –ú–ö–°
    if (!skyIssMesh) {
        skyIssMesh = new THREE.Group();
        
        // –¢–æ—á–∫–∞
        const dot = new THREE.Mesh(
            new THREE.SphereGeometry(0.4, 16, 16),
            new THREE.MeshBasicMaterial({ color: 0xff3333, emissive: 0xff0000 })
        );
        skyIssMesh.add(dot);

        // –¢–µ–∫—Å—Ç
        const canvas = document.createElement('canvas');
        canvas.width = 256; canvas.height = 64;
        const ctx = canvas.getContext('2d');
        ctx.font = 'bold 40px Consolas';
        ctx.fillStyle = '#ff7043';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText("–ú–ö–° (ISS)", 128, 32);
        
        const sprite = new THREE.Sprite(new THREE.SpriteMaterial({ 
            map: new THREE.CanvasTexture(canvas), 
            depthTest: false,
            transparent: true 
        }));
        sprite.position.y = 1.5;
        sprite.scale.set(6, 1.5, 1);
        skyIssMesh.add(sprite);
        
        skyScene.add(skyIssMesh);
    }
    
    skyIssMesh.position.set(x, y, z);
    skyIssMesh.lookAt(0, 0, 0);

    // 3. –†–∏—Å—É–µ–º —Ç—Ä–∞–µ–∫—Ç–æ—Ä–∏—é (–≤–µ–∫—Ç–æ—Ä –¥–≤–∏–∂–µ–Ω–∏—è)
    // –ü—Ä–æ–≥–Ω–æ–∑–∏—Ä—É–µ–º —Ç–æ—á–∫—É —á–µ—Ä–µ–∑ 10 –º–∏–Ω—É—Ç (–ú–ö–° –ª–µ—Ç–∏—Ç –±—ã—Å—Ç—Ä–æ, ~4 –≥—Ä–∞–¥/–º–∏–Ω)
    // –£–ø—Ä–æ—â–µ–Ω–Ω–∞—è —ç–∫—Å—Ç—Ä–∞–ø–æ–ª—è—Ü–∏—è: –±–µ—Ä–µ–º —Ç–µ–∫—É—â—É—é —Å–∫–æ—Ä–æ—Å—Ç—å –∏–∑–º–µ–Ω–µ–Ω–∏—è –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç
    // –ù–æ –¥–ª—è –≤–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏–∏ –ø—Ä–æ—â–µ –ø–æ—Å—Ç—Ä–æ–∏—Ç—å –ª–∏–Ω–∏—é –ø–æ –¥–≤—É–º —Ç–æ—á–∫–∞–º
    
    if (skyIssTrajectory) { skyScene.remove(skyIssTrajectory); }

    // –ü—Ä–æ–≥–Ω–æ–∑ –±—É–¥—É—â–µ–π —Ç–æ—á–∫–∏ (–≥—Ä—É–±—ã–π, –Ω–æ –¥–ª—è –∫–æ—Ä–æ—Ç–∫–æ–≥–æ –≤–µ–∫—Ç–æ—Ä–∞ —Ö–≤–∞—Ç–∏—Ç)
    // –ú–ö–° –¥–≤–∏–∂–µ—Ç—Å—è –Ω–∞ –≤–æ—Å—Ç–æ–∫, –Ω–∞–∫–ª–æ–Ω –æ—Ä–±–∏—Ç—ã 51.6. 
    // –î–ª—è —Ç–æ—á–Ω–æ–≥–æ –≤–µ–∫—Ç–æ—Ä–∞ –Ω—É–∂–Ω–æ —Å—á–∏—Ç–∞—Ç—å heading, –Ω–æ –º—ã –≤–æ–∑—å–º–µ–º –ø—Ä–æ—Å—Ç–æ –ª–∏–Ω–∏—é "–Ω–∞–∑–∞–¥" (—Ö–≤–æ—Å—Ç)
    // –∏–ª–∏ "–≤–ø–µ—Ä–µ–¥". –°–¥–µ–ª–∞–µ–º —Ö–≤–æ—Å—Ç.
    
    // –í–µ–∫—Ç–æ—Ä –ø–æ–∑–∏—Ü–∏–∏
    const posVec = new THREE.Vector3(x, y, z);
    
    // –í–µ–∫—Ç–æ—Ä "—Ö–≤–æ—Å—Ç–∞" (–ø—Ä–æ—Å—Ç–æ –≤–∏–∑—É–∞–ª—å–Ω—ã–π —ç—Ñ—Ñ–µ–∫—Ç, –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–Ω—ã–π –∫ –≥–æ—Ä–∏–∑–æ–Ω—Ç—É –∏–ª–∏ –ø–æ –æ—Ä–±–∏—Ç–µ)
    // –ß—Ç–æ–±—ã –Ω–µ —É—Å–ª–æ–∂–Ω—è—Ç—å –º–∞—Ç–µ–º–∞—Ç–∏–∫—É –æ—Ä–±–∏—Ç—ã, –Ω–∞—Ä–∏—Å—É–µ–º –∫—Ä—É–≥ –≤–æ–∫—Ä—É–≥ –Ω–∞–±–ª—é–¥–∞—Ç–µ–ª—è, –ø—Ä–æ—Ö–æ–¥—è—â–∏–π —á–µ—Ä–µ–∑ –ú–ö–°?
    // –ù–µ—Ç, –ª—É—á—à–µ –ø—Ä–æ—Å—Ç–æ –ø—É–Ω–∫—Ç–∏—Ä–Ω—É—é –ª–∏–Ω–∏—é –æ—Ä–±–∏—Ç—ã.
    
    // –°–∞–º—ã–π –ø—Ä–æ—Å—Ç–æ–π –≤–∞—Ä–∏–∞–Ω—Ç —Ç—Ä–∞–µ–∫—Ç–æ—Ä–∏–∏: –∫—Ä—É–≥ –≤—ã—Å–æ—Ç—ã (–æ—Ä–±–∏—Ç–∞ –ú–ö–° –ø—Ä–∏–º–µ—Ä–Ω–æ –∫—Ä—É–≥–æ–≤–∞—è)
    // –ù–æ —ç—Ç–æ —Å–ª–æ–∂–Ω–æ. –ù–∞—Ä–∏—Å—É–µ–º "—Ö–≤–æ—Å—Ç" –Ω–∞ –æ—Å–Ω–æ–≤–µ –ø—Ä–µ–¥—ã–¥—É—â–µ–≥–æ –∫–∞–¥—Ä–∞? –ù–µ—Ç –∏—Å—Ç–æ—Ä–∏–∏.
    // –ù–∞—Ä–∏—Å—É–µ–º –ø—Ä–æ—Å—Ç–æ –∫—Ä–∞—Å–Ω—É—é –ª–∏–Ω–∏—é
    
    const points = [];
    // –¢–µ–∫—É—â–∞—è —Ç–æ—á–∫–∞
    points.push(new THREE.Vector3(x, y, z));
    // –¢–æ—á–∫–∞ "–≤–ø–µ—Ä–µ–¥–∏" (—Å–∏–º—É–ª—è—Ü–∏—è –¥–≤–∏–∂–µ–Ω–∏—è –ø–æ –∞–∑–∏–º—É—Ç—É)
    // –ú–ö–° –≤—Å–µ–≥–¥–∞ –ª–µ—Ç–∏—Ç –ø—Ä–∏–º–µ—Ä–Ω–æ –Ω–∞ –í–æ—Å—Ç–æ–∫ (—Å –≤–∞—Ä–∏–∞—Ü–∏—è–º–∏ –°-–í –∏–ª–∏ –Æ-–í)
    // –î–æ–±–∞–≤–∏–º +5 –≥—Ä–∞–¥—É—Å–æ–≤ –∫ –¥–æ–ª–≥–æ—Ç–µ —Å–ø—É—Ç–Ω–∏–∫–∞ –∏ –ø–µ—Ä–µ—Å—á–∏—Ç–∞–µ–º
    const futureTopo = getSatelliteTopo(currentSkyLat, currentSkyLon, issDisplayData.lat, issDisplayData.lon + 5, issDisplayData.alt);
    const fAz = futureTopo.azimuth * Math.PI / 180;
    const fAlt = futureTopo.altitude * Math.PI / 180;
    
    points.push(new THREE.Vector3(
        -r * Math.cos(fAlt) * Math.sin(fAz),
        r * Math.sin(fAlt),
        r * Math.cos(fAlt) * Math.cos(fAz)
    ));

    const trajGeo = new THREE.BufferGeometry().setFromPoints(points);
    const trajMat = new THREE.LineDashedMaterial({
        color: 0xff3333,
        dashSize: 1,
        gapSize: 0.5,
        opacity: 0.7,
        transparent: true
    });
    
    skyIssTrajectory = new THREE.Line(trajGeo, trajMat);
    skyIssTrajectory.computeLineDistances();
    skyScene.add(skyIssTrajectory);
}




function updateSkySun(lat, lon) {
    if (!skySunMesh) return;
    
    const now = new Date();
    const sunPos = getSunPosition(lat, lon, now);
    
    const azRad = sunPos.azimuth * Math.PI / 180;
    const altRad = sunPos.altitude * Math.PI / 180;
    const r = 35;
    
    const x = -r * Math.cos(altRad) * Math.sin(azRad);
    const y = r * Math.sin(altRad);
    const z = r * Math.cos(altRad) * Math.cos(azRad);
    
    skySunMesh.position.set(x, y, z);
    if (skySunLight) skySunLight.position.set(x, y, z);

    let finalColor;
    if (sunPos.altitude > 0) {
        const intensity = Math.min(sunPos.altitude / 45, 1);
        finalColor = new THREE.Color(0x4488ff).lerp(new THREE.Color(0x87CEEB), intensity);
    } else if (sunPos.altitude > -6) {
        finalColor = new THREE.Color(0x112244);
    } else {
        finalColor = new THREE.Color(0x000510);
    }

    skyScene.background.copy(finalColor);
    el.skyModal.style.backgroundColor = finalColor.getStyle();

    skyScene.traverse((object) => {
        if (object.isLine && object.material) {
            if (sunPos.altitude > 0) {
                object.material.color.setHex(0x1a3a5c);
                object.material.opacity = 0.4;
            } else {
                object.material.color.setHex(0x4fc3f7);
                object.material.opacity = 0.3;
            }
        }
    });

    let solarTimeString = "--:--:--";
    if (sunPos.solarTimeHours !== undefined) {
        const h = Math.floor(sunPos.solarTimeHours);
        const m = Math.floor((sunPos.solarTimeHours * 60) % 60);
        const s = Math.floor((sunPos.solarTimeHours * 3600) % 60);
        solarTimeString = `${h.toString().padStart(2, '0')}:${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}`;
    }
    el.skySunData.innerHTML = `–ê–∑–∏–º—É—Ç: <span style="color:var(--gold)">${sunPos.azimuth.toFixed(1)}¬∞</span><br>–í—ã—Å–æ—Ç–∞: <span style="color:var(--gold)">${sunPos.altitude.toFixed(1)}¬∞</span>`;
    let statusText = sunPos.altitude > 0 ? `<span style="color: var(--gold);">‚óè –î–µ–Ω—å</span>` : (sunPos.altitude > -6 ? `<span style="color: #ffab91;">‚óè –°—É–º–µ—Ä–∫–∏</span>` : `<span style="color: var(--text-muted);">‚óè –ù–æ—á—å</span>`);
    el.skySunStatus.innerHTML = `
        ${statusText}<br>
        <span style="color: #fff; font-size: 10px; opacity: 0.6; text-transform: uppercase;">–°–æ–ª–Ω–µ—á–Ω–æ–µ –≤—Ä–µ–º—è:</span><br>
        <span style="color: var(--gold); font-family: monospace; font-size: 14px;">${solarTimeString}</span>
    `;
}

function updateSkyMoon(lat, lon) {
    if (!skyMoonMesh) return;
    
    const now = new Date();
    const moonPos = getMoonPosition(lat, lon, now);
    
    const azRad = moonPos.azimuth * Math.PI / 180;
    const altRad = moonPos.altitude * Math.PI / 180;
    const r = 35;
    
    skyMoonMesh.position.set(
        -r * Math.cos(altRad) * Math.sin(azRad),
        r * Math.sin(altRad),
        r * Math.cos(altRad) * Math.cos(azRad)
    );
    
    skyMoonMesh.lookAt(0, 0, 0);

    el.skyMoonData.innerHTML = 
        `–ê–∑–∏–º—É—Ç: <span style="color:var(--neon-cyan)">${moonPos.azimuth.toFixed(1)}¬∞</span><br>` +
        `–í—ã—Å–æ—Ç–∞: <span style="color:var(--neon-cyan)">${moonPos.altitude.toFixed(1)}¬∞</span>`;
    
    const visibility = moonPos.altitude > 0 ? 
        `<span style="color: #81c784;">‚óè –í–∏–¥–Ω–∞</span>` : 
        `<span style="color: var(--red-ui);">‚óè –°–∫—Ä—ã—Ç–∞</span>`;
    el.skyMoonStatus.innerHTML = visibility;
}



// –í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –¥–ª—è –ø–µ—Ä–µ–≤–æ–¥–∞ —Ä—É—Å—Å–∫–∏—Ö –∏–º–µ–Ω –≤ –ª–∞—Ç–∏–Ω—Å–∫–∏–µ –¥–ª—è –±–∏–±–ª–∏–æ—Ç–µ–∫–∏
function getEnglishName(name) {
    const map = {
        '–º–µ—Ä–∫—É—Ä–∏–π': 'Mercury', 'mercury': 'Mercury',
        '–≤–µ–Ω–µ—Ä–∞': 'Venus', 'venus': 'Venus',
        '–∑–µ–º–ª—è': 'Earth', 'earth': 'Earth',
        '–º–∞—Ä—Å': 'Mars', 'mars': 'Mars',
        '—é–ø–∏—Ç–µ—Ä': 'Jupiter', 'jupiter': 'Jupiter',
        '—Å–∞—Ç—É—Ä–Ω': 'Saturn', 'saturn': 'Saturn',
      
        '—É—Ä–∞–Ω': 'Uranus', 'uranus': 'Uranus',
        '–Ω–µ–ø—Ç—É–Ω': 'Neptune', 'neptune': 'Neptune',
        '–ø–ª—É—Ç–æ–Ω': 'Pluto', 'pluto': 'Pluto',
    
        '—Å–æ–ª–Ω—Ü–µ': 'Sun', 'sun': 'Sun',
        '–ª—É–Ω–∞': 'Moon', 'moon': 'Moon'
    };
    return map[name.toLowerCase()] || name;
}

function getPlanetPosition(planetName, jd, lat, lon) {
    // 1. –°–æ–∑–¥–∞–µ–º –Ω–∞–±–ª—é–¥–∞—Ç–µ–ª—è –≤ —É–∫–∞–∑–∞–Ω–Ω–æ–π —Ç–æ—á–∫–µ
    const observer = new Astronomy.Observer(lat, lon, 0);
    
    // 2. –ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º –¥–∞—Ç—É (–±–∏–±–ª–∏–æ—Ç–µ–∫–∞ —Ä–∞–±–æ—Ç–∞–µ—Ç —Å Date –æ–±—ä–µ–∫—Ç–∞–º–∏)
    // JD –ø–µ—Ä–µ–≤–æ–¥–∏–º –æ–±—Ä–∞—Ç–Ω–æ –≤ Date, –∏–ª–∏ –±–µ—Ä–µ–º —Ç–µ–∫—É—â–µ–µ –≤—Ä–µ–º—è, –µ—Å–ª–∏ jd –±–ª–∏–∑–æ–∫ –∫ –Ω–µ–º—É
    const date = new Date((jd - 2440587.5) * 86400000);
    
    // 3. –ü–æ–ª—É—á–∞–µ–º –∞–Ω–≥–ª–∏–π—Å–∫–æ–µ –Ω–∞–∑–≤–∞–Ω–∏–µ
    const engName = getEnglishName(planetName);
    
    // 4. –°—á–∏—Ç–∞–µ–º —ç–∫–≤–∞—Ç–æ—Ä–∏–∞–ª—å–Ω—ã–µ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã (RA/Dec)
    const equator = Astronomy.Equator(engName, date, observer, false, true);
    
    // 5. –ü–µ—Ä–µ–≤–æ–¥–∏–º –≤ –≥–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω—ã–µ (–ê–∑–∏–º—É—Ç/–í—ã—Å–æ—Ç–∞)
    const horizon = Astronomy.Horizon(date, observer, equator.ra, equator.dec, 'normal');
    
    return {
        azimuth: horizon.azimuth,
        altitude: horizon.altitude
    };
}

function getSunPosition(lat, lon, date) {
    const observer = new Astronomy.Observer(lat, lon, 0);
    
    // –°—á–∏—Ç–∞–µ–º –°–æ–ª–Ω—Ü–µ —á–µ—Ä–µ–∑ –±–∏–±–ª–∏–æ—Ç–µ–∫—É
    const equator = Astronomy.Equator('Sun', date, observer, false, true);
    const horizon = Astronomy.Horizon(date, observer, equator.ra, equator.dec, 'normal');
    
    // –†–∞—Å—á–µ—Ç —Å–æ–ª–Ω–µ—á–Ω–æ–≥–æ –≤—Ä–µ–º–µ–Ω–∏ (–¥–ª—è UI) –æ—Å—Ç–∞–≤–∏–º –ø—Ä–æ—Å—Ç—ã–º –ø—Ä–∏–±–ª–∏–∂–µ–Ω–∏–µ–º
    // –∏–ª–∏ –≤–æ–∑—å–º–µ–º —Ç–æ—á–Ω—ã–π —á–∞—Å —á–µ—Ä–µ–∑ –±–∏–±–ª–∏–æ—Ç–µ–∫—É, –Ω–æ –¥–ª—è –ø—Ä–æ—Å—Ç–æ—Ç—ã –æ—Å—Ç–∞–≤–∏–º —Ä–∞—Å—á–µ—Ç:
    const gmst = Astronomy.SiderealTime(date); // –ì—Ä–∏–Ω–≤–∏—á—Å–∫–æ–µ –∑–≤–µ–∑–¥–Ω–æ–µ –≤—Ä–µ–º—è
    const lst = (gmst * 15 + lon + 360) % 360; // –ú–µ—Å—Ç–Ω–æ–µ –∑–≤–µ–∑–¥–Ω–æ–µ –≤—Ä–µ–º—è
    const ha = (lst - equator.ra * 15 + 360) % 360; // –ß–∞—Å–æ–≤–æ–π —É–≥–æ–ª
    let solarTimeHours = (ha + 180) / 15;
    solarTimeHours = (solarTimeHours + 24) % 24;

    return {
        azimuth: horizon.azimuth,
        altitude: horizon.altitude,
        solarTimeHours: solarTimeHours
    };
}

function getMoonPosition(lat, lon, date) {
    const observer = new Astronomy.Observer(lat, lon, 0);
    
    const equator = Astronomy.Equator('Moon', date, observer, false, true);
    const horizon = Astronomy.Horizon(date, observer, equator.ra, equator.dec, 'normal');
    
    return {
        azimuth: horizon.azimuth,
        altitude: horizon.altitude
    };
}

function animateSky() {
    if (!el.skyModal.classList.contains('visible')) {
        skyAnimationId = null;
        return;
    }
    
    skyAnimationId = requestAnimationFrame(animateSky);
      updateSkyISS(); 
    
    const timeDisplay = document.getElementById('sky-local-time');
    
    if (targetLocationOffset !== null) {
        const now = new Date();
        const utcTimestamp = now.getTime() + (now.getTimezoneOffset() * 60000);
        const localTimestamp = utcTimestamp + (targetLocationOffset * 3600000);
        const localDate = new Date(localTimestamp);
        
        const timeStr = localDate.toLocaleTimeString('ru-RU', { hour12: false });
        const offsetStr = targetLocationOffset >= 0 ? `+${targetLocationOffset}` : targetLocationOffset;
        
        timeDisplay.innerText = `–í—Ä–µ–º—è (–≥–µ–æ–≥—Ä.): ${timeStr} (UTC${offsetStr})`;
    } else {
        timeDisplay.innerText = `–í—Ä–µ–º—è (–≥–µ–æ–≥—Ä.): --:--:--`;
    }

    skyControls.update();
    skyRenderer.render(skyScene, skyCamera);
}

async function fetchLocationName(lat, lon) {
    try {
        const url = `https://nominatim.openstreetmap.org/reverse?format=json&lat=${lat}&lon=${lon}&zoom=10&accept-language=ru`;
        const response = await fetch(url);
        if (!response.ok) return "–û–∫–µ–∞–Ω / –û—Ç–∫—Ä—ã—Ç–æ–µ –ø—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–æ";
        const data = await response.json();
        if (data.error) return "–û–∫–µ–∞–Ω";
        
        const addr = data.address;
        const city = addr.city || addr.town || addr.village || addr.municipality;
        const state = addr.state || addr.region;
        const country = addr.country;
        let locString = country || "";
        if (state && state !== country) locString += `, ${state}`;
        if (city && city !== state) locString = `${city}, ${locString}`;
        return locString || "–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è —Ç–µ—Ä—Ä–∏—Ç–æ—Ä–∏—è";
    } catch (e) {
        return "–î–∞–Ω–Ω—ã–µ –æ –º–µ—Å—Ç–µ –Ω–µ–¥–æ—Å—Ç—É–ø–Ω—ã";
    }
}

async function openSkyView(specificCoords = null) {
    if (specificCoords && specificCoords.lat !== undefined) {
        showSkyView(specificCoords.lat, specificCoords.lon, specificCoords.name);
    } else {
        el.loading.innerText = "–û–ü–†–ï–î–ï–õ–ï–ù–ò–ï GPS...";
        el.loading.style.display = "block";
        
        if (!navigator.geolocation) {
            el.loading.style.display = "none";
            alert("–ì–µ–æ–ª–æ–∫–∞—Ü–∏—è –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç—Å—è");
            return;
        }
        
        navigator.geolocation.getCurrentPosition(
            async (position) => {
                const lat = position.coords.latitude;
                const lon = position.coords.longitude;
                
                el.loading.innerText = "–ü–û–õ–£–ß–ï–ù–ò–ï –ê–î–†–ï–°–ê...";
                const resolvedName = await fetchLocationName(lat, lon);
                
                el.loading.style.display = "none";
                showSkyView(lat, lon, `üõ∞Ô∏è GPS ‚Äî ${resolvedName}`);
            },
            (error) => {
                el.loading.style.display = "none";
                alert("–û—à–∏–±–∫–∞ GPS. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –ø–æ–∏—Å–∫ –≥–æ—Ä–æ–¥–∞.");
            },
            { enableHighAccuracy: true, timeout: 10000 }
        );
    }
}

function getSunAltitudeForEvents(lat, lon, date) {
    const DEG = Math.PI / 180;
    const jd = getJulianDate(date);
    const n = jd - 2451545.0;
    const L = (280.466 + 0.9856474 * n) % 360;
    const g = (357.528 + 0.9856003 * n) % 360 * DEG;
    const lambda = (L + 1.915 * Math.sin(g) + 0.020 * Math.sin(2 * g)) * DEG;
    const epsilon = 23.439 * DEG;
    const dec = Math.asin(Math.sin(epsilon) * Math.sin(lambda));
    
    const gmstRad = getGMST(jd);
    
    const ha = gmstRad + (lon * DEG) - Math.atan2(Math.cos(epsilon) * Math.sin(lambda), Math.cos(lambda));
    
    const latRad = lat * DEG;
    const sinAlt = Math.sin(dec) * Math.sin(latRad) + Math.cos(dec) * Math.cos(latRad) * Math.cos(ha);
    return Math.asin(sinAlt) * (180 / Math.PI);
}

function getMoonAltitudeForEvents(lat, lon, date) {
    const DEG = Math.PI / 180;
    const jd = getJulianDate(date);
    const T = (jd - 2451545.0) / 36525.0;
    
    const L0 = (218.3164477 + 481267.88123421 * T) % 360;
    const M = (134.9633964 + 477198.8675055 * T) % 360 * DEG;
    const F = (93.2720950 + 483202.0175233 * T) % 360 * DEG;
    const D = (297.8501921 + 445267.1114034 * T) % 360 * DEG;
    
    let lambda = L0 + 6.289 * Math.sin(M);
    lambda += 1.274 * Math.sin(2 * D - M);
    lambda += 0.658 * Math.sin(2 * D);
    lambda += 0.214 * Math.sin(2 * M);
    lambda *= DEG;

    let beta = (5.128 * Math.sin(F) + 0.281 * Math.sin(M + F)) * DEG;
    const epsilon = 23.439 * DEG;

    const sinDec = Math.sin(beta) * Math.cos(epsilon) + Math.cos(beta) * Math.sin(epsilon) * Math.sin(lambda);
    const dec = Math.asin(sinDec);
    
    const y = Math.sin(lambda) * Math.cos(epsilon) - Math.tan(beta) * Math.sin(epsilon);
    const x = Math.cos(lambda);
    let ra = Math.atan2(y, x);
    
    const gmstRad = getGMST(jd);
    const lst = gmstRad + lon * DEG;
    const ha = lst - ra;
    const latRad = lat * DEG;
    
    const sinAlt = Math.sin(dec) * Math.sin(latRad) + Math.cos(dec) * Math.cos(latRad) * Math.cos(ha);
    return Math.asin(sinAlt) * (180 / Math.PI);
}

function calculateCelestialEvents(lat, lon) {
    const date = new Date();
    date.setHours(0,0,0,0);
    
    let sunRise = null, sunSet = null;
    let moonRise = null, moonSet = null;

    const sunHorizon = -0.833;
    const moonHorizon = 0.125;

    let prevSunAlt = getSunAltitudeForEvents(lat, lon, date);
    let prevMoonAlt = getMoonAltitudeForEvents(lat, lon, date);

    for (let i = 1; i < 1440; i++) {
        const now = new Date(date.getTime() + i * 60000);
        const sAlt = getSunAltitudeForEvents(lat, lon, now);
        const mAlt = getMoonAltitudeForEvents(lat, lon, now);

        if (prevSunAlt < sunHorizon && sAlt >= sunHorizon) sunRise = now;
        if (prevSunAlt > sunHorizon && sAlt <= sunHorizon) sunSet = now;

        if (prevMoonAlt < moonHorizon && mAlt >= moonHorizon) moonRise = now;
        if (prevMoonAlt > moonHorizon && mAlt <= moonHorizon) moonSet = now;

        prevSunAlt = sAlt;
        prevMoonAlt = mAlt;
    }

    return { sunRise, sunSet, moonRise, moonSet };
}

function formatEventTime(date) {
    if (!date) return "--:--";
    return date.toLocaleTimeString('ru-RU', { hour: '2-digit', minute: '2-digit' });
}

async function showSkyView(lat, lon, locName = "–¢–æ—á–∫–∞ –Ω–∞ –∫–∞—Ä—Ç–µ") {
    if (lat === undefined || lon === undefined) return;

    currentSkyLat = lat;
    currentSkyLon = lon;

    el.skyModal.classList.add('visible');
    initSkyView();
    
    const container = document.getElementById('sky-container');
    skyCamera.aspect = container.clientWidth / container.clientHeight;
    skyCamera.updateProjectionMatrix();
    skyRenderer.setSize(container.clientWidth, container.clientHeight);
    
    el.skyUserCoords.innerHTML = `
        <div style="color: var(--neon-cyan); margin-bottom: 8px; font-weight: 800; font-size: 14px; line-height: 1.4; text-shadow: 0 0 12px var(--accent-glow); text-transform: uppercase; letter-spacing: 0.5px;">
            ${locName}
        </div>
        <div style="color: #ffffff; opacity: 0.85; font-size: 11px; font-family: 'Consolas', monospace; border-top: 1px solid rgba(79, 195, 247, 0.3); padding-top: 6px; margin-top: 4px;">
            <span style="color: var(--gold);">LAT:</span> ${Number(lat).toFixed(4)}¬∞ | <span style="color: var(--gold);">LON:</span> ${Number(lon).toFixed(4)}¬∞
        </div>
    `;
    
    el.skyWeather.innerHTML = `<div class="weather-title">üå°Ô∏è –ü–æ–≥–æ–¥–∞</div><div class="weather-loading">–ó–∞–≥—Ä—É–∑–∫–∞...</div>`;
    const weatherData = await fetchWeather(lat, lon);
    displayWeather(weatherData);
    
    updateSkyMoon(lat, lon);
    updateSkySun(lat, lon);
    
    if (locName.includes("GPS")) {
        targetLocationOffset = -new Date().getTimezoneOffset() / 60;
    } else {
        targetLocationOffset = Math.round(lon / 15);
    }
    if (!skyAnimationId) animateSky();
    
    const events = calculateCelestialEvents(lat, lon);
    el.skySunTimes.innerHTML = `‚Üë <span>${formatEventTime(events.sunRise)}</span> &nbsp; ‚Üì <span>${formatEventTime(events.sunSet)}</span>`;
    el.skyMoonTimes.innerHTML = `‚Üë <span>${formatEventTime(events.moonRise)}</span> &nbsp; ‚Üì <span>${formatEventTime(events.moonSet)}</span>`;

    createUserMarker(Number(lat), Number(lon));
    
    updateTrajectories();
}

async function searchCity(query) {
    if (!query || query.trim().length < 2) {
        el.searchResults.style.display = 'none';
        return;
    }

    el.cityInput.style.opacity = "0.5";
    
    const lowerQuery = query.toLowerCase();
  const planetNames = ['–º–µ—Ä–∫—É—Ä–∏–π', '–≤–µ–Ω–µ—Ä–∞', '–º–∞—Ä—Å', '—é–ø–∏—Ç–µ—Ä', '—Å–∞—Ç—É—Ä–Ω', '—É—Ä–∞–Ω', '–Ω–µ–ø—Ç—É–Ω', '–ø–ª—É—Ç–æ–Ω'];
    const matchedPlanets = planetNames.filter(p => p.startsWith(lowerQuery));
    const matchedStars = BRIGHT_STARS.filter(s => s.name.toLowerCase().startsWith(lowerQuery));
    
    const celestialResults = [];
    
    matchedPlanets.forEach(planet => {
        celestialResults.push({
            type: 'planet',
            name: planet.charAt(0).toUpperCase() + planet.slice(1)
        });
    });
    
    matchedStars.forEach(star => {
        celestialResults.push({
            type: 'star',
            name: star.name
        });
    });

    try {
        const url = `https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(query)}&limit=5&accept-language=ru`;
        const response = await fetch(url);
        const data = await response.json();

        displaySearchResults(data, celestialResults);
    } catch (e) {
        displaySearchResults([], celestialResults);
    } finally {
        el.cityInput.style.opacity = "1";
    }
}

el.cityInput.addEventListener('keydown', (e) => {
    if (e.key === 'Enter') {
        e.preventDefault();
        searchCity(el.cityInput.value);
    }
});

el.cityInput.addEventListener('input', (e) => {
    if (e.target.value === '') {
        el.searchResults.style.display = 'none';
    } else {
        searchCity(e.target.value);
    }
});

function displaySearchResults(cityResults, celestialResults) {
    el.searchResults.innerHTML = '';
    
    const hasResults = (cityResults && cityResults.length > 0) || (celestialResults && celestialResults.length > 0);
    
    if (!hasResults) {
        el.searchResults.innerHTML = '<div class="search-item">–ù–∏—á–µ–≥–æ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ</div>';
        el.searchResults.style.display = 'block';
        return;
    }
    
    el.searchResults.style.display = 'block';

    if (celestialResults && celestialResults.length > 0) {
        celestialResults.forEach(obj => {
            const item = document.createElement('div');
            item.className = `search-item ${obj.type}`;
            
            const icon = obj.type === 'planet' ? 'ü™ê' : '‚≠ê';
            item.innerText = `${icon} ${obj.name}`;
            
            item.onclick = (e) => {
                e.stopPropagation();
                el.searchResults.style.display = 'none';
                el.cityInput.value = obj.name;
                
                if (!el.skyModal.classList.contains('visible')) {
                    openSkyView();
                    setTimeout(() => {
                        addCelestialObject(obj.name, currentSkyLat, currentSkyLon);
                    }, 500);
                } else {
                    addCelestialObject(obj.name, currentSkyLat, currentSkyLon);
                }
            };
            el.searchResults.appendChild(item);
        });
    }

    if (cityResults && cityResults.length > 0) {
        cityResults.forEach(res => {
            const item = document.createElement('div');
            item.className = 'search-item';
            
            const parts = res.display_name.split(', ');
            const shortName = parts.length > 2 ? `${parts[0]}, ${parts[parts.length-1]}` : res.display_name;
            
            item.innerText = `üìç ${res.display_name}`;
            item.onclick = (e) => {
                e.stopPropagation();
                el.searchResults.style.display = 'none';
                el.cityInput.value = parts[0];
                clearCelestialObjects();
                showSkyView(parseFloat(res.lat), parseFloat(res.lon), shortName);
            };
            el.searchResults.appendChild(item);
        });
    }
}

document.addEventListener('click', (e) => {
    if (e.target !== el.cityInput) el.searchResults.style.display = 'none';
});


let trajectoriesVisible = false;

el.btnTrajectories.addEventListener('click', () => {
    trajectoriesVisible = !trajectoriesVisible;
    el.btnTrajectories.classList.toggle('active', trajectoriesVisible);
    updateTrajectories();
});

function closeSkyView() {
    el.skyModal.classList.remove('visible');
    currentSkyLat = null;
    currentSkyLon = null;
    clearCelestialObjects();
    
    // –°–±—Ä–æ—Å —Å–æ—Å—Ç–æ—è–Ω–∏—è –∫–Ω–æ–ø–æ–∫
    planetsVisible = false;
    starsVisible = false;
    trajectoriesVisible = false;
    el.btnShowPlanets.classList.remove('active');
    el.btnShowStars.classList.remove('active');
    el.btnTrajectories.classList.remove('active');
    
    if(sunTrajectoryLine) {
        skyScene.remove(sunTrajectoryLine);
        sunTrajectoryLine.geometry.dispose();
        sunTrajectoryLine.material.dispose();
        sunTrajectoryLine = null;
    }
    
    if(moonTrajectoryLine) {
        skyScene.remove(moonTrajectoryLine);
        moonTrajectoryLine.geometry.dispose();
        moonTrajectoryLine.material.dispose();
        moonTrajectoryLine = null;
    }
}

el.btnSkyView.addEventListener('click', openSkyView);
el.skyClose.addEventListener('click', closeSkyView);

window.addEventListener('resize', () => {
    if (skyInitialized && el.skyModal.classList.contains('visible')) {
        const container = document.getElementById('sky-container');
        skyCamera.aspect = container.clientWidth / container.clientHeight;
        skyCamera.updateProjectionMatrix();
        skyRenderer.setSize(container.clientWidth, container.clientHeight);
    }
});

function updateMoonToggleVisibility() {
    if (window.innerWidth <= 1024 && el.chkMoon.checked) {
        el.moonToggle.style.display = 'flex';
    } else {
        el.moonToggle.style.display = 'none';
    }
}

el.uiToggle.addEventListener('click', (e) => {
    e.stopPropagation();
    el.ui.classList.toggle('collapsed');
    el.uiToggle.innerText = el.ui.classList.contains('collapsed') ? '‚ûï' : '‚öôÔ∏è';
});

el.moonToggle.addEventListener('click', (e) => {
    e.stopPropagation();
    el.moonInfo.classList.toggle('collapsed');
    el.moonToggle.innerText = el.moonInfo.classList.contains('collapsed') ? '‚ñ∂' : 'üåì';
});

if (window.innerWidth <= 1024) {
    setTimeout(() => {
        el.ui.classList.add('collapsed');
        el.uiToggle.innerText = '‚ûï';
    }, 1500);
}

window.addEventListener('resize', updateMoonToggleVisibility);

el.btnClear.addEventListener('click', () => {
    el.btnClear.style.transform = "scale(0.9)";
    setTimeout(() => el.btnClear.style.transform = "", 150);
    const req = indexedDB.deleteDatabase(DB_NAME);
    req.onsuccess = () => { location.reload(); };
    req.onerror = () => { alert('–û—à–∏–±–∫–∞ –æ—á–∏—Å—Ç–∫–∏ –∫—ç—à–∞.'); };
    req.onblocked = () => { location.reload(); };
});

const scene = new THREE.Scene();
scene.background = new THREE.Color(0x0a1628);

const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 4000);
camera.position.set(0, 0, 28);

const renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
renderer.outputColorSpace = THREE.SRGBColorSpace;
renderer.toneMapping = THREE.ACESFilmicToneMapping;
renderer.toneMappingExposure = 2;
document.body.appendChild(renderer.domElement);

const ambientLight = new THREE.AmbientLight(0x4fc3f7, 0.15);
scene.add(ambientLight);

const sunLight = new THREE.DirectionalLight(0xffffff, 2.0);
sunLight.castShadow = true;
scene.add(sunLight);

function createFlareTexture(type, colorVal) {
    const size = 512;
    const canvas = document.createElement("canvas");
    canvas.width = size; canvas.height = size;
    const ctx = canvas.getContext("2d");
    const cx = size / 2, cy = size / 2;
    const c = new THREE.Color(colorVal);
    const r = Math.round(c.r * 255), g = Math.round(c.g * 255), b = Math.round(c.b * 255);

    ctx.clearRect(0, 0, size, size);

    if (type === "glow") {
        const grad = ctx.createRadialGradient(cx, cy, 0, cx, cy, size * 0.5);
        grad.addColorStop(0, `rgba(${r},${g},${b},1)`);
        grad.addColorStop(0.1, `rgba(${r},${g},${b},0.8)`);
        grad.addColorStop(0.4, `rgba(${r},${g},${b},0.2)`);
        grad.addColorStop(1, "rgba(0,0,0,0)");
        ctx.fillStyle = grad; ctx.fillRect(0, 0, size, size);
    } else if (type === "star") {
        const grad = ctx.createRadialGradient(cx, cy, 0, cx, cy, size * 0.5);
        grad.addColorStop(0, `rgba(${r},${g},${b},1)`);
        grad.addColorStop(1, "rgba(0,0,0,0)");
        ctx.fillStyle = grad;
        ctx.globalCompositeOperation = "source-over";
        ctx.save(); ctx.translate(cx, cy); ctx.scale(8, 0.4);
        const hGrad = ctx.createRadialGradient(0, 0, 0, 0, 0, size/16);
        hGrad.addColorStop(0, `rgba(${r},${g},${b},0.8)`); hGrad.addColorStop(1, "rgba(0,0,0,0)");
        ctx.fillStyle = hGrad; ctx.beginPath(); ctx.arc(0, 0, size/16, 0, Math.PI*2); ctx.fill(); ctx.restore();
        ctx.save(); ctx.translate(cx, cy); ctx.scale(0.4, 8);
        ctx.fillStyle = hGrad; ctx.beginPath(); ctx.arc(0, 0, size/16, 0, Math.PI*2); ctx.fill(); ctx.restore();
        const centerGrad = ctx.createRadialGradient(cx, cy, 0, cx, cy, size * 0.1);
        centerGrad.addColorStop(0, "white"); centerGrad.addColorStop(1, "rgba(0,0,0,0)");
        ctx.fillStyle = centerGrad; ctx.beginPath(); ctx.arc(cx, cy, size*0.1, 0, Math.PI*2); ctx.fill();
    } else if (type === "lens") {
        const grad = ctx.createRadialGradient(cx, cy, 0, cx, cy, size * 0.5);
        grad.addColorStop(0, `rgba(${r},${g},${b},0.4)`); grad.addColorStop(0.8, `rgba(${r},${g},${b},0.1)`);
        grad.addColorStop(1, "rgba(0,0,0,0)");
        ctx.fillStyle = grad;
        ctx.beginPath();
        for (let i = 0; i < 6; i++) {
            const angle = (Math.PI / 3) * i; const R = size * 0.45;
            const x = cx + R * Math.cos(angle); const y = cy + R * Math.sin(angle);
            if (i === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
        }
        ctx.closePath(); ctx.fill();
    }
    const texture = new THREE.CanvasTexture(canvas);
    texture.colorSpace = THREE.SRGBColorSpace;
    return texture;
}

const texSunGlow = createFlareTexture("glow", 0xffffee);
const texSunStar = createFlareTexture("star", 0xffffff);
const texLensHex = createFlareTexture("lens", 0xffffff);
const lensflare = new Lensflare();

const mainGlow = new LensflareElement(texSunGlow, 1200, 0.0, new THREE.Color(0xffaa55));
const mainStar = new LensflareElement(texSunStar, 500, 0.0, new THREE.Color(0xffffff));

lensflare.addElement(mainGlow);
lensflare.addElement(mainStar);
lensflare.addElement(new LensflareElement(texLensHex, 60, 0.6, new THREE.Color(0xffddaa)));
lensflare.addElement(new LensflareElement(texLensHex, 100, 0.7, new THREE.Color(0xaaccff)));
lensflare.addElement(new LensflareElement(texLensHex, 140, 0.9, new THREE.Color(0xffccaa)));
lensflare.addElement(new LensflareElement(texLensHex, 300, 1.2, new THREE.Color(0x5555aa)));

sunLight.add(lensflare);
lensflare.visible = false;

const controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true; controls.dampingFactor = 0.08;
controls.minDistance = 12; controls.maxDistance = 200;
controls.enablePan = false; controls.rotateSpeed = 0.5; controls.enableZoom = true;
controls.touches = { ONE: THREE.TOUCH.ROTATE, TWO: THREE.TOUCH.DOLLY_PAN };

renderer.domElement.addEventListener('wheel', (e) => {
    e.preventDefault(); e.stopImmediatePropagation();
    const currentDistance = controls.target.distanceTo(camera.position);
    const zoomScale = e.deltaY > 0 ? 1.05 : 0.95;
    let newDistance = currentDistance * zoomScale;
    newDistance = Math.max(controls.minDistance, Math.min(controls.maxDistance, newDistance));
    const direction = new THREE.Vector3().subVectors(camera.position, controls.target).normalize();
    camera.position.copy(controls.target).add(direction.multiplyScalar(newDistance));
}, { passive: false, capture: true });

const earthGroup = new THREE.Group();
scene.add(earthGroup);

const mwGeo = new THREE.SphereGeometry(2500, 64, 64);
const mwMat = new THREE.MeshBasicMaterial({
    map: loadTextureWithCache('./textures/milkyway.jpg'),
    side: THREE.BackSide, transparent: true, opacity: 0.5, depthWrite: false
});
const milkyWay = new THREE.Mesh(mwGeo, mwMat);
milkyWay.visible = false;
scene.add(milkyWay);

const earthMat = new THREE.MeshPhongMaterial({
    map: loadTextureWithCache('./textures/earth-blue-marble.jpg'),
    bumpMap: loadTextureWithCache('./textures/earth-topology.png'),
    bumpScale: 0.1, specularMap: loadTextureWithCache('./textures/earth-water.png'),
    specular: new THREE.Color(0x333333), shininess: 15
});
earthMat.map.colorSpace = THREE.SRGBColorSpace;
const earth = new THREE.Mesh(new THREE.SphereGeometry(10, 64, 64), earthMat);
earthGroup.add(earth);

const nightTexture = loadTextureWithCache('./textures/earth-night.jpg');
nightTexture.colorSpace = THREE.SRGBColorSpace;
const nightUniforms = { tNight: { value: nightTexture }, sunDirection: { value: new THREE.Vector3(1, 0, 0) } };
const nightMat = new THREE.ShaderMaterial({
    uniforms: nightUniforms,
    vertexShader: `varying vec2 vUv; varying vec3 vNormal; void main() { vUv = uv; vNormal = normalize(mat3(modelMatrix) * normal); gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0); }`,
    fragmentShader: `uniform sampler2D tNight; uniform vec3 sunDirection; varying vec2 vUv; varying vec3 vNormal; void main() { vec3 nightColor = texture2D(tNight, vUv).rgb; float lighting = dot(vNormal, sunDirection); float mask = clamp(-lighting + 0.15, 0.0, 1.0); mask = pow(mask, 3.0); gl_FragColor = vec4(nightColor, mask); }`,
    transparent: true, blending: THREE.AdditiveBlending, depthWrite: false, side: THREE.FrontSide
});
const earthNight = new THREE.Mesh(new THREE.SphereGeometry(10.01, 64, 64), nightMat);
earthGroup.add(earthNight);

const cloudMat = new THREE.MeshPhongMaterial({
    map: loadTextureWithCache('./textures/earth-clouds.jpg'),
    transparent: true, opacity: 0.8, blending: THREE.AdditiveBlending, side: THREE.DoubleSide, depthWrite: false
});
const clouds = new THREE.Mesh(new THREE.SphereGeometry(10.15, 64, 64), cloudMat);
earthGroup.add(clouds);
clouds.visible = false;

const atmoMat = new THREE.ShaderMaterial({
    vertexShader: `varying vec3 vN; void main(){vN=normalize(normalMatrix*normal);gl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.0);}`,
    fragmentShader: `varying vec3 vN; void main(){float i=pow(0.5-dot(vN,vec3(0,0,1)),3.0);gl_FragColor=vec4(0.4,0.7,1.0,1.0)*i*1.3;}`,
    blending: THREE.AdditiveBlending, side: THREE.BackSide, transparent: true, depthWrite: false
});
const atmosphere = new THREE.Mesh(new THREE.SphereGeometry(10.3, 64, 64), atmoMat);
scene.add(atmosphere);

function createStars(count = 5000) {
    const geo = new THREE.BufferGeometry();
    const pos = new Float32Array(count * 3);
    for (let i = 0; i < count; i++) {
        const r = 300 + Math.random() * 900;
        const theta = 2 * Math.PI * Math.random();
        const phi = Math.acos(2 * Math.random() - 1);
        pos[i * 3] = r * Math.sin(phi) * Math.cos(theta);
        pos[i * 3 + 1] = r * Math.cos(phi);
        pos[i * 3 + 2] = r * Math.sin(phi) * Math.sin(theta);
    }
    geo.setAttribute("position", new THREE.BufferAttribute(pos, 3));
    const mat = new THREE.PointsMaterial({ color: 0xffffff, size: 0.5, transparent: true, opacity: 0.8, depthWrite: false });
    return new THREE.Points(geo, mat);
}
const starsContainer = createStars();
scene.add(starsContainer);

const moonGroup = new THREE.Group();
moonGroup.visible = false;
scene.add(moonGroup);

const moonUrl = "./textures/moon-color.jpg";
const moonImg2D = new Image(); moonImg2D.src = moonUrl;

const moon3DMat = new THREE.MeshPhongMaterial({
    map: loadTextureWithCache(moonUrl),
    bumpMap: loadTextureWithCache("./textures/moon-bump.jpg"),
    bumpScale: 0.06, shininess: 2, color: 0xffffff
});
moon3DMat.map.colorSpace = THREE.SRGBColorSpace;
const moon = new THREE.Mesh(new THREE.SphereGeometry(2.7, 64, 64), moon3DMat);
moonGroup.add(moon);

const issContainer = new THREE.Group();
scene.add(issContainer);
issContainer.visible = false;

function buildDetailedISS() {
    const iss = new THREE.Group();
    const bodyMat = new THREE.MeshPhongMaterial({ color: 0xeeeeee, shininess: 80, specular: 0x444444 });
    const darkMat = new THREE.MeshPhongMaterial({ color: 0x222222, shininess: 50 });
    const solarMat = new THREE.MeshPhongMaterial({ color: 0x4fc3f7, emissive: 0x102030, shininess: 100, specular: 0x88ccff, side: THREE.DoubleSide });

    const zvezda = new THREE.Mesh(new THREE.CylinderGeometry(0.06, 0.06, 0.4, 12), bodyMat);
    zvezda.rotation.z = Math.PI / 2;
    iss.add(zvezda);

    const zarya = new THREE.Mesh(new THREE.CylinderGeometry(0.065, 0.065, 0.45, 12), bodyMat);
    zarya.rotation.z = Math.PI / 2;
    zarya.position.x = 0.45;
    iss.add(zarya);

    const unity = new THREE.Mesh(new THREE.CylinderGeometry(0.07, 0.07, 0.2, 12), bodyMat);
    unity.rotation.z = Math.PI / 2;
    unity.position.x = 0.8;
    iss.add(unity);

    const destiny = new THREE.Mesh(new THREE.CylinderGeometry(0.065, 0.065, 0.35, 12), bodyMat);
    destiny.rotation.z = Math.PI / 2;
    destiny.position.x = 1.1;
    iss.add(destiny);

    const truss = new THREE.Mesh(new THREE.BoxGeometry(0.04, 3.5, 0.04), bodyMat);
    truss.position.x = 0.9;
    iss.add(truss);

    function createSolarWing(yPos) {
        const wingGroup = new THREE.Group();
        wingGroup.position.set(0.9, yPos, 0);
        const joint = new THREE.Mesh(new THREE.CylinderGeometry(0.03, 0.03, 0.1, 8), darkMat);
        wingGroup.add(joint);
        const panelGeo = new THREE.BoxGeometry(0.3, 1.0, 0.01);
        const p1 = new THREE.Mesh(panelGeo, solarMat); p1.position.set(0.2, 0, 0);
        const p2 = new THREE.Mesh(panelGeo, solarMat); p2.position.set(-0.2, 0, 0);
        wingGroup.add(p1); wingGroup.add(p2); wingGroup.rotation.x = Math.PI / 4;
        return wingGroup;
    }

    iss.add(createSolarWing(1.6));
    iss.add(createSolarWing(1.2));
    iss.add(createSolarWing(-1.2));
    iss.add(createSolarWing(-1.6));

    const radGeo = new THREE.BoxGeometry(0.2, 0.6, 0.01);
    const rad1 = new THREE.Mesh(radGeo, bodyMat); rad1.position.set(0.9, 0.5, -0.15); rad1.rotation.x = -0.5; iss.add(rad1);
    const rad2 = new THREE.Mesh(radGeo, bodyMat); rad2.position.set(0.9, -0.5, -0.15); rad2.rotation.x = -0.5; iss.add(rad2);

    const signal = new THREE.Group();
    signal.position.set(1.25, 0, 0.08);
    const core = new THREE.Mesh(
        new THREE.SphereGeometry(0.02, 8, 8),
        new THREE.MeshBasicMaterial({ color: 0x4fc3f7, transparent: true })
    );
    const canvas = document.createElement('canvas');
    canvas.width = 64; canvas.height = 64;
    const ctx = canvas.getContext('2d');
    const grad = ctx.createRadialGradient(32, 32, 0, 32, 32, 32);
    grad.addColorStop(0, 'rgba(79, 195, 247, 1)');
    grad.addColorStop(0.2, 'rgba(79, 195, 247, 0.6)');
    grad.addColorStop(0.5, 'rgba(79, 195, 247, 0.1)');
    grad.addColorStop(1, 'rgba(79, 195, 247, 0)');
    ctx.fillStyle = grad; ctx.fillRect(0, 0, 64, 64);
    const glow = new THREE.Sprite(new THREE.SpriteMaterial({
        map: new THREE.CanvasTexture(canvas),
        transparent: true,
        blending: THREE.AdditiveBlending,
        depthWrite: false
    }));
    glow.scale.set(0.4, 0.4, 1);
    signal.add(core);
    signal.add(glow);
    signal.userData = { isSignal: true };
    iss.add(signal);

    return iss;
}

const issModel = buildDetailedISS();
issModel.scale.set(0.30, 0.30, 0.30);
issContainer.add(issModel);

const MAX_POINTS = 2000;
const trailGeo = new THREE.BufferGeometry();
const trailPos = new Float32Array(MAX_POINTS * 3);
trailGeo.setAttribute("position", new THREE.BufferAttribute(trailPos, 3));
trailGeo.setDrawRange(0, 0);
const trailMat = new THREE.LineBasicMaterial({ color: 0x4fc3f7, opacity: 1.0 });
const trailLine = new THREE.Line(trailGeo, trailMat);
earth.add(trailLine);

const DEG_TO_RAD = Math.PI / 180;
const EPSILON = 23.43929 * DEG_TO_RAD;

function getJulianDate(date) { return (date.getTime() / 86400000) + 2440587.5; }

function getGMST(jd) {
    const T = (jd - 2451545.0) / 36525.0;
    let st = 280.46061837 + 360.98564736629 * (jd - 2451545.0) + 0.000387933 * T * T - T * T * T / 38710000.0;
    st = st % 360;
    if (st < 0) st += 360;
    return st * DEG_TO_RAD;
}

function getSolarCoordinates(jd) {
    const n = jd - 2451545.0;
    const L = (280.466 + 0.98564736 * n) % 360;
    const g = (357.528 + 0.98560028 * n) % 360;
    const L_rad = L * DEG_TO_RAD; const g_rad = g * DEG_TO_RAD;
    const lambda = L + 1.915 * Math.sin(g_rad) + 0.020 * Math.sin(2 * g_rad);
    const lambda_rad = lambda * DEG_TO_RAD;
    const X_ecl = Math.cos(lambda_rad);
    const Y_ecl = Math.cos(EPSILON) * Math.sin(lambda_rad);
    const Z_ecl = Math.sin(EPSILON) * Math.sin(lambda_rad);
    return { x: X_ecl, y: Y_ecl, z: Z_ecl };
}

function getLunarCoordinates(jd) {
    const T = (jd - 2451545.0) / 36525.0;
    const L_0 = (218.3164477 + 481267.88123421 * T) * DEG_TO_RAD;
    const D = (297.8501921 + 445267.1114034 * T) * DEG_TO_RAD;
    const M = (134.9633964 + 477198.8675055 * T) * DEG_TO_RAD;
    const F = (93.2720950 + 483202.0175233 * T) * DEG_TO_RAD;
    const lambda = L_0 + 0.10976 * Math.sin(M) - 0.02224 * Math.sin(M - 2 * D) + 0.01148 * Math.sin(2 * D);
    const beta = 0.0895 * Math.sin(F) + 0.0049 * Math.sin(M + F) - 0.0048 * Math.sin(M - F);
    const dist = 385000.56 - 20905.0 * Math.cos(M);
    const cosB = Math.cos(beta);
    const x_ecl = cosB * Math.cos(lambda);
    const y_ecl = cosB * Math.sin(lambda);
    const z_ecl = Math.sin(beta);
    const x_eq = x_ecl;
    const y_eq = y_ecl * Math.cos(EPSILON) - z_ecl * Math.sin(EPSILON);
    const z_eq = y_ecl * Math.sin(EPSILON) + z_ecl * Math.cos(EPSILON);
    return { x: x_eq, y: y_eq, z: z_eq, distanceKm: dist };
}

const moonCtx = el.moonCanvas.getContext("2d"), moonW = el.moonCanvas.width, moonH = el.moonCanvas.height;
const moonMaskCanvas = document.createElement("canvas"); moonMaskCanvas.width = moonW; moonMaskCanvas.height = moonH;
const moonMaskCtx = moonMaskCanvas.getContext("2d"); const moonMaskImage = moonMaskCtx.createImageData(moonW, moonH);

function drawMoonPhase(phaseFraction) {
    const ctx = moonCtx, w = moonW, h = moonH, R = w / 2, cx = R, cy = R;
    ctx.clearRect(0, 0, w, h); ctx.fillStyle = "#0a1628"; ctx.beginPath(); ctx.arc(cx, cy, R, 0, Math.PI * 2); ctx.fill();
    if (moonImg2D.complete && moonImg2D.naturalWidth > 0) {
        ctx.save(); ctx.beginPath(); ctx.arc(cx, cy, R, 0, Math.PI * 2); ctx.clip();
        ctx.globalAlpha = 0.2; ctx.drawImage(moonImg2D, 0, 0, w, h); ctx.restore();
    }
    const phi = phaseFraction * 2 * Math.PI, sx = Math.sin(phi), sy = 0, sz = -Math.cos(phi);
    const data = moonMaskImage.data, r2Max = 1.0;
    for (let y = 0; y < h; y++) {
        const ny = (y + 0.5 - cy) / R;
        for (let x = 0; x < w; x++) {
            const nx = (x + 0.5 - cx) / R, r2 = nx * nx + ny * ny, idx = (y * w + x) * 4;
            if (r2 <= r2Max) {
                const nz = Math.sqrt(1 - r2), dot = nx * sx + ny * sy + nz * sz, b = Math.max(0, dot), a = Math.min(1, b * 1.5);
                data[idx] = 255; data[idx + 1] = 255; data[idx + 2] = 255; data[idx + 3] = Math.round(a * 255);
            } else { data[idx] = 0; data[idx + 1] = 0; data[idx + 2] = 0; data[idx + 3] = 0; }
        }
    }
    moonMaskCtx.putImageData(moonMaskImage, 0, 0);
    ctx.save(); ctx.beginPath(); ctx.arc(cx, cy, R, 0, Math.PI * 2); ctx.clip();
    if (moonImg2D.complete && moonImg2D.naturalWidth > 0) {
        ctx.globalAlpha = 1.0; ctx.globalCompositeOperation = "source-over"; ctx.drawImage(moonImg2D, 0, 0, w, h);
        ctx.globalCompositeOperation = "destination-in"; ctx.drawImage(moonMaskCanvas, 0, 0);
    } else { ctx.globalCompositeOperation = "source-over"; ctx.drawImage(moonMaskCanvas, 0, 0); }
    ctx.restore();
    const grad = ctx.createRadialGradient(cx, cy, R * 0.85, cx, cy, R);
    grad.addColorStop(0, "rgba(0,0,0,0)"); grad.addColorStop(1, "rgba(0,0,0,0.5)");
    ctx.fillStyle = grad; ctx.beginPath(); ctx.arc(cx, cy, R, 0, Math.PI * 2); ctx.fill();
}

function getPhaseName(p) {
    if (p < 0.03 || p > 0.97) return "–ù–æ–≤–æ–ª—É–Ω–∏–µ"; if (p < 0.22) return "–†–∞—Å—Ç—É—â–∏–π —Å–µ—Ä–ø";
    if (p < 0.28) return "–ü–µ—Ä–≤–∞—è —á–µ—Ç–≤–µ—Ä—Ç—å"; if (p < 0.47) return "–†–∞—Å—Ç—É—â–∞—è –ª—É–Ω–∞";
    if (p < 0.53) return "–ü–æ–ª–Ω–æ–ª—É–Ω–∏–µ"; if (p < 0.72) return "–£–±—ã–≤–∞—é—â–∞—è –ª—É–Ω–∞";
    if (p < 0.78) return "–ü–æ—Å–ª–µ–¥–Ω—è—è —á–µ—Ç–≤–µ—Ä—Ç—å"; return "–£–±—ã–≤–∞—é—â–∏–π —Å–µ—Ä–ø";
}

let trailIndex = 0, totalDistanceKm = 0;
let trackingDurationSec = 0;
let issTargetPos = null, issHasFix = false;
let issVelocityKmS = 7.66;
let issDisplayData = { lat: 0, lon: 0, alt: 0 };
let issFirstFlyover = false;

const EARTH_RADIUS_UNITS = 10, KM_PER_UNIT_EARTH = 6371 / EARTH_RADIUS_UNITS;

const raycaster = new THREE.Raycaster();
const mouse = new THREE.Vector2();
let cameraMode = 'global';

const camState = {
    isTransitioning: false, startTime: 0, duration: 2000,
    startPos: new THREE.Vector3(), endPos: new THREE.Vector3(),
    startTarget: new THREE.Vector3(), endTarget: new THREE.Vector3()
};

function createUserMarker(lat, lon) {
    if (userMarker) {
        earth.remove(userMarker);
        userMarker.traverse((child) => {
            if (child.isMesh) {
                child.geometry.dispose();
                child.material.dispose();
            }
        });
    }

    userMarker = new THREE.Group();
    const pinGeo = new THREE.CylinderGeometry(0.02, 0.02, 1.2, 8);
    pinGeo.translate(0, 0.6, 0);
    const pinMat = new THREE.MeshBasicMaterial({ color: 0x4fc3f7 });
    const pin = new THREE.Mesh(pinGeo, pinMat);
    userMarker.add(pin);

    const ballGeo = new THREE.SphereGeometry(0.08, 16, 16);
    ballGeo.translate(0, 1.2, 0);
    const ballMat = new THREE.MeshBasicMaterial({ color: 0x4fc3f7, emissive: 0x4fc3f7 });
    const ball = new THREE.Mesh(ballGeo, ballMat);
    userMarker.add(ball);

    const pos = getVector(lat, lon, 0, 10, 0);
    userMarker.position.copy(pos);
    userMarker.quaternion.setFromUnitVectors(
        new THREE.Vector3(0, 1, 0),
        pos.clone().normalize()
    );
    earth.add(userMarker);

    userLocation = { lat, lon };

    if (!camState.isTransitioning) {
        const worldPos = pos.clone().applyAxisAngle(new THREE.Vector3(0, 1, 0), earth.rotation.y);
        const targetPos = worldPos.clone().normalize().multiplyScalar(cameraMode === 'iss' ? 15 : 25);

        camState.startPos.copy(camera.position);
        camState.startTarget.copy(controls.target);
        camState.endPos.copy(targetPos);
        camState.endTarget.set(0, 0, 0);
        camState.duration = 2000;
        startTransition();
    }
}

document.querySelector('.ui-header').addEventListener('dblclick', (e) => {
    e.preventDefault();
    if (!navigator.geolocation) {
        alert("–ì–µ–æ–ª–æ–∫–∞—Ü–∏—è –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç—Å—è –≤–∞—à–∏–º –±—Ä–∞—É–∑–µ—Ä–æ–º.");
        return;
    }
    el.loading.innerText = "–û–ü–†–ï–î–ï–õ–ï–ù–ò–ï –ú–ï–°–¢–ê...";
    el.loading.style.display = "block";
    navigator.geolocation.getCurrentPosition(
        (position) => {
            el.loading.style.display = "none";
            createUserMarker(position.coords.latitude, position.coords.longitude);
        },
        (error) => {
            el.loading.style.display = "none";
            let msg = "–û—à–∏–±–∫–∞ –≥–µ–æ–ª–æ–∫–∞—Ü–∏–∏";
            if(error.code === 1) msg = "–î–æ—Å—Ç—É–ø –∫ –≥–µ–æ–ø–æ–∑–∏—Ü–∏–∏ –∑–∞–ø—Ä–µ—â–µ–Ω";
            alert(msg);
        }
    );
});

window.addEventListener('dblclick', async (event) => {
    if (el.skyModal.classList.contains('visible')) return;

    if (camState.isTransitioning) return;
    event.preventDefault();

    mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
    mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
    raycaster.setFromCamera(mouse, camera);

    if (el.chkISS.checked && cameraMode !== 'iss') {
        const intersectsISS = raycaster.intersectObjects(issModel.children, true);
        if (intersectsISS.length > 0) {
            enterISSMode();
            return;
        }
    }

    if (el.chkMoon.checked && cameraMode !== 'moon') {
        const intersectsMoon = raycaster.intersectObjects(moonGroup.children, true);
        if (intersectsMoon.length > 0) {
            enterMoonMode();
            return;
        }
    }

    if (el.chkMoon.checked && cameraMode === 'global') {
        const intersectsEarth = raycaster.intersectObject(earth);
        if (intersectsEarth.length > 0) {
            const point = intersectsEarth[0].point;

            const now = new Date();
            const jd = getJulianDate(now);
            const gmst = getGMST(jd);

            const r = 10;

            const lat = Math.asin(point.y / r) * (180 / Math.PI);

            const angle = Math.atan2(-point.z, point.x);
            let lon = (angle - gmst) * (180 / Math.PI);

            while (lon <= -180) lon += 360;
            while (lon > 180) lon -= 360;

            createUserMarker(lat, lon);

            el.loading.innerText = "–ü–æ–∏—Å–∫ –º–µ—Å—Ç–æ–ø–æ–ª–æ–∂–µ–Ω–∏—è...";
            el.loading.style.display = "block";
            const locationName = await fetchLocationName(lat, lon);
            el.loading.style.display = "none";

            openSkyView({ lat, lon, name: locationName });
            return;
        }
    }
});

el.btnExit.addEventListener('click', exitISSMode);
el.btnExitMoon.addEventListener('click', exitMoonMode);

function enterISSMode() {
    if (camState.isTransitioning) return;
    cameraMode = 'iss';
    el.btnExit.classList.add('visible');
    el.ui.style.opacity = '0'; el.ui.style.pointerEvents = 'none'; el.issHint.style.display = 'none';

    el.issHud.style.display = 'block';

    camState.startPos.copy(camera.position); camState.startTarget.copy(controls.target);

    const vUp = issModel.position.clone().normalize();
    const vRight = new THREE.Vector3(0,1,0).cross(vUp).normalize();
    camState.endPos.copy(issModel.position).add(vUp.multiplyScalar(0.3)).add(vRight.multiplyScalar(0.5));
    camState.endTarget.copy(issModel.position);

    camState.duration = 2000;
    startTransition();
}

function exitISSMode() {
    if (camState.isTransitioning) return;
    cameraMode = 'global';
    el.btnExit.classList.remove('visible');
    el.ui.style.opacity = '1'; el.ui.style.pointerEvents = 'auto';

    el.issHud.style.display = 'none';

    camState.startPos.copy(camera.position); camState.startTarget.copy(controls.target);
    camState.endPos.set(0, 0, 28); camState.endTarget.set(0, 0, 0);
    camState.duration = 2000;
    startTransition();
}

function enterMoonMode() {
    if (camState.isTransitioning) return;
    if (cameraMode === 'iss') el.btnExit.classList.remove('visible');

    cameraMode = 'moon';
    el.btnExitMoon.classList.add('visible');
    el.ui.style.opacity = '0'; el.ui.style.pointerEvents = 'none';
    el.issHint.style.display = 'none';

    camState.startPos.copy(camera.position);
    camState.startTarget.copy(controls.target);

    const vToMoon = new THREE.Vector3().subVectors(camera.position, moonGroup.position).normalize();
    camState.endPos.copy(moonGroup.position).add(vToMoon.multiplyScalar(10));
    camState.endTarget.copy(moonGroup.position);

    camState.duration = 2000;
    startTransition();
}

function exitMoonMode() {
    if (camState.isTransitioning) return;
    cameraMode = 'global';
    el.btnExitMoon.classList.remove('visible');
    el.ui.style.opacity = '1'; el.ui.style.pointerEvents = 'auto';

    camState.startPos.copy(camera.position);
    camState.startTarget.copy(controls.target);

    const earthPos = new THREE.Vector3(0,0,0);
    const vFromEarth = new THREE.Vector3().subVectors(camera.position, earthPos).normalize();
    camState.endPos.copy(vFromEarth.multiplyScalar(28));
    camState.endTarget.set(0, 0, 0);

    camState.duration = 2000;
    startTransition();
}

function startTransition() {
    camState.isTransitioning = true; camState.startTime = performance.now(); controls.enabled = false;
}

function easeInOutCubic(t) { return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2; }

function getVector(lat, lon, altKm, radiusUnits, gmst = 0) {
    const lonRad = (lon * DEG_TO_RAD) + gmst;
    const latRad = lat * DEG_TO_RAD;
    const r = radiusUnits + (altKm / KM_PER_UNIT_EARTH);
    return new THREE.Vector3(
        r * Math.cos(latRad) * Math.cos(lonRad),
        r * Math.sin(latRad),
        -r * Math.cos(latRad) * Math.sin(lonRad)
    );
}

async function updateISS() {
    if (!el.chkISS.checked) return;
    try {
        const res = await fetch(`https://api.wheretheiss.at/v1/satellites/25544?time=${Date.now()}`, { cache: "no-store" });
        if (!res.ok) throw new Error();
        const data = await res.json();

        issDisplayData = {
            lat: data.latitude,
            lon: data.longitude,
            alt: data.altitude,
            visibility: data.visibility,
            footprint: data.footprint,
            id: data.id
        };
        issVelocityKmS = data.velocity / 3600;
        issHasFix = true;

        const now = new Date();
        const jd = getJulianDate(now);
        const gmst = getGMST(jd);

        const posWorld = getVector(data.latitude, data.longitude, data.altitude, EARTH_RADIUS_UNITS, gmst);
        const posLocal = getVector(data.latitude, data.longitude, data.altitude, EARTH_RADIUS_UNITS, 0);

        if (!issFirstFlyover && !camState.isTransitioning && cameraMode === 'global') {
            issFirstFlyover = true;
            camState.startPos.copy(camera.position);
            camState.startTarget.copy(controls.target);
            camState.endTarget.set(0, 0, 0);
            const camOrbitPos = posWorld.clone().normalize().multiplyScalar(35);
            camState.endPos.copy(camOrbitPos);
            camState.duration = 3000;
            startTransition();
        }

        if (trailIndex < MAX_POINTS) {
            const arr = trailLine.geometry.attributes.position.array;
            arr[trailIndex * 3] = posLocal.x;
            arr[trailIndex * 3 + 1] = posLocal.y;
            arr[trailIndex * 3 + 2] = posLocal.z;
            trailIndex++;
            trailLine.geometry.setDrawRange(0, trailIndex);
            trailLine.geometry.attributes.position.needsUpdate = true;
        }

        if (!issTargetPos) {
            issTargetPos = posWorld.clone();
            issModel.position.copy(posWorld);
        } else {
            issTargetPos.copy(posWorld);
        }
        el.loading.style.display = "none";
    } catch (e) { }
}

function scheduleISS() { if(el.chkISS.checked) updateISS().finally(() => setTimeout(scheduleISS, 10000)); }

el.chkISS.addEventListener("change", (e) => {
    issContainer.visible = e.target.checked;
    if (e.target.checked) {
        issFirstFlyover = false;
        totalDistanceKm = 0;
        trackingDurationSec = 0;
        el.loading.innerText = "–ü–æ–∏—Å–∫ –ú–ö–°...";
        el.loading.style.display = "block";
        el.data.innerHTML = "–ü–æ–∏—Å–∫ —Å–∏–≥–Ω–∞–ª–∞...";
        scheduleISS();
    } else {
        el.loading.style.display = "none";
        if(cameraMode === 'iss') exitISSMode();
        el.data.innerHTML = "–ú–ö–° –≤—ã–∫–ª—é—á–µ–Ω–∞";
    }
});

el.chkClouds.addEventListener("change", (e) => { clouds.visible = e.target.checked; });
el.chkGalaxy.addEventListener("change", (e) => { milkyWay.visible = e.target.checked; });

el.chkMoon.addEventListener("change", (e) => {
    moonGroup.visible = e.target.checked;
    el.moonInfo.style.display = e.target.checked ? "block" : "none";
    updateMoonToggleVisibility();
});

renderer.domElement.addEventListener('mousemove', (e) => {
    if(!el.chkISS.checked || cameraMode === 'iss') { el.issHint.style.opacity = 0; return; }
    mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
    mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
    raycaster.setFromCamera(mouse, camera);
    const intersects = raycaster.intersectObjects(issModel.children, true);
    if(intersects.length > 0) {
        el.issHint.style.opacity = 1;
        el.issHint.style.top = (e.clientY - 30) + 'px';
        el.issHint.style.left = e.clientX + 'px';
    } else { el.issHint.style.opacity = 0; }
});

async function updateGeoLocation(lat, lon) {
    const now = Date.now();
    if (now - lastGeoCheckTime < 10000) return;
    lastGeoCheckTime = now;

    try {
        const url = `https://nominatim.openstreetmap.org/reverse?format=json&lat=${lat}&lon=${lon}&zoom=10&accept-language=ru`;
        const response = await fetch(url);
        if (!response.ok) throw new Error();
        const data = await response.json();

        if (data.error) {
            el.hudLocation.innerText = "–ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö / –û–∫–µ–∞–Ω";
        } else {
            const addr = data.address;
            const city = addr.city || addr.town || addr.village || addr.municipality;
            const state = addr.state || addr.region;
            const country = addr.country;
            let locString = country || "";
            if (state && state !== country) locString += `, ${state}`;
            if (city && city !== state) locString = `${city}, ${locString}`;
            el.hudLocation.innerText = locString || "UNKNOWN TERRAIN";
        }
    } catch (e) {
        el.hudLocation.innerText = "OCEAN / NO SIGNAL";
    }
}

function updateISSHUD() {
    if (cameraMode !== 'iss' || !issHasFix) return;

    el.hudLat.innerText = `–® ${issDisplayData.lat.toFixed(4)}`;
    el.hudLon.innerText = `–î ${issDisplayData.lon.toFixed(4)}`;
    el.hudAlt.innerText = `${issDisplayData.alt.toFixed(1)} KM`;

    el.hudVel.innerText = `${(issVelocityKmS * 3600).toFixed(0)} –∫–º/—á`;

    if (issDisplayData.visibility === 'daylight') {
        el.hudSolar.innerText = "100%";
        el.hudSolar.style.color = "#fff";
        el.hudStatus.innerHTML =
            "<span style='color:#81c784'>‚óè –ù–∞ —Å–æ–ª–Ω—Ü–µ</span><br>" +
            `<span style='color:var(--text-muted); font-size:9px;'>–û–±–∑–æ—Ä: ${Math.round(issDisplayData.footprint)} –∫–º</span>`;
    } else {
        el.hudSolar.innerText = "0% (–ë–∞—Ç–∞—Ä–µ—è)";
        el.hudSolar.style.color = "var(--red-ui)";
        el.hudStatus.innerHTML =
            "<span class='hud-warn'>‚ö† –í —Ç–µ–Ω–∏</span><br>" +
            `<span style='color:var(--text-muted); font-size:9px;'>–û–±–∑–æ—Ä: ${Math.round(issDisplayData.footprint)} –∫–º</span>`;
    }

    updateGeoLocation(issDisplayData.lat, issDisplayData.lon);
}

function updateCelestialPositions() {
    const now = new Date();
    el.timeNow.innerText = now.toLocaleTimeString('ru-RU', { hour12: false });
    el.dateNow.innerText = now.toLocaleDateString('ru-RU');

    const jd = getJulianDate(now);
    const gmst = getGMST(jd);

    earth.rotation.y = gmst;
    earthNight.rotation.y = gmst;
    cloudOffset += 0.00001;
    clouds.rotation.y = gmst + cloudOffset;

    if (el.chkSun.checked) {
        lensflare.visible = true; earthNight.visible = true;
        const sunCoords = getSolarCoordinates(jd);
        const sunVec = new THREE.Vector3(sunCoords.x, sunCoords.z, -sunCoords.y).normalize().multiplyScalar(200);

        sunLight.position.copy(sunVec);
        nightUniforms.sunDirection.value.copy(sunVec).normalize();
        sunLight.intensity = 2.5; ambientLight.intensity = 0.02;
    } else {
        sunLight.position.copy(camera.position);
        sunLight.intensity = 1.0; ambientLight.intensity = 1.5;
        lensflare.visible = false; earthNight.visible = false;
    }

    if (el.chkMoon.checked) {
        const moonC = getLunarCoordinates(jd);
        const moonPos = new THREE.Vector3(moonC.x, moonC.z, -moonC.y).normalize().multiplyScalar(60);
        moonGroup.position.copy(moonPos);
        moon.lookAt(0,0,0);

        const angleSun = Math.atan2(sunLight.position.z, sunLight.position.x);
        const angleMoon = Math.atan2(moonGroup.position.z, moonGroup.position.x);
        let angleDiff = angleMoon - angleSun;
        if (angleDiff < 0) angleDiff += 2*Math.PI;

        const phaseFraction = 1.0 - (angleDiff / (2*Math.PI));
        drawMoonPhase(phaseFraction);

        const sunV = sunLight.position.clone().normalize();
        const moonV = moonPos.clone().normalize();
        const elongation = Math.acos(sunV.dot(moonV));
        const illumination = (1 - Math.cos(elongation)) / 2;

        el.moonData.innerHTML =
            `<div class="phaseName">${getPhaseName(phaseFraction)}</div>` +
            `–û—Å–≤–µ—â–µ–Ω–Ω–æ—Å—Ç—å: ${(illumination * 100).toFixed(0)}%<br>` +
            `–†–∞—Å—Å—Ç–æ—è–Ω–∏–µ: ${moonC.distanceKm.toFixed(0)} –∫–º<br>–ù–∞–∫–ª–æ–Ω: 5.14¬∞`;
    }

    starsContainer.rotation.y = 0;
    milkyWay.rotation.y = 0;
}

let lastFrameT = performance.now();
let cloudOffset = 0;

function animate(t) {
    requestAnimationFrame(animate);
    const dt = Math.min(0.05, (t - lastFrameT) / 1000);
    lastFrameT = t;

    updateCelestialPositions();

    if (el.chkSun.checked) {
        mainGlow.size = 1200 + Math.sin(t * 0.0015) * 16 + Math.cos(t * 0.0005) * 10;
        mainStar.size = 500 + Math.sin(t * 0.002) * 12 + Math.cos(t * 0.005) * 6;
        const intensity = 0.98 + Math.sin(t * 0.002) * 0.02;
        mainStar.color.setHSL(0, 0, intensity);
    }

    if (issHasFix && el.chkISS.checked) {
        const now = new Date();
        const jd = getJulianDate(now);
        const gmst = getGMST(jd);
        const targetPos = getVector(issDisplayData.lat, issDisplayData.lon, issDisplayData.alt, EARTH_RADIUS_UNITS, gmst);

        if (!issTargetPos) {
            issTargetPos = targetPos.clone();
            issModel.position.copy(targetPos);
        } else {
            issTargetPos.copy(targetPos);
            const k = 1 - Math.pow(0.02, dt);
            issModel.position.lerp(issTargetPos, k);
        }

        issModel.lookAt(0, 0, 0);

        issModel.traverse((obj) => {
            if (obj.userData.isSignal) {
                const pulse = Math.sin(t * 0.004) * 0.5 + 0.5;
                obj.children[1].scale.setScalar(0.2 + pulse * 0.4);
                obj.children[0].material.opacity = 0.3 + pulse * 0.7;
            }
        });

        if (issVelocityKmS > 0) {
            totalDistanceKm += issVelocityKmS * dt;
            trackingDurationSec += dt;
        }

        el.data.innerHTML = `–®–∏—Ä–æ—Ç–∞ : ${issDisplayData.lat.toFixed(4)}¬∞<br>` +
                            `–î–æ–ª–≥–æ—Ç–∞: ${issDisplayData.lon.toFixed(4)}¬∞<br>` +
                            `–í—ã—Å–æ—Ç–∞ : ${issDisplayData.alt.toFixed(1)} –∫–º<br>` +
                            `–°–∫–æ—Ä–æ—Å—Ç—å: ${issVelocityKmS.toFixed(2)} –∫–º/—Å<br>` +
                            `–¢—Ä–µ–∫ –ú–ö–°: ${totalDistanceKm.toFixed(0)} –∫–º (${trackingDurationSec.toFixed(0)} —Å–µ–∫)`;

        updateISSHUD();
    }

    if (camState.isTransitioning) {
        const elapsed = t - camState.startTime;
        let alpha = elapsed / camState.duration;

        if (alpha >= 1) {
            alpha = 1;
            camState.isTransitioning = false;
            controls.enabled = true;
            if (cameraMode === 'iss') {
                controls.minDistance = 0.2; controls.maxDistance = 20;
            } else if (cameraMode === 'moon') {
                controls.minDistance = 4; controls.maxDistance = 50;
            } else {
                controls.minDistance = 12; controls.maxDistance = 200;
            }
        }
        const eased = easeInOutCubic(alpha);
        controls.target.lerpVectors(camState.startTarget, camState.endTarget, eased);
        const startDist = camState.startPos.length();
        const endDist = camState.endPos.length();
        const curDist = startDist + (endDist - startDist) * eased;
        const arcPos = camState.startPos.clone().lerp(camState.endPos, eased).normalize().multiplyScalar(curDist);
        camera.position.copy(arcPos);
    } else if (cameraMode === 'iss') {
        controls.target.copy(issModel.position);
    } else if (cameraMode === 'moon') {
        controls.target.copy(moonGroup.position);
    }

    controls.update();
    renderer.render(scene, camera);
}

window.addEventListener("resize", () => {
    camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
});

el.loading.style.display = "none";
animate(performance.now());
</script>
</body>
</html>