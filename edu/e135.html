<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no, maximum-scale=1.0" />
<title>–ü–ª–∞–Ω–µ—Ç–∞—Ä–∏–π</title>
<link rel="icon" href="planet.png" type="image/png" />
<style>
    :root {
        --bg-color: #000510;
        --panel-bg: linear-gradient(135deg, rgba(10, 20, 40, 0.92), rgba(5, 15, 35, 0.88));
        --accent: #00e5ff;
        --accent-glow: rgba(0, 229, 255, 0.4);
        --accent-dim: rgba(0, 229, 255, 0.15);
        --gold: #ffd700;
        --text-main: #e0f7fa;
        --border: rgba(0, 229, 255, 0.4);
        --iss-color: #00ff88;
    }

    * { box-sizing: border-box; }

    body, html {
        margin: 0; padding: 0; width: 100%; height: 100%;
        background: radial-gradient(ellipse at center, #0a1628 0%, #000510 100%);
        overflow: hidden;
        font-family: 'Segoe UI', Tahoma, sans-serif;
        color: var(--text-main);
        user-select: none;
    }

    canvas { display: block; width: 100%; height: 100%; outline: none; cursor: grab; }
    canvas:active { cursor: grabbing; }

#btn-search {
    position: absolute; top: 12px; left: 12px;
    width: 44px; height: 44px;
    background: var(--panel-bg);
    border: 1px solid var(--border);
    border-radius: 10px; cursor: pointer;
    display: flex; justify-content: center; align-items: center;
    font-size: 20px; z-index: 21;
    transition: all 0.3s ease;
    box-shadow: 0 4px 15px rgba(0,0,0,0.5);
}
#btn-search:hover {
    background: var(--accent-dim);
    color: var(--accent);
    border-color: var(--accent);
    transform: scale(1.05);
}
#btn-search.active {
    background: var(--accent);
    color: #000;
    border-color: var(--accent);
}

#search-container {
    position: absolute; top: 12px; left: 62px;
    width: 0;
    z-index: 100;
    display: flex; flex-direction: column; gap: 5px;
    overflow: hidden;
    opacity: 0;
    transition: width 0.3s ease, opacity 0.3s ease;
}
#search-container.visible {
    width: 320px;
    opacity: 1;
}

#universal-search {
    width: 100%; padding: 12px 16px;
    background: var(--panel-bg);
    border: 1px solid var(--accent);
    border-radius: 22px; color: white; font-size: 13px; outline: none;
    box-shadow: 0 0 25px rgba(0, 229, 255, 0.2);
    backdrop-filter: blur(15px);
}
#universal-search::placeholder { color: rgba(255,255,255,0.5); }
#universal-search:focus { box-shadow: 0 0 35px rgba(0, 229, 255, 0.4); }

#search-results {
    background: var(--panel-bg);
    border-radius: 16px;
    border: 1px solid var(--accent);
    max-height: 450px;
    overflow-y: auto;
    display: none;
    box-shadow: 0 15px 40px rgba(0,0,0,0.6);
    backdrop-filter: blur(15px);
}
#search-results::-webkit-scrollbar { width: 6px; }
#search-results::-webkit-scrollbar-thumb { background: var(--accent); border-radius: 3px; }
    
    .search-group-title {
        padding: 10px 18px;
        font-size: 10px;
        text-transform: uppercase;
        color: var(--gold);
        background: rgba(0,0,0,0.4);
        letter-spacing: 2px;
        font-weight: 700;
        position: sticky;
        top: 0;
    }
    .search-item {
        padding: 12px 18px;
        cursor: pointer;
        border-bottom: 1px solid rgba(255,255,255,0.05);
        font-size: 13px;
        transition: all 0.2s;
        display: flex;
        justify-content: space-between;
        align-items: center;
    }
    .search-item:hover { 
        background: rgba(0, 229, 255, 0.2); 
        color: var(--accent);
        padding-left: 22px;
    }
    .search-item-info { font-size: 10px; opacity: 0.6; text-align: right; }
    .search-item-icon { margin-right: 10px; }

#btn-toggle-const {
    position: absolute; top: 62px; left: 12px;
    width: 44px; height: 44px;
    background: var(--panel-bg);
    border: 1px solid var(--border);
    border-radius: 10px; cursor: pointer;
    display: flex; justify-content: center; align-items: center;
    font-size: 22px; z-index: 20;
    transition: all 0.3s ease;
    box-shadow: 0 4px 15px rgba(0,0,0,0.5);
}
#btn-toggle-const:hover {
    background: var(--accent-dim);
    color: var(--accent);
    border-color: var(--accent);
    transform: scale(1.05);
}

   #btn-toggle-controls {
        position: absolute; top: 12px; right: 12px;
        width: 44px; height: 44px;
        background: var(--panel-bg);
        border: 1px solid var(--border);
        border-radius: 10px; cursor: pointer;
        display: flex; /* –ò–ó–ú–ï–ù–ï–ù–û: –±—ã–ª–æ none */
        justify-content: center; align-items: center;
        font-size: 22px; z-index: 21; 
        transition: all 0.3s ease;
        box-shadow: 0 4px 15px rgba(0,0,0,0.5);
    }
    
    #btn-toggle-controls:hover { 
        background: var(--accent-dim); 
        color: var(--accent); 
        border-color: var(--accent);
        transform: scale(1.05);
    }

 #constellation-panel {
    position: absolute; top: 112px; left: 12px; bottom: 12px;
    width: 280px;
    background: var(--panel-bg);
    border: 1px solid var(--border);
    border-radius: 12px;
    display: none; flex-direction: column;
    backdrop-filter: blur(15px);
    z-index: 19;
    box-shadow: 0 6px 30px rgba(0,0,0,0.5);
}
#constellation-panel.visible { display: flex; animation: slideIn 0.3s ease forwards; }


    @keyframes slideIn { from { opacity: 0; transform: translateX(-20px); } to { opacity: 1; transform: translateX(0); } }

    .panel-header { 
        padding: 12px; 
        border-bottom: 1px solid rgba(255,255,255,0.1); 
        flex-shrink: 0;
        background: rgba(0,0,0,0.2);
        border-radius: 12px 12px 0 0;
        font-size: 12px;
        color: var(--accent);
        text-align: center;
        font-weight: 600;
    }
    
    #const-list {
        flex: 1; overflow-y: auto; padding: 6px;
        scrollbar-width: thin; scrollbar-color: var(--accent) transparent;
    }
    #const-list::-webkit-scrollbar { width: 5px; }
    #const-list::-webkit-scrollbar-thumb { background: var(--accent); border-radius: 3px; }
    
    .const-item {
        padding: 10px 12px; cursor: pointer; font-size: 13px; border-radius: 6px;
        margin-bottom: 3px; transition: all 0.2s; display: flex; justify-content: space-between;
        border-left: 3px solid transparent;
        align-items: center;
    }
    .const-item:hover { background: var(--accent-dim); color: var(--accent); border-left-color: var(--accent); }
    .const-item.active { 
        background: linear-gradient(90deg, rgba(0, 229, 255, 0.3), transparent); 
        color: #fff; font-weight: 600; border-left-color: var(--accent);
        box-shadow: inset 0 0 15px rgba(0, 229, 255, 0.2);
    }
    .const-item.below-horizon { opacity: 0.5; }
    .const-item.below-horizon .const-name::after { content: ' ‚Üì'; color: #ff6666; font-size: 11px; }
    .const-item-left { display: flex; flex-direction: column; }
    .const-name { }
    .latin-name { font-size: 10px; opacity: 0.5; font-style: italic; }
    .horizon-badge, .visible-badge {
        font-size: 9px; padding: 2px 6px; border-radius: 8px; white-space: nowrap;
    }
    .horizon-badge { background: rgba(255, 100, 100, 0.3); color: #ff8888; }
    .visible-badge { background: rgba(100, 255, 100, 0.2); color: #88ff88; }
    
    #btn-reset-view {
        margin: 10px; padding: 10px;
        background: rgba(0, 229, 255, 0.15);
        border: 1px solid var(--accent);
        color: var(--accent); cursor: pointer; border-radius: 6px;
        text-transform: uppercase; font-size: 11px; font-weight: 700;
    }
    #btn-reset-view:hover { background: var(--accent); color: #000; }

  #controls-panel {
        position: absolute; top: 62px; /* –ò–ó–ú–ï–ù–ï–ù–û: –±—ã–ª–æ 12px, —Å–¥–≤–∏–≥–∞–µ–º –ø–æ–¥ –∫–Ω–æ–ø–∫—É */
        right: 12px;
        width: 220px;
        background: var(--panel-bg);
        border: 1px solid var(--border);
        border-radius: 12px; padding: 12px;
        backdrop-filter: blur(15px);
        box-shadow: 0 6px 30px rgba(0,0,0,0.5);
        font-size: 12px;
        max-height: calc(100vh - 140px);
        overflow-y: auto;
        z-index: 20;
        display: none; 
    }
  
    #controls-panel.visible { 
        display: block; 
        animation: slideIn 0.3s ease forwards; 
    }
    
    .panel-title {
        font-size: 10px; font-weight: 700; color: var(--accent);
        text-transform: uppercase; letter-spacing: 1.5px; margin-bottom: 10px;
        text-align: center; padding-bottom: 8px;
        border-bottom: 1px solid rgba(0, 229, 255, 0.2);
    }
    .cam-mode-switch {
        display: flex; background: rgba(0,0,0,0.4); border-radius: 8px; padding: 3px; margin-bottom: 12px;
    }
    .cam-btn {
        flex: 1; border: none; background: transparent; color: rgba(255,255,255,0.5);
        padding: 7px 5px; font-size: 11px; cursor: pointer; border-radius: 6px; transition: all 0.2s;
    }
    .cam-btn:hover { color: white; background: rgba(255,255,255,0.1); }
    .cam-btn.active { background: var(--accent); color: #000; font-weight: 700; }
    .cam-btn:disabled { opacity: 0.3; cursor: not-allowed; }
    
    .ctrl-row {
        display: flex; justify-content: space-between; align-items: center;
        margin-bottom: 8px; font-size: 12px; padding: 6px 8px;
        background: rgba(0,0,0,0.2); border-radius: 6px;
    }
    
.magnitude-slider-container {
    padding: 8px 10px 20px;
    background: rgba(0,0,0,0.2);
    border-radius: 6px;
    margin-bottom: 8px;
    position: relative;
}

.magnitude-slider {
    width: 100%;
    height: 6px;
    -webkit-appearance: none;
    appearance: none;
    background: linear-gradient(90deg, var(--accent) 0%, rgba(255,255,255,0.2) 100%);
    border-radius: 3px;
    outline: none;
    cursor: pointer;
}

.magnitude-slider::-webkit-slider-thumb {
    -webkit-appearance: none;
    appearance: none;
    width: 18px;
    height: 18px;
    background: radial-gradient(circle, #fff 30%, var(--accent) 100%);
    border-radius: 50%;
    cursor: pointer;
    box-shadow: 0 0 10px var(--accent), 0 0 20px rgba(0, 229, 255, 0.4);
    transition: transform 0.2s, box-shadow 0.2s;
}

.magnitude-slider::-webkit-slider-thumb:hover {
    transform: scale(1.15);
    box-shadow: 0 0 15px var(--accent), 0 0 30px rgba(0, 229, 255, 0.6);
}

.magnitude-slider::-moz-range-thumb {
    width: 18px;
    height: 18px;
    background: radial-gradient(circle, #fff 30%, var(--accent) 100%);
    border-radius: 50%;
    cursor: pointer;
    border: none;
    box-shadow: 0 0 10px var(--accent);
}

.magnitude-slider::-moz-range-track {
    background: linear-gradient(90deg, var(--accent) 0%, rgba(255,255,255,0.2) 100%);
    height: 6px;
    border-radius: 3px;
}

.magnitude-value {
    position: absolute;
    bottom: 2px;
    transform: translateX(-50%);
    background: var(--accent);
    color: #000;
    font-size: 10px;
    font-weight: 700;
    padding: 2px 6px;
    border-radius: 4px;
    white-space: nowrap;
    opacity: 0;
    transition: opacity 0.2s;
    pointer-events: none;
}

.magnitude-value::before {
    content: '';
    position: absolute;
    top: -4px;
    left: 50%;
    transform: translateX(-50%);
    border-left: 4px solid transparent;
    border-right: 4px solid transparent;
    border-bottom: 4px solid var(--accent);
}

.magnitude-slider-container:hover .magnitude-value,
.magnitude-slider:active + .magnitude-value {
    opacity: 1;
}

    
    .switch { position: relative; width: 38px; height: 20px; flex-shrink: 0; }
    .switch input { opacity: 0; width: 0; height: 0; }
    .slider {
        position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0;
        background-color: rgba(50, 60, 80, 0.8); border-radius: 20px; transition: .3s; 
    }
    .slider:before {
        position: absolute; content: ""; height: 14px; width: 14px;
        left: 3px; bottom: 3px; background: #fff; border-radius: 50%; transition: .3s;
    }
    input:checked + .slider { background: rgba(0, 229, 255, 0.5); }
    input:checked + .slider:before { transform: translateX(18px); background: var(--accent); }

    #info-panel {
        position: absolute; bottom: 12px; right: 12px;
        background: var(--panel-bg); border: 1px solid var(--border);
        border-radius: 10px; padding: 10px 14px;
        backdrop-filter: blur(15px); pointer-events: none;
        text-align: right; min-width: 180px;
        box-shadow: 0 4px 20px rgba(0,0,0,0.4);
        z-index: 18;
    }
    .info-title { font-weight: 600; margin-bottom: 4px; font-size: 10px; text-transform: uppercase; letter-spacing: 1px; opacity: 0.7; }
    .info-data { font-family: 'Consolas', monospace; font-size: 11px; line-height: 1.5; color: rgba(255,255,255,0.7); }
    .info-location { font-size: 12px; color: #fff; margin-bottom: 4px; font-weight: 500; }
    .val-gold { color: var(--gold); font-size: 16px; font-weight: 700; }
    #iss-data { margin-top: 6px; padding-top: 6px; border-top: 1px solid rgba(255,255,255,0.1); color: var(--iss-color); font-weight: 600; font-size: 10px; }
    
    #tooltip {
        position: absolute;
        background: linear-gradient(135deg, rgba(5, 15, 35, 0.95), rgba(10, 25, 50, 0.95));
        border: 1px solid var(--accent); border-radius: 10px; padding: 12px 16px;
        pointer-events: none; display: none; z-index: 100;
        box-shadow: 0 8px 30px rgba(0,0,0,0.6), 0 0 20px var(--accent-glow);
        backdrop-filter: blur(10px); max-width: 250px; min-width: 150px;
    }
    .tooltip-header { display: flex; align-items: center; gap: 8px; margin-bottom: 8px; padding-bottom: 8px; border-bottom: 1px solid rgba(0, 229, 255, 0.3); }
    .tooltip-icon { font-size: 20px; }
    .tooltip-name { font-size: 14px; font-weight: 700; color: #fff; }
    .tooltip-type { font-size: 10px; color: var(--accent); text-transform: uppercase; letter-spacing: 1px; }
    .tooltip-row { display: flex; justify-content: space-between; font-size: 11px; margin-bottom: 4px; color: rgba(255,255,255,0.8); }
    .tooltip-label { opacity: 0.6; }
    .tooltip-value { font-family: 'Consolas', monospace; color: var(--gold); font-weight: 600; }
    .tooltip-constellation { margin-top: 8px; padding-top: 8px; border-top: 1px solid rgba(255,255,255,0.1); font-size: 10px; color: rgba(255,255,255,0.5); }
    .tooltip-hint { margin-top: 8px; padding-top: 8px; border-top: 1px solid rgba(255,255,255,0.1); font-size: 10px; color: var(--accent); text-align: center; }

    #zoom-indicator, #mode-indicator {
        position: absolute; bottom: 12px; left: 50%; transform: translateX(-50%);
        background: var(--panel-bg); border: 1px solid var(--border); border-radius: 15px;
        padding: 8px 20px; font-size: 12px; backdrop-filter: blur(10px);
        pointer-events: none; opacity: 0; transition: opacity 0.3s;
        text-align: center;
    }
    #zoom-indicator { bottom: 55px; }
    #zoom-indicator.visible, #mode-indicator.visible { opacity: 1; }
    
    #loading {
        position: absolute; top: 0; left: 0; width: 100%; height: 100%;
        background: radial-gradient(ellipse at center, #0a1628 0%, #000510 100%);
        display: flex; flex-direction: column; justify-content: center; align-items: center;
        z-index: 9999; transition: opacity 0.5s;
    }
    .loader-text { color: var(--accent); font-size: 16px; text-transform: uppercase; letter-spacing: 3px; margin-top: 25px; animation: pulse 1.5s ease-in-out infinite; }
    @keyframes pulse { 0%, 100% { opacity: 0.5; } 50% { opacity: 1; } }
    .loader-spinner { width: 50px; height: 50px; border: 3px solid rgba(0, 229, 255, 0.2); border-top-color: var(--accent); border-radius: 50%; animation: spin 1s linear infinite; }
    @keyframes spin { to { transform: rotate(360deg); } }

    #transition-overlay {
        position: fixed; top: 0; left: 0; width: 100%; height: 100%;
        pointer-events: none; z-index: 500; display: none;
    }
    #vignette {
        position: absolute; top: 0; left: 0; width: 100%; height: 100%;
        background: radial-gradient(ellipse at center, transparent 0%, transparent 40%, rgba(0,0,0,0) 100%);
        opacity: 0; transition: opacity 0.3s;
    }
    #speed-lines {
        position: absolute; top: 0; left: 0; width: 100%; height: 100%;
        overflow: hidden; opacity: 0;
    }
    .speed-line {
        position: absolute;
        background: linear-gradient(90deg, transparent, rgba(0, 229, 255, 0.8), transparent);
        height: 2px; transform-origin: center;
    }
    #transition-text {
        position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
        font-size: 18px; color: var(--accent); text-transform: uppercase; letter-spacing: 4px;
        opacity: 0; text-shadow: 0 0 20px var(--accent), 0 0 40px var(--accent); white-space: nowrap;
    }
    #skip-hint {
        position: absolute; bottom: 30px; left: 50%; transform: translateX(-50%);
        font-size: 12px; color: rgba(255,255,255,0.5); opacity: 0; transition: opacity 0.3s;
    }

    /* === –°–¢–ò–õ–ò –î–õ–Ø –î–ï–¢–ê–õ–¨–ù–û–ì–û –ü–†–û–°–ú–û–¢–†–ê === */
    #flight-status {
        position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
        text-align: center; z-index: 200; pointer-events: none; display: none;
    }
    .flight-label { font-size: 14px; color: var(--accent); text-transform: uppercase; letter-spacing: 4px; margin-bottom: 10px; text-shadow: 0 0 10px var(--accent); }
    .flight-target { font-size: 24px; color: #fff; font-weight: 700; margin-bottom: 20px; text-shadow: 0 0 20px rgba(255,255,255,0.5); }
    .flight-dist { font-family: 'Consolas', monospace; font-size: 48px; color: var(--gold); font-weight: 700; text-shadow: 0 0 30px rgba(255, 215, 0, 0.5); }
    .flight-unit { font-size: 16px; opacity: 0.7; color: #fff; margin-top: 5px; }

 #detail-view {
    position: fixed; top: 0; left: 0; width: 100%; height: 100%;
    background: radial-gradient(ellipse at center, #0a1628 0%, #000510 100%);
    z-index: 400; display: none; overflow: hidden;
    opacity: 0;
    transition: opacity 0.3s ease;
}
#detail-view.visible { 
    display: block; 
    opacity: 1;
}

#detail-info {
    position: absolute; bottom: 0; left: 0; width: 100%;
    background: linear-gradient(to top, rgba(0,0,0,0.95) 0%, rgba(0,0,0,0.8) 50%, transparent 100%);
    padding: 60px 40px 30px; color: #fff; z-index: 405;
    transform: translateY(100%); 
    transition: transform 0.6s cubic-bezier(0.16, 1, 0.3, 1);
}
#detail-view.show-info #detail-info { 
    transform: translateY(0) !important; 
}

    #detail-canvas-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }
    #detail-close {
        position: absolute; top: 20px; right: 20px; width: 50px; height: 50px;
        background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.3);
        border-radius: 50%; color: white; font-size: 28px; cursor: pointer; z-index: 410;
        display: flex; align-items: center; justify-content: center; transition: all 0.3s;
        backdrop-filter: blur(10px);
    }
    #detail-close:hover { background: var(--accent); color: black; border-color: var(--accent); }



    .detail-header { display: flex; align-items: flex-end; gap: 20px; margin-bottom: 20px; flex-wrap: wrap; }
    .detail-title {
        font-size: 52px; font-weight: 700; margin: 0;
        background: linear-gradient(90deg, #fff, var(--accent));
        -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text;
    }
    .detail-type { color: var(--gold); text-transform: uppercase; letter-spacing: 3px; font-size: 14px; padding-bottom: 10px; }
    .detail-constellation { color: rgba(255,255,255,0.6); font-size: 14px; padding-bottom: 10px; }
    
    .detail-grid {
        display: grid; grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
        gap: 15px; margin-bottom: 20px; max-width: 1000px;
    }
    .d-stat {
        background: rgba(255,255,255,0.05); padding: 12px 15px;
        border-radius: 10px; border-left: 3px solid var(--accent);
    }
    .d-stat h4 { font-size: 10px; color: rgba(255,255,255,0.5); text-transform: uppercase; margin: 0 0 5px 0; letter-spacing: 1px; }
    .d-stat p { font-size: 15px; font-weight: 600; font-family: 'Consolas', monospace; color: #fff; margin: 0; }
    .d-stat.highlight { border-left-color: var(--gold); }
    .d-stat.highlight p { color: var(--gold); }
    
    .detail-fact {
        font-size: 15px; line-height: 1.7; color: rgba(255,255,255,0.8);
        max-width: 800px; padding: 15px 20px;
        background: rgba(0, 229, 255, 0.1); border-radius: 10px; border-left: 3px solid var(--gold);
    }
    .detail-fact::before { content: 'üí° '; }
    
    .detail-wiki {
        margin-top: 15px;
    }
    .detail-wiki a {
        color: var(--accent); text-decoration: none; font-size: 13px;
        display: inline-flex; align-items: center; gap: 5px;
        padding: 8px 16px;
        background: rgba(0, 229, 255, 0.1);
        border: 1px solid var(--accent);
        border-radius: 20px;
        transition: all 0.3s;
    }
    .detail-wiki a:hover { 
        background: var(--accent); 
        color: #000;
        text-decoration: none; 
    }

    #detail-hint { position: absolute; bottom: 20px; right: 40px; font-size: 12px; color: rgba(255,255,255,0.4); z-index: 406; }
    
    /* –°—Ä–∞–≤–Ω–µ–Ω–∏–µ —Ä–∞–∑–º–µ—Ä–æ–≤ */
    #size-comparison {
        position: absolute; top: 20px; left: 20px;
        background: rgba(0,0,0,0.6); border: 1px solid rgba(255,255,255,0.2);
        border-radius: 10px; padding: 15px 20px; z-index: 406;
        backdrop-filter: blur(10px);
    }
    #size-comparison h4 { margin: 0 0 10px 0; font-size: 11px; color: var(--accent); text-transform: uppercase; letter-spacing: 1px; }
    .size-row { display: flex; align-items: center; gap: 10px; margin-bottom: 8px; font-size: 12px; }
    .size-dot { border-radius: 50%; flex-shrink: 0; }
    .size-label { color: rgba(255,255,255,0.8); }
    .size-value { color: var(--gold); font-family: 'Consolas', monospace; margin-left: auto; }

    /* –ò–Ω–¥–∏–∫–∞—Ç–æ—Ä –∑–∞–≥—Ä—É–∑–∫–∏ –¥–∞–Ω–Ω—ã—Ö */
    #detail-loading {
        position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
        text-align: center; z-index: 407;
    }
    #detail-loading .loader-spinner { margin: 0 auto 15px; }
    #detail-loading .loader-text { font-size: 14px; }

    /* –ò–Ω–¥–∏–∫–∞—Ç–æ—Ä "–∑–≤–µ–∑–¥–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞" */
    #star-not-found {
        position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
        text-align: center; z-index: 201; pointer-events: none; display: none;
        background: rgba(0,0,0,0.8); padding: 30px 50px; border-radius: 15px;
        border: 1px solid rgba(255,100,100,0.3);
    }
    #star-not-found .icon { font-size: 48px; margin-bottom: 15px; }
    #star-not-found .message { font-size: 16px; color: rgba(255,255,255,0.8); margin-bottom: 10px; }
    #star-not-found .submessage { font-size: 12px; color: rgba(255,255,255,0.5); }
    
    /* CSS */
#detail-labels {
    position: absolute;
    top: 0; left: 0;
    width: 100%; height: 100%;
    pointer-events: none;
    z-index: 402;
}

.detail-label {
    position: absolute;
    font-size: 14px;
    font-weight: 500;
    color: #fff;
    text-align: center;
    text-shadow: 0 0 8px currentColor, 0 0 2px #000;
    transform: translate(-50%, 0);
    opacity: 0;
    transition: opacity 0.3s;
}

.detail-label.visible {
    opacity: 1;
}

.detail-label .name {
    display: block;
    font-size: 15px;
    font-weight: 600;
}

.detail-label .size {
    font-size: 12px;
    opacity: 0.7;
}


 @media (max-width: 768px) {
    #btn-toggle-controls { display: flex; }
    #controls-panel { display: none; top: 62px; right: 12px; width: calc(100vw - 24px); max-width: 280px; max-height: calc(100vh - 180px); }
    #controls-panel.visible { display: block; animation: slideIn 0.3s ease forwards; }
    #search-container.visible { width: calc(100vw - 80px); max-width: 280px; }
    #universal-search { padding: 10px 14px; font-size: 12px; }
    #constellation-panel { width: calc(100vw - 24px); max-width: 260px; top: 112px; }
    #info-panel { bottom: 8px; right: 8px; padding: 8px 10px; min-width: 150px; }
    .info-location { font-size: 11px; }
    .val-gold { font-size: 14px; }
    .detail-title { font-size: 32px; }
    .detail-grid { grid-template-columns: repeat(2, 1fr); }
    #detail-info { padding: 40px 20px 20px; }
    #size-comparison { top: 70px; left: 10px; padding: 10px 15px; }
}
@media (max-width: 480px) {
    #search-container.visible { width: calc(100vw - 80px); }
    #controls-panel { max-width: none; }
    #constellation-panel { max-width: none; }
    .detail-title { font-size: 26px; }
    .detail-grid { grid-template-columns: 1fr 1fr; gap: 10px; }
    .d-stat p { font-size: 13px; }
}


</style>
</head>
<body>

<div id="loading">
    <div class="loader-spinner"></div>
    <div class="loader-text">–ó–∞–≥—Ä—É–∑–∫–∞ –ü–ª–∞–Ω–µ—Ç–∞—Ä–∏—è...</div>
</div>

<div id="transition-overlay">
    <div id="vignette"></div>
    <div id="speed-lines"></div>
    <div id="transition-text"></div>
    <div id="skip-hint">–ù–∞–∂–º–∏—Ç–µ –¥–ª—è –ø—Ä–æ–ø—É—Å–∫–∞</div>
</div>

<div id="flight-status">
    <div class="flight-label"></div>
    <div class="flight-target" id="flight-target-name">‚Äî</div>
    <div class="flight-dist" id="flight-counter">000</div>
    <div class="flight-unit" id="flight-unit">—Å–≤. –ª–µ—Ç</div>
</div>

<div id="star-not-found">
    <div class="icon">üî≠</div>
    <div class="message">–î–∞–Ω–Ω—ã–µ –æ –∑–≤–µ–∑–¥–µ –Ω–µ –Ω–∞–π–¥–µ–Ω—ã</div>
    <div class="submessage">–í–æ–∑–≤—Ä–∞—â–∞–µ–º—Å—è...</div>
</div>

<div id="detail-view">
    <div id="detail-canvas-container"></div>
    
    <div id="detail-labels">
    <div id="label-star" class="detail-label"></div>
    <div id="label-sun" class="detail-label"></div>
</div>

    <button id="detail-close" title="–í–µ—Ä–Ω—É—Ç—å—Å—è –∫ –∑–≤—ë–∑–¥–Ω–æ–π –∫–∞—Ä—Ç–µ">√ó</button>
    <div id="size-comparison" style="display: none;">
        <h4>üìè –°—Ä–∞–≤–Ω–µ–Ω–∏–µ —Ä–∞–∑–º–µ—Ä–æ–≤</h4>
        <div class="size-row">
            <div class="size-dot" id="sun-dot" style="width: 10px; height: 10px; background: #ffcc00;"></div>
            <span class="size-label">–°–æ–ª–Ω—Ü–µ</span>
            <span class="size-value">1 R‚òâ</span>
        </div>
        <div class="size-row">
            <div class="size-dot" id="star-dot" style="width: 20px; height: 20px; background: #fff;"></div>
            <span class="size-label" id="star-size-label">–ó–≤–µ–∑–¥–∞</span>
            <span class="size-value" id="star-size-value">‚Äî R‚òâ</span>
        </div>
    </div>
    <div id="detail-loading" style="display: none;">
        <div class="loader-spinner"></div>
        <div class="loader-text">–ó–∞–≥—Ä—É–∑–∫–∞ –¥–∞–Ω–Ω—ã—Ö...</div>
    </div>
    <div id="detail-info">
        <div class="detail-header">
            <h1 class="detail-title" id="d-name">–û–±—ä–µ–∫—Ç</h1>
            <div class="detail-type" id="d-type">–¢–∏–ø</div>
            <div class="detail-constellation" id="d-constellation"></div>
        </div>
        <div class="detail-grid" id="d-stats"></div>
        <div class="detail-fact" id="d-fact"></div>
        <div class="detail-wiki" id="d-wiki"></div>
    </div>
    <div id="detail-hint"></div>
</div>

<div id="btn-search" title="–ü–æ–∏—Å–∫">üîç</div>

<div id="search-container">
    <input type="text" id="universal-search" placeholder="–ì–æ—Ä–æ–¥, –ø–ª–∞–Ω–µ—Ç–∞, –∑–≤–µ–∑–¥–∞, —Å–æ–∑–≤–µ–∑–¥–∏–µ..." autocomplete="off">
    <div id="search-results"></div>
</div>

<div id="btn-toggle-const" title="–°–ø–∏—Å–æ–∫ —Å–æ–∑–≤–µ–∑–¥–∏–π">‚ò∞</div>
<div id="btn-toggle-controls" title="–ù–∞—Å—Ç—Ä–æ–π–∫–∏">‚öôÔ∏è</div>

<div id="constellation-panel">
    <div class="panel-header">üìú –í—Å–µ —Å–æ–∑–≤–µ–∑–¥–∏—è</div>
    <div id="const-list"></div>
    <button id="btn-reset-view">‚Ü∫ –°–±—Ä–æ—Å</button>
</div>

<div id="controls-panel">
    <div class="panel-title">üé• –†–µ–∂–∏–º</div>
    <div class="cam-mode-switch">
        <button class="cam-btn active" id="cam-out">üåç –°—Ñ–µ—Ä–∞</button>
        <button class="cam-btn" id="cam-in">üëÅ –ù–∞–±–ª—é–¥–∞—Ç–µ–ª—å</button>
    </div>
    <div class="panel-title">‚öôÔ∏è –°–ª–æ–∏</div>
    <div class="ctrl-row"><span>üåê –°–µ—Ç–∫–∞</span><label class="switch"><input type="checkbox" id="chk-grid"><span class="slider"></span></label></div>
    <div class="ctrl-row"><span>‚≠ê –ó–≤–µ–∑–¥—ã</span><label class="switch"><input type="checkbox" id="chk-stars"><span class="slider"></span></label></div>
    <div class="ctrl-row"><span>‚ú® –õ–∏–Ω–∏–∏ —Å–æ–∑–≤.</span><label class="switch"><input type="checkbox" id="chk-lines"><span class="slider"></span></label></div>
    <div class="ctrl-row"><span>üè∑Ô∏è –ù–∞–∑–≤. —Å–æ–∑–≤.</span><label class="switch"><input type="checkbox" id="chk-const-names"><span class="slider"></span></label></div>
    <div class="ctrl-row"><span>‚≠ê –ù–∞–∑–≤. –∑–≤—ë–∑–¥</span><label class="switch"><input type="checkbox" id="chk-star-names"><span class="slider"></span></label></div>
    <div class="ctrl-row"><span>ü™ê –ü–ª–∞–Ω–µ—Ç—ã</span><label class="switch"><input type="checkbox" id="chk-planets"><span class="slider"></span></label></div>
    <div class="ctrl-row"><span>„Ä∞Ô∏è –¢—Ä–∞–µ–∫—Ç–æ—Ä–∏–∏</span><label class="switch"><input type="checkbox" id="chk-traj"><span class="slider"></span></label></div>
    <div class="ctrl-row"><span>üõ∞Ô∏è –ú–ö–°</span><label class="switch"><input type="checkbox" id="chk-iss"><span class="slider"></span></label></div>
    <div class="ctrl-row"><span>üèûÔ∏è –õ–∞–Ω–¥—à–∞—Ñ—Ç</span><label class="switch"><input type="checkbox" id="chk-ground"><span class="slider"></span></label></div>
      <div class="magnitude-slider-container">
    <input type="range" id="magnitude-slider" class="magnitude-slider" min="0" max="6" step="0.1" value="6">
    <div class="magnitude-value" id="magnitude-value">6.0m</div>
       </div>
</div>

<div id="info-panel">
    <div class="info-title">üìç –ù–∞–±–ª—é–¥–∞—Ç–µ–ª—å</div>
    <div class="info-location" id="location-name">–û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ...</div>
    <div class="info-data" id="loc-data">GPS...</div>
    <div class="info-data val-gold" id="time-data">--:--:--</div>
    <div class="info-data" id="iss-data" style="display:none;">üõ∞Ô∏è –ú–ö–°</div>
</div>

<div id="tooltip"></div>
<div id="zoom-indicator">üî≠ Zoom: 60¬∞</div>
<div id="mode-indicator"></div>

<script type="importmap">
{ "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js", "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/" } }
</script>
<script src="https://cdn.jsdelivr.net/npm/astronomy-engine@2.1.19/astronomy.browser.min.js"></script>
<script src="constellations.js"></script>


<script type="module">
import * as THREE from "three";
import { OrbitControls } from "three/addons/controls/OrbitControls.js";
import { PLANETS_DATA } from './planets.js';

// === SUPABASE –ö–û–ù–§–ò–ì–£–†–ê–¶–ò–Ø ===
const SUPABASE_URL = 'https://qgycxcmxlbyrjpdikyyz.supabase.co';
const SUPABASE_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InFneWN4Y214bGJ5cmpwZGlreXl6Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjQzOTAxNTgsImV4cCI6MjA3OTk2NjE1OH0.UtamcsWCKPpMJwH1cWJhRhh8TL7Jb_NPA0-xLpyk_YU';

// –ö—ç—à –¥–∞–Ω–Ω—ã—Ö –∑–≤—ë–∑–¥
const starDataCache = {};

// === –®–ï–ô–î–ï–†–´ –î–õ–Ø –ó–í–ï–ó–î–´ (–ü–õ–ê–ó–ú–ê) ===
const StarShaders = {
    vertexShader: `
        varying vec2 vUv;
        varying vec3 vNormal;
        varying vec3 vPosition;
        
        void main() {
            vUv = uv;
            vNormal = normalize(normalMatrix * normal);
            vPosition = position;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
    `,
    
    fragmentShader: `
        uniform float uTime;
        uniform vec3 uColorCore;
        uniform vec3 uColorMid;
        uniform vec3 uColorEdge;
        uniform float uPulse;
        
        varying vec2 vUv;
        varying vec3 vNormal;
        varying vec3 vPosition;
        
        // Simplex noise functions
        vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
        vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
        vec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }
        vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }
        
        float snoise(vec3 v) {
            const vec2 C = vec2(1.0/6.0, 1.0/3.0);
            const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);
            
            vec3 i = floor(v + dot(v, C.yyy));
            vec3 x0 = v - i + dot(i, C.xxx);
            
            vec3 g = step(x0.yzx, x0.xyz);
            vec3 l = 1.0 - g;
            vec3 i1 = min(g.xyz, l.zxy);
            vec3 i2 = max(g.xyz, l.zxy);
            
            vec3 x1 = x0 - i1 + C.xxx;
            vec3 x2 = x0 - i2 + C.yyy;
            vec3 x3 = x0 - D.yyy;
            
            i = mod289(i);
            vec4 p = permute(permute(permute(
                i.z + vec4(0.0, i1.z, i2.z, 1.0))
                + i.y + vec4(0.0, i1.y, i2.y, 1.0))
                + i.x + vec4(0.0, i1.x, i2.x, 1.0));
                
            float n_ = 0.142857142857;
            vec3 ns = n_ * D.wyz - D.xzx;
            
            vec4 j = p - 49.0 * floor(p * ns.z * ns.z);
            
            vec4 x_ = floor(j * ns.z);
            vec4 y_ = floor(j - 7.0 * x_);
            
            vec4 x = x_ *ns.x + ns.yyyy;
            vec4 y = y_ *ns.x + ns.yyyy;
            vec4 h = 1.0 - abs(x) - abs(y);
            
            vec4 b0 = vec4(x.xy, y.xy);
            vec4 b1 = vec4(x.zw, y.zw);
            
            vec4 s0 = floor(b0)*2.0 + 1.0;
            vec4 s1 = floor(b1)*2.0 + 1.0;
            vec4 sh = -step(h, vec4(0.0));
            
            vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;
            vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;
            
            vec3 p0 = vec3(a0.xy, h.x);
            vec3 p1 = vec3(a0.zw, h.y);
            vec3 p2 = vec3(a1.xy, h.z);
            vec3 p3 = vec3(a1.zw, h.w);
            
            vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));
            p0 *= norm.x;
            p1 *= norm.y;
            p2 *= norm.z;
            p3 *= norm.w;
            
            vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
            m = m * m;
            return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));
        }
        
        // Fractal Brownian Motion
        float fbm(vec3 p) {
            float value = 0.0;
            float amplitude = 0.5;
            float frequency = 1.0;
            for (int i = 0; i < 5; i++) {
                value += amplitude * snoise(p * frequency);
                amplitude *= 0.5;
                frequency *= 2.0;
            }
            return value;
        }
        
        void main() {
            // –ù–æ—Ä–º–∞–ª–∏–∑–æ–≤–∞–Ω–Ω–∞—è –ø–æ–∑–∏—Ü–∏—è –¥–ª—è —à—É–º–∞
            vec3 noisePos = vPosition * 2.0;
            
            // –ê–Ω–∏–º–∏—Ä–æ–≤–∞–Ω–Ω—ã–π —à—É–º –¥–ª—è "–∫–∏–ø–µ–Ω–∏—è" –ø–æ–≤–µ—Ä—Ö–Ω–æ—Å—Ç–∏
            float noise1 = fbm(noisePos + uTime * 0.15);
            float noise2 = fbm(noisePos * 1.5 - uTime * 0.1);
            float noise3 = snoise(noisePos * 3.0 + uTime * 0.2);
            
            // –ö–æ–º–±–∏–Ω–∏—Ä—É–µ–º —à—É–º—ã
            float combinedNoise = noise1 * 0.5 + noise2 * 0.3 + noise3 * 0.2;
            
            // Fresnel —ç—Ñ—Ñ–µ–∫—Ç (—è—Ä–∫–∏–µ –∫—Ä–∞—è)
            float fresnel = pow(1.0 - abs(dot(vNormal, vec3(0.0, 0.0, 1.0))), 2.0);
            
            // –ü—É–ª—å—Å–∞—Ü–∏—è
            float pulse = 1.0 + sin(uTime * 2.0) * uPulse;
            
            // –ì—Ä–∞–Ω—É–ª—è—Ü–∏—è –ø–æ–≤–µ—Ä—Ö–Ω–æ—Å—Ç–∏
            float granulation = smoothstep(-0.2, 0.8, combinedNoise);
            
            // –°–º–µ—à–∏–≤–∞–Ω–∏–µ —Ü–≤–µ—Ç–æ–≤ –æ—Ç —Ü–µ–Ω—Ç—Ä–∞ –∫ –∫—Ä–∞—è–º
            vec3 coreColor = uColorCore * (1.2 + combinedNoise * 0.3);
            vec3 midColor = uColorMid * (1.0 + granulation * 0.2);
            vec3 edgeColor = uColorEdge;
            
            // –ì—Ä–∞–¥–∏–µ–Ω—Ç –æ—Ç —Ü–µ–Ω—Ç—Ä–∞ –∫ –∫—Ä–∞—è–º
            float edgeFactor = fresnel * 0.7;
            vec3 baseColor = mix(coreColor, midColor, granulation * 0.6);
            baseColor = mix(baseColor, edgeColor, edgeFactor);
            
            // –Ø—Ä–∫–∏–µ –ø—è—Ç–Ω–∞ (—Å–æ–ª–Ω–µ—á–Ω—ã–µ –≤—Å–ø—ã—à–∫–∏)
            float spots = smoothstep(0.6, 0.9, noise3) * 0.5;
            baseColor += vec3(1.0, 0.9, 0.7) * spots;
            
            // –¢—ë–º–Ω—ã–µ –ø—è—Ç–Ω–∞ (—Å–æ–ª–Ω–µ—á–Ω—ã–µ –ø—è—Ç–Ω–∞)
            float darkSpots = smoothstep(0.7, 0.9, snoise(noisePos * 4.0 - uTime * 0.05));
            baseColor *= (1.0 - darkSpots * 0.3);
            
            // –§–∏–Ω–∞–ª—å–Ω—ã–π —Ü–≤–µ—Ç —Å –ø—É–ª—å—Å–∞—Ü–∏–µ–π
            vec3 finalColor = baseColor * pulse;
            
            // –î–æ–±–∞–≤–ª—è–µ–º —Å–≤–µ—á–µ–Ω–∏–µ –∫ –∫—Ä–∞—è–º
            finalColor += uColorMid * fresnel * 0.3;
            
            gl_FragColor = vec4(finalColor, 1.0);
        }
    `,
    
    // –®–µ–π–¥–µ—Ä –¥–ª—è –∫–æ—Ä–æ–Ω—ã/—Å–≤–µ—á–µ–Ω–∏—è
    coronaVertexShader: `
        varying vec2 vUv;
        varying vec3 vNormal;
        
        void main() {
            vUv = uv;
            vNormal = normalize(normalMatrix * normal);
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
    `,
    
    coronaFragmentShader: `
        uniform float uTime;
        uniform vec3 uColor;
        uniform float uIntensity;
        
        varying vec2 vUv;
        varying vec3 vNormal;
        
        void main() {
            float fresnel = pow(1.0 - abs(dot(vNormal, vec3(0.0, 0.0, 1.0))), 3.0);
            float pulse = 1.0 + sin(uTime * 1.5) * 0.1;
            float alpha = fresnel * uIntensity * pulse;
            
            vec3 color = uColor * (1.0 + fresnel * 0.5);
            gl_FragColor = vec4(color, alpha);
        }
    `
};

// === –ù–ê–°–¢–†–û–ô–ö–ò ===
const DEFAULT_SETTINGS = { 
    grid: true, ground: true, stars: true, lines: true, 
    constNames: false, starNames: false, planets: true, 
    traj: false, iss: true, camMode: 'out' , maxMagnitude: 6,  controlsOpen: false 
};
let settings = { ...DEFAULT_SETTINGS };
let transitionFinalTheta = 0;

let isSearchOpen = false;

function loadSettings() {
    const saved = localStorage.getItem('planetarium_v11');
    if (saved) try { settings = { ...DEFAULT_SETTINGS, ...JSON.parse(saved) }; } catch (e) {}
}
function saveSettings() { localStorage.setItem('planetarium_v11', JSON.stringify(settings)); }

// === –û–°–ù–û–í–ù–´–ï –ü–ï–†–ï–ú–ï–ù–ù–´–ï ===
let scene, camera, renderer, controls, raycaster, mouse;
const SPHERE_RADIUS = 50; 
let observerLat = 55.75, observerLon = 37.61;
let locationName = '–ú–æ—Å–∫–≤–∞';
let activeConstellation = null;
let highlightedStarName = null;
let currentSunAltitude = -90;
let minMagnitude = 6;
let maxMagnitude = -2;
let isMoonPhaseMode = false;

const PLANETS = ['Mercury', 'Venus', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune'];
const PLANET_NAMES_RU = { Mercury: '–ú–µ—Ä–∫—É—Ä–∏–π', Venus: '–í–µ–Ω–µ—Ä–∞', Mars: '–ú–∞—Ä—Å', Jupiter: '–Æ–ø–∏—Ç–µ—Ä', Saturn: '–°–∞—Ç—É—Ä–Ω', Uranus: '–£—Ä–∞–Ω', Neptune: '–ù–µ–ø—Ç—É–Ω' };
const PLANET_NAMES_EN = { '–ú–µ—Ä–∫—É—Ä–∏–π': 'Mercury', '–í–µ–Ω–µ—Ä–∞': 'Venus', '–ú–∞—Ä—Å': 'Mars', '–Æ–ø–∏—Ç–µ—Ä': 'Jupiter', '–°–∞—Ç—É—Ä–Ω': 'Saturn', '–£—Ä–∞–Ω': 'Uranus', '–ù–µ–ø—Ç—É–Ω': 'Neptune' };
const PLANET_MAG = { Mercury: 0.5, Venus: -4.0, Mars: 1.0, Jupiter: -2.0, Saturn: 0.5, Uranus: 5.5, Neptune: 7.8 };

const groups = { 
    grid: new THREE.Group(), 
    cardinals: new THREE.Group(),
    zenithNadir: new THREE.Group(),
    stars: new THREE.Group(), 
    starLabels: new THREE.Group(),
    constellations: new THREE.Group(), 
    planets: new THREE.Group(), 
    trajectories: new THREE.Group(), 
    sunMoon: new THREE.Group(), 
    iss: new THREE.Group(), 
    ground: new THREE.Group(),
    transitionParticles: new THREE.Group()
};

const constellationMap = {}; 
const constellationVisibility = {};
const allStarLabels = [];
const starPositions = {};
const planetPositions = {};
let issPosition = null;
let landscapeMesh = null;

const interactiveObjects = [];
let hoveredObject = null;
let hoverTrajectory = null;

let isInsideMode = false;
let spherical = { phi: Math.PI / 2, theta: 0 };
let isMouseDown = false;
let lastMouseX = 0, lastMouseY = 0;
let currentFov = 60;
const MIN_FOV = 15, MAX_FOV = 100;
let zoomTimeout = null;
let searchTimeout = null;

let cameraAnimation = null;
let constellationAnimation = null;

// === –ü–ï–†–ï–ú–ï–ù–ù–´–ï –î–õ–Ø –î–ï–¢–ê–õ–¨–ù–û–ì–û –ü–†–û–°–ú–û–¢–†–ê ===
let isFlightMode = false;
let isReturnFlight = false; 
let returnStartTime = 0;
let isDetailMode = false;
let detailScene, detailCamera, detailControls, detailRenderer;
let detailMainObject = null;
let detailAtmosphere = null;
let detailRing = null;
let detailSunComparison = null;
let detailType = null;
let flightStartTime = 0;
let flightDuration = 4000;
let flightTargetName = null;
let flightTargetData = null;
let flightStartDist = 0;
let savedCameraState = null;
let currentStarData = null;
let starShaderMaterial = null;
let starShaderTime = 0;

// –î–ª—è fallback –∞–Ω–∏–º–∞—Ü–∏–∏ (–µ—Å–ª–∏ –∑–≤–µ–∑–¥—ã –Ω–µ—Ç –≤ –±–∞–∑–µ)
let isFallbackFlight = false;
let fallbackFlightStartTime = 0;
let fallbackFlightDuration = 1500;

// === –°–ò–°–¢–ï–ú–ê –ü–ï–†–ï–•–û–î–û–í ===
let isTransitioning = false;
let transitionProgress = 0;
let transitionStartTime = 0;
let transitionDuration = 3000;
let transitionType = null;
let transitionPath = null;
let transitionLookAtPath = null;
let canSkipTransition = false;
let transitionParticles = [];

const Easing = {
    easeInQuad: t => t * t,
    easeOutQuad: t => t * (2 - t),
    easeOutCubic: t => (--t) * t * t + 1,
    easeOutQuart: t => 1 - (--t) * t * t * t,
    easeInOutCubic: t => t < 0.5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1,
    easeInOutQuad: t => t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t,
    flightEase: t => {
        if (t < 0.15) return Easing.easeInQuad(t / 0.15) * 0.15;
        if (t < 0.85) return 0.15 + (t - 0.15) * 0.7 / 0.7;
        return 0.85 + Easing.easeOutQuart((t - 0.85) / 0.15) * 0.15;
    }
};

// === –í–°–ü–û–ú–û–ì–ê–¢–ï–õ–¨–ù–´–ï –§–£–ù–ö–¶–ò–ò ===

// –§–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ —á–∏—Å–µ–ª —Å —Ä–∞–∑–¥–µ–ª–∏—Ç–µ–ª—è–º–∏
function formatNumber(num, decimals = 0) {
    if (num === null || num === undefined) return '‚Äî';
    if (typeof num !== 'number') return String(num);
    
    if (decimals > 0) {
        return num.toLocaleString('ru-RU', { 
            minimumFractionDigits: decimals, 
            maximumFractionDigits: decimals 
        });
    }
    return num.toLocaleString('ru-RU');
}

// –û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ —Ü–≤–µ—Ç–∞ –∑–≤–µ–∑–¥—ã –ø–æ —Ç–µ–º–ø–µ—Ä–∞—Ç—É—Ä–µ
function getStarColorByTemperature(tempK) {
    // –î–µ—Ñ–æ–ª—Ç –¥–ª—è –Ω–µ–∏–∑–≤–µ—Å—Ç–Ω–æ–π —Ç–µ–º–ø–µ—Ä–∞—Ç—É—Ä—ã ‚Äî –±–µ–ª—ã–π
    if (!tempK || tempK <= 0) {
        return { 
            color: 0xffffff, 
            colorHex: '#ffffff', 
            name: '–ë–µ–ª—ã–π',
            core: new THREE.Color(1.0, 1.0, 1.0),
            mid: new THREE.Color(0.95, 0.95, 1.0),
            edge: new THREE.Color(0.8, 0.85, 1.0)
        };
    }
    
    // M –∫–ª–∞—Å—Å: –ö—Ä–∞—Å–Ω—ã–µ –∑–≤—ë–∑–¥—ã (< 3500K)
    if (tempK < 3500) {
        return { 
            color: 0xff3300, 
            colorHex: '#ff3300', 
            name: '–ö—Ä–∞—Å–Ω—ã–π',
            core: new THREE.Color(1.0, 0.5, 0.2),
            mid: new THREE.Color(1.0, 0.3, 0.1),
            edge: new THREE.Color(0.8, 0.2, 0.05)
        };
    }
    
    // K –∫–ª–∞—Å—Å: –û—Ä–∞–Ω–∂–µ–≤—ã–µ –∑–≤—ë–∑–¥—ã (3500-5000K)
    if (tempK < 5000) {
        return { 
            color: 0xff6600, 
            colorHex: '#ff6600', 
            name: '–û—Ä–∞–Ω–∂–µ–≤—ã–π',
            core: new THREE.Color(1.0, 0.7, 0.3),
            mid: new THREE.Color(1.0, 0.5, 0.2),
            edge: new THREE.Color(0.95, 0.4, 0.1)
        };
    }
    
    // G –∫–ª–∞—Å—Å: –ñ—ë–ª—Ç—ã–µ –∑–≤—ë–∑–¥—ã (5000-6000K) ‚Äî –∫–∞–∫ –°–æ–ª–Ω—Ü–µ
    if (tempK < 6000) {
        return { 
            color: 0xffcc00, 
            colorHex: '#ffcc00', 
            name: '–ñ—ë–ª—Ç—ã–π',
            core: new THREE.Color(1.0, 1.0, 0.7),
            mid: new THREE.Color(1.0, 0.9, 0.4),
            edge: new THREE.Color(1.0, 0.8, 0.3)
        };
    }
    
    // F –∫–ª–∞—Å—Å: –ë–µ–ª–æ-–∂—ë–ª—Ç—ã–µ –∑–≤—ë–∑–¥—ã (6000-7500K)
    if (tempK < 7500) {
        return { 
            color: 0xffffaa, 
            colorHex: '#ffffaa', 
            name: '–ë–µ–ª–æ-–∂—ë–ª—Ç—ã–π',
            core: new THREE.Color(1.0, 1.0, 0.9),
            mid: new THREE.Color(1.0, 1.0, 0.75),
            edge: new THREE.Color(1.0, 0.95, 0.6)
        };
    }
    
    // A –∫–ª–∞—Å—Å: –ë–µ–ª—ã–µ –∑–≤—ë–∑–¥—ã (7500-10000K) ‚Äî –ú–∏—Ü–∞—Ä, –í–µ–≥–∞, –°–∏—Ä–∏—É—Å
    if (tempK < 10000) {
        return { 
            color: 0xffffff, 
            colorHex: '#ffffff', 
            name: '–ë–µ–ª—ã–π',
            core: new THREE.Color(1.0, 1.0, 1.0),
            mid: new THREE.Color(0.98, 0.98, 1.0),
            edge: new THREE.Color(0.9, 0.92, 1.0)
        };
    }
    
    // B –∫–ª–∞—Å—Å: –ë–µ–ª–æ-–≥–æ–ª—É–±—ã–µ –∑–≤—ë–∑–¥—ã (10000-30000K)
    if (tempK < 30000) {
        return { 
            color: 0xaaccff, 
            colorHex: '#aaccff', 
            name: '–ë–µ–ª–æ-–≥–æ–ª—É–±–æ–π',
            core: new THREE.Color(0.95, 0.97, 1.0),
            mid: new THREE.Color(0.8, 0.9, 1.0),
            edge: new THREE.Color(0.6, 0.75, 1.0)
        };
    }
    
    // O –∫–ª–∞—Å—Å: –ì–æ–ª—É–±—ã–µ –∑–≤—ë–∑–¥—ã (> 30000K)
    return { 
        color: 0x6699ff, 
        colorHex: '#6699ff', 
        name: '–ì–æ–ª—É–±–æ–π',
        core: new THREE.Color(0.85, 0.92, 1.0),
        mid: new THREE.Color(0.6, 0.8, 1.0),
        edge: new THREE.Color(0.4, 0.6, 1.0)
    };
}

function getSpectralClassDescription(spectralClass) {
    if (!spectralClass) return '–ó–≤–µ–∑–¥–∞';
    const first = spectralClass.charAt(0).toUpperCase();
    const descriptions = {
        'O': '–ì–æ–ª—É–±–æ–π —Å–≤–µ—Ä—Ö–≥–∏–≥–∞–Ω—Ç',
        'B': '–ë–µ–ª–æ-–≥–æ–ª—É–±–∞—è –∑–≤–µ–∑–¥–∞',
        'A': '–ë–µ–ª–∞—è –∑–≤–µ–∑–¥–∞',
        'F': '–ë–µ–ª–æ-–∂—ë–ª—Ç–∞—è –∑–≤–µ–∑–¥–∞',
        'G': '–ñ—ë–ª—Ç—ã–π –∫–∞—Ä–ª–∏–∫',
        'K': '–û—Ä–∞–Ω–∂–µ–≤–∞—è –∑–≤–µ–∑–¥–∞',
        'M': '–ö—Ä–∞—Å–Ω—ã–π –∫–∞—Ä–ª–∏–∫/–≥–∏–≥–∞–Ω—Ç'
    };
    return descriptions[first] || `–ó–≤–µ–∑–¥–∞ –∫–ª–∞—Å—Å–∞ ${spectralClass}`;
}

// === –§–£–ù–ö–¶–ò–ò –î–õ–Ø –†–ê–ë–û–¢–´ –° SUPABASE ===
async function fetchStarData(starName) {
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º –∫—ç—à
    if (starDataCache[starName]) {
        return starDataCache[starName];
    }
    
    try {
        const response = await fetch(
            `${SUPABASE_URL}/rest/v1/stars?name=eq.${encodeURIComponent(starName)}&select=*`,
            {
                headers: {
                    'apikey': SUPABASE_KEY,
                    'Authorization': `Bearer ${SUPABASE_KEY}`
                }
            }
        );
        
        if (!response.ok) throw new Error('–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏');
        
        const data = await response.json();
        if (data && data.length > 0) {
            starDataCache[starName] = data[0];
            return data[0];
        }
        return null;
    } catch (error) {
        console.error('–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –¥–∞–Ω–Ω—ã—Ö –∑–≤–µ–∑–¥—ã:', error);
        return null;
    }
}


// === –°–û–ó–î–ê–ù–ò–ï –ß–ê–°–¢–ò–¶ –ü–ï–†–ï–•–û–î–ê ===
function createTransitionParticles() {
    while (groups.transitionParticles.children.length > 0) {
        const child = groups.transitionParticles.children[0];
        groups.transitionParticles.remove(child);
        if (child.geometry) child.geometry.dispose();
        if (child.material) child.material.dispose();
    }
    transitionParticles = [];
    
    const particleCount = 150;
    const geometry = new THREE.BufferGeometry();
    const positions = new Float32Array(particleCount * 3);
    const velocities = [];
    
    for (let i = 0; i < particleCount; i++) {
        const theta = Math.random() * Math.PI * 2;
        const phi = Math.acos(2 * Math.random() - 1);
        const r = 3 + Math.random() * 15;
        
        positions[i * 3] = r * Math.sin(phi) * Math.cos(theta);
        positions[i * 3 + 1] = r * Math.sin(phi) * Math.sin(theta);
        positions[i * 3 + 2] = r * Math.cos(phi);
        
        velocities.push({
            x: (Math.random() - 0.5) * 0.3,
            y: (Math.random() - 0.5) * 0.3,
            z: -1.5 - Math.random() * 2
        });
    }
    
    geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    
    const material = new THREE.PointsMaterial({
        color: 0x00e5ff,
        size: 0.25,
        transparent: true,
        opacity: 0,
        blending: THREE.AdditiveBlending,
        depthWrite: false
    });
    
    const particles = new THREE.Points(geometry, material);
    particles.userData.velocities = velocities;
    groups.transitionParticles.add(particles);
    transitionParticles.push(particles);
    
    return particles;
}

function updateTransitionParticles(speed, direction) {
    transitionParticles.forEach(particles => {
        const positions = particles.geometry.attributes.position.array;
        const velocities = particles.userData.velocities;
        
        for (let i = 0; i < velocities.length; i++) {
            positions[i * 3] += velocities[i].x * speed;
            positions[i * 3 + 1] += velocities[i].y * speed;
            positions[i * 3 + 2] += velocities[i].z * speed * direction;
            
            const dist = Math.sqrt(positions[i * 3] ** 2 + positions[i * 3 + 1] ** 2 + positions[i * 3 + 2] ** 2);
            
            if (dist > 40 || dist < 1) {
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                const r = 8 + Math.random() * 12;
                positions[i * 3] = r * Math.sin(phi) * Math.cos(theta);
                positions[i * 3 + 1] = r * Math.sin(phi) * Math.sin(theta);
                positions[i * 3 + 2] = r * Math.cos(phi) * direction;
            }
        }
        particles.geometry.attributes.position.needsUpdate = true;
    });
}

// === –ü–£–¢–ò –ö–ê–ú–ï–†–´ ===
function createPathToInside() {
    const startPos = camera.position.clone();
    const startDist = startPos.length();
    
    const midPoint1 = startPos.clone().normalize().multiplyScalar(startDist * 1.2);
    midPoint1.y += 30;
    
    const angle = Math.atan2(startPos.x, startPos.z) + Math.PI * 0.4;
    const midPoint2 = new THREE.Vector3(Math.sin(angle) * SPHERE_RADIUS * 0.8, SPHERE_RADIUS * 0.6, Math.cos(angle) * SPHERE_RADIUS * 0.8);
    const midPoint3 = new THREE.Vector3(Math.sin(angle + 0.3) * SPHERE_RADIUS * 0.4, SPHERE_RADIUS * 0.3, Math.cos(angle + 0.3) * SPHERE_RADIUS * 0.4);
    
    const finalLookAngle = angle + 0.5;
    const finalLookAt = new THREE.Vector3(Math.sin(finalLookAngle) * 50, 10, Math.cos(finalLookAngle) * 50);
    
    return {
        path: new THREE.CatmullRomCurve3([startPos.clone(), midPoint1, midPoint2, midPoint3, new THREE.Vector3(0, 5, 0), new THREE.Vector3(0, 0.5, 0)]),
        lookAt: [new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 0, 0), finalLookAt.clone(), finalLookAt.clone(), finalLookAt.clone()],
        finalTheta: finalLookAngle
    };
}

function createPathToOutside() {
    const targetPos = new THREE.Vector3(0, 50, 100);
    const lookDir = new THREE.Vector3(Math.sin(spherical.phi) * Math.sin(spherical.theta), Math.cos(spherical.phi), Math.sin(spherical.phi) * Math.cos(spherical.theta)).normalize();
    const exitAngle = Math.atan2(targetPos.x, targetPos.z);
    
    return {
        path: new THREE.CatmullRomCurve3([
            new THREE.Vector3(0, 0.5, 0),
            new THREE.Vector3(0, 8, 0),
            new THREE.Vector3(Math.sin(exitAngle - 0.5) * SPHERE_RADIUS * 0.3, SPHERE_RADIUS * 0.5, Math.cos(exitAngle - 0.5) * SPHERE_RADIUS * 0.3),
            new THREE.Vector3(Math.sin(exitAngle - 0.3) * SPHERE_RADIUS * 0.7, SPHERE_RADIUS * 0.8, Math.cos(exitAngle - 0.3) * SPHERE_RADIUS * 0.7),
            new THREE.Vector3(Math.sin(exitAngle) * SPHERE_RADIUS * 1.3, SPHERE_RADIUS * 0.9, Math.cos(exitAngle) * SPHERE_RADIUS * 1.3),
            targetPos
        ]),
        lookAt: [lookDir.clone().multiplyScalar(50), new THREE.Vector3(0, SPHERE_RADIUS * 0.5, 0), new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 0, 0)]
    };
}

function interpolateLookAt(points, t) {
    const segments = points.length - 1;
    const segmentT = t * segments;
    const segmentIndex = Math.min(Math.floor(segmentT), segments - 1);
    const localT = segmentT - segmentIndex;
    return new THREE.Vector3().lerpVectors(points[segmentIndex], points[segmentIndex + 1], Easing.easeInOutQuad(localT));
}

// === OVERLAY –ò –≠–§–§–ï–ö–¢–´ ===
function showTransitionOverlay(show) {
    const overlay = document.getElementById('transition-overlay');
    const skipHint = document.getElementById('skip-hint');
    overlay.style.display = show ? 'block' : 'none';
    if (show) {
        setTimeout(() => { skipHint.style.opacity = '1'; canSkipTransition = true; }, 400);
    } else {
        skipHint.style.opacity = '0'; canSkipTransition = false;
    }
}

function updateVignette(intensity) {
    const vignette = document.getElementById('vignette');
    const size = 35 + (1 - intensity) * 25;
    vignette.style.background = `radial-gradient(ellipse at center, transparent 0%, transparent ${size}%, rgba(0,0,0,${intensity * 0.7}) 100%)`;
    vignette.style.opacity = intensity > 0 ? '1' : '0';
}

function updateSpeedLines(intensity, direction = 1) {
    const container = document.getElementById('speed-lines');
    container.style.opacity = intensity;
    
    if (intensity > 0.1 && container.children.length < 25) {
        for (let i = 0; i < 4; i++) {
            const line = document.createElement('div');
            line.className = 'speed-line';
            const angle = (Math.random() - 0.5) * 50;
            const startX = 50 + (Math.random() - 0.5) * 50;
            const startY = 50 + (Math.random() - 0.5) * 50;
            const length = 40 + Math.random() * 80;
            line.style.left = `${startX}%`;
            line.style.top = `${startY}%`;
            line.style.width = `${length}px`;
            line.style.transform = `rotate(${angle + (direction > 0 ? 0 : 180)}deg)`;
            line.style.opacity = Math.random() * 0.4 + 0.2;
            container.appendChild(line);
            setTimeout(() => { if (line.parentNode) line.parentNode.removeChild(line); }, 150 + Math.random() * 250);
        }
    }
}

// === –†–ï–ñ–ò–ú–´ –ö–ê–ú–ï–†–´ ===
function startTransition(type) {
    if (isTransitioning) return;
    isTransitioning = true;
    transitionType = type;
    transitionStartTime = Date.now();
    transitionProgress = 0;
    controls.enabled = false;
    document.getElementById('cam-in').disabled = true;
    document.getElementById('cam-out').disabled = true;
    
    if (type === 'toInside') {
        const pathData = createPathToInside();
        transitionPath = pathData.path;
        transitionLookAtPath = pathData.lookAt;
        transitionFinalTheta = pathData.finalTheta;
        transitionDuration = 3000;
    } else {
        const pathData = createPathToOutside();
        transitionPath = pathData.path;
        transitionLookAtPath = pathData.lookAt;
        transitionDuration = 2800;
    }
    
    createTransitionParticles();
    groups.transitionParticles.visible = true;
    showTransitionOverlay(true);
}

function skipTransition() {
    if (!isTransitioning || !canSkipTransition) return;
    transitionProgress = 0.95;
}

function updateTransition() {
    if (!isTransitioning) return;
    
    const elapsed = Date.now() - transitionStartTime;
    transitionProgress = Math.min(elapsed / transitionDuration, 1);
    const easedProgress = Easing.flightEase(transitionProgress);
    
    const position = transitionPath.getPoint(easedProgress);
    const lookAt = interpolateLookAt(transitionLookAtPath, easedProgress);
    camera.position.copy(position);
    camera.lookAt(lookAt);
    
    let vignetteIntensity = 0, speedIntensity = 0;
    if (transitionProgress < 0.15) {
        const t = transitionProgress / 0.15;
        vignetteIntensity = t * 0.3; speedIntensity = t * 0.4;
    } else if (transitionProgress < 0.5) {
        const t = (transitionProgress - 0.15) / 0.35;
        vignetteIntensity = 0.3 + t * 0.3; speedIntensity = 0.4 + t * 0.4;
    } else if (transitionProgress < 0.85) {
        const t = (transitionProgress - 0.5) / 0.35;
        vignetteIntensity = 0.6 - t * 0.3; speedIntensity = 0.8 - t * 0.4;
    } else {
        const t = (transitionProgress - 0.85) / 0.15;
        vignetteIntensity = 0.3 * (1 - t); speedIntensity = 0.4 * (1 - t);
    }
    
    updateVignette(vignetteIntensity);
    updateSpeedLines(speedIntensity, transitionType === 'toInside' ? 1 : -1);
    
    transitionParticles.forEach(p => { p.material.opacity = speedIntensity * 0.5; });
    updateTransitionParticles(speedIntensity * 1.5, transitionType === 'toInside' ? 1 : -1);
    
    camera.fov = 60 + speedIntensity * 12;
    camera.updateProjectionMatrix();
    
    if (transitionProgress >= 1) finishTransition();
}

function finishTransition() {
    isTransitioning = false;
    showTransitionOverlay(false);
    groups.transitionParticles.visible = false;
    document.getElementById('speed-lines').innerHTML = '';
    
    if (transitionType === 'toInside') {
        isInsideMode = true;
        settings.camMode = 'in';
        currentFov = 60;
        camera.fov = currentFov;
        camera.updateProjectionMatrix();
        camera.position.set(0, 0.5, 0);
        spherical = { phi: Math.PI / 2, theta: transitionFinalTheta };
        updateInsideCamera();
        if (landscapeMesh) landscapeMesh.visible = settings.ground;
        document.getElementById('cam-in').classList.add('active');
        document.getElementById('cam-out').classList.remove('active');
    } else {
        isInsideMode = false;
        settings.camMode = 'out';
        camera.fov = 60;
        camera.updateProjectionMatrix();
        camera.position.set(0, 50, 100);
        controls.target.set(0, 0, 0);
        controls.minDistance = 20;
        controls.maxDistance = 300;
        controls.enabled = true;
        controls.update();
        if (landscapeMesh) landscapeMesh.visible = false;
        document.getElementById('cam-in').classList.remove('active');
        document.getElementById('cam-out').classList.add('active');
    }
    
    document.getElementById('cam-in').disabled = false;
    document.getElementById('cam-out').disabled = false;
    saveSettings();
    applyVisibilitySettings();
}

document.addEventListener('click', (e) => {
    if (isTransitioning && canSkipTransition) {
        if (!e.target.closest('#controls-panel') && !e.target.closest('#constellation-panel') && !e.target.closest('#search-container')) {
            skipTransition();
        }
    }
});

document.addEventListener('keydown', (e) => {
    if (isTransitioning && canSkipTransition && (e.key === 'Escape' || e.key === ' ')) skipTransition();
    if (isDetailMode && e.key === 'Escape') closeDetailView();
});

// === –¶–í–ï–¢–ê –ù–ï–ë–ê ===
function getSkyColors(sunAltitude) {
    const alt = Math.max(-18, Math.min(45, sunAltitude));
    const night = { bg: 0x000814, top: 0x000510, horizon: 0x0a1628 };
    const astroTwilight = { bg: 0x0a1030, top: 0x050820, horizon: 0x1a2848 };
    const nauticalTwilight = { bg: 0x152050, top: 0x0a1535, horizon: 0x2a3a68 };
    const civilTwilight = { bg: 0x2a3a70, top: 0x152050, horizon: 0x4a5a88 };
    const sunrise = { bg: 0x3a4a80, top: 0x203060, horizon: 0x6a5a70 };
    const day = { bg: 0x1a3a6a, top: 0x0a2545, horizon: 0x4a6a90 };
    
    let colors;
    if (alt < -18) colors = night;
    else if (alt < -12) colors = lerpColors(night, astroTwilight, (alt + 18) / 6);
    else if (alt < -6) colors = lerpColors(astroTwilight, nauticalTwilight, (alt + 12) / 6);
    else if (alt < 0) colors = lerpColors(nauticalTwilight, civilTwilight, (alt + 6) / 6);
    else if (alt < 10) colors = lerpColors(civilTwilight, sunrise, alt / 10);
    else if (alt < 30) colors = lerpColors(sunrise, day, (alt - 10) / 20);
    else colors = day;
    return colors;
}

function lerpColors(c1, c2, t) {
    t = Math.max(0, Math.min(1, t));
    return { bg: lerpColor(c1.bg, c2.bg, t), top: lerpColor(c1.top, c2.top, t), horizon: lerpColor(c1.horizon, c2.horizon, t) };
}

function lerpColor(color1, color2, t) {
    const r1 = (color1 >> 16) & 255, g1 = (color1 >> 8) & 255, b1 = color1 & 255;
    const r2 = (color2 >> 16) & 255, g2 = (color2 >> 8) & 255, b2 = color2 & 255;
    return (Math.round(r1 + (r2 - r1) * t) << 16) | (Math.round(g1 + (g2 - g1) * t) << 8) | Math.round(b1 + (b2 - b1) * t);
}

function updateSkyBackground(sunAltitude) {
    const colors = getSkyColors(sunAltitude);
    scene.background = new THREE.Color(colors.bg);
    document.body.style.background = `radial-gradient(ellipse at center, #${colors.bg.toString(16).padStart(6, '0')} 0%, #${colors.top.toString(16).padStart(6, '0')} 100%)`;
}

// === FALLBACK –ê–ù–ò–ú–ê–¶–ò–Ø (–∑–≤–µ–∑–¥–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞ –≤ –±–∞–∑–µ) ===
function startFallbackFlight(starName, starPos) {
    isFallbackFlight = true;
    fallbackFlightStartTime = Date.now();
    
    // –°–æ—Ö—Ä–∞–Ω—è–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ –∫–∞–º–µ—Ä—ã
    savedCameraState = {
        position: camera.position.clone(),
        fov: camera.fov,
        isInsideMode: isInsideMode,
        spherical: { ...spherical }
    };
    
    flightTargetName = starName;
    
    // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä
    document.getElementById('flight-status').style.display = 'block';
    document.getElementById('flight-target-name').textContent = starName;
    document.getElementById('flight-counter').textContent = '...';
    document.getElementById('flight-unit').textContent = '–ø–æ–∏—Å–∫ –¥–∞–Ω–Ω—ã—Ö';
    document.getElementById('tooltip').style.display = 'none';
    
    controls.enabled = false;
}

function updateFallbackFlight() {
    if (!isFallbackFlight) return;
    
    const elapsed = Date.now() - fallbackFlightStartTime;
    const progress = Math.min(elapsed / fallbackFlightDuration, 1);
    
    // –î–≤–∏–∂–µ–Ω–∏–µ –≤–ø–µ—Ä—ë–¥ (–ø–µ—Ä–≤–∞—è –ø–æ–ª–æ–≤–∏–Ω–∞) –∏ –Ω–∞–∑–∞–¥ (–≤—Ç–æ—Ä–∞—è –ø–æ–ª–æ–≤–∏–Ω–∞)
    let zoomProgress;
    if (progress < 0.5) {
        // –ü—Ä–∏–±–ª–∏–∂–∞–µ–º—Å—è
        zoomProgress = Easing.easeOutQuad(progress * 2);
    } else {
        // –û—Ç–¥–∞–ª—è–µ–º—Å—è
        zoomProgress = Easing.easeOutQuad(1 - (progress - 0.5) * 2);
    }
    
    // –ò–∑–º–µ–Ω—è–µ–º FOV –¥–ª—è —ç—Ñ—Ñ–µ–∫—Ç–∞ –ø—Ä–∏–±–ª–∏–∂–µ–Ω–∏—è
    const startFov = savedCameraState.fov;
    const minFov = 30;
    camera.fov = startFov - (startFov - minFov) * zoomProgress;
    camera.updateProjectionMatrix();
    
    // –ù–∞ —Å–µ—Ä–µ–¥–∏–Ω–µ –ø–æ–∫–∞–∑—ã–≤–∞–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ
    if (progress >= 0.4 && progress < 0.6) {
        document.getElementById('star-not-found').style.display = 'block';
    }
    
    if (progress >= 1) {
        finishFallbackFlight();
    }
}

function finishFallbackFlight() {
    isFallbackFlight = false;
    
    // –°–∫—Ä—ã–≤–∞–µ–º –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä—ã
    document.getElementById('flight-status').style.display = 'none';
    document.getElementById('star-not-found').style.display = 'none';
    
    // –í–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –∫–∞–º–µ—Ä—É
    camera.fov = savedCameraState.fov;
    camera.updateProjectionMatrix();
    
    if (!isInsideMode) {
        controls.enabled = true;
    }
    
    // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ
    const indicator = document.getElementById('mode-indicator');
    indicator.innerHTML = `‚ö†Ô∏è –î–∞–Ω–Ω—ã–µ –æ –∑–≤–µ–∑–¥–µ "${flightTargetName}" –Ω–µ –Ω–∞–π–¥–µ–Ω—ã`;
    indicator.classList.add('visible');
    setTimeout(() => indicator.classList.remove('visible'), 3000);
}


// === –ò–ù–ò–¶–ò–ê–õ–ò–ó–ê–¶–ò–Ø –°–¶–ï–ù–´ –î–ï–¢–ê–õ–¨–ù–û–ì–û –ü–†–û–°–ú–û–¢–†–ê ===

function initDetailScene() {
    detailScene = new THREE.Scene();
    
    // –ó–≤—ë–∑–¥–Ω—ã–π —Ñ–æ–Ω
    const starGeo = new THREE.BufferGeometry();
    const starVerts = [];
    for (let i = 0; i < 5000; i++) {
        const theta = Math.random() * Math.PI * 2;
        const phi = Math.acos(2 * Math.random() - 1);
        const r = 500;
        starVerts.push(r * Math.sin(phi) * Math.cos(theta), r * Math.sin(phi) * Math.sin(theta), r * Math.cos(phi));
    }
    starGeo.setAttribute('position', new THREE.Float32BufferAttribute(starVerts, 3));
    detailScene.add(new THREE.Points(starGeo, new THREE.PointsMaterial({ color: 0xffffff, size: 0.8, transparent: true, opacity: 0.5 })));
    
    detailCamera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
    detailCamera.position.set(0, 0, 40);
    
    // –û—Å–≤–µ—â–µ–Ω–∏–µ
    const sunLight = new THREE.DirectionalLight(0xffffff, 2.0);
    sunLight.position.set(100, 50, 100);
    detailScene.add(sunLight);
    
    const backLight = new THREE.DirectionalLight(0x4466aa, 0.3);
    backLight.position.set(-50, -20, -50);
    detailScene.add(backLight);
    
    detailScene.add(new THREE.AmbientLight(0x222233, 0.3));
    
    detailRenderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    detailRenderer.setSize(window.innerWidth, window.innerHeight);
    detailRenderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    detailRenderer.toneMapping = THREE.ACESFilmicToneMapping;
    detailRenderer.toneMappingExposure = 1.2;
    
    document.getElementById('detail-canvas-container').appendChild(detailRenderer.domElement);
    
    detailControls = new OrbitControls(detailCamera, detailRenderer.domElement);
    detailControls.enableDamping = true;
    detailControls.dampingFactor = 0.05;
    detailControls.minDistance = 5;
    detailControls.maxDistance = 300;
    detailControls.enablePan = true; // –†–∞–∑—Ä–µ—à–∞–µ–º –ø–∞–Ω–æ—Ä–∞–º–∏—Ä–æ–≤–∞–Ω–∏–µ
    detailControls.autoRotate = true;
    detailControls.autoRotateSpeed = 0.3;
    
    // === –î–û–ë–ê–í–õ–Ø–ï–ú –ó–£–ú –ö–û–õ–Å–°–ò–ö–û–ú ===
    detailRenderer.domElement.addEventListener('wheel', (e) => {
        e.preventDefault();
        // OrbitControls —É–∂–µ –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç –∑—É–º, –Ω–æ –º–æ–∂–Ω–æ –¥–æ–±–∞–≤–∏—Ç—å –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–π —á–µ—Ä–µ–∑ FOV
    }, { passive: false });
    
    // –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–π –∑—É–º —á–µ—Ä–µ–∑ FOV –¥–ª—è –±–æ–ª–µ–µ –ø–ª–∞–≤–Ω–æ–≥–æ –ø—Ä–∏–±–ª–∏–∂–µ–Ω–∏—è
    let detailFov = 45;
    const DETAIL_MIN_FOV = 10;
    const DETAIL_MAX_FOV = 75;
    
    detailRenderer.domElement.addEventListener('wheel', (e) => {
        if (!isDetailMode) return;
        
        // Shift + wheel = FOV –∑—É–º (–¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–π –∫ OrbitControls)
        if (e.shiftKey) {
            e.preventDefault();
            e.stopPropagation();
            
            detailFov += e.deltaY > 0 ? 3 : -3;
            detailFov = Math.max(DETAIL_MIN_FOV, Math.min(DETAIL_MAX_FOV, detailFov));
            detailCamera.fov = detailFov;
            detailCamera.updateProjectionMatrix();
        }
    }, { passive: false });
    
    
    // –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–ª–∏–∫–∞ –≤ –¥–µ—Ç–∞–ª—å–Ω–æ–º –ø—Ä–æ—Å–º–æ—Ç—Ä–µ (–¥–ª—è –õ—É–Ω—ã)
    detailRenderer.domElement.addEventListener('click', (e) => {
        if (!isDetailMode || !detailMainObject || detailMainObject.userData.type !== 'moon_detail') return;

        // –ü–µ—Ä–µ–∫–ª—é—á–∞–µ–º —Ä–µ–∂–∏–º
        isMoonPhaseMode = !isMoonPhaseMode;

        let detailLight = null;
        detailScene.traverse(obj => { if (obj.isDirectionalLight && obj.intensity > 1.0) detailLight = obj; });

        if (!isMoonPhaseMode) {
            // == –†–ï–ñ–ò–ú –°–¢–ê–ù–î–ê–†–¢ (–∫–∞–∫ –ø–ª–∞–Ω–µ—Ç—ã) ==
            // –°–≤–µ—Ç —Å—Ç–∞–≤–∏–º "–∫–∞–∫ –≤ —Å—Ç—É–¥–∏–∏" (—Å–±–æ–∫—É-—Å–≤–µ—Ä—Ö—É-—Å–ø–µ—Ä–µ–¥–∏), —á—Ç–æ–±—ã –±—ã–ª–æ –≤—Å—ë –≤–∏–¥–Ω–æ
            if (detailLight) detailLight.position.set(100, 50, 100);
            
            // –ú–µ–Ω—è–µ–º –ø–æ–¥—Å–∫–∞–∑–∫—É
            const factEl = document.getElementById('d-fact');
            if (factEl) factEl.textContent = '–†–µ–∂–∏–º –æ–±–∑–æ—Ä–∞: –í—Ä–∞—â–µ–Ω–∏–µ –≤–∫–ª—é—á–µ–Ω–æ. –û—Å–≤–µ—â–µ–Ω–∏–µ —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–æ–µ.';
        } else {
            // == –†–ï–ñ–ò–ú –§–ê–ó–´ ==
            // –í–æ–∑–≤—Ä–∞—â–∞–µ–º —Å–≤–µ—Ç –≤ –ø–æ–∑–∏—Ü–∏—é —Ä–µ–∞–ª—å–Ω–æ–π —Ñ–∞–∑—ã (–ø–µ—Ä–µ—Å—á–∏—Ç—ã–≤–∞–µ–º –∏–ª–∏ –ø—Ä–æ—Å—Ç–æ –ø–µ—Ä–µ–∑–∞–ø—É—Å–∫–∞–µ–º –≤—å—é)
            // –î–ª—è –ø—Ä–æ—Å—Ç–æ—Ç—ã –≤—ã–∑–æ–≤–µ–º –ø–µ—Ä–µ—Å—á–µ—Ç —Å–≤–µ—Ç–∞:
             const now = new Date();
             const observer = new Astronomy.Observer(observerLat, observerLon, 0);
             const sunEq = Astronomy.Equator('Sun', now, observer, false, true);
             const moonEq = Astronomy.Equator('Moon', now, observer, false, true);
             let raDiff = sunEq.ra - moonEq.ra;
             while (raDiff < 0) raDiff += 24;
             while (raDiff > 24) raDiff -= 24;
             const angleRad = raDiff * 15 * (Math.PI / 180);
             const lightDist = 100;
             if (detailLight) detailLight.position.set(Math.sin(angleRad) * lightDist, 0, Math.cos(angleRad) * lightDist);
             
             // –°–±—Ä–∞—Å—ã–≤–∞–µ–º –≤—Ä–∞—â–µ–Ω–∏–µ –¥–ª—è –∞–∫–∫—É—Ä–∞—Ç–Ω–æ—Å—Ç–∏
             detailMainObject.rotation.set(0,0,0);
             
             const factEl = document.getElementById('d-fact');
             if (factEl) factEl.textContent = '–õ—É–Ω–∞ –≤—Å–µ–≥–¥–∞ –æ–±—Ä–∞—â–µ–Ω–∞ –∫ –ó–µ–º–ª–µ –æ–¥–Ω–æ–π —Å—Ç–æ—Ä–æ–Ω–æ–π. –ö–ª–∏–∫–Ω–∏—Ç–µ –ø–æ –Ω–µ–π, —á—Ç–æ–±—ã –≤–∫–ª—é—á–∏—Ç—å –≤—Ä–∞—â–µ–Ω–∏–µ.';
        }
    });
}

// === –û–ß–ò–°–¢–ö–ê –î–ï–¢–ê–õ–¨–ù–û–ô –°–¶–ï–ù–´ ===
function clearDetailScene() {
    const objectsToRemove = [];
    detailScene.traverse(obj => {
        if (obj.userData && obj.userData.removable) {
            objectsToRemove.push(obj);
        }
    });
    objectsToRemove.forEach(obj => {
        detailScene.remove(obj);
        if (obj.geometry) obj.geometry.dispose();
        if (obj.material) {
            if (Array.isArray(obj.material)) {
                obj.material.forEach(m => {
                    if (m.map) m.map.dispose();
                    m.dispose();
                });
            } else {
                if (obj.material.map) obj.material.map.dispose();
                obj.material.dispose();
            }
        }
    });
    detailMainObject = null;
    detailAtmosphere = null;
    detailRing = null;
    detailSunComparison = null;
    starShaderMaterial = null;
}

let labelStarPos = new THREE.Vector3();
let labelSunPos = new THREE.Vector3();

function updateDetailLabels() {
    if (!isDetailMode) return;
    
    const labelStar = document.getElementById('label-star');
    const labelSun = document.getElementById('label-sun');
    
    const starScreen = labelStarPos.clone().project(detailCamera);
    const sunScreen = labelSunPos.clone().project(detailCamera);
    
    labelStar.style.left = ((starScreen.x + 1) / 2 * window.innerWidth) + 'px';
    labelStar.style.top = ((-starScreen.y + 1) / 2 * window.innerHeight) + 'px';
    labelStar.classList.toggle('visible', starScreen.z < 1);
    
    labelSun.style.left = ((sunScreen.x + 1) / 2 * window.innerWidth) + 'px';
    labelSun.style.top = ((-sunScreen.y + 1) / 2 * window.innerHeight) + 'px';
    labelSun.classList.toggle('visible', sunScreen.z < 1);
}

function createDetailStar(starData) {
    clearDetailScene();
    
    const tempK = starData?.stats?.temp_k || 5778;
    const radiusSolar = starData?.stats?.radius_solar || 1;
    const colorInfo = getStarColorByTemperature(tempK);
    
    const sunRadius = 3;
    let starRadius;
    
    if (radiusSolar <= 1) {
        starRadius = sunRadius * Math.max(0.3, radiusSolar);
    } else if (radiusSolar <= 10) {
        starRadius = sunRadius * radiusSolar;
    } else if (radiusSolar <= 50) {
        starRadius = sunRadius * 10 + (radiusSolar - 10) * 0.6;
    } else if (radiusSolar <= 200) {
        starRadius = sunRadius * 10 + 24 + (radiusSolar - 50) * 0.2;
    } else {
        starRadius = sunRadius * 10 + 54 + Math.log10(radiusSolar - 199) * 10;
    }
    starRadius = Math.min(starRadius, 80);
    
    const starGeometry = new THREE.SphereGeometry(starRadius, 128, 128);
    
    starShaderMaterial = new THREE.ShaderMaterial({
        uniforms: {
            uTime: { value: 0 },
            uColorCore: { value: colorInfo.core },
            uColorMid: { value: colorInfo.mid },
            uColorEdge: { value: colorInfo.edge },
            uPulse: { value: 0.03 },
            uIntensity: { value: 1.5 }
        },
        vertexShader: `
            varying vec3 vNormal;
            varying vec3 vPosition;
            varying vec3 vViewPosition;
            void main() {
                vNormal = normalize(normalMatrix * normal);
                vPosition = position;
                vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                vViewPosition = -mvPosition.xyz;
                gl_Position = projectionMatrix * mvPosition;
            }
        `,
        fragmentShader: `
            uniform float uTime;
            uniform vec3 uColorCore;
            uniform vec3 uColorMid;
            uniform vec3 uColorEdge;
            uniform float uPulse;
            uniform float uIntensity;
            varying vec3 vNormal;
            varying vec3 vPosition;
            varying vec3 vViewPosition;
            
            vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
            vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
            vec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }
            vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }
            
            float snoise(vec3 v) {
                const vec2 C = vec2(1.0/6.0, 1.0/3.0);
                const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);
                vec3 i = floor(v + dot(v, C.yyy));
                vec3 x0 = v - i + dot(i, C.xxx);
                vec3 g = step(x0.yzx, x0.xyz);
                vec3 l = 1.0 - g;
                vec3 i1 = min(g.xyz, l.zxy);
                vec3 i2 = max(g.xyz, l.zxy);
                vec3 x1 = x0 - i1 + C.xxx;
                vec3 x2 = x0 - i2 + C.yyy;
                vec3 x3 = x0 - D.yyy;
                i = mod289(i);
                vec4 p = permute(permute(permute(i.z + vec4(0.0, i1.z, i2.z, 1.0)) + i.y + vec4(0.0, i1.y, i2.y, 1.0)) + i.x + vec4(0.0, i1.x, i2.x, 1.0));
                float n_ = 0.142857142857;
                vec3 ns = n_ * D.wyz - D.xzx;
                vec4 j = p - 49.0 * floor(p * ns.z * ns.z);
                vec4 x_ = floor(j * ns.z);
                vec4 y_ = floor(j - 7.0 * x_);
                vec4 x = x_ * ns.x + ns.yyyy;
                vec4 y = y_ * ns.x + ns.yyyy;
                vec4 h = 1.0 - abs(x) - abs(y);
                vec4 b0 = vec4(x.xy, y.xy);
                vec4 b1 = vec4(x.zw, y.zw);
                vec4 s0 = floor(b0)*2.0 + 1.0;
                vec4 s1 = floor(b1)*2.0 + 1.0;
                vec4 sh = -step(h, vec4(0.0));
                vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;
                vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;
                vec3 p0 = vec3(a0.xy, h.x);
                vec3 p1 = vec3(a0.zw, h.y);
                vec3 p2 = vec3(a1.xy, h.z);
                vec3 p3 = vec3(a1.zw, h.w);
                vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));
                p0 *= norm.x; p1 *= norm.y; p2 *= norm.z; p3 *= norm.w;
                vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
                m = m * m;
                return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));
            }
            
            float fbm(vec3 p) {
                float value = 0.0;
                float amplitude = 0.5;
                for (int i = 0; i < 5; i++) {
                    value += amplitude * snoise(p);
                    p *= 2.0;
                    amplitude *= 0.5;
                }
                return value;
            }
            
            void main() {
                vec3 viewDir = normalize(vViewPosition);
                float fresnel = pow(1.0 - max(dot(vNormal, viewDir), 0.0), 2.5);
                vec3 noisePos = vPosition * 1.5;
                float noise1 = fbm(noisePos + uTime * 0.12);
                float noise2 = fbm(noisePos * 2.0 - uTime * 0.08);
                float noise3 = snoise(noisePos * 4.0 + uTime * 0.15);
                float plasma = noise1 * 0.5 + noise2 * 0.3 + noise3 * 0.2;
                float pulse = 1.0 + sin(uTime * 1.5) * uPulse;
                float granulation = smoothstep(-0.3, 0.7, plasma);
                vec3 color = mix(uColorCore, uColorMid, granulation * 0.5);
                color = mix(color, uColorEdge, fresnel * 0.6);
                float cells = smoothstep(0.5, 0.8, noise3) * 0.4;
                color += uColorCore * cells;
                float spots = smoothstep(0.65, 0.85, snoise(noisePos * 5.0 - uTime * 0.03));
                color *= (1.0 - spots * 0.25);
                float limb = 1.0 - fresnel * 0.3;
                float centerGlow = pow(1.0 - fresnel, 0.5);
                vec3 finalColor = color * pulse * limb * uIntensity;
                finalColor += uColorCore * centerGlow * 0.3;
                finalColor = finalColor / (finalColor + vec3(1.0)) * 1.3;
                gl_FragColor = vec4(finalColor, 1.0);
            }
        `
    });
    
    detailMainObject = new THREE.Mesh(starGeometry, starShaderMaterial);
    detailMainObject.userData.removable = true;
    detailScene.add(detailMainObject);
    
    const coronaLayers = [
        { scale: 1.03, opacity: 0.5, color: colorInfo.core },
        { scale: 1.08, opacity: 0.35, color: colorInfo.mid },
        { scale: 1.18, opacity: 0.2, color: colorInfo.mid },
        { scale: 1.35, opacity: 0.12, color: colorInfo.edge },
        { scale: 1.6, opacity: 0.06, color: colorInfo.edge },
        { scale: 2.0, opacity: 0.03, color: colorInfo.edge }
    ];
    
    coronaLayers.forEach((layer, index) => {
        const coronaGeo = new THREE.SphereGeometry(starRadius * layer.scale, 64, 64);
        const coronaMat = new THREE.ShaderMaterial({
            uniforms: {
                uTime: { value: 0 },
                uColor: { value: layer.color },
                uOpacity: { value: layer.opacity }
            },
            vertexShader: `
                varying vec3 vNormal;
                varying vec3 vViewPosition;
                void main() {
                    vNormal = normalize(normalMatrix * normal);
                    vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                    vViewPosition = -mvPosition.xyz;
                    gl_Position = projectionMatrix * mvPosition;
                }
            `,
            fragmentShader: `
                uniform float uTime;
                uniform vec3 uColor;
                uniform float uOpacity;
                varying vec3 vNormal;
                varying vec3 vViewPosition;
                void main() {
                    vec3 viewDir = normalize(vViewPosition);
                    float fresnel = pow(1.0 - abs(dot(vNormal, viewDir)), 3.0);
                    float pulse = 1.0 + sin(uTime * 1.2 + float(${index})) * 0.08;
                    float alpha = fresnel * uOpacity * pulse;
                    vec3 glowColor = uColor * (1.0 + fresnel * 0.5);
                    gl_FragColor = vec4(glowColor, alpha);
                }
            `,
            transparent: true,
            side: THREE.BackSide,
            blending: THREE.AdditiveBlending,
            depthWrite: false
        });
        
        const corona = new THREE.Mesh(coronaGeo, coronaMat);
        corona.userData.removable = true;
        corona.userData.isCorona = true;
        detailScene.add(corona);
    });
    
    const starLight = new THREE.PointLight(colorInfo.color, 2, 200);
    starLight.userData.removable = true;
    detailScene.add(starLight);
    
    const sunPositionX = starRadius + sunRadius + 12;
    
    const sunGeometry = new THREE.SphereGeometry(sunRadius, 64, 64);
    const sunMaterial = new THREE.ShaderMaterial({
        uniforms: { uTime: { value: 0 } },
        vertexShader: `
            varying vec3 vNormal;
            varying vec3 vPosition;
            void main() {
                vNormal = normalize(normalMatrix * normal);
                vPosition = position;
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
        `,
        fragmentShader: `
            uniform float uTime;
            varying vec3 vNormal;
            varying vec3 vPosition;
            void main() {
                float n = fract(sin(dot(vPosition * 10.0 + uTime * 0.5, vec3(12.9898, 78.233, 45.164))) * 43758.5453) * 0.1;
                vec3 core = vec3(1.0, 1.0, 0.8);
                vec3 mid = vec3(1.0, 0.85, 0.4);
                float fresnel = pow(1.0 - abs(dot(vNormal, vec3(0.0, 0.0, 1.0))), 2.0);
                vec3 color = mix(core, mid, fresnel * 0.5 + n);
                gl_FragColor = vec4(color * 1.2, 1.0);
            }
        `
    });
    
    detailSunComparison = new THREE.Mesh(sunGeometry, sunMaterial);
    detailSunComparison.position.set(sunPositionX, 0, 0);
    detailSunComparison.userData.removable = true;
    detailScene.add(detailSunComparison);
    
    [1.15, 1.35, 1.6].forEach((scale, i) => {
        const glow = new THREE.Mesh(
            new THREE.SphereGeometry(sunRadius * scale, 32, 32),
            new THREE.MeshBasicMaterial({
                color: [0xffdd44, 0xffaa00, 0xff8800][i],
                transparent: true,
                opacity: [0.3, 0.15, 0.06][i],
                side: THREE.BackSide,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            })
        );
        glow.position.set(sunPositionX, 0, 0);
        glow.userData.removable = true;
        detailScene.add(glow);
    });
    
    labelStarPos.set(0, -starRadius - 4, 0);
    labelSunPos.set(sunPositionX, -sunRadius - 3, 0);
    
    document.getElementById('label-star').innerHTML = `<span class="name" style="color:${colorInfo.colorHex}">${starData?.name || '–ó–≤–µ–∑–¥–∞'}</span><span class="size">${radiusSolar.toFixed(1)} R‚òâ</span>`;
    document.getElementById('label-sun').innerHTML = `<span class="name" style="color:#ffcc00">–°–æ–ª–Ω—Ü–µ</span><span class="size">1 R‚òâ</span>`;
    
    updateSizeComparison(starData?.name || '–ó–≤–µ–∑–¥–∞', radiusSolar, colorInfo.colorHex);
    
    const cameraDistance = Math.max(60, starRadius * 2.5 + sunPositionX * 0.8);
    detailCamera.position.set(0, starRadius * 0.3, cameraDistance);
    detailControls.target.set(sunPositionX * 0.3, 0, 0);
    detailControls.minDistance = Math.max(15, starRadius * 1.2);
    detailControls.maxDistance = cameraDistance * 3;
    detailControls.update();
    
    return colorInfo;
}

function createDetailPlanet(pData, planetName) {
    clearDetailScene();
    
    const textureLoader = new THREE.TextureLoader();
    
    const PLANET_RADIUS_EARTH = {
        '–ú–µ—Ä–∫—É—Ä–∏–π': 0.38, '–í–µ–Ω–µ—Ä–∞': 0.95, '–ú–∞—Ä—Å': 0.53,
        '–Æ–ø–∏—Ç–µ—Ä': 11.2, '–°–∞—Ç—É—Ä–Ω': 9.45, '–£—Ä–∞–Ω': 4.0, '–ù–µ–ø—Ç—É–Ω': 3.88
    };
    
    const radiusEarth = PLANET_RADIUS_EARTH[planetName] || 1;
    
    // –ë–∞–∑–æ–≤—ã–π —Ä–∞–¥–∏—É—Å –ó–µ–º–ª–∏ (—É–º–µ–Ω—å—à–µ–Ω —á—Ç–æ–±—ã –±–æ–ª—å—à–∏–µ –ø–ª–∞–Ω–µ—Ç—ã –ø–æ–º–µ—â–∞–ª–∏—Å—å)
    const earthRadius = 2;
    
    // –õ–ò–ù–ï–ô–ù–û–ï –º–∞—Å—à—Ç–∞–±–∏—Ä–æ–≤–∞–Ω–∏–µ ‚Äî —Ç–æ—á–Ω—ã–µ –ø—Ä–æ–ø–æ—Ä—Ü–∏–∏
    const planetRadius = earthRadius * radiusEarth;
    
    const geometry = new THREE.SphereGeometry(planetRadius, 64, 64);
    let material;
    if (pData.tex) {
        material = new THREE.MeshPhongMaterial({
            map: textureLoader.load(pData.tex),
            bumpMap: pData.bump ? textureLoader.load(pData.bump) : null,
            bumpScale: 0.3,
            specular: new THREE.Color(0x222222),
            shininess: 5
        });
    } else {
        material = new THREE.MeshPhongMaterial({ color: 0x888888 });
    }
    
    detailMainObject = new THREE.Mesh(geometry, material);
    detailMainObject.userData.removable = true;
    detailScene.add(detailMainObject);
    
    if (pData.glow) {
        const atmoGeo = new THREE.SphereGeometry(planetRadius * 1.05, 64, 64);
        const atmoMat = new THREE.MeshBasicMaterial({
            color: pData.glow,
            transparent: true,
            opacity: 0.15,
            side: THREE.BackSide,
            blending: THREE.AdditiveBlending
        });
        detailAtmosphere = new THREE.Mesh(atmoGeo, atmoMat);
        detailAtmosphere.userData.removable = true;
        detailScene.add(detailAtmosphere);
    }
    
    if (pData.ring) {
        const ringGeo = new THREE.RingGeometry(planetRadius * pData.ring.inner, planetRadius * pData.ring.outer, 64);
        const ringTex = textureLoader.load(pData.ring.tex);
        const ringMat = new THREE.MeshBasicMaterial({
            map: ringTex,
            side: THREE.DoubleSide,
            transparent: true,
            opacity: 0.9
        });
        detailRing = new THREE.Mesh(ringGeo, ringMat);
        detailRing.rotation.x = Math.PI / 2.5;
        detailRing.userData.removable = true;
        detailScene.add(detailRing);
    }
    
    // –ü–æ–∑–∏—Ü–∏—è –ó–µ–º–ª–∏ ‚Äî —Å–ø—Ä–∞–≤–∞ –æ—Ç –ø–ª–∞–Ω–µ—Ç—ã —Å –æ—Ç—Å—Ç—É–ø–æ–º
    const earthPositionX = planetRadius + earthRadius + 5;
    
    const earthGeometry = new THREE.SphereGeometry(earthRadius, 64, 64);
    const earthMaterial = new THREE.MeshPhongMaterial({
        map: textureLoader.load('textures/earth-blue-marble.jpg'),
        specular: new THREE.Color(0x333333),
        shininess: 15
    });
    const earthMesh = new THREE.Mesh(earthGeometry, earthMaterial);
    earthMesh.position.set(earthPositionX, 0, 0);
    earthMesh.userData.removable = true;
    earthMesh.userData.isEarth = true;
    detailScene.add(earthMesh);
    
    const earthAtmoGeo = new THREE.SphereGeometry(earthRadius * 1.08, 64, 64);
    const earthAtmoMat = new THREE.MeshBasicMaterial({
        color: 0x6699ff,
        transparent: true,
        opacity: 0.15,
        side: THREE.BackSide,
        blending: THREE.AdditiveBlending
    });
    const earthAtmo = new THREE.Mesh(earthAtmoGeo, earthAtmoMat);
    earthAtmo.position.set(earthPositionX, 0, 0);
    earthAtmo.userData.removable = true;
    detailScene.add(earthAtmo);
    
    // –ü–æ–∑–∏—Ü–∏–∏ –Ω–∞–¥–ø–∏—Å–µ–π
    labelStarPos.set(0, -planetRadius - 2, 0);
    labelSunPos.set(earthPositionX, -earthRadius - 2, 0);
    
    const planetColorHex = typeof pData.glow === 'number' ? '#' + pData.glow.toString(16).padStart(6, '0') : '#ffd700';
    
    document.getElementById('label-star').innerHTML = `<span class="name" style="color:${planetColorHex}">${planetName}</span><span class="size">${radiusEarth.toFixed(2)} R‚äï</span>`;
    document.getElementById('label-sun').innerHTML = `<span class="name" style="color:#6699ff">–ó–µ–º–ª—è</span><span class="size">1 R‚äï</span>`;
    
    updatePlanetSizeComparison(planetName, radiusEarth, planetColorHex);
    
    // –ö–∞–º–µ—Ä–∞ ‚Äî –æ—Ç–æ–¥–≤–∏–≥–∞–µ–º –¥–∞–ª—å—à–µ –¥–ª—è –±–æ–ª—å—à–∏—Ö –ø–ª–∞–Ω–µ—Ç
    const cameraDistance = Math.max(30, planetRadius * 2.5 + earthPositionX);
    detailCamera.position.set(0, planetRadius * 0.3, cameraDistance);
    detailControls.target.set(earthPositionX * 0.3, 0, 0);
    detailControls.minDistance = Math.max(8, planetRadius * 1.2);
    detailControls.maxDistance = cameraDistance * 3;
    detailControls.update();
}

// === –°–û–ó–î–ê–ù–ò–ï 3D –¢–ï–ö–°–¢–û–í–û–ô –ú–ï–¢–ö–ò ===
function createLabel3D(text, color) {
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    const fontSize = 48;
    ctx.font = `bold ${fontSize}px Arial`;
    const textWidth = ctx.measureText(text).width;
    canvas.width = textWidth + 30;
    canvas.height = fontSize + 20;
    
    ctx.font = `bold ${fontSize}px Arial`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    
    // –û–±–≤–æ–¥–∫–∞ –¥–ª—è —á–∏—Ç–∞–µ–º–æ—Å—Ç–∏
    ctx.strokeStyle = 'rgba(0,0,0,0.9)';
    ctx.lineWidth = 4;
    ctx.strokeText(text, canvas.width / 2, canvas.height / 2);
    
    // –¢–µ–Ω—å
    ctx.shadowColor = 'rgba(0,0,0,0.7)';
    ctx.shadowBlur = 4;
    ctx.shadowOffsetX = 1;
    ctx.shadowOffsetY = 1;
    
    // –û—Å–Ω–æ–≤–Ω–æ–π —Ç–µ–∫—Å—Ç
    ctx.fillStyle = '#' + new THREE.Color(color).getHexString();
    ctx.fillText(text, canvas.width / 2, canvas.height / 2);
    
    const texture = new THREE.CanvasTexture(canvas);
    texture.minFilter = THREE.LinearFilter;
    
    const material = new THREE.SpriteMaterial({ 
        map: texture, 
        transparent: true, 
        depthTest: false,
        sizeAttenuation: false // –§–∏–∫—Å–∏—Ä–æ–≤–∞–Ω–Ω—ã–π —Ä–∞–∑–º–µ—Ä –Ω–∞ —ç–∫—Ä–∞–Ω–µ
    });
    
    const sprite = new THREE.Sprite(material);
    
    // –ú–∞–ª–µ–Ω—å–∫–∏–π –º–∞—Å—à—Ç–∞–± –¥–ª—è sizeAttenuation: false
    // –ü—Ä–∏–º–µ—Ä–Ω–æ 14-16px –≤–∏–∑—É–∞–ª—å–Ω–æ
    const scale = 0.00004;
    sprite.scale.set(canvas.width * scale, canvas.height * scale, 1);
    
    return sprite;
}

function createLabel3DScaled(text, color, scale = 1.0) {
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    const fontSize = 64;
    ctx.font = `bold ${fontSize}px Arial`;
    const textWidth = ctx.measureText(text).width;
    canvas.width = textWidth + 40;
    canvas.height = fontSize + 30;
    
    ctx.font = `bold ${fontSize}px Arial`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    
    ctx.strokeStyle = 'rgba(0,0,0,0.9)';
    ctx.lineWidth = 6;
    ctx.strokeText(text, canvas.width / 2, canvas.height / 2);
    
    ctx.shadowColor = 'rgba(0,0,0,0.8)';
    ctx.shadowBlur = 8;
    ctx.fillStyle = '#' + new THREE.Color(color).getHexString();
    ctx.fillText(text, canvas.width / 2, canvas.height / 2);
    
    const texture = new THREE.CanvasTexture(canvas);
    const material = new THREE.SpriteMaterial({ 
        map: texture, 
        transparent: true, 
        depthTest: false,
        sizeAttenuation: true // –†–∞–∑–º–µ—Ä –∑–∞–≤–∏—Å–∏—Ç –æ—Ç —Ä–∞—Å—Å—Ç–æ—è–Ω–∏—è
    });
    
    const sprite = new THREE.Sprite(material);
    sprite.scale.set(canvas.width * 0.03 * scale, canvas.height * 0.03 * scale, 1);
    
    return sprite;
}

async function centerAndFlyToObject(objectData, objectPosition, type) {
    if (isTransitioning || isFlightMode || isDetailMode) return;
    
    // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º —á—Ç–æ –≥–æ—Ç–æ–≤–∏–º—Å—è –∫ –ø–æ–ª—ë—Ç—É
    const indicator = document.getElementById('mode-indicator');
    indicator.innerHTML = `üéØ –ù–∞–≤–µ–¥–µ–Ω–∏–µ –Ω–∞ ${objectData.name}...`;
    indicator.classList.add('visible');
    
    // –°–Ω–∞—á–∞–ª–∞ —Ü–µ–Ω—Ç—Ä–∏—Ä—É–µ–º –∫–∞–º–µ—Ä—É –Ω–∞ –æ–±—ä–µ–∫—Ç
    await centerCameraOnObject(objectPosition);
    
    indicator.classList.remove('visible');
    
    // –¢–µ–ø–µ—Ä—å –Ω–∞—á–∏–Ω–∞–µ–º –ø–æ–ª—ë—Ç
    if (type === 'star') {
        let cachedData = starDataCache[objectData.name] || null;
        if (!cachedData) {
            indicator.innerHTML = `üîç –ò–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏—è "${objectData.name}"...`;
            indicator.classList.add('visible');
            cachedData = await fetchStarData(objectData.name);
            indicator.classList.remove('visible');
        }
        
        if (!cachedData) {
            startFallbackFlight(objectData.name, objectPosition);
            return;
        }
        
        startFlight(objectData.name, cachedData, 'star');
    } else if (type === 'planet') {
        startFlight(objectData.name, null, 'planet');
    } 
    // --- –ò–ó–ú–ï–ù–ï–ù–ò–ï: –î–æ–±–∞–≤–ª–µ–Ω –∑–∞–ø—É—Å–∫ –ø–æ–ª–µ—Ç–∞ –∫ –õ—É–Ω–µ ---
    else if (type === 'moon') {
        startFlight(objectData.name, null, 'moon');
    }
    // ------------------------------------------------
}



function centerCameraOnObject(targetPosition) {
    return new Promise((resolve) => {
        if (!targetPosition) {
            resolve();
            return;
        }
        
        const normalized = targetPosition.clone().normalize();
        const targetTheta = Math.atan2(normalized.x, normalized.z);
        const targetPhi = Math.acos(Math.max(-1, Math.min(1, normalized.y)));
        
        if (isInsideMode) {
            // –í–Ω—É—Ç—Ä–µ–Ω–Ω–∏–π —Ä–µ–∂–∏–º ‚Äî –ø–æ–≤–æ—Ä–∞—á–∏–≤–∞–µ–º –∫–∞–º–µ—Ä—É
            const startTheta = spherical.theta;
            const startPhi = spherical.phi;
            
            let dTheta = targetTheta - startTheta;
            while (dTheta > Math.PI) dTheta -= 2 * Math.PI;
            while (dTheta < -Math.PI) dTheta += 2 * Math.PI;
            
            const duration = 600; // –ë—ã—Å—Ç—Ä–µ–µ —á–µ–º –æ–±—ã—á–Ω–∞—è –Ω–∞–≤–∏–≥–∞—Ü–∏—è
            const startTime = Date.now();
            
            const animateCenter = () => {
                const elapsed = Date.now() - startTime;
                const t = Math.min(elapsed / duration, 1);
                const easeT = 1 - Math.pow(1 - t, 3);
                
                spherical.theta = startTheta + dTheta * easeT;
                spherical.phi = startPhi + (targetPhi - startPhi) * easeT;
                
                const minPhi = 0.05;
                const maxPhi = settings.ground ? (Math.PI / 2 - 0.05) : (Math.PI - 0.05);
                spherical.phi = Math.max(minPhi, Math.min(maxPhi, spherical.phi));
                
                updateInsideCamera();
                
                if (t >= 1) {
                    resolve();
                } else {
                    requestAnimationFrame(animateCenter);
                }
            };
            
            animateCenter();
        } else {
            // –í–Ω–µ—à–Ω–∏–π —Ä–µ–∂–∏–º ‚Äî –ø–æ–≤–æ—Ä–∞—á–∏–≤–∞–µ–º –≤–∏–¥ —á–µ—Ä–µ–∑ controls
            const targetLookAt = normalized.clone().multiplyScalar(SPHERE_RADIUS);
            const startLookAt = controls.target.clone();
            
            const duration = 600;
            const startTime = Date.now();
            
            const animateCenter = () => {
                const elapsed = Date.now() - startTime;
                const t = Math.min(elapsed / duration, 1);
                const easeT = 1 - Math.pow(1 - t, 3);
                
                controls.target.lerpVectors(startLookAt, targetLookAt, easeT);
                controls.update();
                
                if (t >= 1) {
                    resolve();
                } else {
                    requestAnimationFrame(animateCenter);
                }
            };
            
            animateCenter();
        }
    });
}


// === –û–ë–ù–û–í–õ–ï–ù–ò–ï UI –°–†–ê–í–ù–ï–ù–ò–Ø –†–ê–ó–ú–ï–†–û–í ===
function updatePlanetSizeComparison(planetName, radiusEarth, colorHex) {
    const comparison = document.getElementById('size-comparison');
    comparison.style.display = 'block';
    
    const earthDotSize = 10;
    
    // –õ–∏–Ω–µ–π–Ω–æ–µ –º–∞—Å—à—Ç–∞–±–∏—Ä–æ–≤–∞–Ω–∏–µ —Å –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ–º
    let planetDotSize = earthDotSize * radiusEarth;
    planetDotSize = Math.min(120, planetDotSize);
    
    const sunDot = document.getElementById('sun-dot');
    sunDot.style.width = earthDotSize + 'px';
    sunDot.style.height = earthDotSize + 'px';
    sunDot.style.background = '#6699ff';
    sunDot.style.boxShadow = '0 0 8px #6699ff';
    
    const sunRow = sunDot.closest('.size-row');
    sunRow.querySelector('.size-label').textContent = '–ó–µ–º–ª—è';
    sunRow.querySelector('.size-value').textContent = '1 R‚äï';
    
    const starDot = document.getElementById('star-dot');
    starDot.style.width = Math.max(4, planetDotSize) + 'px';
    starDot.style.height = Math.max(4, planetDotSize) + 'px';
    starDot.style.background = colorHex;
    starDot.style.boxShadow = `0 0 ${Math.min(15, planetDotSize/4)}px ${colorHex}`;
    
    document.getElementById('star-size-label').textContent = planetName;
    document.getElementById('star-size-value').textContent = radiusEarth.toFixed(2) + ' R‚äï';
}

// === –ò–ó–ú–ï–ù–ï–ù–ò–ï: –°–±—Ä–æ—Å UI —Å—Ä–∞–≤–Ω–µ–Ω–∏—è –¥–ª—è –∑–≤—ë–∑–¥ ===
function updateSizeComparison(starName, radiusSolar, colorHex) {
    const comparison = document.getElementById('size-comparison');
    comparison.style.display = 'block';
    
    // –°–æ–ª–Ω—Ü–µ = 10px
    const sunDotSize = 10;
    
    // –ó–≤–µ–∑–¥–∞ ‚Äî –ø—Ä–æ–ø–æ—Ä—Ü–∏–æ–Ω–∞–ª—å–Ω–æ, –Ω–æ —Å –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ–º
    let starDotSize;
    if (radiusSolar <= 1) {
        starDotSize = sunDotSize * radiusSolar;
    } else if (radiusSolar <= 20) {
        starDotSize = sunDotSize * radiusSolar;
    } else if (radiusSolar <= 100) {
        starDotSize = sunDotSize * 20 + (radiusSolar - 20) * 0.5;
    } else {
        starDotSize = sunDotSize * 20 + 40 + Math.log10(radiusSolar - 99) * 20;
    }
    
    // –ú–∞–∫—Å–∏–º—É–º 120px
    starDotSize = Math.min(120, starDotSize);
    
    const sunDot = document.getElementById('sun-dot');
    sunDot.style.width = sunDotSize + 'px';
    sunDot.style.height = sunDotSize + 'px';
    sunDot.style.background = '#ffcc00';
    
    const sunRow = sunDot.closest('.size-row');
    sunRow.querySelector('.size-label').textContent = '–°–æ–ª–Ω—Ü–µ';
    sunRow.querySelector('.size-value').textContent = '1 R‚òâ';
    
    const starDot = document.getElementById('star-dot');
    starDot.style.width = Math.max(3, starDotSize) + 'px';
    starDot.style.height = Math.max(3, starDotSize) + 'px';
    starDot.style.background = colorHex;
    starDot.style.boxShadow = `0 0 ${Math.min(20, starDotSize/3)}px ${colorHex}`;
    
    document.getElementById('star-size-label').textContent = starName;
    document.getElementById('star-size-value').textContent = 
        radiusSolar >= 10 ? radiusSolar.toFixed(0) + ' R‚òâ' : radiusSolar.toFixed(1) + ' R‚òâ';
}



// === –ó–ê–ü–û–õ–ù–ï–ù–ò–ï –ò–ù–§–û–†–ú–ê–¶–ò–ò –û –ó–í–ï–ó–î–ï ===
function fillStarInfo(starName, data, colorInfo) {
    console.log('fillStarInfo called with:', { starName, data, colorInfo }); // –î–ª—è –æ—Ç–ª–∞–¥–∫–∏
    
    // –ù–∞–∑–≤–∞–Ω–∏–µ
    document.getElementById('d-name').textContent = starName;
    
    // –¢–∏–ø –∑–≤–µ–∑–¥—ã
    let starType = '–ó–≤–µ–∑–¥–∞';
    if (data && data.stats && data.stats.spectral_class) {
        starType = getSpectralClassDescription(data.stats.spectral_class);
    }
    document.getElementById('d-type').textContent = starType;
    document.getElementById('d-type').style.color = colorInfo?.colorHex || '#ffffff';
    
    // –°–æ–∑–≤–µ–∑–¥–∏–µ
    const constEl = document.getElementById('d-constellation');
    if (data && data.constellation) {
        const latinPart = data.constellation_latin ? ` (${data.constellation_latin})` : '';
        constEl.textContent = `–°–æ–∑–≤–µ–∑–¥–∏–µ: ${data.constellation}${latinPart}`;
        constEl.style.display = 'block';
    } else {
        constEl.style.display = 'none';
    }
    
    // –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞
    let statsHTML = '';
    
    if (data && data.stats) {
        const s = data.stats;
        
        if (s.dist_ly != null) {
            statsHTML += `<div class="d-stat highlight">
                <h4>–†–∞—Å—Å—Ç–æ—è–Ω–∏–µ</h4>
                <p>${formatNumber(s.dist_ly, 1)} —Å–≤. –ª–µ—Ç</p>
            </div>`;
        }
        
        if (s.mag_app != null) {
            statsHTML += `<div class="d-stat">
                <h4>–í–∏–¥–∏–º–∞—è –∑–≤. –≤–µ–ª–∏—á–∏–Ω–∞</h4>
                <p>${formatNumber(s.mag_app, 2)}m</p>
            </div>`;
        }
        
        if (s.temp_k != null) {
            statsHTML += `<div class="d-stat highlight">
                <h4>–¢–µ–º–ø–µ—Ä–∞—Ç—É—Ä–∞</h4>
                <p>${formatNumber(s.temp_k)} K</p>
            </div>`;
        }
        
        if (s.radius_solar != null) {
            statsHTML += `<div class="d-stat">
                <h4>–†–∞–¥–∏—É—Å</h4>
                <p>${formatNumber(s.radius_solar, 2)} R‚òâ</p>
            </div>`;
        }
        
        if (s.mass_solar != null) {
            statsHTML += `<div class="d-stat">
                <h4>–ú–∞—Å—Å–∞</h4>
                <p>${formatNumber(s.mass_solar, 2)} M‚òâ</p>
            </div>`;
        }
        
        if (s.lum_solar != null) {
            statsHTML += `<div class="d-stat highlight">
                <h4>–°–≤–µ—Ç–∏–º–æ—Å—Ç—å</h4>
                <p>${formatNumber(s.lum_solar)} L‚òâ</p>
            </div>`;
        }
        
        if (s.spectral_class) {
            statsHTML += `<div class="d-stat">
                <h4>–°–ø–µ–∫—Ç—Ä–∞–ª—å–Ω—ã–π –∫–ª–∞—Å—Å</h4>
                <p>${s.spectral_class}</p>
            </div>`;
        }
        
        if (s.age_my != null) {
            statsHTML += `<div class="d-stat">
                <h4>–í–æ–∑—Ä–∞—Å—Ç</h4>
                <p>${formatNumber(s.age_my)} –º–ª–Ω –ª–µ—Ç</p>
            </div>`;
        }
    }
    
    if (!statsHTML) {
        statsHTML = `<div class="d-stat"><h4>–î–∞–Ω–Ω—ã–µ</h4><p>–ù–µ—Ç –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏</p></div>`;
    }
    
    document.getElementById('d-stats').innerHTML = statsHTML;
    
    // –§–∞–∫—Ç ‚Äî –æ–¥–∏–Ω —Å–ª—É—á–∞–π–Ω—ã–π
    const factEl = document.getElementById('d-fact');
    if (data && data.facts && Array.isArray(data.facts) && data.facts.length > 0) {
        const randomFact = data.facts[Math.floor(Math.random() * data.facts.length)];
        factEl.textContent = randomFact;
        factEl.style.display = 'block';
    } else {
        factEl.style.display = 'none';
    }
    
    // Wikipedia —Å—Å—ã–ª–∫–∞
    const wikiEl = document.getElementById('d-wiki');
    if (data && data.wiki_url) {
        wikiEl.innerHTML = `<a href="${data.wiki_url}" target="_blank" rel="noopener noreferrer">üìñ Wikipedia</a>`;
        wikiEl.style.display = 'block';
    } else {
        wikiEl.style.display = 'none';
    }
}

// === –ó–ê–ü–û–õ–ù–ï–ù–ò–ï –ò–ù–§–û–†–ú–ê–¶–ò–ò –û –ü–õ–ê–ù–ï–¢–ï ===
function fillPlanetInfo(name, pData) {
    document.getElementById('d-name').textContent = name;
    document.getElementById('d-type').textContent = pData.type;
    document.getElementById('d-type').style.color = '#ffd700';
    document.getElementById('d-constellation').style.display = 'none';
    
    const statsHTML = `
        <div class="d-stat highlight">
            <h4>–î–∏–∞–º–µ—Ç—Ä</h4>
            <p>${pData.info.diameter}</p>
        </div>
        <div class="d-stat">
            <h4>–ú–∞—Å—Å–∞</h4>
            <p>${pData.info.mass}</p>
        </div>
        <div class="d-stat highlight">
            <h4>–¢–µ–º–ø–µ—Ä–∞—Ç—É—Ä–∞</h4>
            <p>${pData.info.temp}</p>
        </div>
        <div class="d-stat">
            <h4>–°—É—Ç–∫–∏</h4>
            <p>${pData.info.day}</p>
        </div>
        <div class="d-stat">
            <h4>–ì–æ–¥</h4>
            <p>${pData.info.year}</p>
        </div>
        <div class="d-stat">
            <h4>–°–ø—É—Ç–Ω–∏–∫–∏</h4>
            <p>${pData.info.moons}</p>
        </div>
        <div class="d-stat">
            <h4>–ì—Ä–∞–≤–∏—Ç–∞—Ü–∏—è</h4>
            <p>${pData.info.gravity}</p>
        </div>
        <div class="d-stat highlight">
            <h4>–†–∞—Å—Å—Ç–æ—è–Ω–∏–µ –æ—Ç –°–æ–ª–Ω—Ü–∞</h4>
            <p>${pData.info.dist}</p>
        </div>
    `;
    document.getElementById('d-stats').innerHTML = statsHTML;
    
    // –§–∞–∫—Ç - –æ–¥–∏–Ω —Å–ª—É—á–∞–π–Ω—ã–π
    if (pData.facts && pData.facts.length > 0) {
        const randomFact = pData.facts[Math.floor(Math.random() * pData.facts.length)];
        document.getElementById('d-fact').textContent = randomFact;
        document.getElementById('d-fact').style.display = 'block';
    } else {
        document.getElementById('d-fact').style.display = 'none';
    }
    
    document.getElementById('d-wiki').style.display = 'none';
}

// === –°–¢–ê–†–¢ –ü–û–õ–Å–¢–ê –ö –û–ë–™–ï–ö–¢–£ ===
function startFlight(targetName, targetData, type) {
    isFlightMode = true;
    flightTargetName = targetName;
    flightTargetData = targetData;
    detailType = type;
    flightStartTime = Date.now();
    
    savedCameraState = {
        position: camera.position.clone(),
        fov: camera.fov,
        isInsideMode: isInsideMode,
        spherical: { ...spherical }
    };
    
    // –û–ø—Ä–µ–¥–µ–ª—è–µ–º —Ä–∞—Å—Å—Ç–æ—è–Ω–∏–µ –¥–ª—è –∞–Ω–∏–º–∞—Ü–∏–∏ —Å—á—ë—Ç—á–∏–∫–∞
    if (type === 'star' && targetData?.stats?.dist_ly) {
        flightStartDist = targetData.stats.dist_ly;
        document.getElementById('flight-unit').textContent = '—Å–≤. –ª–µ—Ç';
    } else if (type === 'star') {
        flightStartDist = 100; // –î–µ—Ñ–æ–ª—Ç–Ω–æ–µ —Ä–∞—Å—Å—Ç–æ—è–Ω–∏–µ
        document.getElementById('flight-unit').textContent = '—Å–≤. –ª–µ—Ç';
    } else if (type === 'planet') {
        const pData = PLANETS_DATA[targetName];
        if (pData) {
            let cleanStr = pData.info.dist.replace(',', '.').replace(/[^\d.]/g, '');
            let val = parseFloat(cleanStr) || 0;
            
            if (pData.info.dist.includes('–º–ª—Ä–¥')) {
                flightStartDist = val * 1000000;
            } else if (pData.info.dist.includes('–º–ª–Ω')) {
                flightStartDist = val * 1000;
            } else {
                flightStartDist = val; 
            }
            
            if (flightStartDist === 0) flightStartDist = 100000;
        } else {
            flightStartDist = 100000;
        }
        document.getElementById('flight-unit').textContent = '—Ç—ã—Å. –∫–º';
    } 
    // --- –ò–ó–ú–ï–ù–ï–ù–ò–ï: –†–∞—Å—Å—Ç–æ—è–Ω–∏–µ –¥–æ –õ—É–Ω—ã ---
    else if (type === 'moon') {
        flightStartDist = 384400; // –°—Ä–µ–¥–Ω–µ–µ —Ä–∞—Å—Å—Ç–æ—è–Ω–∏–µ –≤ –∫–º
        document.getElementById('flight-unit').textContent = '–∫–º';
    }
    // -------------------------------------
    
    controls.enabled = false;
    
    document.getElementById('flight-status').style.display = 'block';
    document.getElementById('flight-target-name').textContent = targetName;
    document.getElementById('tooltip').style.display = 'none';
    document.getElementById('search-container').style.opacity = '0';
    document.getElementById('controls-panel').style.opacity = '0';
    document.getElementById('info-panel').style.opacity = '0';
}

// === –û–ë–ù–û–í–õ–ï–ù–ò–ï –ü–û–õ–Å–¢–ê ===
function updateFlight() {
    if (!isFlightMode) return;
    
    const elapsed = Date.now() - flightStartTime;
    const progress = Math.min(elapsed / flightDuration, 1);
    const ease = Math.pow(progress, 3);
    
    // –°—á—ë—Ç—á–∏–∫ —Ä–∞—Å—Å—Ç–æ—è–Ω–∏—è
    const currentDist = flightStartDist * (1 - ease);
    if (detailType === 'star') {
        document.getElementById('flight-counter').innerText = currentDist.toFixed(1);
    } else {
        document.getElementById('flight-counter').innerText = Math.floor(currentDist).toLocaleString('ru-RU');
    }
    
    // –≠—Ñ—Ñ–µ–∫—Ç –∑—É–º–∞
    const startFov = savedCameraState.fov;
    const endFov = 5;
    camera.fov = startFov + (endFov - startFov) * ease;
    camera.updateProjectionMatrix();
    
    // –≠—Ñ—Ñ–µ–∫—Ç—ã
    const intensity = Math.sin(progress * Math.PI);
    updateVignette(intensity * 0.5);
    updateSpeedLines(intensity * 0.8, 1);
    
    if (progress >= 1) finishFlight();
}


// === –û–¢–ö–†–´–¢–ò–ï –î–ï–¢–ê–õ–¨–ù–û–ì–û –í–ò–î–ê –õ–£–ù–´ (–° –õ–û–ì–ê–ú–ò) ===
function openMoonDetailView() {
    isDetailMode = true;
    isMoonPhaseMode = false; // –û—Ç–∫–ª—é—á–∞–µ–º —Ä–µ–∂–∏–º —Ñ–∞–∑—ã, –≤–∫–ª—é—á–∞–µ–º —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã–π —Ä–µ–∂–∏–º
    
    const container = document.getElementById('detail-view');
    const detailInfo = document.getElementById('detail-info');
    const textureLoader = new THREE.TextureLoader();

    container.style.display = 'block';
    container.classList.remove('visible', 'show-info');
    document.getElementById('detail-loading').style.display = 'none';
    
    // –û—á–∏—Å—Ç–∫–∞ —Å—Ü–µ–Ω—ã
    clearDetailScene();

    // 1. –¢–ï–ö–°–¢–£–†–´ (–ù–∞–¥–µ–∂–Ω—ã–µ —Å—Å—ã–ª–∫–∏)
    const moonColorUrl = 'https://raw.githubusercontent.com/mrdoob/three.js/master/examples/textures/planets/moon_1024.jpg';
    const moonBumpUrl = 'https://raw.githubusercontent.com/mrdoob/three.js/master/examples/textures/planets/moon_bump_1024.jpg';

    const moonColorMap = textureLoader.load(moonColorUrl);
    const moonBumpMap = textureLoader.load(moonBumpUrl);

    // 2. –°–û–ó–î–ê–ù–ò–ï –õ–£–ù–´
    const geometry = new THREE.SphereGeometry(2, 64, 64);
    const material = new THREE.MeshPhongMaterial({
        map: moonColorMap,
        bumpMap: moonBumpMap,
        bumpScale: 0.05,
        color: 0xffffff,
        specular: new THREE.Color(0x222222),
        shininess: 5
    });
    
    detailMainObject = new THREE.Mesh(geometry, material);
    detailMainObject.userData.removable = true;
    detailMainObject.userData.type = 'moon_detail';
    detailScene.add(detailMainObject);

    // 3. –û–°–í–ï–©–ï–ù–ò–ï (–°—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–æ–µ, –∫–∞–∫ –¥–ª—è –ø–ª–∞–Ω–µ—Ç)
    // –ù–∞—Ö–æ–¥–∏–º –∏ –ø–µ—Ä–µ–º–µ—â–∞–µ–º –æ—Å–Ω–æ–≤–Ω–æ–π —Å–≤–µ—Ç –≤ "—Å—Ç—É–¥–∏–π–Ω—É—é" –ø–æ–∑–∏—Ü–∏—é
    let detailLight = null;
    detailScene.traverse(obj => {
        if (obj.isDirectionalLight && obj.intensity > 1.0) detailLight = obj;
    });

    if (detailLight) {
        detailLight.position.set(100, 50, 100);
    } else {
        const newLight = new THREE.DirectionalLight(0xffffff, 2.0);
        newLight.position.set(100, 50, 100);
        newLight.userData.removable = true;
        detailScene.add(newLight);
    }

    // –î–æ–±–∞–≤–ª—è–µ–º –Ω–µ–º–Ω–æ–≥–æ –∑–∞–ø–æ–ª–Ω—è—é—â–µ–≥–æ —Å–≤–µ—Ç–∞, —á—Ç–æ–±—ã —Ç–µ–Ω–∏ –Ω–µ –±—ã–ª–∏ —á–µ—Ä–Ω—ã–º–∏
    const ambientMoon = new THREE.AmbientLight(0x404040, 0.5);
    ambientMoon.userData.removable = true;
    detailScene.add(ambientMoon);

    // 4. –ò–ù–¢–ï–†–§–ï–ô–°
    document.getElementById('d-name').textContent = '–õ—É–Ω–∞';
    document.getElementById('d-type').textContent = '–°–ø—É—Ç–Ω–∏–∫ –ó–µ–º–ª–∏';
    document.getElementById('d-type').style.color = '#cccccc';
    document.getElementById('d-constellation').style.display = 'none';

    // –î–∞–Ω–Ω—ã–µ (–æ—Å—Ç–∞–≤–ª—è–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–æ–Ω–Ω–æ)
    const now = new Date();
    const illum = Astronomy.Illumination('Moon', now);
    const statsHTML = `
        <div class="d-stat highlight">
            <h4>–§–∞–∑–∞ (–∞—Å—Ç—Ä.)</h4>
            <p>${(illum.phase_fraction * 100).toFixed(1)}%</p>
        </div>
        <div class="d-stat">
            <h4>–ó–≤. –≤–µ–ª–∏—á–∏–Ω–∞</h4>
            <p>${illum.mag.toFixed(2)}m</p>
        </div>
        <div class="d-stat">
            <h4>–†–∞—Å—Å—Ç–æ—è–Ω–∏–µ</h4>
            <p>${(illum.dist_km).toFixed(0)} –∫–º</p>
        </div>
        <div class="d-stat">
            <h4>–í–æ–∑—Ä–∞—Å—Ç</h4>
            <p>~${(illum.phase_angle / 12).toFixed(1)} –¥–Ω.</p>
        </div>
    `;
    document.getElementById('d-stats').innerHTML = statsHTML;
    
    // –°–∫—Ä—ã–≤–∞–µ–º –ª–∏—à–Ω–∏–µ –ø–æ–¥—Å–∫–∞–∑–∫–∏, —Ç–∞–∫ –∫–∞–∫ –ø–æ–≤–µ–¥–µ–Ω–∏–µ —Ç–µ–ø–µ—Ä—å —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–æ–µ
    document.getElementById('d-fact').style.display = 'none';
    document.getElementById('d-wiki').style.display = 'none';
    document.getElementById('size-comparison').style.display = 'none';

    // 5. –ö–ê–ú–ï–†–ê
    detailCamera.position.set(0, 0, 8);
    detailCamera.lookAt(0, 0, 0);
    
    detailControls.object = detailCamera;
    detailControls.target.set(0, 0, 0);
    detailControls.minDistance = 3;
    detailControls.maxDistance = 30;
    detailControls.update();

    detailInfo.style.transform = '';
    
    setTimeout(() => {
        container.classList.add('visible');
        setTimeout(() => { container.classList.add('show-info'); }, 300);
    }, 100);
}

// === –ó–ê–í–ï–†–®–ï–ù–ò–ï –ü–û–õ–Å–¢–ê ===
function finishFlight() {
    isFlightMode = false;
    
    document.getElementById('flight-status').style.display = 'none';
    document.getElementById('speed-lines').innerHTML = '';
    updateVignette(0);
    
    if (detailType === 'star') {
        openStarDetailView(flightTargetName, flightTargetData);
    } else if (detailType === 'planet') {
        openPlanetDetailView(flightTargetName);
    } 
    // --- –ò–ó–ú–ï–ù–ï–ù–ò–ï: –û—Ç–∫—Ä—ã—Ç–∏–µ –õ—É–Ω—ã ---
    else if (detailType === 'moon') {
        openMoonDetailView();
    }
    // --------------------------------
}

function startReturnFlight() {
    isReturnFlight = true;
    returnStartTime = Date.now();
    
    // –í–∫–ª—é—á–∞–µ–º –≤–∏–Ω—å–µ—Ç–∫—É –¥–ª—è —ç—Ñ—Ñ–µ–∫—Ç–∞ —Å–∫–æ—Ä–æ—Å—Ç–∏
    updateSpeedLines(0.5, -1); // -1 –¥–ª—è –æ–±—Ä–∞—Ç–Ω–æ–≥–æ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏—è (–µ—Å–ª–∏ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç—Å—è css) –∏–ª–∏ –ø—Ä–æ—Å—Ç–æ –ª–∏–Ω–∏–∏
}

function updateReturnFlight() {
    if (!isReturnFlight) return;

    const duration = 2000; // –î–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å –æ–±—Ä–∞—Ç–Ω–æ–≥–æ –ø–æ–ª—ë—Ç–∞
    const elapsed = Date.now() - returnStartTime;
    const progress = Math.min(elapsed / duration, 1);
    
    // Easing –¥–ª—è –ø–ª–∞–≤–Ω–æ—Å—Ç–∏ (easeOutCubic)
    const ease = 1 - Math.pow(1 - progress, 3);
    
    const startFov = 5; // –¢–æ –∑–Ω–∞—á–µ–Ω–∏–µ, –Ω–∞ –∫–æ—Ç–æ—Ä–æ–º –º—ã –æ—Å—Ç–∞–Ω–æ–≤–∏–ª–∏—Å—å –ø—Ä–∏ –ø–æ–¥–ª–µ—Ç–µ
    const targetFov = savedCameraState ? savedCameraState.fov : 60;
    
    // –ò–Ω—Ç–µ—Ä–ø–æ–ª—è—Ü–∏—è FOV (–æ—Ç–¥–∞–ª–µ–Ω–∏–µ)
    camera.fov = startFov + (targetFov - startFov) * ease;
    camera.updateProjectionMatrix();
    
    // –ü–ª–∞–≤–Ω–æ–µ –ø–æ—è–≤–ª–µ–Ω–∏–µ –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–∞
    const uiOpacity = ease;
    document.getElementById('search-container').style.opacity = uiOpacity;
    document.getElementById('controls-panel').style.opacity = uiOpacity;
    document.getElementById('info-panel').style.opacity = uiOpacity;
    
    // –≠—Ñ—Ñ–µ–∫—Ç—ã —Å–∫–æ—Ä–æ—Å—Ç–∏ —É–≥–∞—Å–∞—é—Ç –∫ –∫–æ–Ω—Ü—É
    const intensity = 1 - ease;
    updateVignette(intensity * 0.3);
    updateSpeedLines(intensity * 0.5, -1);

    if (progress >= 1) {
        finishReturnFlight();
    }
}

function finishReturnFlight() {
    isReturnFlight = false;
    document.getElementById('speed-lines').innerHTML = '';
    updateVignette(0);
    
    // –ü–æ–ª–Ω–æ–µ –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏–µ —Å–æ—Å—Ç–æ—è–Ω–∏—è
    if (savedCameraState) {
        camera.fov = savedCameraState.fov;
        camera.updateProjectionMatrix();
        // –í–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –ø–æ–∑–∏—Ü–∏—é –µ—Å–ª–∏ –Ω—É–∂–Ω–æ, –Ω–æ –æ–±—ã—á–Ω–æ FOV –¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –¥–ª—è —ç—Ñ—Ñ–µ–∫—Ç–∞ –∑—É–º–∞
    }
    
    if (!isInsideMode) controls.enabled = true;
    
    // –£–±–µ–∂–¥–∞–µ–º—Å—è —á—Ç–æ UI –≤–∏–¥–µ–Ω
    document.getElementById('search-container').style.opacity = '1';
    document.getElementById('controls-panel').style.opacity = '1';
    document.getElementById('info-panel').style.opacity = '1';
}



// === –û–¢–ö–†–´–¢–ò–ï –î–ï–¢–ê–õ–¨–ù–û–ì–û –í–ò–î–ê –ó–í–ï–ó–î–´ ===
async function openStarDetailView(starName, cachedData = null) {
    isDetailMode = true;
    currentStarData = cachedData;
    
    const container = document.getElementById('detail-view');
    const detailInfo = document.getElementById('detail-info');
    
    container.style.display = 'block';
    container.classList.remove('visible', 'show-info'); // –°–±—Ä–∞—Å—ã–≤–∞–µ–º –∫–ª–∞—Å—Å—ã
    
    // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä –∑–∞–≥—Ä—É–∑–∫–∏
    document.getElementById('detail-loading').style.display = 'block';
    
    // –ï—Å–ª–∏ –¥–∞–Ω–Ω—ã—Ö –Ω–µ—Ç, –∑–∞–≥—Ä—É–∂–∞–µ–º –∏–∑ Supabase
    if (!cachedData) {
        const data = await fetchStarData(starName);
        if (data) {
            currentStarData = data;
        }
    }
    
    // –ï—Å–ª–∏ –¥–∞–Ω–Ω—ã—Ö –≤—Å—ë –µ—â—ë –Ω–µ—Ç ‚Äî –∑–∞–∫—Ä—ã–≤–∞–µ–º –∏ –≤–æ–∑–≤—Ä–∞—â–∞–µ–º—Å—è
    if (!currentStarData) {
        document.getElementById('detail-loading').style.display = 'none';
        container.style.display = 'none';
        isDetailMode = false;
        
        document.getElementById('search-container').style.opacity = '1';
        document.getElementById('controls-panel').style.opacity = '1';
        document.getElementById('info-panel').style.opacity = '1';
        
        if (!isInsideMode) controls.enabled = true;
        
        const indicator = document.getElementById('mode-indicator');
        indicator.innerHTML = `‚ö†Ô∏è –î–∞–Ω–Ω—ã–µ –æ –∑–≤–µ–∑–¥–µ "${starName}" –Ω–µ –Ω–∞–π–¥–µ–Ω—ã –≤ –±–∞–∑–µ`;
        indicator.classList.add('visible');
        setTimeout(() => indicator.classList.remove('visible'), 4000);
        return;
    }
    
    // –°–æ–∑–¥–∞—ë–º 3D –º–æ–¥–µ–ª—å –∑–≤–µ–∑–¥—ã
    const colorInfo = createDetailStar(currentStarData);
    
    // –°–∫—Ä—ã–≤–∞–µ–º –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä –∑–∞–≥—Ä—É–∑–∫–∏
    document.getElementById('detail-loading').style.display = 'none';
    
    // –ó–∞–ø–æ–ª–Ω—è–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é
    fillStarInfo(starName, currentStarData, colorInfo);
    
    // –í–ê–ñ–ù–û: –£–±–∏—Ä–∞–µ–º inline style —á—Ç–æ–±—ã CSS –∫–ª–∞—Å—Å —Ä–∞–±–æ—Ç–∞–ª
    detailInfo.style.transform = '';
    
    // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º —Å –∞–Ω–∏–º–∞—Ü–∏–µ–π
    setTimeout(() => {
        container.classList.add('visible');
        setTimeout(() => {
            container.classList.add('show-info');
        }, 300); // –ó–∞–¥–µ—Ä–∂–∫–∞ –¥–ª—è –∞–Ω–∏–º–∞—Ü–∏–∏ info –ø–∞–Ω–µ–ª–∏
    }, 100);
}


// === –û–¢–ö–†–´–¢–ò–ï –î–ï–¢–ê–õ–¨–ù–û–ì–û –í–ò–î–ê –ü–õ–ê–ù–ï–¢–´ ===
function openPlanetDetailView(nameRu) {
    isDetailMode = true;
    
    const container = document.getElementById('detail-view');
    const detailInfo = document.getElementById('detail-info');
    
    container.style.display = 'block';
    container.classList.remove('visible', 'show-info');
    document.getElementById('detail-loading').style.display = 'none';
    
    const pData = PLANETS_DATA[nameRu];
    if (!pData) {
        closeDetailView();
        return;
    }
    
    // –ü–µ—Ä–µ–¥–∞—ë–º –∏–º—è –ø–ª–∞–Ω–µ—Ç—ã –¥–ª—è —Å—Ä–∞–≤–Ω–µ–Ω–∏—è —Å –ó–µ–º–ª—ë–π
    createDetailPlanet(pData, nameRu);
    fillPlanetInfo(nameRu, pData);
    
    detailInfo.style.transform = '';
    
    setTimeout(() => {
        container.classList.add('visible');
        setTimeout(() => {
            container.classList.add('show-info');
        }, 300);
    }, 100);
}

// === –ó–ê–ö–†–´–¢–ò–ï –î–ï–¢–ê–õ–¨–ù–û–ì–û –í–ò–î–ê ===
function closeDetailView() {
    const container = document.getElementById('detail-view');
    const detailInfo = document.getElementById('detail-info');
    
    document.getElementById('label-star').classList.remove('visible');
    document.getElementById('label-sun').classList.remove('visible');
    
    container.classList.remove('show-info');
    
    setTimeout(() => {
        container.classList.remove('visible');
        
        setTimeout(() => {
            container.style.display = 'none';
            detailInfo.style.transform = '';
            isDetailMode = false;
            currentStarData = null;
            document.getElementById('size-comparison').style.display = 'none';
            
            // –í–ú–ï–°–¢–û –ú–ì–ù–û–í–ï–ù–ù–û–ì–û –ü–û–Ø–í–õ–ï–ù–ò–Ø ‚Äî –ó–ê–ü–£–°–ö–ê–ï–ú –û–ë–†–ê–¢–ù–´–ô –ü–û–õ–Å–¢
            startReturnFlight();
            
        }, 300);
    }, 300);
}


// –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∑–∞–∫—Ä—ã—Ç–∏—è
document.getElementById('detail-close').onclick = closeDetailView;

// === –ò–ù–ò–¶–ò–ê–õ–ò–ó–ê–¶–ò–Ø ===
function init() {
    if (typeof CONSTELLATIONS === 'undefined') { 
        alert("–û—à–∏–±–∫–∞: constellations.js –Ω–µ –Ω–∞–π–¥–µ–Ω!"); 
        return; 
    }
    loadSettings();

    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x000814);

    camera = new THREE.PerspectiveCamera(currentFov, window.innerWidth / window.innerHeight, 0.1, 1000);
    
    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.5;
    document.body.appendChild(renderer.domElement);

    controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;

    raycaster = new THREE.Raycaster();
    raycaster.params.Sprite = { threshold: 1.5 };
    mouse = new THREE.Vector2();

    scene.add(new THREE.AmbientLight(0xffffff, 1.2));
    scene.add(new THREE.HemisphereLight(0x8888ff, 0x444422, 0.6));
    const dir = new THREE.DirectionalLight(0xffffff, 0.8);
    dir.position.set(50, 100, 50);
    scene.add(dir);

    createBackgroundStars();
    buildGrid();
    buildZenithNadir();
    buildGround();
    Object.values(groups).forEach(g => scene.add(g));
    groups.transitionParticles.visible = false;

    initDetailScene();
    applyCameraModeInstant();
    setupCustomControls();
    setupTooltip();
    setupUniversalSearch();

    window.addEventListener('resize', onResize);
    setupUI();

    if (navigator.geolocation) {
        navigator.geolocation.getCurrentPosition(
            pos => { 
                observerLat = pos.coords.latitude; 
                observerLon = pos.coords.longitude; 
                getLocationName(observerLat, observerLon); 
                updateSky(); 
            },
            () => updateSky()
        );
    } else updateSky();

    setInterval(updateSky, 60000);
    updateISS();
    setInterval(updateISS, 30000);
    updateClock();
    setInterval(updateClock, 1000);

    animate();
    setTimeout(() => { 
        document.getElementById('loading').style.opacity = '0'; 
        setTimeout(() => document.getElementById('loading').style.display = 'none', 500); 
    }, 500);
}

function buildZenithNadir() {
    const zenith = createCardinalSprite('–ó–ï–ù–ò–¢', '#00ffff', true);
    zenith.position.set(0, SPHERE_RADIUS * 1.02, 0);
    groups.zenithNadir.add(zenith);
    
    const nadir = createCardinalSprite('–ù–ê–î–ò–†', '#ff6666', true);
    nadir.position.set(0, -SPHERE_RADIUS * 1.02, 0);
    groups.zenithNadir.add(nadir);
}

function createBackgroundStars() {
    const geo = new THREE.BufferGeometry();
    const verts = [], colors = [];
    for (let i = 0; i < 5000; i++) {
        const theta = Math.random() * Math.PI * 2;
        const phi = Math.acos(2 * Math.random() - 1);
        const r = 180 + Math.random() * 120;
        verts.push(r * Math.sin(phi) * Math.cos(theta), r * Math.sin(phi) * Math.sin(theta), r * Math.cos(phi));
        const b = 0.3 + Math.random() * 0.5;
        colors.push(b, b, b * 1.1);
    }
    geo.setAttribute('position', new THREE.Float32BufferAttribute(verts, 3));
    geo.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
    scene.add(new THREE.Points(geo, new THREE.PointsMaterial({ size: 0.5, vertexColors: true, transparent: true, opacity: 0.8 })));
}

function applyCameraModeInstant() {
    const btnIn = document.getElementById('cam-in');
    const btnOut = document.getElementById('cam-out');

    if (settings.camMode === 'in') {
        isInsideMode = true;
        controls.enabled = false;
        currentFov = 60;
        camera.fov = currentFov;
        camera.updateProjectionMatrix();
        spherical = { phi: Math.PI / 2, theta: 0 };
        updateInsideCamera();
        if (landscapeMesh) landscapeMesh.visible = settings.ground;
        btnIn.classList.add('active');
        btnOut.classList.remove('active');
    } else {
        isInsideMode = false;
        controls.enabled = true;
        camera.fov = 60;
        camera.updateProjectionMatrix();
        camera.position.set(0, 50, 100);
        controls.target.set(0, 0, 0);
        controls.minDistance = 20;
        controls.maxDistance = 300;
        controls.minPolarAngle = 0.1;
        controls.maxPolarAngle = Math.PI - 0.1;
        controls.update();
        if (landscapeMesh) landscapeMesh.visible = false;
        btnIn.classList.remove('active');
        btnOut.classList.add('active');
    }
}

function createLandscapeTexture() {
    const canvas = document.createElement('canvas');
    canvas.width = 2048; canvas.height = 256;
    const ctx = canvas.getContext('2d');
    const grad = ctx.createLinearGradient(0, 0, 0, 256);
    grad.addColorStop(0, 'rgba(0,0,0,0)');
    grad.addColorStop(0.4, 'rgba(5,15,30,0.5)');
    grad.addColorStop(0.6, 'rgba(5,15,30,0.9)');
    grad.addColorStop(1, '#000000');
    ctx.fillStyle = grad;
    ctx.fillRect(0, 0, 2048, 256);
    ctx.fillStyle = '#000000';
    ctx.beginPath();
    ctx.moveTo(0, 256);
    for (let x = 0; x <= 2048; x += 3) {
        const hill = Math.sin(x * 0.003) * 35 + Math.sin(x * 0.008) * 20;
        const tree = Math.random() > 0.8 ? Math.random() * 20 : 0;
        ctx.lineTo(x, 155 + hill - tree);
    }
    ctx.lineTo(2048, 256); ctx.lineTo(0, 256); ctx.fill();
    const tex = new THREE.CanvasTexture(canvas);
    tex.wrapS = THREE.RepeatWrapping;
    tex.repeat.set(3, 1);
    return tex;
}

function buildGround() {
    const disk = new THREE.Mesh(
        new THREE.CircleGeometry(SPHERE_RADIUS * 1.1, 64), 
        new THREE.MeshBasicMaterial({ color: 0x020810, transparent: true, opacity: 0.95, side: THREE.DoubleSide })
    );
    disk.rotation.x = -Math.PI / 2; 
    disk.position.y = -0.5;
    groups.ground.add(disk);

    const grid = new THREE.PolarGridHelper(SPHERE_RADIUS, 12, 6, 64, 0x0066aa, 0x003366);
    grid.material.opacity = 0.25; 
    grid.material.transparent = true;
    groups.ground.add(grid);

    const cyl = new THREE.Mesh(
        new THREE.CylinderGeometry(SPHERE_RADIUS * 0.99, SPHERE_RADIUS * 0.99, 15, 64, 1, true),
        new THREE.MeshBasicMaterial({ map: createLandscapeTexture(), transparent: true, side: THREE.BackSide, depthWrite: false })
    );
    cyl.position.y = 4; 
    cyl.renderOrder = 10;
    landscapeMesh = cyl;
    groups.ground.add(cyl);

    groups.ground.add(new THREE.Mesh(
        new THREE.SphereGeometry(SPHERE_RADIUS * 0.98, 32, 16, 0, Math.PI * 2, Math.PI / 2, Math.PI / 2),
        new THREE.MeshBasicMaterial({ color: 0x000408, side: THREE.DoubleSide })
    ));
}

function sphericalToCartesian(r, az, alt) {
    const altR = THREE.MathUtils.degToRad(alt), azR = THREE.MathUtils.degToRad(az);
    return new THREE.Vector3(r * Math.cos(altR) * Math.sin(azR), r * Math.sin(altR), -r * Math.cos(altR) * Math.cos(azR));
}

function createStarLabelSprite(text) {
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    const fontSize = 36;
    ctx.font = `${fontSize}px Arial`;
    const w = ctx.measureText(text).width + 16;
    canvas.width = w; canvas.height = fontSize + 12;
    ctx.font = `${fontSize}px Arial`;
    ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
    ctx.shadowColor = 'rgba(0,0,0,0.9)'; ctx.shadowBlur = 4;
    ctx.fillStyle = '#aaccff';
    ctx.fillText(text, w / 2, canvas.height / 2);
    const mat = new THREE.SpriteMaterial({ map: new THREE.CanvasTexture(canvas), depthTest: false, depthWrite: false, transparent: true });
    const sprite = new THREE.Sprite(mat);
    sprite.scale.set(w * 0.015, (fontSize + 12) * 0.015, 1);
    return sprite;
}

function createCardinalSprite(text, color, isZenithNadir = false) {
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    const fontSize = isZenithNadir ? 48 : 96;
    ctx.font = `bold ${fontSize}px Arial`;
    const w = ctx.measureText(text).width + 60;
    canvas.width = w; canvas.height = fontSize + 60;
    ctx.font = `bold ${fontSize}px Arial`;
    ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
    [color, color, '#ffffff'].forEach((c, i) => {
        ctx.shadowColor = c; ctx.shadowBlur = [30, 20, 10][i];
        ctx.fillStyle = i === 2 ? '#ffffff' : color;
        ctx.fillText(text, w / 2, canvas.height / 2);
    });
    ctx.shadowBlur = 0;
    ctx.strokeStyle = 'rgba(0,0,0,0.5)'; ctx.lineWidth = 2;
    ctx.strokeText(text, w / 2, canvas.height / 2);
    ctx.fillStyle = '#ffffff';
    ctx.fillText(text, w / 2, canvas.height / 2);
    const mat = new THREE.SpriteMaterial({ map: new THREE.CanvasTexture(canvas), depthTest: false, depthWrite: false, transparent: true, blending: THREE.AdditiveBlending });
    const sprite = new THREE.Sprite(mat);
    const scale = isZenithNadir ? 0.02 : 0.03;
    sprite.scale.set(w * scale, (fontSize + 60) * scale, 1);
    sprite.renderOrder = 999;
    return sprite;
}

function createGlowTextSprite(text, color, scale = 1) {
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    ctx.font = `bold 48px Arial`;
    const w = ctx.measureText(text).width + 30;
    canvas.width = w; canvas.height = 78;
    ctx.font = `bold 48px Arial`;
    ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
    ctx.shadowColor = color; ctx.shadowBlur = 15;
    ctx.fillStyle = color;
    ctx.fillText(text, w / 2, 39);
    ctx.fillText(text, w / 2, 39);
    const mat = new THREE.SpriteMaterial({ map: new THREE.CanvasTexture(canvas), depthTest: false, depthWrite: false, transparent: true });
    const sprite = new THREE.Sprite(mat);
    sprite.scale.set(0.018 * w * scale, 0.018 * 78 * scale, 1);
    return sprite;
}

function createStarSprite(color, magnitude) {
    const size = Math.max(0.3, Math.min(1.8, 2.0 - magnitude * 0.4));
    const canvas = document.createElement('canvas');
    canvas.width = 64; canvas.height = 64;
    const ctx = canvas.getContext('2d');
    const grad = ctx.createRadialGradient(32, 32, 0, 32, 32, 32);
    grad.addColorStop(0, '#ffffff');
    grad.addColorStop(0.1, color);
    grad.addColorStop(0.4, color);
    grad.addColorStop(0.7, 'rgba(100,150,255,0.1)');
    grad.addColorStop(1, 'rgba(0,0,0,0)');
    ctx.fillStyle = grad;
    ctx.fillRect(0, 0, 64, 64);
    if (magnitude < 2) {
        ctx.strokeStyle = 'rgba(255,255,255,0.3)'; ctx.lineWidth = 1;
        for (let i = 0; i < 4; i++) {
            const a = (i * Math.PI) / 2;
            ctx.beginPath(); ctx.moveTo(32 + Math.cos(a) * 4, 32 + Math.sin(a) * 4);
            ctx.lineTo(32 + Math.cos(a) * 16, 32 + Math.sin(a) * 16); ctx.stroke();
        }
    }
    const mat = new THREE.SpriteMaterial({ map: new THREE.CanvasTexture(canvas), blending: THREE.AdditiveBlending, depthTest: true, depthWrite: false, transparent: true });
    const sprite = new THREE.Sprite(mat);
    sprite.scale.set(size, size, 1);
    return sprite;
}

function createPlanetSprite(magnitude) {
    const size = Math.max(0.3, Math.min(1.2, 1.5 - magnitude * 0.15));
    const canvas = document.createElement('canvas');
    canvas.width = 64; canvas.height = 64;
    const ctx = canvas.getContext('2d');
    const grad = ctx.createRadialGradient(32, 32, 2, 32, 32, 30);
    grad.addColorStop(0, '#ffffff');
    grad.addColorStop(0.2, '#ffeeaa');
    grad.addColorStop(0.4, 'rgba(255, 200, 0, 0.5)');
    grad.addColorStop(1, 'rgba(0,0,0,0)');
    ctx.fillStyle = grad;
    ctx.fillRect(0, 0, 64, 64);
    const mat = new THREE.SpriteMaterial({ map: new THREE.CanvasTexture(canvas), blending: THREE.AdditiveBlending, depthTest: true, depthWrite: false, transparent: true });
    const sprite = new THREE.Sprite(mat);
    sprite.scale.set(size, size, 1);
    return sprite;
}

function createISSModel() {
    const g = new THREE.Group();
    const bodyMat = new THREE.MeshPhongMaterial({ color: 0xffffff, emissive: 0x00ff88, emissiveIntensity: 1.0 });
    const solarMat = new THREE.MeshPhongMaterial({ color: 0x00ffaa, emissive: 0x00ff66, emissiveIntensity: 0.8, side: THREE.DoubleSide });
    const body = new THREE.Mesh(new THREE.CylinderGeometry(0.5, 0.5, 5, 12), bodyMat);
    body.rotation.z = Math.PI / 2; g.add(body);
    g.add(new THREE.Mesh(new THREE.BoxGeometry(0.8, 10, 0.5), bodyMat));
    [[1.8, 4], [-1.8, 4], [1.8, -4], [-1.8, -4]].forEach(([x, y]) => {
        const p = new THREE.Mesh(new THREE.BoxGeometry(2.5, 5, 0.1), solarMat);
        p.position.set(x, y, 0); g.add(p);
    });
    g.add(new THREE.PointLight(0x00ff88, 3, 30));
    g.scale.set(0.5, 0.5, 0.5);
    return g;
}

function buildGrid() {
    const r = SPHERE_RADIUS;
    const mat = new THREE.LineBasicMaterial({ color: 0x22aaff, transparent: true, opacity: 0.3 });

    for (let alt = -80; alt <= 80; alt += 20) {
        if (alt === 0) continue;
        const pts = []; 
        for (let az = 0; az <= 360; az += 5) pts.push(sphericalToCartesian(r, az, alt));
        groups.grid.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints(pts), mat));
    }
    for (let az = 0; az < 360; az += 30) {
        const pts = []; 
        for (let alt = -90; alt <= 90; alt += 5) pts.push(sphericalToCartesian(r, az, alt));
        groups.grid.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints(pts), mat));
    }

    const horizonGeo = new THREE.TorusGeometry(r, 0.25, 8, 128);
    horizonGeo.rotateX(Math.PI / 2);
    groups.grid.add(new THREE.Mesh(horizonGeo, new THREE.MeshBasicMaterial({ color: 0x00e5ff, opacity: 0.8, transparent: true })));
    groups.grid.add(new THREE.Mesh(new THREE.SphereGeometry(0.6, 16, 16), new THREE.MeshBasicMaterial({ color: 0x00e5ff })));

    const crossMat = new THREE.LineBasicMaterial({ color: 0x00e5ff, opacity: 0.5, transparent: true });
    [0, 90, 180, 270].forEach(az => {
        groups.grid.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0, 0, 0), sphericalToCartesian(r, az, 0)]), crossMat));
    });

    [{ t: '–°', a: 0, c: '#ff4444' }, { t: '–í', a: 90, c: '#ffaa00' }, { t: '–Æ', a: 180, c: '#ff4444' }, { t: '–ó', a: 270, c: '#ffaa00' }].forEach(d => {
        const s = createCardinalSprite(d.t, d.c);
        s.position.copy(sphericalToCartesian(r * 1.05, d.a, 2));
        groups.cardinals.add(s);
    });
}

function updateClock() {
    const now = new Date();
    const offset = Math.round(observerLon / 15);
    const utcTime = now.getTime() + (now.getTimezoneOffset() * 60000);
    const localTime = new Date(utcTime + (offset * 3600000));
    const timeStr = localTime.toLocaleTimeString('ru-RU', { hour: '2-digit', minute: '2-digit', second: '2-digit' });
    const sign = offset >= 0 ? '+' : '';
    const el = document.getElementById('time-data');
    if (el) el.innerHTML = `${timeStr}<div style="font-size: 10px; color: rgba(255,255,255,0.5); font-weight: 400; line-height: 1.2; margin-top: -2px;">–ì–µ–æ. –≤—Ä–µ–º—è (UTC${sign}${offset})</div>`;
}

function updateSky() {
    const now = new Date();
    document.getElementById('loc-data').innerText = `${observerLat.toFixed(2)}¬∞ / ${observerLon.toFixed(2)}¬∞`;

    const observer = new Astronomy.Observer(observerLat, observerLon, 0);

    interactiveObjects.length = 0;
    allStarLabels.length = 0;
    for (const key in starPositions) delete starPositions[key];
    for (const key in planetPositions) delete planetPositions[key];
    for (const key in constellationVisibility) delete constellationVisibility[key];

    minMagnitude = 6;
    maxMagnitude = -2;

    ['stars', 'starLabels', 'constellations', 'planets', 'trajectories', 'sunMoon'].forEach(k => {
        const g = groups[k];
        while (g.children.length) {
            const o = g.children[0]; g.remove(o);
            if (o.geometry) o.geometry.dispose();
            if (o.material) { if (o.material.map) o.material.map.dispose(); o.material.dispose(); }
        }
    });
    for (const key in constellationMap) delete constellationMap[key];

    const starPosCache = {};

    Object.keys(CONSTELLATIONS).forEach(cName => {
        const cData = CONSTELLATIONS[cName];
        const cLines = new THREE.Group();
        const cLabels = new THREE.Group();
        const cStarLabelsGroup = new THREE.Group();
        let mainStarPos = null;
        let maxAltitude = -90;

        cData.stars.forEach((star, idx) => {
            const hor = Astronomy.Horizon(now, observer, star.ra, star.dec, 'normal');
            const pos = sphericalToCartesian(SPHERE_RADIUS, hor.azimuth, hor.altitude);
            starPosCache[star.name] = pos;
            starPositions[star.name] = pos.clone();
            if (idx === 0) mainStarPos = pos.clone();
            if (hor.altitude > maxAltitude) maxAltitude = hor.altitude;

            if (star.mag < minMagnitude) minMagnitude = star.mag;
            if (star.mag > maxMagnitude) maxMagnitude = star.mag;

            const col = star.mag < 1 ? '#ffffee' : star.mag < 2 ? '#ffffff' : '#ddeeff';
            const sprite = createStarSprite(col, star.mag);
            sprite.position.copy(pos);
           sprite.userData = { 
    type: 'star', 
    name: star.name, 
    magnitude: star.mag, 
    ra: star.ra, 
    dec: star.dec, 
    azimuth: hor.azimuth, 
    altitude: hor.altitude,
    constellation: cName, 
    bayer: star.bayer,
    timesCalculated: false 
};
            groups.stars.add(sprite);
            interactiveObjects.push(sprite);

            const label = createStarLabelSprite(star.name);
            const dir = pos.clone().normalize();
            const up = new THREE.Vector3(0, 1, 0);
            const right = new THREE.Vector3().crossVectors(up, dir).normalize();
            if (right.length() < 0.1) right.set(1, 0, 0);
            label.position.copy(pos.clone().add(right.multiplyScalar(1.2).add(up.multiplyScalar(0.8))));
            label.visible = false;
            label.userData = { constellation: cName, starName: star.name, baseScale: label.scale.clone() };
            cStarLabelsGroup.add(label);
            allStarLabels.push(label);
        });

        constellationVisibility[cName] = maxAltitude > 0;
        if (mainStarPos) constellationMap[cName] = { mainStarPos: mainStarPos.clone() };

        if (cData.lines) {
            const points = [];
            cData.lines.forEach(pair => {
                const p1 = starPosCache[pair[0]], p2 = starPosCache[pair[1]];
                if (p1 && p2) points.push(p1.clone(), p2.clone());
            });
            if (points.length) {
                const seg = new THREE.LineSegments(new THREE.BufferGeometry().setFromPoints(points), new THREE.LineBasicMaterial({ color: 0xaa66ff, opacity: 0.6, transparent: true }));
                seg.visible = settings.lines;
                cLines.add(seg);
            }
        }

        if (mainStarPos) {
            const labelPos = mainStarPos.clone().normalize().multiplyScalar(SPHERE_RADIUS * 1.08);
            const cl = createGlowTextSprite(cName, '#cc99ff', 1.3);
            cl.position.copy(labelPos);
            cl.visible = settings.constNames;
            cLabels.add(cl);
        }

        groups.constellations.add(cLines);
        groups.constellations.add(cLabels);
        groups.starLabels.add(cStarLabelsGroup);

        if (constellationMap[cName]) {
            constellationMap[cName].linesGroup = cLines;
            constellationMap[cName].constLabelGroup = cLabels;
            constellationMap[cName].starLabelsGroup = cStarLabelsGroup;
        }
    });

    buildConstellationList();

PLANETS.forEach(p => {
    try {
        const eq = Astronomy.Equator(p, now, observer, false, true);
        const hor = Astronomy.Horizon(now, observer, eq.ra, eq.dec, 'normal');
        const pos = sphericalToCartesian(SPHERE_RADIUS, hor.azimuth, hor.altitude);
        const mag = PLANET_MAG[p] || 1;
        planetPositions[p] = pos.clone();
        
        if (mag < minMagnitude) minMagnitude = mag;
        if (mag > maxMagnitude) maxMagnitude = mag;
        
        const sprite = createPlanetSprite(mag);
        sprite.position.copy(pos);
        sprite.userData = { type: 'planet', name: PLANET_NAMES_RU[p] || p, magnitude: mag, azimuth: hor.azimuth, altitude: hor.altitude, timesCalculated: false };
        groups.planets.add(sprite);
        interactiveObjects.push(sprite);
        
        const label = createGlowTextSprite(PLANET_NAMES_RU[p] || p, '#ffdd00', 0.9);
        label.position.copy(pos.clone().add(new THREE.Vector3(0, 2.5, 0)));
        label.userData = { type: 'planet-label', planetName: p, magnitude: mag };
        groups.planets.add(label);
    } catch (e) { }
});

    try {
        const sunEq = Astronomy.Equator('Sun', now, observer, false, true);
        const sunHor = Astronomy.Horizon(now, observer, sunEq.ra, sunEq.dec, 'normal');
        const sunPos = sphericalToCartesian(SPHERE_RADIUS, sunHor.azimuth, sunHor.altitude);
        planetPositions['Sun'] = sunPos.clone();
        currentSunAltitude = sunHor.altitude;

        const sunCanvas = document.createElement('canvas');
        sunCanvas.width = 128; sunCanvas.height = 128;
        const sCtx = sunCanvas.getContext('2d');
        const sGrad = sCtx.createRadialGradient(64, 64, 10, 64, 64, 60);
        sGrad.addColorStop(0, '#ffffff'); sGrad.addColorStop(0.2, '#fff0aa');
        sGrad.addColorStop(0.5, '#ffaa00'); sGrad.addColorStop(1, 'rgba(255, 100, 0, 0)');
        sCtx.fillStyle = sGrad; sCtx.fillRect(0, 0, 128, 128);

        const sunSprite = new THREE.Sprite(new THREE.SpriteMaterial({ map: new THREE.CanvasTexture(sunCanvas), blending: THREE.AdditiveBlending, depthTest: true, depthWrite: false, transparent: true }));
        sunSprite.scale.set(7, 7, 1);
        sunSprite.position.copy(sunPos);
       sunSprite.userData = { type: 'sun', name: '–°–æ–ª–Ω—Ü–µ', azimuth: sunHor.azimuth, altitude: sunHor.altitude, timesCalculated: false };
        groups.sunMoon.add(sunSprite);
        interactiveObjects.push(sunSprite);

        const sunLabel = createGlowTextSprite('–°–æ–ª–Ω—Ü–µ', '#ffcc00', 1.3);
        sunLabel.position.copy(sunPos.clone().add(new THREE.Vector3(0, 4, 0)));
        groups.sunMoon.add(sunLabel);

        updateSkyBackground(sunHor.altitude);
    } catch (e) { updateSkyBackground(-90); }

    try {
        const moonEq = Astronomy.Equator('Moon', now, observer, false, true);
        const moonHor = Astronomy.Horizon(now, observer, moonEq.ra, moonEq.dec, 'normal');
        const moonPos = sphericalToCartesian(SPHERE_RADIUS, moonHor.azimuth, moonHor.altitude);
        planetPositions['Moon'] = moonPos.clone();

        const canvas = document.createElement('canvas');
        canvas.width = 64; canvas.height = 64;
        const ctx = canvas.getContext('2d');
        ctx.shadowColor = '#ffffff'; ctx.shadowBlur = 10;
        ctx.fillStyle = '#ffffee';
        ctx.beginPath(); ctx.arc(32, 32, 20, 0, Math.PI * 2); ctx.fill();
        ctx.globalCompositeOperation = 'destination-out';
        ctx.beginPath(); ctx.arc(40, 32, 18, 0, Math.PI * 2); ctx.fill();

        const moonSprite = new THREE.Sprite(new THREE.SpriteMaterial({ map: new THREE.CanvasTexture(canvas), blending: THREE.AdditiveBlending, depthTest: true, depthWrite: false, transparent: true }));
        moonSprite.scale.set(3.5, 3.5, 1);
        moonSprite.position.copy(moonPos);
        moonSprite.userData = { type: 'moon', name: '–õ—É–Ω–∞', azimuth: moonHor.azimuth, altitude: moonHor.altitude, timesCalculated: false };
        groups.sunMoon.add(moonSprite);
        interactiveObjects.push(moonSprite);

        const moonLabel = createGlowTextSprite('–õ—É–Ω–∞', '#ffffff', 1.0);
        moonLabel.position.copy(moonPos.clone().add(new THREE.Vector3(0, 2.5, 0)));
        groups.sunMoon.add(moonLabel);
    } catch (e) { }

    try {
        drawTrajectory('Sun', 0xffaa00, now, observer);
        drawTrajectory('Moon', 0xaaaaff, now, observer);
    } catch (e) { }

  const slider = document.getElementById('magnitude-slider');
const magValue = document.getElementById('magnitude-value');
if (slider) {
    slider.min = minMagnitude.toFixed(1);
    slider.max = maxMagnitude.toFixed(1);
    if (settings.maxMagnitude > maxMagnitude) settings.maxMagnitude = maxMagnitude;
    slider.value = settings.maxMagnitude;
    if (magValue) {
        const val = parseFloat(slider.value);
        const min = parseFloat(slider.min);
        const max = parseFloat(slider.max);
        const percent = (val - min) / (max - min) * 100;
        magValue.textContent = val.toFixed(1) + 'm';
        magValue.style.left = `calc(${percent}% + ${(50 - percent) * 0.18}px)`;
    }
}
    applyVisibilitySettings();
    if (activeConstellation && constellationMap[activeConstellation]) highlightConstellation(activeConstellation);
}


function drawTrajectory(body, color, date, obs) {
    const pts = []; const d = new Date(date); d.setHours(0, 0, 0, 0);
    for (let i = 0; i <= 24; i += 0.16) {
        try {
            const t = new Date(d.getTime() + i * 3600000);
            const eq = Astronomy.Equator(body, t, obs, false, true);
            const h = Astronomy.Horizon(t, obs, eq.ra, eq.dec, 'normal');
            pts.push(sphericalToCartesian(SPHERE_RADIUS, h.azimuth, h.altitude));
        } catch (e) { }
    }
    if (pts.length > 1) groups.trajectories.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints(pts), new THREE.LineBasicMaterial({ color, opacity: 0.6, transparent: true })));
}

function createHoverTrajectory(data, color) {
    const pts = [];
    const now = new Date();
    const startOfDay = new Date(now);
    startOfDay.setHours(0, 0, 0, 0);
    
    const observer = new Astronomy.Observer(observerLat, observerLon, 0);

    // –û–ø—Ä–µ–¥–µ–ª—è–µ–º –∞–Ω–≥–ª–∏–π—Å–∫–æ–µ –∏–º—è –¥–ª—è –±–∏–±–ª–∏–æ—Ç–µ–∫–∏ Astronomy, –µ—Å–ª–∏ —ç—Ç–æ –Ω–µ –∑–≤–µ–∑–¥–∞
    let bodyName = null;
    if (data.type === 'sun') bodyName = 'Sun';
    else if (data.type === 'moon') bodyName = 'Moon';
    else if (data.type === 'planet') {
        // –ü—ã—Ç–∞–µ–º—Å—è –ø–æ–ª—É—á–∏—Ç—å –∞–Ω–≥–ª–∏–π—Å–∫–æ–µ –Ω–∞–∑–≤–∞–Ω–∏–µ –∏–∑ –∫–∞—Ä—Ç—ã –∏–ª–∏ –∏—Å–ø–æ–ª—å–∑—É–µ–º –∫–∞–∫ –µ—Å—Ç—å
        bodyName = PLANET_NAMES_EN[data.name] || data.name;
    }

    // –†–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ–º —Ç–æ—á–∫–∏ –Ω–∞ 24 —á–∞—Å–∞ —Å —à–∞–≥–æ–º 10 –º–∏–Ω—É—Ç
    for (let i = 0; i <= 24 * 60; i += 10) {
        const t = new Date(startOfDay.getTime() + i * 60000);
        try {
            let hor;
            
            if (data.type === 'star') {
                // –î–ª—è –∑–≤–µ–∑–¥ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã (RA/Dec) —Å—á–∏—Ç–∞–µ–º –ø–æ—Å—Ç–æ—è–Ω–Ω—ã–º–∏
                hor = Astronomy.Horizon(t, observer, data.ra, data.dec, 'normal');
            } else if (bodyName) {
                // –î–ª—è –ø–ª–∞–Ω–µ—Ç/–°–æ–ª–Ω—Ü–∞/–õ—É–Ω—ã –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã –º–µ–Ω—è—é—Ç—Å—è –≤ —Ç–µ—á–µ–Ω–∏–µ –¥–Ω—è
                const eq = Astronomy.Equator(bodyName, t, observer, false, true);
                hor = Astronomy.Horizon(t, observer, eq.ra, eq.dec, 'normal');
            }

            if (hor) {
                pts.push(sphericalToCartesian(SPHERE_RADIUS, hor.azimuth, hor.altitude));
            }
        } catch (e) { }
    }

    const geometry = new THREE.BufferGeometry().setFromPoints(pts);
    const material = new THREE.LineDashedMaterial({
        color: color,
        dashSize: 1,
        gapSize: 0.5,
        opacity: 0.6,
        transparent: true
    });

    const line = new THREE.Line(geometry, material);
    line.computeLineDistances();
    // –°–æ—Ö—Ä–∞–Ω—è–µ–º –∏–º—è –æ–±—ä–µ–∫—Ç–∞, —á—Ç–æ–±—ã –Ω–µ –ø–µ—Ä–µ—Å–æ–∑–¥–∞–≤–∞—Ç—å –ª–∏–Ω–∏—é –ª–∏—à–Ω–∏–π —Ä–∞–∑
    line.userData = { targetName: data.name, isHoverLine: true }; 
    return line;
}

function getTopo(obsLat, obsLon, satLat, satLon, satAltKm) {
    const R = 6371, D2R = Math.PI / 180, R2D = 180 / Math.PI;
    const lat1 = obsLat * D2R, lon1 = obsLon * D2R, lat2 = satLat * D2R, lon2 = satLon * D2R;
    const r1 = R, r2 = R + satAltKm;
    const x1 = r1 * Math.cos(lat1) * Math.cos(lon1), y1 = r1 * Math.cos(lat1) * Math.sin(lon1), z1 = r1 * Math.sin(lat1);
    const x2 = r2 * Math.cos(lat2) * Math.cos(lon2), y2 = r2 * Math.cos(lat2) * Math.sin(lon2), z2 = r2 * Math.sin(lat2);
    const dx = x2 - x1, dy = y2 - y1, dz = z2 - z1;
    const sl = Math.sin(lat1), cl = Math.cos(lat1), slo = Math.sin(lon1), clo = Math.cos(lon1);
    const e = -slo * dx + clo * dy, n = -sl * clo * dx - sl * slo * dy + cl * dz, u = cl * clo * dx + cl * slo * dy + sl * dz;
    let az = Math.atan2(e, n) * R2D; if (az < 0) az += 360;
    return { az, alt: Math.asin(u / Math.sqrt(e * e + n * n + u * u)) * R2D, visible: u > 0 };
}

async function updateISS() {
    if (!settings.iss) { groups.iss.visible = false; document.getElementById('iss-data').style.display = 'none'; return; }
    try {
        const resp = await fetch('https://api.wheretheiss.at/v1/satellites/25544');
        if (!resp.ok) throw new Error();
        const data = await resp.json();
        while (groups.iss.children.length) groups.iss.remove(groups.iss.children[0]);

        const topo = getTopo(observerLat, observerLon, data.latitude, data.longitude, data.altitude);
        const pos = sphericalToCartesian(SPHERE_RADIUS * 0.95, topo.az, topo.alt);
        issPosition = pos.clone();

        const model = createISSModel();
        model.position.copy(pos);
        model.lookAt(0, 0, 0);
        model.userData = { type: 'iss', name: '–ú–ö–° (ISS)', azimuth: topo.az, altitude: topo.alt };
        groups.iss.add(model);
        interactiveObjects.push(model);

        const label = createGlowTextSprite('üõ∞Ô∏è –ú–ö–°', '#00ff88', 1.0);
        label.position.copy(pos.clone().multiplyScalar(1.15));
        groups.iss.add(label);

        groups.iss.visible = true;
        const issDiv = document.getElementById('iss-data');
        issDiv.style.display = 'block';
        issDiv.innerHTML = topo.visible
            ? `üõ∞Ô∏è Az:${topo.az.toFixed(0)}¬∞ Alt:${topo.alt.toFixed(0)}¬∞ <span style="color:#00ff88">‚óè</span>`
            : `üõ∞Ô∏è Az:${topo.az.toFixed(0)}¬∞ Alt:${topo.alt.toFixed(0)}¬∞ <span style="color:#666">‚óã</span>`;

        if (!topo.visible) model.traverse(c => { if (c.material) { c.material.opacity = 0.4; c.material.transparent = true; } });
    } catch (e) { document.getElementById('iss-data').innerHTML = 'üõ∞Ô∏è –ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö'; }
}

function buildConstellationList() {
    const list = document.getElementById('const-list');
    list.innerHTML = '';
    Object.keys(CONSTELLATIONS).sort().forEach(name => {
        const isVisible = constellationVisibility[name];
        const div = document.createElement('div');
        div.className = 'const-item' + (isVisible ? '' : ' below-horizon');
        div.dataset.name = name;
        div.innerHTML = `<div class="const-item-left"><span class="const-name">${name}</span><span class="latin-name">${CONSTELLATIONS[name].latin}</span></div><span class="${isVisible ? 'visible-badge' : 'horizon-badge'}">${isVisible ? '‚Üë' : '‚Üì'}</span>`;
        div.onclick = () => toggleConstellation(name);
        list.appendChild(div);
    });
}

function toggleConstellation(name) {
    if (activeConstellation === name) resetView();
    else selectConstellation(name);
}

function selectConstellation(name) {
    highlightedStarName = null;
    const data = constellationMap[name];
    activeConstellation = name;
    document.querySelectorAll('.const-item').forEach(el => el.classList.toggle('active', el.dataset.name === name));
    highlightConstellation(name);

    if (data && data.mainStarPos) {
        const isVisible = constellationVisibility[name];
        if (!isVisible && settings.ground && isInsideMode) {
            const indicator = document.getElementById('mode-indicator');
            indicator.innerHTML = `‚ö†Ô∏è ${name} ‚Äî –Ω–∏–∂–µ –≥–æ—Ä–∏–∑–æ–Ω—Ç–∞<br><small>–û—Ç–∫–ª—é—á–∏—Ç–µ –ª–∞–Ω–¥—à–∞—Ñ—Ç –¥–ª—è –ø—Ä–æ—Å–º–æ—Ç—Ä–∞</small>`;
            indicator.classList.add('visible');
            setTimeout(() => indicator.classList.remove('visible'), 4000);
        } else {
            navigateToPosition(data.mainStarPos, () => animateConstellationHighlight(name));
        }
    }

    const el = document.querySelector(`.const-item[data-name="${name}"]`);
    if (el) el.scrollIntoView({ behavior: 'smooth', block: 'center' });
}

function highlightConstellation(name) {
    Object.entries(constellationMap).forEach(([cName, obj]) => {
        const isSelected = cName === name;
        if (obj.linesGroup) {
            obj.linesGroup.children.forEach(l => {
                if (l.material) {
                    l.material.opacity = isSelected ? 1.0 : 0.15;
                    l.material.color.setHex(isSelected ? 0x00ffff : 0x6644aa);
                    l.visible = true;
                }
            });
        }
        if (obj.constLabelGroup) obj.constLabelGroup.children.forEach(lbl => lbl.visible = isSelected || settings.constNames);
        if (obj.starLabelsGroup) obj.starLabelsGroup.children.forEach(lbl => {
            const isHighlightedStar = highlightedStarName && lbl.userData.starName === highlightedStarName;
            lbl.visible = isSelected || isHighlightedStar || settings.starNames;
        });
    });
}

function animateConstellationHighlight(constName) {
    const data = constellationMap[constName];
    if (!data) return;
    const duration = 2000;
    const startTime = Date.now();
    constellationAnimation = () => {
        const elapsed = Date.now() - startTime;
        const t = elapsed / duration;
        if (t >= 1) {
            constellationAnimation = null;
            data.linesGroup.children.forEach(l => { if (l.material) { l.material.opacity = 1.0; l.material.color.setHex(0x00ffff); } });
            return;
        }
        const pulse = Math.sin(t * Math.PI * 4) * 0.5 + 0.5;
        const color = new THREE.Color();
        color.setHSL(0.5 + pulse * 0.1, 1, 0.5 + pulse * 0.3);
        data.linesGroup.children.forEach(l => { if (l.material) { l.material.opacity = 0.7 + pulse * 0.3; l.material.color.copy(color); } });
    };
}

function resetView() {
    activeConstellation = null;
    highlightedStarName = null;
    document.querySelectorAll('.const-item').forEach(el => el.classList.remove('active'));
    Object.values(constellationMap).forEach(obj => {
        if (obj.linesGroup) obj.linesGroup.children.forEach(l => { if (l.material) { l.material.opacity = 0.6; l.material.color.setHex(0xaa66ff); l.visible = settings.lines; } });
        if (obj.constLabelGroup) obj.constLabelGroup.children.forEach(lbl => lbl.visible = settings.constNames);
        if (obj.starLabelsGroup) obj.starLabelsGroup.children.forEach(lbl => lbl.visible = settings.starNames);
    });
}

function applyVisibilitySettings() {
    groups.grid.visible = settings.grid;
    groups.cardinals.visible = true;
    groups.zenithNadir.visible = true;
    groups.stars.visible = settings.stars;
    groups.planets.visible = settings.planets;
    filterStarsByMagnitude(settings.maxMagnitude);
    if (!activeConstellation) {
        Object.values(constellationMap).forEach(c => {
            if (c.linesGroup) c.linesGroup.children.forEach(l => l.visible = settings.lines);
            if (c.constLabelGroup) c.constLabelGroup.children.forEach(lbl => lbl.visible = settings.constNames);
            if (c.starLabelsGroup) c.starLabelsGroup.children.forEach(lbl => lbl.visible = settings.starNames);
        });
    }
    groups.trajectories.visible = settings.traj;
    groups.iss.visible = settings.iss;
    const groundVisible = settings.ground && isInsideMode;
    if (landscapeMesh) landscapeMesh.visible = groundVisible;
    groups.ground.children.forEach(c => { if (c !== landscapeMesh) c.visible = settings.ground; });
}


function filterStarsByMagnitude(maxMag) {
    groups.stars.children.forEach(star => {
        if (star.userData && star.userData.type === 'star') {
            star.visible = star.userData.magnitude <= maxMag && settings.stars;
        }
    });
    
    groups.planets.children.forEach(obj => {
        if (obj.userData && (obj.userData.type === 'planet' || obj.userData.type === 'planet-label')) {
            obj.visible = obj.userData.magnitude <= maxMag && settings.planets;
        }
    });
}

// === –ù–ê–í–ò–ì–ê–¶–ò–Ø ===
function navigateToPosition(pos, onComplete = null) {
    if (!pos || isTransitioning) return;
    const normalized = pos.clone().normalize();
    const targetTheta = Math.atan2(normalized.x, normalized.z);
    const targetPhi = Math.acos(Math.max(-1, Math.min(1, normalized.y)));
    if (isInsideMode) animateCameraInside(targetTheta, targetPhi, onComplete);
    else animateCameraOutside(normalized.clone().multiplyScalar(100), onComplete);
}

function animateCameraInside(targetTheta, targetPhi, onComplete = null) {
    const startTheta = spherical.theta, startPhi = spherical.phi;
    let dTheta = targetTheta - startTheta;
    while (dTheta > Math.PI) dTheta -= 2 * Math.PI;
    while (dTheta < -Math.PI) dTheta += 2 * Math.PI;
    const duration = 1000, startTime = Date.now();

    cameraAnimation = () => {
        const elapsed = Date.now() - startTime;
        const t = Math.min(elapsed / duration, 1);
        const easeT = 1 - Math.pow(1 - t, 3);
        spherical.theta = startTheta + dTheta * easeT;
        spherical.phi = startPhi + (targetPhi - startPhi) * easeT;
        const minPhi = 0.05, maxPhi = settings.ground ? (Math.PI / 2 - 0.05) : (Math.PI - 0.05);
        spherical.phi = Math.max(minPhi, Math.min(maxPhi, spherical.phi));
        updateInsideCamera();
        if (t >= 1) { cameraAnimation = null; if (onComplete) onComplete(); }
    };
}

function animateCameraOutside(targetPos, onComplete = null) {
    const startPos = camera.position.clone();
    const duration = 1000, startTime = Date.now();
    cameraAnimation = () => {
        const elapsed = Date.now() - startTime;
        const t = Math.min(elapsed / duration, 1);
        camera.position.lerpVectors(startPos, targetPos, 1 - Math.pow(1 - t, 3));
        controls.target.set(0, 0, 0);
        controls.update();
        if (t >= 1) { cameraAnimation = null; if (onComplete) onComplete(); }
    };
}

function updateInsideCamera() {
    const x = Math.sin(spherical.phi) * Math.sin(spherical.theta);
    const y = Math.cos(spherical.phi);
    const z = Math.sin(spherical.phi) * Math.cos(spherical.theta);
    camera.position.set(0, 0.5, 0);
    camera.lookAt(x * 100, y * 100 + 0.5, z * 100);
}

// === –£–ü–†–ê–í–õ–ï–ù–ò–ï ===
function setupCustomControls() {
    const canvas = renderer.domElement;

    canvas.addEventListener('mousedown', (e) => {
        if (!isInsideMode || isTransitioning || isFlightMode) return;
        isMouseDown = true; lastMouseX = e.clientX; lastMouseY = e.clientY;
        canvas.style.cursor = 'grabbing';
    });

    canvas.addEventListener('mousemove', (e) => {
        if (!isInsideMode || !isMouseDown || isTransitioning || isFlightMode) return;
        spherical.theta -= (e.clientX - lastMouseX) * 0.004;
        spherical.phi += (e.clientY - lastMouseY) * 0.004;
        const minPhi = 0.05, maxPhi = settings.ground ? (Math.PI / 2 - 0.05) : (Math.PI - 0.05);
        spherical.phi = Math.max(minPhi, Math.min(maxPhi, spherical.phi));
        lastMouseX = e.clientX; lastMouseY = e.clientY;
        updateInsideCamera();
    });

    canvas.addEventListener('mouseup', () => { isMouseDown = false; canvas.style.cursor = 'grab'; });
    canvas.addEventListener('mouseleave', () => { isMouseDown = false; });

    canvas.addEventListener('wheel', (e) => {
        if (!isInsideMode || isTransitioning || isFlightMode) return;
        e.preventDefault();
        currentFov = Math.max(MIN_FOV, Math.min(MAX_FOV, currentFov + (e.deltaY > 0 ? 3 : -3)));
        camera.fov = currentFov;
        camera.updateProjectionMatrix();
        const indicator = document.getElementById('zoom-indicator');
        indicator.textContent = `üî≠ Zoom: ${currentFov.toFixed(0)}¬∞`;
        indicator.classList.add('visible');
        clearTimeout(zoomTimeout);
        zoomTimeout = setTimeout(() => indicator.classList.remove('visible'), 1500);
    }, { passive: false });

    let touchStartDist = 0;
    canvas.addEventListener('touchstart', (e) => {
        if (!isInsideMode || isTransitioning || isFlightMode) return;
        if (e.touches.length === 1) { isMouseDown = true; lastMouseX = e.touches[0].clientX; lastMouseY = e.touches[0].clientY; }
        else if (e.touches.length === 2) { touchStartDist = Math.hypot(e.touches[0].clientX - e.touches[1].clientX, e.touches[0].clientY - e.touches[1].clientY); }
    });

    canvas.addEventListener('touchmove', (e) => {
        if (!isInsideMode || isTransitioning || isFlightMode) return;
        e.preventDefault();
        if (e.touches.length === 1 && isMouseDown) {
            spherical.theta -= (e.touches[0].clientX - lastMouseX) * 0.004;
            spherical.phi += (e.touches[0].clientY - lastMouseY) * 0.004;
            const minPhi = 0.05, maxPhi = settings.ground ? (Math.PI / 2 - 0.05) : (Math.PI - 0.05);
            spherical.phi = Math.max(minPhi, Math.min(maxPhi, spherical.phi));
            lastMouseX = e.touches[0].clientX; lastMouseY = e.touches[0].clientY;
            updateInsideCamera();
        } else if (e.touches.length === 2) {
            const dist = Math.hypot(e.touches[0].clientX - e.touches[1].clientX, e.touches[0].clientY - e.touches[1].clientY);
            currentFov = Math.max(MIN_FOV, Math.min(MAX_FOV, currentFov + (touchStartDist - dist) * 0.1));
            camera.fov = currentFov;
            camera.updateProjectionMatrix();
            touchStartDist = dist;
        }
    }, { passive: false });

    canvas.addEventListener('touchend', () => { isMouseDown = false; });
}

// === TOOLTIP –ò –î–í–û–ô–ù–û–ô –ö–õ–ò–ö ===
function setupTooltip() {
    const canvas = renderer.domElement;
    const tooltip = document.getElementById('tooltip');

    canvas.addEventListener('mousemove', (e) => {
        if (isTransitioning || isFlightMode) return;
        mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
        raycaster.setFromCamera(mouse, camera);
        const intersects = raycaster.intersectObjects(interactiveObjects, false);
        
        if (intersects.length > 0) {
            const obj = intersects[0].object;
            if (obj.userData && obj.userData.type) {
                hoveredObject = obj;
                showTooltip(e.clientX, e.clientY, obj.userData);
                canvas.style.cursor = 'pointer';

                // --- –ù–ê–ß–ê–õ–û –ò–ó–ú–ï–ù–ï–ù–ò–ô: –¢—Ä–∞–µ–∫—Ç–æ—Ä–∏—è –ø—Ä–∏ –Ω–∞–≤–µ–¥–µ–Ω–∏–∏ ---
                // –†–∏—Å—É–µ–º —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏: –≤–∫–ª—é—á–µ–Ω—ã —Ç—Ä–∞–µ–∫—Ç–æ—Ä–∏–∏, —ç—Ç–æ –∑–≤–µ–∑–¥–∞, –∏ –¥–ª—è –Ω–µ—ë –µ—â–µ –Ω–µ –Ω–∞—Ä–∏—Å–æ–≤–∞–Ω —Ç—Ä–µ–∫
                     const supportedTypes = ['star', 'planet', 'sun', 'moon'];
                
                if (settings.traj && supportedTypes.includes(obj.userData.type)) {
                    // –ï—Å–ª–∏ —Ç—Ä–µ–∫ —É–∂–µ –µ—Å—Ç—å, –Ω–æ –¥–ª—è –¥—Ä—É–≥–æ–≥–æ –æ–±—ä–µ–∫—Ç–∞ - —É–¥–∞–ª—è–µ–º —Å—Ç–∞—Ä—ã–π
                    if (hoverTrajectory && hoverTrajectory.userData.targetName !== obj.userData.name) {
                        scene.remove(hoverTrajectory);
                        if (hoverTrajectory.geometry) hoverTrajectory.geometry.dispose();
                        hoverTrajectory = null;
                    }

                    // –ï—Å–ª–∏ —Ç—Ä–µ–∫–∞ –Ω–µ—Ç - —Å–æ–∑–¥–∞–µ–º –Ω–æ–≤—ã–π
                    if (!hoverTrajectory) {
                        // –í—ã–±–∏—Ä–∞–µ–º —Ü–≤–µ—Ç: –¥–ª—è –∑–≤–µ–∑–¥ —Å–µ—Ä—ã–π, –¥–ª—è –ø–ª–∞–Ω–µ—Ç/—Å–æ–ª–Ω—Ü–∞ - –ø–æ—è—Ä—á–µ (–Ω–∞–ø—Ä–∏–º–µ—Ä, –∑–æ–ª–æ—Ç–∏—Å—Ç—ã–π –∏–ª–∏ –≥–æ–ª—É–±–æ–π)
                        // –ù–æ —á—Ç–æ–±—ã –±—ã–ª–æ –∫–∞–∫ –ø—Ä–æ—Å–∏–ª–∏ (–∫–∞–∫ –¥–ª—è —Å–æ–ª–Ω—Ü–∞) - –≤–æ–∑—å–º–µ–º 0xaaaaaa –∏–ª–∏ —Ü–≤–µ—Ç –æ–±—ä–µ–∫—Ç–∞
                        let trackColor = 0xaaaaaa;
                        if (obj.userData.type === 'sun') trackColor = 0xffaa00;
                        else if (obj.userData.type === 'planet') trackColor = 0xaaccff;

                        hoverTrajectory = createHoverTrajectory(obj.userData, trackColor);
                        scene.add(hoverTrajectory);
                    }
                }
                // --- –ö–û–ù–ï–¶ –ò–ó–ú–ï–ù–ï–ù–ò–ô ---

                return;
            }
        }
        
        // –ï—Å–ª–∏ –∫—É—Ä—Å–æ—Ä —É—à–µ–ª —Å –æ–±—ä–µ–∫—Ç–∞
        if (hoverTrajectory) {
            scene.remove(hoverTrajectory);
            if (hoverTrajectory.geometry) hoverTrajectory.geometry.dispose();
            hoverTrajectory = null;
        }

        hoveredObject = null;
        tooltip.style.display = 'none';
        canvas.style.cursor = isMouseDown ? 'grabbing' : 'grab';
    });

    canvas.addEventListener('mouseleave', () => { 
        tooltip.style.display = 'none'; 
        hoveredObject = null;
        
        // –£–¥–∞–ª—è–µ–º —Ç—Ä–∞–µ–∫—Ç–æ—Ä–∏—é –ø—Ä–∏ —É—Ö–æ–¥–µ –º—ã—à–∏ —Å —Ö–æ–ª—Å—Ç–∞
        if (hoverTrajectory) {
            scene.remove(hoverTrajectory);
            hoverTrajectory = null;
        }
    });

    // === –î–í–û–ô–ù–û–ô –ö–õ–ò–ö ‚Äî –¶–ï–ù–¢–†–ò–†–û–í–ê–ù–ò–ï + –ü–û–õ–Å–¢ ===
 canvas.addEventListener('dblclick', async (e) => {
        if (isTransitioning || isFlightMode || isDetailMode) return;
        
        mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
        raycaster.setFromCamera(mouse, camera);
        const intersects = raycaster.intersectObjects(interactiveObjects, false);

        if (intersects.length > 0) {
            const data = intersects[0].object.userData;
            const position = intersects[0].object.position.clone();
            
            tooltip.style.display = 'none';
            
            // –ó–≤–µ–∑–¥–∞
            if (data.type === 'star') {
                await centerAndFlyToObject(data, position, 'star');
            }
            // –ü–ª–∞–Ω–µ—Ç–∞
            else if (data.type === 'planet' && PLANETS_DATA[data.name]) {
                await centerAndFlyToObject(data, position, 'planet');
            }
            // --- –ò–ó–ú–ï–ù–ï–ù–ò–ï: –î–æ–±–∞–≤–ª–µ–Ω–æ —É—Å–ª–æ–≤–∏–µ –¥–ª—è –õ—É–Ω—ã ---
            else if (data.type === 'moon') {
                 await centerAndFlyToObject(data, position, 'moon');
            }
            // --------------------------------------------
        }
    });
}



// –í—ã—á–∏—Å–ª–µ–Ω–∏–µ –≤—Ä–µ–º–µ–Ω–∏ –≤–æ—Å—Ö–æ–¥–∞, –∑–∞–∫–∞—Ç–∞ –∏ –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–π –≤—ã—Å–æ—Ç—ã –¥–ª—è –æ–±—ä–µ–∫—Ç–∞ –ø–æ RA/Dec
function calculateObjectTimes(ra, dec) {
    const result = { rise: null, set: null, maxAltitude: -90, transitTime: null };
    const observer = new Astronomy.Observer(observerLat, observerLon, 0);
    
    const now = new Date();
    const startOfDay = new Date(now);
    startOfDay.setHours(0, 0, 0, 0);
    
    let prevAlt = null;
    let maxAlt = -90;
    
    // –£–º–µ–Ω—å—à–∞–µ–º —à–∞–≥ —Å 10 –¥–æ 2 –º–∏–Ω—É—Ç –¥–ª—è —Ç–æ—á–Ω–æ—Å—Ç–∏
    const step = 2; 
    
    // –ü—Ä–æ—Ö–æ–¥–∏–º —Å—É—Ç–∫–∏
    for (let minutes = 0; minutes <= 24 * 60; minutes += step) {
        const t = new Date(startOfDay.getTime() + minutes * 60000);
        try {
            // 'normal' —É—á–∏—Ç—ã–≤–∞–µ—Ç —Ä–µ—Ñ—Ä–∞–∫—Ü–∏—é –∞—Ç–º–æ—Å—Ñ–µ—Ä—ã
            const hor = Astronomy.Horizon(t, observer, ra, dec, 'normal');
            
            // –ü–æ–∏—Å–∫ –∫—É–ª—å–º–∏–Ω–∞—Ü–∏–∏ (–º–∞–∫—Å. –≤—ã—Å–æ—Ç—ã)
            if (hor.altitude > maxAlt) {
                maxAlt = hor.altitude;
                result.transitTime = t;
            }
            
            if (prevAlt !== null) {
                // –ò–Ω—Ç–µ—Ä–ø–æ–ª—è—Ü–∏—è –≤—Ä–µ–º–µ–Ω–∏ –¥–ª—è —Ç–æ—á–Ω–æ–≥–æ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è –º–æ–º–µ–Ω—Ç–∞ –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏—è –≥–æ—Ä–∏–∑–æ–Ω—Ç–∞ (0 –≥—Ä–∞–¥—É—Å–æ–≤)
                // –ï—Å–ª–∏ –≤ –ø—Ä–æ—à–ª–æ–º —à–∞–≥–µ –±—ã–ª–æ –Ω–∏–∂–µ 0, –∞ —Å–µ–π—á–∞—Å –≤—ã—à–µ -> –í–æ—Å—Ö–æ–¥
                if (prevAlt < 0 && hor.altitude >= 0 && !result.rise) {
                    const fraction = (0 - prevAlt) / (hor.altitude - prevAlt);
                    const preciseMinutes = (minutes - step) + (fraction * step);
                    result.rise = new Date(startOfDay.getTime() + preciseMinutes * 60000);
                }
                // –ï—Å–ª–∏ –≤ –ø—Ä–æ—à–ª–æ–º —à–∞–≥–µ –±—ã–ª–æ –≤—ã—à–µ 0, –∞ —Å–µ–π—á–∞—Å –Ω–∏–∂–µ -> –ó–∞–∫–∞—Ç
                if (prevAlt >= 0 && hor.altitude < 0 && !result.set) {
                    const fraction = (0 - prevAlt) / (hor.altitude - prevAlt);
                    const preciseMinutes = (minutes - step) + (fraction * step);
                    result.set = new Date(startOfDay.getTime() + preciseMinutes * 60000);
                }
            }
            
            prevAlt = hor.altitude;
        } catch(e) {}
    }
    
    result.maxAltitude = maxAlt;
    return result;
}


// –í—ã—á–∏—Å–ª–µ–Ω–∏–µ –≤—Ä–µ–º—ë–Ω –¥–ª—è –ø–ª–∞–Ω–µ—Ç/–°–æ–ª–Ω—Ü–∞/–õ—É–Ω—ã
function calculateBodyTimes(bodyName) {
    const observer = new Astronomy.Observer(observerLat, observerLon, 0);
    const now = new Date();
    const startOfDay = new Date(now);
    startOfDay.setHours(0, 0, 0, 0);

    // –ò—Å–ø–æ–ª—å–∑—É–µ–º –≤—Å—Ç—Ä–æ–µ–Ω–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏ –ø–æ–∏—Å–∫–∞ —Å–æ–±—ã—Ç–∏–π –¥–ª—è –≤—ã—Å–æ–∫–æ–π —Ç–æ—á–Ω–æ—Å—Ç–∏
    // +1 = –í–æ—Å—Ö–æ–¥, -1 = –ó–∞–∫–∞—Ç. –õ–∏–º–∏—Ç –ø–æ–∏—Å–∫–∞ = 1 –¥–µ–Ω—å.
    const riseEvent = Astronomy.SearchRiseSet(bodyName, observer, +1, startOfDay, 1);
    const setEvent = Astronomy.SearchRiseSet(bodyName, observer, -1, startOfDay, 1);
    
    // –î–ª—è –ø–æ–∏—Å–∫–∞ –∫—É–ª—å–º–∏–Ω–∞—Ü–∏–∏ –∏—â–µ–º –º–æ–º–µ–Ω—Ç, –∫–æ–≥–¥–∞ —á–∞—Å–æ–≤–æ–π —É–≥–æ–ª —Ä–∞–≤–µ–Ω 0
    const transitEvent = Astronomy.SearchHourAngle(bodyName, observer, 0, startOfDay);

    // –ü–æ–ª—É—á–∞–µ–º –¥–∞—Ç—ã –∏–∑ —Å–æ–±—ã—Ç–∏–π (–±–∏–±–ª–∏–æ—Ç–µ–∫–∞ –º–æ–∂–µ—Ç –≤–µ—Ä–Ω—É—Ç—å null, –µ—Å–ª–∏ —Å–æ–±—ã—Ç–∏—è –Ω–µ—Ç –≤ —ç—Ç–æ—Ç –¥–µ–Ω—å)
    const rise = riseEvent ? riseEvent.date : null;
    const set = setEvent ? setEvent.date : null;
    let transitTime = transitEvent ? transitEvent.date : null;

    // –í—ã—á–∏—Å–ª—è–µ–º –º–∞–∫—Å–∏–º–∞–ª—å–Ω—É—é –≤—ã—Å–æ—Ç—É –≤ –º–æ–º–µ–Ω—Ç –∫—É–ª—å–º–∏–Ω–∞—Ü–∏–∏
    let maxAltitude = -90;
    
    // –ï—Å–ª–∏ –∫—É–ª—å–º–∏–Ω–∞—Ü–∏—è –Ω–∞–π–¥–µ–Ω–∞, —Å—á–∏—Ç–∞–µ–º –≤—ã—Å–æ—Ç—É —Ç–æ—á–Ω–æ –≤ —ç—Ç–æ –≤—Ä–µ–º—è
    if (transitTime) {
        const eq = Astronomy.Equator(bodyName, transitTime, observer, false, true);
        const hor = Astronomy.Horizon(transitTime, observer, eq.ra, eq.dec, 'normal');
        maxAltitude = hor.altitude;
    } else {
        // –§–æ–ª–ª–±–µ–∫, –µ—Å–ª–∏ –∫—É–ª—å–º–∏–Ω–∞—Ü–∏—è –Ω–µ –ø–æ–ø–∞–¥–∞–µ—Ç –≤ —ç—Ç–∏ —Å—É—Ç–∫–∏ (—Ä–µ–¥–∫–æ, –Ω–æ –±—ã–≤–∞–µ—Ç –¥–ª—è –õ—É–Ω—ã)
        // –ë–µ—Ä–µ–º —Ç–µ–∫—É—â–∏–π –º–æ–º–µ–Ω—Ç –∫–∞–∫ –ø—Ä–∏–±–ª–∏–∑–∏—Ç–µ–ª—å–Ω—ã–π
        const eq = Astronomy.Equator(bodyName, now, observer, false, true);
        const hor = Astronomy.Horizon(now, observer, eq.ra, eq.dec, 'normal');
        maxAltitude = hor.altitude;
    }

    return { 
        rise: rise, 
        set: set, 
        maxAltitude: maxAltitude, 
        transitTime: transitTime 
    };
}

// –§–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –≤—Ä–µ–º–µ–Ω–∏
function formatTime(date) {
    if (!date) return '‚Äî';
    return date.toLocaleTimeString('ru-RU', { hour: '2-digit', minute: '2-digit' });
}

function showTooltip(x, y, data) {
    const tooltip = document.getElementById('tooltip');
    let icon = '‚≠ê', typeText = '–ó–≤–µ–∑–¥–∞', extraInfo = '';

    // –õ–µ–Ω–∏–≤–æ–µ –≤—ã—á–∏—Å–ª–µ–Ω–∏–µ –≤—Ä–µ–º—ë–Ω –ø—Ä–∏ –ø–µ—Ä–≤–æ–º –Ω–∞–≤–µ–¥–µ–Ω–∏–∏
    if (!data.timesCalculated && data.type !== 'iss') {
        let times = null;
        if (data.type === 'star' && data.ra !== undefined && data.dec !== undefined) {
            times = calculateObjectTimes(data.ra, data.dec);
        } else if (data.type === 'planet') {
            const enName = PLANET_NAMES_EN[data.name] || data.name;
            times = calculateBodyTimes(enName);
        } else if (data.type === 'sun') {
            times = calculateBodyTimes('Sun');
        } else if (data.type === 'moon') {
            times = calculateBodyTimes('Moon');
        }
        
        if (times) {
            data.riseTime = times.rise;
            data.setTime = times.set;
            data.maxAltitude = times.maxAltitude;
            data.timesCalculated = true;
        }
    }

    if (data.type === 'star') {
        icon = data.magnitude < 1 ? 'üåü' : '‚≠ê';
        extraInfo = `
            <div class="tooltip-row"><span class="tooltip-label">–ó–≤. –≤–µ–ª–∏—á–∏–Ω–∞:</span><span class="tooltip-value">${data.magnitude.toFixed(2)}m</span></div>
            <div class="tooltip-row"><span class="tooltip-label">–ê–∑–∏–º—É—Ç:</span><span class="tooltip-value">${data.azimuth?.toFixed(1) || '‚Äî'}¬∞</span></div>
            <div class="tooltip-row"><span class="tooltip-label">–í—ã—Å–æ—Ç–∞:</span><span class="tooltip-value">${data.altitude?.toFixed(1) || '‚Äî'}¬∞</span></div>
            <div class="tooltip-row"><span class="tooltip-label">–ú–∞–∫—Å. –≤—ã—Å–æ—Ç–∞:</span><span class="tooltip-value">${data.maxAltitude?.toFixed(1) || '‚Äî'}¬∞</span></div>
            <div class="tooltip-row"><span class="tooltip-label">–í–æ—Å—Ö–æ–¥:</span><span class="tooltip-value">${formatTime(data.riseTime)}</span></div>
            <div class="tooltip-row"><span class="tooltip-label">–ó–∞–∫–∞—Ç:</span><span class="tooltip-value">${formatTime(data.setTime)}</span></div>
            <div class="tooltip-row"><span class="tooltip-label">RA:</span><span class="tooltip-value">${data.ra?.toFixed(2) || '‚Äî'}h</span></div>
            <div class="tooltip-row"><span class="tooltip-label">Dec:</span><span class="tooltip-value">${data.dec?.toFixed(2) || '‚Äî'}¬∞</span></div>`;
        if (data.constellation) extraInfo += `<div class="tooltip-constellation">–°–æ–∑–≤–µ–∑–¥–∏–µ: ${data.constellation}</div>`;
        extraInfo += `<div class="tooltip-hint">üñ±Ô∏è –î–≤–æ–π–Ω–æ–π –∫–ª–∏–∫ ‚Äî –ø–æ–¥—Ä–æ–±–Ω–µ–µ</div>`;
        
    } else if (data.type === 'planet') {
        icon = 'ü™ê'; typeText = '–ü–ª–∞–Ω–µ—Ç–∞';
        extraInfo = `
            <div class="tooltip-row"><span class="tooltip-label">–ó–≤. –≤–µ–ª–∏—á–∏–Ω–∞:</span><span class="tooltip-value">${data.magnitude?.toFixed(1) || '‚Äî'}m</span></div>
            <div class="tooltip-row"><span class="tooltip-label">–ê–∑–∏–º—É—Ç:</span><span class="tooltip-value">${data.azimuth?.toFixed(1) || '‚Äî'}¬∞</span></div>
            <div class="tooltip-row"><span class="tooltip-label">–í—ã—Å–æ—Ç–∞:</span><span class="tooltip-value">${data.altitude?.toFixed(1) || '‚Äî'}¬∞</span></div>
            <div class="tooltip-row"><span class="tooltip-label">–ú–∞–∫—Å. –≤—ã—Å–æ—Ç–∞:</span><span class="tooltip-value">${data.maxAltitude?.toFixed(1) || '‚Äî'}¬∞</span></div>
            <div class="tooltip-row"><span class="tooltip-label">–í–æ—Å—Ö–æ–¥:</span><span class="tooltip-value">${formatTime(data.riseTime)}</span></div>
            <div class="tooltip-row"><span class="tooltip-label">–ó–∞–∫–∞—Ç:</span><span class="tooltip-value">${formatTime(data.setTime)}</span></div>`;
        if (PLANETS_DATA[data.name]) extraInfo += `<div class="tooltip-hint">üñ±Ô∏è –î–≤–æ–π–Ω–æ–π –∫–ª–∏–∫ ‚Äî –ø–æ–¥—Ä–æ–±–Ω–µ–µ</div>`;
        
    } else if (data.type === 'sun') {
        icon = '‚òÄÔ∏è'; typeText = '–ó–≤–µ–∑–¥–∞ (–Ω–∞—à–∞)';
        extraInfo = `
            <div class="tooltip-row"><span class="tooltip-label">–ó–≤. –≤–µ–ª–∏—á–∏–Ω–∞:</span><span class="tooltip-value">-26.7m</span></div>
            <div class="tooltip-row"><span class="tooltip-label">–ê–∑–∏–º—É—Ç:</span><span class="tooltip-value">${data.azimuth?.toFixed(1)}¬∞</span></div>
            <div class="tooltip-row"><span class="tooltip-label">–í—ã—Å–æ—Ç–∞:</span><span class="tooltip-value">${data.altitude?.toFixed(1)}¬∞</span></div>
            <div class="tooltip-row"><span class="tooltip-label">–ú–∞–∫—Å. –≤—ã—Å–æ—Ç–∞:</span><span class="tooltip-value">${data.maxAltitude?.toFixed(1) || '‚Äî'}¬∞</span></div>
            <div class="tooltip-row"><span class="tooltip-label">–í–æ—Å—Ö–æ–¥:</span><span class="tooltip-value">${formatTime(data.riseTime)}</span></div>
            <div class="tooltip-row"><span class="tooltip-label">–ó–∞–∫–∞—Ç:</span><span class="tooltip-value">${formatTime(data.setTime)}</span></div>`;
        
    } else if (data.type === 'moon') {
        icon = 'üåô'; typeText = '–°–ø—É—Ç–Ω–∏–∫ –ó–µ–º–ª–∏';
        extraInfo = `
            <div class="tooltip-row"><span class="tooltip-label">–ó–≤. –≤–µ–ª–∏—á–∏–Ω–∞:</span><span class="tooltip-value">~-12.7m</span></div>
            <div class="tooltip-row"><span class="tooltip-label">–ê–∑–∏–º—É—Ç:</span><span class="tooltip-value">${data.azimuth?.toFixed(1)}¬∞</span></div>
            <div class="tooltip-row"><span class="tooltip-label">–í—ã—Å–æ—Ç–∞:</span><span class="tooltip-value">${data.altitude?.toFixed(1)}¬∞</span></div>
            <div class="tooltip-row"><span class="tooltip-label">–ú–∞–∫—Å. –≤—ã—Å–æ—Ç–∞:</span><span class="tooltip-value">${data.maxAltitude?.toFixed(1) || '‚Äî'}¬∞</span></div>
            <div class="tooltip-row"><span class="tooltip-label">–í–æ—Å—Ö–æ–¥:</span><span class="tooltip-value">${formatTime(data.riseTime)}</span></div>
            <div class="tooltip-row"><span class="tooltip-label">–ó–∞–∫–∞—Ç:</span><span class="tooltip-value">${formatTime(data.setTime)}</span></div>`;
        
    } else if (data.type === 'iss') {
        icon = 'üõ∞Ô∏è'; typeText = '–ö–æ—Å–º–∏—á–µ—Å–∫–∞—è —Å—Ç–∞–Ω—Ü–∏—è';
        extraInfo = `
            <div class="tooltip-row"><span class="tooltip-label">–ê–∑–∏–º—É—Ç:</span><span class="tooltip-value">${data.azimuth?.toFixed(1)}¬∞</span></div>
            <div class="tooltip-row"><span class="tooltip-label">–í—ã—Å–æ—Ç–∞:</span><span class="tooltip-value">${data.altitude?.toFixed(1)}¬∞</span></div>
            <div class="tooltip-row"><span class="tooltip-label">–û—Ä–±–∏—Ç–∞:</span><span class="tooltip-value">~408 –∫–º</span></div>`;
    }

    tooltip.innerHTML = `<div class="tooltip-header"><span class="tooltip-icon">${icon}</span>
        <div><div class="tooltip-name">${data.name || '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ'}</div><div class="tooltip-type">${typeText}</div></div>
        </div>${extraInfo}`;

    let left = x + 15, top = y + 15;
    if (left + 260 > window.innerWidth) left = x - 270;
    if (top + 350 > window.innerHeight) top = y - 350;
    tooltip.style.left = left + 'px';
    tooltip.style.top = top + 'px';
    tooltip.style.display = 'block';
}

function toggleSearch() {
    const container = document.getElementById('search-container');
    const btn = document.getElementById('btn-search');
    const input = document.getElementById('universal-search');
    
    isSearchOpen = !isSearchOpen;
    
    if (isSearchOpen) {
        container.classList.add('visible');
        btn.classList.add('active');
        setTimeout(() => input.focus(), 300);
    } else {
        container.classList.remove('visible');
        btn.classList.remove('active');
        input.value = '';
        document.getElementById('search-results').style.display = 'none';
    }
}

// === –ü–û–ò–°–ö ===
function setupUniversalSearch() {
    const input = document.getElementById('universal-search');
    const results = document.getElementById('search-results');
    const btnSearch = document.getElementById('btn-search');

    btnSearch.onclick = toggleSearch;

    input.addEventListener('input', (e) => {
        const val = e.target.value.trim().toLowerCase();
        if (val.length < 2) { results.style.display = 'none'; return; }
        clearTimeout(searchTimeout);
        searchTimeout = setTimeout(() => performSearch(val, false), 300);
    });

    input.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') {
            const val = input.value.trim().toLowerCase();
            if (val.length >= 2) performSearch(val, true);
        }
        if (e.key === 'Escape') {
            toggleSearch();
        }
    });

    input.addEventListener('focus', () => { if (input.value.length >= 2) results.style.display = 'block'; });
    
    document.addEventListener('click', (e) => {
        if (!e.target.closest('#search-container') && !e.target.closest('#btn-search')) {
            if (isSearchOpen) {
                toggleSearch();
            }
        }
    });
}

async function performSearch(query, includeCity = false) {
    const results = document.getElementById('search-results');
    let html = '';

    // –°–æ–∑–≤–µ–∑–¥–∏—è
    const matchedConstellations = [];
    Object.keys(CONSTELLATIONS).forEach(name => {
        const data = CONSTELLATIONS[name];
        if (name.toLowerCase().includes(query) || data.latin.toLowerCase().includes(query) || (data.abbr && data.abbr.toLowerCase().includes(query))) {
            matchedConstellations.push({ name, latin: data.latin, visible: constellationVisibility[name] });
        }
    });
    if (matchedConstellations.length > 0) {
        html += `<div class="search-group-title">‚ú® –°–æ–∑–≤–µ–∑–¥–∏—è</div>`;
        matchedConstellations.forEach(c => {
            html += `<div class="search-item" data-type="constellation" data-name="${c.name}">
                <span><span class="search-item-icon">‚ú®</span>${c.name}</span>
                <span class="search-item-info">${c.latin} <span style="color:${c.visible ? '#88ff88' : '#ff8888'}">${c.visible ? '‚Üë' : '‚Üì'}</span></span>
            </div>`;
        });
    }

    // –ó–≤—ë–∑–¥—ã
    const matchedStars = [];
    Object.keys(CONSTELLATIONS).forEach(constName => {
        CONSTELLATIONS[constName].stars.forEach(star => {
            if (star.name.toLowerCase().includes(query)) {
                matchedStars.push({ name: star.name, constellation: constName, mag: star.mag, bayer: star.bayer });
            }
        });
    });
    if (matchedStars.length > 0) {
        html += `<div class="search-group-title">‚≠ê –ó–≤—ë–∑–¥—ã</div>`;
        matchedStars.slice(0, 10).forEach(s => {
            html += `<div class="search-item" data-type="star" data-name="${s.name}" data-constellation="${s.constellation}">
                <span><span class="search-item-icon">‚≠ê</span>${s.name} ${s.bayer || ''}</span>
                <span class="search-item-info">${s.constellation}, ${s.mag.toFixed(2)}m</span>
            </div>`;
        });
    }

    // –ü–ª–∞–Ω–µ—Ç—ã
    const matchedPlanets = [];
    PLANETS.forEach(p => {
        const ruName = PLANET_NAMES_RU[p];
        if (p.toLowerCase().includes(query) || ruName.toLowerCase().includes(query)) {
            matchedPlanets.push({ en: p, ru: ruName, mag: PLANET_MAG[p] });
        }
    });
    if ('—Å–æ–ª–Ω—Ü–µ'.includes(query) || 'sun'.includes(query)) matchedPlanets.push({ en: 'Sun', ru: '–°–æ–ª–Ω—Ü–µ', mag: -26.7 });
    if ('–ª—É–Ω–∞'.includes(query) || 'moon'.includes(query)) matchedPlanets.push({ en: 'Moon', ru: '–õ—É–Ω–∞', mag: -12.7 });

    if (matchedPlanets.length > 0) {
        html += `<div class="search-group-title">ü™ê –ü–ª–∞–Ω–µ—Ç—ã –∏ —Å–≤–µ—Ç–∏–ª–∞</div>`;
        matchedPlanets.forEach(p => {
            const icon = p.en === 'Sun' ? '‚òÄÔ∏è' : p.en === 'Moon' ? 'üåô' : 'ü™ê';
            html += `<div class="search-item" data-type="planet" data-name="${p.en}">
                <span><span class="search-item-icon">${icon}</span>${p.ru}</span>
                <span class="search-item-info">${p.mag.toFixed(1)}m</span>
            </div>`;
        });
    }

    // –ì–æ—Ä–æ–¥–∞
    if (includeCity) {
        try {
            const response = await fetch(`https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(query)}&limit=5&accept-language=ru`);
            const cities = await response.json();
            if (cities.length > 0) {
                html += `<div class="search-group-title">üìç –ì–æ—Ä–æ–¥–∞ –∏ –º–µ—Å—Ç–∞</div>`;
                cities.forEach(city => {
                    html += `<div class="search-item" data-type="city" data-lat="${city.lat}" data-lon="${city.lon}" data-name="${city.display_name.split(',')[0]}">
                        <span><span class="search-item-icon">üìç</span>${city.display_name.split(',')[0]}</span>
                        <span class="search-item-info">${parseFloat(city.lat).toFixed(2)}¬∞, ${parseFloat(city.lon).toFixed(2)}¬∞</span>
                    </div>`;
                });
            }
        } catch (e) { }
    } else {
        html += `<div class="search-group-title" style="opacity: 0.5;">üìç –ù–∞–∂–º–∏—Ç–µ Enter –¥–ª—è –ø–æ–∏—Å–∫–∞ –≥–æ—Ä–æ–¥–æ–≤</div>`;
    }

    if (html) {
        results.innerHTML = html;
        results.style.display = 'block';
        results.querySelectorAll('.search-item').forEach(item => { item.addEventListener('click', () => handleSearchSelect(item)); });
    } else {
        results.innerHTML = '<div style="padding: 15px; text-align: center; opacity: 0.5;">–ù–∏—á–µ–≥–æ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ</div>';
        results.style.display = 'block';
    }
}

function handleSearchSelect(item) {
    const type = item.dataset.type;
    const name = item.dataset.name;
    const input = document.getElementById('universal-search');
    const results = document.getElementById('search-results');
    results.style.display = 'none';
    
    toggleSearch();

    switch (type) {
        case 'constellation':
            selectConstellation(name);
            break;
        case 'star':
            highlightedStarName = name;
            navigateToStar(name, true);
            break;
        case 'planet':
            navigateToPosition(planetPositions[name]);
            break;
        case 'city':
            setLocation(parseFloat(item.dataset.lat), parseFloat(item.dataset.lon), name);
            break;
    }
}

function navigateToStar(starName, withZoom = false) {
    const pos = starPositions[starName];
    if (!pos) return;
    highlightedStarName = starName;
    allStarLabels.forEach(label => {
        if (label.userData.starName === starName) {
            label.visible = true;
            label.scale.set(label.userData.baseScale?.x * 1.5 || label.scale.x, label.userData.baseScale?.y * 1.5 || label.scale.y, 1);
        } else {
            if (label.userData.baseScale) label.scale.copy(label.userData.baseScale);
        }
    });
    navigateToPosition(pos, () => {
        if (withZoom && isInsideMode) {
            const targetFov = 20, startFov = currentFov, duration = 800, startTime = Date.now();
            const zoomAnim = () => {
                const elapsed = Date.now() - startTime;
                const t = Math.min(elapsed / duration, 1);
                currentFov = startFov + (targetFov - startFov) * (1 - Math.pow(1 - t, 3));
                camera.fov = currentFov;
                camera.updateProjectionMatrix();
                if (t < 1) requestAnimationFrame(zoomAnim);
            };
            zoomAnim();
        }
    });
    const indicator = document.getElementById('mode-indicator');
    indicator.innerHTML = `‚≠ê ${starName}`;
    indicator.classList.add('visible');
    setTimeout(() => indicator.classList.remove('visible'), 3000);
}

function setLocation(lat, lon, name) {
    observerLat = lat; observerLon = lon; locationName = name;
    document.getElementById('location-name').textContent = name;
    updateSky();
    const indicator = document.getElementById('mode-indicator');
    indicator.textContent = `üìç ${name}`;
    indicator.classList.add('visible');
    setTimeout(() => indicator.classList.remove('visible'), 3000);
}

async function getLocationName(lat, lon) {
    try {
        const response = await fetch(`https://nominatim.openstreetmap.org/reverse?lat=${lat}&lon=${lon}&format=json&accept-language=ru`);
        const data = await response.json();
        if (data.address) {
            locationName = data.address.city || data.address.town || data.address.village || data.address.county || data.address.state || '';
            const country = data.address.country || '';
            if (locationName && country) locationName = `${locationName}, ${country}`;
            else if (country) locationName = country;
        }
        document.getElementById('location-name').textContent = locationName || '–ú–µ—Å—Ç–æ–ø–æ–ª–æ–∂–µ–Ω–∏–µ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–æ';
    } catch (e) { document.getElementById('location-name').textContent = '–ú–µ—Å—Ç–æ–ø–æ–ª–æ–∂–µ–Ω–∏–µ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–æ'; }
}

// === UI SETUP ===
document.getElementById('btn-toggle-const').onclick = () => {
    const panel = document.getElementById('constellation-panel');
    panel.classList.toggle('visible');
    if (panel.classList.contains('visible') && window.innerWidth <= 768) {
        document.getElementById('controls-panel').classList.remove('visible');
        document.getElementById('info-panel').style.display = 'block';
    }
};

document.getElementById('btn-toggle-controls').onclick = () => {
    const panel = document.getElementById('controls-panel');
    const infoPanel = document.getElementById('info-panel');
    
    panel.classList.toggle('visible');
    
    // –°–æ—Ö—Ä–∞–Ω—è–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ
    settings.controlsOpen = panel.classList.contains('visible');
    saveSettings();

    // –õ–æ–≥–∏–∫–∞ –ø–µ—Ä–µ–∫—Ä—ã—Ç–∏—è –ø–∞–Ω–µ–ª–µ–π (–æ—Å—Ç–∞–≤–ª—è–µ–º –∫–∞–∫ –±—ã–ª–æ –¥–ª—è –º–æ–±–∏–ª—å–Ω—ã—Ö, –Ω–æ —Ä–∞–±–æ—Ç–∞–µ—Ç –≤–µ–∑–¥–µ)
    if (panel.classList.contains('visible')) {
        // –ï—Å–ª–∏ —ç–∫—Ä–∞–Ω —É–∑–∫–∏–π, —Å–∫—Ä—ã–≤–∞–µ–º –∏–Ω—Ñ–æ-–ø–∞–Ω–µ–ª—å
        if (window.innerWidth <= 768) {
            infoPanel.style.display = 'none';
            document.getElementById('constellation-panel').classList.remove('visible');
        }
    } else {
        infoPanel.style.display = 'block';
    }
};

document.addEventListener('click', (e) => {
    if (window.innerWidth <= 768 && !isTransitioning && !isFlightMode && !isDetailMode) {
        const controlsPanel = document.getElementById('controls-panel');
        const infoPanel = document.getElementById('info-panel');
        if (!e.target.closest('#controls-panel') && !e.target.closest('#btn-toggle-controls')) {
            if (controlsPanel.classList.contains('visible')) {
                controlsPanel.classList.remove('visible');
                infoPanel.style.display = 'block';
            }
        }
        if (!e.target.closest('#constellation-panel') && !e.target.closest('#btn-toggle-const')) {
            document.getElementById('constellation-panel').classList.remove('visible');
        }
    }
});

document.getElementById('btn-reset-view').onclick = resetView;

function setupUI() {
    const bind = (id, key, callback) => {
        const el = document.getElementById(id);
        if (!el) return;
        el.checked = settings[key];
        el.onchange = (e) => { settings[key] = e.target.checked; saveSettings(); applyVisibilitySettings(); if (callback) callback(); };
    };
    
      if (settings.controlsOpen) {
        document.getElementById('controls-panel').classList.add('visible');
       
        if (window.innerWidth <= 768) {
            document.getElementById('info-panel').style.display = 'none';
        }
    }

    bind('chk-grid', 'grid');
    bind('chk-stars', 'stars');
    bind('chk-lines', 'lines');
    bind('chk-const-names', 'constNames');
    bind('chk-star-names', 'starNames');
    bind('chk-planets', 'planets');
  bind('chk-traj', 'traj', () => {
        // –ï—Å–ª–∏ –≤—ã–∫–ª—é—á–∏–ª–∏ —Ç—Ä–∞–µ–∫—Ç–æ—Ä–∏–∏, —Å—Ä–∞–∑—É —É–±–∏—Ä–∞–µ–º –ª–∏–Ω–∏—é –Ω–∞–≤–µ–¥–µ–Ω–∏—è
        if (!settings.traj && hoverTrajectory) {
            scene.remove(hoverTrajectory);
            hoverTrajectory = null;
        }
    });
    bind('chk-iss', 'iss', async () => { await updateISS(); if (settings.iss && issPosition) navigateToPosition(issPosition); });
    bind('chk-ground', 'ground');

    const magSlider = document.getElementById('magnitude-slider');
    const magValue = document.getElementById('magnitude-value');
    
    const updateMagnitudeDisplay = () => {
        if (!magSlider || !magValue) return;
        const val = parseFloat(magSlider.value);
        const min = parseFloat(magSlider.min);
        const max = parseFloat(magSlider.max);
        const percent = (val - min) / (max - min) * 100;
        magValue.textContent = val.toFixed(1) + 'm';
        magValue.style.left = `calc(${percent}% + ${(50 - percent) * 0.18}px)`;
    };

    if (magSlider) {
        magSlider.value = settings.maxMagnitude;
        updateMagnitudeDisplay();
        
        magSlider.oninput = (e) => {
            settings.maxMagnitude = parseFloat(e.target.value);
            filterStarsByMagnitude(settings.maxMagnitude);
            updateMagnitudeDisplay();
            saveSettings();
        };
    }

    document.getElementById('cam-out').onclick = () => {
        if (isTransitioning || !isInsideMode || isFlightMode || isDetailMode) return;
        startTransition('toOutside');
    };

    document.getElementById('cam-in').onclick = () => {
        if (isTransitioning || isInsideMode || isFlightMode || isDetailMode) return;
        startTransition('toInside');
    };
}

function onResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);

    if (detailRenderer) {
        detailRenderer.setSize(window.innerWidth, window.innerHeight);
        detailCamera.aspect = window.innerWidth / window.innerHeight;
        detailCamera.updateProjectionMatrix();
    }
}

// === –ì–õ–ê–í–ù–´–ô –¶–ò–ö–õ –ê–ù–ò–ú–ê–¶–ò–ò ===


function animate() {
    requestAnimationFrame(animate);
    starShaderTime += 0.016;

    if (isFallbackFlight) {
        updateFallbackFlight();
        renderer.render(scene, camera);
    } else if (isFlightMode) {
        updateFlight();
        renderer.render(scene, camera);
    } else if (isReturnFlight) {
        updateReturnFlight();
        renderer.render(scene, camera);
    } else if (isDetailMode) {
        // –ê–Ω–∏–º–∞—Ü–∏—è —à–µ–π–¥–µ—Ä–∞ –∑–≤–µ–∑–¥—ã
        if (starShaderMaterial) {
            starShaderMaterial.uniforms.uTime.value = starShaderTime;
        }
        
        // –ê–Ω–∏–º–∞—Ü–∏—è –∫–æ—Ä–æ–Ω—ã –∏ –ó–µ–º–ª–∏
        detailScene.traverse(obj => {
            if (obj.userData?.isCorona && obj.material?.uniforms) {
                obj.material.uniforms.uTime.value = starShaderTime;
            }
            if (obj.userData?.isEarth) {
                obj.rotation.y += 0.003;
            }
        });
        
        // –í—Ä–∞—â–µ–Ω–∏–µ –≥–ª–∞–≤–Ω–æ–≥–æ –æ–±—ä–µ–∫—Ç–∞ (—Ç–µ–ø–µ—Ä—å –≤—Ä–∞—â–∞–µ—Ç—Å—è –≤—Å–µ–≥–¥–∞, –≤–∫–ª—é—á–∞—è –õ—É–Ω—É)
        if (detailMainObject) {
            detailMainObject.rotation.y += 0.002;
            
            if (detailAtmosphere) detailAtmosphere.rotation.y += 0.0015;
            if (detailRing) detailRing.rotation.z += 0.0005;
        }
        
        // –í—Ä–∞—â–µ–Ω–∏–µ –°–æ–ª–Ω—Ü–∞ –¥–ª—è —Å—Ä–∞–≤–Ω–µ–Ω–∏—è —Ä–∞–∑–º–µ—Ä–æ–≤
        if (detailSunComparison) {
            detailSunComparison.rotation.y += 0.004;
        }
        
        detailControls.update();
        detailRenderer.render(detailScene, detailCamera);
        updateDetailLabels();
        
    } else {
        if (isTransitioning) updateTransition();
        if (cameraAnimation) cameraAnimation();
        if (constellationAnimation) constellationAnimation();
        if (!isInsideMode && !isTransitioning) controls.update();
        groups.iss.children.forEach(c => { if (c.type === 'Group') c.rotation.z += 0.008; });
        renderer.render(scene, camera);
    }
}

// === –ó–ê–ü–£–°–ö ===
init();
</script>
</body>
</html>

