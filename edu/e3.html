<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Deep Space Warp</title>
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            background-color: #000; 
            font-family: 'Segoe UI', sans-serif; 
            user-select: none; /* Чтобы текст не выделялся при вращении */
        }
        canvas { display: block; }
        
        #hud {
            position: fixed;
            bottom: 20px;
            left: 20px;
            color: rgba(255, 255, 255, 0.8);
            pointer-events: none;
        }
        #speedVal {
            font-size: 24px;
            font-weight: bold;
            color: #4da6ff;
        }
        .hint {
            font-size: 12px;
            color: #888;
            margin-top: 5px;
        }
    </style>
</head>
<body>

    <div id="hud">
        <div id="speedVal">0 km/s</div>
        <div class="hint">Колесо мыши: Скорость</div>
        <div class="hint">ЛКМ + Драг: Обзор 360°</div>
    </div>

    <!-- Подключаем Three.js -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';

        // --- 1. НАСТРОЙКА СЦЕНЫ ---
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 100000);
        
        // Камера в центре (0,0,0)
        camera.position.set(0, 0, 0);
        // Смотрим изначально вперед (-Z)
        camera.rotation.order = 'YXZ'; // Важно для корректного вращения головой

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // --- 2. ФОН (ГАЛАКТИКА) ---
        const bgGeo = new THREE.SphereGeometry(10000, 64, 64);
        const textureLoader = new THREE.TextureLoader();
        
        // Загружаем вашу текстуру
        const bgTexture = textureLoader.load('textures/milkyway.jpg');
        
        const bgMat = new THREE.MeshBasicMaterial({
            map: bgTexture,
            side: THREE.BackSide, // Рисуем внутри шара
            depthWrite: false,    // Фон всегда позади всего
            fog: false
        });
        
        const skybox = new THREE.Mesh(bgGeo, bgMat);
        scene.add(skybox);


        // --- 3. ЗВЕЗДЫ (ТОЧКИ) ---
        const starCount = 15000;
        const starGeo = new THREE.BufferGeometry();
        const positions = new Float32Array(starCount * 3);
        const colors = new Float32Array(starCount * 3);
        const sizes = new Float32Array(starCount);

        const colorPalette = [
            new THREE.Color(0xffffff), // Белый
            new THREE.Color(0xccccff), // Голубоватый
            new THREE.Color(0xffddaa)  // Желтоватый
        ];

        // Зона появления звезд (туннель)
        const range = 4000; 

        for(let i = 0; i < starCount; i++) {
            // Случайная позиция в кубе
            positions[i*3] = (Math.random() - 0.5) * range;     // x
            positions[i*3+1] = (Math.random() - 0.5) * range;   // y
            positions[i*3+2] = (Math.random() - 0.5) * range;   // z

            // Случайный цвет
            const c = colorPalette[Math.floor(Math.random() * colorPalette.length)];
            colors[i*3] = c.r;
            colors[i*3+1] = c.g;
            colors[i*3+2] = c.b;

            // Случайный размер
            sizes[i] = Math.random() * 1.5;
        }

        starGeo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        starGeo.setAttribute('color', new THREE.BufferAttribute(colors, 3));
        starGeo.setAttribute('size', new THREE.BufferAttribute(sizes, 1));

        // Создаем текстуру для круглой точки программно (чтобы не грузить png)
        function createCircleTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 32; canvas.height = 32;
            const ctx = canvas.getContext('2d');
            const grad = ctx.createRadialGradient(16,16,0, 16,16,16);
            grad.addColorStop(0, 'rgba(255,255,255,1)');
            grad.addColorStop(0.5, 'rgba(255,255,255,0.8)');
            grad.addColorStop(1, 'rgba(255,255,255,0)');
            ctx.fillStyle = grad;
            ctx.fillRect(0,0,32,32);
            return new THREE.CanvasTexture(canvas);
        }

        const starMat = new THREE.PointsMaterial({
            size: 2, // Базовый размер
            vertexColors: true,
            map: createCircleTexture(),
            blending: THREE.AdditiveBlending,
            depthWrite: false,
            transparent: true,
            opacity: 0.9,
            sizeAttenuation: true // Звезды уменьшаются с расстоянием
        });

        const starSystem = new THREE.Points(starGeo, starMat);
        scene.add(starSystem);


        // --- 4. УПРАВЛЕНИЕ (СКОРОСТЬ И КАМЕРА) ---
        
        // Параметры
        let speed = 0;          // Текущая скорость
        let targetSpeed = 0;    // Целевая скорость (для плавности)
        const maxSpeed = 100;   // Максимальная скорость
        
        // Элементы интерфейса
        const uiSpeed = document.getElementById('speedVal');

        // Колесо мыши - СКОРОСТЬ
        document.addEventListener('wheel', (e) => {
            // e.deltaY > 0 (вниз) - тормозим/назад
            // e.deltaY < 0 (вверх) - ускоряемся
            targetSpeed -= e.deltaY * 0.05;
            
            // Ограничиваем скорость (можно сделать отрицательную для полета назад)
            if (targetSpeed > maxSpeed) targetSpeed = maxSpeed;
            if (targetSpeed < -20) targetSpeed = -20;
        });

        // Мышь - ВРАЩЕНИЕ КАМЕРЫ (Drag & Drop)
        let isDragging = false;
        let previousMousePosition = { x: 0, y: 0 };
        
        // Чувствительность мыши
        const sensitivity = 0.003;

        document.addEventListener('mousedown', (e) => {
            isDragging = true;
            previousMousePosition = { x: e.clientX, y: e.clientY };
            document.body.style.cursor = 'grabbing';
        });

        document.addEventListener('mouseup', () => {
            isDragging = false;
            document.body.style.cursor = 'default';
        });

        document.addEventListener('mousemove', (e) => {
            if (isDragging) {
                const deltaMove = {
                    x: e.clientX - previousMousePosition.x,
                    y: e.clientY - previousMousePosition.y
                };

                // Вращаем камеру
                // Y (yaw) - вращение вокруг оси Y (влево-вправо)
                camera.rotation.y -= deltaMove.x * sensitivity;
                // X (pitch) - вращение вокруг оси X (вверх-вниз)
                camera.rotation.x -= deltaMove.y * sensitivity;

                // Ограничим взгляд вверх/вниз, чтобы камера не перевернулась (опционально, но удобно)
                // camera.rotation.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, camera.rotation.x));

                previousMousePosition = { x: e.clientX, y: e.clientY };
            }
        });

        // --- 5. АНИМАЦИЯ ---
        function animate() {
            requestAnimationFrame(animate);

            // Плавное изменение скорости
            speed += (targetSpeed - speed) * 0.1;
            
            // Обновляем текст скорости
            let displaySpeed = Math.abs(speed);
            let unit = "km/s";
            if(displaySpeed > 10) { displaySpeed /= 10; unit = "c (Light Speed)"; }
            if(displaySpeed > 10) { unit = "WARP"; }
            uiSpeed.innerText = speed.toFixed(1) + " " + unit;
            uiSpeed.style.color = speed >= 0 ? '#4da6ff' : '#ff4d4d'; // Красный если летим назад

            // Движение звезд
            // Звезды движутся по оси Z навстречу камере (если скорость положительная)
            const posAttr = starSystem.geometry.attributes.position;
            const positions = posAttr.array;
            
            // Границы для сброса звезд
            const boundary = range / 2;

            for(let i = 0; i < starCount; i++) {
                // Двигаем только Z координату
                // speed * 5 - коэффициент для визуальной скорости
                positions[i*3 + 2] += speed * 5; 

                // Проверка границ (бесконечный туннель)
                
                // Если звезда улетела за спину (Z слишком большой)
                if (positions[i*3 + 2] > boundary) {
                    positions[i*3 + 2] -= range; // Перекидываем далеко вперед
                    
                    // Перегенерируем X и Y для разнообразия
                    positions[i*3] = (Math.random() - 0.5) * range;
                    positions[i*3+1] = (Math.random() - 0.5) * range;
                }
                
                // Если летим назад и звезда улетела слишком далеко вперед
                if (positions[i*3 + 2] < -boundary) {
                    positions[i*3 + 2] += range;
                }
            }
            
            posAttr.needsUpdate = true;

            // Медленное вращение галактики для красоты (независимо от звезд)
            skybox.rotation.y += 0.0001;

            renderer.render(scene, camera);
        }

        // Адаптация под размер окна
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();

    </script>
</body>
</html>