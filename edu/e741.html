<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no, maximum-scale=1.0" />
  <title>Космический Симулятор</title>
  
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&family=Jura:wght@400;500;600;700&display=swap" rel="stylesheet">

  <style>
    :root {
      --bg-color: #000000;
      --panel-bg: rgba(12, 12, 18, 0.75);
      --panel-border: rgba(255, 255, 255, 0.15);
      --text-main: #f0f0f0;
      --text-sec: #94a3b8;
      --accent: #38bdf8;
      --btn-bg: rgba(255, 255, 255, 0.08);
      --btn-hover: rgba(255, 255, 255, 0.2);
      --font-display: 'Jura', sans-serif;
      --font-body: 'Inter', sans-serif;
    }

    * { margin: 0; padding: 0; box-sizing: border-box; -webkit-tap-highlight-color: transparent; }

    html, body {
      width: 100%; height: 100%; overflow: hidden;
      background: var(--bg-color);
      font-family: var(--font-body);
      color: var(--text-main);
    }

    canvas { display: block; outline: none; }

    /* UI Layer */
    #ui-layer {
      position: absolute; inset: 0; pointer-events: none;
      display: flex; flex-direction: column; justify-content: space-between;
      padding: 24px; z-index: 10;
    }

    /* Top Bar */
    .top-bar {
      pointer-events: auto;
      display: flex; justify-content: space-between; align-items: flex-start;
    }

    .app-title h1 {
      font-family: var(--font-display); font-weight: 700; font-size: 26px;
      letter-spacing: 2px; text-transform: uppercase;
      text-shadow: 0 0 15px rgba(56, 189, 248, 0.5);
      margin-bottom: 4px;
    }
    .app-title span { font-size: 11px; color: var(--accent); letter-spacing: 4px; text-transform: uppercase; font-weight: 700; }

    /* Controls (Top Right) */
    .controls-top {
      display: flex; gap: 10px;
    }

    .toggle-btn {
      background: var(--panel-bg); border: 1px solid var(--panel-border);
      color: var(--text-sec); padding: 8px 16px; border-radius: 20px;
      font-size: 12px; font-weight: 600; cursor: pointer;
      backdrop-filter: blur(10px); transition: all 0.3s;
      display: flex; align-items: center; gap: 6px;
    }
    .toggle-btn:hover { background: var(--btn-hover); color: white; }
    .toggle-btn.active { border-color: var(--accent); color: var(--accent); background: rgba(56, 189, 248, 0.1); }
    .toggle-btn::before {
      content: ''; width: 8px; height: 8px; border-radius: 50%;
      background: currentColor; box-shadow: 0 0 8px currentColor;
    }

    /* Bottom Dock */
    .dock-container {
      pointer-events: auto;
      align-self: center; width: 100%; max-width: 900px;
      display: flex; justify-content: center;
    }

    .dock {
      background: var(--panel-bg);
      backdrop-filter: blur(20px); -webkit-backdrop-filter: blur(20px);
      border: 1px solid var(--panel-border);
      padding: 12px 20px; border-radius: 24px;
      display: flex; gap: 16px; align-items: center;
      box-shadow: 0 10px 40px rgba(0,0,0,0.5);
      transition: all 0.3s ease;
    }

    .btn-icon {
      width: 44px; height: 44px; flex-shrink: 0;
      border-radius: 14px; background: var(--btn-bg);
      border: 1px solid var(--panel-border); color: white;
      display: flex; align-items: center; justify-content: center;
      cursor: pointer; transition: 0.3s;
    }
    .btn-icon:hover { background: var(--accent); border-color: var(--accent); box-shadow: 0 0 15px var(--accent); }
    .btn-icon svg { width: 22px; height: 22px; stroke-width: 2; }

    .divider { width: 1px; height: 32px; background: rgba(255,255,255,0.15); }

    .planet-scroll {
      display: flex; gap: 8px; overflow-x: auto; padding: 4px;
      -ms-overflow-style: none; scrollbar-width: none;
      mask-image: linear-gradient(90deg, transparent, black 20px, black calc(100% - 20px), transparent);
      -webkit-mask-image: linear-gradient(90deg, transparent, black 20px, black calc(100% - 20px), transparent);
    }
    .planet-scroll::-webkit-scrollbar { display: none; }

    .chip {
      padding: 10px 20px; border-radius: 12px;
      background: var(--btn-bg); color: var(--text-sec);
      font-family: var(--font-display); font-size: 13px; font-weight: 600;
      cursor: pointer; white-space: nowrap; border: 1px solid transparent;
      transition: all 0.2s; user-select: none;
    }
    .chip:hover { background: var(--btn-hover); color: white; transform: translateY(-2px); }
    .chip.active {
      background: rgba(56, 189, 248, 0.2); color: var(--accent);
      border-color: rgba(56, 189, 248, 0.5);
      box-shadow: 0 4px 15px rgba(56, 189, 248, 0.2);
    }

    /* Modal */
    .modal {
      position: fixed; inset: 0; z-index: 100;
      background: rgba(0,0,0,0.6); backdrop-filter: blur(8px);
      opacity: 0; visibility: hidden; transition: 0.3s;
      display: flex; align-items: center; justify-content: center;
    }
    .modal.visible { opacity: 1; visibility: visible; }
    
    .card {
      width: 90%; max-width: 420px;
      background: rgba(10, 12, 20, 0.95); border: 1px solid var(--panel-border);
      border-radius: 28px; padding: 36px; position: relative;
      color: white; box-shadow: 0 20px 60px rgba(0,0,0,0.8);
      transform: translateY(30px) scale(0.95); transition: 0.4s cubic-bezier(0.19, 1, 0.22, 1);
    }
    .modal.visible .card { transform: translateY(0) scale(1); }
    
    .close-btn {
      position: absolute; top: 20px; right: 20px; width: 36px; height: 36px;
      background: rgba(255,255,255,0.05); border: none; border-radius: 50%; color: var(--text-sec);
      cursor: pointer; display: flex; align-items: center; justify-content: center; transition: 0.2s;
    }
    .close-btn:hover { background: rgba(255,255,255,0.15); color: white; }

    @media (max-width: 768px) {
      .planet-scroll { max-width: 100%; mask-image: none; -webkit-mask-image: none; }
      .dock { flex-direction: column-reverse; width: 100%; border-radius: 24px; padding: 16px; gap: 12px; }
      .divider { display: none; }
      .btn-icon { width: 100%; height: 48px; border-radius: 12px; }
      .top-bar { margin-bottom: 20px; }
      #ui-layer { padding: 16px; }
    }
  </style>
</head>
<body>

  <div id="ui-layer">
    <div class="top-bar">
      <div class="app-title">
        <h1>Cosmos</h1>
        <span>Interactive Model</span>
      </div>
      <div class="controls-top">
        <button class="toggle-btn active" id="btnMilkyWay" onclick="toggleBackground()">Галактика</button>
      </div>
    </div>

    <div class="dock-container">
      <div class="dock">
        <button class="btn-icon" onclick="clearAll()" title="Сбросить (Только Солнце)">
          <!-- Иконка Солнца -->
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor">
            <circle cx="12" cy="12" r="4"></circle>
            <path d="M12 2v2"></path><path d="M12 20v2"></path>
            <path d="M4.93 4.93l1.41 1.41"></path><path d="M17.66 17.66l1.41 1.41"></path>
            <path d="M2 12h2"></path><path d="M20 12h2"></path>
            <path d="M6.34 17.66l-1.41 1.41"></path><path d="M19.07 4.93l-1.41 1.41"></path>
          </svg>
        </button>
        <div class="divider"></div>
        <div class="planet-scroll" id="planetBtns"></div>
      </div>
    </div>
  </div>

  <div class="modal" id="modal">
    <div class="card">
      <button class="close-btn" onclick="closeModal()">×</button>
      <h2 id="mTitle" style="font-family:var(--font-display); font-size:36px; margin-bottom:6px">Планета</h2>
      <div id="mType" style="color:var(--accent); font-size:11px; letter-spacing:3px; text-transform:uppercase; font-weight:700; margin-bottom:24px">Тип</div>
      <div id="mStats" style="display:grid; grid-template-columns:1fr 1fr; gap:20px; margin-bottom:24px"></div>
      <p id="mFact" style="font-size:14px; line-height:1.7; color:rgba(255,255,255,0.7); border-top:1px solid rgba(255,255,255,0.1); padding-top:20px"></p>
    </div>
  </div>

  <script type="importmap">
    { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js", "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/" } }
  </script>

  <script type="module">
    import * as THREE from "three";
    import { OrbitControls } from "three/addons/controls/OrbitControls.js";
    import { UnrealBloomPass } from "three/addons/postprocessing/UnrealBloomPass.js";
    import { EffectComposer } from "three/addons/postprocessing/EffectComposer.js";
    import { RenderPass } from "three/addons/postprocessing/RenderPass.js";

    // --- CONFIGURATION ---
    const PLANETS = {
      Солнце: { order: 0, radius: 25000, type: 'Звезда', info: { mass: '1.98 × 10³⁰ кг', temp: '5500°C', dist: '0 км' }, fact: 'Звезда, дающая жизнь. Центр системы. Занимает 99.8% всей массы системы.', isSun: true },
      Меркурий: { order: 1, radius: 2439, tex: 'textures/mercury2.jpg', bump: 'textures/mercury2.jpg', distAU: 0.39, info: { mass: '3.3 × 10²³ кг', temp: '+427°C', dist: '58 млн км' }, fact: 'Самая быстрая планета. У него нет атмосферы, чтобы удерживать тепло.', type: 'Земная группа' },
      Венера: { order: 2, radius: 6051, tex: 'textures/venus.jpg', bump: 'textures/venus.jpg', glow: 0xffaa55, distAU: 0.72, info: { mass: '4.9 × 10²⁴ кг', temp: '+462°C', dist: '108 млн км' }, fact: 'Самая горячая планета из-за парникового эффекта. Вращается по часовой стрелке.', type: 'Земная группа' },
      Земля: { order: 3, radius: 6371, tex: 'textures/earth-blue-marble.jpg', spec: 'textures/earth2.jpg', glow: 0x4488ff, distAU: 1.0, info: { mass: '5.9 × 10²⁴ кг', temp: '+15°C', dist: '150 млн км' }, fact: 'Единственная планета с жидкой водой на поверхности и жизнью.', type: 'Земная группа' },
      Марс: { order: 4, radius: 3389, tex: 'textures/mars.jpg', bump: 'textures/mars2.jpg', glow: 0xff4422, distAU: 1.52, info: { mass: '6.4 × 10²³ кг', temp: '-60°C', dist: '228 млн км' }, fact: 'Красный цвет из-за оксида железа (ржавчины). Здесь находится гора Олимп (21 км).', type: 'Земная группа' },
      Юпитер: { order: 5, radius: 69911, tex: 'textures/jupiter.jpg', glow: 0xeebb99, distAU: 5.2, info: { mass: '1.9 × 10²⁷ кг', temp: '-108°C', dist: '778 млн км' }, fact: 'Газовый гигант. Больше всех остальных планет вместе взятых в 2.5 раза.', type: 'Газовый гигант' },
      Сатурн: { order: 6, radius: 58232, tex: 'textures/saturn.jpg', ring: { tex: 'textures/saturn2.png', inner: 1.3, outer: 2.3 }, glow: 0xeeddcc, distAU: 9.58, info: { mass: '5.7 × 10²⁶ кг', temp: '-139°C', dist: '1.4 млрд км' }, fact: 'Имеет самую сложную систему колец из льда и пыли.', type: 'Газовый гигант' },
      Уран: { order: 7, radius: 25362, tex: 'textures/uranus.jpg', glow: 0x88ffff, distAU: 19.22, info: { mass: '8.7 × 10²⁵ кг', temp: '-197°C', dist: '2.9 млрд км' }, fact: 'Вращается лежа на боку (наклон оси 98°).', type: 'Ледяной гигант' },
      Нептун: { order: 8, radius: 24622, tex: 'textures/neptune.jpg', glow: 0x3355ff, distAU: 30.05, info: { mass: '1.0 × 10²⁶ кг', temp: '-201°C', dist: '4.5 млрд км' }, fact: 'Ветры здесь дуют со скоростью 2100 км/ч — быстрее скорости звука.', type: 'Ледяной гигант' },
      Плутон: { order: 9, radius: 1188, tex: 'textures/pluto.jpg', bump: 'textures/pluto.jpg', distAU: 39.48, info: { mass: '1.3 × 10²² кг', temp: '-223°C', dist: '5.9 млрд км' }, fact: 'Карликовая планета с большим сердцем из азотного льда.', type: 'Карликовая планета' }
    };

    const BASE_SCALE = 1 / 4000;
    const AU_SCALE = 150; // Масштаб расстояния (1 а.е. = 150 единиц сцены)

    // --- SCENE SETUP ---
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 300000);
    
    const renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.3; // Чуть ярче
    document.body.appendChild(renderer.domElement);

    // --- TEXTURES ---
    const texLoader = new THREE.TextureLoader();

    // --- BACKGROUNDS (LOCAL FILES) ---
    // Milky Way Sphere
    const bgGeo = new THREE.SphereGeometry(100000, 64, 64);
    const bgMat = new THREE.MeshBasicMaterial({
        map: texLoader.load('textures/milkyway.jpg'), // LOCAL
        side: THREE.BackSide,
        transparent: true,
        opacity: 0.8
    });
    const skybox = new THREE.Mesh(bgGeo, bgMat);
    scene.add(skybox);

    // Andromeda Sprite (Local)
    const galaxyTex = texLoader.load('textures/andromeda.jpg'); // LOCAL
    const galaxyMat = new THREE.SpriteMaterial({ 
        map: galaxyTex, 
        transparent: true, 
        opacity: 0.9,
        blending: THREE.AdditiveBlending 
    });
    const andromeda = new THREE.Sprite(galaxyMat);
    andromeda.scale.set(15000, 7500, 1);
    andromeda.position.set(20000, 8000, -40000); // Далеко на фоне
    scene.add(andromeda);

    // Stars (Procedural)
    function createStars() {
      const count = 5000;
      const geo = new THREE.BufferGeometry();
      const pos = new Float32Array(count * 3);
      for(let i=0; i<count; i++) {
        const r = 20000 + Math.random() * 20000;
        const theta = Math.random() * Math.PI * 2;
        const phi = Math.acos(2 * Math.random() - 1);
        pos[i*3] = r * Math.sin(phi) * Math.cos(theta);
        pos[i*3+1] = r * Math.cos(phi);
        pos[i*3+2] = r * Math.sin(phi) * Math.sin(theta);
      }
      geo.setAttribute('position', new THREE.BufferAttribute(pos, 3));
      const mat = new THREE.PointsMaterial({ color: 0xffffff, size: 1.5, transparent: true, opacity: 0.8 });
      return new THREE.Points(geo, mat);
    }
    const starField = createStars();
    scene.add(starField);

    // --- LIGHTS ---
    // Основной свет от Солнца
    const sunLight = new THREE.PointLight(0xffffff, 3.5, 0, 1);
    scene.add(sunLight);
    
    // Заполняющий свет (чтобы тени не были черными)
    const ambiLight = new THREE.AmbientLight(0xffffff, 0.1); 
    scene.add(ambiLight);
    const hemiLight = new THREE.HemisphereLight(0x0f0e0d, 0x000000, 0.3);
    scene.add(hemiLight);

    // --- POST PROCESSING (BLOOM) ---
    const composer = new EffectComposer(renderer);
    composer.addPass(new RenderPass(scene, camera));
    const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.2, 0.4, 0.9);
    composer.addPass(bloomPass);

    // --- CONTROLS ---
    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true; 
    controls.dampingFactor = 0.05;
    controls.enablePan = false; 
    controls.zoomSpeed = 0.4;
    controls.minDistance = 20; 
    controls.maxDistance = 25000; // Ограничение чтобы не улетать в бесконечность

    // --- SUN SHADER (Procedural Lava) ---
    const sunMat = new THREE.ShaderMaterial({
        uniforms: { time: { value: 0 } },
        vertexShader: `
          varying vec2 vUv;
          varying vec3 vNormal;
          void main() {
            vUv = uv; vNormal = normalize(normalMatrix * normal);
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
          }
        `,
        fragmentShader: `
          uniform float time;
          varying vec2 vUv;
          float noise(vec3 p) {
            vec3 i = floor(p); vec3 f = fract(p); f = f*f*(3.0-2.0*f);
            return mix(mix(mix(fract(sin(dot(i, vec3(1, 57, 113))) * 43758.5453),
                               fract(sin(dot(i + vec3(1, 0, 0), vec3(1, 57, 113))) * 43758.5453), f.x),
                           mix(fract(sin(dot(i + vec3(0, 1, 0), vec3(1, 57, 113))) * 43758.5453),
                               fract(sin(dot(i + vec3(1, 1, 0), vec3(1, 57, 113))) * 43758.5453), f.x), f.y),
                       mix(mix(fract(sin(dot(i + vec3(0, 0, 1), vec3(1, 57, 113))) * 43758.5453),
                               fract(sin(dot(i + vec3(1, 0, 1), vec3(1, 57, 113))) * 43758.5453), f.x),
                           mix(fract(sin(dot(i + vec3(0, 1, 1), vec3(1, 57, 113))) * 43758.5453),
                               fract(sin(dot(i + vec3(1, 1, 1), vec3(1, 57, 113))) * 43758.5453), f.x), f.y), f.z);
          }
          void main() {
            float n = noise(vec3(vUv * 8.0, time * 0.15)) * 0.5 + noise(vec3(vUv * 16.0, time * 0.4)) * 0.25;
            vec3 color = mix(vec3(1.0, 0.35, 0.0), vec3(1.0, 0.8, 0.2), n + 0.3);
            gl_FragColor = vec4(color * 1.5, 1.0);
          }
        `
    });

    // --- PLANET CREATION SYSTEM ---
    const planetsGroup = new THREE.Group();
    scene.add(planetsGroup);
    let activePlanets = [];
    const addedKeys = new Set();

    function createPlanet(key) {
        const d = PLANETS[key];
        // Sun visual size vs Planet visual size
        let r = d.isSun ? 6.0 : d.radius * BASE_SCALE; 
        const grp = new THREE.Group();

        if (d.isSun) {
            // Sun Mesh
            const mesh = new THREE.Mesh(new THREE.SphereGeometry(r, 64, 64), sunMat);
            grp.add(mesh);
            // Corona (Glow Sprite)
            const sprite = new THREE.Sprite(new THREE.SpriteMaterial({
                map: createSunGlowTexture(),
                color: 0xffaa00, blending: THREE.AdditiveBlending
            }));
            sprite.scale.set(r*4.5, r*4.5, 1);
            grp.add(sprite);
            grp.userData.isSun = true;
        } else {
            // Planet Mesh
            const mat = new THREE.MeshPhongMaterial({ 
                map: texLoader.load(d.tex), 
                shininess: 5 
            });
            if(d.bump) { 
                mat.bumpMap = texLoader.load(d.bump); 
                mat.bumpScale = 0.03; 
            }
            if(d.spec) {
                mat.specularMap = texLoader.load(d.spec);
                mat.specular = new THREE.Color(0x333333);
            }

            const mesh = new THREE.Mesh(new THREE.SphereGeometry(r, 64, 64), mat);
            grp.add(mesh);

            // Atmosphere Glow
            if(d.glow) {
                const atmoMat = new THREE.ShaderMaterial({
                    uniforms: { 
                        c: { value: 0.4 }, p: { value: 5.0 }, 
                        glowColor: { value: new THREE.Color(d.glow) }, 
                        viewVector: { value: camera.position } 
                    },
                    vertexShader: `uniform vec3 viewVector; uniform float c; uniform float p; varying float intensity; void main() { vec3 vNormal = normalize( normalMatrix * normal ); vec3 vNormel = normalize( normalMatrix * viewVector ); intensity = pow( c - dot(vNormal, vNormel), p ); gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 ); }`,
                    fragmentShader: `uniform vec3 glowColor; varying float intensity; void main() { gl_FragColor = vec4( glowColor, intensity ); }`,
                    side: THREE.BackSide, blending: THREE.AdditiveBlending, transparent: true, depthWrite: false
                });
                const atmo = new THREE.Mesh(new THREE.SphereGeometry(r*1.12, 64, 64), atmoMat);
                grp.add(atmo);
                grp.userData.glowMesh = atmo;
            }

            // Rings
            if(d.ring) {
                const rg = new THREE.RingGeometry(r*d.ring.inner, r*d.ring.outer, 128);
                const pos = rg.attributes.position; const v3 = new THREE.Vector3();
                for(let i=0; i<pos.count; i++){
                    v3.fromBufferAttribute(pos, i);
                    rg.attributes.uv.setXY(i, 0.5+v3.x/(r*d.ring.outer*2), 0.5+v3.y/(r*d.ring.outer*2));
                }
                const rm = new THREE.MeshStandardMaterial({ 
                    map: texLoader.load(d.ring.tex), side: THREE.DoubleSide, transparent: true, opacity: 0.8 
                });
                const ring = new THREE.Mesh(rg, rm);
                ring.rotation.x = -Math.PI/2;
                grp.add(ring);
            }
        }
        grp.userData = { name: key, ...d };
        return grp;
    }

    function createSunGlowTexture() {
        const c = document.createElement('canvas'); c.width=64; c.height=64;
        const ctx = c.getContext('2d');
        const g = ctx.createRadialGradient(32,32,0,32,32,32);
        g.addColorStop(0, 'rgba(255, 200, 100, 1)');
        g.addColorStop(0.5, 'rgba(255, 120, 0, 0.3)');
        g.addColorStop(1, 'rgba(0,0,0,0)');
        ctx.fillStyle = g; ctx.fillRect(0,0,64,64);
        return new THREE.CanvasTexture(c);
    }

    // --- LOGIC: ORBITS vs COMPARISON ---
    let camTarget = new THREE.Vector3();

    function updatePositions() {
        const hasSun = activePlanets.some(p => p.userData.isSun);
        
        if (hasSun) {
            // РЕЖИМ ОРБИТ (Есть Солнце)
            sunLight.position.set(0, 0, 0); // Свет в центре
            activePlanets.forEach(p => {
                if(p.userData.isSun) {
                    p.userData.tx = 0;
                } else {
                    // Расстояние пропорционально AU
                    p.userData.tx = p.userData.distAU * AU_SCALE;
                }
            });
            // Камера смотрит на систему со стороны
            // Находим самую дальнюю планету, чтобы настроить камеру
            let maxDist = 0;
            activePlanets.forEach(p => { if(p.userData.tx > maxDist) maxDist = p.userData.tx; });
            camTarget.set(maxDist/2, maxDist*0.4, maxDist + 100);

        } else {
            // РЕЖИМ СРАВНЕНИЯ (Нет Солнца)
            sunLight.position.set(100, 50, 100); // Свет сбоку
            activePlanets.sort((a,b) => PLANETS[a.userData.name].order - PLANETS[b.userData.name].order);
            
            let x = 0;
            activePlanets.forEach((p, i) => {
                if (i > 0) {
                    const prev = activePlanets[i-1];
                    let r1 = prev.userData.isSun ? 6.0 : prev.userData.radius * BASE_SCALE;
                    if(prev.userData.ring) r1 *= 1.8;
                    let r2 = p.userData.isSun ? 6.0 : p.userData.radius * BASE_SCALE;
                    if(p.userData.ring) r2 *= 1.8;
                    x += r1 + r2 + 10;
                }
                p.userData.tx = x;
            });
            
            // Центрируем группу
            const totalW = x;
            activePlanets.forEach(p => p.userData.tx -= totalW/2);
            camTarget.set(0, 30, 80); // Близкий вид
        }
    }

    window.addPlanet = (k) => {
        if(addedKeys.has(k)) return;
        const p = createPlanet(k);
        // Анимация появления
        p.scale.set(0,0,0);
        planetsGroup.add(p); 
        activePlanets.push(p); 
        addedKeys.add(k);
        
        updatePositions(); 
        updateUI();
        
        // Elastic scale up
        let t=0; 
        function animIn(){ 
            t+=0.05; 
            const s = Math.min(t,1);
            const ease = 1 - Math.pow(1 - s, 3); // Cubic ease out
            p.scale.setScalar(ease);
            if(t<1) requestAnimationFrame(animIn); 
        } 
        animIn();
    };

    window.removePlanet = (k) => {
        const p = activePlanets.find(x => x.userData.name === k);
        if(!p) return;
        planetsGroup.remove(p); 
        activePlanets = activePlanets.filter(x=>x!==p); 
        addedKeys.delete(k);
        updatePositions(); 
        updateUI();
    };

    window.clearAll = () => {
        [...activePlanets].forEach(p => {
            if(p.userData.name !== 'Солнце') window.removePlanet(p.userData.name);
        });
        // Если солнца нет, добавляем его
        if(!addedKeys.has('Солнце')) window.addPlanet('Солнце');
    };

    // Toggle Background
    window.toggleBackground = () => {
        const btn = document.getElementById('btnMilkyWay');
        const isVisible = !skybox.visible;
        skybox.visible = isVisible;
        andromeda.visible = isVisible; // Также скрываем Андромеду
        starField.visible = isVisible; // И звезды
        
        if(isVisible) btn.classList.add('active');
        else btn.classList.remove('active');
    };

    // Build UI
    const box = document.getElementById('planetBtns');
    Object.keys(PLANETS).sort((a,b)=>PLANETS[a].order-PLANETS[b].order).forEach(k => {
        const b = document.createElement('div');
        b.className = 'chip'; b.textContent = k; b.dataset.p = k;
        b.onclick = () => addedKeys.has(k) ? window.removePlanet(k) : window.addPlanet(k);
        box.appendChild(b);
    });

    function updateUI() {
        document.querySelectorAll('.chip').forEach(c => 
            addedKeys.has(c.dataset.p) ? c.classList.add('active') : c.classList.remove('active')
        );
    }

    // Init Scene
    window.addPlanet('Солнце');
    window.addPlanet('Земля');
    camera.position.set(0, 40, 150);

    // --- LOOP ---
    function animate(time) {
        requestAnimationFrame(animate);
        const t = time * 0.001;

        // Smooth Camera Move
        if(controls.enabled) { // check if user isn't actively dragging too hard
             // Simple lerp for "Cinematic" feel when switching modes
             // Note: OrbitControls handles user interaction, this lerp brings it back/adjusts slightly
             // We only lerp if the target changed drastically
        }

        // Logic for planets movement
        activePlanets.forEach(p => {
            // Interpolate position
            p.position.x += (p.userData.tx - p.position.x) * 0.1;

            if(p.userData.isSun) {
                p.children[0].material.uniforms.time.value = t;
                p.children[0].rotation.y = t * 0.05;
            } else {
                p.children[0].rotation.y += 0.005;
                // Update Atmosphere shader to look at camera
                if(p.userData.glowMesh && p.userData.glowMesh.material.uniforms) {
                    p.userData.glowMesh.material.uniforms.viewVector.value = camera.position;
                }
            }
        });

        // Rotate Background slowly
        skybox.rotation.y = t * 0.005;

        controls.update();
        composer.render();
    }

    // --- INTERACTION ---
    const ray = new THREE.Raycaster();
    const m = new THREE.Vector2();
    
    window.addEventListener('dblclick', e => {
        // Calculate mouse pos
        m.x = (e.clientX/window.innerWidth)*2-1; 
        m.y = -(e.clientY/window.innerHeight)*2+1;
        
        ray.setFromCamera(m, camera);
        // Intersect recursive
        const hits = ray.intersectObjects(planetsGroup.children, true);
        
        if(hits.length) {
            let o = hits[0].object; 
            // Find parent group
            while(o.parent && o.parent!==planetsGroup) o=o.parent;
            
            const d = o.userData;
            document.getElementById('mTitle').textContent = d.name;
            document.getElementById('mType').textContent = d.type || 'Объект';
            document.getElementById('mStats').innerHTML = `
                <div><small style="color:#888; text-transform:uppercase">Масса</small><br>${d.info.mass}</div>
                <div><small style="color:#888; text-transform:uppercase">Температура</small><br>${d.info.temp}</div>
            `;
            document.getElementById('mFact').textContent = d.fact;
            document.getElementById('modal').classList.add('visible');
        }
    });
    
    window.closeModal = () => document.getElementById('modal').classList.remove('visible');

    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth/window.innerHeight; camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight); composer.setSize(window.innerWidth, window.innerHeight);
    });

    animate(0);
  </script>
</body>
</html>