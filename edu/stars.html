<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no, maximum-scale=1.0" />
  <title>Звёзды</title>

  <link rel="icon" href="sparkle.png" type="image/png" />
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&family=Jura:wght@400;500;600;700&display=swap" rel="stylesheet">

  <style>
    :root {
      --bg-color: #020206;
      --panel-bg: rgba(10, 10, 20, 0.85);
      --panel-border: rgba(255, 255, 255, 0.1);
      --text-main: #ffffff;
      --text-sec: #8899bb;
      --accent: #4da6ff;
      --accent-glow: rgba(77, 166, 255, 0.4);
      --accent-warm: #ffaa44;
      --accent-warm-glow: rgba(255, 170, 68, 0.4);
      --accent-hr: #ff66aa;
      --accent-hr-glow: rgba(255, 102, 170, 0.4);
      --btn-bg: rgba(255, 255, 255, 0.06);
      --btn-hover: rgba(255, 255, 255, 0.15);
      --font-display: 'Jura', sans-serif;
      --font-body: 'Inter', sans-serif;
    }

    [data-theme="light"] {
      --bg-color: #f0f4f8;
      --panel-bg: rgba(255, 255, 255, 0.9);
      --panel-border: rgba(0, 0, 0, 0.08);
      --text-main: #0f172a;
      --text-sec: #64748b;
      --accent: #2563eb;
      --accent-glow: rgba(37, 99, 235, 0.2);
      --btn-bg: rgba(0, 0, 0, 0.04);
      --btn-hover: rgba(0, 0, 0, 0.08);
    }

    * { margin: 0; padding: 0; box-sizing: border-box; -webkit-tap-highlight-color: transparent; }

    html, body {
      width: 100%; height: 100%; overflow: hidden;
      background: var(--bg-color);
      font-family: var(--font-body);
      color: var(--text-main);
      transition: background 0.5s ease, color 0.5s ease;
    }

    canvas { display: block; outline: none; z-index: 1; }

    #ui-layer {
      position: absolute; inset: 0; z-index: 10; pointer-events: none;
      display: flex; flex-direction: column; justify-content: space-between;
      padding: 20px;
    }

    .top-bar {
      pointer-events: auto;
      display: flex; justify-content: space-between; align-items: flex-start;
    }

    .app-title h1 {
      font-family: var(--font-display); font-weight: 700; font-size: 26px;
      letter-spacing: 3px; text-transform: uppercase;
      background: linear-gradient(135deg, #ffffff 0%, #88aaff 50%, #ffaa66 100%);
      -webkit-background-clip: text; -webkit-text-fill-color: transparent;
      background-clip: text;
    }
    .app-title span { 
      font-size: 10px; color: var(--accent); letter-spacing: 5px; 
      text-transform: uppercase; font-weight: 600; 
      display: block; margin-top: 2px;
    }
    .app-title { min-width: 200px; }
    .app-title h1, .app-title span { transition: opacity 0.2s ease, color 0.2s ease; }

    .controls-right { display: flex; gap: 10px; align-items: center; flex-wrap: wrap; justify-content: flex-end; }

    .icon-btn {
      width: 42px; height: 42px; border-radius: 50%;
      background: var(--panel-bg); border: 1px solid var(--panel-border);
      backdrop-filter: blur(12px); -webkit-backdrop-filter: blur(12px);
      display: flex; align-items: center; justify-content: center;
      cursor: pointer; color: var(--text-main);
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      box-shadow: 0 4px 20px rgba(0,0,0,0.2);
    }
    .icon-btn:hover { transform: scale(1.1); background: var(--btn-hover); color: var(--accent); }
    .icon-btn svg { width: 20px; height: 20px; fill: none; stroke: currentColor; stroke-width: 2; }
    .delete-btn:hover { 
      color: #ff5555; border-color: rgba(255, 85, 85, 0.3);
      box-shadow: 0 4px 20px rgba(255, 85, 85, 0.25);
    }

    .toggle-btn {
      height: 42px; padding: 0 16px; border-radius: 21px;
      background: var(--panel-bg); border: 1px solid var(--panel-border);
      color: var(--text-sec); font-family: var(--font-display);
      font-size: 11px; font-weight: 600; text-transform: uppercase; letter-spacing: 1px;
      cursor: pointer; display: flex; align-items: center; gap: 8px;
      backdrop-filter: blur(12px); transition: all 0.3s;
    }
    .toggle-btn:hover { background: var(--btn-hover); color: var(--text-main); }
    .toggle-btn svg { width: 16px; height: 16px; fill: none; stroke: currentColor; stroke-width: 2; }

    .scale-toggle.active { 
      border-color: var(--accent); color: var(--accent); 
      background: rgba(77, 166, 255, 0.1);
      box-shadow: 0 0 15px var(--accent-glow);
    }
    .scale-indicator { width: 8px; height: 8px; border-radius: 50%; background: currentColor; }

    .space-toggle.active { 
      border-color: var(--accent-warm); color: var(--accent-warm); 
      background: rgba(255, 170, 68, 0.1);
      box-shadow: 0 0 15px var(--accent-warm-glow);
    }

    .hr-toggle.active { 
      border-color: var(--accent-hr); color: var(--accent-hr); 
      background: rgba(255, 102, 170, 0.1);
      box-shadow: 0 0 15px var(--accent-hr-glow);
    }

    .bg-toggle.active { 
      border-color: #8866ff; color: #8866ff; 
      background: rgba(136, 102, 255, 0.1);
      box-shadow: 0 0 15px rgba(136, 102, 255, 0.3);
    }

    .temp-scale {
      pointer-events: auto;
      position: absolute; left: 20px; top: 50%; transform: translateY(-50%);
      background: var(--panel-bg); border: 1px solid var(--panel-border);
      border-radius: 16px; padding: 16px 12px;
      backdrop-filter: blur(16px); -webkit-backdrop-filter: blur(16px);
      box-shadow: 0 10px 40px rgba(0,0,0,0.3);
      width: 140px; transition: all 0.4s;
    }
    .temp-scale h3 {
      font-family: var(--font-display); font-size: 9px; 
      text-transform: uppercase; letter-spacing: 2px;
      color: var(--text-sec); margin-bottom: 12px; text-align: center;
    }
    .temp-bar {
      height: 220px; width: 20px; margin: 0 auto;
      border-radius: 10px; position: relative;
      background: linear-gradient(to top, 
        #FF3300 0%, #FF5500 15%, #FFAA33 30%, 
        #FFDDAA 45%, #FFFFFF 55%, #CCDEFF 70%, 
        #99BBFF 85%, #7799FF 100%);
      box-shadow: 0 0 15px rgba(255,150,100,0.3);
    }
    .temp-labels {
      position: absolute; left: 30px; top: 0; height: 100%;
      display: flex; flex-direction: column-reverse; justify-content: space-between;
      font-size: 9px; color: var(--text-sec); font-family: var(--font-display);
    }
    .temp-labels span { white-space: nowrap; }

    .dock-wrapper {
      pointer-events: auto;
      align-self: center; width: 100%; max-width: 1100px;
      display: flex; justify-content: center;
    }

    .dock {
      background: var(--panel-bg);
      backdrop-filter: blur(20px); -webkit-backdrop-filter: blur(20px);
      border: 1px solid var(--panel-border);
      padding: 10px 16px; border-radius: 24px;
      display: flex; gap: 12px; align-items: center;
      box-shadow: 0 20px 60px -10px rgba(0,0,0,0.4);
      transition: all 0.3s ease;
      max-width: 100%;
    }

    .reset-btn {
      width: 46px; height: 46px; flex-shrink: 0;
      border-radius: 14px; background: var(--btn-bg);
      border: 1px solid var(--panel-border); color: var(--text-sec);
      display: flex; align-items: center; justify-content: center;
      cursor: pointer; transition: all 0.3s;
    }
    .reset-btn:hover {
      background: linear-gradient(135deg, #4da6ff, #2563eb); 
      color: white; border-color: transparent;
      box-shadow: 0 0 25px rgba(77, 166, 255, 0.5);
      transform: translateY(-2px) rotate(90deg);
    }
    .reset-btn svg { width: 24px; height: 24px; stroke-width: 1.5; }

    .divider { width: 1px; height: 30px; background: var(--panel-border); margin: 0 2px; flex-shrink: 0; }

    .star-scroll {
      display: flex; gap: 6px; overflow-x: auto; padding: 4px;
      -ms-overflow-style: none; scrollbar-width: none; 
      scroll-behavior: smooth;
      flex: 1; min-width: 0;
    }
    .star-scroll::-webkit-scrollbar { display: none; }

    .chip {
      padding: 8px 12px; border-radius: 10px;
      background: var(--btn-bg); color: var(--text-sec);
      font-family: var(--font-display); font-size: 10px; font-weight: 600;
      cursor: pointer; white-space: nowrap; border: 1px solid transparent;
      transition: all 0.2s; user-select: none; letter-spacing: 0.3px;
      display: flex; align-items: center; gap: 5px;
      flex-shrink: 0;
    }
    .chip .color-dot {
      width: 6px; height: 6px; border-radius: 50%;
      box-shadow: 0 0 4px currentColor;
      flex-shrink: 0;
    }
    .chip:hover { background: var(--btn-hover); color: var(--text-main); transform: translateY(-2px); }
    .chip.active {
      background: rgba(77, 166, 255, 0.15); color: var(--accent);
      border-color: rgba(77, 166, 255, 0.4);
      box-shadow: 0 4px 15px var(--accent-glow);
    }

    .compare-panel {
      pointer-events: auto;
      position: absolute; right: 20px; top: 50%; transform: translateY(-50%);
      background: var(--panel-bg); border: 1px solid var(--panel-border);
      border-radius: 16px; padding: 16px;
      backdrop-filter: blur(16px); -webkit-backdrop-filter: blur(16px);
      box-shadow: 0 10px 40px rgba(0,0,0,0.3);
      width: 150px;
      transition: opacity 0.3s, visibility 0.3s;
    }
    .compare-panel.hidden { opacity: 0; visibility: hidden; pointer-events: none; }
    .compare-panel h3 {
      font-family: var(--font-display); font-size: 9px; 
      text-transform: uppercase; letter-spacing: 2px;
      color: var(--text-sec); margin-bottom: 10px; text-align: center;
    }
    .compare-btn {
      width: 100%; padding: 10px; margin-bottom: 8px;
      border-radius: 10px; border: 1px solid var(--panel-border);
      background: var(--btn-bg); color: var(--text-sec);
      font-family: var(--font-display); font-size: 10px;
      cursor: pointer; transition: all 0.3s; text-transform: uppercase;
      letter-spacing: 1px;
    }
    .compare-btn:last-child { margin-bottom: 0; }
    .compare-btn:hover { background: var(--btn-hover); color: var(--text-main); }
    .compare-btn.active {
      background: rgba(77, 166, 255, 0.15); color: var(--accent);
      border-color: var(--accent);
    }

    .space-info {
      pointer-events: auto;
      position: absolute; right: 20px; top: 50%; transform: translateY(-50%);
      background: var(--panel-bg); border: 1px solid var(--panel-border);
      border-radius: 16px; padding: 16px;
      backdrop-filter: blur(16px); -webkit-backdrop-filter: blur(16px);
      box-shadow: 0 10px 40px rgba(0,0,0,0.3);
      width: 180px;
      opacity: 0; visibility: hidden; transition: opacity 0.3s, visibility 0.3s;
    }
    .space-info.visible { opacity: 1; visibility: visible; }
    .space-info h3 {
      font-family: var(--font-display); font-size: 9px; 
      text-transform: uppercase; letter-spacing: 2px;
      color: var(--text-sec); margin-bottom: 10px; text-align: center;
    }
    .space-info p { font-size: 11px; color: var(--text-sec); line-height: 1.6; margin-bottom: 10px; }
    .space-info .legend { display: flex; flex-direction: column; gap: 6px; padding-top: 10px; border-top: 1px solid var(--panel-border); }
    .space-info .legend-item { display: flex; align-items: center; gap: 8px; font-size: 10px; color: var(--text-sec); }
    .space-info .legend-dot { width: 8px; height: 8px; border-radius: 50%; }

    /* HR Diagram Modal */
    .hr-modal {
      position: fixed; inset: 0; z-index: 100;
      background: rgba(0,0,0,0.85); backdrop-filter: blur(12px);
      opacity: 0; visibility: hidden; transition: all 0.4s;
      display: flex; align-items: center; justify-content: center;
      padding: 20px;
    }
    .hr-modal.visible { opacity: 1; visibility: visible; }

    .hr-container {
      width: 100%; max-width: 1000px; height: 90vh; max-height: 700px;
      background: linear-gradient(135deg, rgba(10, 10, 30, 0.95), rgba(5, 5, 20, 0.98));
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 24px; padding: 24px;
      box-shadow: 0 40px 100px -20px rgba(0,0,0,0.8);
      transform: translateY(30px) scale(0.95); 
      transition: all 0.5s cubic-bezier(0.19, 1, 0.22, 1);
      display: flex; flex-direction: column;
      position: relative;
    }
    .hr-modal.visible .hr-container { transform: translateY(0) scale(1); }

    .hr-header {
      display: flex; justify-content: space-between; align-items: center;
      margin-bottom: 16px; flex-shrink: 0;
    }
    .hr-header h2 {
      font-family: var(--font-display); font-size: 20px; font-weight: 600;
      background: linear-gradient(135deg, #ff66aa, #ffaa66);
      -webkit-background-clip: text; -webkit-text-fill-color: transparent;
      letter-spacing: 2px;
    }
    .hr-header .subtitle {
      font-size: 11px; color: var(--text-sec); margin-top: 2px;
      letter-spacing: 1px;
    }

    .hr-legend {
      display: flex; gap: 16px; flex-wrap: wrap;
      font-size: 10px; color: var(--text-sec);
    }
    .hr-legend-item { display: flex; align-items: center; gap: 6px; }
    .hr-legend-dot { width: 10px; height: 10px; border-radius: 50%; }
    .hr-legend-line { width: 20px; height: 3px; border-radius: 2px; }

    .hr-canvas-wrapper {
      flex: 1; position: relative; min-height: 0;
      background: rgba(0, 0, 0, 0.3);
      border-radius: 12px; overflow: hidden;
    }
    #hrCanvas { width: 100%; height: 100%; cursor: crosshair; }

    .hr-tooltip {
      position: absolute; pointer-events: none;
      background: rgba(10, 10, 30, 0.95);
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 10px; padding: 10px 14px;
      font-size: 11px; color: var(--text-main);
      box-shadow: 0 10px 30px rgba(0,0,0,0.5);
      opacity: 0; transition: opacity 0.2s;
      z-index: 10; max-width: 200px;
    }
    .hr-tooltip.visible { opacity: 1; }
    .hr-tooltip .star-name { font-family: var(--font-display); font-size: 14px; font-weight: 600; margin-bottom: 6px; }
    .hr-tooltip .star-type { color: var(--text-sec); font-size: 10px; margin-bottom: 8px; }
    .hr-tooltip .star-stats { display: grid; grid-template-columns: 1fr 1fr; gap: 4px 12px; }
    .hr-tooltip .stat-label { color: var(--text-sec); }
    .hr-tooltip .stat-value { color: var(--accent); font-weight: 500; }

    .close-hr {
      position: absolute; top: 16px; right: 16px; width: 40px; height: 40px;
      background: rgba(255,255,255,0.05); border: 1px solid rgba(255,255,255,0.1);
      border-radius: 50%; color: var(--text-sec);
      cursor: pointer; display: flex; align-items: center; justify-content: center; 
      transition: 0.3s; font-size: 20px;
    }
    .close-hr:hover { background: rgba(255,255,255,0.1); color: var(--text-main); transform: rotate(90deg); }

    /* Star Info Modal */
    .modal {
      position: fixed; inset: 0; z-index: 100;
      background: rgba(0,0,0,0.6); backdrop-filter: blur(8px);
      opacity: 0; visibility: hidden; transition: all 0.3s;
      display: flex; align-items: center; justify-content: center;
    }
    .modal.visible { opacity: 1; visibility: visible; }

    .card {
      width: 95%; max-width: 720px;
      background: var(--bg-color); color: var(--text-main);
      border: 1px solid var(--panel-border);
      border-radius: 28px; padding: 36px;
      box-shadow: 0 40px 100px -20px rgba(0,0,0,0.6);
      transform: translateY(30px) scale(0.95); 
      transition: all 0.5s cubic-bezier(0.19, 1, 0.22, 1);
      max-height: 90vh; overflow-y: auto; position: relative;
    }
    .modal.visible .card { transform: translateY(0) scale(1); }

    .card-header { display: flex; align-items: center; gap: 20px; margin-bottom: 24px; }
    .star-preview {
      width: 70px; height: 70px; border-radius: 50%;
      box-shadow: 0 0 40px var(--star-color, #ffaa44);
      flex-shrink: 0;
    }
    .card h2 { font-family: var(--font-display); font-size: 36px; margin-bottom: 4px; line-height: 1; font-weight: 500; }
    .card .type { color: var(--accent); font-size: 10px; text-transform: uppercase; letter-spacing: 2px; font-weight: 600; }
    .card .constellation { color: var(--text-sec); font-size: 11px; margin-top: 4px; }

    .stats { display: grid; grid-template-columns: repeat(4, 1fr); gap: 16px 12px; margin-bottom: 20px; }
    .stat h4 { font-size: 9px; text-transform: uppercase; color: var(--text-sec); margin-bottom: 3px; letter-spacing: 1px; }
    .stat p { font-family: var(--font-display); font-size: 13px; font-weight: 600; color: var(--text-main); }
    .stat span.sub { display: block; font-size: 10px; color: var(--text-sec); font-weight: 400; margin-top: 1px; }

    .fact { font-size: 13px; line-height: 1.7; color: var(--text-sec); padding-top: 20px; border-top: 1px solid var(--panel-border); }
    .close-modal {
      position: absolute; top: 20px; right: 20px; width: 34px; height: 34px;
      background: var(--btn-bg); border: none; border-radius: 50%; color: var(--text-sec);
      cursor: pointer; display: flex; align-items: center; justify-content: center; 
      transition: 0.2s; font-size: 18px;
    }
    .close-modal:hover { background: var(--btn-hover); color: var(--text-main); }

    .size-indicator {
      pointer-events: none;
      position: absolute; bottom: 100px; left: 50%; transform: translateX(-50%);
      background: var(--panel-bg); border: 1px solid var(--panel-border);
      padding: 8px 16px; border-radius: 20px;
      backdrop-filter: blur(12px);
      font-family: var(--font-display); font-size: 11px;
      color: var(--text-sec); letter-spacing: 1px;
      opacity: 0; transition: opacity 0.3s;
    }
    .size-indicator.visible { opacity: 1; pointer-events: auto; }

    @media (max-width: 900px) {
      .temp-scale, .compare-panel, .space-info { display: none; }
    }

    @media (max-width: 768px) {
      .dock { flex-direction: column-reverse; padding: 14px; width: 100%; border-radius: 20px; gap: 14px; }
      .dock-wrapper { max-width: 100%; }
      .star-scroll { width: 100%; justify-content: flex-start; }
      .divider { display: none; }
      .reset-btn { width: 100%; height: 48px; border-radius: 12px; }
      .top-bar { margin-bottom: 16px; }
      #ui-layer { padding: 14px; }
      .card h2 { font-size: 28px; }
      .stats { grid-template-columns: repeat(2, 1fr); }
      .toggle-btn span { display: none; }
      .hr-container { padding: 16px; border-radius: 16px; }
      .hr-header h2 { font-size: 16px; }
      .hr-legend { display: none; }
    }

    @media (max-width: 500px) {
      .card { 
        padding: 20px; width: 100%; border-radius: 20px 20px 0 0; 
        position: absolute; bottom: 0; top: auto; transform: translateY(100%); 
      }
      .modal.visible .card { transform: translateY(0); }
      .stats { grid-template-columns: 1fr 1fr; }
    }
  </style>
</head>
<body data-theme="dark">

  <div id="ui-layer">
    <div class="top-bar">
      <div class="app-title">
        <h1>Звёзды</h1>
        <span>нашей Галактики</span>
      </div>
      
      <div class="controls-right">
        <button class="toggle-btn bg-toggle" id="btnBgToggle" onclick="toggleBackground()" title="Переключить фон">
          <svg viewBox="0 0 24 24">
            <circle cx="12" cy="12" r="10"></circle>
            <path d="M12 2a10 10 0 0 1 0 20" fill="currentColor" opacity="0.3"></path>
          </svg>
          <span>Фон</span>
        </button>

        <button class="toggle-btn hr-toggle" id="btnHRDiagram" onclick="toggleHRDiagram()" title="Диаграмма Герцшпрунга-Рассела">
          <svg viewBox="0 0 24 24">
            <path d="M3 3v18h18"></path>
            <circle cx="8" cy="16" r="2"></circle>
            <circle cx="12" cy="10" r="2"></circle>
            <circle cx="17" cy="6" r="2"></circle>
            <path d="M6 18L8 16L12 10L17 6" stroke-dasharray="2 2"></path>
          </svg>
          <span>Диаграмма Г-Р</span>
        </button>

        <button class="toggle-btn space-toggle" id="btnSpaceView" onclick="toggleSpaceView()" title="Показать в пространстве">
          <svg viewBox="0 0 24 24">
            <circle cx="12" cy="12" r="2"></circle>
            <circle cx="12" cy="12" r="6" stroke-dasharray="2 2"></circle>
            <circle cx="12" cy="12" r="10" stroke-dasharray="3 3"></circle>
          </svg>
          <span>В пространстве</span>
        </button>

        <button class="toggle-btn scale-toggle active" id="btnRealScale" onclick="toggleRealScale()" title="Реальный масштаб">
          <div class="scale-indicator"></div>
          <span>Масштаб</span>
        </button>

        <button class="icon-btn theme-btn" onclick="toggleTheme()" title="Сменить тему">
          <svg class="icon-moon" viewBox="0 0 24 24" style="display:block"><path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path></svg>
          <svg class="icon-sun" viewBox="0 0 24 24" style="display:none"><circle cx="12" cy="12" r="5"></circle><line x1="12" y1="1" x2="12" y2="3"></line><line x1="12" y1="21" x2="12" y2="23"></line><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line><line x1="1" y1="12" x2="3" y2="12"></line><line x1="21" y1="12" x2="23" y2="12"></line><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line></svg>
        </button>

        <button class="icon-btn delete-btn" onclick="clearCache()" title="Очистить кэш">
          <svg viewBox="0 0 24 24">
            <ellipse cx="12" cy="5" rx="9" ry="3"></ellipse>
            <path d="M21 12c0 1.66-4 3-9 3s-9-1.34-9-3"></path>
            <path d="M3 5v14c0 1.66 4 3 9 3 1.2 0 2.33-.08 3.39-.23"></path>
            <line x1="21" y1="21" x2="17" y2="17" stroke-width="2.5"></line>
            <line x1="17" y1="21" x2="21" y2="17" stroke-width="2.5"></line>
          </svg>
        </button>
      </div>
    </div>

    <div class="temp-scale">
      <h3>Температура</h3>
      <div style="position: relative;">
        <div class="temp-bar"></div>
        <div class="temp-labels">
          <span>2 000 K</span>
          <span>5 000 K</span>
          <span>10 000 K</span>
          <span>20 000 K</span>
          <span>50 000 K</span>
        </div>
      </div>
    </div>

    <div class="compare-panel" id="comparePanel">
      <h3>Сравнение</h3>
      <button class="compare-btn active" data-mode="size" onclick="setCompareMode('size')">По размеру</button>
      <button class="compare-btn" data-mode="luminosity" onclick="setCompareMode('luminosity')">По светимости</button>
      <button class="compare-btn" data-mode="mass" onclick="setCompareMode('mass')">По массе</button>
      <button class="compare-btn" data-mode="temp" onclick="setCompareMode('temp')">По температуре</button>
    </div>

    <div class="space-info" id="spaceInfo">
      <h3>3D Карта</h3>
      <p>Звёзды расположены по реальным галактическим координатам относительно Солнца.</p>
      <p style="font-size: 10px; color: var(--accent);">Масштаб сжат для далёких звёзд</p>
      <div class="legend">
        <div class="legend-item">
          <div class="legend-dot" style="background: #FFF5E0;"></div>
          <span>Солнце (центр)</span>
        </div>
        <div class="legend-item">
          <div class="legend-dot" style="background: #4da6ff;"></div>
          <span>Ближние (&lt;50 св.лет)</span>
        </div>
        <div class="legend-item">
          <div class="legend-dot" style="background: #FF6B4A;"></div>
          <span>Дальние (&gt;500 св.лет)</span>
        </div>
      </div>
    </div>

    <div class="size-indicator" id="sizeIndicator">
      <span id="sizeText">Солнце = 1</span>
    </div>

    <div class="dock-wrapper">
      <div class="dock">
        <button class="reset-btn" onclick="clearAll()" title="Сбросить всё">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor">
            <path d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z"></path>
          </svg>
        </button>
        <div class="divider"></div>
        <div class="star-scroll" id="starBtns"></div>
      </div>
    </div>
  </div>

  <!-- HR Diagram Modal -->
  <div class="hr-modal" id="hrModal">
    <div class="hr-container">
      <button class="close-hr" onclick="toggleHRDiagram()">×</button>
      <div class="hr-header">
        <div>
          <h2>Диаграмма Герцшпрунга-Рассела</h2>
          <div class="subtitle">Классификация звёзд по температуре и светимости</div>
        </div>
        <div class="hr-legend">
          <div class="hr-legend-item">
            <div class="hr-legend-line" style="background: linear-gradient(90deg, #7799FF, #FFAA33, #FF3300);"></div>
            <span>Главная последовательность</span>
          </div>
          <div class="hr-legend-item">
            <div class="hr-legend-dot" style="background: #FF6644; box-shadow: 0 0 8px #FF6644;"></div>
            <span>Гиганты</span>
          </div>
          <div class="hr-legend-item">
            <div class="hr-legend-dot" style="background: #AACCFF; box-shadow: 0 0 8px #AACCFF;"></div>
            <span>Сверхгиганты</span>
          </div>
        </div>
      </div>
      <div class="hr-canvas-wrapper">
        <canvas id="hrCanvas"></canvas>
        <div class="hr-tooltip" id="hrTooltip">
          <div class="star-name">Название</div>
          <div class="star-type">Тип звезды</div>
          <div class="star-stats">
            <span class="stat-label">Темп:</span><span class="stat-value">5778 K</span>
            <span class="stat-label">Светим:</span><span class="stat-value">1 L☉</span>
            <span class="stat-label">Масса:</span><span class="stat-value">1 M☉</span>
            <span class="stat-label">Радиус:</span><span class="stat-value">1 R☉</span>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Star Info Modal -->
  <div class="modal" id="modal">
    <div class="card">
      <button class="close-modal" onclick="closeModal()">×</button>
      <div class="card-header">
        <div class="star-preview" id="mPreview"></div>
        <div>
          <h2 id="mTitle">Звезда</h2>
          <div class="type" id="mType">Тип</div>
          <div class="constellation" id="mConstellation">Созвездие</div>
        </div>
      </div>
      <div class="stats" id="mStats"></div>
      <p class="fact" id="mFact">...</p>
    </div>
  </div>

  <script type="importmap">
    { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js", "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/" } }
  </script>
  
   <script type="module">
    import * as THREE from "three";
    import { OrbitControls } from "three/addons/controls/OrbitControls.js";
    import { UnrealBloomPass } from "three/addons/postprocessing/UnrealBloomPass.js";
    import { EffectComposer } from "three/addons/postprocessing/EffectComposer.js";
    import { RenderPass } from "three/addons/postprocessing/RenderPass.js";
    import { STARS_DATA } from './stars.js';

    const STARS = STARS_DATA;

    // ==================== HR DIAGRAM ====================
    let hrDiagramOpen = false;
    let hrStarPositions = [];

    window.toggleHRDiagram = () => {
      hrDiagramOpen = !hrDiagramOpen;
      const modal = document.getElementById('hrModal');
      const btn = document.getElementById('btnHRDiagram');
      
      modal.classList.toggle('visible', hrDiagramOpen);
      btn.classList.toggle('active', hrDiagramOpen);
      
      if (hrDiagramOpen) {
        setTimeout(() => drawHRDiagram(), 100);
      }
    };

    function drawHRDiagram() {
      const canvas = document.getElementById('hrCanvas');
      const wrapper = canvas.parentElement;
      const dpr = window.devicePixelRatio || 1;
      
      canvas.width = wrapper.clientWidth * dpr;
      canvas.height = wrapper.clientHeight * dpr;
      canvas.style.width = wrapper.clientWidth + 'px';
      canvas.style.height = wrapper.clientHeight + 'px';
      
      const ctx = canvas.getContext('2d');
      ctx.scale(dpr, dpr);
      
      const w = wrapper.clientWidth;
      const h = wrapper.clientHeight;
      const padding = { top: 40, right: 40, bottom: 60, left: 80 };
      const plotW = w - padding.left - padding.right;
      const plotH = h - padding.top - padding.bottom;

      // Background
      ctx.fillStyle = '#050510';
      ctx.fillRect(0, 0, w, h);

      // Grid
      ctx.strokeStyle = 'rgba(255,255,255,0.05)';
      ctx.lineWidth = 1;
      
      for (let i = 0; i <= 10; i++) {
        const x = padding.left + (plotW / 10) * i;
        ctx.beginPath();
        ctx.moveTo(x, padding.top);
        ctx.lineTo(x, h - padding.bottom);
        ctx.stroke();
      }
      for (let i = 0; i <= 8; i++) {
        const y = padding.top + (plotH / 8) * i;
        ctx.beginPath();
        ctx.moveTo(padding.left, y);
        ctx.lineTo(w - padding.right, y);
        ctx.stroke();
      }

      // Main Sequence band
      ctx.save();
      const msGrad = ctx.createLinearGradient(padding.left, padding.top, w - padding.right, h - padding.bottom);
      msGrad.addColorStop(0, 'rgba(119, 153, 255, 0.15)');
      msGrad.addColorStop(0.5, 'rgba(255, 255, 255, 0.1)');
      msGrad.addColorStop(1, 'rgba(255, 51, 0, 0.15)');
      ctx.fillStyle = msGrad;
      
      ctx.beginPath();
      ctx.moveTo(padding.left + plotW * 0.05, padding.top + plotH * 0.02);
      ctx.lineTo(padding.left + plotW * 0.15, padding.top + plotH * 0.08);
      ctx.lineTo(padding.left + plotW * 0.95, padding.top + plotH * 0.85);
      ctx.lineTo(padding.left + plotW * 0.98, padding.top + plotH * 0.98);
      ctx.lineTo(padding.left + plotW * 0.85, padding.top + plotH * 0.98);
      ctx.lineTo(padding.left + plotW * 0.08, padding.top + plotH * 0.15);
      ctx.closePath();
      ctx.fill();
      ctx.restore();

      // Giants region
      ctx.save();
      ctx.fillStyle = 'rgba(255, 102, 68, 0.08)';
      ctx.beginPath();
      ctx.ellipse(padding.left + plotW * 0.7, padding.top + plotH * 0.35, plotW * 0.2, plotH * 0.2, 0, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();

      // Supergiants region
      ctx.save();
      ctx.fillStyle = 'rgba(170, 204, 255, 0.06)';
      ctx.beginPath();
      ctx.ellipse(padding.left + plotW * 0.5, padding.top + plotH * 0.1, plotW * 0.35, plotH * 0.08, 0, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();

      // White dwarfs region
      ctx.save();
      ctx.fillStyle = 'rgba(200, 220, 255, 0.08)';
      ctx.beginPath();
      ctx.ellipse(padding.left + plotW * 0.15, padding.top + plotH * 0.9, plotW * 0.12, plotH * 0.06, 0, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();

      // Axes
      ctx.strokeStyle = 'rgba(255,255,255,0.3)';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(padding.left, padding.top);
      ctx.lineTo(padding.left, h - padding.bottom);
      ctx.lineTo(w - padding.right, h - padding.bottom);
      ctx.stroke();

      // Labels
      ctx.fillStyle = '#8899bb';
      ctx.font = '11px Jura, sans-serif';
      ctx.textAlign = 'center';

      // Spectral classes (X axis) - reversed: O B A F G K M
      const spectralClasses = ['O', 'B', 'A', 'F', 'G', 'K', 'M'];
      const spectralTemps = [40000, 20000, 9000, 7000, 5500, 4000, 3000];
      
      spectralClasses.forEach((cls, i) => {
        const x = padding.left + (plotW / (spectralClasses.length - 1)) * i;
        ctx.fillStyle = getStarColorByTemp(spectralTemps[i]);
        ctx.fillText(cls, x, h - padding.bottom + 20);
      });

      ctx.fillStyle = '#8899bb';
      ctx.fillText('Спектральный класс (Температура →)', w / 2, h - 15);

      // Luminosity labels (Y axis)
      ctx.textAlign = 'right';
      const lumLabels = ['10⁶', '10⁴', '10²', '1', '10⁻²', '10⁻⁴'];
      lumLabels.forEach((label, i) => {
        const y = padding.top + (plotH / (lumLabels.length - 1)) * i;
        ctx.fillText(label + ' L☉', padding.left - 10, y + 4);
      });

      ctx.save();
      ctx.translate(15, h / 2);
      ctx.rotate(-Math.PI / 2);
      ctx.textAlign = 'center';
      ctx.fillText('Светимость', 0, 0);
      ctx.restore();

      // Region labels
      ctx.font = '10px Inter, sans-serif';
      ctx.fillStyle = 'rgba(255,255,255,0.4)';
      ctx.textAlign = 'center';
      ctx.fillText('Сверхгиганты', padding.left + plotW * 0.5, padding.top + plotH * 0.06);
      ctx.fillText('Гиганты', padding.left + plotW * 0.72, padding.top + plotH * 0.32);
      ctx.fillText('Белые карлики', padding.left + plotW * 0.15, padding.top + plotH * 0.88);

      // Main sequence label
      ctx.save();
      ctx.translate(padding.left + plotW * 0.5, padding.top + plotH * 0.55);
      ctx.rotate(-Math.PI / 4);
      ctx.fillStyle = 'rgba(255,255,255,0.3)';
      ctx.font = '12px Jura, sans-serif';
      ctx.fillText('Главная последовательность', 0, 0);
      ctx.restore();

      // Plot stars
      hrStarPositions = [];
      
      const tempToX = (temp) => {
        const logTemp = Math.log10(temp);
        const minLog = Math.log10(2500);
        const maxLog = Math.log10(50000);
        return padding.left + plotW * (1 - (logTemp - minLog) / (maxLog - minLog));
      };
      
      const lumToY = (lum) => {
        const logLum = Math.log10(Math.max(lum, 0.0001));
        const minLog = -4;
        const maxLog = 6;
        return padding.top + plotH * (1 - (logLum - minLog) / (maxLog - minLog));
      };

      Object.entries(STARS).forEach(([name, star]) => {
        const x = tempToX(star.temperature);
        const y = lumToY(star.luminosity);
        
        const size = Math.max(4, Math.min(12, Math.log10(star.luminosity + 1) * 2 + 4));
        const isActive = addedKeys.has(name);
        
        hrStarPositions.push({ name, x, y, size, star });

        // Glow
        const glowGrad = ctx.createRadialGradient(x, y, 0, x, y, size * 3);
        glowGrad.addColorStop(0, star.color + '60');
        glowGrad.addColorStop(1, 'transparent');
        ctx.fillStyle = glowGrad;
        ctx.beginPath();
        ctx.arc(x, y, size * 3, 0, Math.PI * 2);
        ctx.fill();

        // Star dot
        const starGrad = ctx.createRadialGradient(x, y, 0, x, y, size);
        starGrad.addColorStop(0, '#ffffff');
        starGrad.addColorStop(0.3, star.color);
        starGrad.addColorStop(1, star.coronaColor);
        ctx.fillStyle = starGrad;
        ctx.beginPath();
        ctx.arc(x, y, size, 0, Math.PI * 2);
        ctx.fill();

        // Active ring
        if (isActive) {
          ctx.strokeStyle = '#4da6ff';
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.arc(x, y, size + 4, 0, Math.PI * 2);
          ctx.stroke();
        }

        // Label for major stars
        if (star.luminosity > 100 || star.radius > 5 || name === 'Солнце') {
          ctx.fillStyle = 'rgba(255,255,255,0.7)';
          ctx.font = '9px Inter, sans-serif';
          ctx.textAlign = 'left';
          ctx.fillText(name, x + size + 5, y + 3);
        }
      });
    }

    function getStarColorByTemp(temp) {
      if (temp > 25000) return '#7799FF';
      if (temp > 10000) return '#AACCFF';
      if (temp > 7500) return '#FFFFFF';
      if (temp > 6000) return '#FFDDAA';
      if (temp > 5000) return '#FFAA33';
      if (temp > 3500) return '#FF5500';
      return '#FF3300';
    }

    // HR Canvas interactions
    const hrCanvas = document.getElementById('hrCanvas');
    const hrTooltip = document.getElementById('hrTooltip');

    hrCanvas.addEventListener('mousemove', (e) => {
      const rect = hrCanvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      
      let hoveredStar = null;
      for (const pos of hrStarPositions) {
        const dist = Math.sqrt((x - pos.x) ** 2 + (y - pos.y) ** 2);
        if (dist < pos.size + 8) {
          hoveredStar = pos;
          break;
        }
      }
      
      if (hoveredStar) {
        const s = hoveredStar.star;
        hrTooltip.querySelector('.star-name').textContent = hoveredStar.name;
        hrTooltip.querySelector('.star-name').style.color = s.color;
        hrTooltip.querySelector('.star-type').textContent = s.type;
        hrTooltip.querySelector('.star-stats').innerHTML = `
          <span class="stat-label">Темп:</span><span class="stat-value">${s.temperature.toLocaleString()} K</span>
          <span class="stat-label">Светим:</span><span class="stat-value">${s.luminosity.toLocaleString()} L☉</span>
          <span class="stat-label">Масса:</span><span class="stat-value">${s.mass} M☉</span>
          <span class="stat-label">Радиус:</span><span class="stat-value">${s.radius} R☉</span>
        `;
        
        hrTooltip.style.left = (hoveredStar.x + 20) + 'px';
        hrTooltip.style.top = (hoveredStar.y - 10) + 'px';
        hrTooltip.classList.add('visible');
        hrCanvas.style.cursor = 'pointer';
      } else {
        hrTooltip.classList.remove('visible');
        hrCanvas.style.cursor = 'crosshair';
      }
    });

    hrCanvas.addEventListener('click', (e) => {
      const rect = hrCanvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      
      for (const pos of hrStarPositions) {
        const dist = Math.sqrt((x - pos.x) ** 2 + (y - pos.y) ** 2);
        if (dist < pos.size + 8) {
          if (addedKeys.has(pos.name)) {
            window.removeStar(pos.name);
          } else {
            window.addStar(pos.name);
          }
          setTimeout(() => drawHRDiagram(), 50);
          break;
        }
      }
    });

    hrCanvas.addEventListener('mouseleave', () => {
      hrTooltip.classList.remove('visible');
    });

    window.addEventListener('resize', () => {
      if (hrDiagramOpen) {
        setTimeout(() => drawHRDiagram(), 100);
      }
    });

    // ==================== THREE.JS SCENE ====================
    const starScroll = document.getElementById('starBtns');
    starScroll.addEventListener('wheel', (e) => {
      e.preventDefault();
      starScroll.scrollLeft += e.deltaY;
    }, { passive: false });

    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.01, 500000);
    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.0;
    document.body.appendChild(renderer.domElement);

    const composer = new EffectComposer(renderer);
    composer.addPass(new RenderPass(scene, camera));
    const bloomPass = new UnrealBloomPass(
      new THREE.Vector2(window.innerWidth, window.innerHeight), 1.2, 0.4, 0.85
    );
    composer.addPass(bloomPass);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.08;
    controls.minDistance = 1;
    controls.maxDistance = 50000;
    controls.enableZoom = true;
    controls.zoomSpeed = 1.2;
    controls.rotateSpeed = 0.5;
    controls.enablePan = true;
    controls.panSpeed = 0.5;
    controls.maxPolarAngle = Math.PI * 0.85;
    controls.minPolarAngle = Math.PI * 0.15;

    scene.add(new THREE.AmbientLight(0x445566, 0.4));
    scene.add(new THREE.HemisphereLight(0xddeeff, 0x0f0e0d, 0.3));

    const bgGeo = new THREE.SphereGeometry(100000, 64, 64);
    const bgMat = new THREE.MeshBasicMaterial({
      map: new THREE.TextureLoader().load('textures/milkyway.jpg'),
      side: THREE.BackSide, transparent: true, opacity: 0.9, depthWrite: false
    });
    const skyboxMilkyWay = new THREE.Mesh(bgGeo, bgMat);
    skyboxMilkyWay.renderOrder = -1;
    scene.add(skyboxMilkyWay);

    function createStarfield() {
      const count = 10000;
      const geo = new THREE.BufferGeometry();
      const pos = new Float32Array(count * 3);
      const sizes = new Float32Array(count);
      const colors = new Float32Array(count * 3);
      
      for (let i = 0; i < count; i++) {
        const r = 5000 + Math.random() * 30000;
        const theta = Math.random() * Math.PI * 2;
        const phi = Math.acos(2 * Math.random() - 1);
        pos[i * 3] = r * Math.sin(phi) * Math.cos(theta);
        pos[i * 3 + 1] = r * Math.cos(phi);
        pos[i * 3 + 2] = r * Math.sin(phi) * Math.sin(theta);
        sizes[i] = 0.5 + Math.random() * 2;
        
        const temp = Math.random();
        let c = temp < 0.3 ? new THREE.Color().setHSL(0.08, 0.8, 0.7) :
                temp < 0.6 ? new THREE.Color().setHSL(0.12, 0.3, 0.9) :
                            new THREE.Color().setHSL(0.6, 0.5, 0.8);
        colors[i * 3] = c.r; colors[i * 3 + 1] = c.g; colors[i * 3 + 2] = c.b;
      }
      
      geo.setAttribute('position', new THREE.BufferAttribute(pos, 3));
      geo.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
      geo.setAttribute('color', new THREE.BufferAttribute(colors, 3));
      
      const canvas = document.createElement('canvas');
      canvas.width = canvas.height = 64;
      const ctx = canvas.getContext('2d');
      const grad = ctx.createRadialGradient(32, 32, 0, 32, 32, 32);
      grad.addColorStop(0, 'rgba(255,255,255,1)');
      grad.addColorStop(0.1, 'rgba(255,255,255,0.9)');
      grad.addColorStop(0.3, 'rgba(200,220,255,0.4)');
      grad.addColorStop(1, 'rgba(0,0,0,0)');
      ctx.fillStyle = grad;
      ctx.fillRect(0, 0, 64, 64);
      const tex = new THREE.Texture(canvas);
      tex.needsUpdate = true;
      
      return new THREE.Points(geo, new THREE.PointsMaterial({
        size: 1.5, map: tex, vertexColors: true, transparent: true,
        opacity: 0.9, blending: THREE.AdditiveBlending, depthWrite: false
      }));
    }
    const stars = createStarfield();
    scene.add(stars);

    // Shaders (keeping them compact)
    const starVertexShader = `varying vec2 vUv;varying vec3 vNormal,vPosition,vWorldNormal;void main(){vUv=uv;vNormal=normalize(normalMatrix*normal);vPosition=position;vWorldNormal=normalize((modelMatrix*vec4(normal,0.0)).xyz);gl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.0);}`;
    
    const starFragmentShader = `uniform float time;uniform vec3 starColor,brightColor,darkColor;uniform float temperature,rotationSpeed,starType;varying vec3 vNormal,vPosition;varying vec2 vUv;vec3 mod289v3(vec3 x){return x-floor(x*(1.0/289.0))*289.0;}vec4 mod289v4(vec4 x){return x-floor(x*(1.0/289.0))*289.0;}vec4 permute(vec4 x){return mod289v4(((x*34.0)+1.0)*x);}vec4 taylorInvSqrt(vec4 r){return 1.79284291400159-0.85373472095314*r;}float snoise(vec3 v){const vec2 C=vec2(1.0/6.0,1.0/3.0);const vec4 D=vec4(0.0,0.5,1.0,2.0);vec3 i=floor(v+dot(v,C.yyy));vec3 x0=v-i+dot(i,C.xxx);vec3 g=step(x0.yzx,x0.xyz);vec3 l=1.0-g;vec3 i1=min(g.xyz,l.zxy);vec3 i2=max(g.xyz,l.zxy);vec3 x1=x0-i1+C.xxx;vec3 x2=x0-i2+C.yyy;vec3 x3=x0-D.yyy;i=mod289v3(i);vec4 p=permute(permute(permute(i.z+vec4(0.0,i1.z,i2.z,1.0))+i.y+vec4(0.0,i1.y,i2.y,1.0))+i.x+vec4(0.0,i1.x,i2.x,1.0));float n_=0.142857142857;vec3 ns=n_*D.wyz-D.xzx;vec4 j=p-49.0*floor(p*ns.z*ns.z);vec4 x_=floor(j*ns.z);vec4 y_=floor(j-7.0*x_);vec4 x=x_*ns.x+ns.yyyy;vec4 y=y_*ns.x+ns.yyyy;vec4 h=1.0-abs(x)-abs(y);vec4 b0=vec4(x.xy,y.xy);vec4 b1=vec4(x.zw,y.zw);vec4 s0=floor(b0)*2.0+1.0;vec4 s1=floor(b1)*2.0+1.0;vec4 sh=-step(h,vec4(0.0));vec4 a0=b0.xzyw+s0.xzyw*sh.xxyy;vec4 a1=b1.xzyw+s1.xzyw*sh.zzww;vec3 p0=vec3(a0.xy,h.x);vec3 p1=vec3(a0.zw,h.y);vec3 p2=vec3(a1.xy,h.z);vec3 p3=vec3(a1.zw,h.w);vec4 norm=taylorInvSqrt(vec4(dot(p0,p0),dot(p1,p1),dot(p2,p2),dot(p3,p3)));p0*=norm.x;p1*=norm.y;p2*=norm.z;p3*=norm.w;vec4 m=max(0.6-vec4(dot(x0,x0),dot(x1,x1),dot(x2,x2),dot(x3,x3)),0.0);m=m*m;return 42.0*dot(m*m,vec4(dot(p0,x0),dot(p1,x1),dot(p2,x2),dot(p3,x3)));}float fbm(vec3 p,int octaves){float f=0.0;float amplitude=0.5;float frequency=1.0;for(int i=0;i<6;i++){if(i>=octaves)break;f+=amplitude*snoise(p*frequency);frequency*=2.0;amplitude*=0.5;}return f;}vec3 getRotatedPos(vec3 pos,float angle){float c=cos(angle);float s=sin(angle);return vec3(pos.x*c-pos.z*s,pos.y,pos.x*s+pos.z*c);}void main(){vec3 pos=vPosition;float t=time*rotationSpeed;vec3 rotatedPos=getRotatedPos(pos,t*0.15);float granuleScale=mix(2.0,4.0,starType);float granules=fbm(rotatedPos*granuleScale+vec3(t*0.02),5)*0.5+0.5;float convectionScale=mix(1.0,2.0,starType);vec3 convectionPos=getRotatedPos(pos,t*0.08);float convection=fbm(convectionPos*convectionScale+vec3(0.0,t*0.03,0.0),4)*0.5+0.5;float fineDetail=snoise(rotatedPos*12.0+vec3(t*0.1))*0.15;float prominenceNoise=fbm(getRotatedPos(pos,t*0.05)*0.8,3);float prominences=smoothstep(0.2,0.6,prominenceNoise)*0.2;float sunspotNoise=fbm(rotatedPos*1.2+vec3(t*0.005),4);float sunspots=smoothstep(0.55,0.7,sunspotNoise)*smoothstep(0.8,0.3,abs(pos.y/length(pos)));vec3 surfaceColor=starColor;surfaceColor=mix(surfaceColor,brightColor,granules*0.4);surfaceColor=mix(surfaceColor,brightColor*1.2,convection*0.3);surfaceColor+=fineDetail*brightColor;surfaceColor=mix(surfaceColor,darkColor,sunspots*0.5);surfaceColor=mix(surfaceColor,brightColor*1.3,prominences);vec3 normal=normalize(vNormal);float fresnel=1.0-max(dot(normal,vec3(0.0,0.0,1.0)),0.0);float limbDarkening=pow(1.0-fresnel*0.7,0.5);surfaceColor*=limbDarkening;float edgeGlow=pow(fresnel,3.0)*0.6;surfaceColor+=brightColor*edgeGlow;float flicker=sin(t*2.0+snoise(pos*5.0)*3.0)*0.03+1.0;surfaceColor*=flicker*(1.0+granules*0.1+convection*0.1);gl_FragColor=vec4(surfaceColor,1.0);}`;

    const coronaVertexShader = `varying vec3 vNormal,vPosition,vWorldPosition;void main(){vNormal=normalize(normalMatrix*normal);vPosition=position;vWorldPosition=(modelMatrix*vec4(position,1.0)).xyz;gl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.0);}`;
    
    const coronaFragmentShader = `uniform float time;uniform vec3 coronaColor,innerColor;uniform float rotationSpeed,coronaIntensity;varying vec3 vNormal,vPosition;float hash(float n){return fract(sin(n)*43758.5453123);}float noise(vec3 x){vec3 p=floor(x);vec3 f=fract(x);f=f*f*(3.0-2.0*f);float n=p.x+p.y*57.0+p.z*113.0;return mix(mix(mix(hash(n),hash(n+1.0),f.x),mix(hash(n+57.0),hash(n+58.0),f.x),f.y),mix(mix(hash(n+113.0),hash(n+114.0),f.x),mix(hash(n+170.0),hash(n+171.0),f.x),f.y),f.z);}float fbm(vec3 p){float f=0.0;float amp=0.5;for(int i=0;i<4;i++){f+=amp*noise(p);p*=2.0;amp*=0.5;}return f;}void main(){float fresnel=1.0-abs(dot(vNormal,vec3(0.0,0.0,1.0)));float t=time*rotationSpeed*0.3;float theta=atan(vPosition.z,vPosition.x)+t*0.1;vec3 animPos=vec3(cos(theta),vPosition.y,sin(theta))*length(vPosition.xz);float plasma=fbm(animPos*0.5+vec3(t*0.05))+fbm(animPos*1.0-vec3(0.0,t*0.03,0.0))*0.5;float streamers=pow(abs(sin(theta*8.0+plasma*3.0)),4.0)*0.3;float alpha=pow(fresnel,2.5)*(0.3+plasma*0.4+streamers)*smoothstep(0.0,0.6,1.0-fresnel)*coronaIntensity;vec3 color=mix(innerColor,coronaColor,fresnel)+streamers*coronaColor*0.5;gl_FragColor=vec4(color,alpha*0.6);}`;

    const glowVertexShader = `varying vec3 vNormal,vPosition;void main(){vNormal=normalize(normalMatrix*normal);vPosition=position;gl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.0);}`;
    
    const glowFragmentShader = `uniform vec3 glowColor,viewVector;uniform float intensity,time,glowFalloff;varying vec3 vNormal,vPosition;void main(){vec3 viewDir=normalize(viewVector);float fresnel=1.0-max(dot(vNormal,viewDir),0.0);float innerGlow=pow(fresnel,glowFalloff)*0.7;float midGlow=pow(fresnel,glowFalloff*0.6)*0.4;float outerGlow=pow(fresnel,glowFalloff*0.3)*0.2;float totalGlow=(innerGlow+midGlow+outerGlow)*(sin(time*0.4)*0.08+1.0)*(sin(time*2.3+fresnel*5.0)*0.03+1.0)*intensity;gl_FragColor=vec4(glowColor*totalGlow,totalGlow*0.5);}`;

    const prominenceVertexShader = `varying vec3 vNormal,vPosition;varying vec2 vUv;void main(){vNormal=normalize(normalMatrix*normal);vPosition=position;vUv=uv;gl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.0);}`;
    
    const prominenceFragmentShader = `uniform float time;uniform vec3 prominenceColor;uniform float rotationSpeed;varying vec3 vNormal,vPosition;float hash(float n){return fract(sin(n)*43758.5453);}float noise(vec3 x){vec3 p=floor(x);vec3 f=fract(x);f=f*f*(3.0-2.0*f);float n=p.x+p.y*57.0+p.z*113.0;return mix(mix(mix(hash(n),hash(n+1.0),f.x),mix(hash(n+57.0),hash(n+58.0),f.x),f.y),mix(mix(hash(n+113.0),hash(n+114.0),f.x),mix(hash(n+170.0),hash(n+171.0),f.x),f.y),f.z);}void main(){float fresnel=1.0-abs(dot(vNormal,vec3(0.0,0.0,1.0)));float t=time*rotationSpeed*0.2;float theta=atan(vPosition.z,vPosition.x);vec3 animPos=vPosition;animPos.x=cos(theta+t*0.1)*length(vPosition.xz);animPos.z=sin(theta+t*0.1)*length(vPosition.xz);float n=noise(animPos*2.0+t*0.1)+noise(animPos*4.0-t*0.05)*0.5;float arch=pow(sin(theta*3.0+t*0.5+n*2.0),8.0)*smoothstep(0.3,0.8,fresnel);float alpha=arch*n*0.4*smoothstep(0.0,0.5,1.0-fresnel);gl_FragColor=vec4(prominenceColor,alpha);}`;

    const starsGroup = new THREE.Group();
    scene.add(starsGroup);
    const connectionsGroup = new THREE.Group();
    scene.add(connectionsGroup);
    
    let activeStars = [];
    const addedKeys = new Set();
    let compareMode = 'size';
    let realScaleMode = true;
    let spaceViewMode = false;
    let showGalaxyBackground = true;
    let isDark = true;

    // Helper functions
    function galacticToCartesian(l, b, dist) {
      const lRad = l * Math.PI / 180, bRad = b * Math.PI / 180;
      let scaledDist = dist < 1 ? dist * 5 : dist < 50 ? 5 + (dist - 1) * 2 :
        dist < 200 ? 5 + 49 * 2 + (dist - 50) * 0.8 :
        dist < 1000 ? 5 + 49 * 2 + 150 * 0.8 + (dist - 200) * 0.3 :
        5 + 49 * 2 + 150 * 0.8 + 800 * 0.3 + (dist - 1000) * 0.1;
      return {
        x: scaledDist * Math.cos(bRad) * Math.cos(lRad),
        y: scaledDist * Math.sin(bRad),
        z: scaledDist * Math.cos(bRad) * Math.sin(lRad)
      };
    }

    function calculateVisualRadius(data, isRealScale) {
      if (spaceViewMode) return Math.min(Math.max(Math.log10(data.luminosity + 1) * 0.3 + 0.5, 0.3), 2);
      if (!isRealScale) return 12;
      switch (compareMode) {
        case 'mass': return Math.pow(data.mass, 0.5) * 2;
        case 'luminosity': return Math.pow(data.luminosity, 0.25) * 2;
        case 'temp': return (data.temperature / 5778) * 3;
        default:
          return data.radius <= 1 ? data.radius * 3 :
            data.radius <= 10 ? 3 + (data.radius - 1) * 1.5 :
            data.radius <= 100 ? 3 + 9 * 1.5 + (data.radius - 10) * 0.8 :
            data.radius <= 500 ? 3 + 9 * 1.5 + 90 * 0.8 + (data.radius - 100) * 0.4 :
            3 + 9 * 1.5 + 90 * 0.8 + 400 * 0.4 + (data.radius - 500) * 0.15;
      }
    }

    function getStarType(temp) {
      return temp > 25000 ? 0.0 : temp > 10000 ? 0.2 : temp > 7500 ? 0.4 :
        temp > 6000 ? 0.5 : temp > 5000 ? 0.6 : temp > 3500 ? 0.8 : 1.0;
    }

    function createGlowTexture(coronaColorStr, starColorStr, temperature) {
      const canvas = document.createElement('canvas');
      canvas.width = canvas.height = 512;
      const ctx = canvas.getContext('2d');
      const cc = new THREE.Color(coronaColorStr), sc = new THREE.Color(starColorStr);
      const cx = 256, coreSize = temperature > 10000 ? 60 : temperature > 5000 ? 50 : 40;
      
      const g1 = ctx.createRadialGradient(cx, cx, 0, cx, cx, coreSize);
      g1.addColorStop(0, `rgba(255,255,255,0.95)`);
      g1.addColorStop(0.3, `rgba(${sc.r*255|0},${sc.g*255|0},${sc.b*255|0},0.7)`);
      g1.addColorStop(0.7, `rgba(${cc.r*255|0},${cc.g*255|0},${cc.b*255|0},0.3)`);
      g1.addColorStop(1, 'rgba(0,0,0,0)');
      ctx.fillStyle = g1; ctx.fillRect(0, 0, 512, 512);
      
      const g2 = ctx.createRadialGradient(cx, cx, coreSize * 0.5, cx, cx, 180);
      g2.addColorStop(0, `rgba(${cc.r*255|0},${cc.g*255|0},${cc.b*255|0},0.4)`);
      g2.addColorStop(0.5, `rgba(${cc.r*200|0},${cc.g*200|0},${cc.b*200|0},0.15)`);
      g2.addColorStop(1, 'rgba(0,0,0,0)');
      ctx.fillStyle = g2; ctx.fillRect(0, 0, 512, 512);
      
      return canvas;
    }

    function createRaysTexture(colorStr, temperature) {
      const canvas = document.createElement('canvas');
      canvas.width = canvas.height = 512;
      const ctx = canvas.getContext('2d');
      const color = new THREE.Color(colorStr);
      const rayCount = temperature > 10000 ? 12 : temperature > 5000 ? 8 : 6;
      const rayLength = temperature > 10000 ? 220 : temperature > 5000 ? 180 : 150;
      
      ctx.translate(256, 256);
      for (let i = 0; i < rayCount; i++) {
        ctx.save();
        ctx.rotate((i / rayCount) * Math.PI * 2);
        const grad = ctx.createLinearGradient(0, 0, rayLength, 0);
        grad.addColorStop(0, `rgba(255,255,255,0.4)`);
        grad.addColorStop(0.2, `rgba(${color.r*255|0},${color.g*255|0},${color.b*255|0},0.25)`);
        grad.addColorStop(1, 'rgba(0,0,0,0)');
        ctx.fillStyle = grad;
        ctx.beginPath(); ctx.moveTo(20, 0); ctx.lineTo(rayLength, -3); ctx.lineTo(rayLength, 3); ctx.closePath(); ctx.fill();
        ctx.restore();
      }
      return canvas;
    }

    function createLabelTexture(name, distance) {
      const canvas = document.createElement('canvas');
      canvas.width = 320; canvas.height = 80;
      const ctx = canvas.getContext('2d');
      ctx.fillStyle = 'rgba(0,0,0,0.6)';
      ctx.roundRect(10, 10, 300, 60, 10); ctx.fill();
      ctx.font = 'bold 22px Jura, sans-serif';
      ctx.fillStyle = '#ffffff'; ctx.textAlign = 'center';
      ctx.fillText(name, 160, 32);
      const distText = distance < 0.01 ? '☀ Центр' : distance < 1 ? `${(distance * 63241).toFixed(0)} а.е.` :
        distance < 100 ? `${distance.toFixed(2)} св. лет` : `${distance.toFixed(0)} св. лет`;
      ctx.font = '16px Inter, sans-serif'; ctx.fillStyle = '#88aaff';
      ctx.fillText(distText, 160, 56);
      return canvas;
    }

    function createStar(key) {
      const d = STARS[key];
      const group = new THREE.Group();
      const visualRadius = calculateVisualRadius(d, realScaleMode);
      const rotationSpeed = 0.2 / Math.sqrt(Math.max(d.radius, 0.1));
      const starType = getStarType(d.temperature);
      
      const starColor = new THREE.Color(d.color);
      const brightColor = starColor.clone().multiplyScalar(1.4).add(new THREE.Color(0.15, 0.15, 0.15));
      const darkColor = starColor.clone().multiplyScalar(0.5);
      const coronaColor = new THREE.Color(d.coronaColor);
      
      const starMat = new THREE.ShaderMaterial({
        uniforms: { time: { value: 0 }, starColor: { value: starColor }, brightColor: { value: brightColor },
          darkColor: { value: darkColor }, temperature: { value: d.temperature }, starRadius: { value: visualRadius },
          rotationSpeed: { value: rotationSpeed }, starType: { value: starType }
        },
        vertexShader: starVertexShader, fragmentShader: starFragmentShader
      });
      const starMesh = new THREE.Mesh(new THREE.SphereGeometry(visualRadius, 128, 128), starMat);
      group.add(starMesh);

      const coronaIntensity = d.temperature > 10000 ? 0.8 : d.temperature > 5000 ? 0.5 : 0.3;
      
      const innerCoronaMat = new THREE.ShaderMaterial({
        uniforms: { time: { value: 0 }, coronaColor: { value: coronaColor }, innerColor: { value: brightColor },
          viewVector: { value: camera.position }, rotationSpeed: { value: rotationSpeed }, coronaIntensity: { value: coronaIntensity }
        },
        vertexShader: coronaVertexShader, fragmentShader: coronaFragmentShader,
        side: THREE.BackSide, blending: THREE.AdditiveBlending, transparent: true, depthWrite: false
      });
      const innerCorona = new THREE.Mesh(new THREE.SphereGeometry(visualRadius * 1.12, 64, 64), innerCoronaMat);
      group.add(innerCorona);

      const outerCoronaMat = new THREE.ShaderMaterial({
        uniforms: { time: { value: 0 }, coronaColor: { value: coronaColor.clone().multiplyScalar(0.6) },
          innerColor: { value: coronaColor }, viewVector: { value: camera.position },
          rotationSpeed: { value: rotationSpeed * 0.7 }, coronaIntensity: { value: coronaIntensity * 0.5 }
        },
        vertexShader: coronaVertexShader, fragmentShader: coronaFragmentShader,
        side: THREE.BackSide, blending: THREE.AdditiveBlending, transparent: true, depthWrite: false
      });
      const outerCorona = new THREE.Mesh(new THREE.SphereGeometry(visualRadius * 1.25, 48, 48), outerCoronaMat);
      group.add(outerCorona);

      const glowFalloff = d.temperature > 10000 ? 3.0 : d.temperature > 5000 ? 4.0 : 5.0;
      const glowMat = new THREE.ShaderMaterial({
        uniforms: { glowColor: { value: coronaColor }, viewVector: { value: camera.position },
          intensity: { value: 0.6 }, time: { value: 0 }, glowFalloff: { value: glowFalloff }
        },
        vertexShader: glowVertexShader, fragmentShader: glowFragmentShader,
        side: THREE.BackSide, blending: THREE.AdditiveBlending, transparent: true, depthWrite: false
      });
      const atmosphericGlow = new THREE.Mesh(new THREE.SphereGeometry(visualRadius * 1.4, 32, 32), glowMat);
      group.add(atmosphericGlow);

      let prominences = null;
      if (d.temperature > 4000 && d.temperature < 20000) {
        const prominenceMat = new THREE.ShaderMaterial({
          uniforms: { time: { value: 0 }, prominenceColor: { value: coronaColor.clone().multiplyScalar(1.5) },
            rotationSpeed: { value: rotationSpeed }
          },
          vertexShader: prominenceVertexShader, fragmentShader: prominenceFragmentShader,
          side: THREE.DoubleSide, blending: THREE.AdditiveBlending, transparent: true, depthWrite: false
        });
        prominences = new THREE.Mesh(new THREE.SphereGeometry(visualRadius * 1.3, 48, 48), prominenceMat);
        group.add(prominences);
      }

      const glowTex = new THREE.CanvasTexture(createGlowTexture(d.coronaColor, d.color, d.temperature));
      const glowSprite = new THREE.Sprite(new THREE.SpriteMaterial({
        map: glowTex, transparent: true, blending: THREE.AdditiveBlending, depthWrite: false, opacity: 0.35
      }));
      glowSprite.scale.set(visualRadius * 3, visualRadius * 3, 1);
      group.add(glowSprite);

      const raysTex = new THREE.CanvasTexture(createRaysTexture(d.color, d.temperature));
      const raysSprite = new THREE.Sprite(new THREE.SpriteMaterial({
        map: raysTex, transparent: true, blending: THREE.AdditiveBlending, depthWrite: false, opacity: 0.2
      }));
      raysSprite.scale.set(visualRadius * 4, visualRadius * 4, 1);
      group.add(raysSprite);

      const light = new THREE.PointLight(starColor.getHex(), Math.min(Math.sqrt(d.luminosity) / 8, 6) + 0.5, visualRadius * 20);
      group.add(light);

      const labelTex = new THREE.CanvasTexture(createLabelTexture(key, d.distance));
      const labelSprite = new THREE.Sprite(new THREE.SpriteMaterial({ map: labelTex, transparent: true, depthTest: false }));
      labelSprite.scale.set(visualRadius * 5, visualRadius * 2.5, 1);
      labelSprite.position.y = visualRadius * 1.8;
      labelSprite.visible = spaceViewMode;
      group.add(labelSprite);

      group.userData = { name: key, ...d, visualRadius, rotationSpeed, starType, starMesh, innerCorona, outerCorona,
        atmosphericGlow, prominences, glowSprite, raysSprite, light, labelSprite };
      
      return group;
    }

    function createConnectionLine(starGroup) {
      const points = [new THREE.Vector3(0, 0, 0), new THREE.Vector3(starGroup.userData.tx, starGroup.userData.ty || 0, starGroup.userData.tz || 0)];
      const geometry = new THREE.BufferGeometry().setFromPoints(points);
      const material = new THREE.LineDashedMaterial({ color: new THREE.Color(starGroup.userData.color), dashSize: 3, gapSize: 2, opacity: 0.25, transparent: true });
      const line = new THREE.Line(geometry, material);
      line.computeLineDistances();
      line.userData.starName = starGroup.userData.name;
      return line;
    }

    function updateConnections() {
      while (connectionsGroup.children.length > 0) connectionsGroup.remove(connectionsGroup.children[0]);
      if (!spaceViewMode) return;
      activeStars.forEach(star => {
        if (star.userData.name !== 'Солнце') connectionsGroup.add(createConnectionLine(star));
      });
    }

    let camTarget = new THREE.Vector3(0, 20, 100);
    let viewTarget = new THREE.Vector3(0, 0, 0);
    let interacting = false;

    function calculateOptimalCamera() {
      if (!activeStars.length) return;
      let maxRadius = 0, minX = Infinity, maxX = -Infinity;
      activeStars.forEach(star => {
        const r = star.userData.visualRadius, x = star.userData.tx || 0;
        maxRadius = Math.max(maxRadius, r);
        minX = Math.min(minX, x - r); maxX = Math.max(maxX, x + r);
      });
      const totalWidth = maxX - minX, centerX = (minX + maxX) / 2;
      const fovRad = camera.fov * Math.PI / 180;
      let optimalDistance = Math.max((totalWidth / 2) / Math.tan(fovRad / 2) / camera.aspect, maxRadius * 3 / Math.tan(fovRad / 2)) * 1.4;
      optimalDistance = Math.max(Math.min(optimalDistance, 40000), maxRadius * 4);
      return { position: new THREE.Vector3(centerX, maxRadius * 0.3, optimalDistance), target: new THREE.Vector3(centerX, 0, 0),
        minDist: Math.max(maxRadius * 0.3, 1), maxDist: Math.max(optimalDistance * 4, 2000) };
    }

    function updateLayout() {
      if (!activeStars.length) return;
      
      if (spaceViewMode) {
        activeStars.forEach(star => {
          const g = star.userData.galactic;
          if (g && g.dist > 0) {
            const pos = galacticToCartesian(g.l, g.b, g.dist);
            star.userData.tx = pos.x; star.userData.ty = pos.y; star.userData.tz = pos.z;
          } else { star.userData.tx = star.userData.ty = star.userData.tz = 0; }
        });
        let maxDist = 0;
        activeStars.forEach(star => {
          maxDist = Math.max(maxDist, Math.sqrt(star.userData.tx ** 2 + star.userData.ty ** 2 + star.userData.tz ** 2));
        });
        viewTarget.set(0, 0, 0);
        const camDist = Math.min(Math.max(maxDist * 1.2, 80), 600);
        camTarget.set(camDist * 0.2, camDist * 0.3, camDist);
        controls.minDistance = 5; controls.maxDistance = 2000;
        updateConnections();
      } else {
        const sortFn = { luminosity: (a, b) => b.userData.luminosity - a.userData.luminosity,
          mass: (a, b) => b.userData.mass - a.userData.mass, temp: (a, b) => b.userData.temperature - a.userData.temperature
        }[compareMode] || ((a, b) => b.userData.radius - a.userData.radius);
        activeStars.sort(sortFn);
        
        let x = 0;
        activeStars.forEach((star, i) => {
          if (i > 0) {
            const gap = Math.max((activeStars[i - 1].userData.visualRadius + star.userData.visualRadius) * 0.4, 8);
            x += activeStars[i - 1].userData.visualRadius + star.userData.visualRadius + gap;
          }
          star.userData.tx = x; star.userData.ty = star.userData.tz = 0;
        });
        const totalWidth = x;
        activeStars.forEach(star => star.userData.tx -= totalWidth / 2);
        
        const camData = calculateOptimalCamera();
        if (camData) {
          camTarget.copy(camData.position); viewTarget.copy(camData.target);
          controls.minDistance = camData.minDist; controls.maxDistance = camData.maxDist;
        }
        while (connectionsGroup.children.length > 0) connectionsGroup.remove(connectionsGroup.children[0]);
      }
      interacting = false;
      updateSizeIndicator();
    }

    function updateStarSizes() {
      activeStars.forEach(star => {
        const d = star.userData;
        const visualRadius = calculateVisualRadius(d, realScaleMode);
        d.visualRadius = visualRadius;
        
        d.starMesh.geometry.dispose(); d.starMesh.geometry = new THREE.SphereGeometry(visualRadius, 128, 128);
        d.starMesh.material.uniforms.starRadius.value = visualRadius;
        d.innerCorona.geometry.dispose(); d.innerCorona.geometry = new THREE.SphereGeometry(visualRadius * 1.12, 64, 64);
        d.outerCorona.geometry.dispose(); d.outerCorona.geometry = new THREE.SphereGeometry(visualRadius * 1.25, 48, 48);
        d.atmosphericGlow.geometry.dispose(); d.atmosphericGlow.geometry = new THREE.SphereGeometry(visualRadius * 1.4, 32, 32);
        if (d.prominences) { d.prominences.geometry.dispose(); d.prominences.geometry = new THREE.SphereGeometry(visualRadius * 1.3, 48, 48); }
        d.glowSprite.scale.set(visualRadius * 3, visualRadius * 3, 1);
        d.raysSprite.scale.set(visualRadius * 4, visualRadius * 4, 1);
        d.light.distance = visualRadius * 20;
        
        if (spaceViewMode) { d.labelSprite.scale.set(16, 8, 1); d.labelSprite.position.y = visualRadius + 4; }
        else { d.labelSprite.scale.set(visualRadius * 5, visualRadius * 2.5, 1); d.labelSprite.position.y = visualRadius * 1.8; }
        d.labelSprite.visible = spaceViewMode;
      });
      updateLayout();
    }

    function updateSizeIndicator() {
      const indicator = document.getElementById('sizeIndicator'), text = document.getElementById('sizeText');
      if (spaceViewMode) {
        indicator.classList.add('visible');
        const distances = activeStars.filter(s => s.userData.distance > 0).map(s => s.userData.distance);
        text.textContent = distances.length > 0 ? `Расстояния: ${Math.min(...distances).toFixed(1)} — ${Math.max(...distances).toFixed(0)} св. лет` : 'Галактические координаты';
        return;
      }
      if (activeStars.length > 0) {
        indicator.classList.add('visible');
        const largest = activeStars.reduce((a, b) => a.userData.radius > b.userData.radius ? a : b);
        const smallest = activeStars.reduce((a, b) => a.userData.radius < b.userData.radius ? a : b);
        text.textContent = { size: `${largest.userData.name}: ${largest.userData.radius}☉ | ${smallest.userData.name}: ${smallest.userData.radius}☉`,
          luminosity: `Макс: ${largest.userData.luminosity.toLocaleString()} L☉`, mass: `Макс: ${largest.userData.mass.toFixed(1)} M☉`,
          temp: `Макс: ${largest.userData.temperature.toLocaleString()} K` }[compareMode];
      } else indicator.classList.remove('visible');
    }

    // Public functions
    window.addStar = (key) => {
      if (addedKeys.has(key)) return;
      const star = createStar(key);
      star.scale.set(0, 0, 0);
      starsGroup.add(star); activeStars.push(star); addedKeys.add(key);
      updateLayout(); updateUI();
      let t = 0;
      (function anim() { t += 0.04; star.scale.setScalar(1 - Math.pow(1 - Math.min(t, 1), 3)); if (t < 1) requestAnimationFrame(anim); })();
    };

    window.removeStar = (key) => {
      const star = activeStars.find(s => s.userData.name === key);
      if (!star) return;
      let t = 1;
      (function anim() {
        t -= 0.06; star.scale.setScalar(Math.pow(Math.max(t, 0), 2));
        if (t > 0) requestAnimationFrame(anim);
        else { starsGroup.remove(star); activeStars = activeStars.filter(s => s !== star); addedKeys.delete(key); updateLayout(); updateUI(); }
      })();
    };

    window.clearAll = () => [...activeStars].forEach(star => window.removeStar(star.userData.name));
    window.toggleRealScale = () => { realScaleMode = !realScaleMode; document.getElementById('btnRealScale').classList.toggle('active', realScaleMode); updateStarSizes(); };
    window.toggleSpaceView = () => {
      spaceViewMode = !spaceViewMode;
      document.getElementById('btnSpaceView').classList.toggle('active', spaceViewMode);
      document.getElementById('comparePanel').classList.toggle('hidden', spaceViewMode);
      document.getElementById('spaceInfo').classList.toggle('visible', spaceViewMode);
      const scaleBtn = document.getElementById('btnRealScale');
      scaleBtn.style.opacity = spaceViewMode ? '0.5' : '1';
      scaleBtn.style.pointerEvents = spaceViewMode ? 'none' : 'auto';
      updateStarSizes(); updateLayout();
    };
    window.setCompareMode = (mode) => { compareMode = mode; document.querySelectorAll('.compare-btn').forEach(btn => btn.classList.toggle('active', btn.dataset.mode === mode)); updateStarSizes(); updateLayout(); };
    window.toggleBackground = () => {
      showGalaxyBackground = !showGalaxyBackground;
      document.getElementById('btnBgToggle').classList.toggle('active', !showGalaxyBackground);
      if (showGalaxyBackground) { skyboxMilkyWay.visible = isDark; stars.visible = isDark; scene.background = null; }
      else { skyboxMilkyWay.visible = stars.visible = false; scene.background = new THREE.Color(0x000000); }
    };
    window.toggleTheme = () => {
      isDark = !isDark;
      document.body.dataset.theme = isDark ? 'dark' : 'light';
      document.querySelector('.theme-btn .icon-moon').style.display = isDark ? 'block' : 'none';
      document.querySelector('.theme-btn .icon-sun').style.display = isDark ? 'none' : 'block';
      if (isDark) { if (showGalaxyBackground) { skyboxMilkyWay.visible = stars.visible = true; scene.background = null; } else scene.background = new THREE.Color(0x000000); bloomPass.strength = 1.2; }
      else { scene.background = new THREE.Color(0xf0f4f8); skyboxMilkyWay.visible = stars.visible = false; bloomPass.strength = 0.4; }
    };
    window.clearCache = () => { if (confirm('Очистить все данные приложения?')) { localStorage.clear(); location.reload(); } };
    window.closeModal = () => document.getElementById('modal').classList.remove('visible');

    // UI setup
    const box = document.getElementById('starBtns');
    Object.keys(STARS).sort((a, b) => a === 'Солнце' ? -1 : b === 'Солнце' ? 1 : a.localeCompare(b, 'ru')).forEach(key => {
      const d = STARS[key], btn = document.createElement('div');
      btn.className = 'chip'; btn.dataset.s = key;
      btn.innerHTML = `<span class="color-dot" style="background:${d.color};box-shadow:0 0 4px ${d.color};"></span>${key}`;
      btn.onclick = () => addedKeys.has(key) ? window.removeStar(key) : window.addStar(key);
      box.appendChild(btn);
    });

    function updateUI() { document.querySelectorAll('.chip').forEach(c => c.classList.toggle('active', addedKeys.has(c.dataset.s))); }

    window.addStar('Солнце');

    // Raycaster
    const ray = new THREE.Raycaster(), mouse = new THREE.Vector2();
    window.addEventListener('dblclick', e => {
      mouse.x = (e.clientX / innerWidth) * 2 - 1; mouse.y = -(e.clientY / innerHeight) * 2 + 1;
      ray.setFromCamera(mouse, camera);
      const hits = ray.intersectObjects(starsGroup.children, true);
      if (hits.length) {
        const seen = new Set(), hitStars = [];
        hits.forEach(hit => { let obj = hit.object; while (obj.parent && obj.parent !== starsGroup) obj = obj.parent;
          if (obj.userData?.name && !seen.has(obj.uuid)) { hitStars.push(obj); seen.add(obj.uuid); } });
        if (hitStars.length) {
          hitStars.sort((a, b) => a.userData.visualRadius - b.userData.visualRadius);
          const d = hitStars[0].userData, i = d.info || {};
          document.getElementById('mTitle').textContent = d.name;
          document.getElementById('mType').textContent = d.type;
          document.getElementById('mConstellation').textContent = d.constellation !== '—' ? `Созвездие: ${d.constellation}` : '';
          const preview = document.getElementById('mPreview');
          preview.style.background = `radial-gradient(circle,${d.color} 0%,${d.coronaColor} 50%,transparent 100%)`;
          preview.style.setProperty('--star-color', d.coronaColor);
          document.getElementById('mStats').innerHTML = `
            <div class="stat"><h4>Диаметр</h4><p>${i.diameter||'-'}</p><span class="sub">${i.diamSun||'-'} ☉</span></div>
            <div class="stat"><h4>Масса</h4><p>${i.mass||'-'}</p><span class="sub">${i.massSun||'-'} M☉</span></div>
            <div class="stat"><h4>Светимость</h4><p>${i.luminosity||'-'}</p><span class="sub">${i.lumSun||'-'} L☉</span></div>
            <div class="stat"><h4>Температура</h4><p>${i.temperature||'-'}</p><span class="sub">${i.tempClass||'-'}</span></div>
            <div class="stat"><h4>Плотность</h4><p>${i.density||'-'}</p></div>
            <div class="stat"><h4>Гравитация</h4><p>${i.gravity||'-'}</p></div>
            <div class="stat"><h4>Вращение</h4><p>${i.rotation||'-'}</p></div>
            <div class="stat"><h4>Возраст</h4><p>${i.age||'-'}</p></div>
            <div class="stat"><h4>Расстояние</h4><p>${i.dist||'-'}</p></div>
            <div class="stat"><h4>Состав</h4><p>${i.composition||'-'}</p></div>
            <div class="stat"><h4>Спектр</h4><p>${d.spectralClass||'-'}</p></div>
            <div class="stat"><h4>Вид. величина</h4><p>${d.apparentMagnitude!==undefined?d.apparentMagnitude:'—'}</p><span class="sub">mag</span></div>`;
          document.getElementById('mFact').textContent = d.facts?.length ? d.facts[Math.floor(Math.random() * d.facts.length)] : 'Нет данных';
          document.getElementById('modal').classList.add('visible');
        }
      }
    });

    controls.addEventListener('start', () => interacting = true);

    const titleH1 = document.querySelector('.app-title h1'), titleSpan = document.querySelector('.app-title span');
    const defaultTitle = titleH1.textContent, defaultSub = titleSpan.textContent;
    let hoveredObj = null;

    window.addEventListener('mousemove', e => {
      mouse.x = (e.clientX / innerWidth) * 2 - 1; mouse.y = -(e.clientY / innerHeight) * 2 + 1;
      ray.setFromCamera(mouse, camera);
      const hits = ray.intersectObjects(starsGroup.children, true);
      if (hits.length) {
        const seen = new Set(), hitStars = [];
        hits.forEach(hit => { let obj = hit.object; while (obj.parent && obj.parent !== starsGroup) obj = obj.parent;
          if (obj.userData?.name && !seen.has(obj.uuid)) { hitStars.push(obj); seen.add(obj.uuid); } });
        if (hitStars.length) {
          hitStars.sort((a, b) => a.userData.visualRadius - b.userData.visualRadius);
          const targetObj = hitStars[0];
          if (hoveredObj !== targetObj) {
            hoveredObj = targetObj; const d = targetObj.userData;
            titleH1.textContent = d.name; titleH1.style.color = d.color; titleH1.style.textShadow = `0 0 20px ${d.color}`;
            titleH1.style.background = 'none'; titleH1.style.webkitTextFillColor = 'initial';
            titleSpan.textContent = `${d.type}${d.spectralClass ? ` (${d.spectralClass})` : ''}`;
            titleSpan.style.color = '#ffffff';
            document.body.style.cursor = 'pointer';
          }
          return;
        }
      }
      if (hoveredObj) {
        hoveredObj = null; titleH1.textContent = defaultTitle; titleSpan.textContent = defaultSub;
        titleH1.style.background = 'linear-gradient(135deg,#ffffff 0%,#88aaff 50%,#ffaa66 100%)';
        titleH1.style.webkitBackgroundClip = 'text'; titleH1.style.webkitTextFillColor = 'transparent';
        titleH1.style.textShadow = 'none'; titleH1.style.color = 'transparent';
        titleSpan.style.color = 'var(--accent)';
        document.body.style.cursor = 'default';
      }
    });

    function animate(time) {
      requestAnimationFrame(animate);
      const t = time * 0.001;
      if (!interacting) { camera.position.lerp(camTarget, 0.025); controls.target.lerp(viewTarget, 0.025); }
      skyboxMilkyWay.rotation.y = t * 0.002; stars.rotation.y = t * 0.0015;
      
      activeStars.forEach(star => {
        star.position.x += (star.userData.tx - star.position.x) * 0.08;
        star.position.y += ((star.userData.ty || 0) - star.position.y) * 0.08;
        star.position.z += ((star.userData.tz || 0) - star.position.z) * 0.08;
        const viewVec = camera.position.clone().sub(star.position).normalize();
        if (star.userData.starMesh.material.uniforms) star.userData.starMesh.material.uniforms.time.value = t;
        if (star.userData.innerCorona.material.uniforms) { star.userData.innerCorona.material.uniforms.time.value = t; star.userData.innerCorona.material.uniforms.viewVector.value = viewVec; }
        if (star.userData.outerCorona.material.uniforms) { star.userData.outerCorona.material.uniforms.time.value = t; star.userData.outerCorona.material.uniforms.viewVector.value = viewVec; }
        if (star.userData.atmosphericGlow.material.uniforms) { star.userData.atmosphericGlow.material.uniforms.time.value = t; star.userData.atmosphericGlow.material.uniforms.viewVector.value = viewVec; }
        if (star.userData.prominences?.material.uniforms) star.userData.prominences.material.uniforms.time.value = t;
        const pulseScale = 1 + Math.sin(t * (0.3 + star.userData.starType * 0.2) + star.userData.radius * 0.1) * (0.03 + star.userData.starType * 0.02);
        star.userData.glowSprite.scale.set(star.userData.visualRadius * 3 * pulseScale, star.userData.visualRadius * 3 * pulseScale, 1);
        star.userData.raysSprite.scale.set(star.userData.visualRadius * 4 * pulseScale, star.userData.visualRadius * 4 * pulseScale, 1);
        star.userData.raysSprite.material.rotation = t * 0.02 * star.userData.rotationSpeed;
      });

      if (spaceViewMode) connectionsGroup.children.forEach(line => {
        const star = activeStars.find(s => s.userData.name === line.userData.starName);
        if (star) { const pos = line.geometry.attributes.position.array; pos[3] = star.position.x; pos[4] = star.position.y; pos[5] = star.position.z;
          line.geometry.attributes.position.needsUpdate = true; line.computeLineDistances(); }
      });
      
      controls.update(); composer.render();
    }

    window.addEventListener('resize', () => { camera.aspect = innerWidth / innerHeight; camera.updateProjectionMatrix();
      renderer.setSize(innerWidth, innerHeight); composer.setSize(innerWidth, innerHeight); });

    animate(0);
  </script>
</body>
</html>