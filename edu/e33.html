<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no, maximum-scale=1.0" />
  <title>Планеты</title>
  <link rel="icon" href="solar-system.png" type="image/png" />
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&family=Jura:wght@400;500;600;700&display=swap" rel="stylesheet">

  <style>
    :root {
      --bg-color: #030305;
      --panel-bg: rgba(15, 15, 25, 0.75);
      --panel-border: rgba(255, 255, 255, 0.12);
      --text-main: #ffffff;
      --text-sec: #94a3b8;
      --accent: #f59e0b;
      --accent-glow: rgba(245, 158, 11, 0.4);
      --btn-bg: rgba(255, 255, 255, 0.07);
      --btn-hover: rgba(255, 255, 255, 0.18);
      --font-display: 'Jura', sans-serif;
      --font-body: 'Inter', sans-serif;
    }

    [data-theme="light"] {
      --bg-color: #f8fafc;
      --panel-bg: rgba(255, 255, 255, 0.85);
      --panel-border: rgba(0, 0, 0, 0.08);
      --text-main: #0f172a;
      --text-sec: #64748b;
      --accent: #ea580c;
      --accent-glow: rgba(234, 88, 12, 0.2);
      --btn-bg: rgba(0, 0, 0, 0.04);
      --btn-hover: rgba(0, 0, 0, 0.08);
    }

    * { margin: 0; padding: 0; box-sizing: border-box; -webkit-tap-highlight-color: transparent; }

    html, body {
      width: 100%; height: 100%; overflow: hidden;
      background: var(--bg-color);
      font-family: var(--font-body);
      color: var(--text-main);
      transition: background 0.5s ease, color 0.5s ease;
    }

    canvas { display: block; outline: none; z-index: 1; }

    #ui-layer {
      position: absolute; inset: 0; z-index: 10; pointer-events: none;
      display: flex; flex-direction: column; justify-content: space-between;
      padding: 24px;
    }

    .top-bar {
      pointer-events: auto;
      display: flex; justify-content: space-between; align-items: flex-start;
    }

    .app-title h1 {
      font-family: var(--font-display); font-weight: 700; font-size: 28px;
      letter-spacing: 2px; text-transform: uppercase;
      background: linear-gradient(135deg, var(--text-main), var(--text-sec));
      -webkit-background-clip: text; -webkit-text-fill-color: transparent;
    }
    .app-title span { font-size: 11px; color: var(--accent); letter-spacing: 4px; text-transform: uppercase; font-weight: 700; }

    .controls-right {
      display: flex; gap: 12px; align-items: center;
    }

    .icon-btn {
      width: 44px; height: 44px; border-radius: 50%;
      background: var(--panel-bg); border: 1px solid var(--panel-border);
      backdrop-filter: blur(12px); -webkit-backdrop-filter: blur(12px);
      display: flex; align-items: center; justify-content: center;
      cursor: pointer; color: var(--text-main);
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      box-shadow: 0 4px 20px rgba(0,0,0,0.1);
    }
    .icon-btn:hover { transform: scale(1.1); background: var(--btn-hover); color: var(--accent); }
    .icon-btn svg { width: 22px; height: 22px; fill: none; stroke: currentColor; stroke-width: 2; }

    .delete-btn:hover { 
      color: #ff4444; 
      border-color: rgba(255, 68, 68, 0.3);
      box-shadow: 0 4px 20px rgba(255, 68, 68, 0.2);
    }

    .toggle-btn {
      height: 44px; padding: 0 20px; border-radius: 22px;
      background: var(--panel-bg); border: 1px solid var(--panel-border);
      color: var(--text-sec); font-family: var(--font-display);
      font-size: 12px; font-weight: 600; text-transform: uppercase; letter-spacing: 1px;
      cursor: pointer; display: flex; align-items: center; gap: 8px;
      backdrop-filter: blur(12px); transition: all 0.3s;
    }
    .toggle-btn:hover { background: var(--btn-hover); color: var(--text-main); }
    .toggle-btn.active { 
      border-color: var(--accent); 
      color: var(--accent); 
      background: rgba(245, 158, 11, 0.1);
      box-shadow: 0 0 15px var(--accent-glow);
    }
    .toggle-indicator {
      width: 8px; height: 8px; border-radius: 50%; background: currentColor;
      box-shadow: 0 0 8px currentColor;
    }

    .dock-wrapper {
      pointer-events: auto;
      align-self: center; width: 100%; max-width: 950px;
      display: flex; justify-content: center;
      transition: opacity 0.3s, transform 0.3s;
    }
    
    .dock-wrapper.hidden {
      opacity: 0.3;
      pointer-events: none;
      transform: translateY(20px);
    }

    .dock {
      background: var(--panel-bg);
      backdrop-filter: blur(20px); -webkit-backdrop-filter: blur(20px);
      border: 1px solid var(--panel-border);
      padding: 12px 20px; border-radius: 28px;
      display: flex; gap: 16px; align-items: center;
      box-shadow: 0 20px 50px -10px rgba(0,0,0,0.3);
      transition: all 0.3s ease;
    }

    .reset-btn {
      width: 48px; height: 48px; flex-shrink: 0;
      border-radius: 16px; background: var(--btn-bg);
      border: 1px solid var(--panel-border); color: var(--text-sec);
      display: flex; align-items: center; justify-content: center;
      cursor: pointer; transition: all 0.3s;
    }
    .reset-btn:hover {
      background: linear-gradient(135deg, #f59e0b, #d97706); 
      color: white; border-color: transparent;
      box-shadow: 0 0 25px rgba(245, 158, 11, 0.5);
      transform: translateY(-2px) rotate(90deg);
    }
    .reset-btn svg { width: 26px; height: 26px; stroke-width: 1.5; }

    .divider { width: 1px; height: 32px; background: var(--panel-border); margin: 0 4px; }

    .planet-scroll {
      display: flex; gap: 8px; overflow-x: auto; padding: 4px;
      -ms-overflow-style: none; scrollbar-width: none; 
      mask-image: linear-gradient(90deg, transparent, black 15px, black calc(100% - 15px), transparent);
      -webkit-mask-image: linear-gradient(90deg, transparent, black 15px, black calc(100% - 15px), transparent);
    }
    .planet-scroll::-webkit-scrollbar { display: none; }

    .chip {
      padding: 10px 20px; border-radius: 14px;
      background: var(--btn-bg); color: var(--text-sec);
      font-family: var(--font-display); font-size: 13px; font-weight: 600;
      cursor: pointer; white-space: nowrap; border: 1px solid transparent;
      transition: all 0.2s; user-select: none; letter-spacing: 0.5px;
    }
    .chip:hover { background: var(--btn-hover); color: var(--text-main); transform: translateY(-2px); }
    .chip.active {
      background: rgba(245, 158, 11, 0.15); color: var(--accent);
      border-color: rgba(245, 158, 11, 0.4);
      box-shadow: 0 4px 20px var(--accent-glow);
    }

    .modal {
      position: fixed; inset: 0; z-index: 100;
      background: rgba(0,0,0,0.1); backdrop-filter: blur(8px);
      opacity: 0; visibility: hidden; transition: all 0.3s;
      display: flex; align-items: center; justify-content: center;
    }
    .modal.visible { opacity: 1; visibility: visible; }

    .card {
      width: 95%; 
      max-width: 700px;
      background: var(--bg-color); color: var(--text-main);
      border: 1px solid var(--panel-border);
      border-radius: 32px; padding: 40px;
      box-shadow: 0 40px 80px -20px rgba(0,0,0,0.5);
      transform: translateY(30px) scale(0.95); transition: all 0.5s cubic-bezier(0.19, 1, 0.22, 1);
      max-height: 90vh; overflow-y: auto;
    }
    
    .modal.visible .card { transform: translateY(0) scale(1); }

    .card h2 { font-family: var(--font-display); font-size: 42px; margin-bottom: 4px; line-height: 1; font-weight: 400; }
    .card .type { color: var(--accent); font-size: 11px; text-transform: uppercase; letter-spacing: 3px; font-weight: 700; margin-bottom: 30px; }
    
    .stats { 
      display: grid; 
      grid-template-columns: repeat(3, 1fr);
      gap: 20px 16px; 
      margin-bottom: 24px; 
    }
    
    .stat h4 { 
      font-size: 10px; text-transform: uppercase; 
      color: var(--text-sec); margin-bottom: 4px; letter-spacing: 1px; 
    }
    .stat p { 
      font-family: var(--font-display); 
      font-size: 15px; font-weight: 600; 
      color: var(--text-main);
    }
    .stat span.sub {
      display: block; font-size: 11px; 
      color: var(--text-sec); font-weight: 400; margin-top: 2px;
    }
    
    .fact { font-size: 14px; line-height: 1.7; color: var(--text-sec); padding-top: 24px; border-top: 1px solid var(--panel-border); }
    .close-modal {
      position: absolute; top: 24px; right: 24px; width: 36px; height: 36px;
      background: var(--btn-bg); border: none; border-radius: 50%; color: var(--text-sec);
      cursor: pointer; display: flex; align-items: center; justify-content: center; transition: 0.2s;
    }
    .close-modal:hover { background: var(--btn-hover); color: var(--text-main); }

    @media (max-width: 768px) {
      .dock { flex-direction: column-reverse; padding: 16px; width: 100%; border-radius: 24px; gap: 16px; }
      .dock-wrapper { max-width: 100%; }
      .planet-scroll { width: 100%; justify-content: flex-start; mask-image: none; -webkit-mask-image: none; }
      .divider { display: none; }
      .reset-btn { width: 100%; height: 50px; border-radius: 14px; }
      .top-bar { margin-bottom: 20px; flex-wrap: wrap; gap: 12px; }
      #ui-layer { padding: 16px; }
      .card h2 { font-size: 32px; }
      .controls-right { flex-wrap: wrap; }
    }
    
    @media (max-width: 600px) {
      .stats { grid-template-columns: 1fr 1fr; }
      .card { padding: 24px; width: 100%; border-radius: 24px 24px 0 0; bottom: 0; top: auto; transform: translateY(100%); position: absolute;}
      .modal.visible .card { transform: translateY(0); }
      .toggle-btn span { display: none; }
      .toggle-btn { padding: 0 14px; }
    }
  </style>
</head>
<body data-theme="dark">

  <div id="ui-layer">
    <div class="top-bar">
      <div class="app-title">
        <h1>Планеты</h1>
        <span>Солнечной системы</span>
      </div>
      
      <div class="controls-right">
        <button class="toggle-btn" id="btnOverview" onclick="toggleOverview()" title="Обзор всей системы">
          <div class="toggle-indicator"></div>
          <span>Обзор</span>
          <svg viewBox="0 0 24 24" width="18" height="18" fill="none" stroke="currentColor" stroke-width="1.5">
            <circle cx="12" cy="12" r="2"></circle>
            <circle cx="12" cy="12" r="6" opacity="0.5"></circle>
            <circle cx="12" cy="12" r="10" opacity="0.3"></circle>
          </svg>
        </button>

        <button class="toggle-btn active" id="btnMW" onclick="toggleMilkyWay()" title="Вкл/Выкл Галактику">
          <div class="toggle-indicator"></div>
          <span>Галактика</span>
        </button>

        <button class="icon-btn theme-btn" onclick="toggleTheme()" title="Сменить тему">
          <svg class="icon-moon" viewBox="0 0 24 24" style="display:block"><path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path></svg>
          <svg class="icon-sun" viewBox="0 0 24 24" style="display:none"><circle cx="12" cy="12" r="5"></circle><line x1="12" y1="1" x2="12" y2="3"></line><line x1="12" y1="21" x2="12" y2="23"></line><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line><line x1="1" y1="12" x2="3" y2="12"></line><line x1="21" y1="12" x2="23" y2="12"></line><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line></svg>
        </button>

        <button class="icon-btn delete-btn" onclick="clearTextureCache()" title="Удалить кэшированные данные">
          <svg viewBox="0 0 24 24">
            <ellipse cx="12" cy="5" rx="9" ry="3"></ellipse>
            <path d="M21 12c0 1.66-4 3-9 3s-9-1.34-9-3"></path>
            <path d="M3 5v14c0 1.66 4 3 9 3 1.2 0 2.33-.08 3.39-.23"></path>
            <line x1="21" y1="21" x2="17" y2="17" stroke-width="2.5"></line>
            <line x1="17" y1="21" x2="21" y2="17" stroke-width="2.5"></line>
          </svg>
        </button>
      </div>
    </div>

    <div class="dock-wrapper" id="dockWrapper">
      <div class="dock">
        <button class="reset-btn" onclick="clearAll()" title="Сбросить систему">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor">
            <circle cx="12" cy="12" r="4"></circle>
            <path d="M12 2v2"></path><path d="M12 20v2"></path>
            <path d="M4.93 4.93l1.41 1.41"></path><path d="M17.66 17.66l1.41 1.41"></path>
            <path d="M2 12h2"></path><path d="M20 12h2"></path>
            <path d="M6.34 17.66l-1.41 1.41"></path><path d="M19.07 4.93l-1.41 1.41"></path>
          </svg>
        </button>
        <div class="divider"></div>
        <div class="planet-scroll" id="planetBtns"></div>
      </div>
    </div>
  </div>

  <div class="modal" id="modal">
    <div class="card">
      <button class="close-modal" onclick="closeModal()">×</button>
      <h2 id="mTitle">Планета</h2>
      <div class="type" id="mType">Тип</div>
      <div class="stats" id="mStats"></div>
      <p class="fact" id="mFact">...</p>
    </div>
  </div>

  <script type="importmap">
    { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js", "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/" } }
  </script>

  <script type="module">
    import * as THREE from "three";
    import { OrbitControls } from "three/addons/controls/OrbitControls.js";
    import { UnrealBloomPass } from "three/addons/postprocessing/UnrealBloomPass.js";
    import { EffectComposer } from "three/addons/postprocessing/EffectComposer.js";
    import { RenderPass } from "three/addons/postprocessing/RenderPass.js";
    import { PLANETS_DATA } from './planets.js';
    
    const PLANETS = PLANETS_DATA;

    // Орбитальные данные планет (J2000 эпоха)
  const ORBITAL_ELEMENTS = {
  'Меркурий': { semiMajorAU: 0.387, eccentricity: 0.206, periodDays: 87.97, L0: 252.25, periLong: 77.46 },
  'Венера':   { semiMajorAU: 0.723, eccentricity: 0.007, periodDays: 224.70, L0: 181.98, periLong: 131.53 },
  'Земля':    { semiMajorAU: 1.000, eccentricity: 0.017, periodDays: 365.25, L0: 100.46, periLong: 102.94 },
  'Марс':     { semiMajorAU: 1.524, eccentricity: 0.093, periodDays: 686.98, L0: 355.45, periLong: 336.04 },
  'Юпитер':   { semiMajorAU: 5.203, eccentricity: 0.049, periodDays: 4332.59, L0: 34.40, periLong: 14.75 },
  'Сатурн':   { semiMajorAU: 9.537, eccentricity: 0.054, periodDays: 10759.22, L0: 49.94, periLong: 92.43 },
  'Уран':     { semiMajorAU: 19.191, eccentricity: 0.047, periodDays: 30688.5, L0: 313.23, periLong: 170.96 },
  'Нептун':   { semiMajorAU: 30.069, eccentricity: 0.009, periodDays: 60182.0, L0: 304.88, periLong: 44.97 },
  'Плутон':   { semiMajorAU: 39.482, eccentricity: 0.249, periodDays: 90560.0, L0: 238.93, periLong: 224.07 }
};

    const J2000_EPOCH = new Date(Date.UTC(2000, 0, 1, 12, 0, 0));
    
    let planetLabels = [];
    let hoveredPlanet = null;

    function daysSinceJ2000(date = new Date()) {
      return (date.getTime() - J2000_EPOCH.getTime()) / (1000 * 60 * 60 * 24);
    }

    function calculatePlanetAngle(planetName, date = new Date()) {
      const elem = ORBITAL_ELEMENTS[planetName];
      if (!elem) return 0;

      const days = daysSinceJ2000(date);
      const meanAnomaly = ((elem.L0 + (360 / elem.periodDays) * days - elem.periLong) % 360) * Math.PI / 180;
      
      // Решение уравнения Кеплера итерационно
      let E = meanAnomaly;
      for (let i = 0; i < 10; i++) {
        E = meanAnomaly + elem.eccentricity * Math.sin(E);
      }
      
      // Истинная аномалия
      const trueAnomaly = 2 * Math.atan2(
        Math.sqrt(1 + elem.eccentricity) * Math.sin(E / 2),
        Math.sqrt(1 - elem.eccentricity) * Math.cos(E / 2)
      );
      
      return trueAnomaly + (elem.periLong * Math.PI / 180);
    }

    // IndexedDB для кэширования текстур
    const DB_NAME = 'SolarisDB';
    const STORE_NAME = 'textures';
    
    const dbPromise = new Promise((resolve, reject) => {
      const request = indexedDB.open(DB_NAME, 1);
      request.onupgradeneeded = (e) => e.target.result.createObjectStore(STORE_NAME);
      request.onsuccess = (e) => resolve(e.target.result);
      request.onerror = (e) => reject(e);
    });

    const textureLoader = new THREE.TextureLoader();

    function loadTextureWithCache(url) {
      const texture = new THREE.Texture();
      const image = new Image();
      image.crossOrigin = "Anonymous";
      
      image.onload = () => {
        texture.image = image;
        texture.needsUpdate = true;
      };

      dbPromise.then(db => {
        const tx = db.transaction(STORE_NAME, 'readonly');
        const store = tx.objectStore(STORE_NAME);
        const request = store.get(url);

        request.onsuccess = () => {
          if (request.result) {
            image.src = URL.createObjectURL(request.result);
          } else {
            fetch(url)
              .then(res => res.blob())
              .then(blob => {
                const txWrite = db.transaction(STORE_NAME, 'readwrite');
                txWrite.objectStore(STORE_NAME).put(blob, url);
                image.src = URL.createObjectURL(blob);
              })
              .catch(() => {
                textureLoader.load(url, (t) => {
                  texture.image = t.image;
                  texture.needsUpdate = true;
                });
              });
          }
        };
      }).catch(() => {
        textureLoader.load(url, (t) => {
          texture.image = t.image;
          texture.needsUpdate = true;
        });
      });

      return texture;
    }

    window.clearTextureCache = () => {
      const req = indexedDB.deleteDatabase(DB_NAME);
      req.onsuccess = () => { alert('Кэш успешно очищен!'); location.reload(); };
      req.onerror = () => alert('Ошибка очистки кэша');
    };

    const BASE_SCALE = 1 / 4000;

    // Инициализация Three.js
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(45, innerWidth / innerHeight, 0.1, 100000);
    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(innerWidth, innerHeight);
    renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.4;
    document.body.appendChild(renderer.domElement);

    const composer = new EffectComposer(renderer);
    composer.addPass(new RenderPass(scene, camera));
    const bloomPass = new UnrealBloomPass(new THREE.Vector2(innerWidth, innerHeight), 1.2, 0.4, 0.85);
    composer.addPass(bloomPass);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;
    controls.minDistance = 20;
    controls.maxDistance = 60000;
    controls.zoomSpeed = 0.3;
    controls.rotateSpeed = 0.5;
    controls.enablePan = false;

    // Освещение
    const ambLight = new THREE.AmbientLight(0xffffff, 0.7);
    scene.add(ambLight);

    const hemiLight = new THREE.HemisphereLight(0xddeeff, 0x0f0e0d, 0.6);
    scene.add(hemiLight);

    const sunLight = new THREE.PointLight(0xffffff, 3.5, 0, 1);
    sunLight.position.set(100, 30, 80);
    scene.add(sunLight);

    // Скайбокс Млечного пути
    const skyboxGeo = new THREE.SphereGeometry(60000, 64, 64);
    const skyboxMat = new THREE.MeshBasicMaterial({
      map: loadTextureWithCache('textures/milkyway.jpg'),
      side: THREE.BackSide,
      transparent: true,
      opacity: 0.8,
      depthWrite: false
    });
    const skyboxMilkyWay = new THREE.Mesh(skyboxGeo, skyboxMat);
    skyboxMilkyWay.renderOrder = -1;
    scene.add(skyboxMilkyWay);

    // Звёздное поле
    function createStarfield() {
      const count = 6000;
      const geo = new THREE.BufferGeometry();
      const pos = new Float32Array(count * 3);
      const colors = new Float32Array(count * 3);
      
      for (let i = 0; i < count; i++) {
        const r = 5000 + Math.random() * 5000;
        const theta = Math.random() * Math.PI * 2;
        const phi = Math.acos(2 * Math.random() - 1);
        pos[i * 3] = r * Math.sin(phi) * Math.cos(theta);
        pos[i * 3 + 1] = r * Math.cos(phi);
        pos[i * 3 + 2] = r * Math.sin(phi) * Math.sin(theta);
        const c = new THREE.Color().setHSL(0.6, 0.2, 0.8 + Math.random() * 0.2);
        colors[i * 3] = c.r;
        colors[i * 3 + 1] = c.g;
        colors[i * 3 + 2] = c.b;
      }
      
      geo.setAttribute('position', new THREE.BufferAttribute(pos, 3));
      geo.setAttribute('color', new THREE.BufferAttribute(colors, 3));
      
      const canvas = document.createElement('canvas');
      canvas.width = 32;
      canvas.height = 32;
      const ctx = canvas.getContext('2d');
      const grad = ctx.createRadialGradient(16, 16, 0, 16, 16, 16);
      grad.addColorStop(0, 'white');
      grad.addColorStop(1, 'transparent');
      ctx.fillStyle = grad;
      ctx.fillRect(0, 0, 32, 32);
      const tex = new THREE.Texture(canvas);
      tex.needsUpdate = true;
      
      const mat = new THREE.PointsMaterial({
        size: 1, map: tex, vertexColors: true,
        transparent: true, opacity: 0.9,
        blending: THREE.AdditiveBlending, depthWrite: false
      });
      return new THREE.Points(geo, mat);
    }
    const stars = createStarfield();
    scene.add(stars);

    // Млечный путь (частицы)
    function createMilkyWayParticles() {
      const count = 20000;
      const geo = new THREE.BufferGeometry();
      const pos = new Float32Array(count * 3);
      const colors = new Float32Array(count * 3);
      
      for (let i = 0; i < count; i++) {
        const angle = Math.random() * Math.PI * 2;
        const radius = 6000 + Math.random() * 1000;
        const height = (Math.random() - 0.5) * 1500;
        const x = radius * Math.cos(angle);
        const y = height;
        const z = radius * Math.sin(angle);
        const tilt = Math.PI / 4;
        pos[i * 3] = x * Math.cos(tilt) - y * Math.sin(tilt);
        pos[i * 3 + 1] = x * Math.sin(tilt) + y * Math.cos(tilt);
        pos[i * 3 + 2] = z;
        const c = new THREE.Color().setHSL(0.65 + Math.random() * 0.1, 0.6, 0.1 + Math.random() * 0.1);
        colors[i * 3] = c.r;
        colors[i * 3 + 1] = c.g;
        colors[i * 3 + 2] = c.b;
      }
      
      geo.setAttribute('position', new THREE.BufferAttribute(pos, 3));
      geo.setAttribute('color', new THREE.BufferAttribute(colors, 3));
      const mat = new THREE.PointsMaterial({
        size: 40, vertexColors: true, transparent: true, opacity: 0.2,
        blending: THREE.AdditiveBlending, depthWrite: false
      });
      return new THREE.Points(geo, mat);
    }
    const milkyWayParticles = createMilkyWayParticles();
    scene.add(milkyWayParticles);

    // Падающие звёзды
    class ShootingStar {
      constructor() {
        this.group = new THREE.Group();
        this.head = new THREE.Mesh(
          new THREE.SphereGeometry(1, 8, 8),
          new THREE.MeshBasicMaterial({ color: 0xffffff })
        );
        this.group.add(this.head);
        this.tail = new THREE.Line(
          new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(), new THREE.Vector3()]),
          new THREE.LineBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.5 })
        );
        this.group.add(this.tail);
        scene.add(this.group);
        this.group.visible = false;
        this.active = false;
      }
      
      spawn() {
        if (this.active) return;
        const r = 1000;
        const theta = Math.random() * Math.PI * 2;
        const phi = Math.random() * Math.PI;
        this.group.position.set(
          r * Math.sin(phi) * Math.cos(theta),
          r * Math.cos(phi),
          r * Math.sin(phi) * Math.sin(theta)
        );
        const target = new THREE.Vector3(
          (Math.random() - 0.5) * 300,
          (Math.random() - 0.5) * 300,
          (Math.random() - 0.5) * 300
        );
        this.vel = new THREE.Vector3().subVectors(target, this.group.position).normalize().multiplyScalar(6 + Math.random() * 6);
        this.active = true;
        this.life = 1.0;
        this.group.visible = true;
      }
      
      update() {
        if (!this.active) return;
        this.group.position.add(this.vel);
        const trail = this.vel.clone().normalize().multiplyScalar(-30);
        const attr = this.tail.geometry.attributes.position;
        attr.setXYZ(1, trail.x, trail.y, trail.z);
        attr.needsUpdate = true;
        this.life -= 0.015;
        this.tail.material.opacity = this.life;
        if (this.life <= 0) {
          this.active = false;
          this.group.visible = false;
        }
      }
    }
    const meteors = Array.from({ length: 4 }, () => new ShootingStar());

    // Шейдеры для Солнца
    const sunVertexShader = `
      varying vec2 vUv;
      void main() {
        vUv = uv;
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
      }
    `;

    const sunFragmentShader = `
      uniform float time;
      varying vec2 vUv;
      
      float noise(vec3 p) {
        vec3 i = floor(p);
        vec3 f = fract(p);
        f = f * f * (3.0 - 2.0 * f);
        return mix(
          mix(mix(fract(sin(dot(i, vec3(12.9898, 78.233, 45.543))) * 43758.5453),
                  fract(sin(dot(i + vec3(1, 0, 0), vec3(12.9898, 78.233, 45.543))) * 43758.5453), f.x),
              mix(fract(sin(dot(i + vec3(0, 1, 0), vec3(12.9898, 78.233, 45.543))) * 43758.5453),
                  fract(sin(dot(i + vec3(1, 1, 0), vec3(12.9898, 78.233, 45.543))) * 43758.5453), f.x), f.y),
          mix(mix(fract(sin(dot(i + vec3(0, 0, 1), vec3(12.9898, 78.233, 45.543))) * 43758.5453),
                  fract(sin(dot(i + vec3(1, 0, 1), vec3(12.9898, 78.233, 45.543))) * 43758.5453), f.x),
              mix(fract(sin(dot(i + vec3(0, 1, 1), vec3(12.9898, 78.233, 45.543))) * 43758.5453),
                  fract(sin(dot(i + vec3(1, 1, 1), vec3(12.9898, 78.233, 45.543))) * 43758.5453), f.x), f.y), f.z);
      }
      
      void main() {
        float n = noise(vec3(vUv * 8.0, time * 0.5)) * 0.5 + noise(vec3(vUv * 16.0, time * 1.0)) * 0.25;
        vec3 color = mix(vec3(1.0, 0.3, 0.0), vec3(1.0, 0.9, 0.2), n + 0.2);
        gl_FragColor = vec4(color * 1.5, 1.0);
      }
    `;

    function generateSunGlowTexture() {
      const canvas = document.createElement('canvas');
      canvas.width = 64;
      canvas.height = 64;
      const ctx = canvas.getContext('2d');
      const gradient = ctx.createRadialGradient(32, 32, 0, 32, 32, 32);
      gradient.addColorStop(0, 'rgba(255, 200, 100, 1)');
      gradient.addColorStop(0.4, 'rgba(255, 100, 0, 0.2)');
      gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, 64, 64);
      return canvas;
    }

    // Группы планет
    const planetsGroup = new THREE.Group();
    scene.add(planetsGroup);

    const overviewGroup = new THREE.Group();
    overviewGroup.visible = false;
    scene.add(overviewGroup);

    let activePlanets = [];
    const addedKeys = new Set();
    let overviewObjects = [];
    let orbitLines = [];

    // Создание планеты
    function createPlanet(key, forOverview = false) {
      const data = PLANETS[key];
      const baseRadius = data.radius * BASE_SCALE;
      const radius = data.isSun ? (forOverview ? 6 : 4) : (forOverview ? 4 : baseRadius);

      const group = new THREE.Group();

      if (data.isSun) {
        const sunMat = new THREE.ShaderMaterial({
          uniforms: { time: { value: 0 } },
          vertexShader: sunVertexShader,
          fragmentShader: sunFragmentShader
        });
        const mesh = new THREE.Mesh(new THREE.SphereGeometry(radius, 64, 64), sunMat);
        group.add(mesh);

        const glowMat = new THREE.SpriteMaterial({
          map: new THREE.CanvasTexture(generateSunGlowTexture()),
          color: 0xffaa00,
          transparent: true,
          blending: THREE.AdditiveBlending
        });
        const glow = new THREE.Sprite(glowMat);
        glow.scale.set(radius * 5, radius * 5, 1);
        group.add(glow);
        group.userData = { isSun: true };
      } else {
        const mat = new THREE.MeshPhongMaterial({
          map: loadTextureWithCache(data.tex),
          shininess: 15
        });
        if (data.bump) {
          mat.bumpMap = loadTextureWithCache(data.bump);
          mat.bumpScale = 0.02;
        }

        const mesh = new THREE.Mesh(new THREE.SphereGeometry(radius, 64, 64), mat);
        group.add(mesh);

        if (data.glow && !forOverview) {
          const glowMat = new THREE.ShaderMaterial({
            uniforms: {
              c: { value: 0.2 },
              p: { value: 4.5 },
              glowColor: { value: new THREE.Color(data.glow) },
              viewVector: { value: camera.position }
            },
            vertexShader: `
              uniform vec3 viewVector;
              uniform float c;
              uniform float p;
              varying float intensity;
              void main() {
                vec3 vNormal = normalize(normalMatrix * normal);
                vec3 vNormel = normalize(normalMatrix * viewVector);
                intensity = pow(max(0.0, c - dot(vNormal, vNormel)), p);
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
              }
            `,
            fragmentShader: `
              uniform vec3 glowColor;
              varying float intensity;
              void main() {
                gl_FragColor = vec4(glowColor, intensity * 0.6);
              }
            `,
            side: THREE.BackSide,
            blending: THREE.AdditiveBlending,
            transparent: true,
            depthWrite: false
          });
          const glowMesh = new THREE.Mesh(new THREE.SphereGeometry(baseRadius * 1.12, 64, 64), glowMat);
          group.add(glowMesh);
          group.userData.glowMesh = glowMesh;
        }

        if (data.ring) {
          const ringInner = forOverview ? 5 : baseRadius * data.ring.inner;
          const ringOuter = forOverview ? 7.5 : baseRadius * data.ring.outer;
          const ringGeo = new THREE.RingGeometry(ringInner, ringOuter, 128);
          
          const pos = ringGeo.attributes.position;
          const v3 = new THREE.Vector3();
          for (let i = 0; i < pos.count; i++) {
            v3.fromBufferAttribute(pos, i);
            ringGeo.attributes.uv.setXY(i, 0.5 + v3.x / (ringOuter * 2), 0.5 + v3.y / (ringOuter * 2));
          }
          
          const ringMat = forOverview
            ? new THREE.MeshBasicMaterial({
                map: loadTextureWithCache(data.ring.tex),
                side: THREE.DoubleSide,
                transparent: true,
                opacity: 0.7
              })
            : new THREE.MeshStandardMaterial({
                map: loadTextureWithCache(data.ring.tex),
                side: THREE.DoubleSide,
                transparent: true,
                opacity: 0.8
              });
          
          const ring = new THREE.Mesh(ringGeo, ringMat);
          ring.rotation.x = -Math.PI / 2;
          group.add(ring);
        }
      }

      group.userData = { ...group.userData, name: key, ...data };
      return group;
    }

    // Создание линии орбиты
    function createOrbitLine(radius, color = 0x4a5568) {
      const points = [];
      const segments = 128;
      for (let i = 0; i <= segments; i++) {
        const angle = (i / segments) * Math.PI * 2;
        points.push(new THREE.Vector3(Math.cos(angle) * radius, 0, Math.sin(angle) * radius));
      }
      const geo = new THREE.BufferGeometry().setFromPoints(points);
      const mat = new THREE.LineBasicMaterial({ color, transparent: true, opacity: 0.25 });
      return new THREE.Line(geo, mat);
    }
    
    // Создание текстовой метки для планеты
function createPlanetLabel(name, color = 0xffffff) {
  const canvas = document.createElement('canvas');
  const ctx = canvas.getContext('2d');
  canvas.width = 512;
  canvas.height = 128;
  
  ctx.fillStyle = 'transparent';
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  
  ctx.font = 'bold 48px Jura, sans-serif';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  
  ctx.shadowColor = 'rgba(0, 0, 0, 0.9)';
  ctx.shadowBlur = 12;
  ctx.shadowOffsetX = 3;
  ctx.shadowOffsetY = 3;
  
  const c = new THREE.Color(color);
  ctx.fillStyle = `rgb(${Math.floor(c.r * 255)}, ${Math.floor(c.g * 255)}, ${Math.floor(c.b * 255)})`;
  ctx.fillText(name, canvas.width / 2, canvas.height / 2);
  
  const texture = new THREE.CanvasTexture(canvas);
  texture.needsUpdate = true;
  
  const spriteMat = new THREE.SpriteMaterial({
    map: texture,
    transparent: true,
    depthTest: false,
    depthWrite: false
  });
  
  const sprite = new THREE.Sprite(spriteMat);
  sprite.scale.set(32, 8, 1);
  sprite.userData.baseScale = { x: 32, y: 8 };
  sprite.userData.targetScale = { x: 32, y: 8 };
  sprite.userData.planetName = name;
  
  return sprite;
}



    // Режим обзора
    let isOverviewMode = false;
    let savedCameraPos = null;
    let savedControlsTarget = null;

function setupOverviewMode() {
  overviewObjects.forEach(obj => overviewGroup.remove(obj));
  orbitLines.forEach(line => overviewGroup.remove(line));
  planetLabels.forEach(label => overviewGroup.remove(label));
  overviewObjects = [];
  orbitLines = [];
  planetLabels = [];

  const ORBIT_SPACING = 32;
  const planetOrder = ['Солнце', 'Меркурий', 'Венера', 'Земля', 'Марс', 'Юпитер', 'Сатурн', 'Уран', 'Нептун', 'Плутон'];
  const currentDate = new Date();

  planetOrder.forEach((name, index) => {
    if (!PLANETS[name]) return;

    const planet = createPlanet(name, true);
    const planetData = PLANETS[name];
    const labelColor = planetData.glow || 0xaabbcc;

    if (planetData.isSun) {
      planet.position.set(0, 0, 0);
      
      const label = createPlanetLabel(name, 0xffaa00);
      label.position.set(0, 14, 0);
      label.userData.baseY = 14;
      planetLabels.push(label);
      overviewGroup.add(label);
    } else {
      const orbitRadius = index * ORBIT_SPACING;

      const orbitColor = planetData.glow || 0x4a5568;
      const orbit = createOrbitLine(orbitRadius, orbitColor);
      orbitLines.push(orbit);
      overviewGroup.add(orbit);

      const angle = calculatePlanetAngle(name, currentDate);
      const x = Math.cos(angle) * orbitRadius;
      const z = Math.sin(angle) * orbitRadius;
      
      planet.position.set(x, 0, z);
      planet.userData.orbitRadius = orbitRadius;
      planet.userData.orbitalAngle = angle;

      const label = createPlanetLabel(name, labelColor);
      label.position.set(x, 10, z);
      label.userData.baseY = 10;
      label.userData.orbitRadius = orbitRadius;
      label.userData.orbitalAngle = angle;
      planetLabels.push(label);
      overviewGroup.add(label);
    }

    overviewObjects.push(planet);
    overviewGroup.add(planet);
  });
}

    window.toggleOverview = () => {
      isOverviewMode = !isOverviewMode;
      const btn = document.getElementById('btnOverview');
      const dock = document.getElementById('dockWrapper');

      if (isOverviewMode) {
        btn.classList.add('active');
        dock.classList.add('hidden');

        savedCameraPos = camera.position.clone();
        savedControlsTarget = controls.target.clone();

        planetsGroup.visible = false;
        setupOverviewMode();
        overviewGroup.visible = true;

        const maxOrbit = 9 * 32; 
camTarget.set(0, maxOrbit * 0.7, maxOrbit * 0.5);
        viewTarget.set(0, 0, 0);
        sunLight.position.set(0, 0, 0);
        interacting = false;
      } else {
        btn.classList.remove('active');
        dock.classList.remove('hidden');

        overviewGroup.visible = false;
        planetsGroup.visible = true;

        if (savedCameraPos && savedControlsTarget) {
          camTarget.copy(savedCameraPos);
          viewTarget.copy(savedControlsTarget);
        }
        updateLayout();
        interacting = false;
      }
    };

    // Камера и управление
    let camTarget = new THREE.Vector3(0, 30, 80);
    let viewTarget = new THREE.Vector3(0, 0, 0);
    let interacting = false;

    function updateLayout() {
      if (isOverviewMode || !activePlanets.length) return;

      const hasSun = activePlanets.some(p => p.userData.isSun);

      if (hasSun) {
        sunLight.position.set(0, 0, 0);
        const AU_SCALE = 100;
        let maxDist = 0;

        activePlanets.forEach(p => {
          if (p.userData.isSun) {
            p.userData.tx = 0;
            p.scale.setScalar(3.0);
          } else {
            p.userData.tx = p.userData.distAU * AU_SCALE;
            const geoRadius = p.userData.radius * BASE_SCALE;
            p.scale.setScalar(4.0 / geoRadius);
          }
          if (p.userData.tx > maxDist) maxDist = p.userData.tx;
        });

        viewTarget.set(maxDist * 0.5, 0, 0);
        camTarget.set(maxDist * 0.5, maxDist * 0.2, maxDist * 0.9 + 200);
      } else {
        sunLight.position.set(100, 30, 80);
        activePlanets.sort((a, b) => PLANETS[a.userData.name].order - PLANETS[b.userData.name].order);

        let x = 0;
        activePlanets.forEach((p, i) => {
          p.scale.setScalar(1);
          if (i > 0) {
            const prev = activePlanets[i - 1];
            let pr = prev.userData.isSun ? 4 : prev.userData.radius * BASE_SCALE;
            if (!prev.userData.isSun && PLANETS[prev.userData.name].ring) pr *= 1.5;
            let cr = p.userData.isSun ? 4 : p.userData.radius * BASE_SCALE;
            if (!p.userData.isSun && PLANETS[p.userData.name].ring) cr *= 1.5;
            x += (pr + cr) * 1.2 + 8;
          }
          p.userData.tx = x;
        });

        const total = activePlanets[activePlanets.length - 1].userData.tx;
        activePlanets.forEach(p => p.userData.tx -= total / 2);

        viewTarget.set(0, 0, 0);
        camTarget.set(0, Math.max(total, 30) * 0.35, Math.max(total, 30) * 1.1);
      }
      interacting = false;
    }

    window.addPlanet = (key) => {
      if (addedKeys.has(key) || isOverviewMode) return;
      
      const planet = createPlanet(key);
      planet.scale.set(0, 0, 0);
      planetsGroup.add(planet);
      activePlanets.push(planet);
      addedKeys.add(key);
      updateLayout();
      updateUI();

      let t = 0;
      function animateIn() {
        t += 0.04;
        if (planet.userData.isSun) {
          planet.scale.setScalar(Math.min(t, 3.0));
        } else {
          const geoRadius = planet.userData.radius * BASE_SCALE;
          const targetScale = activePlanets.some(x => x.userData.isSun) ? 4.0 / geoRadius : 1.0;
          planet.scale.setScalar(Math.min(t * targetScale, targetScale));
        }
        if (t < 1) requestAnimationFrame(animateIn);
      }
      animateIn();
    };

    window.removePlanet = (key) => {
      const planet = activePlanets.find(p => p.userData.name === key);
      if (!planet) return;

      let t = 1;
      function animateOut() {
        t -= 0.06;
        planet.scale.setScalar(Math.max(t, 0));
        if (t > 0) {
          requestAnimationFrame(animateOut);
        } else {
          planetsGroup.remove(planet);
          activePlanets = activePlanets.filter(p => p !== planet);
          addedKeys.delete(key);
          updateLayout();
          updateUI();
        }
      }
      animateOut();
    };

    window.clearAll = () => {
      if (isOverviewMode) toggleOverview();
      [...activePlanets].forEach(p => removePlanet(p.userData.name));
    };

    // UI
    const btnContainer = document.getElementById('planetBtns');
    const sortedKeys = Object.keys(PLANETS).sort((a, b) => PLANETS[a].order - PLANETS[b].order);

    sortedKeys.forEach(key => {
      const chip = document.createElement('div');
      chip.className = 'chip';
      chip.textContent = key;
      chip.dataset.p = key;
      chip.onclick = () => {
        if (isOverviewMode) return;
        addedKeys.has(key) ? removePlanet(key) : addPlanet(key);
      };
      btnContainer.appendChild(chip);
    });

    function updateUI() {
      document.querySelectorAll('.chip').forEach(chip => {
        chip.classList.toggle('active', addedKeys.has(chip.dataset.p));
      });
    }

    let isDark = true;
    let isMWActive = true;

    window.toggleMilkyWay = () => {
      isMWActive = !isMWActive;
      const btn = document.getElementById('btnMW');
      btn.classList.toggle('active', isMWActive);
      skyboxMilkyWay.visible = isMWActive && isDark;
    };

    window.toggleTheme = () => {
      isDark = !isDark;
      document.body.dataset.theme = isDark ? 'dark' : 'light';

      const btn = document.querySelector('.theme-btn');
      btn.querySelector('.icon-moon').style.display = isDark ? 'block' : 'none';
      btn.querySelector('.icon-sun').style.display = isDark ? 'none' : 'block';

      if (isDark) {
        scene.background = null;
        stars.visible = true;
        milkyWayParticles.visible = true;
        skyboxMilkyWay.visible = isMWActive;
        meteors.forEach(m => m.group.visible = m.active);
        bloomPass.strength = 1.0;
        ambLight.intensity = 0.7;
        hemiLight.intensity = 0.6;
      } else {
        scene.background = new THREE.Color(0xf8fafc);
        stars.visible = false;
        milkyWayParticles.visible = false;
        skyboxMilkyWay.visible = false;
        meteors.forEach(m => m.group.visible = false);
        bloomPass.strength = 0;
        ambLight.intensity = 1.2;
        hemiLight.intensity = 0.8;
      }
    };

    // Инициализация
    addPlanet('Земля');
    addPlanet('Марс');

    renderer.domElement.addEventListener('wheel', () => interacting = true);
    controls.addEventListener('start', () => interacting = true);

    // Анимация
    function animate(time) {
      requestAnimationFrame(animate);
      const t = time * 0.001;

      if (!interacting) {
        camera.position.lerp(camTarget, 0.04);
        controls.target.lerp(viewTarget, 0.04);
      }

      skyboxMilkyWay.rotation.y = t * 0.005;

      if (!isOverviewMode) {
        activePlanets.forEach(p => {
          p.position.x += (p.userData.tx - p.position.x) * 0.1;
          if (p.userData.isSun) {
            p.children[0].material.uniforms.time.value = t;
            p.children[0].rotation.y = t * 0.05;
          } else {
            p.children[0].rotation.y += 0.002;
            if (p.userData.glowMesh?.material?.uniforms) {
              p.userData.glowMesh.material.uniforms.viewVector.value = camera.position;
            }
          }
        });
} else {
  overviewObjects.forEach(p => {
    if (p.userData.isSun) {
      p.children[0].material.uniforms.time.value = t;
      p.children[0].rotation.y = t * 0.05;
    } else {
      p.children[0].rotation.y += 0.003;
    }
  });
  
  planetLabels.forEach(label => {
    const baseY = label.userData.baseY || 10;
    const targetY = label.userData.targetY || baseY;
    const floatY = targetY + Math.sin(t * 2 + label.position.x * 0.1) * 0.5;
    label.position.y += (floatY - label.position.y) * 0.1;
    
    const target = label.userData.targetScale;
    const current = label.scale;
    current.x += (target.x - current.x) * 0.12;
    current.y += (target.y - current.y) * 0.12;
  });
}

      if (isDark) {
        meteors.forEach(m => m.update());
        if (Math.random() < 0.005) {
          const m = meteors.find(x => !x.active);
          if (m) m.spawn();
        }
      }

      controls.update();
      composer.render();
    }

    window.addEventListener('resize', () => {
      camera.aspect = innerWidth / innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(innerWidth, innerHeight);
      composer.setSize(innerWidth, innerHeight);
    });

    animate(0);

    // Клик по планете
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();

    window.addEventListener('dblclick', (e) => {
      mouse.x = (e.clientX / innerWidth) * 2 - 1;
      mouse.y = -(e.clientY / innerHeight) * 2 + 1;
      raycaster.setFromCamera(mouse, camera);

      const targetGroup = isOverviewMode ? overviewGroup : planetsGroup;
      const hits = raycaster.intersectObjects(targetGroup.children, true);

      if (hits.length) {
        let obj = hits[0].object;
        while (obj.parent && obj.parent !== targetGroup) obj = obj.parent;

        const data = obj.userData;
        if (!data.info) return;

        const info = data.info;
        document.getElementById('mTitle').textContent = data.name;
        document.getElementById('mType').textContent = data.type;

        const earthLabel = data.isSun ? 'Земли' : '× Земля';
        document.getElementById('mStats').innerHTML = `
          <div class="stat"><h4>Диаметр</h4><p>${info.diameter}</p><span class="sub">${info.diamEarth} ${earthLabel}</span></div>
          <div class="stat"><h4>Масса</h4><p>${info.mass}</p><span class="sub">${info.massEarth} ${earthLabel}</span></div>
          <div class="stat"><h4>Плотность</h4><p>${info.density}</p></div>
          <div class="stat"><h4>Гравитация</h4><p>${info.gravity}</p></div>
          <div class="stat"><h4>Год</h4><p>${info.year}</p></div>
          <div class="stat"><h4>Сутки</h4><p>${info.day}</p></div>
          <div class="stat"><h4>Атмосфера</h4><p>${info.atmosphere}</p></div>
          <div class="stat"><h4>Температура</h4><p>${info.temp}</p></div>
          <div class="stat"><h4>Расстояние</h4><p>${info.dist}</p></div>
          <div class="stat"><h4>Спутники</h4><p>${info.moons}</p></div>
          <div class="stat"><h4>Наклон оси</h4><p>${info.tilt}</p></div>
        `;

        const fact = data.facts?.length
          ? data.facts[Math.floor(Math.random() * data.facts.length)]
          : "Информация уточняется...";
        document.getElementById('mFact').textContent = fact;
        document.getElementById('modal').classList.add('visible');
      }
    });
    
    
window.addEventListener('mousemove', (e) => {
  if (!isOverviewMode) return;
  
  mouse.x = (e.clientX / innerWidth) * 2 - 1;
  mouse.y = -(e.clientY / innerHeight) * 2 + 1;
  raycaster.setFromCamera(mouse, camera);
  
  const hits = raycaster.intersectObjects(overviewObjects, true);
  
  if (hits.length) {
    let obj = hits[0].object;
    while (obj.parent && obj.parent !== overviewGroup) obj = obj.parent;
    
    if (hoveredPlanet !== obj.userData.name) {
      hoveredPlanet = obj.userData.name;
      document.body.style.cursor = 'pointer';
      
      planetLabels.forEach(label => {
        if (label.userData.planetName === hoveredPlanet) {
          label.userData.targetScale = { x: 120, y: 30 };
          label.userData.targetY = 18;
        } else {
          label.userData.targetScale = { x: 32, y: 8 };
          label.userData.targetY = label.userData.baseY;
        }
      });
    }
  } else {
    if (hoveredPlanet) {
      hoveredPlanet = null;
      document.body.style.cursor = 'default';
      planetLabels.forEach(label => {
        label.userData.targetScale = { x: 32, y: 8 };
        label.userData.targetY = label.userData.baseY;
      });
    }
  }
});

    window.closeModal = () => document.getElementById('modal').classList.remove('visible');
  </script>
</body>
</html>