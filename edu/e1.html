<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no, maximum-scale=1.0" />
<title>–ê—Ç–ª–∞—Å –°–æ–∑–≤–µ–∑–¥–∏–π 3D</title>
<style>
    :root {
        --bg-color: #050a10;
        --panel-bg: rgba(20, 30, 45, 0.9);
        --accent: #00e5ff;
        --gold: #ffd700;
        --text-main: #ffffff;
        --border: rgba(0, 229, 255, 0.3);
    }

    body, html {
        margin: 0; padding: 0; width: 100%; height: 100%;
        background-color: var(--bg-color);
        overflow: hidden;
        font-family: 'Segoe UI', Tahoma, sans-serif;
        color: var(--text-main);
    }

    canvas { display: block; width: 100%; height: 100%; outline: none; }

    /* UI ELEMENTS */
    #search-container {
        position: absolute; top: 20px; left: 50%; transform: translateX(-50%);
        width: 320px; z-index: 100;
        display: flex; flex-direction: column; gap: 5px;
    }
    #city-input {
        width: 100%; padding: 12px 20px;
        background: var(--panel-bg); border: 1px solid var(--accent);
        border-radius: 25px; color: white; font-size: 15px; outline: none;
        box-shadow: 0 0 20px rgba(0, 229, 255, 0.15);
        backdrop-filter: blur(10px);
    }
    #search-results {
        background: var(--panel-bg); border-radius: 12px;
        border: 1px solid var(--accent); max-height: 400px; overflow-y: auto;
        display: none; box-shadow: 0 10px 30px rgba(0,0,0,0.5);
    }
    .search-group-title {
        padding: 8px 15px; font-size: 11px; text-transform: uppercase;
        color: var(--gold); background: rgba(0,0,0,0.3); letter-spacing: 1px;
    }
    .search-item {
        padding: 10px 15px; cursor: pointer; border-bottom: 1px solid rgba(255,255,255,0.05);
        font-size: 14px; transition: 0.2s; display: flex; justify-content: space-between;
    }
    .search-item:hover { background: rgba(0, 229, 255, 0.2); color: var(--accent); }
    .star-mag { font-size: 11px; opacity: 0.6; }

    #controls-panel {
        position: absolute; top: 80px; right: 20px;
        width: 260px;
        background: var(--panel-bg);
        border: 1px solid var(--border);
        border-radius: 16px; padding: 20px;
        backdrop-filter: blur(12px);
    }
    .panel-title {
        font-size: 14px; font-weight: 700; color: var(--accent);
        text-transform: uppercase; letter-spacing: 1px;
        margin-bottom: 15px; text-align: center;
        border-bottom: 1px solid rgba(255,255,255,0.1); padding-bottom: 10px;
    }
    .ctrl-row {
        display: flex; justify-content: space-between; align-items: center;
        margin-bottom: 12px; font-size: 14px;
    }
    
    .switch { position: relative; width: 46px; height: 24px; }
    .switch input { opacity: 0; width: 0; height: 0; }
    .slider {
        position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0;
        background-color: #334; border-radius: 34px; transition: .3s; border: 1px solid #556;
    }
    .slider:before {
        position: absolute; content: ""; height: 16px; width: 16px;
        left: 3px; bottom: 3px; background-color: white; border-radius: 50%; transition: .3s;
    }
    input:checked + .slider { background-color: rgba(0, 229, 255, 0.3); border-color: var(--accent); }
    input:checked + .slider:before { transform: translateX(22px); background-color: var(--accent); }

    #info-panel {
        position: absolute; bottom: 20px; left: 20px;
        background: var(--panel-bg); border: 1px solid var(--border);
        border-radius: 16px; padding: 15px 20px;
        backdrop-filter: blur(12px); pointer-events: none;
    }
    .info-data { font-family: 'Consolas', monospace; font-size: 13px; line-height: 1.6; }
    .val-accent { color: var(--accent); font-weight: bold; }
</style>
</head>
<body>

<div id="search-container">
    <input type="text" id="city-input" placeholder="üîç –ü–æ–∏—Å–∫ (–°–∏—Ä–∏—É—Å, –ú–µ–¥–≤–µ–¥–∏—Ü–∞, –ú–æ—Å–∫–≤–∞...)" autocomplete="off">
    <div id="search-results"></div>
</div>

<div id="controls-panel">
    <div class="panel-title">–£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ</div>
    <div class="ctrl-row">
        <span>üåê –°–µ—Ç–∫–∞ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç</span>
        <label class="switch"><input type="checkbox" id="chk-grid" checked><span class="slider"></span></label>
    </div>
    <div class="ctrl-row">
        <span>‚ú® –õ–∏–Ω–∏–∏ —Å–æ–∑–≤–µ–∑–¥–∏–π</span>
        <label class="switch"><input type="checkbox" id="chk-lines" checked><span class="slider"></span></label>
    </div>
    <div class="ctrl-row">
        <span>üè∑Ô∏è –ù–∞–∑–≤–∞–Ω–∏—è (–°–æ–∑–≤.)</span>
        <label class="switch"><input type="checkbox" id="chk-const-names" checked><span class="slider"></span></label>
    </div>
    <div class="ctrl-row">
        <span>ü™ê –ü–ª–∞–Ω–µ—Ç—ã</span>
        <label class="switch"><input type="checkbox" id="chk-planets" checked><span class="slider"></span></label>
    </div>
    <div class="ctrl-row">
        <span>„Ä∞Ô∏è –¢—Ä–∞–µ–∫—Ç–æ—Ä–∏–∏</span>
        <label class="switch"><input type="checkbox" id="chk-traj" checked><span class="slider"></span></label>
    </div>
    <div class="ctrl-row">
        <span>üåç –ó–µ–º–ª—è</span>
        <label class="switch"><input type="checkbox" id="chk-ground" checked><span class="slider"></span></label>
    </div>
</div>

<div id="info-panel">
    <div style="font-weight:bold; margin-bottom:5px; font-size:14px; color:var(--gold);">–ù–ê–ë–õ–Æ–î–ê–¢–ï–õ–¨</div>
    <div class="info-data" id="loc-data">GPS –ø–æ–∏—Å–∫...</div>
    <div style="margin-top:5px; font-size:12px; opacity:0.7;" id="time-data"></div>
</div>

<!-- Libraries -->
<script type="importmap">
{
    "imports": {
        "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
    }
}
</script>
<script src="https://cdn.jsdelivr.net/npm/astronomy-engine@2.1.19/astronomy.browser.min.js"></script>

<script>
// --- CONSTELLATIONS DATABASE (constellations.js simulation) ---
// RA in hours, Dec in degrees
const CONSTELLATIONS = {
    "–ë–æ–ª—å—à–∞—è –ú–µ–¥–≤–µ–¥–∏—Ü–∞": {
        latin: "Ursa Major", abbr: "UMa",
        stars: [
            { name: "–î—É–±—Ö–µ", bayer: "Œ±", ra: 11.062, dec: 61.751, mag: 1.79 },
            { name: "–ú–µ—Ä–∞–∫", bayer: "Œ≤", ra: 11.031, dec: 56.382, mag: 2.37 },
            { name: "–§–µ–∫–¥–∞", bayer: "Œ≥", ra: 11.897, dec: 53.695, mag: 2.44 },
            { name: "–ú–µ–≥—Ä–µ—Ü", bayer: "Œ¥", ra: 12.257, dec: 57.033, mag: 3.31 },
            { name: "–ê–ª–∏–æ—Ç", bayer: "Œµ", ra: 12.900, dec: 55.960, mag: 1.77 },
            { name: "–ú–∏—Ü–∞—Ä", bayer: "Œ∂", ra: 13.399, dec: 54.925, mag: 2.27 },
            { name: "–ê–ª—å–∫–∞–∏–¥", bayer: "Œ∑", ra: 13.792, dec: 49.313, mag: 1.86 }
        ],
        lines: [
            ["–î—É–±—Ö–µ", "–ú–µ—Ä–∞–∫"], ["–ú–µ—Ä–∞–∫", "–§–µ–∫–¥–∞"], ["–§–µ–∫–¥–∞", "–ú–µ–≥—Ä–µ—Ü"], ["–ú–µ–≥—Ä–µ—Ü", "–î—É–±—Ö–µ"],
            ["–ú–µ–≥—Ä–µ—Ü", "–ê–ª–∏–æ—Ç"], ["–ê–ª–∏–æ—Ç", "–ú–∏—Ü–∞—Ä"], ["–ú–∏—Ü–∞—Ä", "–ê–ª—å–∫–∞–∏–¥"]
        ]
    },
    "–ú–∞–ª–∞—è –ú–µ–¥–≤–µ–¥–∏—Ü–∞": {
        latin: "Ursa Minor", abbr: "UMi",
        stars: [
            { name: "–ü–æ–ª—è—Ä–Ω–∞—è", bayer: "Œ±", ra: 2.530, dec: 89.264, mag: 1.98 },
            { name: "–ö–æ—Ö–∞–±", bayer: "Œ≤", ra: 14.845, dec: 74.156, mag: 2.08 },
            { name: "–§–µ—Ä–∫–∞–¥", bayer: "Œ≥", ra: 15.345, dec: 71.834, mag: 3.05 },
            { name: "–ô–∏–ª—å–¥—É–Ω", bayer: "Œ¥", ra: 17.537, dec: 86.586, mag: 4.36 },
            { name: "–£—Ä–æ–¥–µ–ª—É—Å", bayer: "Œµ", ra: 16.766, dec: 82.037, mag: 4.23 },
            { name: "–ê—Ö—Ñ–∞", bayer: "Œ∂", ra: 15.734, dec: 77.795, mag: 4.32 },
            { name: "–ê–Ω–≤–∞—Ä", bayer: "Œ∑", ra: 16.292, dec: 75.755, mag: 4.95 }
        ],
        lines: [
            ["–ü–æ–ª—è—Ä–Ω–∞—è", "–ô–∏–ª—å–¥—É–Ω"], ["–ô–∏–ª—å–¥—É–Ω", "–£—Ä–æ–¥–µ–ª—É—Å"], ["–£—Ä–æ–¥–µ–ª—É—Å", "–ê—Ö—Ñ–∞"],
            ["–ê—Ö—Ñ–∞", "–§–µ—Ä–∫–∞–¥"], ["–§–µ—Ä–∫–∞–¥", "–ö–æ—Ö–∞–±"], ["–ö–æ—Ö–∞–±", "–ê—Ö—Ñ–∞"]
        ]
    },
    "–ö–∞—Å—Å–∏–æ–ø–µ—è": {
        latin: "Cassiopeia", abbr: "Cas",
        stars: [
            { name: "–®–µ–¥–∞—Ä", bayer: "Œ±", ra: 0.675, dec: 56.537, mag: 2.24 },
            { name: "–ö–∞—Ñ", bayer: "Œ≤", ra: 0.153, dec: 59.150, mag: 2.28 },
            { name: "–ù–∞–≤–∏", bayer: "Œ≥", ra: 0.945, dec: 60.717, mag: 2.15 },
            { name: "–†—É–∫–±–∞—Ö", bayer: "Œ¥", ra: 1.43, dec: 60.235, mag: 2.68 },
            { name: "–°–µ–≥–∏–Ω", bayer: "Œµ", ra: 1.907, dec: 63.670, mag: 3.35 }
        ],
        lines: [
             ["–°–µ–≥–∏–Ω", "–†—É–∫–±–∞—Ö"], ["–†—É–∫–±–∞—Ö", "–ù–∞–≤–∏"], ["–ù–∞–≤–∏", "–®–µ–¥–∞—Ä"], ["–®–µ–¥–∞—Ä", "–ö–∞—Ñ"]
        ]
    },
    "–û—Ä–∏–æ–Ω": {
        latin: "Orion", abbr: "Ori",
        stars: [
            { name: "–ë–µ—Ç–µ–ª—å–≥–µ–π–∑–µ", bayer: "Œ±", ra: 5.919, dec: 7.407, mag: 0.45 },
            { name: "–†–∏–≥–µ–ª—å", bayer: "Œ≤", ra: 5.242, dec: -8.201, mag: 0.12 },
            { name: "–ë–µ–ª–ª–∞—Ç—Ä–∏–∫—Å", bayer: "Œ≥", ra: 5.418, dec: 6.349, mag: 1.64 },
            { name: "–ú–∏–Ω—Ç–∞–∫–∞", bayer: "Œ¥", ra: 5.533, dec: -0.299, mag: 2.25 },
            { name: "–ê–ª—å–Ω–∏–ª–∞–º", bayer: "Œµ", ra: 5.603, dec: -1.202, mag: 1.69 },
            { name: "–ê–ª—å–Ω–∏—Ç–∞–∫", bayer: "Œ∂", ra: 5.679, dec: -1.942, mag: 1.74 },
            { name: "–°–∞–∏—Ñ", bayer: "Œ∫", ra: 5.795, dec: -9.669, mag: 2.07 }
        ],
        lines: [
            ["–ë–µ—Ç–µ–ª—å–≥–µ–π–∑–µ", "–ë–µ–ª–ª–∞—Ç—Ä–∏–∫—Å"], ["–ë–µ–ª–ª–∞—Ç—Ä–∏–∫—Å", "–ú–∏–Ω—Ç–∞–∫–∞"], ["–ú–∏–Ω—Ç–∞–∫–∞", "–ê–ª—å–Ω–∏–ª–∞–º"],
            ["–ê–ª—å–Ω–∏–ª–∞–º", "–ê–ª—å–Ω–∏—Ç–∞–∫"], ["–ê–ª—å–Ω–∏—Ç–∞–∫", "–°–∞–∏—Ñ"], ["–°–∞–∏—Ñ", "–†–∏–≥–µ–ª—å"],
            ["–†–∏–≥–µ–ª—å", "–ú–∏–Ω—Ç–∞–∫–∞"], ["–ë–µ—Ç–µ–ª—å–≥–µ–π–∑–µ", "–ê–ª—å–Ω–∏—Ç–∞–∫"]
        ]
    },
    "–ú–∞–ª—ã–π –ü–µ—Å": {
        latin: "Canis Minor", abbr: "CMi",
        stars: [
            { name: "–ü—Ä–æ—Ü–∏–æ–Ω", bayer: "Œ±", ra: 7.655, dec: 5.225, mag: 0.38 },
            { name: "–ì–æ–º–µ–π—Å–∞", bayer: "Œ≤", ra: 7.453, dec: 8.29, mag: 2.89 }
        ],
        lines: [ ["–ü—Ä–æ—Ü–∏–æ–Ω", "–ì–æ–º–µ–π—Å–∞"] ]
    }
};

const PLANETS = ['Mercury', 'Venus', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune'];
</script>

<script type="module">
import * as THREE from "three";
import { OrbitControls } from "three/addons/controls/OrbitControls.js";

// --- GLOBALS ---
let scene, camera, renderer, controls;
const SPHERE_RADIUS = 50; 
let observerLat = 55.75, observerLon = 37.61, locationName = "–ú–æ—Å–∫–≤–∞";

// Scene Groups
const groups = {
    grid: new THREE.Group(),
    stars: new THREE.Group(),
    lines: new THREE.Group(),
    labels: new THREE.Group(),
    planets: new THREE.Group(),
    trajectories: new THREE.Group(),
    sunMoon: new THREE.Group(),
    ground: new THREE.Group()
};

// --- INIT ---
function init() {
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x050a10);

    // Camera (Outside God View)
    camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 40, 90);
    
    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    document.body.appendChild(renderer.domElement);

    controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.minDistance = 10;
    controls.maxDistance = 250;
    
    // Lights
    scene.add(new THREE.AmbientLight(0xffffff, 0.5));
    const dir = new THREE.DirectionalLight(0xffffff, 1);
    dir.position.set(100, 50, 50);
    scene.add(dir);

    buildGrid();
    buildGround();
    
    Object.values(groups).forEach(g => scene.add(g));

    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });

    setupUI();
    
    // Start loop
    if(navigator.geolocation) {
        navigator.geolocation.getCurrentPosition(pos => {
            setLocation(pos.coords.latitude, pos.coords.longitude, "GPS –õ–æ–∫–∞—Ü–∏—è");
        });
    }
    updateSky();
    setInterval(updateSky, 60000); // 1 min update
    animate();
}

// --- RENDERING HELPERS ---

function sphericalToCartesian(radius, azDeg, altDeg) {
    const altRad = THREE.MathUtils.degToRad(altDeg);
    const azRad = THREE.MathUtils.degToRad(azDeg);
    // Y=Up, Z=South(0 for Azimuth calculation in Astronomy.js depends on convention, usually South=0 or North=0)
    // Astronomy.js Horizon: Azimuth is measured from North (0) clockwise (East=90).
    // ThreeJS: +Z is usually towards camera. Let's map North to -Z.
    const x = radius * Math.cos(altRad) * Math.sin(azRad);
    const y = radius * Math.sin(altRad);
    const z = -radius * Math.cos(altRad) * Math.cos(azRad);
    return new THREE.Vector3(x, y, z);
}

function createTextSprite(text, color, scale = 1) {
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    const fontSize = 48;
    ctx.font = `bold ${fontSize}px Arial`;
    const w = ctx.measureText(text).width + 10;
    canvas.width = w; canvas.height = fontSize + 10;
    ctx.font = `bold ${fontSize}px Arial`;
    ctx.fillStyle = color;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.shadowColor = 'black'; ctx.shadowBlur = 4;
    ctx.fillText(text, w/2, canvas.height/2);
    
    const tex = new THREE.CanvasTexture(canvas);
    const mat = new THREE.SpriteMaterial({ map: tex, depthTest: false });
    const sprite = new THREE.Sprite(mat);
    sprite.scale.set(scale * w/20, scale * canvas.height/20, 1);
    return sprite;
}

function createPointSprite(color, size) {
    const canvas = document.createElement('canvas');
    canvas.width = 32; canvas.height = 32;
    const ctx = canvas.getContext('2d');
    const grad = ctx.createRadialGradient(16,16,0, 16,16,16);
    grad.addColorStop(0, 'white');
    grad.addColorStop(0.4, color);
    grad.addColorStop(1, 'rgba(0,0,0,0)');
    ctx.fillStyle = grad;
    ctx.fillRect(0,0,32,32);
    
    const mat = new THREE.SpriteMaterial({ map: new THREE.CanvasTexture(canvas), blending: THREE.AdditiveBlending });
    const sprite = new THREE.Sprite(mat);
    sprite.scale.set(size, size, 1);
    return sprite;
}

function buildGrid() {
    const r = SPHERE_RADIUS;
    const mat = new THREE.LineBasicMaterial({ color: 0x004466, transparent: true, opacity: 0.3 });
    // Parallels
    for(let alt=-80; alt<=80; alt+=20) {
        const pts = [];
        for(let az=0; az<=360; az+=5) pts.push(sphericalToCartesian(r, az, alt));
        groups.grid.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints(pts), mat));
    }
    // Meridians
    for(let az=0; az<360; az+=30) {
        const pts = [];
        for(let alt=-90; alt<=90; alt+=5) pts.push(sphericalToCartesian(r, az, alt));
        groups.grid.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints(pts), mat));
    }
    // NSEW Labels
    const dirs = [{t:'N',a:0},{t:'E',a:90},{t:'S',a:180},{t:'W',a:270}];
    dirs.forEach(d => {
        const s = createTextSprite(d.t, '#00e5ff', 2);
        s.position.copy(sphericalToCartesian(r+2, d.a, 0));
        groups.grid.add(s);
    });
}

function buildGround() {
    // Horizon Disk
    const geo = new THREE.CircleGeometry(SPHERE_RADIUS, 64);
    const mat = new THREE.MeshBasicMaterial({ color: 0x0a1520, transparent: true, opacity: 0.5, side: THREE.DoubleSide });
    const disk = new THREE.Mesh(geo, mat);
    disk.rotation.x = Math.PI/2;
    groups.ground.add(disk);
    // Horizon Line
    const ringGeo = new THREE.RingGeometry(SPHERE_RADIUS-0.2, SPHERE_RADIUS+0.2, 128);
    const ringMat = new THREE.MeshBasicMaterial({ color: 0x00e5ff, side: THREE.DoubleSide });
    const ring = new THREE.Mesh(ringGeo, ringMat);
    ring.rotation.x = Math.PI/2;
    groups.ground.add(ring);
    // Center point
    const c = new THREE.Mesh(new THREE.SphereGeometry(0.5), new THREE.MeshBasicMaterial({color:'red'}));
    groups.ground.add(c);
}

// --- UPDATE LOGIC ---

function updateSky() {
    const now = new Date();
    document.getElementById('loc-data').innerHTML = `LAT: ${observerLat.toFixed(4)} <span style="color:var(--accent)">|</span> LON: ${observerLon.toFixed(4)}`;
    document.getElementById('time-data').innerText = now.toLocaleString();

    // Clean groups
    ['stars','lines','labels','planets','trajectories','sunMoon'].forEach(k => {
        while(groups[k].children.length) {
            const o = groups[k].children[0];
            groups[k].remove(o);
            if(o.material) o.material.dispose();
            if(o.geometry) o.geometry.dispose();
        }
    });

    const observer = new Astronomy.Observer(observerLat, observerLon, 0);
    const starPosMap = {}; // name -> Vector3

    // 1. STARS & CONSTELLATIONS from CONSTELLATIONS object
    Object.keys(CONSTELLATIONS).forEach(constKey => {
        const cData = CONSTELLATIONS[constKey];
        const cCenter = new THREE.Vector3();
        let starCount = 0;

        // Draw Stars
        cData.stars.forEach(star => {
            // Calc position
            const hor = Astronomy.Horizon(now, observer, star.ra, star.dec, 'normal');
            const pos = sphericalToCartesian(SPHERE_RADIUS, hor.azimuth, hor.altitude);
            starPosMap[star.name] = pos;
            
            // Draw Sprite
            const size = Math.max(0.5, 2.5 - star.mag * 0.5); 
            const sSprite = createPointSprite('#ffffff', size);
            sSprite.position.copy(pos);
            groups.stars.add(sSprite);

            // Label if bright
            if(star.mag < 1.5 && hor.altitude > 0) {
                const sl = createTextSprite(star.name, '#aaaaaa', 0.5);
                sl.position.copy(pos).multiplyScalar(1.03);
                groups.stars.add(sl);
            }

            cCenter.add(pos);
            starCount++;
        });

        // Draw Constellation Lines
        if(cData.lines) {
            const lineGeo = new THREE.BufferGeometry();
            const pts = [];
            cData.lines.forEach(pair => {
                const p1 = starPosMap[pair[0]];
                const p2 = starPosMap[pair[1]];
                if(p1 && p2) pts.push(p1, p2);
            });
            if(pts.length) {
                lineGeo.setFromPoints(pts);
                groups.lines.add(new THREE.LineSegments(lineGeo, new THREE.LineBasicMaterial({ color: 0xaa44ff, opacity:0.6, transparent:true })));
            }
        }

        // Constellation Label (Average position)
        if(starCount > 0) {
            cCenter.divideScalar(starCount).normalize().multiplyScalar(SPHERE_RADIUS * 1.05);
            // Only show label if above horizon
            if(cCenter.y > -10) {
                const cLabel = createTextSprite(constKey, '#d699ff', 1.2);
                cLabel.position.copy(cCenter);
                groups.labels.add(cLabel);
            }
        }
    });

    // 2. PLANETS
    PLANETS.forEach(p => {
        const eq = Astronomy.Equator(p, now, observer, false, true);
        const hor = Astronomy.Horizon(now, observer, eq.ra, eq.dec, 'normal');
        const pos = sphericalToCartesian(SPHERE_RADIUS, hor.azimuth, hor.altitude);
        
        let col = '#ddd';
        if(p==='Mars') col='#ff5555'; if(p==='Jupiter') col='#ffcc99'; if(p==='Venus') col='#fff';
        
        const sp = createPointSprite(col, 2.5);
        sp.position.copy(pos);
        groups.planets.add(sp);
        
        if(hor.altitude > -5) {
            const lb = createTextSprite(p, col, 1);
            lb.position.copy(pos).multiplyScalar(1.08);
            groups.planets.add(lb);
        }
    });

    // 3. SUN & MOON
    const sunEq = Astronomy.Equator('Sun', now, observer, false, true);
    const sunHor = Astronomy.Horizon(now, observer, sunEq.ra, sunEq.dec, 'normal');
    const sunPos = sphericalToCartesian(SPHERE_RADIUS, sunHor.azimuth, sunHor.altitude);
    const sunSp = createPointSprite('#ffaa00', 5); sunSp.position.copy(sunPos);
    groups.sunMoon.add(sunSp);
    const sunLb = createTextSprite('–°–æ–ª–Ω—Ü–µ', '#ffaa00', 1.5); sunLb.position.copy(sunPos).multiplyScalar(1.1);
    groups.sunMoon.add(sunLb);

    const moonEq = Astronomy.Equator('Moon', now, observer, false, true);
    const moonHor = Astronomy.Horizon(now, observer, moonEq.ra, moonEq.dec, 'normal');
    const moonPos = sphericalToCartesian(SPHERE_RADIUS, moonHor.azimuth, moonHor.altitude);
    const moonSp = createPointSprite('#ffffff', 4); moonSp.position.copy(moonPos);
    groups.sunMoon.add(moonSp);

    // 4. TRAJECTORIES (Sun/Moon arc)
    drawTrajectory('Sun', 0xffaa00, now, observer);
    drawTrajectory('Moon', 0xffffff, now, observer);
}

function drawTrajectory(body, color, date, obs) {
    const pts = [];
    const d = new Date(date); d.setHours(0,0,0,0);
    for(let i=0; i<=24; i+=0.5) {
        const t = new Date(d.getTime() + i*3600000);
        const eq = Astronomy.Equator(body, t, obs, false, true);
        const h = Astronomy.Horizon(t, obs, eq.ra, eq.dec, 'normal');
        if(h.altitude > -10) pts.push(sphericalToCartesian(SPHERE_RADIUS, h.azimuth, h.altitude));
    }
    if(pts.length) {
        groups.trajectories.add(new THREE.Line(
            new THREE.BufferGeometry().setFromPoints(pts),
            new THREE.LineBasicMaterial({ color: color, opacity: 0.4, transparent: true })
        ));
    }
}

// --- UI & INTERACTION ---

function setLocation(lat, lon, name) {
    observerLat = parseFloat(lat);
    observerLon = parseFloat(lon);
    locationName = name;
    updateSky();
}

function setupUI() {
    // Toggles
    const link = (id, grp) => document.getElementById(id).addEventListener('change', e => grp.visible = e.target.checked);
    link('chk-grid', groups.grid);
    link('chk-lines', groups.lines);
    link('chk-const-names', groups.labels);
    link('chk-planets', groups.planets);
    link('chk-traj', groups.trajectories);
    link('chk-ground', groups.ground);
    
    // Search
    const inp = document.getElementById('city-input');
    const res = document.getElementById('search-results');
    
    inp.addEventListener('input', async (e) => {
        const val = e.target.value.toLowerCase();
        if(val.length < 2) { res.style.display='none'; return; }
        
        let html = '';
        
        // 1. Constellations & Stars
        let starsFound = '';
        Object.keys(CONSTELLATIONS).forEach(cName => {
            // Match Constellation Name
            if(cName.toLowerCase().includes(val)) {
                html += `<div class="search-item" onclick="alert('–ù–∞–π–¥–µ–Ω–æ —Å–æ–∑–≤–µ–∑–¥–∏–µ: ${cName}')">‚ú® ${cName} <span class="star-mag">–°–æ–∑–≤–µ–∑–¥–∏–µ</span></div>`;
            }
            // Match Stars inside
            CONSTELLATIONS[cName].stars.forEach(s => {
                if(s.name.toLowerCase().includes(val)) {
                    starsFound += `<div class="search-item" onclick="alert('–ó–≤–µ–∑–¥–∞: ${s.name} (${cName})')">‚≠ê ${s.name} <span class="star-mag">${cName}, mag:${s.mag}</span></div>`;
                }
            });
        });
        
        if(starsFound) html += `<div class="search-group-title">–ó–≤–µ–∑–¥—ã</div>` + starsFound;

        // 2. Planets
        PLANETS.forEach(p => {
             if(p.toLowerCase().includes(val)) html += `<div class="search-item">ü™ê ${p}</div>`;
        });

        // 3. Cities (API)
        try {
            const resp = await fetch(`https://nominatim.openstreetmap.org/search?format=json&q=${val}&limit=3&accept-language=ru`);
            const data = await resp.json();
            if(data.length) {
                html += `<div class="search-group-title">–ì–æ—Ä–æ–¥–∞</div>`;
                data.forEach(city => {
                    const n = city.display_name.split(',')[0];
                    html += `<div class="search-item" onclick="setCity(${city.lat}, ${city.lon}, '${n}')">üìç ${city.display_name}</div>`;
                });
            }
        } catch(e){}

        if(html) { res.innerHTML = html; res.style.display='block'; }
        else res.style.display='none';
    });
    
    window.setCity = (lat, lon, name) => {
        setLocation(lat, lon, name);
        res.style.display='none'; inp.value = name;
    };
    
    document.addEventListener('click', e => {
        if(e.target !== inp && e.target !== res) res.style.display='none';
    });
}

function animate() {
    requestAnimationFrame(animate);
    controls.update();
    renderer.render(scene, camera);
}

init();

</script>
</body>
</html>