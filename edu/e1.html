<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no, maximum-scale=1.0" />
  <title>Звёзды</title>

  <link rel="icon" href="sparkle.png" type="image/png" />
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&family=Jura:wght@400;500;600;700&display=swap" rel="stylesheet">

  <style>
    :root {
      --bg-color: #020206;
      --panel-bg: rgba(10, 10, 20, 0.85);
      --panel-border: rgba(255, 255, 255, 0.1);
      --text-main: #ffffff;
      --text-sec: #8899bb;
      --accent: #4da6ff;
      --accent-glow: rgba(77, 166, 255, 0.4);
      --accent-warm: #ffaa44;
      --accent-warm-glow: rgba(255, 170, 68, 0.4);
      --btn-bg: rgba(255, 255, 255, 0.06);
      --btn-hover: rgba(255, 255, 255, 0.15);
      --font-display: 'Jura', sans-serif;
      --font-body: 'Inter', sans-serif;
    }

    [data-theme="light"] {
      --bg-color: #f0f4f8;
      --panel-bg: rgba(255, 255, 255, 0.9);
      --panel-border: rgba(0, 0, 0, 0.08);
      --text-main: #0f172a;
      --text-sec: #64748b;
      --accent: #2563eb;
      --accent-glow: rgba(37, 99, 235, 0.2);
      --btn-bg: rgba(0, 0, 0, 0.04);
      --btn-hover: rgba(0, 0, 0, 0.08);
    }

    * { margin: 0; padding: 0; box-sizing: border-box; -webkit-tap-highlight-color: transparent; }

    html, body {
      width: 100%; height: 100%; overflow: hidden;
      background: var(--bg-color);
      font-family: var(--font-body);
      color: var(--text-main);
      transition: background 0.5s ease, color 0.5s ease;
    }

    canvas { display: block; outline: none; z-index: 1; }

    #ui-layer {
      position: absolute; inset: 0; z-index: 10; pointer-events: none;
      display: flex; flex-direction: column; justify-content: space-between;
      padding: 20px;
    }

    .top-bar {
      pointer-events: auto;
      display: flex; justify-content: space-between; align-items: flex-start;
    }

    .app-title h1 {
      font-family: var(--font-display); font-weight: 700; font-size: 26px;
      letter-spacing: 3px; text-transform: uppercase;
      background: linear-gradient(135deg, #ffffff 0%, #88aaff 50%, #ffaa66 100%);
      -webkit-background-clip: text; -webkit-text-fill-color: transparent;
      background-clip: text;
    }
    .app-title span { 
      font-size: 10px; color: var(--accent); letter-spacing: 5px; 
      text-transform: uppercase; font-weight: 600; 
      display: block; margin-top: 2px;
    }

    .controls-right {
      display: flex; gap: 10px; align-items: center;
    }

    .icon-btn {
      width: 42px; height: 42px; border-radius: 50%;
      background: var(--panel-bg); border: 1px solid var(--panel-border);
      backdrop-filter: blur(12px); -webkit-backdrop-filter: blur(12px);
      display: flex; align-items: center; justify-content: center;
      cursor: pointer; color: var(--text-main);
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      box-shadow: 0 4px 20px rgba(0,0,0,0.2);
    }
    .icon-btn:hover { transform: scale(1.1); background: var(--btn-hover); color: var(--accent); }
    .icon-btn svg { width: 20px; height: 20px; fill: none; stroke: currentColor; stroke-width: 2; }

    .delete-btn:hover { 
      color: #ff5555; border-color: rgba(255, 85, 85, 0.3);
      box-shadow: 0 4px 20px rgba(255, 85, 85, 0.25);
    }

    .scale-toggle {
      height: 42px; padding: 0 16px; border-radius: 21px;
      background: var(--panel-bg); border: 1px solid var(--panel-border);
      color: var(--text-sec); font-family: var(--font-display);
      font-size: 11px; font-weight: 600; text-transform: uppercase; letter-spacing: 1px;
      cursor: pointer; display: flex; align-items: center; gap: 8px;
      backdrop-filter: blur(12px); transition: all 0.3s;
    }
    .scale-toggle:hover { background: var(--btn-hover); color: var(--text-main); }
    .scale-toggle.active { 
      border-color: var(--accent); color: var(--accent); 
      background: rgba(77, 166, 255, 0.1);
      box-shadow: 0 0 15px var(--accent-glow);
    }
    .scale-indicator { width: 8px; height: 8px; border-radius: 50%; background: currentColor; }

    .space-toggle {
      height: 42px; padding: 0 16px; border-radius: 21px;
      background: var(--panel-bg); border: 1px solid var(--panel-border);
      color: var(--text-sec); font-family: var(--font-display);
      font-size: 11px; font-weight: 600; text-transform: uppercase; letter-spacing: 1px;
      cursor: pointer; display: flex; align-items: center; gap: 8px;
      backdrop-filter: blur(12px); transition: all 0.3s;
    }
    .space-toggle:hover { background: var(--btn-hover); color: var(--text-main); }
    .space-toggle.active { 
      border-color: var(--accent-warm); color: var(--accent-warm); 
      background: rgba(255, 170, 68, 0.1);
      box-shadow: 0 0 15px var(--accent-warm-glow);
    }
    .space-toggle svg {
      width: 16px; height: 16px; fill: none; stroke: currentColor; stroke-width: 2;
    }

    .temp-scale {
      pointer-events: auto;
      position: absolute; left: 20px; top: 50%; transform: translateY(-50%);
      background: var(--panel-bg); border: 1px solid var(--panel-border);
      border-radius: 16px; padding: 16px 12px;
      backdrop-filter: blur(16px); -webkit-backdrop-filter: blur(16px);
      box-shadow: 0 10px 40px rgba(0,0,0,0.3);
      width: 140px; transition: all 0.4s;
    }
    .temp-scale h3 {
      font-family: var(--font-display); font-size: 9px; 
      text-transform: uppercase; letter-spacing: 2px;
      color: var(--text-sec); margin-bottom: 12px; text-align: center;
    }
    .temp-bar {
      height: 220px; width: 20px; margin: 0 auto;
      border-radius: 10px; position: relative;
      background: linear-gradient(to top, 
        #FF3300 0%, #FF5500 15%, #FFAA33 30%, 
        #FFDDAA 45%, #FFFFFF 55%, #CCDEFF 70%, 
        #99BBFF 85%, #7799FF 100%);
      box-shadow: 0 0 15px rgba(255,150,100,0.3);
    }
    .temp-labels {
      position: absolute; left: 30px; top: 0; height: 100%;
      display: flex; flex-direction: column-reverse; justify-content: space-between;
      font-size: 9px; color: var(--text-sec); font-family: var(--font-display);
    }
    .temp-labels span { white-space: nowrap; }

    .dock-wrapper {
      pointer-events: auto;
      align-self: center; width: 100%; max-width: 1100px;
      display: flex; justify-content: center;
    }

    .dock {
      background: var(--panel-bg);
      backdrop-filter: blur(20px); -webkit-backdrop-filter: blur(20px);
      border: 1px solid var(--panel-border);
      padding: 10px 16px; border-radius: 24px;
      display: flex; gap: 12px; align-items: center;
      box-shadow: 0 20px 60px -10px rgba(0,0,0,0.4);
      transition: all 0.3s ease;
      max-width: 100%;
    }

    .reset-btn {
      width: 46px; height: 46px; flex-shrink: 0;
      border-radius: 14px; background: var(--btn-bg);
      border: 1px solid var(--panel-border); color: var(--text-sec);
      display: flex; align-items: center; justify-content: center;
      cursor: pointer; transition: all 0.3s;
    }
    .reset-btn:hover {
      background: linear-gradient(135deg, #4da6ff, #2563eb); 
      color: white; border-color: transparent;
      box-shadow: 0 0 25px rgba(77, 166, 255, 0.5);
      transform: translateY(-2px) rotate(90deg);
    }
    .reset-btn svg { width: 24px; height: 24px; stroke-width: 1.5; }

    .divider { width: 1px; height: 30px; background: var(--panel-border); margin: 0 2px; flex-shrink: 0; }

    .star-scroll {
      display: flex; gap: 6px; overflow-x: auto; padding: 4px;
      -ms-overflow-style: none; scrollbar-width: none; 
      scroll-behavior: smooth;
      flex: 1; min-width: 0;
    }
    .star-scroll::-webkit-scrollbar { display: none; }

    .chip {
      padding: 8px 12px; border-radius: 10px;
      background: var(--btn-bg); color: var(--text-sec);
      font-family: var(--font-display); font-size: 10px; font-weight: 600;
      cursor: pointer; white-space: nowrap; border: 1px solid transparent;
      transition: all 0.2s; user-select: none; letter-spacing: 0.3px;
      display: flex; align-items: center; gap: 5px;
      flex-shrink: 0;
    }
    .chip .color-dot {
      width: 6px; height: 6px; border-radius: 50%;
      box-shadow: 0 0 4px currentColor;
      flex-shrink: 0;
    }
    .chip:hover { background: var(--btn-hover); color: var(--text-main); transform: translateY(-2px); }
    .chip.active {
      background: rgba(77, 166, 255, 0.15); color: var(--accent);
      border-color: rgba(77, 166, 255, 0.4);
      box-shadow: 0 4px 15px var(--accent-glow);
    }

    .compare-panel {
      pointer-events: auto;
      position: absolute; right: 20px; top: 50%; transform: translateY(-50%);
      background: var(--panel-bg); border: 1px solid var(--panel-border);
      border-radius: 16px; padding: 16px;
      backdrop-filter: blur(16px); -webkit-backdrop-filter: blur(16px);
      box-shadow: 0 10px 40px rgba(0,0,0,0.3);
      width: 150px;
      transition: opacity 0.3s, visibility 0.3s;
    }
    .compare-panel.hidden {
      opacity: 0;
      visibility: hidden;
      pointer-events: none;
    }
    .compare-panel h3 {
      font-family: var(--font-display); font-size: 9px; 
      text-transform: uppercase; letter-spacing: 2px;
      color: var(--text-sec); margin-bottom: 10px; text-align: center;
    }
    .compare-btn {
      width: 100%; padding: 10px; margin-bottom: 8px;
      border-radius: 10px; border: 1px solid var(--panel-border);
      background: var(--btn-bg); color: var(--text-sec);
      font-family: var(--font-display); font-size: 10px;
      cursor: pointer; transition: all 0.3s; text-transform: uppercase;
      letter-spacing: 1px;
    }
    .compare-btn:last-child { margin-bottom: 0; }
    .compare-btn:hover { background: var(--btn-hover); color: var(--text-main); }
    .compare-btn.active {
      background: rgba(77, 166, 255, 0.15); color: var(--accent);
      border-color: var(--accent);
    }

    .space-info {
      pointer-events: auto;
      position: absolute; right: 20px; top: 50%; transform: translateY(-50%);
      background: var(--panel-bg); border: 1px solid var(--panel-border);
      border-radius: 16px; padding: 16px;
      backdrop-filter: blur(16px); -webkit-backdrop-filter: blur(16px);
      box-shadow: 0 10px 40px rgba(0,0,0,0.3);
      width: 180px;
      opacity: 0; visibility: hidden; transition: opacity 0.3s, visibility 0.3s;
    }
    .space-info.visible {
      opacity: 1; visibility: visible;
    }
    .space-info h3 {
      font-family: var(--font-display); font-size: 9px; 
      text-transform: uppercase; letter-spacing: 2px;
      color: var(--text-sec); margin-bottom: 10px; text-align: center;
    }
    .space-info p {
      font-size: 11px; color: var(--text-sec); line-height: 1.6;
      margin-bottom: 10px;
    }
    .space-info .legend {
      display: flex; flex-direction: column; gap: 6px;
      padding-top: 10px; border-top: 1px solid var(--panel-border);
    }
    .space-info .legend-item {
      display: flex; align-items: center; gap: 8px;
      font-size: 10px; color: var(--text-sec);
    }
    .space-info .legend-dot {
      width: 8px; height: 8px; border-radius: 50%;
    }

    .modal {
      position: fixed; inset: 0; z-index: 100;
      background: rgba(0,0,0,0.6); backdrop-filter: blur(8px);
      opacity: 0; visibility: hidden; transition: all 0.3s;
      display: flex; align-items: center; justify-content: center;
    }
    .modal.visible { opacity: 1; visibility: visible; }

    .card {
      width: 95%; max-width: 720px;
      background: var(--bg-color); color: var(--text-main);
      border: 1px solid var(--panel-border);
      border-radius: 28px; padding: 36px;
      box-shadow: 0 40px 100px -20px rgba(0,0,0,0.6);
      transform: translateY(30px) scale(0.95); 
      transition: all 0.5s cubic-bezier(0.19, 1, 0.22, 1);
      max-height: 90vh; overflow-y: auto; position: relative;
    }
    .modal.visible .card { transform: translateY(0) scale(1); }

    .card-header {
      display: flex; align-items: center; gap: 20px; margin-bottom: 24px;
    }
    .star-preview {
      width: 70px; height: 70px; border-radius: 50%;
      box-shadow: 0 0 40px var(--star-color, #ffaa44);
      flex-shrink: 0;
    }
    .card h2 { 
      font-family: var(--font-display); font-size: 36px; 
      margin-bottom: 4px; line-height: 1; font-weight: 500; 
    }
    .card .type { 
      color: var(--accent); font-size: 10px; text-transform: uppercase; 
      letter-spacing: 2px; font-weight: 600; 
    }
    .card .constellation {
      color: var(--text-sec); font-size: 11px; margin-top: 4px;
    }

    .stats { 
      display: grid; grid-template-columns: repeat(4, 1fr);
      gap: 16px 12px; margin-bottom: 20px; 
    }
    .stat h4 { 
      font-size: 9px; text-transform: uppercase; 
      color: var(--text-sec); margin-bottom: 3px; letter-spacing: 1px; 
    }
    .stat p { 
      font-family: var(--font-display); font-size: 13px; font-weight: 600; 
      color: var(--text-main);
    }
    .stat span.sub {
      display: block; font-size: 10px; 
      color: var(--text-sec); font-weight: 400; margin-top: 1px;
    }

    .fact { 
      font-size: 13px; line-height: 1.7; color: var(--text-sec); 
      padding-top: 20px; border-top: 1px solid var(--panel-border); 
    }
    .close-modal {
      position: absolute; top: 20px; right: 20px; width: 34px; height: 34px;
      background: var(--btn-bg); border: none; border-radius: 50%; color: var(--text-sec);
      cursor: pointer; display: flex; align-items: center; justify-content: center; 
      transition: 0.2s; font-size: 18px;
    }
    .close-modal:hover { background: var(--btn-hover); color: var(--text-main); }

    .size-indicator {
      pointer-events: none;
      position: absolute; bottom: 100px; left: 50%; transform: translateX(-50%);
      background: var(--panel-bg); border: 1px solid var(--panel-border);
      padding: 8px 16px; border-radius: 20px;
      backdrop-filter: blur(12px);
      font-family: var(--font-display); font-size: 11px;
      color: var(--text-sec); letter-spacing: 1px;
      opacity: 0; transition: opacity 0.3s;
    }
    .size-indicator.visible { opacity: 1; pointer-events: auto; }

    .connection-lines {
      position: absolute;
      pointer-events: none;
    }
    
    .bg-toggle {
      height: 42px; padding: 0 16px; border-radius: 21px;
      background: var(--panel-bg); border: 1px solid var(--panel-border);
      color: var(--text-sec); font-family: var(--font-display);
      font-size: 11px; font-weight: 600; text-transform: uppercase; letter-spacing: 1px;
      cursor: pointer; display: flex; align-items: center; gap: 8px;
      backdrop-filter: blur(12px); transition: all 0.3s;
    }
    .bg-toggle:hover { background: var(--btn-hover); color: var(--text-main); }
    .bg-toggle.active { 
      border-color: #8866ff; color: #8866ff; 
      background: rgba(136, 102, 255, 0.1);
      box-shadow: 0 0 15px rgba(136, 102, 255, 0.3);
    }
    .bg-toggle svg {
      width: 16px; height: 16px; fill: none; stroke: currentColor; stroke-width: 2;
    }

    .app-title {
      min-width: 200px;
    }

    .app-title h1 {
      transition: opacity 0.2s ease;
    }
    
    .app-title span {
      transition: opacity 0.2s ease, color 0.2s ease;
    }

    @media (max-width: 900px) {
      .temp-scale, .compare-panel, .space-info { display: none; }
    }

    @media (max-width: 768px) {
      .dock { flex-direction: column-reverse; padding: 14px; width: 100%; border-radius: 20px; gap: 14px; }
      .dock-wrapper { max-width: 100%; }
      .star-scroll { width: 100%; justify-content: flex-start; }
      .divider { display: none; }
      .reset-btn { width: 100%; height: 48px; border-radius: 12px; }
      .top-bar { margin-bottom: 16px; }
      #ui-layer { padding: 14px; }
      .card h2 { font-size: 28px; }
      .stats { grid-template-columns: repeat(2, 1fr); }
      .space-toggle span { display: none; }
    }

    @media (max-width: 500px) {
      .card { 
        padding: 20px; width: 100%; border-radius: 20px 20px 0 0; 
        position: absolute; bottom: 0; top: auto; transform: translateY(100%); 
      }
      .modal.visible .card { transform: translateY(0); }
      .stats { grid-template-columns: 1fr 1fr; }
    }
  </style>
</head>
<body data-theme="dark">

  <div id="ui-layer">
    <div class="top-bar">
      <div class="app-title">
        <h1>Звёзды</h1>
        <span>нашей Галактики</span>
      </div>
      
      <div class="controls-right">
        <button class="bg-toggle" id="btnBgToggle" onclick="toggleBackground()" title="Переключить фон">
          <svg viewBox="0 0 24 24">
            <circle cx="12" cy="12" r="10"></circle>
            <path d="M12 2a10 10 0 0 1 0 20" fill="currentColor" opacity="0.3"></path>
          </svg>
          <span>Фон</span>
        </button>

        <button class="space-toggle" id="btnSpaceView" onclick="toggleSpaceView()" title="Показать в пространстве">
          <svg viewBox="0 0 24 24">
            <circle cx="12" cy="12" r="2"></circle>
            <circle cx="12" cy="12" r="6" stroke-dasharray="2 2"></circle>
            <circle cx="12" cy="12" r="10" stroke-dasharray="3 3"></circle>
          </svg>
          <span>В пространстве</span>
        </button>

        <button class="scale-toggle active" id="btnRealScale" onclick="toggleRealScale()" title="Реальный масштаб">
          <div class="scale-indicator"></div>
          <span>Масштаб</span>
        </button>

        <button class="icon-btn theme-btn" onclick="toggleTheme()" title="Сменить тему">
          <svg class="icon-moon" viewBox="0 0 24 24" style="display:block"><path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path></svg>
          <svg class="icon-sun" viewBox="0 0 24 24" style="display:none"><circle cx="12" cy="12" r="5"></circle><line x1="12" y1="1" x2="12" y2="3"></line><line x1="12" y1="21" x2="12" y2="23"></line><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line><line x1="1" y1="12" x2="3" y2="12"></line><line x1="21" y1="12" x2="23" y2="12"></line><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line></svg>
        </button>

        <button class="icon-btn delete-btn" onclick="clearCache()" title="Очистить кэш">
          <svg viewBox="0 0 24 24">
            <ellipse cx="12" cy="5" rx="9" ry="3"></ellipse>
            <path d="M21 12c0 1.66-4 3-9 3s-9-1.34-9-3"></path>
            <path d="M3 5v14c0 1.66 4 3 9 3 1.2 0 2.33-.08 3.39-.23"></path>
            <line x1="21" y1="21" x2="17" y2="17" stroke-width="2.5"></line>
            <line x1="17" y1="21" x2="21" y2="17" stroke-width="2.5"></line>
          </svg>
        </button>
      </div>
    </div>

    <div class="temp-scale">
      <h3>Температура</h3>
      <div style="position: relative;">
        <div class="temp-bar"></div>
        <div class="temp-labels">
          <span>2 000 K</span>
          <span>5 000 K</span>
          <span>10 000 K</span>
          <span>20 000 K</span>
          <span>50 000 K</span>
        </div>
      </div>
    </div>

    <div class="compare-panel" id="comparePanel">
      <h3>Сравнение</h3>
      <button class="compare-btn active" data-mode="size" onclick="setCompareMode('size')">По размеру</button>
      <button class="compare-btn" data-mode="luminosity" onclick="setCompareMode('luminosity')">По светимости</button>
      <button class="compare-btn" data-mode="mass" onclick="setCompareMode('mass')">По массе</button>
      <button class="compare-btn" data-mode="temp" onclick="setCompareMode('temp')">По температуре</button>
    </div>

    <div class="space-info" id="spaceInfo">
      <h3>3D Карта</h3>
      <p>Звёзды расположены по реальным галактическим координатам относительно Солнца.</p>
      <p style="font-size: 10px; color: var(--accent);">Масштаб сжат для далёких звёзд</p>
      <div class="legend">
        <div class="legend-item">
          <div class="legend-dot" style="background: #FFF5E0;"></div>
          <span>Солнце (центр)</span>
        </div>
        <div class="legend-item">
          <div class="legend-dot" style="background: #4da6ff;"></div>
          <span>Ближние (&lt;50 св.лет)</span>
        </div>
        <div class="legend-item">
          <div class="legend-dot" style="background: #FF6B4A;"></div>
          <span>Дальние (&gt;500 св.лет)</span>
        </div>
      </div>
    </div>

    <div class="size-indicator" id="sizeIndicator">
      <span id="sizeText">Солнце = 1</span>
    </div>

    <div class="dock-wrapper">
      <div class="dock">
        <button class="reset-btn" onclick="clearAll()" title="Сбросить всё">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor">
            <path d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z"></path>
          </svg>
        </button>
        <div class="divider"></div>
        <div class="star-scroll" id="starBtns"></div>
      </div>
    </div>
  </div>

  <div class="modal" id="modal">
    <div class="card">
      <button class="close-modal" onclick="closeModal()">×</button>
      <div class="card-header">
        <div class="star-preview" id="mPreview"></div>
        <div>
          <h2 id="mTitle">Звезда</h2>
          <div class="type" id="mType">Тип</div>
          <div class="constellation" id="mConstellation">Созвездие</div>
        </div>
      </div>
      <div class="stats" id="mStats"></div>
      <p class="fact" id="mFact">...</p>
    </div>
  </div>

  <script type="importmap">
    { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js", "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/" } }
  </script>

  <script type="module">
    import * as THREE from "three";
    import { OrbitControls } from "three/addons/controls/OrbitControls.js";
    import { UnrealBloomPass } from "three/addons/postprocessing/UnrealBloomPass.js";
    import { EffectComposer } from "three/addons/postprocessing/EffectComposer.js";
    import { RenderPass } from "three/addons/postprocessing/RenderPass.js";
    import { STARS_DATA } from './stars.js';

    const STARS = STARS_DATA;

    const starScroll = document.getElementById('starBtns');
    starScroll.addEventListener('wheel', (e) => {
      e.preventDefault();
      starScroll.scrollLeft += e.deltaY;
    }, { passive: false });

    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.01, 500000);
    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.0;
    document.body.appendChild(renderer.domElement);

    const composer = new EffectComposer(renderer);
    composer.addPass(new RenderPass(scene, camera));
    const bloomPass = new UnrealBloomPass(
      new THREE.Vector2(window.innerWidth, window.innerHeight),
      0.8,
      0.4,
      0.85
    );
    composer.addPass(bloomPass);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.08;
    controls.minDistance = 1;
    controls.maxDistance = 50000;
    controls.enableZoom = true;
    controls.zoomSpeed = 1.2;
    controls.rotateSpeed = 0.5;
    controls.enablePan = true;
    controls.panSpeed = 0.5;
    controls.maxPolarAngle = Math.PI * 0.85;
    controls.minPolarAngle = Math.PI * 0.15;

    const ambLight = new THREE.AmbientLight(0x445566, 0.6);
    scene.add(ambLight);

    const hemiLight = new THREE.HemisphereLight(0xddeeff, 0x0f0e0d, 0.4);
    scene.add(hemiLight);

    const bgGeo = new THREE.SphereGeometry(100000, 64, 64);
    const bgLoader = new THREE.TextureLoader();
    const bgMat = new THREE.MeshBasicMaterial({
      map: bgLoader.load('textures/milkyway.jpg'),
      side: THREE.BackSide,
      transparent: true,
      opacity: 0.9,
      depthWrite: false
    });
    const skyboxMilkyWay = new THREE.Mesh(bgGeo, bgMat);
    skyboxMilkyWay.renderOrder = -1;
    scene.add(skyboxMilkyWay);

    function createStarfield() {
      const count = 8000;
      const geo = new THREE.BufferGeometry();
      const pos = new Float32Array(count * 3);
      const sizes = new Float32Array(count);
      const colors = new Float32Array(count * 3);
      
      for (let i = 0; i < count; i++) {
        const r = 5000 + Math.random() * 20000;
        const theta = Math.random() * Math.PI * 2;
        const phi = Math.acos(2 * Math.random() - 1);
        pos[i * 3] = r * Math.sin(phi) * Math.cos(theta);
        pos[i * 3 + 1] = r * Math.cos(phi);
        pos[i * 3 + 2] = r * Math.sin(phi) * Math.sin(theta);
        sizes[i] = 0.3 + Math.random() * 1.5;
        
        const hue = 0.55 + Math.random() * 0.15;
        const c = new THREE.Color().setHSL(hue, 0.2, 0.8 + Math.random() * 0.2);
        colors[i * 3] = c.r;
        colors[i * 3 + 1] = c.g;
        colors[i * 3 + 2] = c.b;
      }
      
      geo.setAttribute('position', new THREE.BufferAttribute(pos, 3));
      geo.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
      geo.setAttribute('color', new THREE.BufferAttribute(colors, 3));
      
      const canvas = document.createElement('canvas');
      canvas.width = 64;
      canvas.height = 64;
      const ctx = canvas.getContext('2d');
      const grad = ctx.createRadialGradient(32, 32, 0, 32, 32, 32);
      grad.addColorStop(0, 'rgba(255,255,255,1)');
      grad.addColorStop(0.15, 'rgba(255,255,255,0.8)');
      grad.addColorStop(0.4, 'rgba(200,220,255,0.3)');
      grad.addColorStop(1, 'rgba(0,0,0,0)');
      ctx.fillStyle = grad;
      ctx.fillRect(0, 0, 64, 64);
      const tex = new THREE.Texture(canvas);
      tex.needsUpdate = true;
      
      const mat = new THREE.PointsMaterial({
        size: 1.2,
        map: tex,
        vertexColors: true,
        transparent: true,
        opacity: 0.9,
        blending: THREE.AdditiveBlending,
        depthWrite: false
      });
      
      return new THREE.Points(geo, mat);
    }
    const stars = createStarfield();
    scene.add(stars);

    const starVertexShader = `
      varying vec2 vUv;
      varying vec3 vNormal;
      varying vec3 vPosition;
      varying vec3 vWorldPosition;
      
      void main() {
        vUv = uv;
        vNormal = normalize(normalMatrix * normal);
        vPosition = position;
        vWorldPosition = (modelMatrix * vec4(position, 1.0)).xyz;
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
      }
    `;

    const starFragmentShader = `
      uniform float time;
      uniform vec3 starColor;
      uniform vec3 coronaColor;
      uniform float temperature;
      uniform float rotationSpeed;
      varying vec3 vNormal;
      varying vec3 vPosition;
      varying vec2 vUv;
      
      vec3 mod289v3(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
      vec4 mod289v4(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
      vec4 permute(vec4 x) { return mod289v4(((x * 34.0) + 1.0) * x); }
      vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }
      
      float snoise(vec3 v) {
        const vec2 C = vec2(1.0/6.0, 1.0/3.0);
        const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);
        vec3 i = floor(v + dot(v, C.yyy));
        vec3 x0 = v - i + dot(i, C.xxx);
        vec3 g = step(x0.yzx, x0.xyz);
        vec3 l = 1.0 - g;
        vec3 i1 = min(g.xyz, l.zxy);
        vec3 i2 = max(g.xyz, l.zxy);
        vec3 x1 = x0 - i1 + C.xxx;
        vec3 x2 = x0 - i2 + C.yyy;
        vec3 x3 = x0 - D.yyy;
        i = mod289v3(i);
        vec4 p = permute(permute(permute(i.z + vec4(0.0, i1.z, i2.z, 1.0)) + i.y + vec4(0.0, i1.y, i2.y, 1.0)) + i.x + vec4(0.0, i1.x, i2.x, 1.0));
        float n_ = 0.142857142857;
        vec3 ns = n_ * D.wyz - D.xzx;
        vec4 j = p - 49.0 * floor(p * ns.z * ns.z);
        vec4 x_ = floor(j * ns.z);
        vec4 y_ = floor(j - 7.0 * x_);
        vec4 x = x_ * ns.x + ns.yyyy;
        vec4 y = y_ * ns.x + ns.yyyy;
        vec4 h = 1.0 - abs(x) - abs(y);
        vec4 b0 = vec4(x.xy, y.xy);
        vec4 b1 = vec4(x.zw, y.zw);
        vec4 s0 = floor(b0) * 2.0 + 1.0;
        vec4 s1 = floor(b1) * 2.0 + 1.0;
        vec4 sh = -step(h, vec4(0.0));
        vec4 a0 = b0.xzyw + s0.xzyw * sh.xxyy;
        vec4 a1 = b1.xzyw + s1.xzyw * sh.zzww;
        vec3 p0 = vec3(a0.xy, h.x);
        vec3 p1 = vec3(a0.zw, h.y);
        vec3 p2 = vec3(a1.xy, h.z);
        vec3 p3 = vec3(a1.zw, h.w);
        vec4 norm = taylorInvSqrt(vec4(dot(p0, p0), dot(p1, p1), dot(p2, p2), dot(p3, p3)));
        p0 *= norm.x; p1 *= norm.y; p2 *= norm.z; p3 *= norm.w;
        vec4 m = max(0.6 - vec4(dot(x0, x0), dot(x1, x1), dot(x2, x2), dot(x3, x3)), 0.0);
        m = m * m;
        return 42.0 * dot(m * m, vec4(dot(p0, x0), dot(p1, x1), dot(p2, x2), dot(p3, x3)));
      }
      
      float fbm(vec3 p) {
        float f = 0.0;
        float amplitude = 0.5;
        float frequency = 1.0;
        for (int i = 0; i < 5; i++) {
          f += amplitude * snoise(p * frequency);
          frequency *= 2.0;
          amplitude *= 0.5;
        }
        return f;
      }

      void main() {
        vec3 pos = vPosition;
        float t = time * rotationSpeed;
        
        float theta = atan(pos.z, pos.x) + t * 0.1;
        float phi = acos(pos.y / length(pos));
        vec3 rotatedPos = vec3(cos(theta) * sin(phi), cos(phi), sin(theta) * sin(phi)) * length(pos);
        
        float noise1 = fbm(rotatedPos * 2.0 + vec3(t * 0.05));
        float noise2 = fbm(rotatedPos * 4.0 - vec3(t * 0.03, 0.0, t * 0.02));
        float noise3 = snoise(rotatedPos * 8.0 + vec3(0.0, t * 0.1, 0.0));
        
        float granulation = noise1 * 0.4 + noise2 * 0.3 + noise3 * 0.15;
        
        float sunspotNoise = fbm(rotatedPos * 1.5 + vec3(t * 0.01));
        float sunspots = smoothstep(0.3, 0.5, sunspotNoise) * 0.3;
        
        vec3 baseColor = starColor;
        vec3 brightColor = starColor * 1.4 + vec3(0.1);
        vec3 darkColor = starColor * 0.6;
        
        vec3 surfaceColor = mix(baseColor, brightColor, granulation * 0.5);
        surfaceColor = mix(surfaceColor, darkColor, sunspots);
        
        vec3 normal = normalize(vNormal);
        float fresnel = 1.0 - max(dot(normal, vec3(0.0, 0.0, 1.0)), 0.0);
        
        float limbDarkening = pow(1.0 - fresnel, 0.4);
        surfaceColor *= limbDarkening;
        
        vec3 edgeGlow = coronaColor * pow(fresnel, 2.0) * 0.5;
        surfaceColor += edgeGlow;
        
        float convectionBrightness = snoise(rotatedPos * 6.0 + vec3(t * 0.15)) * 0.1 + 1.0;
        surfaceColor *= convectionBrightness;
        
        gl_FragColor = vec4(surfaceColor, 1.0);
      }
    `;

    const coronaVertexShader = `
      varying vec3 vNormal;
      varying vec3 vPosition;
      varying vec3 vWorldPosition;
      
      void main() {
        vNormal = normalize(normalMatrix * normal);
        vPosition = position;
        vWorldPosition = (modelMatrix * vec4(position, 1.0)).xyz;
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
      }
    `;

    const coronaFragmentShader = `
      uniform float time;
      uniform vec3 coronaColor;
      uniform float rotationSpeed;
      varying vec3 vNormal;
      varying vec3 vPosition;
      
      float hash(float n) { return fract(sin(n) * 43758.5453123); }
      
      float noise(vec3 x) {
        vec3 p = floor(x);
        vec3 f = fract(x);
        f = f * f * (3.0 - 2.0 * f);
        float n = p.x + p.y * 57.0 + p.z * 113.0;
        return mix(mix(mix(hash(n), hash(n + 1.0), f.x),
                       mix(hash(n + 57.0), hash(n + 58.0), f.x), f.y),
                   mix(mix(hash(n + 113.0), hash(n + 114.0), f.x),
                       mix(hash(n + 170.0), hash(n + 171.0), f.x), f.y), f.z);
      }

      void main() {
        vec3 viewDir = normalize(cameraPosition - vPosition);
        float fresnel = 1.0 - abs(dot(vNormal, vec3(0.0, 0.0, 1.0)));
        
        float t = time * rotationSpeed * 0.5;
        vec3 rotatedPos = vPosition;
        float theta = atan(rotatedPos.z, rotatedPos.x) + t * 0.05;
        rotatedPos = vec3(cos(theta) * length(vec2(vPosition.x, vPosition.z)), vPosition.y, sin(theta) * length(vec2(vPosition.x, vPosition.z)));
        
        float gas = noise(rotatedPos * 0.3 + t * 0.1);
        gas += noise(rotatedPos * 0.6 - t * 0.05) * 0.5;
        
        float alpha = pow(fresnel, 3.0) * (0.4 + gas * 0.3);
        alpha *= smoothstep(0.0, 0.7, 1.0 - fresnel);

        gl_FragColor = vec4(coronaColor, alpha * 0.5);
      }
    `;

    const glowVertexShader = `
      varying vec3 vNormal;
      varying vec3 vPosition;
      
      void main() {
        vNormal = normalize(normalMatrix * normal);
        vPosition = position;
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
      }
    `;

    const glowFragmentShader = `
      uniform vec3 glowColor;
      uniform vec3 viewVector;
      uniform float intensity;
      uniform float time;
      varying vec3 vNormal;
      varying vec3 vPosition;
      
      void main() {
        vec3 viewDir = normalize(viewVector);
        float fresnel = 1.0 - max(dot(vNormal, viewDir), 0.0);
        
        float glow1 = pow(fresnel, 4.0) * 0.8;
        float glow2 = pow(fresnel, 2.0) * 0.3;
        
        float totalGlow = glow1 + glow2;
        
        float pulse = sin(time * 0.3) * 0.05 + 1.0;
        totalGlow *= pulse * intensity;
        
        vec3 finalColor = glowColor * totalGlow;
        float alpha = totalGlow * 0.4;
        
        gl_FragColor = vec4(finalColor, alpha);
      }
    `;

    const starsGroup = new THREE.Group();
    scene.add(starsGroup);

    const connectionsGroup = new THREE.Group();
    scene.add(connectionsGroup);
    
    let activeStars = [];
    const addedKeys = new Set();
    let compareMode = 'size';
    let realScaleMode = true;
    let spaceViewMode = false;
    let showGalaxyBackground = true;

    function galacticToCartesian(l, b, dist) {
      const lRad = l * Math.PI / 180;
      const bRad = b * Math.PI / 180;
      
      let scaledDist;
      if (dist < 1) {
        scaledDist = dist * 5;
      } else if (dist < 50) {
        scaledDist = 5 + (dist - 1) * 2;
      } else if (dist < 200) {
        scaledDist = 5 + 49 * 2 + (dist - 50) * 0.8;
      } else if (dist < 1000) {
        scaledDist = 5 + 49 * 2 + 150 * 0.8 + (dist - 200) * 0.3;
      } else {
        scaledDist = 5 + 49 * 2 + 150 * 0.8 + 800 * 0.3 + (dist - 1000) * 0.1;
      }
      
      const x = scaledDist * Math.cos(bRad) * Math.cos(lRad);
      const y = scaledDist * Math.sin(bRad);
      const z = scaledDist * Math.cos(bRad) * Math.sin(lRad);
      
      return { x, y, z };
    }

    window.toggleBackground = () => {
      showGalaxyBackground = !showGalaxyBackground;
      const btn = document.getElementById('btnBgToggle');
      btn.classList.toggle('active', !showGalaxyBackground);
      
      if (showGalaxyBackground) {
        skyboxMilkyWay.visible = isDark;
        stars.visible = isDark;
        scene.background = null;
      } else {
        skyboxMilkyWay.visible = false;
        stars.visible = false;
        scene.background = new THREE.Color(0x000000);
      }
    };

    function calculateVisualRadius(data, isRealScale) {
      if (spaceViewMode) {
        const brightnessSize = Math.log10(data.luminosity + 1) * 0.3 + 0.5;
        return Math.min(Math.max(brightnessSize, 0.3), 2);
      }
      
      switch (compareMode) {
        case 'mass':
          if (isRealScale) {
            return Math.pow(data.mass, 0.5) * 2;
          }
          return 12;
        case 'luminosity':
          if (isRealScale) {
            return Math.pow(data.luminosity, 0.25) * 2;
          }
          return 12;
        case 'temp':
          if (isRealScale) {
            return (data.temperature / 5778) * 3;
          }
          return 12;
        case 'size':
        default:
          if (isRealScale) {
            if (data.radius <= 1) {
              return data.radius * 3;
            } else if (data.radius <= 10) {
              return 3 + (data.radius - 1) * 1.5;
            } else if (data.radius <= 100) {
              return 3 + 9 * 1.5 + (data.radius - 10) * 0.8;
            } else if (data.radius <= 500) {
              return 3 + 9 * 1.5 + 90 * 0.8 + (data.radius - 100) * 0.4;
            } else {
              return 3 + 9 * 1.5 + 90 * 0.8 + 400 * 0.4 + (data.radius - 500) * 0.15;
            }
          } else {
            return 12;
          }
      }
    }

    function createStar(key) {
      const d = STARS[key];
      const group = new THREE.Group();
      
      const visualRadius = calculateVisualRadius(d, realScaleMode);
      const rotationSpeed = 0.15 / Math.sqrt(Math.max(d.radius, 0.1));
      
      const starMat = new THREE.ShaderMaterial({
        uniforms: {
          time: { value: 0 },
          starColor: { value: new THREE.Color(d.color) },
          coronaColor: { value: new THREE.Color(d.coronaColor) },
          temperature: { value: d.temperature },
          starRadius: { value: visualRadius },
          rotationSpeed: { value: rotationSpeed }
        },
        vertexShader: starVertexShader,
        fragmentShader: starFragmentShader
      });
      
      const starMesh = new THREE.Mesh(
        new THREE.SphereGeometry(visualRadius, 128, 128),
        starMat
      );
      group.add(starMesh);
      
      const innerCoronaMat = new THREE.ShaderMaterial({
        uniforms: {
          time: { value: 0 },
          coronaColor: { value: new THREE.Color(d.coronaColor) },
          viewVector: { value: camera.position },
          temperature: { value: d.temperature },
          starRadius: { value: visualRadius },
          rotationSpeed: { value: rotationSpeed }
        },
        vertexShader: coronaVertexShader,
        fragmentShader: coronaFragmentShader,
        side: THREE.BackSide,
        blending: THREE.AdditiveBlending,
        transparent: true,
        depthWrite: false
      });
      
      const innerCorona = new THREE.Mesh(
        new THREE.SphereGeometry(visualRadius * 1.08, 64, 64),
        innerCoronaMat
      );
      group.add(innerCorona);
      
      const glowMat = new THREE.ShaderMaterial({
        uniforms: {
          glowColor: { value: new THREE.Color(d.coronaColor) },
          viewVector: { value: camera.position },
          intensity: { value: 0.5 },
          time: { value: 0 }
        },
        vertexShader: glowVertexShader,
        fragmentShader: glowFragmentShader,
        side: THREE.BackSide,
        blending: THREE.AdditiveBlending,
        transparent: true,
        depthWrite: false
      });
      
      const atmosphericGlow = new THREE.Mesh(
        new THREE.SphereGeometry(visualRadius * 1.15, 32, 32),
        glowMat
      );
      group.add(atmosphericGlow);
      
      const glowCanvas = createGlowTexture(d.coronaColor, d.color);
      const glowTex = new THREE.CanvasTexture(glowCanvas);
      const glowSprite = new THREE.Sprite(
        new THREE.SpriteMaterial({
          map: glowTex,
          transparent: true,
          blending: THREE.AdditiveBlending,
          depthWrite: false,
          opacity: 0.25
        })
      );
      glowSprite.scale.set(visualRadius * 2.2, visualRadius * 2.2, 1);
      group.add(glowSprite);
      
      const lightIntensity = Math.min(Math.sqrt(d.luminosity) / 10, 5) + 0.5;
      const light = new THREE.PointLight(
        new THREE.Color(d.color).getHex(),
        lightIntensity,
        visualRadius * 15
      );
      group.add(light);

      const labelCanvas = createLabelTexture(key, d.distance);
      const labelTex = new THREE.CanvasTexture(labelCanvas);
      const labelSprite = new THREE.Sprite(
        new THREE.SpriteMaterial({
          map: labelTex,
          transparent: true,
          depthTest: false
        })
      );
      labelSprite.scale.set(visualRadius * 5, visualRadius * 2.5, 1);
      labelSprite.position.y = visualRadius * 1.8;
      labelSprite.visible = spaceViewMode;
      group.add(labelSprite);
      
      group.userData = {
        name: key,
        ...d,
        visualRadius,
        rotationSpeed,
        starMesh,
        innerCorona,
        atmosphericGlow,
        glowSprite,
        light,
        labelSprite
      };
      
      return group;
    }

    function createGlowTexture(coronaColorStr, starColorStr) {
      const canvas = document.createElement('canvas');
      canvas.width = 256;
      canvas.height = 256;
      const ctx = canvas.getContext('2d');
      
      const coronaColor = new THREE.Color(coronaColorStr);
      const starColor = new THREE.Color(starColorStr);
      const cx = 128, cy = 128;
      
      const gradient1 = ctx.createRadialGradient(cx, cy, 0, cx, cy, 50);
      gradient1.addColorStop(0, `rgba(255, 255, 255, 0.8)`);
      gradient1.addColorStop(0.3, `rgba(${Math.round(starColor.r*255)}, ${Math.round(starColor.g*255)}, ${Math.round(starColor.b*255)}, 0.5)`);
      gradient1.addColorStop(0.7, `rgba(${Math.round(coronaColor.r*255)}, ${Math.round(coronaColor.g*255)}, ${Math.round(coronaColor.b*255)}, 0.2)`);
      gradient1.addColorStop(1, 'rgba(0,0,0,0)');
      ctx.fillStyle = gradient1;
      ctx.fillRect(0, 0, 256, 256);
      
      return canvas;
    }

    function createLabelTexture(name, distance) {
      const canvas = document.createElement('canvas');
      canvas.width = 320;
      canvas.height = 80;
      const ctx = canvas.getContext('2d');
      
      ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';
      ctx.roundRect(10, 10, canvas.width - 20, canvas.height - 20, 10);
      ctx.fill();
      
      ctx.font = 'bold 22px Jura, sans-serif';
      ctx.fillStyle = '#ffffff';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(name, canvas.width / 2, 32);
      
      let distText;
      if (distance < 0.01) {
        distText = '☀ Центр';
      } else if (distance < 1) {
        distText = `${(distance * 63241).toFixed(0)} а.е.`;
      } else if (distance < 100) {
        distText = `${distance.toFixed(2)} св. лет`;
      } else {
        distText = `${distance.toFixed(0)} св. лет`;
      }
      
      ctx.font = '16px Inter, sans-serif';
      ctx.fillStyle = '#88aaff';
      ctx.fillText(distText, canvas.width / 2, 56);
      
      return canvas;
    }

    function createConnectionLine(starGroup) {
      const sunPos = new THREE.Vector3(0, 0, 0);
      const starPos = new THREE.Vector3(
        starGroup.userData.tx,
        starGroup.userData.ty || 0,
        starGroup.userData.tz || 0
      );
      
      const points = [sunPos, starPos];
      const geometry = new THREE.BufferGeometry().setFromPoints(points);
      
      const material = new THREE.LineDashedMaterial({
        color: new THREE.Color(starGroup.userData.color),
        dashSize: 3,
        gapSize: 2,
        opacity: 0.25,
        transparent: true
      });
      
      const line = new THREE.Line(geometry, material);
      line.computeLineDistances();
      line.userData.starName = starGroup.userData.name;
      
      return line;
    }

    function updateConnections() {
      while (connectionsGroup.children.length > 0) {
        connectionsGroup.remove(connectionsGroup.children[0]);
      }
      
      if (!spaceViewMode) return;
      
      activeStars.forEach(star => {
        if (star.userData.name !== 'Солнце') {
          const line = createConnectionLine(star);
          connectionsGroup.add(line);
        }
      });
    }

    let camTarget = new THREE.Vector3(0, 20, 100);
    let viewTarget = new THREE.Vector3(0, 0, 0);
    let interacting = false;

    function calculateOptimalCamera() {
      if (!activeStars.length) return;
      
      let totalWidth = 0;
      let maxRadius = 0;
      let minX = Infinity, maxX = -Infinity;
      
      activeStars.forEach(star => {
        const r = star.userData.visualRadius;
        const x = star.userData.tx || 0;
        maxRadius = Math.max(maxRadius, r);
        minX = Math.min(minX, x - r);
        maxX = Math.max(maxX, x + r);
      });
      
      totalWidth = maxX - minX;
      const centerX = (minX + maxX) / 2;
      
      const fovRad = camera.fov * Math.PI / 180;
      const aspect = camera.aspect;
      
      let distanceForWidth = (totalWidth / 2) / Math.tan(fovRad / 2) / aspect;
      let distanceForHeight = maxRadius * 2.5 / Math.tan(fovRad / 2);
      
      let optimalDistance = Math.max(distanceForWidth, distanceForHeight) * 1.3;
      optimalDistance = Math.max(optimalDistance, maxRadius * 3);
      optimalDistance = Math.min(optimalDistance, 30000);
      
      return {
        position: new THREE.Vector3(centerX, maxRadius * 0.3, optimalDistance),
        target: new THREE.Vector3(centerX, 0, 0),
        minDist: maxRadius * 0.5,
        maxDist: Math.max(optimalDistance * 3, 1000)
      };
    }

    function updateLayout() {
      if (!activeStars.length) return;
      
      if (spaceViewMode) {
        activeStars.forEach(star => {
          const g = star.userData.galactic;
          if (g && g.dist > 0) {
            const pos = galacticToCartesian(g.l, g.b, g.dist);
            star.userData.tx = pos.x;
            star.userData.ty = pos.y;
            star.userData.tz = pos.z;
          } else {
            star.userData.tx = 0;
            star.userData.ty = 0;
            star.userData.tz = 0;
          }
        });
        
        let maxDist = 0;
        activeStars.forEach(star => {
          const dist = Math.sqrt(
            star.userData.tx ** 2 + 
            star.userData.ty ** 2 + 
            star.userData.tz ** 2
          );
          maxDist = Math.max(maxDist, dist);
        });
        
        viewTarget.set(0, 0, 0);
        const camDist = Math.min(Math.max(maxDist * 1.2, 80), 600);
        camTarget.set(camDist * 0.2, camDist * 0.3, camDist);
        
        controls.minDistance = 5;
        controls.maxDistance = 2000;
        
        updateConnections();
      } else {
        let sortFn;
        switch (compareMode) {
          case 'luminosity':
            sortFn = (a, b) => b.userData.luminosity - a.userData.luminosity;
            break;
          case 'mass':
            sortFn = (a, b) => b.userData.mass - a.userData.mass;
            break;
          case 'temp':
            sortFn = (a, b) => b.userData.temperature - a.userData.temperature;
            break;
          default:
            sortFn = (a, b) => b.userData.radius - a.userData.radius;
        }
        
        activeStars.sort(sortFn);
        
        let x = 0;
        
        activeStars.forEach((star, i) => {
          if (i > 0) {
            const prevStar = activeStars[i - 1];
            const gap = Math.max(
              (prevStar.userData.visualRadius + star.userData.visualRadius) * 0.3,
              5
            );
            x += prevStar.userData.visualRadius + star.userData.visualRadius + gap;
          }
          star.userData.tx = x;
          star.userData.ty = 0;
          star.userData.tz = 0;
        });
        
        const totalWidth = x;
        activeStars.forEach(star => {
          star.userData.tx -= totalWidth / 2;
        });
        
        const camData = calculateOptimalCamera();
        if (camData) {
          camTarget.copy(camData.position);
          viewTarget.copy(camData.target);
          controls.minDistance = camData.minDist;
          controls.maxDistance = camData.maxDist;
        }
        
        while (connectionsGroup.children.length > 0) {
          connectionsGroup.remove(connectionsGroup.children[0]);
        }
      }
      
      interacting = false;
      updateSizeIndicator();
    }

    function updateStarSizes() {
      activeStars.forEach(star => {
        const d = star.userData;
        const visualRadius = calculateVisualRadius(d, realScaleMode);
        
        d.visualRadius = visualRadius;
        
        d.starMesh.geometry.dispose();
        d.starMesh.geometry = new THREE.SphereGeometry(visualRadius, 128, 128);
        d.starMesh.material.uniforms.starRadius.value = visualRadius;
        
        d.innerCorona.geometry.dispose();
        d.innerCorona.geometry = new THREE.SphereGeometry(visualRadius * 1.08, 64, 64);
        d.innerCorona.material.uniforms.starRadius.value = visualRadius;
        
        d.atmosphericGlow.geometry.dispose();
        d.atmosphericGlow.geometry = new THREE.SphereGeometry(visualRadius * 1.15, 32, 32);
        
        d.glowSprite.scale.set(visualRadius * 2.2, visualRadius * 2.2, 1);
        d.light.distance = visualRadius * 15;
        
        if (spaceViewMode) {
          d.labelSprite.scale.set(16, 8, 1);
          d.labelSprite.position.y = visualRadius + 4;
        } else {
          d.labelSprite.scale.set(visualRadius * 5, visualRadius * 2.5, 1);
          d.labelSprite.position.y = visualRadius * 1.8;
        }
        d.labelSprite.visible = spaceViewMode;
      });
      
      updateLayout();
    }

    function updateSizeIndicator() {
      const indicator = document.getElementById('sizeIndicator');
      const text = document.getElementById('sizeText');
      
      if (spaceViewMode) {
        indicator.classList.add('visible');
        const distances = activeStars
          .filter(s => s.userData.distance > 0)
          .map(s => s.userData.distance);
        
        if (distances.length > 0) {
          const minDist = Math.min(...distances);
          const maxDist = Math.max(...distances);
          text.textContent = `Расстояния: ${minDist.toFixed(1)} — ${maxDist.toFixed(0)} св. лет`;
        } else {
          text.textContent = 'Галактические координаты';
        }
        return;
      }
      
      if (activeStars.length > 0) {
        indicator.classList.add('visible');
        const largest = activeStars.reduce((a, b) => 
          a.userData.radius > b.userData.radius ? a : b
        );
        const smallest = activeStars.reduce((a, b) => 
          a.userData.radius < b.userData.radius ? a : b
        );
        
        const modeLabels = {
          size: `${largest.userData.name}: ${largest.userData.radius}☉ | ${smallest.userData.name}: ${smallest.userData.radius}☉`,
          luminosity: `Макс: ${largest.userData.luminosity.toLocaleString()} L☉`,
          mass: `Макс: ${largest.userData.mass.toFixed(1)} M☉`,
          temp: `Макс: ${largest.userData.temperature.toLocaleString()} K`
        };
        text.textContent = modeLabels[compareMode];
      } else {
        indicator.classList.remove('visible');
      }
    }

    window.addStar = (key) => {
      if (addedKeys.has(key)) return;
      
      const star = createStar(key);
      star.scale.set(0, 0, 0);
      starsGroup.add(star);
      activeStars.push(star);
      addedKeys.add(key);
      
      updateLayout();
      updateUI();
      
      let t = 0;
      function animateStar() {
        t += 0.05;
        const scale = Math.min(t, 1);
        star.scale.setScalar(scale);
        if (t < 1) requestAnimationFrame(animateStar);
      }
      animateStar();
    };

    window.removeStar = (key) => {
      const star = activeStars.find(s => s.userData.name === key);
      if (!star) return;
      
      let t = 1;
      function animate() {
        t -= 0.08;
        star.scale.setScalar(Math.max(t, 0));
        if (t > 0) {
          requestAnimationFrame(animate);
        } else {
          starsGroup.remove(star);
          activeStars = activeStars.filter(s => s !== star);
          addedKeys.delete(key);
          updateLayout();
          updateUI();
        }
      }
      animate();
    };

    window.clearAll = () => {
      [...activeStars].forEach(star => window.removeStar(star.userData.name));
    };

    window.toggleRealScale = () => {
      realScaleMode = !realScaleMode;
      const btn = document.getElementById('btnRealScale');
      btn.classList.toggle('active', realScaleMode);
      updateStarSizes();
    };

    window.toggleSpaceView = () => {
      spaceViewMode = !spaceViewMode;
      const btn = document.getElementById('btnSpaceView');
      btn.classList.toggle('active', spaceViewMode);
      
      document.getElementById('comparePanel').classList.toggle('hidden', spaceViewMode);
      document.getElementById('spaceInfo').classList.toggle('visible', spaceViewMode);
      
      const scaleBtn = document.getElementById('btnRealScale');
      scaleBtn.style.opacity = spaceViewMode ? '0.5' : '1';
      scaleBtn.style.pointerEvents = spaceViewMode ? 'none' : 'auto';
      
      updateStarSizes();
      updateLayout();
    };

    window.setCompareMode = (mode) => {
      compareMode = mode;
      document.querySelectorAll('.compare-btn').forEach(btn => {
        btn.classList.toggle('active', btn.dataset.mode === mode);
      });
      updateStarSizes();
      updateLayout();
    };
    
    let isDark = true;
    window.toggleTheme = () => {
      isDark = !isDark;
      document.body.dataset.theme = isDark ? 'dark' : 'light';
      
      const tBtn = document.querySelector('.theme-btn');
      tBtn.querySelector('.icon-moon').style.display = isDark ? 'block' : 'none';
      tBtn.querySelector('.icon-sun').style.display = isDark ? 'none' : 'block';
      
      if (isDark) {
        if (showGalaxyBackground) {
          skyboxMilkyWay.visible = true;
          stars.visible = true;
          scene.background = null;
        } else {
          scene.background = new THREE.Color(0x000000);
        }
        bloomPass.strength = 0.8;
        ambLight.intensity = 0.6;
      } else {
        scene.background = new THREE.Color(0xf0f4f8);
        skyboxMilkyWay.visible = false;
        stars.visible = false;
        bloomPass.strength = 0.3;
        ambLight.intensity = 1.2;
      }
    };

    window.clearCache = () => {
      if (confirm('Очистить все данные приложения?')) {
        localStorage.clear();
        location.reload();
      }
    };

    const box = document.getElementById('starBtns');
    
    const keys = Object.keys(STARS).sort((a, b) => {
      if (a === 'Солнце') return -1;
      if (b === 'Солнце') return 1;
      return a.localeCompare(b, 'ru');
    });

    keys.forEach(key => {
      const d = STARS[key];
      const btn = document.createElement('div');
      btn.className = 'chip';
      btn.dataset.s = key;
      btn.innerHTML = `<span class="color-dot" style="background: ${d.color}; box-shadow: 0 0 4px ${d.color};"></span>${key}`;
      btn.onclick = () => addedKeys.has(key) ? window.removeStar(key) : window.addStar(key);
      box.appendChild(btn);
    });

    function updateUI() {
      document.querySelectorAll('.chip').forEach(c => {
        c.classList.toggle('active', addedKeys.has(c.dataset.s));
      });
    }

    window.addStar('Солнце');

    const ray = new THREE.Raycaster();
    const mouse = new THREE.Vector2();

    window.addEventListener('dblclick', e => {
      mouse.x = (e.clientX / innerWidth) * 2 - 1;
      mouse.y = -(e.clientY / innerHeight) * 2 + 1;
      ray.setFromCamera(mouse, camera);
      
      const hits = ray.intersectObjects(starsGroup.children, true);
      
      if (hits.length) {
        const hitStars = [];
        const seenUuids = new Set();

        hits.forEach(hit => {
          let obj = hit.object;
          
          while (obj.parent && obj.parent !== starsGroup) obj = obj.parent;
          
          if (obj.userData && obj.userData.name && !seenUuids.has(obj.uuid)) {
            hitStars.push(obj);
            seenUuids.add(obj.uuid);
          }
        });

        if (hitStars.length > 0) {
          hitStars.sort((a, b) => a.userData.visualRadius - b.userData.visualRadius);
          
          const targetStar = hitStars[0];
          const d = targetStar.userData;
          const i = d.info || {};
          
          document.getElementById('mTitle').textContent = d.name;
          document.getElementById('mType').textContent = d.type;
          document.getElementById('mConstellation').textContent = d.constellation !== '—' ? `Созвездие: ${d.constellation}` : '';
          
          const preview = document.getElementById('mPreview');
          preview.style.background = `radial-gradient(circle, ${d.color} 0%, ${d.coronaColor} 50%, transparent 100%)`;
          preview.style.setProperty('--star-color', d.coronaColor);
          
          document.getElementById('mStats').innerHTML = `
            <div class="stat"><h4>Диаметр</h4><p>${i.diameter || '-'}</p><span class="sub">${i.diamSun || '-'} ☉</span></div>
            <div class="stat"><h4>Масса</h4><p>${i.mass || '-'}</p><span class="sub">${i.massSun || '-'} M☉</span></div>
            <div class="stat"><h4>Светимость</h4><p>${i.luminosity || '-'}</p><span class="sub">${i.lumSun || '-'} L☉</span></div>
            <div class="stat"><h4>Температура</h4><p>${i.temperature || '-'}</p><span class="sub">${i.tempClass || '-'}</span></div>
            <div class="stat"><h4>Плотность</h4><p>${i.density || '-'}</p></div>
            <div class="stat"><h4>Гравитация</h4><p>${i.gravity || '-'}</p></div>
            <div class="stat"><h4>Вращение</h4><p>${i.rotation || '-'}</p></div>
            <div class="stat"><h4>Возраст</h4><p>${i.age || '-'}</p></div>
            <div class="stat"><h4>Расстояние</h4><p>${i.dist || '-'}</p></div>
            <div class="stat"><h4>Состав</h4><p>${i.composition || '-'}</p></div>
            <div class="stat"><h4>Спектр</h4><p>${d.spectralClass || '-'}</p></div>
            <div class="stat"><h4>Вид. величина</h4><p>${d.apparentMagnitude !== undefined ? d.apparentMagnitude : '—'}</p><span class="sub">mag</span></div>
          `;
          
          const randomFact = d.facts && d.facts.length ? d.facts[Math.floor(Math.random() * d.facts.length)] : 'Нет данных';
          document.getElementById('mFact').textContent = randomFact;
          
          document.getElementById('modal').classList.add('visible');
        }
      }
    });

    window.closeModal = () => {
      document.getElementById('modal').classList.remove('visible');
    };

    controls.addEventListener('start', () => interacting = true);

    function animate(time) {
      requestAnimationFrame(animate);
      const t = time * 0.001;
      
      if (!interacting) {
        camera.position.lerp(camTarget, 0.03);
        controls.target.lerp(viewTarget, 0.03);
      }
      
      skyboxMilkyWay.rotation.y = t * 0.003;
      stars.rotation.y = t * 0.002;
      
      activeStars.forEach(star => {
        star.position.x += (star.userData.tx - star.position.x) * 0.1;
        star.position.y += ((star.userData.ty || 0) - star.position.y) * 0.1;
        star.position.z += ((star.userData.tz || 0) - star.position.z) * 0.1;
        
        const viewVec = camera.position.clone().sub(star.position).normalize();
        
        if (star.userData.starMesh.material.uniforms) {
          star.userData.starMesh.material.uniforms.time.value = t;
        }
        if (star.userData.innerCorona.material.uniforms) {
          star.userData.innerCorona.material.uniforms.time.value = t;
          star.userData.innerCorona.material.uniforms.viewVector.value = viewVec;
        }
        if (star.userData.atmosphericGlow.material.uniforms) {
          star.userData.atmosphericGlow.material.uniforms.time.value = t;
          star.userData.atmosphericGlow.material.uniforms.viewVector.value = viewVec;
        }
        
        const pulseScale = 1 + Math.sin(t * 0.2 + star.userData.radius * 0.05) * 0.02;
        const baseGlowScale = star.userData.visualRadius * 2.2;
        star.userData.glowSprite.scale.set(baseGlowScale * pulseScale, baseGlowScale * pulseScale, 1);
      });

      if (spaceViewMode) {
        connectionsGroup.children.forEach(line => {
          const star = activeStars.find(s => s.userData.name === line.userData.starName);
          if (star) {
            const positions = line.geometry.attributes.position.array;
            positions[3] = star.position.x;
            positions[4] = star.position.y;
            positions[5] = star.position.z;
            line.geometry.attributes.position.needsUpdate = true;
            line.computeLineDistances();
          }
        });
      }
      
      controls.update();
      composer.render();
    }

    window.addEventListener('resize', () => {
      camera.aspect = innerWidth / innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(innerWidth, innerHeight);
      composer.setSize(innerWidth, innerHeight);
    });

    const titleH1 = document.querySelector('.app-title h1');
    const titleSpan = document.querySelector('.app-title span');

    const defaultTitle = titleH1.textContent;
    const defaultSub = titleSpan.textContent;

    let hoveredObj = null;

    window.addEventListener('mousemove', (e) => {
      mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
      mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;

      ray.setFromCamera(mouse, camera);
      
      const hits = ray.intersectObjects(starsGroup.children, true);

      if (hits.length > 0) {
        const hitStars = [];
        const seenUuids = new Set();

        hits.forEach(hit => {
          let obj = hit.object;
          while (obj.parent && obj.parent !== starsGroup) obj = obj.parent;
          if (obj.userData && obj.userData.name && !seenUuids.has(obj.uuid)) {
            hitStars.push(obj);
            seenUuids.add(obj.uuid);
          }
        });

        if (hitStars.length > 0) {
          hitStars.sort((a, b) => a.userData.visualRadius - b.userData.visualRadius);
          
          const targetObj = hitStars[0];

          if (hoveredObj !== targetObj) {
            hoveredObj = targetObj;
            const d = targetObj.userData;

            titleH1.textContent = d.name;
            titleH1.style.color = d.color;
            titleH1.style.textShadow = `0 0 20px ${d.color}`;
            
            titleH1.style.background = 'none';
            titleH1.style.webkitTextFillColor = 'initial';

            const specInfo = d.spectralClass ? ` (${d.spectralClass})` : '';
            titleSpan.textContent = `${d.type}${specInfo}`;
            titleSpan.style.color = '#ffffff';

            document.body.style.cursor = 'pointer';
          }
          return;
        }
      }
      
      if (hoveredObj) {
        hoveredObj = null;

        titleH1.textContent = defaultTitle;
        titleSpan.textContent = defaultSub;

        titleH1.style.background = 'linear-gradient(135deg, #ffffff 0%, #88aaff 50%, #ffaa66 100%)';
        titleH1.style.webkitBackgroundClip = 'text';
        titleH1.style.webkitTextFillColor = 'transparent';
        titleH1.style.textShadow = 'none';
        titleH1.style.color = 'transparent';

        titleSpan.style.color = 'var(--accent)';

        document.body.style.cursor = 'default';
      }
    });
    
    animate(0);
  </script>
</body>
</html>
