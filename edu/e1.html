<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Warp Drive</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Segoe UI', sans-serif; }
        canvas { display: block; }
        
        /* Интерфейс (копия вашего стиля) */
        .controls {
            position: fixed; bottom: 30px; left: 50%; transform: translateX(-50%);
            background: rgba(10, 10, 30, 0.85); padding: 20px 30px; border-radius: 15px;
            border: 1px solid rgba(100, 150, 255, 0.3); backdrop-filter: blur(10px);
            z-index: 100; display: flex; gap: 30px; user-select: none;
        }
        .control-group { display: flex; flex-direction: column; gap: 10px; }
        .control-group h3 { color: #8af; font-size: 11px; text-transform: uppercase; letter-spacing: 2px; text-align: center; margin: 0; }
        .slider-row { display: flex; align-items: center; gap: 10px; }
        .slider-label { color: #aaa; font-size: 12px; min-width: 70px; }
        .slider { -webkit-appearance: none; width: 120px; height: 6px; border-radius: 3px; background: linear-gradient(90deg, #1a1a3a, #3a3a6a); outline: none; cursor: pointer; }
        .slider::-webkit-slider-thumb { -webkit-appearance: none; width: 18px; height: 18px; border-radius: 50%; background: #6af; cursor: pointer; transition: transform 0.2s; }
        .slider::-webkit-slider-thumb:hover { transform: scale(1.2); }
        .speed-display { text-align: center; margin-top: 5px; }
        .speed-value { color: #fff; font-weight: bold; font-size: 20px; }
        .speed-label { color: #888; font-size: 11px; display: block; }

        .info {
            position: fixed; top: 20px; left: 20px; color: rgba(255, 255, 255, 0.7);
            font-size: 12px; background: rgba(10, 10, 30, 0.7); padding: 15px;
            border-radius: 10px; border: 1px solid rgba(100, 150, 255, 0.2); pointer-events: none;
        }
        .info span { color: #6af; font-weight: bold; }
        
        .hints {
            position: fixed; top: 20px; right: 20px; color: rgba(255, 255, 255, 0.5);
            font-size: 11px; background: rgba(10, 10, 30, 0.7); padding: 15px;
            border-radius: 10px; border: 1px solid rgba(100, 150, 255, 0.2); line-height: 1.8; pointer-events: none;
        }
        .hints strong { color: #8af; }

        #loading {
            position: fixed; inset: 0; background: #000; display: flex; 
            align-items: center; justify-content: center; color: #6af; z-index: 999;
            transition: opacity 0.5s;
        }
    </style>
</head>
<body>

    <div id="loading">Загрузка бортовых систем...</div>

    <div class="info">
        <div>Звёзд: <span id="starCount">0</span></div>
        <div>Объектов: <span id="objCount">0</span></div>
        <div style="margin-top: 10px; border-top: 1px solid rgba(255,255,255,0.2); padding-top: 5px;">
            Угол обзора: <span id="camAngle">0°, 0°</span>
        </div>
    </div>

    <div class="hints">
        <strong>Колесо мыши</strong> — тяга<br>
        <strong>Мышь</strong> — обзор и поворот<br>
        <strong>ЛКМ</strong> — форсаж (2x)<br>
    </div>

    <div class="controls">
        <div class="control-group">
            <h3>Тяга</h3>
            <div class="slider-row">
                <input type="range" class="slider" id="speedSlider" min="0" max="100" value="20">
            </div>
            <div class="speed-display">
                <span class="speed-value" id="speedValue">0.2c</span>
                <span class="speed-label" id="speedLabel">Субсветовая</span>
            </div>
        </div>
        <div class="control-group">
            <h3>Плотность</h3>
            <div class="slider-row">
                <span class="slider-label">Звёзды</span>
                <input type="range" class="slider" id="starSlider" min="500" max="10000" value="3000">
            </div>
            <div class="slider-row">
                <span class="slider-label">Туманности</span>
                <input type="range" class="slider" id="nebulaSlider" min="0" max="50" value="10">
            </div>
        </div>
    </div>

    <!-- Подключаем Three.js через CDN -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';

        // --- Инициализация сцены ---
        const scene = new THREE.Scene();
        // Туман для плавного появления звезд из темноты
        scene.fog = new THREE.FogExp2(0x000000, 0.0003);

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 20000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        document.body.appendChild(renderer.domElement);

        // --- 1. СФЕРИЧЕСКИЙ ФОН (SKYBOX) ---
        const textureLoader = new THREE.TextureLoader();
        
        // Создаем огромную сферу
        const skyGeo = new THREE.SphereGeometry(10000, 64, 64);
        const skyMat = new THREE.MeshBasicMaterial({
            map: textureLoader.load('textures/milkyway.jpg', () => {
                document.getElementById('loading').style.opacity = 0;
                setTimeout(() => document.getElementById('loading').remove(), 500);
            }),
            side: THREE.BackSide, // Текстура внутри сферы
            depthWrite: false     // Звезды рисуются поверх фона
        });
        const skybox = new THREE.Mesh(skyGeo, skyMat);
        scene.add(skybox);

        // --- 2. ЗВЕЗДЫ (Warp Lines) ---
        // Используем LineSegments для эффекта длинных полос при скорости
        const starCountMax = 10000;
        let activeStarCount = 3000;
        
        const starGeo = new THREE.BufferGeometry();
        const positions = new Float32Array(starCountMax * 6); // 2 точки на звезду * 3 коорд
        const colors = new Float32Array(starCountMax * 6);
        const speeds = new Float32Array(starCountMax); // Индивидуальная скорость звезды
        const offsets = new Float32Array(starCountMax * 3); // Базовая позиция

        const colorPalette = [
            new THREE.Color(0xffffff), // Белый
            new THREE.Color(0xaaccff), // Голубой
            new THREE.Color(0xffddaa)  // Оранжевый
        ];

        for(let i = 0; i < starCountMax; i++) {
            // Случайная позиция в туннеле
            const r = Math.random() * 2000 + 100; // Радиус от центра
            const theta = Math.random() * Math.PI * 2;
            const x = r * Math.cos(theta);
            const y = r * Math.sin(theta);
            const z = (Math.random() - 0.5) * 4000; // Глубина

            offsets[i * 3] = x;
            offsets[i * 3 + 1] = y;
            offsets[i * 3 + 2] = z;

            speeds[i] = Math.random() * 0.5 + 0.5;

            // Цвет
            const color = colorPalette[Math.floor(Math.random() * colorPalette.length)];
            
            // Вершина 1 (голова)
            colors[i*6] = color.r; colors[i*6+1] = color.g; colors[i*6+2] = color.b;
            // Вершина 2 (хвост)
            colors[i*6+3] = color.r; colors[i*6+4] = color.g; colors[i*6+5] = color.b;
        }

        starGeo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        starGeo.setAttribute('color', new THREE.BufferAttribute(colors, 3));
        
        // Материал линий (прозрачный, аддитивный для свечения)
        const starMat = new THREE.LineBasicMaterial({
            vertexColors: true,
            blending: THREE.AdditiveBlending,
            transparent: true,
            opacity: 0.8
        });

        const starField = new THREE.LineSegments(starGeo, starMat);
        starField.frustumCulled = false; // Всегда рисовать, даже если "за спиной"
        scene.add(starField);


        // --- 3. ГАЛАКТИКИ И ТУМАННОСТИ (Спрайты) ---
        // Генерируем текстуры программно, чтобы не качать картинки
        function createCloudTexture(hue) {
            const canvas = document.createElement('canvas');
            canvas.width = 128; canvas.height = 128;
            const ctx = canvas.getContext('2d');
            const grad = ctx.createRadialGradient(64,64,0, 64,64,64);
            grad.addColorStop(0, `hsla(${hue}, 100%, 70%, 1)`);
            grad.addColorStop(0.4, `hsla(${hue}, 80%, 40%, 0.5)`);
            grad.addColorStop(1, 'rgba(0,0,0,0)');
            ctx.fillStyle = grad;
            ctx.fillRect(0,0,128,128);
            return new THREE.CanvasTexture(canvas);
        }

        function createGalaxyTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 256; canvas.height = 256;
            const ctx = canvas.getContext('2d');
            ctx.translate(128,128);
            
            // Спираль
            ctx.fillStyle = '#fff';
            for(let i=0; i<300; i++) {
                const angle = i * 0.1;
                const r = i * 0.4;
                const x = Math.cos(angle) * r;
                const y = Math.sin(angle) * r * 0.5; // Сплюснутая
                ctx.globalAlpha = Math.max(0, 1 - i/300);
                ctx.beginPath();
                ctx.arc(x, y, Math.random()*2, 0, Math.PI*2);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(-x, -y, Math.random()*2, 0, Math.PI*2); // Второй рукав
                ctx.fill();
            }
            // Ядро
            const grad = ctx.createRadialGradient(0,0,0, 0,0,40);
            grad.addColorStop(0, 'rgba(255,240,200,1)');
            grad.addColorStop(1, 'rgba(255,240,200,0)');
            ctx.globalAlpha = 0.6;
            ctx.fillStyle = grad;
            ctx.beginPath(); ctx.arc(0,0,40,0,Math.PI*2); ctx.fill();

            return new THREE.CanvasTexture(canvas);
        }

        const nebulaGroup = new THREE.Group();
        scene.add(nebulaGroup);
        
        const nebulaTex1 = createCloudTexture(200); // Синяя
        const nebulaTex2 = createCloudTexture(320); // Розовая
        const galaxyTex = createGalaxyTexture();

        const clouds = [];
        const cloudCountMax = 50;
        let activeCloudCount = 10;

        // Создаем пул спрайтов
        for(let i=0; i<cloudCountMax; i++) {
            let material;
            let scale;
            if (i % 5 === 0) { // Галактика
                material = new THREE.SpriteMaterial({ 
                    map: galaxyTex, 
                    blending: THREE.AdditiveBlending, 
                    opacity: 0.8,
                    rotation: Math.random() * Math.PI 
                });
                scale = 400 + Math.random() * 400;
            } else { // Туманность
                material = new THREE.SpriteMaterial({ 
                    map: Math.random() > 0.5 ? nebulaTex1 : nebulaTex2, 
                    blending: THREE.AdditiveBlending, 
                    opacity: 0.4,
                    rotation: Math.random() * Math.PI 
                });
                scale = 600 + Math.random() * 800;
            }
            
            const sprite = new THREE.Sprite(material);
            // Прячем пока
            sprite.visible = false;
            sprite.scale.set(scale, scale, 1);
            
            // Данные для анимации
            sprite.userData = {
                x: (Math.random() - 0.5) * 5000,
                y: (Math.random() - 0.5) * 5000,
                z: (Math.random() - 0.5) * 10000 - 5000,
                speed: Math.random() * 0.5 + 0.5
            };
            
            clouds.push(sprite);
            nebulaGroup.add(sprite);
        }

        // --- ЛОГИКА И УПРАВЛЕНИЕ ---
        
        let speed = 0.2; // 0 to 1 (Warp factor)
        let warpSpeed = 0; // Реальная скорость Z
        let targetSpeed = 0.2;
        
        // Камера
        let camLat = 0, camLon = 0;
        let targetLat = 0, targetLon = 0;
        
        // Слайдеры
        const speedSlider = document.getElementById('speedSlider');
        const starSlider = document.getElementById('starSlider');
        const nebulaSlider = document.getElementById('nebulaSlider');
        
        speedSlider.addEventListener('input', e => targetSpeed = e.target.value / 100);
        
        starSlider.addEventListener('input', e => {
            activeStarCount = parseInt(e.target.value);
            starField.geometry.setDrawRange(0, activeStarCount * 2);
            document.getElementById('starCount').innerText = activeStarCount;
        });

        nebulaSlider.addEventListener('input', e => {
            activeCloudCount = parseInt(e.target.value);
            document.getElementById('objCount').innerText = activeCloudCount;
        });

        // Мышь
        let isMouseDown = false;
        document.addEventListener('mousedown', () => isMouseDown = true);
        document.addEventListener('mouseup', () => isMouseDown = false);
        
        document.addEventListener('mousemove', e => {
            const x = (e.clientX - window.innerWidth / 2) / (window.innerWidth / 2);
            const y = (e.clientY - window.innerHeight / 2) / (window.innerHeight / 2);
            
            // Мышь управляет целевым углом поворота камеры
            targetLon = -x * 60; // +/- 60 градусов влево/вправо
            targetLat = -y * 45; // +/- 45 градусов вверх/вниз
        });

        document.addEventListener('wheel', e => {
            targetSpeed -= e.deltaY * 0.001;
            targetSpeed = Math.max(0, Math.min(1, targetSpeed));
            speedSlider.value = targetSpeed * 100;
        });

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // --- ANIMATION LOOP ---
        const clock = new THREE.Clock();
        const baseZSpeed = 5000; // Базовая скорость полета

        function animate() {
            const dt = clock.getDelta();

            // Плавное изменение скорости
            let factor = isMouseDown ? 2 : 1;
            speed += (targetSpeed * factor - speed) * 0.05;
            
            // Обновление UI
            let displaySpd = speed < 0.3 ? (speed).toFixed(2) + 'c' : 'ВАРП ' + (speed*10).toFixed(1);
            document.getElementById('speedValue').innerText = displaySpd;
            document.getElementById('speedLabel').innerText = speed > 0.9 ? "Гиперпространство" : (speed > 0.3 ? "Релятивистская" : "Субсветовая");

            // --- Камера и Фон ---
            // Плавный поворот камеры
            camLon += (targetLon - camLon) * 0.05;
            camLat += (targetLat - camLat) * 0.05;
            
            // Переводим углы в радианы для вращения
            const phi = THREE.MathUtils.degToRad(90 - camLat);
            const theta = THREE.MathUtils.degToRad(camLon);
            
            const targetPos = new THREE.Vector3();
            targetPos.setFromSphericalCoords(1, phi, theta);
            camera.lookAt(targetPos);
            
            document.getElementById('camAngle').innerText = `${camLon.toFixed(1)}°, ${camLat.toFixed(1)}°`;

            // --- Анимация Звезд ---
            warpSpeed = speed * baseZSpeed * dt;
            
            // Удлинение звезд (trail) зависит от скорости
            const trailLen = speed * 800; 

            const posAttr = starField.geometry.attributes.position;
            
            for(let i = 0; i < activeStarCount; i++) {
                let z = offsets[i * 3 + 2];
                const s = speeds[i]; // Индивидуальный модификатор скорости

                // Двигаем звезду к камере (+Z)
                z += warpSpeed * s;

                // Если звезда улетела за камеру (или слишком далеко вперед), сбрасываем назад
                if (z > 1000) {
                    z = -3000; // Сброс вдаль
                    // Новая случайная XY позиция при сбросе
                    const r = Math.random() * 2000 + 100;
                    const th = Math.random() * Math.PI * 2;
                    offsets[i*3] = r * Math.cos(th);
                    offsets[i*3+1] = r * Math.sin(th);
                }
                
                offsets[i * 3 + 2] = z;

                const x = offsets[i * 3];
                const y = offsets[i * 3 + 1];

                // Вершина 1 (Голова)
                posAttr.setXYZ(i * 2, x, y, z);
                
                // Вершина 2 (Хвост) - растягиваем по Z назад
                posAttr.setXYZ(i * 2 + 1, x, y, z - trailLen);
            }
            posAttr.needsUpdate = true;
            starField.geometry.setDrawRange(0, activeStarCount * 2);

            // --- Анимация Объектов (Спрайты) ---
            for(let i = 0; i < cloudCountMax; i++) {
                const sprite = clouds[i];
                if (i >= activeCloudCount) {
                    sprite.visible = false;
                    continue;
                }
                sprite.visible = true;

                let d = sprite.userData;
                d.z += warpSpeed * d.speed * 0.5; // Спрайты движутся медленнее (параллакс)

                if (d.z > 2000) {
                    d.z = -8000;
                    d.x = (Math.random() - 0.5) * 6000;
                    d.y = (Math.random() - 0.5) * 6000;
                }

                sprite.position.set(d.x, d.y, d.z);
            }

            renderer.render(scene, camera);
            requestAnimationFrame(animate);
        }

        // Стартуем с количеством по умолчанию
        starField.geometry.setDrawRange(0, activeStarCount * 2);
        document.getElementById('starCount').innerText = activeStarCount;
        document.getElementById('objCount').innerText = activeCloudCount;

        animate();
    </script>
</body>
</html>