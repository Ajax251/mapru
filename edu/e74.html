<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no, maximum-scale=1.0" />
  <title>AstroSim: Solar System</title>
  
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&family=Jura:wght@400;500;600;700&display=swap" rel="stylesheet">

  <style>
    :root {
      --bg-color: #000000;
      --panel-bg: rgba(10, 10, 16, 0.6);
      --panel-border: rgba(255, 255, 255, 0.15);
      --text-main: #eeeeee;
      --text-sec: #94a3b8;
      --accent: #0ea5e9; 
      --btn-bg: rgba(255, 255, 255, 0.08);
      --btn-hover: rgba(255, 255, 255, 0.2);
      --font-display: 'Jura', sans-serif;
      --font-body: 'Inter', sans-serif;
    }

    * { margin: 0; padding: 0; box-sizing: border-box; -webkit-tap-highlight-color: transparent; }

    html, body {
      width: 100%; height: 100%; overflow: hidden;
      background: var(--bg-color);
      font-family: var(--font-body);
      color: var(--text-main);
    }

    canvas { display: block; outline: none; }

    /* UI Layer */
    #ui-layer {
      position: absolute; inset: 0; pointer-events: none;
      display: flex; flex-direction: column; justify-content: space-between;
      padding: 20px; z-index: 10;
    }

    /* Top Bar */
    .top-bar {
      pointer-events: auto;
      display: flex; justify-content: space-between; align-items: flex-start;
    }

    .app-title h1 {
      font-family: var(--font-display); font-weight: 700; font-size: 24px;
      letter-spacing: 2px; text-transform: uppercase;
      text-shadow: 0 0 10px rgba(0,0,0,0.8);
    }
    .app-title span { font-size: 10px; color: var(--accent); letter-spacing: 4px; text-transform: uppercase; font-weight: 700; }

    /* Controls Dock */
    .dock-container {
      pointer-events: auto;
      align-self: center; width: 100%; max-width: 800px;
      display: flex; justify-content: center; padding-bottom: 20px;
    }

    .dock {
      background: var(--panel-bg);
      backdrop-filter: blur(15px); -webkit-backdrop-filter: blur(15px);
      border: 1px solid var(--panel-border);
      padding: 10px; border-radius: 20px;
      display: flex; gap: 10px; align-items: center;
      transition: all 0.3s ease;
    }

    /* Scrollable Planets */
    .planet-scroll {
      display: flex; gap: 6px; overflow-x: auto; padding: 2px 4px;
      -ms-overflow-style: none; scrollbar-width: none;
      max-width: 60vw;
    }
    .planet-scroll::-webkit-scrollbar { display: none; }

    .chip {
      padding: 8px 16px; border-radius: 10px;
      background: var(--btn-bg); color: var(--text-sec);
      font-family: var(--font-display); font-size: 12px; font-weight: 600;
      cursor: pointer; white-space: nowrap; border: 1px solid transparent;
      transition: all 0.2s; user-select: none;
    }
    .chip:hover { background: var(--btn-hover); color: white; }
    .chip.active {
      background: rgba(14, 165, 233, 0.2); color: var(--accent);
      border-color: rgba(14, 165, 233, 0.5);
    }

    .btn-icon {
      width: 40px; height: 40px; flex-shrink: 0;
      border-radius: 12px; background: var(--btn-bg);
      border: 1px solid var(--panel-border); color: white;
      display: flex; align-items: center; justify-content: center;
      cursor: pointer; transition: 0.2s;
    }
    .btn-icon:hover { background: var(--btn-hover); border-color: white; }
    .btn-icon svg { width: 20px; height: 20px; }

    .divider { width: 1px; height: 24px; background: rgba(255,255,255,0.2); }

    /* Info Modal */
    .modal {
      position: fixed; inset: 0; z-index: 100;
      background: rgba(0,0,0,0.4); backdrop-filter: blur(5px);
      opacity: 0; visibility: hidden; transition: 0.3s;
      display: flex; align-items: center; justify-content: center;
    }
    .modal.visible { opacity: 1; visibility: visible; }
    
    .card {
      width: 90%; max-width: 400px;
      background: rgba(5, 5, 10, 0.9); border: 1px solid var(--panel-border);
      border-radius: 24px; padding: 30px; position: relative;
      color: white; box-shadow: 0 0 50px rgba(0,0,0,0.8);
      transform: scale(0.9); transition: 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
    }
    .modal.visible .card { transform: scale(1); }
    
    .close-btn {
      position: absolute; top: 15px; right: 15px; width: 30px; height: 30px;
      background: rgba(255,255,255,0.1); border: none; border-radius: 50%; color: white;
      cursor: pointer; display: flex; align-items: center; justify-content: center;
    }

    /* Loading Overlay */
    #loader {
      position: fixed; inset: 0; background: black; z-index: 200;
      display: flex; align-items: center; justify-content: center;
      color: var(--accent); font-family: var(--font-display);
      transition: opacity 0.5s;
    }
    
    @media (max-width: 768px) {
      .planet-scroll { max-width: 100%; }
      .dock { flex-direction: column-reverse; width: 100%; border-radius: 20px; }
      .divider { display: none; }
      .btn-icon { width: 100%; border-radius: 10px; }
      .top-bar { margin-top: 20px; }
    }
  </style>
</head>
<body>

  <!-- Loader -->
  <div id="loader">ЗАГРУЗКА ВСЕЛЕННОЙ...</div>

  <!-- UI -->
  <div id="ui-layer">
    <div class="top-bar">
      <div class="app-title">
        <h1>AstroSim</h1>
        <span>Solar System</span>
      </div>
    </div>

    <div class="dock-container">
      <div class="dock">
        <button class="btn-icon" onclick="clearAll()" title="Сбросить / Только Солнце">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <circle cx="12" cy="12" r="5"></circle>
            <line x1="12" y1="1" x2="12" y2="3"></line>
            <line x1="12" y1="21" x2="12" y2="23"></line>
            <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
            <line x1="19.78" y1="19.78" x2="18.36" y2="18.36"></line>
            <line x1="1" y1="12" x2="3" y2="12"></line>
            <line x1="21" y1="12" x2="23" y2="12"></line>
            <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
            <line x1="19.78" y1="4.22" x2="18.36" y2="5.64"></line>
          </svg>
        </button>
        <div class="divider"></div>
        <div class="planet-scroll" id="planetBtns"></div>
      </div>
    </div>
  </div>

  <!-- Info Modal -->
  <div class="modal" id="modal">
    <div class="card">
      <button class="close-btn" onclick="closeModal()">×</button>
      <h2 id="mTitle" style="font-family:var(--font-display); font-size:32px; margin-bottom:5px">Planet</h2>
      <div id="mType" style="color:var(--accent); font-size:12px; letter-spacing:2px; text-transform:uppercase; margin-bottom:20px">Type</div>
      <div id="mStats" style="display:grid; grid-template-columns:1fr 1fr; gap:15px; margin-bottom:20px"></div>
      <p id="mFact" style="font-size:14px; line-height:1.6; color:#ccc; border-top:1px solid rgba(255,255,255,0.1); padding-top:15px"></p>
    </div>
  </div>

  <script type="importmap">
    { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js", "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/" } }
  </script>

  <script type="module">
    import * as THREE from "three";
    import { OrbitControls } from "three/addons/controls/OrbitControls.js";
    import { UnrealBloomPass } from "three/addons/postprocessing/UnrealBloomPass.js";
    import { EffectComposer } from "three/addons/postprocessing/EffectComposer.js";
    import { RenderPass } from "three/addons/postprocessing/RenderPass.js";

    // --- TEXTURE URLS (Reliable Sources) ---
    // Using high-res Wikimedia/ESO/NASA proxies via standard tutorial assets
    const BG_URL = 'https://raw.githubusercontent.com/mrdoob/three.js/master/examples/textures/cube/MilkyWay/dark-s_px.jpg'; // Using one side for simplicity or a full eq map
    const MILKY_WAY_PANORAMA = 'https://upload.wikimedia.org/wikipedia/commons/6/60/ESO_-_Milky_Way.jpg'; // High Res ESO
    const ANDROMEDA_URL = 'https://upload.wikimedia.org/wikipedia/commons/thumb/c/c2/M31_Lanoue.png/600px-M31_Lanoue.png';
    
    // --- DATA ---
    const PLANETS = {
      Солнце: { order: 0, radius: 25000, type: 'Звезда', info: { mass: '1.98 × 10³⁰ кг', temp: '5500°C', dist: '0 км' }, fact: 'Звезда, дающая жизнь. Центр системы.', isSun: true },
      Меркурий: { order: 1, radius: 2439, tex: 'textures/mercury2.jpg', bump: 'textures/mercury2.jpg', distAU: 0.39, info: { mass: '0.055 Zem', temp: '427°C', dist: '58M km' }, fact: 'Самая быстрая планета.' },
      Венера: { order: 2, radius: 6051, tex: 'textures/venus.jpg', bump: 'textures/venus.jpg', glow: 0xffaa55, distAU: 0.72, info: { mass: '0.81 Zem', temp: '462°C', dist: '108M km' }, fact: 'Самая горячая планета.' },
      Земля: { order: 3, radius: 6371, tex: 'textures/earth-blue-marble.jpg', spec: 'textures/earth2.jpg', glow: 0x4488ff, distAU: 1.0, info: { mass: '1.0 Zem', temp: '15°C', dist: '150M km' }, fact: 'Наш дом.' },
      Марс: { order: 4, radius: 3389, tex: 'textures/mars.jpg', bump: 'textures/mars2.jpg', glow: 0xff4422, distAU: 1.52, info: { mass: '0.11 Zem', temp: '-60°C', dist: '228M km' }, fact: 'Красная планета.' },
      Юпитер: { order: 5, radius: 69911, tex: 'textures/jupiter.jpg', glow: 0xeebb99, distAU: 5.2, info: { mass: '318 Zem', temp: '-108°C', dist: '778M km' }, fact: 'Король планет.' },
      Сатурн: { order: 6, radius: 58232, tex: 'textures/saturn.jpg', ring: { tex: 'textures/saturn2.png', inner: 1.3, outer: 2.3 }, glow: 0xeeddcc, distAU: 9.58, info: { mass: '95 Zem', temp: '-139°C', dist: '1.4B km' }, fact: 'Властелин колец.' },
      Уран: { order: 7, radius: 25362, tex: 'textures/uranus.jpg', glow: 0x88ffff, distAU: 19.22, info: { mass: '14.5 Zem', temp: '-197°C', dist: '2.9B km' }, fact: 'Ледяной гигант.' },
      Нептун: { order: 8, radius: 24622, tex: 'textures/neptune.jpg', glow: 0x3355ff, distAU: 30.05, info: { mass: '17.1 Zem', temp: '-201°C', dist: '4.5B km' }, fact: 'Планета бурь.' },
      Плутон: { order: 9, radius: 1188, tex: 'textures/pluto.jpg', bump: 'textures/pluto.jpg', distAU: 39.48, info: { mass: '0.002 Zem', temp: '-223°C', dist: '5.9B km' }, fact: 'Сердце изо льда.' }
    };

    const BASE_SCALE = 1 / 4000;
    const AU_SCALE = 150; // Distance multiplier

    // --- SCENE SETUP ---
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 200000); // Far clipped enough for galaxy
    
    const renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.3;
    document.body.appendChild(renderer.domElement);

    // --- LOADING MANAGER ---
    const manager = new THREE.LoadingManager();
    manager.onLoad = () => {
        const l = document.getElementById('loader');
        l.style.opacity = '0';
        setTimeout(() => l.style.display = 'none', 500);
    };
    const texLoader = new THREE.TextureLoader(manager);

    // --- BACKGROUND: REAL MILKY WAY ---
    // Instead of dots, we use a large Sphere with a panorama texture
    const bgGeo = new THREE.SphereGeometry(80000, 64, 64);
    const bgMat = new THREE.MeshBasicMaterial({
        map: texLoader.load(MILKY_WAY_PANORAMA), // Using a real photo
        side: THREE.BackSide,
        transparent: true,
        opacity: 0.6 // Slightly dim so it doesn't overpower planets
    });
    const skybox = new THREE.Mesh(bgGeo, bgMat);
    scene.add(skybox);

    // --- ANDROMEDA GALAXY (Sprite) ---
    const galaxyTex = texLoader.load(ANDROMEDA_URL);
    const galaxyMat = new THREE.SpriteMaterial({ 
        map: galaxyTex, 
        transparent: true, 
        opacity: 0.8,
        blending: THREE.AdditiveBlending 
    });
    const andromeda = new THREE.Sprite(galaxyMat);
    // Position it very far away in 3D space
    andromeda.scale.set(10000, 5000, 1);
    andromeda.position.set(15000, 5000, -40000);
    scene.add(andromeda);

    // --- LIGHTS ---
    const sunLight = new THREE.PointLight(0xffffff, 3.0, 0, 1); // No decay, infinite range
    scene.add(sunLight);
    
    // Fill light (so shadows aren't pitch black)
    const ambiLight = new THREE.AmbientLight(0xffffff, 0.05); // Very dim ambient
    scene.add(ambiLight);
    const hemiLight = new THREE.HemisphereLight(0x0f0e0d, 0x000000, 0.2);
    scene.add(hemiLight);

    // --- POST PROCESSING (Bloom) ---
    const composer = new EffectComposer(renderer);
    const renderPass = new RenderPass(scene, camera);
    composer.addPass(renderPass);
    const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
    composer.addPass(bloomPass);

    // --- CONTROLS (ASTRO STYLE) ---
    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true; 
    controls.dampingFactor = 0.05;
    
    // CRITICAL FIXES FOR ZOOM:
    controls.enablePan = false; // Disable panning so user doesn't get lost
    controls.zoomSpeed = 0.4;   // Slow down zoom speed significantly
    controls.rotateSpeed = 0.5; // Smooth rotation
    controls.minDistance = 20;  // Don't clip into Sun
    controls.maxDistance = 15000; // Limit zoom out to roughly Pluto's orbit scale. 
                                  // Prevents flying out to the galaxy view instantly.

    // --- SUN SHADER ---
    const sunMat = new THREE.ShaderMaterial({
        uniforms: { time: { value: 0 } },
        vertexShader: `
          varying vec2 vUv;
          varying vec3 vNormal;
          void main() {
            vUv = uv; vNormal = normalize(normalMatrix * normal);
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
          }
        `,
        fragmentShader: `
          uniform float time;
          varying vec2 vUv;
          float noise(vec3 p) {
            vec3 i = floor(p); vec3 f = fract(p); f = f*f*(3.0-2.0*f);
            return mix(mix(mix(fract(sin(dot(i, vec3(1, 57, 113))) * 43758.5453),
                               fract(sin(dot(i + vec3(1, 0, 0), vec3(1, 57, 113))) * 43758.5453), f.x),
                           mix(fract(sin(dot(i + vec3(0, 1, 0), vec3(1, 57, 113))) * 43758.5453),
                               fract(sin(dot(i + vec3(1, 1, 0), vec3(1, 57, 113))) * 43758.5453), f.x), f.y),
                       mix(mix(fract(sin(dot(i + vec3(0, 0, 1), vec3(1, 57, 113))) * 43758.5453),
                               fract(sin(dot(i + vec3(1, 0, 1), vec3(1, 57, 113))) * 43758.5453), f.x),
                           mix(fract(sin(dot(i + vec3(0, 1, 1), vec3(1, 57, 113))) * 43758.5453),
                               fract(sin(dot(i + vec3(1, 1, 1), vec3(1, 57, 113))) * 43758.5453), f.x), f.y), f.z);
          }
          void main() {
            float n = noise(vec3(vUv * 10.0, time * 0.2)) * 0.5 + noise(vec3(vUv * 20.0, time * 0.5)) * 0.25;
            vec3 color = mix(vec3(1.0, 0.4, 0.0), vec3(1.0, 0.9, 0.3), n + 0.3);
            gl_FragColor = vec4(color * 1.8, 1.0);
          }
        `
    });

    // --- PLANET GENERATION ---
    const planetsGroup = new THREE.Group();
    scene.add(planetsGroup);
    let activePlanets = [];
    const addedKeys = new Set();

    function createPlanet(key) {
        const d = PLANETS[key];
        let r = d.isSun ? 5.0 : d.radius * BASE_SCALE; 
        const grp = new THREE.Group();

        if (d.isSun) {
            const mesh = new THREE.Mesh(new THREE.SphereGeometry(r, 64, 64), sunMat);
            grp.add(mesh);
            // Corona Glow
            const sprite = new THREE.Sprite(new THREE.SpriteMaterial({
                map: new THREE.CanvasTexture(generateSunGlow()),
                color: 0xffaa00, blending: THREE.AdditiveBlending
            }));
            sprite.scale.set(r*4, r*4, 1);
            grp.add(sprite);
            grp.userData.isSun = true;
        } else {
            const mat = new THREE.MeshPhongMaterial({ map: texLoader.load(d.tex), shininess: 5 });
            if(d.bump) { mat.bumpMap = texLoader.load(d.bump); mat.bumpScale = 0.02; }
            const mesh = new THREE.Mesh(new THREE.SphereGeometry(r, 64, 64), mat);
            grp.add(mesh);

            // Atmosphere
            if(d.glow) {
                const atmoGeo = new THREE.SphereGeometry(r*1.1, 64, 64);
                const atmoMat = new THREE.ShaderMaterial({
                    uniforms: { 
                        c: { value: 0.5 }, p: { value: 5.0 }, 
                        glowColor: { value: new THREE.Color(d.glow) }, 
                        viewVector: { value: camera.position } 
                    },
                    vertexShader: `uniform vec3 viewVector; uniform float c; uniform float p; varying float intensity; void main() { vec3 vNormal = normalize( normalMatrix * normal ); vec3 vNormel = normalize( normalMatrix * viewVector ); intensity = pow( c - dot(vNormal, vNormel), p ); gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 ); }`,
                    fragmentShader: `uniform vec3 glowColor; varying float intensity; void main() { gl_FragColor = vec4( glowColor, intensity ); }`,
                    side: THREE.BackSide, blending: THREE.AdditiveBlending, transparent: true, depthWrite: false
                });
                const atmo = new THREE.Mesh(atmoGeo, atmoMat);
                grp.add(atmo);
                grp.userData.glowMesh = atmo;
            }

            // Rings
            if(d.ring) {
                const rg = new THREE.RingGeometry(r*d.ring.inner, r*d.ring.outer, 128);
                const pos = rg.attributes.position; const v3 = new THREE.Vector3();
                for(let i=0; i<pos.count; i++){
                    v3.fromBufferAttribute(pos, i);
                    rg.attributes.uv.setXY(i, 0.5+v3.x/(r*d.ring.outer*2), 0.5+v3.y/(r*d.ring.outer*2));
                }
                const rm = new THREE.MeshStandardMaterial({ 
                    map: texLoader.load(d.ring.tex), side: THREE.DoubleSide, transparent: true, opacity: 0.8 
                });
                const ring = new THREE.Mesh(rg, rm);
                ring.rotation.x = -Math.PI/2;
                grp.add(ring);
            }
        }
        grp.userData = { name: key, ...d };
        return grp;
    }

    function generateSunGlow() {
        const c = document.createElement('canvas'); c.width=64; c.height=64;
        const ctx = c.getContext('2d');
        const g = ctx.createRadialGradient(32,32,0,32,32,32);
        g.addColorStop(0, 'rgba(255, 200, 100, 1)');
        g.addColorStop(0.5, 'rgba(255, 100, 0, 0.2)');
        g.addColorStop(1, 'rgba(0,0,0,0)');
        ctx.fillStyle = g; ctx.fillRect(0,0,64,64);
        return c;
    }

    // --- LOGIC ---
    let camTarget = new THREE.Vector3();

    function updatePositions() {
        const hasSun = activePlanets.some(p => p.userData.isSun);
        
        if (hasSun) {
            // SCALE MODE (Real Distance)
            sunLight.position.set(0, 0, 0);
            activePlanets.forEach(p => {
                if(p.userData.isSun) p.position.set(0,0,0);
                else {
                    // Place along X axis based on AU
                    p.position.set(p.userData.distAU * AU_SCALE, 0, 0);
                }
            });
        } else {
            // COMPARISON MODE (Line up)
            sunLight.position.set(100, 50, 100);
            activePlanets.sort((a,b) => PLANETS[a.userData.name].order - PLANETS[b.userData.name].order);
            let x = 0;
            activePlanets.forEach((p, i) => {
                if (i > 0) {
                    const prev = activePlanets[i-1];
                    let r1 = prev.userData.isSun ? 5.0 : prev.userData.radius * BASE_SCALE;
                    if(prev.userData.ring) r1 *= 1.8;
                    let r2 = p.userData.isSun ? 5.0 : p.userData.radius * BASE_SCALE;
                    if(p.userData.ring) r2 *= 1.8;
                    x += r1 + r2 + 10;
                }
                p.position.set(x, 0, 0);
            });
            // Center group
            const totalW = x;
            activePlanets.forEach(p => p.position.x -= totalW/2);
        }
    }

    window.addPlanet = (k) => {
        if(addedKeys.has(k)) return;
        const p = createPlanet(k);
        planetsGroup.add(p); activePlanets.push(p); addedKeys.add(k);
        updatePositions(); updateUI();
        
        // If adding Sun, move camera back significantly but smoothly
        if(k === 'Солнце') {
            const targetDist = 200;
            const startPos = camera.position.clone();
            const endPos = new THREE.Vector3(0, targetDist*0.4, targetDist);
            // Simple tween logic could go here, but direct lerp in animate handles it
            camTarget.copy(endPos);
        }
    };

    window.removePlanet = (k) => {
        const p = activePlanets.find(x => x.userData.name === k);
        if(!p) return;
        planetsGroup.remove(p); activePlanets = activePlanets.filter(x=>x!==p); addedKeys.delete(k);
        updatePositions(); updateUI();
    };

    window.clearAll = () => {
        [...activePlanets].forEach(p => window.removePlanet(p.userData.name));
        window.addPlanet('Солнце'); // Reset to just Sun
    };

    // UI Builders
    const box = document.getElementById('planetBtns');
    Object.keys(PLANETS).sort((a,b)=>PLANETS[a].order-PLANETS[b].order).forEach(k => {
        const b = document.createElement('div');
        b.className = 'chip'; b.textContent = k; b.dataset.p = k;
        b.onclick = () => addedKeys.has(k) ? window.removePlanet(k) : window.addPlanet(k);
        box.appendChild(b);
    });

    function updateUI() {
        document.querySelectorAll('.chip').forEach(c => 
            addedKeys.has(c.dataset.p) ? c.classList.add('active') : c.classList.remove('active')
        );
    }

    // Init
    window.addPlanet('Солнце');
    window.addPlanet('Земля');
    camera.position.set(0, 40, 100); // Initial pos

    // --- LOOP ---
    function animate(time) {
        requestAnimationFrame(animate);
        const t = time * 0.001;

        // Rotate Planets
        activePlanets.forEach(p => {
            if(p.userData.isSun) {
                p.children[0].material.uniforms.time.value = t;
                p.children[0].rotation.y = t * 0.05;
            } else {
                p.children[0].rotation.y += 0.005;
                if(p.userData.glowMesh) p.userData.glowMesh.material.uniforms.viewVector.value = camera.position;
            }
        });

        // Slow rotate background for realism
        skybox.rotation.y = t * 0.005;

        controls.update();
        composer.render();
    }

    // Input Handling
    const ray = new THREE.Raycaster();
    const m = new THREE.Vector2();
    window.addEventListener('dblclick', e => {
        m.x = (e.clientX/innerWidth)*2-1; m.y = -(e.clientY/innerHeight)*2+1;
        ray.setFromCamera(m, camera);
        const hits = ray.intersectObjects(planetsGroup.children, true);
        if(hits.length) {
            let o = hits[0].object; while(o.parent && o.parent!==planetsGroup) o=o.parent;
            const d = o.userData;
            document.getElementById('mTitle').textContent = d.name;
            document.getElementById('mType').textContent = d.type || 'Планета';
            document.getElementById('mStats').innerHTML = `
                <div><small style="color:#888; text-transform:uppercase">Масса</small><br>${d.info.mass}</div>
                <div><small style="color:#888; text-transform:uppercase">Температура</small><br>${d.info.temp}</div>
            `;
            document.getElementById('mFact').textContent = d.fact;
            document.getElementById('modal').classList.add('visible');
        }
    });
    window.closeModal = () => document.getElementById('modal').classList.remove('visible');

    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth/window.innerHeight; camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight); composer.setSize(window.innerWidth, window.innerHeight);
    });

    animate(0);
  </script>
</body>
</html>