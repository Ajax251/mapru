<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no, maximum-scale=1.0" />
  <title>Планеты</title>
  <style>
    :root {
      --panel-bg: rgba(8, 12, 21, 0.85); /* Более прозрачный фон */
      --panel-border: rgba(255, 255, 255, 0.1);
      --cyan: #00d4ff;
      --cyan-dark: #0099cc;
      --gold: #ffc107;
      --danger: #ff4757;
      --success: #2ed573;
      --glass: rgba(255, 255, 255, 0.05);
    }
    * { margin: 0; padding: 0; box-sizing: border-box; }
    html, body {
      width: 100%; height: 100%; overflow: hidden; background: #000;
      font-family: 'SF Pro Display', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
      /* Отключаем выделение текста для тач-интерфейсов */
      user-select: none;
      -webkit-user-select: none;
    }
    canvas { display: block; outline: none; }
    
    #header {
      position: absolute; top: 30px; left: 50%; transform: translateX(-50%); color: white;
      text-align: center; z-index: 10; pointer-events: none; width: 100%;
      text-shadow: 0 2px 10px rgba(0,0,0,0.8);
    }
    #header h1 {
      font-size: 32px; font-weight: 200; letter-spacing: 8px;
      background: linear-gradient(135deg, #fff 0%, var(--cyan) 50%, #fff 100%);
      -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text;
      margin-bottom: 8px;
    }
    #header p {
      font-size: 12px; color: rgba(255, 255, 255, 0.6); letter-spacing: 3px; text-transform: uppercase;
    }

    #ui {
      position: absolute; top: 30px; right: 30px; 
      background: var(--panel-bg); padding: 24px;
      border-radius: 20px; border: 1px solid var(--panel-border); color: white; width: 300px;
      box-shadow: 0 25px 50px rgba(0, 0, 0, 0.5), inset 0 1px 0 rgba(255, 255, 255, 0.05);
      backdrop-filter: blur(20px); -webkit-backdrop-filter: blur(20px);
      z-index: 20;
      transition: all 0.3s ease;
    }
    
    .ui-title {
      font-size: 11px; color: var(--cyan); margin-bottom: 15px; text-transform: uppercase;
      letter-spacing: 3px; font-weight: 600; display: flex; align-items: center; gap: 10px;
    }
    .ui-title::before {
      content: ''; width: 20px; height: 1px;
      background: linear-gradient(90deg, var(--cyan), transparent);
    }
    
    .planet-grid { display: grid; grid-template-columns: repeat(2, 1fr); gap: 8px; margin-bottom: 15px; }
    
    .planet-btn {
      background: var(--glass); border: 1px solid rgba(255, 255, 255, 0.08);
      color: rgba(255, 255, 255, 0.8); padding: 12px 5px; border-radius: 10px;
      cursor: pointer; font-size: 13px; font-weight: 500;
      transition: all 0.2s; position: relative; overflow: hidden;
    }
    .planet-btn:active { transform: scale(0.95); }
    .planet-btn.added {
      background: rgba(46, 213, 115, 0.2); border-color: var(--success); color: white;
    }
    /* Галочка */
    .planet-btn.added::before {
      content: '•'; position: absolute; right: 6px; top: 6px; color: var(--success); font-size: 14px; line-height: 0;
    }

    .control-btn {
      width: 100%; background: rgba(255, 71, 87, 0.1); border: 1px solid rgba(255, 71, 87, 0.3);
      color: var(--danger); padding: 12px; border-radius: 10px; cursor: pointer;
      font-size: 13px; font-weight: 600; transition: all 0.3s;
    }
    .control-btn:hover { background: var(--danger); color: white; }

    /* Modal Styles (без изменений, кроме адаптива) */
    .modal-overlay {
      position: fixed; inset: 0; background: rgba(0, 0, 0, 0.8); backdrop-filter: blur(10px);
      z-index: 100; opacity: 0; visibility: hidden; transition: all 0.3s;
      display: flex; align-items: center; justify-content: center;
    }
    .modal-overlay.visible { opacity: 1; visibility: visible; }
    .modal-content {
      background: linear-gradient(180deg, rgba(15, 25, 40, 0.98) 0%, rgba(8, 12, 21, 0.98) 100%);
      border-radius: 28px; border: 1px solid rgba(255, 255, 255, 0.1); max-width: 600px;
      width: 90%; max-height: 80vh; overflow-y: auto;
      transform: scale(0.95); transition: all 0.3s;
    }
    .modal-overlay.visible .modal-content { transform: scale(1); }
    .modal-header { padding: 30px; position: relative; border-bottom: 1px solid rgba(255,255,255,0.05); }
    .planet-title { font-size: 32px; font-weight: 200; color: white; }
    .planet-subtitle { font-size: 12px; color: var(--cyan); text-transform: uppercase; letter-spacing: 2px; }
    .close-modal {
      position: absolute; top: 20px; right: 20px; width: 40px; height: 40px;
      background: rgba(255,255,255,0.1); border: none; border-radius: 50%;
      color: white; font-size: 24px; cursor: pointer;
    }
    .modal-body { padding: 30px; }
    .stats-grid { display: grid; grid-template-columns: repeat(2, 1fr); gap: 12px; margin-bottom: 25px; }
    .stat-card {
      background: rgba(255, 255, 255, 0.03); border-radius: 12px; padding: 15px;
    }
    .stat-value { font-size: 14px; color: white; font-weight: 500; margin-top: 4px; }
    .stat-label { font-size: 10px; color: rgba(255,255,255,0.4); text-transform: uppercase; }
    .fact-card { background: rgba(0, 212, 255, 0.05); padding: 20px; border-radius: 16px; border: 1px solid rgba(0,212,255,0.1); }
    .fact-text { font-size: 14px; color: rgba(255,255,255,0.85); line-height: 1.6; }

    #hints {
      position: absolute; bottom: 30px; left: 30px; color: rgba(255, 255, 255, 0.3);
      font-size: 11px; z-index: 5;
    }

    .planet-counter {
      display: flex; align-items: baseline; justify-content: space-between; 
      padding-bottom: 10px; margin-bottom: 10px; border-bottom: 1px solid rgba(255,255,255,0.1);
    }

    /* --- MOBILE ADAPTATION --- */
    @media (max-width: 768px) {
      /* Header compact */
      #header { top: 15px; }
      #header h1 { font-size: 20px; letter-spacing: 3px; margin-bottom: 4px; }
      #header p { font-size: 10px; letter-spacing: 1px; }

      /* UI Panel Move to Bottom */
      #ui {
        top: auto; bottom: 0; right: 0; left: 0; width: 100%;
        border-radius: 20px 20px 0 0;
        padding: 15px 15px 25px 15px; /* Extra padding at bottom for iOS home bar */
        border-left: none; border-right: none; border-bottom: none;
        max-height: 40vh; /* Don't take more than 40% height */
        display: flex; flex-direction: column;
      }
      
      .ui-title { display: none; } /* Экономим место */
      
      .planet-counter { display: none; } /* Экономим место */

      .planet-grid {
        grid-template-columns: repeat(5, 1fr); /* Больше колонок */
        gap: 6px; margin-bottom: 10px;
      }

      .planet-btn {
        padding: 8px 2px; font-size: 9px;
        display: flex; flex-direction: column; align-items: center; justify-content: center;
        text-align: center; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;
      }
      
      .planet-btn.added::before { top: 2px; right: 2px; font-size: 10px; }

      .control-btn { padding: 10px; font-size: 12px; margin-top: 0; }

      #hints { display: none; }
      
      .modal-content { max-height: 85vh; width: 95%; }
    }
  </style>
</head>
<body>

  <div id="header">
    <h1>ПЛАНЕТЫ СОЛНЕЧНОЙ СИСТЕМЫ</h1>
    
  </div>

  <div id="hints">
    <div>ЛКМ — Вращение • Колесо — Зум • 2xКлик — Инфо</div>
  </div>

  <div id="ui">
    <div class="ui-title">Управление</div>
    <div class="planet-counter">
      <span style="font-size: 12px; color:rgba(255,255,255,0.5)">ВЫБРАНО ПЛАНЕТ</span>
      <strong id="planetCount" style="color:var(--cyan)">0</strong>
    </div>
    <div class="planet-grid" id="planetButtons"></div>
    <button class="control-btn" onclick="clearAll()">Сбросить всё</button>
  </div>

  <div class="modal-overlay" id="modal">
    <div class="modal-content">
      <div class="modal-header">
        <h2 class="planet-title" id="modalTitle"></h2>
        <p class="planet-subtitle" id="modalSubtitle"></p>
        <button class="close-modal" onclick="closeModal()">×</button>
      </div>
      <div class="modal-body">
        <div class="stats-grid" id="statsGrid"></div>
        <div class="fact-card">
          <p class="fact-text" id="factText"></p>
        </div>
      </div>
    </div>
  </div>

  <script type="importmap">
    { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js", "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/" } }
  </script>

  <script type="module">
    import * as THREE from "three";
    import { OrbitControls } from "three/addons/controls/OrbitControls.js";
    import { UnrealBloomPass } from "three/addons/postprocessing/UnrealBloomPass.js";
    import { EffectComposer } from "three/addons/postprocessing/EffectComposer.js";
    import { RenderPass } from "three/addons/postprocessing/RenderPass.js";

    // --- CONFIGURATION ---
    const PLANETS = {
      Меркурий: { order: 1, radius: 2439, tex: 'textures/mercury2.jpg', bump: 'textures/mercury2.jpg', type: 'Планета земной группы', info: { mass: '3.3 × 10²³ кг', temp: '-173°C / +427°C', day: '58.6 дн.', distance: '57.9 млн км', fact: 'Меркурий — самая быстрая планета (88 дней вокруг Солнца).' } },
      Венера: { order: 2, radius: 6051, tex: 'textures/venus.jpg', bump: 'textures/venus.jpg', glow: 0xffaa55, type: 'Планета земной группы', info: { mass: '4.87 × 10²⁴ кг', temp: '+462°C', day: '243 дн.', distance: '108.2 млн км', fact: 'Венера вращается в обратную сторону и жарче Меркурия.' } },
      Земля: { order: 3, radius: 6371, tex: 'textures/earth-blue-marble.jpg', spec: 'textures/earth2.jpg', glow: 0x4488ff, type: 'Планета земной группы', info: { mass: '5.97 × 10²⁴ кг', temp: '-89°C / +58°C', day: '24 ч.', distance: '149.6 млн км', fact: 'Единственная известная планета с жизнью и жидкой водой.' } },
      Луна: { order: 3.5, radius: 1737, tex: 'textures/moon.png', bump: 'textures/moon.png', type: 'Спутник', info: { mass: '7.35 × 10²² кг', temp: '-173°C / +127°C', day: '27.3 дн.', distance: '384 400 км', fact: 'Луна вызывает приливы на Земле и всегда повернута одной стороной.' } },
      Марс: { order: 4, radius: 3389, tex: 'textures/mars.jpg', bump: 'textures/mars2.jpg', glow: 0xff6644, type: 'Планета земной группы', info: { mass: '6.42 × 10²³ кг', temp: '-87°C / -5°C', day: '24.6 ч.', distance: '227.9 млн км', fact: 'Имеет самую высокую гору в системе — Олимп (21 км).' } },
      Юпитер: { order: 5, radius: 69911, tex: 'textures/jupiter.jpg', glow: 0xffcc88, type: 'Газовый гигант', info: { mass: '1.9 × 10²⁷ кг', temp: '-108°C', day: '9.9 ч.', distance: '778.5 млн км', fact: 'Больше всех остальных планет вместе взятых в 2.5 раза.' } },
      Сатурн: { order: 6, radius: 58232, tex: 'textures/saturn.jpg', glow: 0xffdd99, type: 'Газовый гигант', ring: { tex: 'textures/saturn2.png', inner: 74500, outer: 140220 }, info: { mass: '5.68 × 10²⁶ кг', temp: '-139°C', day: '10.7 ч.', distance: '1.43 млрд км', fact: 'Мог бы плавать в воде, так как его плотность меньше воды.' } },
      Уран: { order: 7, radius: 25362, tex: 'textures/uranus.jpg', glow: 0x4499cc, type: 'Ледяной гигант', info: { mass: '8.68 × 10²⁵ кг', temp: '-197°C', day: '17.2 ч.', distance: '2.87 млрд км', fact: 'Вращается «лежа на боку» (наклон оси 98°).' } },
      Нептун: { order: 8, radius: 24622, tex: 'textures/neptune.jpg', glow: 0x4466ee, type: 'Ледяной гигант', info: { mass: '1.02 × 10²⁶ кг', temp: '-201°C', day: '16.1 ч.', distance: '4.5 млрд км', fact: 'Ветра достигают скорости 2100 км/ч (сверхзвуковые).' } },
      Плутон: { order: 9, radius: 1188, tex: 'textures/pluto.jpg', bump: 'textures/pluto.jpg', type: 'Карликовая планета', info: { mass: '1.3 × 10²² кг', temp: '-223°C', day: '6.4 дн.', distance: '5.9 млрд км', fact: 'С 2006 года считается карликовой планетой пояса Койпера.' } }
    };

    const BASE_SCALE = 1 / 5000;
    
    // --- SCENE SETUP ---
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x000306);
    
    const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 50000);
    const renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.1;
    document.body.appendChild(renderer.domElement);

    // --- POST PROCESSING ---
    const composer = new EffectComposer(renderer);
    composer.addPass(new RenderPass(scene, camera));
    const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 0.5, 0.4, 0.85);
    composer.addPass(bloomPass);

    // --- CONTROLS ---
    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;
    controls.minDistance = 10;
    controls.maxDistance = 1000;
    controls.maxPolarAngle = Math.PI * 0.9;
    controls.enableZoom = false; // Zoom is handled manually to prevent jumping

    // --- LIGHTS ---
    scene.add(new THREE.AmbientLight(0xffffff, 0.6));
    const mainLight = new THREE.DirectionalLight(0xffffff, 1.2);
    mainLight.position.set(50, 20, 50);
    scene.add(mainLight);

    // --- STARS ---
    function createStars() {
      const geo = new THREE.BufferGeometry(); const count = 5000; const pos = new Float32Array(count * 3);
      for (let i = 0; i < count; i++) {
        const r = 800 + Math.random() * 1200; 
        const theta = Math.random() * Math.PI * 2; 
        const phi = Math.acos(2 * Math.random() - 1);
        pos[i * 3] = r * Math.sin(phi) * Math.cos(theta); 
        pos[i * 3 + 1] = r * Math.cos(phi); 
        pos[i * 3 + 2] = r * Math.sin(phi) * Math.sin(theta);
      }
      geo.setAttribute("position", new THREE.BufferAttribute(pos, 3));
      return new THREE.Points(geo, new THREE.PointsMaterial({ color: 0x888888, size: 1.2 }));
    }
    scene.add(createStars());

    // --- PLANET MANAGEMENT ---
    const loadingManager = new THREE.LoadingManager();
    const textureLoader = new THREE.TextureLoader(loadingManager);
    
    let activePlanets = [];
    const addedPlanetKeys = new Set();
    const planetsGroup = new THREE.Group();
    scene.add(planetsGroup);

    // Camera target logic
    let cameraTarget = { position: new THREE.Vector3(0, 30, 80), target: new THREE.Vector3(0, 0, 0) };
    let userHasInteracted = false;

    // Reset interaction flag logic
    controls.addEventListener('start', () => { userHasInteracted = true; });
    renderer.domElement.addEventListener('wheel', (e) => {
        e.preventDefault();
        userHasInteracted = true;
        const scale = e.deltaY > 0 ? 1.1 : 0.9;
        const currentDist = camera.position.distanceTo(controls.target);
        let newDist = currentDist * scale;
        newDist = Math.max(controls.minDistance, Math.min(controls.maxDistance, newDist));
        
        const dir = new THREE.Vector3().subVectors(camera.position, controls.target).normalize();
        camera.position.copy(controls.target).add(dir.multiplyScalar(newDist));
    }, { passive: false });

    function createPlanet(key) {
      const data = PLANETS[key];
      const radius = data.radius * BASE_SCALE;
      const geometry = new THREE.SphereGeometry(radius, 64, 64);
      
      const materialProps = { 
        map: textureLoader.load(data.tex), 
        shininess: 5,
        emissive: data.glow ? new THREE.Color(data.glow) : new THREE.Color(0x000000),
        emissiveIntensity: data.glow ? 0.15 : 0 
      };
      
      if (data.bump) { materialProps.bumpMap = textureLoader.load(data.bump); materialProps.bumpScale = 0.05; }
      if (data.spec) { materialProps.specularMap = textureLoader.load(data.spec); materialProps.specular = new THREE.Color(0x333333); }
      
      const mesh = new THREE.Mesh(geometry, new THREE.MeshPhongMaterial(materialProps));
      const container = new THREE.Group();
      container.add(mesh);

    
  // Atmosphere Glow
      if (data.glow) {
        const glowMat = new THREE.ShaderMaterial({
          uniforms: { glowColor: { value: new THREE.Color(data.glow) } },
          // Изменено: pow(..., 5.0) делает градиент резче, 0.63 - сдвигает границу
          vertexShader: `varying float intensity; void main() { vec3 vNormal = normalize( normalMatrix * normal ); vec3 vNormel = normalize( normalMatrix * cameraPosition ); intensity = pow( 0.63 - dot( vNormal, vNormel ), 5.0 ); gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 ); }`,
          // Изменено: intensity * 0.25 снижает яркость/прозрачность
          fragmentShader: `uniform vec3 glowColor; varying float intensity; void main() { gl_FragColor = vec4( glowColor, intensity * 0.25 ); }`,
          side: THREE.BackSide, blending: THREE.AdditiveBlending, transparent: true, depthWrite: false
        });
        // Изменено: radius * 1.08 (было 1.15) — уменьшает размер ореола
        container.add(new THREE.Mesh(new THREE.SphereGeometry(radius * 1.08, 32, 32), glowMat));
      }

      // Rings
      if (data.ring) {
        const ringGeo = new THREE.RingGeometry(data.ring.inner * BASE_SCALE, data.ring.outer * BASE_SCALE, 128);
        const ringMat = new THREE.MeshBasicMaterial({ 
          map: textureLoader.load(data.ring.tex), 
          side: THREE.DoubleSide, transparent: true, opacity: 0.9 
        });
        // Выравниваем UV кольца
        const pos = ringGeo.attributes.position;
        const v3 = new THREE.Vector3();
        for (let i = 0; i < pos.count; i++){
          v3.fromBufferAttribute(pos, i);
          ringGeo.attributes.uv.setXY(i, 0.5 + v3.x / (data.ring.outer * BASE_SCALE * 2), 0.5 + v3.y / (data.ring.outer * BASE_SCALE * 2));
        }
        const ringMesh = new THREE.Mesh(ringGeo, ringMat);
        ringMesh.rotation.x = -Math.PI / 2;
        container.add(ringMesh);
      }

      container.userData = { name: key, radius: radius, info: data.info, type: data.type, realRadius: data.radius };
      return container;
    }

    function recalculatePositions() {
      if (activePlanets.length === 0) { fitCamera(); return; }

      // 1. Sort by solar system order
      activePlanets.sort((a, b) => PLANETS[a.userData.name].order - PLANETS[b.userData.name].order);

      // 2. Calculate positions on X axis
      let currentX = 0;
      const padding = 2; // gap between planets

      activePlanets.forEach((obj, i) => {
        const hasRing = !!PLANETS[obj.userData.name].ring;
        const r = obj.userData.radius;
        // Visual width: if rings, take roughly ring radius, else planet radius
        const width = hasRing ? r * 2.2 : r; 
        
        if (i > 0) {
          const prev = activePlanets[i - 1];
          const prevRing = !!PLANETS[prev.userData.name].ring;
          const prevWidth = prevRing ? prev.userData.radius * 2.2 : prev.userData.radius;
          currentX += prevWidth + width + padding;
        }
        
        obj.userData.targetX = currentX;
      });

      // 3. Center the whole group around X=0
      const totalWidth = activePlanets[activePlanets.length - 1].userData.targetX;
      const offset = totalWidth / 2;
      
      activePlanets.forEach(obj => {
        obj.userData.targetX -= offset;
      });

      fitCamera();
    }

    // --- УЛУЧШЕННАЯ ЛОГИКА КАМЕРЫ ---
    function fitCamera() {
      if (activePlanets.length === 0) return;
      
      // Вычисляем границы всех объектов
      const box = new THREE.Box3();
      activePlanets.forEach(obj => {
         // Простая аппроксимация сферы для Box3, чтобы не пересчитывать геометрию каждый кадр
         const r = obj.userData.radius;
         const hasRing = !!PLANETS[obj.userData.name].ring;
         const size = hasRing ? r * 2.5 : r; // берем с запасом
         
         const center = new THREE.Vector3(obj.userData.targetX || obj.position.x, 0, 0);
         box.expandByPoint(center.clone().addScalar(size));
         box.expandByPoint(center.clone().subScalar(size));
      });

      const size = new THREE.Vector3(); 
      box.getSize(size);
      const center = new THREE.Vector3(); 
      box.getCenter(center);

      // Рассчитываем необходимую дистанцию (Z)
      const fovRad = camera.fov * (Math.PI / 180);
      const aspect = camera.aspect;
      
      // Дистанция, чтобы вместить высоту объектов
      const distVertical = size.y / (2 * Math.tan(fovRad / 2));
      // Дистанция, чтобы вместить ширину (критично для мобильных!)
      const distHorizontal = size.x / (2 * Math.tan(fovRad / 2) * aspect);
      
      // Берем максимальную + отступ 15%
      let cameraZ = Math.max(distVertical, distHorizontal) * 1.15;
      cameraZ = Math.max(cameraZ, 25); // Минимальный зум

      // --- МОБИЛЬНЫЙ СДВИГ ---
      // На мобильных UI внизу. Чтобы планеты были визуально в центре свободной зоны,
      // мы заставляем камеру смотреть НИЖЕ реального центра планет.
      // Тогда планеты "уедут" вверх экрана.
      const isMobile = window.innerWidth < 768;
      const verticalOffset = isMobile ? -cameraZ * 0.2 : 0; // Смещаем точку обзора вниз

      cameraTarget.position.set(center.x, center.y + cameraZ * 0.4, cameraZ); // Камера чуть выше плоскости
      cameraTarget.target.set(center.x, center.y + verticalOffset, center.z);
      
      userHasInteracted = false;
    }

    // --- UI ACTIONS ---
    window.addPlanet = (key) => {
      if (addedPlanetKeys.has(key)) return;
      const planet = createPlanet(key);
      
      // Animation start pos
      planet.scale.set(0, 0, 0);
      planet.position.y = -10;
      
      planetsGroup.add(planet);
      activePlanets.push(planet);
      addedPlanetKeys.add(key);
      
      recalculatePositions();
      updateUI();

      // Animate In
      let p = 0;
      function tick() {
        p += 0.05;
        const s = Math.min(p, 1);
        const ease = 1 - Math.pow(1 - s, 3);
        planet.scale.setScalar(ease);
        planet.position.y = -10 * (1 - ease);
        if (p < 1) requestAnimationFrame(tick);
      }
      tick();
    };

    window.removePlanet = (key) => {
      const planet = activePlanets.find(p => p.userData.name === key);
      if (!planet) return;
      
      // Animation Out
      let p = 0;
      function tick() {
        p += 0.08;
        const s = Math.min(p, 1);
        planet.scale.setScalar(1 - s);
        planet.position.y = 10 * s;
        
        if (p < 1) {
          requestAnimationFrame(tick);
        } else {
          planetsGroup.remove(planet);
          activePlanets = activePlanets.filter(p => p !== planet);
          addedPlanetKeys.delete(key);
          recalculatePositions();
          updateUI();
        }
      }
      tick();
    };

    window.clearAll = () => {
      [...activePlanets].forEach((p, i) => setTimeout(() => window.removePlanet(p.userData.name), i * 50));
    };

    function updateUI() {
      document.getElementById('planetCount').textContent = activePlanets.length;
      document.querySelectorAll('.planet-btn').forEach(btn => {
        const key = btn.dataset.planet;
        if (addedPlanetKeys.has(key)) btn.classList.add('added');
        else btn.classList.remove('added');
      });
    }

    // Create Buttons
    const btnContainer = document.getElementById("planetButtons");
    Object.keys(PLANETS).sort((a,b) => PLANETS[a].order - PLANETS[b].order).forEach(key => {
      const btn = document.createElement("div"); 
      btn.className = "planet-btn"; 
      btn.textContent = key; 
      btn.dataset.planet = key;
      btn.onclick = () => { 
        if (addedPlanetKeys.has(key)) window.removePlanet(key); 
        else window.addPlanet(key); 
      };
      btnContainer.appendChild(btn);
    });

    // --- MODAL ---
    function showModal(planetObj) {
      const { name, type, realRadius, info } = planetObj.userData;
      document.getElementById('modalTitle').textContent = name;
      document.getElementById('modalSubtitle').textContent = type;
      document.getElementById('statsGrid').innerHTML = `
        <div class="stat-card"><div class="stat-label">Радиус</div><div class="stat-value">${realRadius.toLocaleString()} км</div></div>
        <div class="stat-card"><div class="stat-label">Масса</div><div class="stat-value">${info.mass}</div></div>
        <div class="stat-card"><div class="stat-label">Температура</div><div class="stat-value">${info.temp}</div></div>
        <div class="stat-card"><div class="stat-label">Сутки</div><div class="stat-value">${info.day}</div></div>
        <div class="stat-card"><div class="stat-label">Расстояние</div><div class="stat-value">${info.distance}</div></div>
      `;
      document.getElementById('factText').textContent = info.fact;
      document.getElementById('modal').classList.add('visible');
    }
    window.closeModal = () => document.getElementById('modal').classList.remove('visible');
    document.getElementById('modal').addEventListener('click', (e) => { if (e.target === e.currentTarget) closeModal(); });

    // --- INTERACTION ---
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();
    renderer.domElement.addEventListener('dblclick', (event) => {
      event.preventDefault(); // Prevent zoom on mobile
      mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
      mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
      raycaster.setFromCamera(mouse, camera);
      const intersects = raycaster.intersectObjects(planetsGroup.children, true);
      if (intersects.length > 0) {
        let t = intersects[0].object;
        while (t.parent && t.parent !== planetsGroup) t = t.parent;
        if (activePlanets.includes(t)) showModal(t);
      }
    });

    // Init Scene
    setTimeout(() => { ['Земля', 'Марс'].forEach(p => window.addPlanet(p)); }, 100);

    // --- LOOP ---
    function animate() {
      requestAnimationFrame(animate);
      
      // Smooth Camera Transition
      if (!userHasInteracted) {
        camera.position.lerp(cameraTarget.position, 0.05);
        controls.target.lerp(cameraTarget.target, 0.05);
      }

      // Planet Rotation & Positioning
      activePlanets.forEach(obj => {
        if (obj.userData.targetX !== undefined) {
          obj.position.x += (obj.userData.targetX - obj.position.x) * 0.1;
        }
        // Rotate the mesh inside the group (child 0)
        if (obj.children[0]) obj.children[0].rotation.y += 0.002;
        // If rings exist (often child 2 or last), rotate them slightly too? Usually rings don't rotate fast visually relative to texture
      });

      controls.update();
      composer.render();
    }

    window.addEventListener("resize", () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
      composer.setSize(window.innerWidth, window.innerHeight);
      fitCamera();
    });

    animate();
  </script>
</body>
</html>