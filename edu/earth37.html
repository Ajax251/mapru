<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no, maximum-scale=1.0" />
<link rel="icon" href="worldwide.png" type="image/png" />
<title>–ó–µ–º–ª—è 3D</title>
<style>
:root {
--glass-bg: rgba(12, 20, 40, 0.65);
--glass-border: rgba(100, 220, 255, 0.15);
--glass-highlight: rgba(255, 255, 255, 0.05);
--neon-cyan: #00f3ff;
--neon-blue: #0066ff;
--gold: #ffd700;
--red-ui: #ff3366;
--text-main: #ffffff;
--text-muted: #8ba4b8;
}

html, body {
width: 100%; height: 100%; margin: 0; padding: 0; overflow: hidden;
background-color: #000;
font-family: "Segoe UI", "Roboto", system-ui, sans-serif;
touch-action: none;
}

canvas { display: block; width: 100%; height: 100%; outline: none; }

#loading {
position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
color: var(--neon-cyan); letter-spacing: 3px; font-size: 14px;
pointer-events: none; text-transform: uppercase; font-weight: 600;
user-select: none; white-space: nowrap; z-index: 10;
text-shadow: 0 0 15px rgba(0, 243, 255, 0.4);
animation: pulse 2s infinite;
}
@keyframes pulse { 0% { opacity: 0.6; } 50% { opacity: 1; } 100% { opacity: 0.6; } }

.panel-glass {
background: var(--glass-bg);
backdrop-filter: blur(16px);
-webkit-backdrop-filter: blur(16px);
border: 1px solid var(--glass-border);
border-radius: 16px;
box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5), inset 0 0 0 1px var(--glass-highlight);
color: var(--text-main);
transition: transform 0.4s cubic-bezier(0.2, 0.8, 0.2, 1), opacity 0.4s;
}

#ui {
position: absolute; bottom: 20px; right: 20px; width: 280px;
padding: 0; display: flex; flex-direction: column; z-index: 5;
}

.ui-header {
background: rgba(0, 10, 20, 0.3);
padding: 20px 20px 15px 20px;
border-bottom: 1px solid var(--glass-border);
text-align: center;
border-radius: 16px 16px 0 0;
}
#time-now {
font-size: 32px; font-weight: 300; letter-spacing: 1px;
color: #fff; text-shadow: 0 0 10px rgba(255,255,255,0.3);
font-variant-numeric: tabular-nums; line-height: 1; margin-bottom: 4px;
}
#date-now {
font-size: 11px; color: var(--neon-cyan); text-transform: uppercase;
letter-spacing: 4px; font-weight: 700; opacity: 0.9;
text-shadow: 0 0 8px rgba(0, 243, 255, 0.4);
}

.ui-controls { padding: 15px 20px; display: flex; flex-direction: column; gap: 12px; }

.row { display: flex; justify-content: space-between; align-items: center; font-size: 14px; font-weight: 500; letter-spacing: 0.5px; }

.switch { position: relative; width: 44px; height: 24px; flex: 0 0 auto; }
.switch input { opacity: 0; width: 0; height: 0; }
.slider {
position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0;
background-color: rgba(255,255,255,0.1); border-radius: 34px; transition: .3s;
border: 1px solid rgba(255,255,255,0.1);
}
.slider:before {
position: absolute; content: ""; height: 16px; width: 16px; left: 3px; bottom: 3px;
background-color: #ccc; border-radius: 50%; transition: .3s;
box-shadow: 0 2px 4px rgba(0,0,0,0.3);
}
input:checked + .slider { background-color: rgba(0, 243, 255, 0.25); border-color: var(--neon-cyan); }
input:checked + .slider:before { transform: translateX(20px); background-color: var(--neon-cyan); box-shadow: 0 0 10px var(--neon-cyan); }

#data {
font-family: "Consolas", "Monaco", monospace; font-size: 11px; color: var(--neon-cyan);
margin: 5px 20px 20px 20px; padding-top: 12px;
border-top: 1px solid rgba(255,255,255,0.1); line-height: 1.7; min-height: 72px;
}

#moonInfo {
position: absolute; top: 20px; left: 20px; width: 260px;
padding: 20px; display: none; z-index: 5;
}
.moonTitle {
font-size: 13px; font-weight: 700; color: var(--gold); text-align: center; margin-bottom: 15px;
text-transform: uppercase; letter-spacing: 3px; text-shadow: 0 0 10px rgba(255, 204, 0, 0.3);
}
#moonPhase {
width: 140px; height: 140px; margin: 0 auto 15px auto; border-radius: 50%; overflow: hidden;
box-shadow: 0 0 40px rgba(255,255,255,0.05); border: 1px solid rgba(255,255,255,0.1); background: #000;
}
#moonData {
font-family: "Consolas", monospace; font-size: 11px; color: #ddd; line-height: 1.6;
text-align: center; min-height: 76px;
}
.phaseName { font-size: 13px; color: var(--gold); font-weight: 700; margin-bottom: 6px; }

#btn-sky-view {
margin-top: 15px;
width: 100%;
padding: 10px 15px;
background: linear-gradient(135deg, rgba(255, 215, 0, 0.2), rgba(255, 180, 0, 0.1));
border: 1px solid var(--gold);
color: var(--gold);
border-radius: 8px;
font-size: 12px;
font-weight: 600;
letter-spacing: 1px;
text-transform: uppercase;
cursor: pointer;
transition: all 0.3s ease;
display: flex;
align-items: center;
justify-content: center;
gap: 8px;
}
#btn-sky-view:hover {
background: linear-gradient(135deg, rgba(255, 215, 0, 0.4), rgba(255, 180, 0, 0.2));
box-shadow: 0 0 20px rgba(255, 215, 0, 0.3);
transform: translateY(-2px);
}
#btn-sky-view:active {
transform: translateY(0);
}

#btn-clear-cache {
position: absolute; bottom: 20px; left: 20px; width: 44px; height: 44px;
background: var(--glass-bg); border: 1px solid rgba(255, 80, 80, 0.3);
color: #ff5555; border-radius: 50%; cursor: pointer; z-index: 100;
display: flex; justify-content: center; align-items: center;
backdrop-filter: blur(8px); box-shadow: 0 4px 15px rgba(0,0,0,0.3);
transition: all 0.3s;
}
#btn-clear-cache:hover {
background: rgba(255, 50, 50, 0.15); border-color: #ff5555;
box-shadow: 0 0 20px rgba(255, 50, 50, 0.4); transform: rotate(90deg);
}

#btn-exit-iss {
position: absolute; bottom: 40px; left: 50%; transform: translateX(-50%) translateY(100px);
background: rgba(0, 0, 0, 0.6); border: 1px solid var(--red-ui); color: var(--red-ui);
padding: 12px 28px; border-radius: 30px; font-size: 13px; font-weight: 700; letter-spacing: 2px;
cursor: pointer; z-index: 20; backdrop-filter: blur(10px); text-transform: uppercase;
transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275); opacity: 0; pointer-events: none;
box-shadow: 0 0 15px rgba(255, 51, 102, 0.2);
}
#btn-exit-iss:hover { background: var(--red-ui); color: white; box-shadow: 0 0 30px rgba(255, 51, 102, 0.6); }
#btn-exit-iss.visible { transform: translateX(-50%) translateY(0); opacity: 1; pointer-events: auto; }

.iss-hint {
position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
color: var(--neon-cyan); font-size: 11px; text-transform: uppercase; letter-spacing: 1.5px;
opacity: 0; transition: opacity 0.3s; pointer-events: none; z-index: 8; font-weight: 600;
text-shadow: 0 0 10px var(--neon-cyan); background: rgba(0,0,0,0.6);
padding: 6px 12px; border-radius: 6px; border: 1px solid var(--glass-border);
}

#btn-exit-moon {
position: absolute; bottom: 40px; left: 50%; transform: translateX(-50%) translateY(100px);
background: rgba(0, 0, 0, 0.6); border: 1px solid var(--gold); color: var(--gold);
padding: 12px 28px; border-radius: 30px; font-size: 13px; font-weight: 700; letter-spacing: 2px;
cursor: pointer; z-index: 20; backdrop-filter: blur(10px); text-transform: uppercase;
transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275); opacity: 0; pointer-events: none;
box-shadow: 0 0 15px rgba(255, 215, 0, 0.2);
}
#btn-exit-moon:hover { background: var(--gold); color: #000; box-shadow: 0 0 30px rgba(255, 215, 0, 0.6); }
#btn-exit-moon.visible { transform: translateX(-50%) translateY(0); opacity: 1; pointer-events: auto; }

.iss-hud {
position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
width: 80%; height: 80%; pointer-events: none; z-index: 4;
display: none; font-family: "Consolas", "Monaco", monospace;
}

.iss-hud::before {
content: ''; position: absolute; top: 0; left: 0; right: 0; bottom: 0;
border: 1px solid rgba(0, 243, 255, 0.1);
background:
linear-gradient(90deg, rgba(0,243,255,0.1) 1px, transparent 1px) 50% 50% / 20% 100% no-repeat,
linear-gradient(rgba(0,243,255,0.1) 1px, transparent 1px) 50% 50% / 100% 20% no-repeat;
mask-image: radial-gradient(circle, transparent 30%, black 100%);
-webkit-mask-image: radial-gradient(circle, transparent 30%, black 100%);
}

.hud-corner {
position: absolute; width: 40px; height: 40px;
border: 2px solid var(--neon-cyan); opacity: 0.6;
box-shadow: 0 0 10px var(--neon-cyan);
}
.hc-tl { top: 0; left: 0; border-right: 0; border-bottom: 0; }
.hc-tr { top: 0; right: 0; border-left: 0; border-bottom: 0; }
.hc-bl { bottom: 0; left: 0; border-right: 0; border-top: 0; }
.hc-br { bottom: 0; right: 0; border-left: 0; border-top: 0; }

.hud-panel {
position: absolute; background: rgba(0, 10, 20, 0.6);
border: 1px solid var(--neon-cyan); padding: 10px 15px;
color: var(--neon-cyan); font-size: 12px; line-height: 1.6;
backdrop-filter: blur(4px); text-shadow: 0 0 5px var(--neon-cyan);
}
.hp-left { top: 50%; left: 20px; transform: translateY(-50%); text-align: left; border-left: 4px solid var(--neon-cyan); }
.hp-right { top: 50%; right: 20px; transform: translateY(-50%); text-align: right; border-right: 4px solid var(--neon-cyan); }
.hp-bottom { bottom: 40px; left: 50%; transform: translateX(-50%); text-align: center; border-bottom: 4px solid var(--neon-cyan); width: 300px; }

.hud-value { font-size: 18px; font-weight: 700; color: #fff; }
.hud-label { font-size: 10px; color: var(--text-muted); text-transform: uppercase; letter-spacing: 1px; }
.hud-warn { color: #ff3366; text-shadow: 0 0 8px #ff3366; }

.panel-toggle {
    position: absolute;
    width: 44px; height: 44px;
    background: var(--glass-bg);
    border: 1px solid var(--glass-border);
    backdrop-filter: blur(12px);
    -webkit-backdrop-filter: blur(12px);
    border-radius: 50%;
    display: none;
    justify-content: center;
    align-items: center;
    cursor: pointer;
    z-index: 100;
    color: var(--neon-cyan);
    font-size: 20px;
    box-shadow: 0 4px 15px rgba(0,0,0,0.5);
    transition: all 0.3s ease;
    user-select: none;
}
.panel-toggle:active { transform: scale(0.9); }

#ui-toggle { bottom: 20px; right: 20px; }
#moon-toggle { top: 20px; left: 20px; }


#sky-modal {
position: fixed;
top: 0; left: 0; right: 0; bottom: 0;
background: rgba(0, 0, 0, 0.95);
z-index: 1000;
display: none;
flex-direction: column;
align-items: center;
justify-content: center;
}

#sky-modal.visible {
display: flex;
}

#sky-container {
width: 95%;
height: 85%;
border-radius: 16px;
overflow: hidden;
border: 1px solid var(--glass-border);
box-shadow: 0 0 50px rgba(0, 243, 255, 0.2);
position: relative;
}

#sky-canvas {
width: 100%;
height: 100%;
}

#sky-close {
position: absolute;
top: 20px;
right: 20px;
width: 50px;
height: 50px;
background: rgba(255, 50, 50, 0.2);
border: 2px solid #ff5555;
border-radius: 50%;
color: #ff5555;
font-size: 24px;
cursor: pointer;
display: flex;
align-items: center;
justify-content: center;
transition: all 0.3s;
z-index: 1001;
}
#sky-close:hover {
background: #ff5555;
color: white;
box-shadow: 0 0 20px rgba(255, 85, 85, 0.5);
}

#sky-info {
    position: absolute;
    bottom: 20px;
    left: 50%;
    transform: translateX(-50%);
    background: rgba(12, 20, 40, 0.85); 
    backdrop-filter: blur(12px);
    border: 1px solid var(--glass-border);
    border-radius: 16px;
    padding: 0; 
    color: white;
    font-family: "Consolas", monospace;
    z-index: 1001;
    min-width: 320px;
    box-shadow: 0 10px 30px rgba(0,0,0,0.5);
}

.sky-info-container {
    display: flex;
    flex-direction: row;
    align-items: stretch;
}

.celestial-box {
    flex: 1;
    padding: 15px 20px;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    min-width: 140px;
}

.cb-divider {
    width: 1px;
    background: linear-gradient(to bottom, transparent, var(--glass-border), transparent);
}

.cb-header {
    font-size: 14px;
    font-weight: 700;
    margin-bottom: 8px;
    text-transform: uppercase;
    letter-spacing: 1.5px;
    color: var(--neon-cyan);
    text-shadow: 0 0 10px rgba(0,0,0,0.5);
}

.cb-coords {
    font-size: 12px;
    line-height: 1.6;
    color: #fff;
    white-space: nowrap;
    text-align: center;
    margin-bottom: 6px;
}

.cb-status {
    font-size: 11px;
    font-weight: 600;
}



#sky-info .title {
font-size: 14px;
color: var(--gold);
font-weight: 700;
margin-bottom: 10px;
letter-spacing: 2px;
text-transform: uppercase;
}

#sky-info .coords {
color: var(--neon-cyan);
margin-bottom: 5px;
}

#sky-location-info {
position: absolute;
top: 20px;
left: 20px;
background: var(--glass-bg);
backdrop-filter: blur(12px);
border: 1px solid var(--glass-border);
border-radius: 12px;
padding: 12px 18px;
color: white;
font-family: "Consolas", monospace;
font-size: 11px;
z-index: 1001;
}

#sky-location-info .loc-title {
color: var(--neon-cyan);
font-weight: 700;
margin-bottom: 5px;
text-transform: uppercase;
letter-spacing: 1px;
}

@media (max-width: 1024px) {
    .panel-toggle { display: flex; }
    
    #ui.collapsed { transform: translateX(calc(100% + 30px)); opacity: 0; pointer-events: none; }
    #moonInfo.collapsed { transform: translateX(calc(-100% - 30px)); opacity: 0; pointer-events: none; }
    
    #ui { width: 260px; right: 20px; bottom: 80px; }
    .ui-header { padding: 15px; }
    #time-now { font-size: 26px; }

    #moonInfo { width: 220px; left: 20px; top: 80px; padding: 15px; }
    #moonPhase { width: 100px; height: 100px; }

    #btn-clear-cache { bottom: 20px; left: 20px; width: 44px; height: 44px; }
    #ui-toggle { bottom: 20px; right: 20px; }
    #moon-toggle { top: 20px; left: 20px; }
    
    .iss-hud { width: 98%; height: 95%; top: 50%; transform: translate(-50%, -50%); }
    .iss-hud::before { display: none; }
    
    .hud-value { font-size: 13px; line-height: 1.2; }
    .hud-label { font-size: 8px; margin-bottom: 2px; }
    
    .hp-left, .hp-right {
        position: relative; top: auto; left: auto; right: auto; transform: none;
        display: inline-block; width: 38%; margin: 10px 1%;
        border: 1px solid var(--neon-cyan); border-radius: 8px;
        background: rgba(0, 10, 20, 0.4);
        text-align: center;
        padding: 6px;
    }
    
    .hp-bottom {
        width: 90%; bottom: 80px;
        background: rgba(0, 10, 20, 0.4);
        border: 1px solid var(--neon-cyan); border-radius: 8px;
        padding: 5px;
    }
    #hud-location { font-size: 11px !important; margin-bottom: 2px !important; min-height: auto !important; }
    
    #sky-info { 
        min-width: auto; 
        width: 90%;
        padding: 10px 15px;
    }
    #sky-location-info {
        font-size: 10px;
        padding: 8px 12px;
    }
}

.cb-times {
    margin-top: 8px;
    padding-top: 8px;
    border-top: 1px solid rgba(255, 255, 255, 0.1);
    font-size: 11px;
    color: var(--text-muted);
    font-family: "Consolas", monospace;
    letter-spacing: 0px;
    white-space: nowrap;
}
.cb-times span {
    color: #fff;
    font-weight: 600;
}

/* –°—Ç–∏–ª–∏ –¥–ª—è –ø–æ–∏—Å–∫–∞ –≤ –º–æ–¥–∞–ª—å–Ω–æ–º –æ–∫–Ω–µ */
#sky-search-wrapper {
    position: absolute;
    top: 20px;
    left: 50%;
    transform: translateX(-50%);
    width: 280px;
    z-index: 1002;
    display: flex;
    flex-direction: column;
    gap: 5px;
}

#city-input {
    width: 100%;
    padding: 12px 15px;
    background: rgba(12, 20, 40, 0.9);
    border: 1px solid var(--neon-cyan);
    border-radius: 25px;
    color: white;
    font-family: inherit;
    outline: none;
    box-shadow: 0 0 15px rgba(0, 243, 255, 0.2);
}

#search-results {
    background: #ffffff; /* –ë–µ–ª—ã–π —Ñ–æ–Ω */
    border-radius: 12px;
    overflow: hidden;
    margin-top: 8px;
    box-shadow: 0 10px 30px rgba(0,0,0,0.3);
    border: 1px solid #4169E1;
}

.search-item {
    padding: 12px 15px;
    cursor: pointer;
    font-size: 14px;
    color: #1a1a1a; /* –ü–æ—á—Ç–∏ —á–µ—Ä–Ω—ã–π —Ç–µ–∫—Å—Ç */
    background: #ffffff;
    border-bottom: 1px solid #f0f0f0;
    transition: all 0.2s ease;
    text-shadow: none;
    font-weight: 500;
}

.search-item:hover {
    background: #4169E1; /* Royal Blue */
    color: #ffffff;      /* –ë–µ–ª—ã–π —Ç–µ–∫—Å—Ç –ø—Ä–∏ –Ω–∞–≤–µ–¥–µ–Ω–∏–∏ */
}

/* –ù–∞—Å—Ç—Ä–æ–π–∫–∞ —Å–∫—Ä–æ–ª–ª–±–∞—Ä–∞ –¥–ª—è –≤—ã–ø–∞–¥–∞—é—â–µ–≥–æ —Å–ø–∏—Å–∫–∞ */
#search-results::-webkit-scrollbar {
    width: 8px;
}
#search-results::-webkit-scrollbar-track {
    background: #f1f1f1;
}
#search-results::-webkit-scrollbar-thumb {
    background: #4169E1;
    border-radius: 4px;
}

#city-input::placeholder {
    color: rgba(255,255,255,0.5);
}

/* –°–º–µ—â–µ–Ω–∏–µ —Å—É—â–µ—Å—Ç–≤—É—é—â–∏—Ö —ç–ª–µ–º–µ–Ω—Ç–æ–≤ –¥–ª—è –∫—Ä–∞—Å–æ—Ç—ã */
#sky-location-info { top: 80px; }

@media (max-width: 600px) {
    .sky-info-container { flex-direction: column; }
    .cb-divider { width: 100%; height: 1px; background: linear-gradient(to right, transparent, var(--glass-border), transparent); }
    #sky-info { width: 90%; min-width: auto; bottom: 60px; }
}
</style>

</head>
<body>
<div id="loading">–ó–∞–≥—Ä—É–∑–∫–∞...</div>
<div class="iss-hint" id="issHint">–î–≤–æ–π–Ω–æ–π –∫–ª–∏–∫: –°—Ç—ã–∫–æ–≤–∫–∞</div>

<div id="ui-toggle" class="panel-toggle">‚öôÔ∏è</div>
<div id="moon-toggle" class="panel-toggle" style="display:none;">üåì</div>

<div id="moonInfo" class="panel-glass">
<div class="moonTitle">–õ—É–Ω–∞</div>
<div id="moonPhase"><canvas id="moonCanvas" width="140" height="140"></canvas></div>
<div id="moonData">–û–∂–∏–¥–∞–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö...</div>
<button id="btn-sky-view">
    <span>üåå</span>
    <span>–õ—É–Ω–∞ –Ω–∞ –Ω–µ–±–µ</span>
</button>
</div>

<div id="ui" class="panel-glass">
<div class="ui-header">
<div id="time-now">00:00:00</div>
<div id="date-now">DD.MM.YYYY</div>
</div>

<div class="ui-controls">
  <div class="row">
    <span>–°–æ–ª–Ω—Ü–µ</span>
    <label class="switch"><input type="checkbox" id="chk-sun" /><span class="slider"></span></label>
  </div>
  <div class="row">
    <span>–õ—É–Ω–∞</span>
    <label class="switch"><input type="checkbox" id="chk-moon" /><span class="slider"></span></label>
  </div>
  <div class="row">
    <span>–ì–∞–ª–∞–∫—Ç–∏–∫–∞</span>
    <label class="switch"><input type="checkbox" id="chk-galaxy" /><span class="slider"></span></label>
  </div>
  <div class="row">
    <span>–û–±–ª–∞–∫–∞</span>
    <label class="switch"><input type="checkbox" id="chk-clouds" /><span class="slider"></span></label>
  </div>
  <div class="row">
    <span>–ú–ö–°</span>
    <label class="switch"><input type="checkbox" id="chk-iss" /><span class="slider"></span></label>
  </div>
</div>

<div id="data">–ú–ö–° –≤—ã–∫–ª—é—á–µ–Ω–∞</div>
</div>

<div id="iss-hud" class="iss-hud">
<div class="hud-corner hc-tl"></div>
<div class="hud-corner hc-tr"></div>
<div class="hud-corner hc-bl"></div>
<div class="hud-corner hc-br"></div>

<div class="hud-panel hp-left">
  <div class="hud-label">–ö–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã</div>
  <div id="hud-lat" class="hud-value">LAT 00.00</div>
  <div id="hud-lon" class="hud-value">LON 00.00</div>
  <br>
  <div class="hud-label">–í—ã—Å–æ—Ç–∞</div>
  <div id="hud-alt" class="hud-value">420 KM</div>
</div>

<div class="hud-panel hp-right">
  <div class="hud-label">–ë–∞—Ç–∞—Ä–µ–∏</div>
  <div id="hud-solar" class="hud-value">100%</div>
  <br>
  <div class="hud-label">–°–∫–æ—Ä–æ—Å—Ç—å</div>
  <div id="hud-vel" class="hud-value">27600</div>
</div>

<div class="hud-panel hp-bottom">
    <div id="hud-location" class="hud-value" style="font-size: 14px; color: #ffd700; margin-bottom: 8px; text-transform: uppercase; letter-spacing: 1px; min-height: 20px;">
        –°–∫–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ...
    </div>
    <div id="hud-status" style="font-size:10px; margin-top:5px;">STATUS OK</div>
</div>
</div>

<button id="btn-clear-cache" title="–û—á–∏—Å—Ç–∏—Ç—å –∫—ç—à —Ç–µ–∫—Å—Ç—É—Ä">
<svg viewBox="0 0 24 24" width="20" height="20">
<ellipse cx="12" cy="5" rx="9" ry="3" fill="none" stroke="currentColor" stroke-width="2"></ellipse>
<path d="M21 12c0 1.66-4 3-9 3s-9-1.34-9-3" fill="none" stroke="currentColor" stroke-width="2"></path>
<path d="M3 5v14c0 1.66 4 3 9 3 1.2 0 2.33-.08 3.39-.23" fill="none" stroke="currentColor" stroke-width="2"></path>
<line x1="21" y1="21" x2="17" y2="17" stroke="currentColor" stroke-width="2.5" stroke-linecap="round"></line>
<line x1="17" y1="21" x2="21" y2="17" stroke="currentColor" stroke-width="2.5" stroke-linecap="round"></line>
</svg>
</button>


<button id="btn-exit-iss">–û—Ç—Å—Ç—ã–∫–æ–≤–∞—Ç—å—Å—è</button>
<button id="btn-exit-moon">–í–µ—Ä–Ω—É—Ç—å—Å—è –∫ –ó–µ–º–ª–µ</button>


<div id="sky-modal">
       <div id="sky-search-wrapper">
 <input type="text" id="city-input" placeholder="–í–≤–µ–¥–∏—Ç–µ –≥–æ—Ä–æ–¥ –∏ –Ω–∞–∂–º–∏—Ç–µ Enter..." autocomplete="off">
        <div id="search-results"></div>
    </div>
    <div id="sky-container">
        <canvas id="sky-canvas"></canvas>
    </div>
    <button id="sky-close">‚úï</button>
    <div id="sky-location-info">
        <div class="loc-title">üìç –í–∞—à–µ –º–µ—Å—Ç–æ–ø–æ–ª–æ–∂–µ–Ω–∏–µ</div>
        <div id="sky-user-coords">–û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ...</div>
          <div id="sky-local-time" style="margin-top:8px; color:#ffd700; font-weight:bold; font-size:14px;">
        –ú–µ—Å—Ç–Ω–æ–µ –≤—Ä–µ–º—è: --:--:--
    </div>
    </div>
<div id="sky-info">
    <div class="sky-info-container">
        
        <!-- –°–µ–∫—Ü–∏—è –õ—É–Ω—ã -->
        <div class="celestial-box">
            <div class="cb-header">üåô –õ—É–Ω–∞</div>
            <div id="sky-moon-data" class="cb-coords">–†–∞—Å—á—ë—Ç...</div>
            <div id="sky-moon-status" class="cb-status">‚Äî</div>
            <!-- –ù–æ–≤–æ–µ –ø–æ–ª–µ –¥–ª—è –≤—Ä–µ–º–µ–Ω–∏ -->
            <div id="sky-moon-times" class="cb-times">
                ‚Üë --:-- &nbsp; ‚Üì --:--
            </div>
        </div>
        
        <div class="cb-divider"></div>
        
        <!-- –°–µ–∫—Ü–∏—è –°–æ–ª–Ω—Ü–∞ -->
        <div class="celestial-box">
            <div class="cb-header" style="color: #ffdd44;">‚òÄÔ∏è –°–æ–ª–Ω—Ü–µ</div>
            <div id="sky-sun-data" class="cb-coords">–†–∞—Å—á—ë—Ç...</div>
            <div id="sky-sun-status" class="cb-status">‚Äî</div>
            <!-- –ù–æ–≤–æ–µ –ø–æ–ª–µ –¥–ª—è –≤—Ä–µ–º–µ–Ω–∏ -->
            <div id="sky-sun-times" class="cb-times">
                ‚Üë --:-- &nbsp; ‚Üì --:--
            </div>
        </div>
    </div>
</div>

<script type="importmap">
{
"imports": {
"three": "https://unpkg.com/three@0.160.0/build/three.module.js",
"three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
}
}
</script>

<script type="module">
import * as THREE from "three";
import { OrbitControls } from "three/addons/controls/OrbitControls.js";
import { Lensflare, LensflareElement } from 'three/addons/objects/Lensflare.js';

let lastGeoCheckTime = 0;
let userMarker = null;
let userLocation = null; 

const DB_NAME = 'EarthISS_DB';
const STORE_NAME = 'textures';

const dbPromise = new Promise((resolve, reject) => {
const request = indexedDB.open(DB_NAME, 1);
request.onupgradeneeded = (e) => { e.target.result.createObjectStore(STORE_NAME); };
request.onsuccess = (e) => resolve(e.target.result);
request.onerror = (e) => reject(e);
});

const internalLoader = new THREE.TextureLoader();

function loadTextureWithCache(url) {
const tex = new THREE.Texture();
const image = new Image();
image.crossOrigin = "Anonymous";
tex.image = image;
image.onload = () => { tex.needsUpdate = true; };

dbPromise.then(db => {
const tx = db.transaction(STORE_NAME, 'readonly');
const store = tx.objectStore(STORE_NAME);
const request = store.get(url);
request.onsuccess = () => {
if (request.result) {
image.src = URL.createObjectURL(request.result);
} else {
fetch(url).then(res => res.blob()).then(blob => {
const txWrite = db.transaction(STORE_NAME, 'readwrite');
txWrite.objectStore(STORE_NAME).put(blob, url);
image.src = URL.createObjectURL(blob);
}).catch(() => {
internalLoader.load(url, (t) => { tex.image = t.image; tex.needsUpdate = true; });
});
}
};
}).catch(() => {
internalLoader.load(url, (t) => { tex.image = t.image; tex.needsUpdate = true; });
});
return tex;
}

const el = {
    
    loading: document.getElementById("loading"),
    data: document.getElementById("data"),
    ui: document.getElementById("ui"),
    timeNow: document.getElementById('time-now'),
    dateNow: document.getElementById('date-now'),
    
    
    chkSun: document.getElementById("chk-sun"),
    chkISS: document.getElementById("chk-iss"),
    chkMoon: document.getElementById("chk-moon"),
    chkClouds: document.getElementById("chk-clouds"),
    chkGalaxy: document.getElementById("chk-galaxy"),
    
    
    moonInfo: document.getElementById("moonInfo"),
    moonData: document.getElementById("moonData"),
    moonCanvas: document.getElementById("moonCanvas"),
    moonToggle: document.getElementById("moon-toggle"),
    
    
    btnExit: document.getElementById("btn-exit-iss"),
    btnExitMoon: document.getElementById("btn-exit-moon"),
    btnClear: document.getElementById("btn-clear-cache"),
    btnSkyView: document.getElementById("btn-sky-view"),
    uiToggle: document.getElementById("ui-toggle"),
    
    
    issHint: document.getElementById("issHint"),
    issHud: document.getElementById("iss-hud"),
    hudLat: document.getElementById("hud-lat"),
    hudLon: document.getElementById("hud-lon"),
    hudAlt: document.getElementById("hud-alt"),
    hudSolar: document.getElementById("hud-solar"),
    hudVel: document.getElementById("hud-vel"),
    hudStatus: document.getElementById("hud-status"),
    hudLocation: document.getElementById("hud-location"),
    
    
    skyModal: document.getElementById("sky-modal"),
    skyClose: document.getElementById("sky-close"),
    skyCanvas: document.getElementById("sky-canvas"),
    skyUserCoords: document.getElementById("sky-user-coords"),
    
    


    skyMoonData: document.getElementById("sky-moon-data"),
    skyMoonStatus: document.getElementById("sky-moon-status"),
    skySunData: document.getElementById("sky-sun-data"),
    skySunStatus: document.getElementById("sky-sun-status"),
     skySunTimes: document.getElementById("sky-sun-times"),
    skyMoonTimes: document.getElementById("sky-moon-times")
    
    
};


el.cityInput = document.getElementById('city-input');
el.searchResults = document.getElementById('search-results');


let skyScene, skyCamera, skyRenderer, skyControls, skyAnimationId;
let skyMoonMesh, skySunMesh, skyInitialized = false;
let skySunLight; 
let targetLocationOffset = null;

function initSkyView() {
    if (skyInitialized) return;
    
    const container = document.getElementById('sky-container');
    const width = container.clientWidth;
    const height = container.clientHeight;
    
    skyScene = new THREE.Scene();
    skyScene.background = new THREE.Color(0x000510);
    
    skyCamera = new THREE.PerspectiveCamera(60, width / height, 0.1, 1000);
    skyCamera.position.set(0, 0, 0.1); 
    
    skyRenderer = new THREE.WebGLRenderer({ canvas: el.skyCanvas, antialias: true });
    skyRenderer.setSize(width, height);
    skyRenderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    
    skyControls = new OrbitControls(skyCamera, skyRenderer.domElement);
    skyControls.enableZoom = true;
    skyControls.enablePan = false;
    skyControls.rotateSpeed = 0.5;
    skyControls.minDistance = 0.1;
    skyControls.maxDistance = 0.1; 
    skyControls.target.set(0, 0, -1); 

    skySunLight = new THREE.DirectionalLight(0xffffff, 2.5);
    skyScene.add(skySunLight);
    skyScene.add(new THREE.AmbientLight(0xffffff, 0.3)); 

    // –ó–≤–µ–∑–¥—ã
    const starCount = 3000;
    const starsGeo = new THREE.BufferGeometry();
    const starPos = new Float32Array(starCount * 3);
    for (let i = 0; i < starCount; i++) {
        const theta = Math.random() * Math.PI * 2;
        const phi = Math.acos(2 * Math.random() - 1);
        const r = 45;
        starPos[i * 3] = -r * Math.sin(phi) * Math.cos(theta);
        starPos[i * 3 + 1] = r * Math.sin(phi) * Math.sin(theta);
        starPos[i * 3 + 2] = r * Math.cos(phi);
    }
    starsGeo.setAttribute('position', new THREE.BufferAttribute(starPos, 3));
    skyScene.add(new THREE.Points(starsGeo, new THREE.PointsMaterial({ color: 0xffffff, size: 0.15, transparent: true, opacity: 0.8 })));

    // –°–û–õ–ù–¶–ï
    const sunGroup = new THREE.Group();
    const sunCore = new THREE.Mesh(new THREE.SphereGeometry(2.2, 32, 32), new THREE.MeshBasicMaterial({ color: 0xffffff }));
    sunGroup.add(sunCore);
    for(let i=1; i<=4; i++) {
        const glow = new THREE.Mesh(
            new THREE.SphereGeometry(2.2 + (i*1.8), 32, 32),
            new THREE.MeshBasicMaterial({ color: 0xffdd44, transparent: true, opacity: 0.5 / i, side: THREE.BackSide })
        );
        sunGroup.add(glow);
    }
    skySunMesh = sunGroup;
    skyScene.add(skySunMesh);

    // –õ–£–ù–ê
    const moonGeo = new THREE.SphereGeometry(2.1, 32, 32);
    const moonMat = new THREE.MeshPhongMaterial({ 
        map: loadTextureWithCache('./textures/moon-color.jpg'),
        bumpMap: loadTextureWithCache("./textures/moon-bump.jpg"),
        bumpScale: 0.05,
        shininess: 0
    });
    skyMoonMesh = new THREE.Mesh(moonGeo, moonMat);
    skyScene.add(skyMoonMesh);

    // –°–ï–¢–ö–ê
    const gridMat = new THREE.LineBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.4, depthWrite: false });
    const rGrid = 42;
    for (let az = 0; az < 360; az += 30) {
        const points = [];
        const azRad = az * Math.PI / 180;
        for (let alt = 0; alt <= 90; alt += 5) {
            const altRad = alt * Math.PI / 180;
            points.push(new THREE.Vector3(-rGrid * Math.cos(altRad) * Math.sin(azRad), rGrid * Math.sin(altRad), rGrid * Math.cos(altRad) * Math.cos(azRad)));
        }
        skyScene.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints(points), gridMat));
    }
    for (let alt = 0; alt <= 90; alt += 15) {
        const points = [];
        const altRad = alt * Math.PI / 180;
        for (let az = 0; az <= 360; az += 5) {
            const azRad = az * Math.PI / 180;
            points.push(new THREE.Vector3(-rGrid * Math.cos(altRad) * Math.sin(azRad), rGrid * Math.sin(altRad), rGrid * Math.cos(altRad) * Math.cos(azRad)));
        }
        skyScene.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints(points), gridMat));
    }

    // –ì–û–†–ò–ó–û–ù–¢
    const horizonPoints = [];
    for (let az = 0; az <= 360; az += 2) {
        const azRad = az * Math.PI / 180;
        horizonPoints.push(new THREE.Vector3(-rGrid * Math.sin(azRad), 0, rGrid * Math.cos(azRad)));
    }
    skyScene.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints(horizonPoints), new THREE.LineBasicMaterial({ color: 0x00f3ff, transparent: true, opacity: 0.8 })));

    // –°–¢–û–†–û–ù–´ –°–í–ï–¢–ê
    const directions = [
        { name: '–°–ï–í–ï–†', az: 0, color: '#ff3333' },
        { name: '–°–í', az: 45, color: '#ffffff' },
        { name: '–í–û–°–¢–û–ö', az: 90, color: '#ffee00' },
        { name: '–Æ–í', az: 135, color: '#ffffff' },
        { name: '–Æ–ì', az: 180, color: '#00ff44' },
        { name: '–Æ–ó', az: 225, color: '#ffffff' },
        { name: '–ó–ê–ü–ê–î', az: 270, color: '#00ffff' },
        { name: '–°–ó', az: 315, color: '#ffffff' }
    ];
    
    directions.forEach(dir => {
        const azRad = dir.az * Math.PI / 180;
        const rLabel = 43; // –†–∞—Å—Å—Ç–æ—è–Ω–∏–µ –æ—Ç —Ü–µ–Ω—Ç—Ä–∞
        
        const canvas = document.createElement('canvas');
        canvas.width = 256; canvas.height = 128;
        const ctx = canvas.getContext('2d');
        
        // –ù–∞—Å—Ç—Ä–æ–π–∫–∞ —à—Ä–∏—Ñ—Ç–∞: –¥–ª—è –¥–ª–∏–Ω–Ω—ã—Ö —Å–ª–æ–≤ —á—É—Ç—å –º–µ–Ω—å—à–µ, –¥–ª—è –∫–æ—Ä–æ—Ç–∫–∏—Ö ‚Äî –±–æ–ª—å—à–µ
        const fontSize = dir.name.length > 2 ? '48px' : '64px';
        ctx.font = `bold ${fontSize} Arial`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        
        // 1. –ü–ª–æ—Ç–Ω–∞—è —á–µ—Ä–Ω–∞—è –æ–±–≤–æ–¥–∫–∞ (—á—Ç–æ–±—ã —Ç–µ–∫—Å—Ç –Ω–µ –ø—Ä–æ–ø–∞–¥–∞–ª –Ω–∞ —Å–≤–µ—Ç–ª–æ–º –Ω–µ–±–µ)
        ctx.strokeStyle = 'black';
        ctx.lineWidth = 10;
        ctx.strokeText(dir.name, 128, 64);
        
        // 2. –í–Ω–µ—à–Ω–µ–µ —Å–≤–µ—á–µ–Ω–∏–µ (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ, –¥–ª—è –º—è–≥–∫–æ—Å—Ç–∏)
        ctx.shadowColor = 'black';
        ctx.shadowBlur = 10;
        
        // 3. –û—Å–Ω–æ–≤–Ω–æ–π —Ü–≤–µ—Ç —Ç–µ–∫—Å—Ç–∞
        ctx.fillStyle = dir.color;
        ctx.fillText(dir.name, 128, 64);
        
        const texture = new THREE.CanvasTexture(canvas);
        const spriteMat = new THREE.SpriteMaterial({ 
            map: texture, 
            transparent: true,
            depthTest: false, // –¢–µ–∫—Å—Ç –≤—Å–µ–≥–¥–∞ –ø–æ–≤–µ—Ä—Ö —Å–µ—Ç–∫–∏
            renderOrder: 10   // –ü—Ä–∏–æ—Ä–∏—Ç–µ—Ç –æ—Ç—Ä–∏—Å–æ–≤–∫–∏
        });
        
        const sprite = new THREE.Sprite(spriteMat);
        
        // –†–∞—Å–ø–æ–ª–æ–∂–µ–Ω–∏–µ —Å—Ç—Ä–æ–≥–æ –ø–æ –∞–∑–∏–º—É—Ç—É –Ω–∞ –ª–∏–Ω–∏–∏ –≥–æ—Ä–∏–∑–æ–Ω—Ç–∞ (y = 1.2)
        sprite.position.set(
            -rLabel * Math.sin(azRad), 
            1.2, 
            rLabel * Math.cos(azRad)
        );
        
        // –†–∞–∑–º–µ—Ä —Å–ø—Ä–∞–π—Ç–∞ (—á—É—Ç—å —à–∏—Ä–µ –¥–ª—è –¥–ª–∏–Ω–Ω—ã—Ö —Å–ª–æ–≤)
        const scaleW = dir.name.length > 2 ? 7 : 5;
        sprite.scale.set(scaleW, 3.5, 1);
        
        skyScene.add(sprite);
    });
    skyInitialized = true;
}



function updateSkySun(lat, lon) {
    if (!skySunMesh) return;
    
    const now = new Date();
    const sunPos = getSunPosition(lat, lon, now);
    
    const azRad = sunPos.azimuth * Math.PI / 180;
    const altRad = sunPos.altitude * Math.PI / 180;
    const r = 35;
    
    const x = -r * Math.cos(altRad) * Math.sin(azRad);
    const y = r * Math.sin(altRad);
    const z = r * Math.cos(altRad) * Math.cos(azRad);
    
    skySunMesh.position.set(x, y, z);
    if (skySunLight) skySunLight.position.set(x, y, z);

    // –¶–í–ï–¢ –ù–ï–ë–ê
    let finalColor;
    if (sunPos.altitude > 0) {
        const intensity = Math.min(sunPos.altitude / 45, 1);
        finalColor = new THREE.Color(0x4488ff).lerp(new THREE.Color(0x87CEEB), intensity);
    } else if (sunPos.altitude > -6) {
        finalColor = new THREE.Color(0x112244);
    } else {
        finalColor = new THREE.Color(0x000510);
    }

    // –ü—Ä–∏–º–µ–Ω—è–µ–º —Ü–≤–µ—Ç –∫ —Å—Ü–µ–Ω–µ –∏ –ö –§–û–ù–£ –ú–û–î–ê–õ–¨–ù–û–ì–û –û–ö–ù–ê
    skyScene.background.copy(finalColor);
    el.skyModal.style.backgroundColor = finalColor.getStyle(); // –£–±–∏—Ä–∞–µ—Ç —Ç–µ–º–Ω—ã–µ –∫—Ä–∞—è

    // –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –≤–∏–¥–∏–º–æ—Å—Ç–∏ —Å–µ—Ç–∫–∏: –µ—Å–ª–∏ –Ω–µ–±–æ —Å–≤–µ—Ç–ª–æ–µ, –¥–µ–ª–∞–µ–º –ª–∏–Ω–∏–∏ —Ç–µ–º–Ω–µ–µ –¥–ª—è –∫–æ–Ω—Ç—Ä–∞—Å—Ç–∞
    skyScene.traverse((object) => {
        if (object.isLine && object.material) {
            if (sunPos.altitude > 0) {
                object.material.color.setHex(0x004466); // –¢–µ–º–Ω—ã–µ –ª–∏–Ω–∏–∏ –¥–Ω–µ–º
                object.material.opacity = 0.3;
            } else {
                object.material.color.setHex(0xffffff); // –ë–µ–ª—ã–µ –ª–∏–Ω–∏–∏ –Ω–æ—á—å—é
                object.material.opacity = 0.4;
            }
        }
    });

    // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ UI
    let solarTimeString = "--:--:--";
    if (sunPos.solarTimeHours !== undefined) {
        const h = Math.floor(sunPos.solarTimeHours);
        const m = Math.floor((sunPos.solarTimeHours * 60) % 60);
        const s = Math.floor((sunPos.solarTimeHours * 3600) % 60);
        solarTimeString = `${h.toString().padStart(2, '0')}:${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}`;
    }
    el.skySunData.innerHTML = `–ê–∑–∏–º—É—Ç: <span style="color:#ffdd44">${sunPos.azimuth.toFixed(1)}¬∞</span><br>–í—ã—Å–æ—Ç–∞: <span style="color:#ffdd44">${sunPos.altitude.toFixed(1)}¬∞</span>`;
    let statusText = sunPos.altitude > 0 ? `<span style="color: #ffdd44;">‚óè –î–µ–Ω—å</span>` : (sunPos.altitude > -6 ? `<span style="color: #ffaa66;">‚óè –°—É–º–µ—Ä–∫–∏</span>` : `<span style="color: #6688aa;">‚óè –ù–æ—á—å</span>`);
el.skySunStatus.innerHTML = `
    ${statusText}<br>
    <span style="color: #fff; font-size: 10px; opacity: 0.6; text-transform: uppercase;">–°–æ–ª–Ω–µ—á–Ω–æ–µ –≤—Ä–µ–º—è:</span><br>
    <span style="color: #ffd700; font-family: monospace; font-size: 14px;">${solarTimeString}</span>
`;
}


function updateSkyMoon(lat, lon) {
    if (!skyMoonMesh) return;
    
    const now = new Date();
    const moonPos = getMoonPosition(lat, lon, now);
    
    const azRad = moonPos.azimuth * Math.PI / 180;
    const altRad = moonPos.altitude * Math.PI / 180;
    const r = 35;
    
    skyMoonMesh.position.set(
        -r * Math.cos(altRad) * Math.sin(azRad),
        r * Math.sin(altRad),
        r * Math.cos(altRad) * Math.cos(azRad)
    );
    
    // –ü–æ–≤–æ—Ä–∞—á–∏–≤–∞–µ–º –õ—É–Ω—É ¬´–ª–∏—Ü–æ–º¬ª –∫ –ó–µ–º–ª–µ (—Ü–µ–Ω—Ç—Ä—É), —á—Ç–æ–±—ã —Ç–µ–∫—Å—Ç—É—Ä–∞ –±—ã–ª–∞ –≤–∏–¥–Ω–∞ –ø—Ä–∞–≤–∏–ª—å–Ω–æ
    skyMoonMesh.lookAt(0, 0, 0);

    el.skyMoonData.innerHTML = 
        `–ê–∑–∏–º—É—Ç: <span style="color:#00f3ff">${moonPos.azimuth.toFixed(1)}¬∞</span><br>` +
        `–í—ã—Å–æ—Ç–∞: <span style="color:#00f3ff">${moonPos.altitude.toFixed(1)}¬∞</span>`;
    
    const visibility = moonPos.altitude > 0 ? 
        `<span style="color: #00ff88;">‚óè –í–∏–¥–Ω–∞</span>` : 
        `<span style="color: #ff5555;">‚óè –°–∫—Ä—ã—Ç–∞</span>`;
    el.skyMoonStatus.innerHTML = visibility;
}


function getSunPosition(lat, lon, date) {
    const DEG = Math.PI / 180;
    const RAD = 180 / Math.PI;
    
    const jd = getJulianDate(date);
    const n = jd - 2451545.0;
    
    const L = (280.466 + 0.9856474 * n) % 360;
    const g = (357.528 + 0.9856003 * n) % 360;
    const gRad = g * DEG;
    
    const lambda = L + 1.915 * Math.sin(gRad) + 0.020 * Math.sin(2 * gRad);
    const lambdaRad = lambda * DEG;
    
    const epsilon = 23.439 * DEG;
    
    const sinDec = Math.sin(epsilon) * Math.sin(lambdaRad);
    const dec = Math.asin(sinDec);
    
    const y = Math.cos(epsilon) * Math.sin(lambdaRad);
    const x = Math.cos(lambdaRad);
    let ra = Math.atan2(y, x);
    if (ra < 0) ra += 2 * Math.PI;
    
    const gmst = getGMST(jd);
    const lst = gmst + lon * DEG;
    
    let ha = lst - ra;
    
    // –†–∞—Å—á–µ—Ç –∏—Å—Ç–∏–Ω–Ω–æ–≥–æ —Å–æ–ª–Ω–µ—á–Ω–æ–≥–æ –≤—Ä–µ–º–µ–Ω–∏ (Apparent Solar Time)
    let solarTimeHours = (ha * RAD + 180) / 15; 
    solarTimeHours = (solarTimeHours + 24) % 24;

    const latRad = lat * DEG;
    const sinAlt = Math.sin(dec) * Math.sin(latRad) + 
                   Math.cos(dec) * Math.cos(latRad) * Math.cos(ha);
    const altitude = Math.asin(sinAlt) * RAD;
    
    const cosAz = (Math.sin(dec) - Math.sin(altitude * DEG) * Math.sin(latRad)) / 
                  (Math.cos(altitude * DEG) * Math.cos(latRad));
    let azimuth = Math.acos(Math.max(-1, Math.min(1, cosAz))) * RAD;
    
    if (Math.sin(ha) > 0) {
        azimuth = 360 - azimuth;
    }
    
    return { azimuth, altitude, solarTimeHours };
}

function getMoonPosition(lat, lon, date) {
    
    const DEG = Math.PI / 180;
    const RAD = 180 / Math.PI;
    
    const jd = getJulianDate(date);
    const T = (jd - 2451545.0) / 36525.0;
    
    
    const L0 = (218.3164477 + 481267.88123421 * T - 0.0015786 * T * T) % 360;
    const M = (134.9633964 + 477198.8675055 * T + 0.0087414 * T * T) % 360;
    const F = (93.2720950 + 483202.0175233 * T - 0.0036539 * T * T) % 360;
    const D = (297.8501921 + 445267.1114034 * T - 0.0018819 * T * T) % 360;
    const Omega = (125.0445479 - 1934.1362891 * T + 0.0020754 * T * T) % 360;
    
    
    const Mrad = M * DEG;
    const Drad = D * DEG;
    const Frad = F * DEG;
    
    
    let lambda = L0 + 6.289 * Math.sin(Mrad);
    lambda += 1.274 * Math.sin(2 * Drad - Mrad);
    lambda += 0.658 * Math.sin(2 * Drad);
    lambda += 0.214 * Math.sin(2 * Mrad);
    
    
    let beta = 5.128 * Math.sin(Frad);
    beta += 0.281 * Math.sin(Mrad + Frad);
    
    
    const epsilon = 23.4393 * DEG; 
    const lambdaRad = lambda * DEG;
    const betaRad = beta * DEG;
    
    const sinDec = Math.sin(betaRad) * Math.cos(epsilon) + 
                   Math.cos(betaRad) * Math.sin(epsilon) * Math.sin(lambdaRad);
    const dec = Math.asin(sinDec);
    
    const y = Math.sin(lambdaRad) * Math.cos(epsilon) - Math.tan(betaRad) * Math.sin(epsilon);
    const x = Math.cos(lambdaRad);
    let ra = Math.atan2(y, x);
    if (ra < 0) ra += 2 * Math.PI;
    
    
    const gmst = getGMST(jd);
    const lst = gmst + lon * DEG; 
    
    
    let ha = lst - ra;
    
    
    const latRad = lat * DEG;
    
    const sinAlt = Math.sin(dec) * Math.sin(latRad) + 
                   Math.cos(dec) * Math.cos(latRad) * Math.cos(ha);
    const altitude = Math.asin(sinAlt) * RAD;
    
    const cosAz = (Math.sin(dec) - Math.sin(altitude * DEG) * Math.sin(latRad)) / 
                  (Math.cos(altitude * DEG) * Math.cos(latRad));
    let azimuth = Math.acos(Math.max(-1, Math.min(1, cosAz))) * RAD;
    
    if (Math.sin(ha) > 0) {
        azimuth = 360 - azimuth;
    }
    
    return { azimuth, altitude };
}

function animateSky() {
    if (!el.skyModal.classList.contains('visible')) {
        skyAnimationId = null;
        return;
    }
    
    skyAnimationId = requestAnimationFrame(animateSky);
    
    const timeDisplay = document.getElementById('sky-local-time');
    
    if (targetLocationOffset !== null) {
        // 1. –ü–æ–ª—É—á–∞–µ–º —Ç–µ–∫—É—â–µ–µ –≤—Ä–µ–º—è UTC
        const now = new Date();
        const utcTimestamp = now.getTime() + (now.getTimezoneOffset() * 60000);
        
        // 2. –î–æ–±–∞–≤–ª—è–µ–º –≥–µ–æ–≥—Ä–∞—Ñ–∏—á–µ—Å–∫–æ–µ —Å–º–µ—â–µ–Ω–∏–µ
        const localTimestamp = utcTimestamp + (targetLocationOffset * 3600000);
        const localDate = new Date(localTimestamp);
        
        // 3. –§–æ—Ä–º–∞—Ç–∏—Ä—É–µ–º –≤—ã–≤–æ–¥
        const timeStr = localDate.toLocaleTimeString('ru-RU', { hour12: false });
        const offsetStr = targetLocationOffset >= 0 ? `+${targetLocationOffset}` : targetLocationOffset;
        
        // –û–ë–ù–û–í–õ–ï–ù–ù–ê–Ø –ü–û–î–ü–ò–°–¨
        timeDisplay.innerText = `–ú–µ—Å—Ç–Ω–æ–µ –≤—Ä–µ–º—è (–≥–µ–æ–≥—Ä.): ${timeStr} (UTC${offsetStr})`;
    } else {
        timeDisplay.innerText = `–ú–µ—Å—Ç–Ω–æ–µ –≤—Ä–µ–º—è: --:--:--`;
    }

    skyControls.update();
    skyRenderer.render(skyScene, skyCamera);
}

async function fetchLocationName(lat, lon) {
    try {
        const url = `https://nominatim.openstreetmap.org/reverse?format=json&lat=${lat}&lon=${lon}&zoom=10&accept-language=ru`;
        const response = await fetch(url);
        if (!response.ok) return "–û–∫–µ–∞–Ω / –û—Ç–∫—Ä—ã—Ç–æ–µ –ø—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–æ";
        const data = await response.json();
        if (data.error) return "–û–∫–µ–∞–Ω";
        
        const addr = data.address;
        const city = addr.city || addr.town || addr.village || addr.municipality;
        const state = addr.state || addr.region;
        const country = addr.country;
        let locString = country || "";
        if (state && state !== country) locString += `, ${state}`;
        if (city && city !== state) locString = `${city}, ${locString}`;
        return locString || "–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è —Ç–µ—Ä—Ä–∏—Ç–æ—Ä–∏—è";
    } catch (e) {
        return "–î–∞–Ω–Ω—ã–µ –æ –º–µ—Å—Ç–µ –Ω–µ–¥–æ—Å—Ç—É–ø–Ω—ã";
    }
}

async function openSkyView(specificCoords = null) {
    if (specificCoords && specificCoords.lat !== undefined) {
        showSkyView(specificCoords.lat, specificCoords.lon, specificCoords.name);
    } else {
        el.loading.innerText = "–û–ü–†–ï–î–ï–õ–ï–ù–ò–ï GPS...";
        el.loading.style.display = "block";
        
        if (!navigator.geolocation) {
            el.loading.style.display = "none";
            alert("–ì–µ–æ–ª–æ–∫–∞—Ü–∏—è –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç—Å—è");
            return;
        }
        
        navigator.geolocation.getCurrentPosition(
            async (position) => {
                const lat = position.coords.latitude;
                const lon = position.coords.longitude;
                
                el.loading.innerText = "–ü–û–õ–£–ß–ï–ù–ò–ï –ê–î–†–ï–°–ê...";
                const resolvedName = await fetchLocationName(lat, lon);
                
                el.loading.style.display = "none";
                // –ò—Å–ø–æ–ª—å–∑—É–µ–º –∫—Ä–∞—Å–∏–≤–æ–µ –¥–ª–∏–Ω–Ω–æ–µ —Ç–∏—Ä–µ –∏ Neon Cyan –æ—Ñ–æ—Ä–º–ª–µ–Ω–∏–µ –≤—ã—à–µ
               showSkyView(lat, lon, `üõ∞Ô∏è GPS ‚Äî ${resolvedName}`);
            },
            (error) => {
                el.loading.style.display = "none";
                alert("–û—à–∏–±–∫–∞ GPS. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –ø–æ–∏—Å–∫ –≥–æ—Ä–æ–¥–∞.");
            },
            { enableHighAccuracy: true, timeout: 10000 }
        );
    }
}

function getSunAltitudeForEvents(lat, lon, date) {
    const DEG = Math.PI / 180;
    const jd = getJulianDate(date); // –ò—Å–ø–æ–ª—å–∑—É–µ–º –≤–∞—à—É —Å—É—â–µ—Å—Ç–≤—É—é—â—É—é —Ñ—É–Ω–∫—Ü–∏—é getJulianDate
    const n = jd - 2451545.0;
    const L = (280.466 + 0.9856474 * n) % 360;
    const g = (357.528 + 0.9856003 * n) % 360 * DEG;
    const lambda = (L + 1.915 * Math.sin(g) + 0.020 * Math.sin(2 * g)) * DEG;
    const epsilon = 23.439 * DEG;
    const dec = Math.asin(Math.sin(epsilon) * Math.sin(lambda));
    
    const gmst = getGMST(jd) / DEG; // getGMST —É –≤–∞—Å –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Ä–∞–¥–∏–∞–Ω—ã, –ø–µ—Ä–µ–≤–æ–¥–∏–º –≤ –≥—Ä–∞–¥—É—Å—ã –¥–ª—è —Ñ–æ—Ä–º—É–ª—ã –Ω–∏–∂–µ
    // –ü—Ä–∏–º–µ—á–∞–Ω–∏–µ: –í –≤–∞—à–µ–π getGMST –≤–æ–∑–≤—Ä–∞—â–∞—é—Ç—Å—è —Ä–∞–¥–∏–∞–Ω—ã. 
    // –§–æ—Ä–º—É–ª–∞ –Ω–∏–∂–µ –æ–∂–∏–¥–∞–µ—Ç GMST –≤ —Ä–∞–¥–∏–∞–Ω–∞—Ö, –Ω–æ lon –≤ –≥—Ä–∞–¥—É—Å–∞—Ö –ø–µ—Ä–µ–≤–æ–¥–∏—Ç—Å—è –≤–Ω—É—Ç—Ä–∏.
    // –°–∫–æ—Ä—Ä–µ–∫—Ç–∏—Ä—É–µ–º –ø–æ–¥ –≤–∞—à—É getGMST:
    const gmstRad = getGMST(jd); 
    
    const ha = gmstRad + (lon * DEG) - Math.atan2(Math.cos(epsilon) * Math.sin(lambda), Math.cos(lambda));
    
    const latRad = lat * DEG;
    const sinAlt = Math.sin(dec) * Math.sin(latRad) + Math.cos(dec) * Math.cos(latRad) * Math.cos(ha);
    return Math.asin(sinAlt) * (180 / Math.PI);
}

// –°–ø–µ—Ü–∏–∞–ª—å–Ω–∞—è –≤–µ—Ä—Å–∏—è —Ä–∞—Å—á–µ—Ç–∞ –≤—ã—Å–æ—Ç—ã –õ—É–Ω—ã –¥–ª—è –∞–ª–≥–æ—Ä–∏—Ç–º–∞ —Å–æ–±—ã—Ç–∏–π
function getMoonAltitudeForEvents(lat, lon, date) {
    const DEG = Math.PI / 180;
    const jd = getJulianDate(date);
    const T = (jd - 2451545.0) / 36525.0;
    
    const L0 = (218.3164477 + 481267.88123421 * T) % 360;
    const M = (134.9633964 + 477198.8675055 * T) % 360 * DEG;
    const F = (93.2720950 + 483202.0175233 * T) % 360 * DEG;
    const D = (297.8501921 + 445267.1114034 * T) % 360 * DEG;
    
    let lambda = L0 + 6.289 * Math.sin(M);
    lambda += 1.274 * Math.sin(2 * D - M);
    lambda += 0.658 * Math.sin(2 * D);
    lambda += 0.214 * Math.sin(2 * M);
    lambda *= DEG;

    let beta = (5.128 * Math.sin(F) + 0.281 * Math.sin(M + F)) * DEG;
    const epsilon = 23.439 * DEG;

    const sinDec = Math.sin(beta) * Math.cos(epsilon) + Math.cos(beta) * Math.sin(epsilon) * Math.sin(lambda);
    const dec = Math.asin(sinDec);
    
    const y = Math.sin(lambda) * Math.cos(epsilon) - Math.tan(beta) * Math.sin(epsilon);
    const x = Math.cos(lambda);
    let ra = Math.atan2(y, x);
    
    const gmstRad = getGMST(jd);
    const lst = gmstRad + lon * DEG;
    const ha = lst - ra;
    const latRad = lat * DEG;
    
    const sinAlt = Math.sin(dec) * Math.sin(latRad) + Math.cos(dec) * Math.cos(latRad) * Math.cos(ha);
    return Math.asin(sinAlt) * (180 / Math.PI);
}

// –û—Å–Ω–æ–≤–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è —Ä–∞—Å—á–µ—Ç–∞ —Å–æ–±—ã—Ç–∏–π (–ò—Ç–µ—Ä–∞—Ç–∏–≤–Ω—ã–π –º–µ—Ç–æ–¥)
function calculateCelestialEvents(lat, lon) {
    const date = new Date();
    date.setHours(0,0,0,0);
    
    let sunRise = null, sunSet = null;
    let moonRise = null, moonSet = null;

    const sunHorizon = -0.833; 
    const moonHorizon = 0.125;

    let prevSunAlt = getSunAltitudeForEvents(lat, lon, date);
    let prevMoonAlt = getMoonAltitudeForEvents(lat, lon, date);

    // –ü—Ä–æ—Ö–æ–¥ –ø–æ —Å—É—Ç–∫–∞–º (—à–∞–≥ 1 –º–∏–Ω—É—Ç–∞)
    for (let i = 1; i < 1440; i++) {
        const now = new Date(date.getTime() + i * 60000);
        const sAlt = getSunAltitudeForEvents(lat, lon, now);
        const mAlt = getMoonAltitudeForEvents(lat, lon, now);

        // –°–æ–ª–Ω—Ü–µ
        if (prevSunAlt < sunHorizon && sAlt >= sunHorizon) sunRise = now;
        if (prevSunAlt > sunHorizon && sAlt <= sunHorizon) sunSet = now;

        // –õ—É–Ω–∞
        if (prevMoonAlt < moonHorizon && mAlt >= moonHorizon) moonRise = now;
        if (prevMoonAlt > moonHorizon && mAlt <= moonHorizon) moonSet = now;

        prevSunAlt = sAlt;
        prevMoonAlt = mAlt;
    }

    return { sunRise, sunSet, moonRise, moonSet };
}

function formatEventTime(date) {
    if (!date) return "--:--";
    return date.toLocaleTimeString('ru-RU', { hour: '2-digit', minute: '2-digit' });
}

function showSkyView(lat, lon, locName = "–¢–æ—á–∫–∞ –Ω–∞ –∫–∞—Ä—Ç–µ") {
    if (lat === undefined || lon === undefined) return;

    el.skyModal.classList.add('visible');
    initSkyView();
    
    const container = document.getElementById('sky-container');
    skyCamera.aspect = container.clientWidth / container.clientHeight;
    skyCamera.updateProjectionMatrix();
    skyRenderer.setSize(container.clientWidth, container.clientHeight);
    
    // –û–ë–ù–û–í–õ–ï–ù–ù–´–ï –¶–í–ï–¢–ê –ò –®–†–ò–§–¢–´
    el.skyUserCoords.innerHTML = `
        <div style="color: #00f3ff; margin-bottom: 8px; font-weight: 800; font-size: 14px; line-height: 1.4; text-shadow: 0 0 10px rgba(0, 243, 255, 0.4); text-transform: uppercase; letter-spacing: 0.5px;">
            ${locName}
        </div>
        <div style="color: #ffffff; opacity: 0.85; font-size: 11px; font-family: 'Consolas', monospace; border-top: 1px solid rgba(0, 243, 255, 0.2); pt: 6px; margin-top: 4px; padding-top: 6px;">
            <span style="color: #ffd700;">LAT:</span> ${Number(lat).toFixed(4)}¬∞ | <span style="color: #ffd700;">LON:</span> ${Number(lon).toFixed(4)}¬∞
        </div>
    `;
    
    updateSkyMoon(lat, lon);
    updateSkySun(lat, lon);
    
    // –û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ —á–∞—Å–æ–≤–æ–≥–æ –ø–æ—è—Å–∞
      if (locName.includes("GPS")) {
        // –î–ª—è –≤–∞—à–µ–≥–æ —Ä–µ–∞–ª—å–Ω–æ–≥–æ –º–µ—Å—Ç–æ–ø–æ–ª–æ–∂–µ–Ω–∏—è –±–µ—Ä–µ–º —Ç–æ—á–Ω–æ–µ –≤—Ä–µ–º—è –∏–∑ —Å–∏—Å—Ç–µ–º—ã
        targetLocationOffset = -new Date().getTimezoneOffset() / 60;
    } else {
        // –î–ª—è –ø–æ–∏—Å–∫–∞ –∏ –∫–ª–∏–∫–æ–≤ –ø–æ –∫–∞—Ä—Ç–µ —Å—á–∏—Ç–∞–µ–º –≥–µ–æ–≥—Ä–∞—Ñ–∏—á–µ—Å–∫–∏ (15 –≥—Ä–∞–¥—É—Å–æ–≤ = 1 —á–∞—Å)
        targetLocationOffset = Math.round(lon / 15);
    }
    if (!skyAnimationId) animateSky();
    
    const events = calculateCelestialEvents(lat, lon);
    el.skySunTimes.innerHTML = `‚Üë <span>${formatEventTime(events.sunRise)}</span> &nbsp; ‚Üì <span>${formatEventTime(events.sunSet)}</span>`;
    el.skyMoonTimes.innerHTML = `‚Üë <span>${formatEventTime(events.moonRise)}</span> &nbsp; ‚Üì <span>${formatEventTime(events.moonSet)}</span>`;

    createUserMarker(Number(lat), Number(lon));
}

async function searchCity(query) {
    if (!query || query.trim().length < 2) {
        el.searchResults.style.display = 'none';
        return;
    }

    // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é, —á—Ç–æ –∑–∞–ø—Ä–æ—Å –ø–æ—à–µ–ª (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ)
    el.cityInput.style.opacity = "0.5";

    try {
        const url = `https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(query)}&limit=5&accept-language=ru`;
        const response = await fetch(url);
        const data = await response.json();

        if (data && data.length > 0) {
            displaySearchResults(data);
        } else {
            el.searchResults.innerHTML = '<div class="search-item">–ì–æ—Ä–æ–¥ –Ω–µ –Ω–∞–π–¥–µ–Ω</div>';
            el.searchResults.style.display = 'block';
        }
    } catch (e) {
        console.error("–û—à–∏–±–∫–∞ –ø–æ–∏—Å–∫–∞:", e);
    } finally {
        el.cityInput.style.opacity = "1";
    }
}

// –û–ë–†–ê–ë–û–¢–ß–ò–ö: –ü–æ–∏—Å–∫ —Ç–æ–ª—å–∫–æ –ø—Ä–∏ –Ω–∞–∂–∞—Ç–∏–∏ ENTER
el.cityInput.addEventListener('keydown', (e) => {
    if (e.key === 'Enter') {
        e.preventDefault(); // –ü—Ä–µ–¥–æ—Ç–≤—Ä–∞—â–∞–µ–º –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å—Ç—Ä–∞–Ω–∏—Ü—ã
        searchCity(el.cityInput.value);
    }
});

// –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–æ: —Å–∫—Ä—ã–≤–∞–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã, –µ—Å–ª–∏ –ø–æ–ª–µ –æ—á–∏—â–µ–Ω–æ –≤—Ä—É—á–Ω—É—é
el.cityInput.addEventListener('input', (e) => {
    if (e.target.value === '') {
        el.searchResults.style.display = 'none';
    }
});



function displaySearchResults(results) {
    el.searchResults.innerHTML = '';
    el.searchResults.style.display = 'block';

    results.forEach(res => {
        const item = document.createElement('div');
        item.className = 'search-item';
        
        // –û—á–∏—â–∞–µ–º –Ω–∞–∑–≤–∞–Ω–∏–µ –¥–ª—è –∫—Ä–∞—Å–æ—Ç—ã
        const parts = res.display_name.split(', ');
        const shortName = parts.length > 2 ? `${parts[0]}, ${parts[parts.length-1]}` : res.display_name;
        
        item.innerText = res.display_name;
        item.onclick = (e) => {
            e.stopPropagation();
            el.searchResults.style.display = 'none';
            el.cityInput.value = parts[0];
            showSkyView(parseFloat(res.lat), parseFloat(res.lon), shortName);
        };
        el.searchResults.appendChild(item);
    });
}




// –ó–∞–∫—Ä—ã—Ç–∏–µ —Å–ø–∏—Å–∫–∞ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤ –ø—Ä–∏ –∫–ª–∏–∫–µ –º–∏–º–æ
document.addEventListener('click', (e) => {
    if (e.target !== el.cityInput) el.searchResults.style.display = 'none';
});


function closeSkyView() {
    el.skyModal.classList.remove('visible');
}

el.btnSkyView.addEventListener('click', openSkyView);
el.skyClose.addEventListener('click', closeSkyView);




window.addEventListener('resize', () => {
    if (skyInitialized && el.skyModal.classList.contains('visible')) {
        const container = document.getElementById('sky-container');
        skyCamera.aspect = container.clientWidth / container.clientHeight;
        skyCamera.updateProjectionMatrix();
        skyRenderer.setSize(container.clientWidth, container.clientHeight);
    }
});



function updateMoonToggleVisibility() {
    if (window.innerWidth <= 1024 && el.chkMoon.checked) {
        el.moonToggle.style.display = 'flex';
    } else {
        el.moonToggle.style.display = 'none';
    }
}

el.uiToggle.addEventListener('click', (e) => {
    e.stopPropagation();
    el.ui.classList.toggle('collapsed');
    el.uiToggle.innerText = el.ui.classList.contains('collapsed') ? '‚ûï' : '‚öôÔ∏è';
});

el.moonToggle.addEventListener('click', (e) => {
    e.stopPropagation();
    el.moonInfo.classList.toggle('collapsed');
    el.moonToggle.innerText = el.moonInfo.classList.contains('collapsed') ? '‚ñ∂' : 'üåì';
});

if (window.innerWidth <= 1024) {
    setTimeout(() => {
        el.ui.classList.add('collapsed');
        el.uiToggle.innerText = '‚ûï';
    }, 1500);
}

window.addEventListener('resize', updateMoonToggleVisibility);

el.btnClear.addEventListener('click', () => {
el.btnClear.style.transform = "scale(0.9)";
setTimeout(() => el.btnClear.style.transform = "", 150);
const req = indexedDB.deleteDatabase(DB_NAME);
req.onsuccess = () => { location.reload(); };
req.onerror = () => { alert('–û—à–∏–±–∫–∞ –æ—á–∏—Å—Ç–∫–∏ –∫—ç—à–∞.'); };
req.onblocked = () => { location.reload(); };
});

const scene = new THREE.Scene();
scene.background = new THREE.Color(0x020205);

const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 4000);
camera.position.set(0, 0, 28);

const renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
renderer.outputColorSpace = THREE.SRGBColorSpace;
renderer.toneMapping = THREE.ACESFilmicToneMapping;
renderer.toneMappingExposure = 2;
document.body.appendChild(renderer.domElement);

const ambientLight = new THREE.AmbientLight(0x404060, 0.1);
scene.add(ambientLight);

const sunLight = new THREE.DirectionalLight(0xffffff, 2.0);
sunLight.castShadow = true;
scene.add(sunLight);

function createFlareTexture(type, colorVal) {
const size = 512;
const canvas = document.createElement("canvas");
canvas.width = size; canvas.height = size;
const ctx = canvas.getContext("2d");
const cx = size / 2, cy = size / 2;
const c = new THREE.Color(colorVal);
const r = Math.round(c.r * 255), g = Math.round(c.g * 255), b = Math.round(c.b * 255);

ctx.clearRect(0, 0, size, size);

if (type === "glow") {
const grad = ctx.createRadialGradient(cx, cy, 0, cx, cy, size * 0.5);
grad.addColorStop(0, `rgba(${r},${g},${b},1)`);
grad.addColorStop(0.1, `rgba(${r},${g},${b},0.8)`);
grad.addColorStop(0.4, `rgba(${r},${g},${b},0.2)`);
grad.addColorStop(1, "rgba(0,0,0,0)");
ctx.fillStyle = grad; ctx.fillRect(0, 0, size, size);
} else if (type === "star") {
const grad = ctx.createRadialGradient(cx, cy, 0, cx, cy, size * 0.5);
grad.addColorStop(0, `rgba(${r},${g},${b},1)`);
grad.addColorStop(1, "rgba(0,0,0,0)");
ctx.fillStyle = grad;
ctx.globalCompositeOperation = "source-over";
ctx.save(); ctx.translate(cx, cy); ctx.scale(8, 0.4);
const hGrad = ctx.createRadialGradient(0, 0, 0, 0, 0, size/16);
hGrad.addColorStop(0, `rgba(${r},${g},${b},0.8)`); hGrad.addColorStop(1, "rgba(0,0,0,0)");
ctx.fillStyle = hGrad; ctx.beginPath(); ctx.arc(0, 0, size/16, 0, Math.PI*2); ctx.fill(); ctx.restore();
ctx.save(); ctx.translate(cx, cy); ctx.scale(0.4, 8);
ctx.fillStyle = hGrad; ctx.beginPath(); ctx.arc(0, 0, size/16, 0, Math.PI*2); ctx.fill(); ctx.restore();
const centerGrad = ctx.createRadialGradient(cx, cy, 0, cx, cy, size * 0.1);
centerGrad.addColorStop(0, "white"); centerGrad.addColorStop(1, "rgba(0,0,0,0)");
ctx.fillStyle = centerGrad; ctx.beginPath(); ctx.arc(cx, cy, size*0.1, 0, Math.PI*2); ctx.fill();
} else if (type === "lens") {
const grad = ctx.createRadialGradient(cx, cy, 0, cx, cy, size * 0.5);
grad.addColorStop(0, `rgba(${r},${g},${b},0.4)`); grad.addColorStop(0.8, `rgba(${r},${g},${b},0.1)`);
grad.addColorStop(1, "rgba(0,0,0,0)");
ctx.fillStyle = grad;
ctx.beginPath();
for (let i = 0; i < 6; i++) {
const angle = (Math.PI / 3) * i; const R = size * 0.45;
const x = cx + R * Math.cos(angle); const y = cy + R * Math.sin(angle);
if (i === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
}
ctx.closePath(); ctx.fill();
}
const texture = new THREE.CanvasTexture(canvas);
texture.colorSpace = THREE.SRGBColorSpace;
return texture;
}

const texSunGlow = createFlareTexture("glow", 0xffffee);
const texSunStar = createFlareTexture("star", 0xffffff);
const texLensHex = createFlareTexture("lens", 0xffffff);
const lensflare = new Lensflare();

const mainGlow = new LensflareElement(texSunGlow, 1200, 0.0, new THREE.Color(0xffaa55));
const mainStar = new LensflareElement(texSunStar, 500, 0.0, new THREE.Color(0xffffff));

lensflare.addElement(mainGlow);
lensflare.addElement(mainStar);
lensflare.addElement(new LensflareElement(texLensHex, 60, 0.6, new THREE.Color(0xffddaa)));
lensflare.addElement(new LensflareElement(texLensHex, 100, 0.7, new THREE.Color(0xaaccff)));
lensflare.addElement(new LensflareElement(texLensHex, 140, 0.9, new THREE.Color(0xffccaa)));
lensflare.addElement(new LensflareElement(texLensHex, 300, 1.2, new THREE.Color(0x5555aa)));

sunLight.add(lensflare);
lensflare.visible = false;

const controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true; controls.dampingFactor = 0.08;
controls.minDistance = 12; controls.maxDistance = 200;
controls.enablePan = false; controls.rotateSpeed = 0.5; controls.enableZoom = true;
controls.touches = { ONE: THREE.TOUCH.ROTATE, TWO: THREE.TOUCH.DOLLY_PAN };

renderer.domElement.addEventListener('wheel', (e) => {
e.preventDefault(); e.stopImmediatePropagation();
const currentDistance = controls.target.distanceTo(camera.position);
const zoomScale = e.deltaY > 0 ? 1.05 : 0.95;
let newDistance = currentDistance * zoomScale;
newDistance = Math.max(controls.minDistance, Math.min(controls.maxDistance, newDistance));
const direction = new THREE.Vector3().subVectors(camera.position, controls.target).normalize();
camera.position.copy(controls.target).add(direction.multiplyScalar(newDistance));
}, { passive: false, capture: true });

const earthGroup = new THREE.Group();
scene.add(earthGroup);

const mwGeo = new THREE.SphereGeometry(2500, 64, 64);
const mwMat = new THREE.MeshBasicMaterial({
map: loadTextureWithCache('./textures/milkyway.jpg'),
side: THREE.BackSide, transparent: true, opacity: 0.5, depthWrite: false
});
const milkyWay = new THREE.Mesh(mwGeo, mwMat);
milkyWay.visible = false;
scene.add(milkyWay);

const earthMat = new THREE.MeshPhongMaterial({
map: loadTextureWithCache('./textures/earth-blue-marble.jpg'),
bumpMap: loadTextureWithCache('./textures/earth-topology.png'),
bumpScale: 0.1, specularMap: loadTextureWithCache('./textures/earth-water.png'),
specular: new THREE.Color(0x333333), shininess: 15
});
earthMat.map.colorSpace = THREE.SRGBColorSpace;
const earth = new THREE.Mesh(new THREE.SphereGeometry(10, 64, 64), earthMat);
earthGroup.add(earth);

const nightTexture = loadTextureWithCache('./textures/earth-night.jpg');
nightTexture.colorSpace = THREE.SRGBColorSpace;
const nightUniforms = { tNight: { value: nightTexture }, sunDirection: { value: new THREE.Vector3(1, 0, 0) } };
const nightMat = new THREE.ShaderMaterial({
uniforms: nightUniforms,
vertexShader: `varying vec2 vUv; varying vec3 vNormal; void main() { vUv = uv; vNormal = normalize(mat3(modelMatrix) * normal); gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0); }`,
fragmentShader: `uniform sampler2D tNight; uniform vec3 sunDirection; varying vec2 vUv; varying vec3 vNormal; void main() { vec3 nightColor = texture2D(tNight, vUv).rgb; float lighting = dot(vNormal, sunDirection); float mask = clamp(-lighting + 0.15, 0.0, 1.0); mask = pow(mask, 3.0); gl_FragColor = vec4(nightColor, mask); }`,
transparent: true, blending: THREE.AdditiveBlending, depthWrite: false, side: THREE.FrontSide
});
const earthNight = new THREE.Mesh(new THREE.SphereGeometry(10.01, 64, 64), nightMat);
earthGroup.add(earthNight);

const cloudMat = new THREE.MeshPhongMaterial({
map: loadTextureWithCache('./textures/earth-clouds.jpg'),
transparent: true, opacity: 0.8, blending: THREE.AdditiveBlending, side: THREE.DoubleSide, depthWrite: false
});
const clouds = new THREE.Mesh(new THREE.SphereGeometry(10.15, 64, 64), cloudMat);
earthGroup.add(clouds);
clouds.visible = false;

const atmoMat = new THREE.ShaderMaterial({
vertexShader: `varying vec3 vN; void main(){vN=normalize(normalMatrix*normal);gl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.0);}`,
fragmentShader: `varying vec3 vN; void main(){float i=pow(0.5-dot(vN,vec3(0,0,1)),3.0);gl_FragColor=vec4(0.3,0.6,1.0,1.0)*i*1.3;}`,
blending: THREE.AdditiveBlending, side: THREE.BackSide, transparent: true, depthWrite: false
});
const atmosphere = new THREE.Mesh(new THREE.SphereGeometry(10.3, 64, 64), atmoMat);
scene.add(atmosphere);

function createStars(count = 5000) {
const geo = new THREE.BufferGeometry();
const pos = new Float32Array(count * 3);
for (let i = 0; i < count; i++) {
const r = 300 + Math.random() * 900;
const theta = 2 * Math.PI * Math.random();
const phi = Math.acos(2 * Math.random() - 1);
pos[i * 3] = r * Math.sin(phi) * Math.cos(theta);
pos[i * 3 + 1] = r * Math.cos(phi);
pos[i * 3 + 2] = r * Math.sin(phi) * Math.sin(theta);
}
geo.setAttribute("position", new THREE.BufferAttribute(pos, 3));
const mat = new THREE.PointsMaterial({ color: 0xffffff, size: 0.5, transparent: true, opacity: 0.8, depthWrite: false });
return new THREE.Points(geo, mat);
}
const starsContainer = createStars();
scene.add(starsContainer);

const moonGroup = new THREE.Group();
moonGroup.visible = false;
scene.add(moonGroup);

const moonUrl = "./textures/moon-color.jpg";
const moonImg2D = new Image(); moonImg2D.src = moonUrl;

const moon3DMat = new THREE.MeshPhongMaterial({
map: loadTextureWithCache(moonUrl),
bumpMap: loadTextureWithCache("./textures/moon-bump.jpg"),
bumpScale: 0.06, shininess: 2, color: 0xffffff
});
moon3DMat.map.colorSpace = THREE.SRGBColorSpace;
const moon = new THREE.Mesh(new THREE.SphereGeometry(2.7, 64, 64), moon3DMat);
moonGroup.add(moon);

const issContainer = new THREE.Group();
scene.add(issContainer);
issContainer.visible = false;

function buildDetailedISS() {
const iss = new THREE.Group();
const bodyMat = new THREE.MeshPhongMaterial({ color: 0xeeeeee, shininess: 80, specular: 0x444444 });
const darkMat = new THREE.MeshPhongMaterial({ color: 0x222222, shininess: 50 });
const solarMat = new THREE.MeshPhongMaterial({ color: 0x3333aa, emissive: 0x050520, shininess: 100, specular: 0x8888ff, side: THREE.DoubleSide });

const zvezda = new THREE.Mesh(new THREE.CylinderGeometry(0.06, 0.06, 0.4, 12), bodyMat); zvezda.rotation.z = Math.PI / 2; iss.add(zvezda);
const zarya = new THREE.Mesh(new THREE.CylinderGeometry(0.065, 0.065, 0.45, 12), bodyMat); zarya.rotation.z = Math.PI / 2; zarya.position.x = 0.45; iss.add(zarya);
const unity = new THREE.Mesh(new THREE.CylinderGeometry(0.07, 0.07, 0.2, 12), bodyMat); unity.rotation.z = Math.PI / 2; unity.position.x = 0.8; iss.add(unity);
const destiny = new THREE.Mesh(new THREE.CylinderGeometry(0.065, 0.065, 0.35, 12), bodyMat); destiny.rotation.z = Math.PI / 2; destiny.position.x = 1.1; iss.add(destiny);
const truss = new THREE.Mesh(new THREE.BoxGeometry(0.04, 3.5, 0.04), bodyMat); truss.position.x = 0.9; iss.add(truss);

function createSolarWing(yPos) {
const wingGroup = new THREE.Group(); wingGroup.position.set(0.9, yPos, 0);
const joint = new THREE.Mesh(new THREE.CylinderGeometry(0.03, 0.03, 0.1, 8), darkMat); wingGroup.add(joint);
const panelGeo = new THREE.BoxGeometry(0.3, 1.0, 0.01);
const p1 = new THREE.Mesh(panelGeo, solarMat); p1.position.set(0.2, 0, 0);
const p2 = new THREE.Mesh(panelGeo, solarMat); p2.position.set(-0.2, 0, 0);
wingGroup.add(p1); wingGroup.add(p2); wingGroup.rotation.x = Math.PI / 4;
return wingGroup;
}
iss.add(createSolarWing(1.6)); iss.add(createSolarWing(1.2)); iss.add(createSolarWing(-1.2)); iss.add(createSolarWing(-1.6));
const radGeo = new THREE.BoxGeometry(0.2, 0.6, 0.01);
const rad1 = new THREE.Mesh(radGeo, bodyMat); rad1.position.set(0.9, 0.5, -0.15); rad1.rotation.x = -0.5; iss.add(rad1);
const rad2 = new THREE.Mesh(radGeo, bodyMat); rad2.position.set(0.9, -0.5, -0.15); rad2.rotation.x = -0.5; iss.add(rad2);
return iss;
}

const issModel = buildDetailedISS();
issModel.scale.set(0.30, 0.30, 0.30);
issContainer.add(issModel);

const MAX_POINTS = 2000;
const trailGeo = new THREE.BufferGeometry();
const trailPos = new Float32Array(MAX_POINTS * 3);
trailGeo.setAttribute("position", new THREE.BufferAttribute(trailPos, 3));
trailGeo.setDrawRange(0, 0);
const trailMat = new THREE.LineBasicMaterial({ color: 0x00ffff, opacity: 1.0 });
const trailLine = new THREE.Line(trailGeo, trailMat);
earth.add(trailLine);

const DEG_TO_RAD = Math.PI / 180;
const EPSILON = 23.43929 * DEG_TO_RAD;

function getJulianDate(date) { return (date.getTime() / 86400000) + 2440587.5; }

function getGMST(jd) {
const T = (jd - 2451545.0) / 36525.0;
let st = 280.46061837 + 360.98564736629 * (jd - 2451545.0) + 0.000387933 * T * T - T * T * T / 38710000.0;
st = st % 360;
if (st < 0) st += 360;
return st * DEG_TO_RAD;
}

function getSolarCoordinates(jd) {
const n = jd - 2451545.0;
const L = (280.466 + 0.98564736 * n) % 360;
const g = (357.528 + 0.98560028 * n) % 360;
const L_rad = L * DEG_TO_RAD; const g_rad = g * DEG_TO_RAD;
const lambda = L + 1.915 * Math.sin(g_rad) + 0.020 * Math.sin(2 * g_rad);
const lambda_rad = lambda * DEG_TO_RAD;
const X_ecl = Math.cos(lambda_rad);
const Y_ecl = Math.cos(EPSILON) * Math.sin(lambda_rad);
const Z_ecl = Math.sin(EPSILON) * Math.sin(lambda_rad);
return { x: X_ecl, y: Y_ecl, z: Z_ecl };
}

function getLunarCoordinates(jd) {
const T = (jd - 2451545.0) / 36525.0;
const L_0 = (218.3164477 + 481267.88123421 * T) * DEG_TO_RAD;
const D = (297.8501921 + 445267.1114034 * T) * DEG_TO_RAD;
const M = (134.9633964 + 477198.8675055 * T) * DEG_TO_RAD;
const F = (93.2720950 + 483202.0175233 * T) * DEG_TO_RAD;
const lambda = L_0 + 0.10976 * Math.sin(M) - 0.02224 * Math.sin(M - 2 * D) + 0.01148 * Math.sin(2 * D);
const beta = 0.0895 * Math.sin(F) + 0.0049 * Math.sin(M + F) - 0.0048 * Math.sin(M - F);
const dist = 385000.56 - 20905.0 * Math.cos(M);
const cosB = Math.cos(beta);
const x_ecl = cosB * Math.cos(lambda);
const y_ecl = cosB * Math.sin(lambda);
const z_ecl = Math.sin(beta);
const x_eq = x_ecl;
const y_eq = y_ecl * Math.cos(EPSILON) - z_ecl * Math.sin(EPSILON);
const z_eq = y_ecl * Math.sin(EPSILON) + z_ecl * Math.cos(EPSILON);
return { x: x_eq, y: y_eq, z: z_eq, distanceKm: dist };
}

const moonCtx = el.moonCanvas.getContext("2d"), moonW = el.moonCanvas.width, moonH = el.moonCanvas.height;
const moonMaskCanvas = document.createElement("canvas"); moonMaskCanvas.width = moonW; moonMaskCanvas.height = moonH;
const moonMaskCtx = moonMaskCanvas.getContext("2d"); const moonMaskImage = moonMaskCtx.createImageData(moonW, moonH);

function drawMoonPhase(phaseFraction) {
const ctx = moonCtx, w = moonW, h = moonH, R = w / 2, cx = R, cy = R;
ctx.clearRect(0, 0, w, h); ctx.fillStyle = "#111"; ctx.beginPath(); ctx.arc(cx, cy, R, 0, Math.PI * 2); ctx.fill();
if (moonImg2D.complete && moonImg2D.naturalWidth > 0) {
ctx.save(); ctx.beginPath(); ctx.arc(cx, cy, R, 0, Math.PI * 2); ctx.clip();
ctx.globalAlpha = 0.2; ctx.drawImage(moonImg2D, 0, 0, w, h); ctx.restore();
}
const phi = phaseFraction * 2 * Math.PI, sx = Math.sin(phi), sy = 0, sz = -Math.cos(phi);
const data = moonMaskImage.data, r2Max = 1.0;
for (let y = 0; y < h; y++) {
const ny = (y + 0.5 - cy) / R;
for (let x = 0; x < w; x++) {
const nx = (x + 0.5 - cx) / R, r2 = nx * nx + ny * ny, idx = (y * w + x) * 4;
if (r2 <= r2Max) {
const nz = Math.sqrt(1 - r2), dot = nx * sx + ny * sy + nz * sz, b = Math.max(0, dot), a = Math.min(1, b * 1.5);
data[idx] = 255; data[idx + 1] = 255; data[idx + 2] = 255; data[idx + 3] = Math.round(a * 255);
} else { data[idx] = 0; data[idx + 1] = 0; data[idx + 2] = 0; data[idx + 3] = 0; }
}
}
moonMaskCtx.putImageData(moonMaskImage, 0, 0);
ctx.save(); ctx.beginPath(); ctx.arc(cx, cy, R, 0, Math.PI * 2); ctx.clip();
if (moonImg2D.complete && moonImg2D.naturalWidth > 0) {
ctx.globalAlpha = 1.0; ctx.globalCompositeOperation = "source-over"; ctx.drawImage(moonImg2D, 0, 0, w, h);
ctx.globalCompositeOperation = "destination-in"; ctx.drawImage(moonMaskCanvas, 0, 0);
} else { ctx.globalCompositeOperation = "source-over"; ctx.drawImage(moonMaskCanvas, 0, 0); }
ctx.restore();
const grad = ctx.createRadialGradient(cx, cy, R * 0.85, cx, cy, R);
grad.addColorStop(0, "rgba(0,0,0,0)"); grad.addColorStop(1, "rgba(0,0,0,0.5)");
ctx.fillStyle = grad; ctx.beginPath(); ctx.arc(cx, cy, R, 0, Math.PI * 2); ctx.fill();
}

function getPhaseName(p) {
if (p < 0.03 || p > 0.97) return "–ù–æ–≤–æ–ª—É–Ω–∏–µ"; if (p < 0.22) return "–†–∞—Å—Ç—É—â–∏–π —Å–µ—Ä–ø";
if (p < 0.28) return "–ü–µ—Ä–≤–∞—è —á–µ—Ç–≤–µ—Ä—Ç—å"; if (p < 0.47) return "–†–∞—Å—Ç—É—â–∞—è –ª—É–Ω–∞";
if (p < 0.53) return "–ü–æ–ª–Ω–æ–ª—É–Ω–∏–µ"; if (p < 0.72) return "–£–±—ã–≤–∞—é—â–∞—è –ª—É–Ω–∞";
if (p < 0.78) return "–ü–æ—Å–ª–µ–¥–Ω—è—è —á–µ—Ç–≤–µ—Ä—Ç—å"; return "–£–±—ã–≤–∞—é—â–∏–π —Å–µ—Ä–ø";
}

let trailIndex = 0, totalDistanceKm = 0;
let trackingDurationSec = 0;
let issTargetPos = null, issHasFix = false;
let issVelocityKmS = 7.66;
let issDisplayData = { lat: 0, lon: 0, alt: 0 };
let issFirstFlyover = false;

const EARTH_RADIUS_UNITS = 10, KM_PER_UNIT_EARTH = 6371 / EARTH_RADIUS_UNITS;

const raycaster = new THREE.Raycaster();
const mouse = new THREE.Vector2();
let cameraMode = 'global';

const camState = {
isTransitioning: false, startTime: 0, duration: 2000,
startPos: new THREE.Vector3(), endPos: new THREE.Vector3(),
startTarget: new THREE.Vector3(), endTarget: new THREE.Vector3()
};

function createUserMarker(lat, lon) {
    if (userMarker) {
        earth.remove(userMarker);
        userMarker.traverse((child) => {
            if (child.isMesh) {
                child.geometry.dispose();
                child.material.dispose();
            }
        });
    }

    userMarker = new THREE.Group();
    const pinGeo = new THREE.CylinderGeometry(0.02, 0.02, 1.2, 8);
    pinGeo.translate(0, 0.6, 0); 
    const pinMat = new THREE.MeshBasicMaterial({ color: 0x00f3ff }); // –¶–≤–µ—Ç –≤ —Å—Ç–∏–ª—å UI
    const pin = new THREE.Mesh(pinGeo, pinMat);
    userMarker.add(pin);
    
    const ballGeo = new THREE.SphereGeometry(0.08, 16, 16);
    ballGeo.translate(0, 1.2, 0);
    const ballMat = new THREE.MeshBasicMaterial({ color: 0x00f3ff, emissive: 0x00f3ff });
    const ball = new THREE.Mesh(ballGeo, ballMat);
    userMarker.add(ball);
    
    const pos = getVector(lat, lon, 0, 10, 0); 
    userMarker.position.copy(pos);
    userMarker.quaternion.setFromUnitVectors(
        new THREE.Vector3(0, 1, 0),
        pos.clone().normalize()
    );
    earth.add(userMarker);
    
    userLocation = { lat, lon };
    
  
    if (!camState.isTransitioning) {
      
        const worldPos = pos.clone().applyAxisAngle(new THREE.Vector3(0, 1, 0), earth.rotation.y);
        const targetPos = worldPos.clone().normalize().multiplyScalar(cameraMode === 'iss' ? 15 : 25);
        
        camState.startPos.copy(camera.position);
        camState.startTarget.copy(controls.target);
        camState.endPos.copy(targetPos);
        camState.endTarget.set(0, 0, 0);
        camState.duration = 2000;
        startTransition();
    }
}

document.querySelector('.ui-header').addEventListener('dblclick', (e) => {
    e.preventDefault(); 
    if (!navigator.geolocation) {
        alert("–ì–µ–æ–ª–æ–∫–∞—Ü–∏—è –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç—Å—è –≤–∞—à–∏–º –±—Ä–∞—É–∑–µ—Ä–æ–º.");
        return;
    }
    el.loading.innerText = "–û–ü–†–ï–î–ï–õ–ï–ù–ò–ï –ú–ï–°–¢–ê...";
    el.loading.style.display = "block";
    navigator.geolocation.getCurrentPosition(
        (position) => {
            el.loading.style.display = "none";
            createUserMarker(position.coords.latitude, position.coords.longitude);
        },
        (error) => {
            el.loading.style.display = "none";
            let msg = "–û—à–∏–±–∫–∞ –≥–µ–æ–ª–æ–∫–∞—Ü–∏–∏";
            if(error.code === 1) msg = "–î–æ—Å—Ç—É–ø –∫ –≥–µ–æ–ø–æ–∑–∏—Ü–∏–∏ –∑–∞–ø—Ä–µ—â–µ–Ω";
            alert(msg);
        }
    );
});

window.addEventListener('dblclick', async (event) => {
  
    if (el.skyModal.classList.contains('visible')) return;

    if (camState.isTransitioning) return;
    event.preventDefault();
    
    mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
    mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
    raycaster.setFromCamera(mouse, camera);
    
    if (el.chkISS.checked && cameraMode !== 'iss') {
        const intersectsISS = raycaster.intersectObjects(issModel.children, true);
        if (intersectsISS.length > 0) {
            enterISSMode();
            return;
        }
    }

    
    if (el.chkMoon.checked && cameraMode !== 'moon') {
        const intersectsMoon = raycaster.intersectObjects(moonGroup.children, true);
        if (intersectsMoon.length > 0) {
            enterMoonMode();
            return;
        }
    }

    
    if (el.chkMoon.checked && cameraMode === 'global') {
        const intersectsEarth = raycaster.intersectObject(earth);
        if (intersectsEarth.length > 0) {
            const point = intersectsEarth[0].point;
            
            
            const now = new Date();
            const jd = getJulianDate(now);
            const gmst = getGMST(jd);
            
            
            const r = 10;
            
            
            const lat = Math.asin(point.y / r) * (180 / Math.PI);
            
            
            
            const angle = Math.atan2(-point.z, point.x); 
            let lon = (angle - gmst) * (180 / Math.PI);
            
            
            while (lon <= -180) lon += 360;
            while (lon > 180) lon -= 360;

            
            createUserMarker(lat, lon);
            
            
            el.loading.innerText = "–ü–æ–∏—Å–∫ –º–µ—Å—Ç–æ–ø–æ–ª–æ–∂–µ–Ω–∏—è –≤ —Ç–æ—á–∫–µ...";
            el.loading.style.display = "block";
            const locationName = await fetchLocationName(lat, lon);
            el.loading.style.display = "none";
            
            openSkyView({ lat, lon, name: locationName });
            return;
        }
    }
});

el.btnExit.addEventListener('click', exitISSMode);
el.btnExitMoon.addEventListener('click', exitMoonMode);

function enterISSMode() {
if (camState.isTransitioning) return;
cameraMode = 'iss';
el.btnExit.classList.add('visible');
el.ui.style.opacity = '0'; el.ui.style.pointerEvents = 'none'; el.issHint.style.display = 'none';

el.issHud.style.display = 'block';

camState.startPos.copy(camera.position); camState.startTarget.copy(controls.target);

const vUp = issModel.position.clone().normalize();
const vRight = new THREE.Vector3(0,1,0).cross(vUp).normalize();
camState.endPos.copy(issModel.position).add(vUp.multiplyScalar(0.3)).add(vRight.multiplyScalar(0.5));
camState.endTarget.copy(issModel.position);

camState.duration = 2000;
startTransition();
}

function exitISSMode() {
if (camState.isTransitioning) return;
cameraMode = 'global';
el.btnExit.classList.remove('visible');
el.ui.style.opacity = '1'; el.ui.style.pointerEvents = 'auto';

el.issHud.style.display = 'none';

camState.startPos.copy(camera.position); camState.startTarget.copy(controls.target);
camState.endPos.set(0, 0, 28); camState.endTarget.set(0, 0, 0);
camState.duration = 2000;
startTransition();
}

function enterMoonMode() {
if (camState.isTransitioning) return;
if (cameraMode === 'iss') el.btnExit.classList.remove('visible');

cameraMode = 'moon';
el.btnExitMoon.classList.add('visible');
el.ui.style.opacity = '0'; el.ui.style.pointerEvents = 'none';
el.issHint.style.display = 'none';

camState.startPos.copy(camera.position);
camState.startTarget.copy(controls.target);

const vToMoon = new THREE.Vector3().subVectors(camera.position, moonGroup.position).normalize();
camState.endPos.copy(moonGroup.position).add(vToMoon.multiplyScalar(10));
camState.endTarget.copy(moonGroup.position);

camState.duration = 2000;
startTransition();
}

function exitMoonMode() {
if (camState.isTransitioning) return;
cameraMode = 'global';
el.btnExitMoon.classList.remove('visible');
el.ui.style.opacity = '1'; el.ui.style.pointerEvents = 'auto';

camState.startPos.copy(camera.position);
camState.startTarget.copy(controls.target);

const earthPos = new THREE.Vector3(0,0,0);
const vFromEarth = new THREE.Vector3().subVectors(camera.position, earthPos).normalize();
camState.endPos.copy(vFromEarth.multiplyScalar(28));
camState.endTarget.set(0, 0, 0);

camState.duration = 2000;
startTransition();
}

function startTransition() {
camState.isTransitioning = true; camState.startTime = performance.now(); controls.enabled = false;
}

function easeInOutCubic(t) { return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2; }

function getVector(lat, lon, altKm, radiusUnits, gmst = 0) {
const lonRad = (lon * DEG_TO_RAD) + gmst;
const latRad = lat * DEG_TO_RAD;
const r = radiusUnits + (altKm / KM_PER_UNIT_EARTH);
return new THREE.Vector3(
r * Math.cos(latRad) * Math.cos(lonRad),
r * Math.sin(latRad),
-r * Math.cos(latRad) * Math.sin(lonRad)
);
}

async function updateISS() {
    if (!el.chkISS.checked) return;
    try {
        const res = await fetch(`https://api.wheretheiss.at/v1/satellites/25544?time=${Date.now()}`, { cache: "no-store" });
        if (!res.ok) throw new Error();
        const data = await res.json();

        issDisplayData = { 
            lat: data.latitude, 
            lon: data.longitude, 
            alt: data.altitude,
            visibility: data.visibility, 
            footprint: data.footprint,   
            id: data.id                 
        };
        issVelocityKmS = data.velocity / 3600;
        issHasFix = true;

        const now = new Date();
        const jd = getJulianDate(now);
        const gmst = getGMST(jd);

        const posWorld = getVector(data.latitude, data.longitude, data.altitude, EARTH_RADIUS_UNITS, gmst);
        const posLocal = getVector(data.latitude, data.longitude, data.altitude, EARTH_RADIUS_UNITS, 0);

        if (!issFirstFlyover && !camState.isTransitioning && cameraMode === 'global') {
            issFirstFlyover = true;
            camState.startPos.copy(camera.position);
            camState.startTarget.copy(controls.target);
            camState.endTarget.set(0, 0, 0);
            const camOrbitPos = posWorld.clone().normalize().multiplyScalar(35);
            camState.endPos.copy(camOrbitPos);
            camState.duration = 3000;
            startTransition();
        }

        if (trailIndex < MAX_POINTS) {
            const arr = trailLine.geometry.attributes.position.array;
            arr[trailIndex * 3] = posLocal.x;
            arr[trailIndex * 3 + 1] = posLocal.y;
            arr[trailIndex * 3 + 2] = posLocal.z;
            trailIndex++;
            trailLine.geometry.setDrawRange(0, trailIndex);
            trailLine.geometry.attributes.position.needsUpdate = true;
        }

        if (!issTargetPos) {
            issTargetPos = posWorld.clone();
            issModel.position.copy(posWorld);
        } else {
            issTargetPos.copy(posWorld);
        }
        el.loading.style.display = "none";
    } catch (e) { }
}

function scheduleISS() { if(el.chkISS.checked) updateISS().finally(() => setTimeout(scheduleISS, 10000)); }

el.chkISS.addEventListener("change", (e) => {
issContainer.visible = e.target.checked;
if (e.target.checked) {
issFirstFlyover = false;
  totalDistanceKm = 0;
    trackingDurationSec = 0;
el.loading.innerText = "–ü–æ–∏—Å–∫ –ú–ö–°..";
el.loading.style.display = "block";
el.data.innerHTML = "–ü–æ–∏—Å–∫ —Å–∏–≥–Ω–∞–ª–∞...";
scheduleISS();
} else {
el.loading.style.display = "none";
if(cameraMode === 'iss') exitISSMode();
el.data.innerHTML = "–ú–ö–° –≤—ã–∫–ª—é—á–µ–Ω–∞";
}
});

el.chkClouds.addEventListener("change", (e) => { clouds.visible = e.target.checked; });
el.chkGalaxy.addEventListener("change", (e) => { milkyWay.visible = e.target.checked; });

el.chkMoon.addEventListener("change", (e) => {
moonGroup.visible = e.target.checked;
el.moonInfo.style.display = e.target.checked ? "block" : "none";
updateMoonToggleVisibility();
});

renderer.domElement.addEventListener('mousemove', (e) => {
if(!el.chkISS.checked || cameraMode === 'iss') { el.issHint.style.opacity = 0; return; }
mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
raycaster.setFromCamera(mouse, camera);
const intersects = raycaster.intersectObjects(issModel.children, true);
if(intersects.length > 0) {
el.issHint.style.opacity = 1;
el.issHint.style.top = (e.clientY - 30) + 'px';
el.issHint.style.left = e.clientX + 'px';
} else { el.issHint.style.opacity = 0; }
});

async function updateGeoLocation(lat, lon) {
    const now = Date.now();
    if (now - lastGeoCheckTime < 10000) return;
    lastGeoCheckTime = now;

    try {
        const url = `https://nominatim.openstreetmap.org/reverse?format=json&lat=${lat}&lon=${lon}&zoom=10&accept-language=ru`;
        const response = await fetch(url);
        if (!response.ok) throw new Error();
        const data = await response.json();

        if (data.error) {
            el.hudLocation.innerText = "–ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö / –û–∫–µ–∞–Ω";
        } else {
            const addr = data.address;
            const city = addr.city || addr.town || addr.village || addr.municipality;
            const state = addr.state || addr.region;
            const country = addr.country;
            let locString = country || "";
            if (state && state !== country) locString += `, ${state}`;
            if (city && city !== state) locString = `${city}, ${locString}`;
            el.hudLocation.innerText = locString || "UNKNOWN TERRAIN";
        }
    } catch (e) {
        el.hudLocation.innerText = "OCEAN / NO SIGNAL";
    }
}

function updateISSHUD() {
    if (cameraMode !== 'iss' || !issHasFix) return;

    el.hudLat.innerText = `–® ${issDisplayData.lat.toFixed(4)}`;
    el.hudLon.innerText = `–î ${issDisplayData.lon.toFixed(4)}`;
    el.hudAlt.innerText = `${issDisplayData.alt.toFixed(1)} KM`;

    el.hudVel.innerText = `${(issVelocityKmS * 3600).toFixed(0)} –∫–º/—á`;

    if (issDisplayData.visibility === 'daylight') {
        el.hudSolar.innerText = "100%";
        el.hudSolar.style.color = "#fff";
        el.hudStatus.innerHTML = 
            "<span style='color:#0f0'>‚óè –ù–∞ —Å–æ–ª–Ω—Ü–µ</span><br>" + 
            `<span style='color:#8ba4b8; font-size:9px;'>–û–±–∑–æ—Ä: ${Math.round(issDisplayData.footprint)} –∫–º</span>`;
    } else {
        el.hudSolar.innerText = "0% (–ë–∞—Ç–∞—Ä–µ—è)";
        el.hudSolar.style.color = "#ff3366";
        el.hudStatus.innerHTML = 
            "<span class='hud-warn'>‚ö† –í —Ç–µ–Ω–∏</span><br>" + 
            `<span style='color:#8ba4b8; font-size:9px;'>–û–±–∑–æ—Ä: ${Math.round(issDisplayData.footprint)} –∫–º</span>`;
    }

    updateGeoLocation(issDisplayData.lat, issDisplayData.lon);
}

function updateCelestialPositions() {
const now = new Date();
el.timeNow.innerText = now.toLocaleTimeString('ru-RU', { hour12: false });
el.dateNow.innerText = now.toLocaleDateString('ru-RU');

const jd = getJulianDate(now);
const gmst = getGMST(jd);

earth.rotation.y = gmst;
earthNight.rotation.y = gmst;
cloudOffset += 0.00001;
clouds.rotation.y = gmst + cloudOffset;

if (el.chkSun.checked) {
lensflare.visible = true; earthNight.visible = true;
const sunCoords = getSolarCoordinates(jd);
const sunVec = new THREE.Vector3(sunCoords.x, sunCoords.z, -sunCoords.y).normalize().multiplyScalar(200);

sunLight.position.copy(sunVec);
nightUniforms.sunDirection.value.copy(sunVec).normalize();
sunLight.intensity = 2.5; ambientLight.intensity = 0.02;
} else {
sunLight.position.copy(camera.position);
sunLight.intensity = 1.0; ambientLight.intensity = 1.5;
lensflare.visible = false; earthNight.visible = false;
}

if (el.chkMoon.checked) {
const moonC = getLunarCoordinates(jd);
const moonPos = new THREE.Vector3(moonC.x, moonC.z, -moonC.y).normalize().multiplyScalar(60);
moonGroup.position.copy(moonPos);
moon.lookAt(0,0,0);

const angleSun = Math.atan2(sunLight.position.z, sunLight.position.x);
const angleMoon = Math.atan2(moonGroup.position.z, moonGroup.position.x);
let angleDiff = angleMoon - angleSun;
if (angleDiff < 0) angleDiff += 2*Math.PI;

const phaseFraction = 1.0 - (angleDiff / (2*Math.PI));
drawMoonPhase(phaseFraction);

const sunV = sunLight.position.clone().normalize();
const moonV = moonPos.clone().normalize();
const elongation = Math.acos(sunV.dot(moonV));
const illumination = (1 - Math.cos(elongation)) / 2;

el.moonData.innerHTML =
`<div class="phaseName">${getPhaseName(phaseFraction)}</div>` +
`–û—Å–≤–µ—â–µ–Ω–Ω–æ—Å—Ç—å: ${(illumination * 100).toFixed(0)}%<br>` +
`–†–∞—Å—Å—Ç–æ—è–Ω–∏–µ: ${moonC.distanceKm.toFixed(0)} –∫–º<br>–ù–∞–∫–ª–æ–Ω: 5.14¬∞`;
}

starsContainer.rotation.y = 0;
milkyWay.rotation.y = 0;
}

let lastFrameT = performance.now();
let cloudOffset = 0;

function animate(t) {
requestAnimationFrame(animate);
const dt = Math.min(0.05, (t - lastFrameT) / 1000);
lastFrameT = t;

updateCelestialPositions();

if (el.chkSun.checked) {
mainGlow.size = 1200 + Math.sin(t * 0.0015) * 16 + Math.cos(t * 0.0005) * 10;
mainStar.size = 500 + Math.sin(t * 0.002) * 12 + Math.cos(t * 0.005) * 6;
const intensity = 0.98 + Math.sin(t * 0.002) * 0.02;
mainStar.color.setHSL(0, 0, intensity);
}

if (issHasFix && el.chkISS.checked) {
const now = new Date();
const jd = getJulianDate(now);
const gmst = getGMST(jd);
const targetPos = getVector(issDisplayData.lat, issDisplayData.lon, issDisplayData.alt, EARTH_RADIUS_UNITS, gmst);

if (!issTargetPos) {
issTargetPos = targetPos.clone();
issModel.position.copy(targetPos);
} else {
issTargetPos.copy(targetPos);
const k = 1 - Math.pow(0.02, dt);
issModel.position.lerp(issTargetPos, k);
}

issModel.lookAt(0, 0, 0);

   if (issVelocityKmS > 0) {
        totalDistanceKm += issVelocityKmS * dt;
        trackingDurationSec += dt;
    }
    
    el.data.innerHTML = `–®–∏—Ä–æ—Ç–∞ : ${issDisplayData.lat.toFixed(4)}¬∞<br>` + 
                        `–î–æ–ª–≥–æ—Ç–∞: ${issDisplayData.lon.toFixed(4)}¬∞<br>` + 
                        `–í—ã—Å–æ—Ç–∞ : ${issDisplayData.alt.toFixed(1)} –∫–º<br>` + 
                        `–°–∫–æ—Ä–æ—Å—Ç—å: ${issVelocityKmS.toFixed(2)} –∫–º/—Å<br>` + 
                        `–¢—Ä–µ–∫ –ú–ö–°: ${totalDistanceKm.toFixed(0)} –∫–º (${trackingDurationSec.toFixed(0)} —Å–µ–∫)`;

updateISSHUD();
}

if (camState.isTransitioning) {
const elapsed = t - camState.startTime;
let alpha = elapsed / camState.duration;

if (alpha >= 1) {
alpha = 1;
camState.isTransitioning = false;
controls.enabled = true;
camState.duration = 2000;

if (cameraMode === 'iss') {
controls.minDistance = 0.2; controls.maxDistance = 20;
} else if (cameraMode === 'moon') {
controls.minDistance = 4; controls.maxDistance = 50;
} else {
controls.minDistance = 12; controls.maxDistance = 200;
}
}
const eased = easeInOutCubic(alpha);

controls.target.lerpVectors(camState.startTarget, camState.endTarget, eased);

const startDist = camState.startPos.length();
const endDist = camState.endPos.length();
const curDist = startDist + (endDist - startDist) * eased;

const arcPos = camState.startPos.clone().lerp(camState.endPos, eased).normalize().multiplyScalar(curDist);
camera.position.copy(arcPos);

} else if (cameraMode === 'iss') {
controls.target.copy(issModel.position);
} else if (cameraMode === 'moon') {
controls.target.copy(moonGroup.position);
}

controls.update();
renderer.render(scene, camera);
}

window.addEventListener("resize", () => {
camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix();
renderer.setSize(window.innerWidth, window.innerHeight);
});

el.loading.style.display = "none";
animate(performance.now());
</script>

</body>
</html>
