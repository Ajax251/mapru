<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Полёт сквозь космос</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            overflow: hidden;
            background: #000;
            font-family: 'Segoe UI', Arial, sans-serif;
        }

        canvas {
            display: block;
            cursor: crosshair;
        }

        .controls {
            position: fixed;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(10, 10, 30, 0.85);
            padding: 20px 30px;
            border-radius: 15px;
            border: 1px solid rgba(100, 150, 255, 0.3);
            backdrop-filter: blur(10px);
            z-index: 100;
            display: flex;
            gap: 30px;
            align-items: flex-start;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .control-group h3 {
            color: #8af;
            font-weight: 300;
            letter-spacing: 2px;
            text-transform: uppercase;
            font-size: 11px;
            text-align: center;
            margin-bottom: 5px;
        }

        .slider-row {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .slider-label {
            color: #aaa;
            font-size: 12px;
            min-width: 70px;
        }

        .slider {
            -webkit-appearance: none;
            width: 120px;
            height: 6px;
            border-radius: 3px;
            background: linear-gradient(90deg, #1a1a3a, #3a3a6a);
            outline: none;
            cursor: pointer;
        }

        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: linear-gradient(135deg, #6af, #a6f);
            cursor: pointer;
            box-shadow: 0 0 15px rgba(100, 170, 255, 0.6);
            transition: transform 0.2s;
        }

        .slider::-webkit-slider-thumb:hover {
            transform: scale(1.2);
        }

        .slider-value {
            color: #6af;
            font-weight: bold;
            font-size: 14px;
            min-width: 60px;
            text-align: right;
        }

        .speed-display {
            text-align: center;
            margin-top: 5px;
        }

        .speed-value {
            color: #fff;
            font-weight: bold;
            font-size: 20px;
        }

        .speed-label {
            color: #888;
            font-size: 11px;
            display: block;
            margin-top: 3px;
        }

        .info {
            position: fixed;
            top: 20px;
            left: 20px;
            color: rgba(255, 255, 255, 0.7);
            font-size: 12px;
            z-index: 100;
            background: rgba(10, 10, 30, 0.7);
            padding: 15px;
            border-radius: 10px;
            border: 1px solid rgba(100, 150, 255, 0.2);
        }

        .info div {
            margin: 5px 0;
        }

        .info span {
            color: #6af;
            font-weight: bold;
        }

        .hints {
            position: fixed;
            top: 20px;
            right: 20px;
            color: rgba(255, 255, 255, 0.5);
            font-size: 11px;
            z-index: 100;
            background: rgba(10, 10, 30, 0.7);
            padding: 15px;
            border-radius: 10px;
            border: 1px solid rgba(100, 150, 255, 0.2);
            line-height: 1.8;
        }

        .hints strong {
            color: #8af;
        }

        .warp-effect {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 50;
            opacity: 0;
            transition: opacity 0.3s;
        }

        .direction-indicator {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 40px;
            height: 40px;
            border: 2px solid rgba(100, 170, 255, 0.3);
            border-radius: 50%;
            pointer-events: none;
            z-index: 60;
        }

        .direction-indicator::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 6px;
            height: 6px;
            background: rgba(100, 170, 255, 0.5);
            border-radius: 50%;
            transform: translate(-50%, -50%);
        }
    </style>
</head>
<body>
    <canvas id="space"></canvas>
    
    <div class="warp-effect" id="warpEffect"></div>
    <div class="direction-indicator"></div>
    
    <div class="info">
        <div>Звёзд: <span id="starCount">0</span></div>
        <div>Галактик: <span id="galaxyCount">0</span></div>
        <div>Туманностей: <span id="nebulaCount">0</span></div>
        <div style="margin-top: 10px; border-top: 1px solid rgba(255,255,255,0.2); padding-top: 10px;">
            Направление: <span id="directionInfo">0°, 0°</span>
        </div>
    </div>

    <div class="hints">
        <strong>Колесо мыши</strong> — скорость<br>
        <strong>Движение мыши</strong> — направление<br>
        <strong>ЛКМ + движение</strong> — быстрый поворот<br>
        <strong>ПКМ</strong> — сброс направления
    </div>
    
    <div class="controls">
        <div class="control-group">
            <h3>Скорость</h3>
            <div class="slider-row">
                <input type="range" class="slider" id="speedSlider" min="0" max="100" value="20" style="width: 150px;">
            </div>
            <div class="speed-display">
                <span class="speed-value" id="speedValue">0.2c</span>
                <span class="speed-label" id="speedLabel">Субсветовая</span>
            </div>
        </div>

        <div class="control-group">
            <h3>Объекты</h3>
            <div class="slider-row">
                <span class="slider-label">Звёзды</span>
                <input type="range" class="slider" id="starSlider" min="100" max="5000" value="2000">
                <span class="slider-value" id="starSliderValue">2000</span>
            </div>
            <div class="slider-row">
                <span class="slider-label">Галактики</span>
                <input type="range" class="slider" id="galaxySlider" min="0" max="50" value="15">
                <span class="slider-value" id="galaxySliderValue">15</span>
            </div>
            <div class="slider-row">
                <span class="slider-label">Туманности</span>
                <input type="range" class="slider" id="nebulaSlider" min="0" max="20" value="8">
                <span class="slider-value" id="nebulaSliderValue">8</span>
            </div>
        </div>

        <div class="control-group">
            <h3>Чувствительность</h3>
            <div class="slider-row">
                <span class="slider-label">Мышь</span>
                <input type="range" class="slider" id="sensitivitySlider" min="1" max="20" value="10">
                <span class="slider-value" id="sensitivityValue">10</span>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('space');
        const ctx = canvas.getContext('2d');
        
        // Элементы управления
        const speedSlider = document.getElementById('speedSlider');
        const speedValue = document.getElementById('speedValue');
        const speedLabel = document.getElementById('speedLabel');
        const starSlider = document.getElementById('starSlider');
        const galaxySlider = document.getElementById('galaxySlider');
        const nebulaSlider = document.getElementById('nebulaSlider');
        const sensitivitySlider = document.getElementById('sensitivitySlider');
        const warpEffect = document.getElementById('warpEffect');
        const starCountEl = document.getElementById('starCount');
        const galaxyCountEl = document.getElementById('galaxyCount');
        const nebulaCountEl = document.getElementById('nebulaCount');
        const directionInfo = document.getElementById('directionInfo');

        let width, height, centerX, centerY;

        function resize() {
            width = canvas.width = window.innerWidth;
            height = canvas.height = window.innerHeight;
            centerX = width / 2;
            centerY = height / 2;
        }
        resize();
        window.addEventListener('resize', resize);

        // Параметры
        let speed = 0.2;
        let targetSpeed = 0.2;
        let sensitivity = 10;

        // Направление (смещение от центра)
        let directionX = 0;
        let directionY = 0;
        let targetDirectionX = 0;
        let targetDirectionY = 0;

        // Мышь
        let mouseX = 0;
        let mouseY = 0;
        let isMouseDown = false;

        // Массивы объектов
        let stars = [];
        let galaxies = [];
        let nebulae = [];

        // Целевые количества
        let targetStarCount = 2000;
        let targetGalaxyCount = 15;
        let targetNebulaCount = 8;

        class Star {
            constructor() {
                this.reset(true);
            }

            reset(initial = false) {
                if (initial) {
                    this.z = Math.random() * 2000;
                } else {
                    this.z = 2000;
                }
                
                const angle = Math.random() * Math.PI * 2;
                const distance = Math.random() * 1500 + 100;
                this.x = Math.cos(angle) * distance;
                this.y = Math.sin(angle) * distance;
                this.pz = this.z;
                this.px = this.x;
                this.py = this.y;
                this.baseSize = Math.random() * 1.5 + 0.5;
                
                const colorType = Math.random();
                if (colorType < 0.6) {
                    this.color = { r: 255, g: 255, b: 255 };
                } else if (colorType < 0.75) {
                    this.color = { r: 255, g: 200, b: 150 };
                } else if (colorType < 0.85) {
                    this.color = { r: 150, g: 180, b: 255 };
                } else if (colorType < 0.92) {
                    this.color = { r: 255, g: 150, b: 100 };
                } else {
                    this.color = { r: 255, g: 100, b: 100 };
                }
            }

            update() {
                this.pz = this.z;
                this.px = this.x;
                this.py = this.y;
                
                this.z -= speed * 50;
                
                // Влияние направления
                this.x += directionX * speed * 20;
                this.y += directionY * speed * 20;

                if (this.z < 1 || 
                    Math.abs(this.x) > 3000 || 
                    Math.abs(this.y) > 3000) {
                    this.reset();
                }
            }

            draw() {
                const sx = (this.x / this.z) * width + centerX;
                const sy = (this.y / this.z) * height + centerY;
                const px = (this.px / this.pz) * width + centerX;
                const py = (this.py / this.pz) * height + centerY;

                const size = (1 - this.z / 2000) * this.baseSize * 3;
                const alpha = (1 - this.z / 2000) * 0.9 + 0.1;

                if (sx < -100 || sx > width + 100 || sy < -100 || sy > height + 100) return;

                if (speed > 0.3) {
                    const trailLength = Math.min(speed * 2, 3);
                    const gradient = ctx.createLinearGradient(px, py, sx, sy);
                    gradient.addColorStop(0, `rgba(${this.color.r}, ${this.color.g}, ${this.color.b}, 0)`);
                    gradient.addColorStop(1, `rgba(${this.color.r}, ${this.color.g}, ${this.color.b}, ${alpha})`);
                    
                    ctx.beginPath();
                    ctx.strokeStyle = gradient;
                    ctx.lineWidth = size * trailLength;
                    ctx.moveTo(px, py);
                    ctx.lineTo(sx, sy);
                    ctx.stroke();
                }

                ctx.beginPath();
                ctx.fillStyle = `rgba(${this.color.r}, ${this.color.g}, ${this.color.b}, ${alpha})`;
                ctx.arc(sx, sy, Math.max(0.5, size), 0, Math.PI * 2);
                ctx.fill();

                if (size > 2 && this.z < 500) {
                    const glowGradient = ctx.createRadialGradient(sx, sy, 0, sx, sy, size * 4);
                    glowGradient.addColorStop(0, `rgba(${this.color.r}, ${this.color.g}, ${this.color.b}, ${alpha * 0.5})`);
                    glowGradient.addColorStop(1, 'transparent');
                    ctx.beginPath();
                    ctx.fillStyle = glowGradient;
                    ctx.arc(sx, sy, size * 4, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
        }

        class Galaxy {
            constructor() {
                this.reset(true);
            }

            reset(initial = false) {
                if (initial) {
                    this.z = Math.random() * 3000 + 500;
                } else {
                    this.z = 4000;
                }
                
                const angle = Math.random() * Math.PI * 2;
                const distance = Math.random() * 2000 + 500;
                this.x = Math.cos(angle) * distance;
                this.y = Math.sin(angle) * distance;
                this.rotation = Math.random() * Math.PI * 2;
                this.rotationSpeed = (Math.random() - 0.5) * 0.02;
                this.size = Math.random() * 100 + 50;
                this.arms = Math.floor(Math.random() * 3) + 2;
                this.type = Math.random() < 0.7 ? 'spiral' : 'elliptical';
                
                const hue = Math.random() * 60 + 200;
                this.hue = hue;
            }

            update() {
                this.z -= speed * 30;
                this.rotation += this.rotationSpeed * speed;
                
                this.x += directionX * speed * 15;
                this.y += directionY * speed * 15;

                if (this.z < 50 || 
                    Math.abs(this.x) > 5000 || 
                    Math.abs(this.y) > 5000) {
                    this.reset();
                }
            }

            draw() {
                const scale = 800 / this.z;
                const sx = (this.x / this.z) * width + centerX;
                const sy = (this.y / this.z) * height + centerY;
                const size = this.size * scale;
                const alpha = Math.min(1, (3500 - this.z) / 2500) * 0.8;

                if (size < 2 || alpha < 0.05) return;
                if (sx < -size || sx > width + size || sy < -size || sy > height + size) return;

                ctx.save();
                ctx.translate(sx, sy);
                ctx.rotate(this.rotation);

                if (this.type === 'spiral') {
                    for (let arm = 0; arm < this.arms; arm++) {
                        const armAngle = (arm / this.arms) * Math.PI * 2;
                        
                        for (let i = 0; i < 40; i++) {
                            const t = i / 40;
                            const spiralAngle = armAngle + t * Math.PI * 2;
                            const r = t * size;
                            const x = Math.cos(spiralAngle) * r;
                            const y = Math.sin(spiralAngle) * r * 0.4;

                            const starSize = (1 - t) * 2 * scale;
                            const starAlpha = alpha * (1 - t * 0.7);

                            ctx.beginPath();
                            ctx.fillStyle = `rgba(200, 220, 255, ${starAlpha})`;
                            ctx.arc(x + (Math.random() - 0.5) * size * 0.1, 
                                   y + (Math.random() - 0.5) * size * 0.05, 
                                   Math.max(0.5, starSize), 0, Math.PI * 2);
                            ctx.fill();
                        }
                    }

                    const coreGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, size * 0.3);
                    coreGradient.addColorStop(0, `rgba(255, 250, 230, ${alpha})`);
                    coreGradient.addColorStop(0.5, `rgba(255, 220, 180, ${alpha * 0.5})`);
                    coreGradient.addColorStop(1, 'transparent');
                    ctx.beginPath();
                    ctx.fillStyle = coreGradient;
                    ctx.ellipse(0, 0, size * 0.3, size * 0.15, 0, 0, Math.PI * 2);
                    ctx.fill();
                } else {
                    const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, size);
                    gradient.addColorStop(0, `rgba(255, 240, 200, ${alpha})`);
                    gradient.addColorStop(0.3, `rgba(255, 200, 150, ${alpha * 0.6})`);
                    gradient.addColorStop(1, 'transparent');
                    ctx.beginPath();
                    ctx.fillStyle = gradient;
                    ctx.ellipse(0, 0, size, size * 0.6, 0, 0, Math.PI * 2);
                    ctx.fill();
                }

                ctx.restore();
            }
        }

        class Nebula {
            constructor() {
                this.reset(true);
            }

            reset(initial = false) {
                if (initial) {
                    this.z = Math.random() * 4000 + 1000;
                } else {
                    this.z = 6000;
                }
                
                const angle = Math.random() * Math.PI * 2;
                const distance = Math.random() * 3000 + 1000;
                this.x = Math.cos(angle) * distance;
                this.y = Math.sin(angle) * distance;
                this.size = Math.random() * 400 + 200;
                
                this.hue = Math.random() * 360;
                
                this.blobs = [];
                for (let i = 0; i < 5; i++) {
                    this.blobs.push({
                        offsetX: (Math.random() - 0.5) * this.size,
                        offsetY: (Math.random() - 0.5) * this.size,
                        size: Math.random() * 0.5 + 0.3
                    });
                }
            }

            update() {
                this.z -= speed * 20;
                
                this.x += directionX * speed * 10;
                this.y += directionY * speed * 10;

                if (this.z < 100 || 
                    Math.abs(this.x) > 8000 || 
                    Math.abs(this.y) > 8000) {
                    this.reset();
                }
            }

            draw() {
                const scale = 1000 / this.z;
                const sx = (this.x / this.z) * width + centerX;
                const sy = (this.y / this.z) * height + centerY;
                const size = this.size * scale;
                const alpha = Math.min(0.4, (5000 - this.z) / 5000);

                if (size < 10 || alpha < 0.02) return;

                for (const blob of this.blobs) {
                    const bx = sx + blob.offsetX * scale;
                    const by = sy + blob.offsetY * scale;
                    const bSize = size * blob.size;

                    if (bx < -bSize || bx > width + bSize || by < -bSize || by > height + bSize) continue;

                    const gradient = ctx.createRadialGradient(bx, by, 0, bx, by, bSize);
                    gradient.addColorStop(0, `hsla(${this.hue}, 80%, 60%, ${alpha})`);
                    gradient.addColorStop(0.4, `hsla(${(this.hue + 30) % 360}, 70%, 40%, ${alpha * 0.5})`);
                    gradient.addColorStop(1, 'transparent');

                    ctx.beginPath();
                    ctx.fillStyle = gradient;
                    ctx.arc(bx, by, bSize, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
        }

        // Функции управления количеством объектов
        function updateStarCount(count) {
            while (stars.length < count) {
                stars.push(new Star());
            }
            while (stars.length > count) {
                stars.pop();
            }
        }

        function updateGalaxyCount(count) {
            while (galaxies.length < count) {
                galaxies.push(new Galaxy());
            }
            while (galaxies.length > count) {
                galaxies.pop();
            }
        }

        function updateNebulaCount(count) {
            while (nebulae.length < count) {
                nebulae.push(new Nebula());
            }
            while (nebulae.length > count) {
                nebulae.pop();
            }
        }

        // Инициализация
        updateStarCount(targetStarCount);
        updateGalaxyCount(targetGalaxyCount);
        updateNebulaCount(targetNebulaCount);

        // События слайдеров
        speedSlider.addEventListener('input', (e) => {
            targetSpeed = e.target.value / 100;
        });

        starSlider.addEventListener('input', (e) => {
            targetStarCount = parseInt(e.target.value);
            document.getElementById('starSliderValue').textContent = targetStarCount;
            updateStarCount(targetStarCount);
        });

        galaxySlider.addEventListener('input', (e) => {
            targetGalaxyCount = parseInt(e.target.value);
            document.getElementById('galaxySliderValue').textContent = targetGalaxyCount;
            updateGalaxyCount(targetGalaxyCount);
        });

        nebulaSlider.addEventListener('input', (e) => {
            targetNebulaCount = parseInt(e.target.value);
            document.getElementById('nebulaSliderValue').textContent = targetNebulaCount;
            updateNebulaCount(targetNebulaCount);
        });

        sensitivitySlider.addEventListener('input', (e) => {
            sensitivity = parseInt(e.target.value);
            document.getElementById('sensitivityValue').textContent = sensitivity;
        });

        // События мыши
        canvas.addEventListener('mousemove', (e) => {
            mouseX = e.clientX;
            mouseY = e.clientY;
            
            const factor = isMouseDown ? 2 : 0.5;
            targetDirectionX = ((mouseX - centerX) / centerX) * sensitivity * factor;
            targetDirectionY = ((mouseY - centerY) / centerY) * sensitivity * factor;
        });

        canvas.addEventListener('mousedown', (e) => {
            if (e.button === 0) {
                isMouseDown = true;
            }
        });

        canvas.addEventListener('mouseup', (e) => {
            if (e.button === 0) {
                isMouseDown = false;
            }
        });

        canvas.addEventListener('mouseleave', () => {
            isMouseDown = false;
            targetDirectionX = 0;
            targetDirectionY = 0;
        });

        // Правая кнопка — сброс направления
        canvas.addEventListener('contextmenu', (e) => {
            e.preventDefault();
            targetDirectionX = 0;
            targetDirectionY = 0;
        });

        // Колесо мыши — скорость
        canvas.addEventListener('wheel', (e) => {
            e.preventDefault();
            const delta = -e.deltaY * 0.001;
            targetSpeed = Math.max(0, Math.min(1, targetSpeed + delta));
            speedSlider.value = targetSpeed * 100;
        });

        function updateSpeedDisplay() {
            let displayValue, label;
            
            if (speed < 0.1) {
                displayValue = (speed * 1000).toFixed(0) + ' км/с';
                label = 'Импульсная тяга';
            } else if (speed < 0.3) {
                displayValue = (speed).toFixed(2) + 'c';
                label = 'Субсветовая';
            } else if (speed < 0.6) {
                displayValue = (speed).toFixed(2) + 'c';
                label = 'Релятивистская';
            } else if (speed < 0.9) {
                displayValue = (speed).toFixed(2) + 'c';
                label = 'Околосветовая';
            } else {
                displayValue = 'ВАРП ' + (1 + (speed - 0.9) * 10).toFixed(1);
                label = 'Сверхсветовой!';
            }

            speedValue.textContent = displayValue;
            speedLabel.textContent = label;

            if (speed > 0.7) {
                const warpIntensity = (speed - 0.7) / 0.3;
                warpEffect.style.opacity = warpIntensity * 0.4;
                warpEffect.style.background = `radial-gradient(ellipse at center, 
                    transparent 0%, 
                    transparent ${70 - warpIntensity * 40}%, 
                    rgba(100, 150, 255, ${warpIntensity * 0.4}) 100%)`;
            } else {
                warpEffect.style.opacity = 0;
            }
        }

        function updateDirectionDisplay() {
            const angleX = (directionX * 10).toFixed(1);
            const angleY = (directionY * 10).toFixed(1);
            directionInfo.textContent = `${angleX}°, ${angleY}°`;
        }

        // Анимация
        function animate() {
            // Плавные переходы
            speed += (targetSpeed - speed) * 0.05;
            directionX += (targetDirectionX - directionX) * 0.08;
            directionY += (targetDirectionY - directionY) * 0.08;

            // Очистка
            if (speed < 0.15) {
                ctx.fillStyle = '#000005';
                ctx.fillRect(0, 0, width, height);
            } else {
                ctx.fillStyle = `rgba(0, 0, 5, ${0.1 + (1 - speed) * 0.2})`;
                ctx.fillRect(0, 0, width, height);
            }

            // Рисуем объекты
            for (const nebula of nebulae) {
                nebula.update();
                nebula.draw();
            }

            for (const galaxy of galaxies) {
                galaxy.update();
                galaxy.draw();
            }

            for (const star of stars) {
                star.update();
                star.draw();
            }

            // Центральный эффект при высокой скорости
            if (speed > 0.5) {
                const glowIntensity = (speed - 0.5) / 0.5;
                const gradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, 150);
                gradient.addColorStop(0, `rgba(200, 220, 255, ${glowIntensity * 0.15})`);
                gradient.addColorStop(1, 'transparent');
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(centerX, centerY, 150, 0, Math.PI * 2);
                ctx.fill();
            }

            // Эффект направления — лёгкое виньетирование
            if (Math.abs(directionX) > 0.5 || Math.abs(directionY) > 0.5) {
                const intensity = Math.max(Math.abs(directionX), Math.abs(directionY)) / 10;
                const gradient = ctx.createRadialGradient(
                    centerX - directionX * 50, 
                    centerY - directionY * 50, 
                    0, 
                    centerX, 
                    centerY, 
                    Math.max(width, height) * 0.7
                );
                gradient.addColorStop(0, 'transparent');
                gradient.addColorStop(1, `rgba(0, 0, 20, ${intensity})`);
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, width, height);
            }

            updateSpeedDisplay();
            updateDirectionDisplay();

            starCountEl.textContent = stars.length;
            galaxyCountEl.textContent = galaxies.length;
            nebulaCountEl.textContent = nebulae.length;

            requestAnimationFrame(animate);
        }

        animate();
    </script>
</body>
</html>