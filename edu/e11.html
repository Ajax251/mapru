<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no, maximum-scale=1.0" />
<link rel="icon" href="worldwide.png" type="image/png" />
<title>Земля 3D</title>
<style>
:root {
--glass-bg: rgba(12, 20, 40, 0.65);
--glass-border: rgba(100, 220, 255, 0.15);
--glass-highlight: rgba(255, 255, 255, 0.05);
--neon-cyan: #00f3ff;
--neon-blue: #0066ff;
--gold: #ffd700;
--red-ui: #ff3366;
--text-main: #ffffff;
--text-muted: #8ba4b8;
}


html, body {
width: 100%; height: 100%; margin: 0; padding: 0; overflow: hidden;
background-color: #000;
font-family: "Segoe UI", "Roboto", system-ui, sans-serif;
touch-action: none;
}

canvas { display: block; width: 100%; height: 100%; outline: none; }

#loading {
position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
color: var(--neon-cyan); letter-spacing: 3px; font-size: 14px;
pointer-events: none; text-transform: uppercase; font-weight: 600;
user-select: none; white-space: nowrap; z-index: 10;
text-shadow: 0 0 15px rgba(0, 243, 255, 0.4);
animation: pulse 2s infinite;
}
@keyframes pulse { 0% { opacity: 0.6; } 50% { opacity: 1; } 100% { opacity: 0.6; } }

.panel-glass {
background: var(--glass-bg);
backdrop-filter: blur(16px);
-webkit-backdrop-filter: blur(16px);
border: 1px solid var(--glass-border);
border-radius: 16px;
box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5), inset 0 0 0 1px var(--glass-highlight);
color: var(--text-main);
transition: all 0.4s ease;
}

#ui {
position: absolute; bottom: 20px; right: 20px; width: 280px;
padding: 0; display: flex; flex-direction: column; z-index: 5;
}

.ui-header {
background: rgba(0, 10, 20, 0.3);
padding: 20px 20px 15px 20px;
border-bottom: 1px solid var(--glass-border);
text-align: center;
border-radius: 16px 16px 0 0;
}
#time-now {
font-size: 32px; font-weight: 300; letter-spacing: 1px;
color: #fff; text-shadow: 0 0 10px rgba(255,255,255,0.3);
font-variant-numeric: tabular-nums; line-height: 1; margin-bottom: 4px;
}
#date-now {
font-size: 11px; color: var(--neon-cyan); text-transform: uppercase;
letter-spacing: 4px; font-weight: 700; opacity: 0.9;
text-shadow: 0 0 8px rgba(0, 243, 255, 0.4);
}

.ui-controls { padding: 15px 20px; display: flex; flex-direction: column; gap: 12px; }

.row { display: flex; justify-content: space-between; align-items: center; font-size: 14px; font-weight: 500; letter-spacing: 0.5px; }

.switch { position: relative; width: 44px; height: 24px; flex: 0 0 auto; }
.switch input { opacity: 0; width: 0; height: 0; }
.slider {
position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0;
background-color: rgba(255,255,255,0.1); border-radius: 34px; transition: .3s;
border: 1px solid rgba(255,255,255,0.1);
}
.slider:before {
position: absolute; content: ""; height: 16px; width: 16px; left: 3px; bottom: 3px;
background-color: #ccc; border-radius: 50%; transition: .3s;
box-shadow: 0 2px 4px rgba(0,0,0,0.3);
}
input:checked + .slider { background-color: rgba(0, 243, 255, 0.25); border-color: var(--neon-cyan); }
input:checked + .slider:before { transform: translateX(20px); background-color: var(--neon-cyan); box-shadow: 0 0 10px var(--neon-cyan); }

#data {
font-family: "Consolas", "Monaco", monospace; font-size: 11px; color: var(--neon-cyan);
margin: 5px 20px 20px 20px; padding-top: 12px;
border-top: 1px solid rgba(255,255,255,0.1); line-height: 1.7; min-height: 72px;
}

#moonInfo {
position: absolute; top: 20px; left: 20px; width: 260px;
padding: 20px; display: none; z-index: 5;
}
.moonTitle {
font-size: 13px; font-weight: 700; color: var(--gold); text-align: center; margin-bottom: 15px;
text-transform: uppercase; letter-spacing: 3px; text-shadow: 0 0 10px rgba(255, 204, 0, 0.3);
}
#moonPhase {
width: 140px; height: 140px; margin: 0 auto 15px auto; border-radius: 50%; overflow: hidden;
box-shadow: 0 0 40px rgba(255,255,255,0.05); border: 1px solid rgba(255,255,255,0.1); background: #000;
}
#moonData {
font-family: "Consolas", monospace; font-size: 11px; color: #ddd; line-height: 1.6;
text-align: center; min-height: 76px;
}
.phaseName { font-size: 13px; color: var(--gold); font-weight: 700; margin-bottom: 6px; }

#btn-clear-cache {
position: absolute; bottom: 20px; left: 20px; width: 44px; height: 44px;
background: var(--glass-bg); border: 1px solid rgba(255, 80, 80, 0.3);
color: #ff5555; border-radius: 50%; cursor: pointer; z-index: 100;
display: flex; justify-content: center; align-items: center;
backdrop-filter: blur(8px); box-shadow: 0 4px 15px rgba(0,0,0,0.3);
transition: all 0.3s;
}
#btn-clear-cache:hover {
background: rgba(255, 50, 50, 0.15); border-color: #ff5555;
box-shadow: 0 0 20px rgba(255, 50, 50, 0.4); transform: rotate(90deg);
}

#btn-exit-iss {
position: absolute; bottom: 40px; left: 50%; transform: translateX(-50%) translateY(100px);
background: rgba(0, 0, 0, 0.6); border: 1px solid var(--red-ui); color: var(--red-ui);
padding: 12px 28px; border-radius: 30px; font-size: 13px; font-weight: 700; letter-spacing: 2px;
cursor: pointer; z-index: 20; backdrop-filter: blur(10px); text-transform: uppercase;
transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275); opacity: 0; pointer-events: none;
box-shadow: 0 0 15px rgba(255, 51, 102, 0.2);
}
#btn-exit-iss:hover { background: var(--red-ui); color: white; box-shadow: 0 0 30px rgba(255, 51, 102, 0.6); }
#btn-exit-iss.visible { transform: translateX(-50%) translateY(0); opacity: 1; pointer-events: auto; }

.iss-hint {
position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
color: var(--neon-cyan); font-size: 11px; text-transform: uppercase; letter-spacing: 1.5px;
opacity: 0; transition: opacity 0.3s; pointer-events: none; z-index: 8; font-weight: 600;
text-shadow: 0 0 10px var(--neon-cyan); background: rgba(0,0,0,0.6);
padding: 6px 12px; border-radius: 6px; border: 1px solid var(--glass-border);
}

#btn-exit-moon {
position: absolute; bottom: 40px; left: 50%; transform: translateX(-50%) translateY(100px);
background: rgba(0, 0, 0, 0.6); border: 1px solid var(--gold); color: var(--gold);
padding: 12px 28px; border-radius: 30px; font-size: 13px; font-weight: 700; letter-spacing: 2px;
cursor: pointer; z-index: 20; backdrop-filter: blur(10px); text-transform: uppercase;
transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275); opacity: 0; pointer-events: none;
box-shadow: 0 0 15px rgba(255, 215, 0, 0.2);
}
#btn-exit-moon:hover { background: var(--gold); color: #000; box-shadow: 0 0 30px rgba(255, 215, 0, 0.6); }
#btn-exit-moon.visible { transform: translateX(-50%) translateY(0); opacity: 1; pointer-events: auto; }

.iss-hud {
position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
width: 80%; height: 80%; pointer-events: none; z-index: 4;
display: none; font-family: "Consolas", "Monaco", monospace;
}

.iss-hud::before {
content: ''; position: absolute; top: 0; left: 0; right: 0; bottom: 0;
border: 1px solid rgba(0, 243, 255, 0.1);
background:
linear-gradient(90deg, rgba(0,243,255,0.1) 1px, transparent 1px) 50% 50% / 20% 100% no-repeat,
linear-gradient(rgba(0,243,255,0.1) 1px, transparent 1px) 50% 50% / 100% 20% no-repeat;
mask-image: radial-gradient(circle, transparent 30%, black 100%);
-webkit-mask-image: radial-gradient(circle, transparent 30%, black 100%);
}

.hud-corner {
position: absolute; width: 40px; height: 40px;
border: 2px solid var(--neon-cyan); opacity: 0.6;
box-shadow: 0 0 10px var(--neon-cyan);
}
.hc-tl { top: 0; left: 0; border-right: 0; border-bottom: 0; }
.hc-tr { top: 0; right: 0; border-left: 0; border-bottom: 0; }
.hc-bl { bottom: 0; left: 0; border-right: 0; border-top: 0; }
.hc-br { bottom: 0; right: 0; border-left: 0; border-top: 0; }

.hud-panel {
position: absolute; background: rgba(0, 10, 20, 0.6);
border: 1px solid var(--neon-cyan); padding: 10px 15px;
color: var(--neon-cyan); font-size: 12px; line-height: 1.6;
backdrop-filter: blur(4px); text-shadow: 0 0 5px var(--neon-cyan);
}
.hp-left { top: 50%; left: 20px; transform: translateY(-50%); text-align: left; border-left: 4px solid var(--neon-cyan); }
.hp-right { top: 50%; right: 20px; transform: translateY(-50%); text-align: right; border-right: 4px solid var(--neon-cyan); }
.hp-bottom { bottom: 40px; left: 50%; transform: translateX(-50%); text-align: center; border-bottom: 4px solid var(--neon-cyan); width: 300px; }

.hud-value { font-size: 18px; font-weight: 700; color: #fff; }
.hud-label { font-size: 10px; color: var(--text-muted); text-transform: uppercase; letter-spacing: 1px; }
.hud-warn { color: #ff3366; text-shadow: 0 0 8px #ff3366; }

@media (max-width: 720px) {
#ui { width: 240px; right: 10px; bottom: 10px; }
.ui-header { padding: 15px; }
#time-now { font-size: 26px; }
#moonInfo { width: 220px; left: 10px; top: 10px; padding: 15px; }
#moonPhase { width: 100px; height: 100px; }
#btn-clear-cache { bottom: 15px; left: 15px; width: 38px; height: 38px; }
}
</style>

</head>
<body>
<div id="loading">''</div>
<div class="iss-hint" id="issHint">Двойной клик: Стыковка</div>

<div id="moonInfo" class="panel-glass">
<div class="moonTitle">Луна</div>
<div id="moonPhase"><canvas id="moonCanvas" width="140" height="140"></canvas></div>
<div id="moonData">Ожидание данных...</div>
</div>

<div id="ui" class="panel-glass">
<div class="ui-header">
<div id="time-now">00:00:00</div>
<div id="date-now">DD.MM.YYYY</div>
</div>

<div class="ui-controls">
  <div class="row">
    <span>Солнце</span>
    <label class="switch"><input type="checkbox" id="chk-sun" /><span class="slider"></span></label>
  </div>
  <div class="row">
    <span>Луна</span>
    <label class="switch"><input type="checkbox" id="chk-moon" /><span class="slider"></span></label>
  </div>
  <div class="row">
    <span>Галактика</span>
    <label class="switch"><input type="checkbox" id="chk-galaxy" /><span class="slider"></span></label>
  </div>
  <div class="row">
    <span>Облака</span>
    <label class="switch"><input type="checkbox" id="chk-clouds" /><span class="slider"></span></label>
  </div>
  <div class="row">
    <span>МКС</span>
    <label class="switch"><input type="checkbox" id="chk-iss" /><span class="slider"></span></label>
  </div>
</div>

<div id="data">МКС выключена</div>
</div>

<div id="iss-hud" class="iss-hud">
<div class="hud-corner hc-tl"></div>
<div class="hud-corner hc-tr"></div>
<div class="hud-corner hc-bl"></div>
<div class="hud-corner hc-br"></div>

<div class="hud-panel hp-left">
  <div class="hud-label">Координаты</div>
  <div id="hud-lat" class="hud-value">LAT 00.0000</div>
  <div id="hud-lon" class="hud-value">LON 00.0000</div>
  <br>
  <div class="hud-label">Высота</div>
  <div id="hud-alt" class="hud-value">420 KM</div>
</div>

<div class="hud-panel hp-right">
  <div class="hud-label">Солнечные панели</div>
  <div id="hud-solar" class="hud-value">100%</div>
  <br>
  <div class="hud-label">Скорость</div>
  <div id="hud-vel" class="hud-value">27,600 km/h</div>
</div>

<div class="hud-panel hp-bottom">
    <div id="hud-location" class="hud-value" style="font-size: 14px; color: #ffd700; margin-bottom: 8px; text-transform: uppercase; letter-spacing: 1px; min-height: 20px;">
        Сканирование местности...
    </div>
    <div id="hud-status" style="font-size:10px; margin-top:5px;">STATUS OK</div>
</div>
</div>

<button id="btn-clear-cache" title="Очистить кэш текстур">
<svg viewBox="0 0 24 24" width="20" height="20">
<ellipse cx="12" cy="5" rx="9" ry="3" fill="none" stroke="currentColor" stroke-width="2"></ellipse>
<path d="M21 12c0 1.66-4 3-9 3s-9-1.34-9-3" fill="none" stroke="currentColor" stroke-width="2"></path>
<path d="M3 5v14c0 1.66 4 3 9 3 1.2 0 2.33-.08 3.39-.23" fill="none" stroke="currentColor" stroke-width="2"></path>
<line x1="21" y1="21" x2="17" y2="17" stroke="currentColor" stroke-width="2.5" stroke-linecap="round"></line>
<line x1="17" y1="21" x2="21" y2="17" stroke="currentColor" stroke-width="2.5" stroke-linecap="round"></line>
</svg>
</button>


<button id="btn-exit-iss">Отстыковаться</button>
<button id="btn-exit-moon">Вернуться к Земле</button>

<script type="importmap">
{
"imports": {
"three": "https://unpkg.com/three@0.160.0/build/three.module.js",
"three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
}
}
</script>

<script type="module">
import * as THREE from "three";
import { OrbitControls } from "three/addons/controls/OrbitControls.js";
import { Lensflare, LensflareElement } from 'three/addons/objects/Lensflare.js';

let lastGeoCheckTime = 0;
let userMarker = null;

const DB_NAME = 'EarthISS_DB';
const STORE_NAME = 'textures';

const dbPromise = new Promise((resolve, reject) => {
const request = indexedDB.open(DB_NAME, 1);
request.onupgradeneeded = (e) => { e.target.result.createObjectStore(STORE_NAME); };
request.onsuccess = (e) => resolve(e.target.result);
request.onerror = (e) => reject(e);
});

const internalLoader = new THREE.TextureLoader();

function loadTextureWithCache(url) {
const tex = new THREE.Texture();
const image = new Image();
image.crossOrigin = "Anonymous";
tex.image = image;
image.onload = () => { tex.needsUpdate = true; };

dbPromise.then(db => {
const tx = db.transaction(STORE_NAME, 'readonly');
const store = tx.objectStore(STORE_NAME);
const request = store.get(url);
request.onsuccess = () => {
if (request.result) {
image.src = URL.createObjectURL(request.result);
} else {
fetch(url).then(res => res.blob()).then(blob => {
const txWrite = db.transaction(STORE_NAME, 'readwrite');
txWrite.objectStore(STORE_NAME).put(blob, url);
image.src = URL.createObjectURL(blob);
}).catch(() => {
internalLoader.load(url, (t) => { tex.image = t.image; tex.needsUpdate = true; });
});
}
};
}).catch(() => {
internalLoader.load(url, (t) => { tex.image = t.image; tex.needsUpdate = true; });
});
return tex;
}

const el = {
loading: document.getElementById("loading"),
data: document.getElementById("data"),
moonInfo: document.getElementById("moonInfo"),
moonData: document.getElementById("moonData"),
moonCanvas: document.getElementById("moonCanvas"),
chkSun: document.getElementById("chk-sun"),
chkISS: document.getElementById("chk-iss"),
chkMoon: document.getElementById("chk-moon"),
chkClouds: document.getElementById("chk-clouds"),
chkGalaxy: document.getElementById("chk-galaxy"),
btnExit: document.getElementById("btn-exit-iss"),
btnExitMoon: document.getElementById("btn-exit-moon"),
issHint: document.getElementById("issHint"),
ui: document.getElementById("ui"),
btnClear: document.getElementById("btn-clear-cache"),
timeNow: document.getElementById('time-now'),
dateNow: document.getElementById('date-now'),
issHud: document.getElementById("iss-hud"),
hudLat: document.getElementById("hud-lat"),
hudLon: document.getElementById("hud-lon"),
hudAlt: document.getElementById("hud-alt"),
hudSolar: document.getElementById("hud-solar"),
hudVel: document.getElementById("hud-vel"),
hudStatus: document.getElementById("hud-status"),
hudLocation: document.getElementById("hud-location")
};

el.btnClear.addEventListener('click', () => {
el.btnClear.style.transform = "scale(0.9)";
setTimeout(() => el.btnClear.style.transform = "", 150);
const req = indexedDB.deleteDatabase(DB_NAME);
req.onsuccess = () => { location.reload(); };
req.onerror = () => { alert('Ошибка очистки кэша.'); };
req.onblocked = () => { location.reload(); };
});

const scene = new THREE.Scene();
scene.background = new THREE.Color(0x020205);

const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 4000);
camera.position.set(0, 0, 28);

const renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
renderer.outputColorSpace = THREE.SRGBColorSpace;
renderer.toneMapping = THREE.ACESFilmicToneMapping;
renderer.toneMappingExposure = 2.5;
document.body.appendChild(renderer.domElement);

const ambientLight = new THREE.AmbientLight(0x404060, 0.1);
scene.add(ambientLight);

const sunLight = new THREE.DirectionalLight(0xffffff, 2.0);
sunLight.castShadow = true;
scene.add(sunLight);

function createFlareTexture(type, colorVal) {
const size = 512;
const canvas = document.createElement("canvas");
canvas.width = size; canvas.height = size;
const ctx = canvas.getContext("2d");
const cx = size / 2, cy = size / 2;
const c = new THREE.Color(colorVal);
const r = Math.round(c.r * 255), g = Math.round(c.g * 255), b = Math.round(c.b * 255);


let userMarker = null;

function createUserMarker(lat, lon) {
    // Удаляем старую метку
    if (userMarker) {
        earth.remove(userMarker);
        userMarker.traverse((child) => {
            if (child.isMesh) {
                child.geometry.dispose();
                child.material.dispose();
            }
        });
    }

    userMarker = new THREE.Group();

    // Штырек (Cylinder):
    // Сдвигаем геометрию по Y на половину высоты (0.75), 
    // чтобы точка привязки (pivot) была у основания
    const pinGeo = new THREE.CylinderGeometry(0.02, 0.02, 1.5, 8);
    pinGeo.translate(0, 0.75, 0); 
    const pinMat = new THREE.MeshBasicMaterial({ color: 0xff0033 });
    const pin = new THREE.Mesh(pinGeo, pinMat);
    userMarker.add(pin);

    // Шарик сверху
    const ballGeo = new THREE.SphereGeometry(0.12, 16, 16);
    ballGeo.translate(0, 1.5, 0);
    const ballMat = new THREE.MeshBasicMaterial({ color: 0xff0033 });
    const ball = new THREE.Mesh(ballGeo, ballMat);
    userMarker.add(ball);

    // 1. РАСЧЕТ ПОЗИЦИИ
    // Используем ту же функцию, что и МКС.
    // gmst = 0, так как мы прикрепляем объект к самой Земле (earth), 
    // которая уже вращается в animate().
    // Убрал смещение долготы, теперь координаты совпадают с системой МКС.
    const pos = getVector(lat, lon, 0, 10, 0); 
    userMarker.position.copy(pos);

    // 2. ОРИЕНТАЦИЯ
    // Направляем ось Y (штырек) вдоль нормали поверхности (от центра к точке)
    userMarker.quaternion.setFromUnitVectors(
        new THREE.Vector3(0, 1, 0), // Вектор вверх самого объекта
        pos.clone().normalize()     // Нормаль к поверхности сферы в этой точке
    );

    earth.add(userMarker);

    // Обновляем текст в UI
    el.data.innerHTML = `ВАША ЛОКАЦИЯ:<br>LAT: ${lat.toFixed(4)}<br>LON: ${lon.toFixed(4)}`;
    
    // 3. ПЕРЕЛЕТ КАМЕРЫ
    if (cameraMode === 'global' && !camState.isTransitioning) {
        // Нам нужно узнать, где эта точка находится в МИРОВЫХ координатах прямо сейчас,
        // учитывая текущий поворот Земли.
        
        // Берем локальную позицию и применяем текущий поворот контейнера earth
        const worldPos = pos.clone().applyAxisAngle(new THREE.Vector3(0, 1, 0), earth.rotation.y);

        // Ставим камеру на ту же линию, но выше (расстояние 28)
        const targetPos = worldPos.clone().normalize().multiplyScalar(28);

        camState.startPos.copy(camera.position);
        camState.startTarget.copy(controls.target);
        camState.endPos.copy(targetPos);
        camState.endTarget.set(0, 0, 0); // Смотрим в центр Земли
        camState.duration = 2000;
        startTransition();
    }
}

// Обработчик двойного клика (без изменений логики, только вызов функции)
document.querySelector('.ui-header').addEventListener('dblclick', (e) => {
    e.preventDefault();
    if (!navigator.geolocation) {
        alert("Геолокация недоступна");
        return;
    }
    el.loading.innerText = "ОПРЕДЕЛЕНИЕ МЕСТА...";
    el.loading.style.display = "block";

    navigator.geolocation.getCurrentPosition(
        (position) => {
            el.loading.style.display = "none";
            createUserMarker(position.coords.latitude, position.coords.longitude);
        },
        (error) => {
            el.loading.style.display = "none";
            console.error(error);
            alert("Не удалось получить координаты");
        }
    );
});

// Слушатель двойного клика на заголовок
document.querySelector('.ui-header').addEventListener('dblclick', (e) => {
    e.preventDefault(); // Предотвращаем выделение текста
    
    if (!navigator.geolocation) {
        alert("Геолокация не поддерживается вашим браузером.");
        return;
    }

    el.loading.innerText = "ОПРЕДЕЛЕНИЕ МЕСТА...";
    el.loading.style.display = "block";

    navigator.geolocation.getCurrentPosition(
        (position) => {
            el.loading.style.display = "none";
            createUserMarker(position.coords.latitude, position.coords.longitude);
        },
        (error) => {
            el.loading.style.display = "none";
            let msg = "Ошибка геолокации";
            if(error.code === 1) msg = "Доступ к геопозиции запрещен";
            alert(msg);
        }
    );
});
// ---------------------------

ctx.clearRect(0, 0, size, size);

if (type === "glow") {
const grad = ctx.createRadialGradient(cx, cy, 0, cx, cy, size * 0.5);
grad.addColorStop(0, `rgba(${r},${g},${b},1)`);
grad.addColorStop(0.1, `rgba(${r},${g},${b},0.8)`);
grad.addColorStop(0.4, `rgba(${r},${g},${b},0.2)`);
grad.addColorStop(1, "rgba(0,0,0,0)");
ctx.fillStyle = grad; ctx.fillRect(0, 0, size, size);
} else if (type === "star") {
const grad = ctx.createRadialGradient(cx, cy, 0, cx, cy, size * 0.5);
grad.addColorStop(0, `rgba(${r},${g},${b},1)`);
grad.addColorStop(1, "rgba(0,0,0,0)");
ctx.fillStyle = grad;
ctx.globalCompositeOperation = "source-over";
ctx.save(); ctx.translate(cx, cy); ctx.scale(8, 0.4);
const hGrad = ctx.createRadialGradient(0, 0, 0, 0, 0, size/16);
hGrad.addColorStop(0, `rgba(${r},${g},${b},0.8)`); hGrad.addColorStop(1, "rgba(0,0,0,0)");
ctx.fillStyle = hGrad; ctx.beginPath(); ctx.arc(0, 0, size/16, 0, Math.PI*2); ctx.fill(); ctx.restore();
ctx.save(); ctx.translate(cx, cy); ctx.scale(0.4, 8);
ctx.fillStyle = hGrad; ctx.beginPath(); ctx.arc(0, 0, size/16, 0, Math.PI*2); ctx.fill(); ctx.restore();
const centerGrad = ctx.createRadialGradient(cx, cy, 0, cx, cy, size * 0.1);
centerGrad.addColorStop(0, "white"); centerGrad.addColorStop(1, "rgba(0,0,0,0)");
ctx.fillStyle = centerGrad; ctx.beginPath(); ctx.arc(cx, cy, size*0.1, 0, Math.PI*2); ctx.fill();
} else if (type === "lens") {
const grad = ctx.createRadialGradient(cx, cy, 0, cx, cy, size * 0.5);
grad.addColorStop(0, `rgba(${r},${g},${b},0.4)`); grad.addColorStop(0.8, `rgba(${r},${g},${b},0.1)`);
grad.addColorStop(1, "rgba(0,0,0,0)");
ctx.fillStyle = grad;
ctx.beginPath();
for (let i = 0; i < 6; i++) {
const angle = (Math.PI / 3) * i; const R = size * 0.45;
const x = cx + R * Math.cos(angle); const y = cy + R * Math.sin(angle);
if (i === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
}
ctx.closePath(); ctx.fill();
}
const texture = new THREE.CanvasTexture(canvas);
texture.colorSpace = THREE.SRGBColorSpace;
return texture;
}

const texSunGlow = createFlareTexture("glow", 0xffffee);
const texSunStar = createFlareTexture("star", 0xffffff);
const texLensHex = createFlareTexture("lens", 0xffffff);
const lensflare = new Lensflare();

const mainGlow = new LensflareElement(texSunGlow, 1200, 0.0, new THREE.Color(0xffaa55));
const mainStar = new LensflareElement(texSunStar, 500, 0.0, new THREE.Color(0xffffff));

lensflare.addElement(mainGlow);
lensflare.addElement(mainStar);
lensflare.addElement(new LensflareElement(texLensHex, 60, 0.6, new THREE.Color(0xffddaa)));
lensflare.addElement(new LensflareElement(texLensHex, 100, 0.7, new THREE.Color(0xaaccff)));
lensflare.addElement(new LensflareElement(texLensHex, 140, 0.9, new THREE.Color(0xffccaa)));
lensflare.addElement(new LensflareElement(texLensHex, 300, 1.2, new THREE.Color(0x5555aa)));

sunLight.add(lensflare);
lensflare.visible = false;

const controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true; controls.dampingFactor = 0.08;
controls.minDistance = 12; controls.maxDistance = 200;
controls.enablePan = false; controls.rotateSpeed = 0.5; controls.enableZoom = true;

renderer.domElement.addEventListener('wheel', (e) => {
e.preventDefault(); e.stopImmediatePropagation();
const currentDistance = controls.target.distanceTo(camera.position);
const zoomScale = e.deltaY > 0 ? 1.05 : 0.95;
let newDistance = currentDistance * zoomScale;
newDistance = Math.max(controls.minDistance, Math.min(controls.maxDistance, newDistance));
const direction = new THREE.Vector3().subVectors(camera.position, controls.target).normalize();
camera.position.copy(controls.target).add(direction.multiplyScalar(newDistance));
}, { passive: false, capture: true });

const earthGroup = new THREE.Group();
scene.add(earthGroup);

const mwGeo = new THREE.SphereGeometry(2500, 64, 64);
const mwMat = new THREE.MeshBasicMaterial({
map: loadTextureWithCache('./textures/milkyway.jpg'),
side: THREE.BackSide, transparent: true, opacity: 0.5, depthWrite: false
});
const milkyWay = new THREE.Mesh(mwGeo, mwMat);
milkyWay.visible = false;
scene.add(milkyWay);

const earthMat = new THREE.MeshPhongMaterial({
map: loadTextureWithCache('./textures/earth-blue-marble.jpg'),
bumpMap: loadTextureWithCache('./textures/earth-topology.png'),
bumpScale: 0.1, specularMap: loadTextureWithCache('./textures/earth-water.png'),
specular: new THREE.Color(0x333333), shininess: 15
});
earthMat.map.colorSpace = THREE.SRGBColorSpace;
const earth = new THREE.Mesh(new THREE.SphereGeometry(10, 64, 64), earthMat);
earthGroup.add(earth);

const nightTexture = loadTextureWithCache('./textures/earth-night.jpg');
nightTexture.colorSpace = THREE.SRGBColorSpace;
const nightUniforms = { tNight: { value: nightTexture }, sunDirection: { value: new THREE.Vector3(1, 0, 0) } };
const nightMat = new THREE.ShaderMaterial({
uniforms: nightUniforms,
vertexShader: `varying vec2 vUv; varying vec3 vNormal; void main() { vUv = uv; vNormal = normalize(mat3(modelMatrix) * normal); gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0); }`,
fragmentShader: `uniform sampler2D tNight; uniform vec3 sunDirection; varying vec2 vUv; varying vec3 vNormal; void main() { vec3 nightColor = texture2D(tNight, vUv).rgb; float lighting = dot(vNormal, sunDirection); float mask = clamp(-lighting + 0.15, 0.0, 1.0); mask = pow(mask, 3.0); gl_FragColor = vec4(nightColor, mask); }`,
transparent: true, blending: THREE.AdditiveBlending, depthWrite: false, side: THREE.FrontSide
});
const earthNight = new THREE.Mesh(new THREE.SphereGeometry(10.01, 64, 64), nightMat);
earthGroup.add(earthNight);

const cloudMat = new THREE.MeshPhongMaterial({
map: loadTextureWithCache('./textures/earth-clouds.jpg'),
transparent: true, opacity: 0.8, blending: THREE.AdditiveBlending, side: THREE.DoubleSide, depthWrite: false
});
const clouds = new THREE.Mesh(new THREE.SphereGeometry(10.15, 64, 64), cloudMat);
earthGroup.add(clouds);
clouds.visible = false;

const atmoMat = new THREE.ShaderMaterial({
vertexShader: `varying vec3 vN; void main(){vN=normalize(normalMatrix*normal);gl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.0);}`,
fragmentShader: `varying vec3 vN; void main(){float i=pow(0.5-dot(vN,vec3(0,0,1)),3.0);gl_FragColor=vec4(0.3,0.6,1.0,1.0)*i*1.3;}`,
blending: THREE.AdditiveBlending, side: THREE.BackSide, transparent: true, depthWrite: false
});
const atmosphere = new THREE.Mesh(new THREE.SphereGeometry(10.3, 64, 64), atmoMat);
scene.add(atmosphere);

function createStars(count = 5000) {
const geo = new THREE.BufferGeometry();
const pos = new Float32Array(count * 3);
for (let i = 0; i < count; i++) {
const r = 300 + Math.random() * 900;
const theta = 2 * Math.PI * Math.random();
const phi = Math.acos(2 * Math.random() - 1);
pos[i * 3] = r * Math.sin(phi) * Math.cos(theta);
pos[i * 3 + 1] = r * Math.cos(phi);
pos[i * 3 + 2] = r * Math.sin(phi) * Math.sin(theta);
}
geo.setAttribute("position", new THREE.BufferAttribute(pos, 3));
const mat = new THREE.PointsMaterial({ color: 0xffffff, size: 0.5, transparent: true, opacity: 0.8, depthWrite: false });
return new THREE.Points(geo, mat);
}
const starsContainer = createStars();
scene.add(starsContainer);

const moonGroup = new THREE.Group();
moonGroup.visible = false;
scene.add(moonGroup);

const moonUrl = "./textures/moon-color.jpg";
const moonImg2D = new Image(); moonImg2D.src = moonUrl;

const moon3DMat = new THREE.MeshPhongMaterial({
map: loadTextureWithCache(moonUrl),
bumpMap: loadTextureWithCache("./textures/moon-bump.jpg"),
bumpScale: 0.06, shininess: 2, color: 0xffffff
});
moon3DMat.map.colorSpace = THREE.SRGBColorSpace;
const moon = new THREE.Mesh(new THREE.SphereGeometry(2.7, 64, 64), moon3DMat);
moonGroup.add(moon);

const issContainer = new THREE.Group();
scene.add(issContainer);
issContainer.visible = false;

function buildDetailedISS() {
const iss = new THREE.Group();
const bodyMat = new THREE.MeshPhongMaterial({ color: 0xeeeeee, shininess: 80, specular: 0x444444 });
const darkMat = new THREE.MeshPhongMaterial({ color: 0x222222, shininess: 50 });
const solarMat = new THREE.MeshPhongMaterial({ color: 0x3333aa, emissive: 0x050520, shininess: 100, specular: 0x8888ff, side: THREE.DoubleSide });

const zvezda = new THREE.Mesh(new THREE.CylinderGeometry(0.06, 0.06, 0.4, 12), bodyMat); zvezda.rotation.z = Math.PI / 2; iss.add(zvezda);
const zarya = new THREE.Mesh(new THREE.CylinderGeometry(0.065, 0.065, 0.45, 12), bodyMat); zarya.rotation.z = Math.PI / 2; zarya.position.x = 0.45; iss.add(zarya);
const unity = new THREE.Mesh(new THREE.CylinderGeometry(0.07, 0.07, 0.2, 12), bodyMat); unity.rotation.z = Math.PI / 2; unity.position.x = 0.8; iss.add(unity);
const destiny = new THREE.Mesh(new THREE.CylinderGeometry(0.065, 0.065, 0.35, 12), bodyMat); destiny.rotation.z = Math.PI / 2; destiny.position.x = 1.1; iss.add(destiny);
const truss = new THREE.Mesh(new THREE.BoxGeometry(0.04, 3.5, 0.04), bodyMat); truss.position.x = 0.9; iss.add(truss);

function createSolarWing(yPos) {
const wingGroup = new THREE.Group(); wingGroup.position.set(0.9, yPos, 0);
const joint = new THREE.Mesh(new THREE.CylinderGeometry(0.03, 0.03, 0.1, 8), darkMat); wingGroup.add(joint);
const panelGeo = new THREE.BoxGeometry(0.3, 1.0, 0.01);
const p1 = new THREE.Mesh(panelGeo, solarMat); p1.position.set(0.2, 0, 0);
const p2 = new THREE.Mesh(panelGeo, solarMat); p2.position.set(-0.2, 0, 0);
wingGroup.add(p1); wingGroup.add(p2); wingGroup.rotation.x = Math.PI / 4;
return wingGroup;
}
iss.add(createSolarWing(1.6)); iss.add(createSolarWing(1.2)); iss.add(createSolarWing(-1.2)); iss.add(createSolarWing(-1.6));
const radGeo = new THREE.BoxGeometry(0.2, 0.6, 0.01);
const rad1 = new THREE.Mesh(radGeo, bodyMat); rad1.position.set(0.9, 0.5, -0.15); rad1.rotation.x = -0.5; iss.add(rad1);
const rad2 = new THREE.Mesh(radGeo, bodyMat); rad2.position.set(0.9, -0.5, -0.15); rad2.rotation.x = -0.5; iss.add(rad2);
return iss;
}

const issModel = buildDetailedISS();
issModel.scale.set(0.30, 0.30, 0.30);
issContainer.add(issModel);

const MAX_POINTS = 2000;
const trailGeo = new THREE.BufferGeometry();
const trailPos = new Float32Array(MAX_POINTS * 3);
trailGeo.setAttribute("position", new THREE.BufferAttribute(trailPos, 3));
trailGeo.setDrawRange(0, 0);
const trailMat = new THREE.LineBasicMaterial({ color: 0x00ffff, opacity: 1.0 });
const trailLine = new THREE.Line(trailGeo, trailMat);
earth.add(trailLine);

const DEG_TO_RAD = Math.PI / 180;
const EPSILON = 23.43929 * DEG_TO_RAD;

function getJulianDate(date) { return (date.getTime() / 86400000) + 2440587.5; }

function getGMST(jd) {
const T = (jd - 2451545.0) / 36525.0;
let st = 280.46061837 + 360.98564736629 * (jd - 2451545.0) + 0.000387933 * T * T - T * T * T / 38710000.0;
st = st % 360;
if (st < 0) st += 360;
return st * DEG_TO_RAD;
}

function getSolarCoordinates(jd) {
const n = jd - 2451545.0;
const L = (280.466 + 0.98564736 * n) % 360;
const g = (357.528 + 0.98560028 * n) % 360;
const L_rad = L * DEG_TO_RAD; const g_rad = g * DEG_TO_RAD;
const lambda = L + 1.915 * Math.sin(g_rad) + 0.020 * Math.sin(2 * g_rad);
const lambda_rad = lambda * DEG_TO_RAD;
const X_ecl = Math.cos(lambda_rad);
const Y_ecl = Math.cos(EPSILON) * Math.sin(lambda_rad);
const Z_ecl = Math.sin(EPSILON) * Math.sin(lambda_rad);
return { x: X_ecl, y: Y_ecl, z: Z_ecl };
}

function getLunarCoordinates(jd) {
const T = (jd - 2451545.0) / 36525.0;
const L_0 = (218.3164477 + 481267.88123421 * T) * DEG_TO_RAD;
const D = (297.8501921 + 445267.1114034 * T) * DEG_TO_RAD;
const M = (134.9633964 + 477198.8675055 * T) * DEG_TO_RAD;
const F = (93.2720950 + 483202.0175233 * T) * DEG_TO_RAD;
const lambda = L_0 + 0.10976 * Math.sin(M) - 0.02224 * Math.sin(M - 2 * D) + 0.01148 * Math.sin(2 * D);
const beta = 0.0895 * Math.sin(F) + 0.0049 * Math.sin(M + F) - 0.0048 * Math.sin(M - F);
const dist = 385000.56 - 20905.0 * Math.cos(M);
const cosB = Math.cos(beta);
const x_ecl = cosB * Math.cos(lambda);
const y_ecl = cosB * Math.sin(lambda);
const z_ecl = Math.sin(beta);
const x_eq = x_ecl;
const y_eq = y_ecl * Math.cos(EPSILON) - z_ecl * Math.sin(EPSILON);
const z_eq = y_ecl * Math.sin(EPSILON) + z_ecl * Math.cos(EPSILON);
return { x: x_eq, y: y_eq, z: z_eq, distanceKm: dist };
}

const moonCtx = el.moonCanvas.getContext("2d"), moonW = el.moonCanvas.width, moonH = el.moonCanvas.height;
const moonMaskCanvas = document.createElement("canvas"); moonMaskCanvas.width = moonW; moonMaskCanvas.height = moonH;
const moonMaskCtx = moonMaskCanvas.getContext("2d"); const moonMaskImage = moonMaskCtx.createImageData(moonW, moonH);

function drawMoonPhase(phaseFraction) {
const ctx = moonCtx, w = moonW, h = moonH, R = w / 2, cx = R, cy = R;
ctx.clearRect(0, 0, w, h); ctx.fillStyle = "#111"; ctx.beginPath(); ctx.arc(cx, cy, R, 0, Math.PI * 2); ctx.fill();
if (moonImg2D.complete && moonImg2D.naturalWidth > 0) {
ctx.save(); ctx.beginPath(); ctx.arc(cx, cy, R, 0, Math.PI * 2); ctx.clip();
ctx.globalAlpha = 0.2; ctx.drawImage(moonImg2D, 0, 0, w, h); ctx.restore();
}
const phi = phaseFraction * 2 * Math.PI, sx = Math.sin(phi), sy = 0, sz = -Math.cos(phi);
const data = moonMaskImage.data, r2Max = 1.0;
for (let y = 0; y < h; y++) {
const ny = (y + 0.5 - cy) / R;
for (let x = 0; x < w; x++) {
const nx = (x + 0.5 - cx) / R, r2 = nx * nx + ny * ny, idx = (y * w + x) * 4;
if (r2 <= r2Max) {
const nz = Math.sqrt(1 - r2), dot = nx * sx + ny * sy + nz * sz, b = Math.max(0, dot), a = Math.min(1, b * 1.5);
data[idx] = 255; data[idx + 1] = 255; data[idx + 2] = 255; data[idx + 3] = Math.round(a * 255);
} else { data[idx] = 0; data[idx + 1] = 0; data[idx + 2] = 0; data[idx + 3] = 0; }
}
}
moonMaskCtx.putImageData(moonMaskImage, 0, 0);
ctx.save(); ctx.beginPath(); ctx.arc(cx, cy, R, 0, Math.PI * 2); ctx.clip();
if (moonImg2D.complete && moonImg2D.naturalWidth > 0) {
ctx.globalAlpha = 1.0; ctx.globalCompositeOperation = "source-over"; ctx.drawImage(moonImg2D, 0, 0, w, h);
ctx.globalCompositeOperation = "destination-in"; ctx.drawImage(moonMaskCanvas, 0, 0);
} else { ctx.globalCompositeOperation = "source-over"; ctx.drawImage(moonMaskCanvas, 0, 0); }
ctx.restore();
const grad = ctx.createRadialGradient(cx, cy, R * 0.85, cx, cy, R);
grad.addColorStop(0, "rgba(0,0,0,0)"); grad.addColorStop(1, "rgba(0,0,0,0.5)");
ctx.fillStyle = grad; ctx.beginPath(); ctx.arc(cx, cy, R, 0, Math.PI * 2); ctx.fill();
}

function getPhaseName(p) {
if (p < 0.03 || p > 0.97) return "Новолуние"; if (p < 0.22) return "Растущий серп";
if (p < 0.28) return "Первая четверть"; if (p < 0.47) return "Растущая луна";
if (p < 0.53) return "Полнолуние"; if (p < 0.72) return "Убывающая луна";
if (p < 0.78) return "Последняя четверть"; return "Убывающий серп";
}

let trailIndex = 0, totalDistanceKm = 0;
let trackingDurationSec = 0;
let issTargetPos = null, issHasFix = false;
let issVelocityKmS = 7.66;
let issDisplayData = { lat: 0, lon: 0, alt: 0 };
let issFirstFlyover = false;

const EARTH_RADIUS_UNITS = 10, KM_PER_UNIT_EARTH = 6371 / EARTH_RADIUS_UNITS;

const raycaster = new THREE.Raycaster();
const mouse = new THREE.Vector2();
let cameraMode = 'global';

const camState = {
isTransitioning: false, startTime: 0, duration: 2000,
startPos: new THREE.Vector3(), endPos: new THREE.Vector3(),
startTarget: new THREE.Vector3(), endTarget: new THREE.Vector3()
};

window.addEventListener('dblclick', (event) => {
if (camState.isTransitioning) return;

mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
raycaster.setFromCamera(mouse, camera);

if (el.chkISS.checked && cameraMode !== 'iss') {
const intersectsISS = raycaster.intersectObjects(issModel.children, true);
if (intersectsISS.length > 0) {
enterISSMode();
return;
}
}

if (el.chkMoon.checked && cameraMode !== 'moon') {
const intersectsMoon = raycaster.intersectObjects(moonGroup.children, true);
if (intersectsMoon.length > 0) {
enterMoonMode();
return;
}
}
});

el.btnExit.addEventListener('click', exitISSMode);
el.btnExitMoon.addEventListener('click', exitMoonMode);

function enterISSMode() {
if (camState.isTransitioning) return;
cameraMode = 'iss';
el.btnExit.classList.add('visible');
el.ui.style.opacity = '0'; el.ui.style.pointerEvents = 'none'; el.issHint.style.display = 'none';

el.issHud.style.display = 'block';

camState.startPos.copy(camera.position); camState.startTarget.copy(controls.target);

const vUp = issModel.position.clone().normalize();
const vRight = new THREE.Vector3(0,1,0).cross(vUp).normalize();
camState.endPos.copy(issModel.position).add(vUp.multiplyScalar(0.3)).add(vRight.multiplyScalar(0.5));
camState.endTarget.copy(issModel.position);

camState.duration = 2000;
startTransition();
}

function exitISSMode() {
if (camState.isTransitioning) return;
cameraMode = 'global';
el.btnExit.classList.remove('visible');
el.ui.style.opacity = '1'; el.ui.style.pointerEvents = 'auto';

el.issHud.style.display = 'none';

camState.startPos.copy(camera.position); camState.startTarget.copy(controls.target);
camState.endPos.set(0, 0, 28); camState.endTarget.set(0, 0, 0);
camState.duration = 2000;
startTransition();
}

function enterMoonMode() {
if (camState.isTransitioning) return;
if (cameraMode === 'iss') el.btnExit.classList.remove('visible');

cameraMode = 'moon';
el.btnExitMoon.classList.add('visible');
el.ui.style.opacity = '0'; el.ui.style.pointerEvents = 'none';
el.issHint.style.display = 'none';

camState.startPos.copy(camera.position);
camState.startTarget.copy(controls.target);

const vToMoon = new THREE.Vector3().subVectors(camera.position, moonGroup.position).normalize();
camState.endPos.copy(moonGroup.position).add(vToMoon.multiplyScalar(10));
camState.endTarget.copy(moonGroup.position);

camState.duration = 2000;
startTransition();
}

function exitMoonMode() {
if (camState.isTransitioning) return;
cameraMode = 'global';
el.btnExitMoon.classList.remove('visible');
el.ui.style.opacity = '1'; el.ui.style.pointerEvents = 'auto';

camState.startPos.copy(camera.position);
camState.startTarget.copy(controls.target);

const earthPos = new THREE.Vector3(0,0,0);
const vFromEarth = new THREE.Vector3().subVectors(camera.position, earthPos).normalize();
camState.endPos.copy(vFromEarth.multiplyScalar(28));
camState.endTarget.set(0, 0, 0);

camState.duration = 2000;
startTransition();
}

function startTransition() {
camState.isTransitioning = true; camState.startTime = performance.now(); controls.enabled = false;
}

function easeInOutCubic(t) { return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2; }

function getVector(lat, lon, altKm, radiusUnits, gmst = 0) {
const lonRad = (lon * DEG_TO_RAD) + gmst;
const latRad = lat * DEG_TO_RAD;
const r = radiusUnits + (altKm / KM_PER_UNIT_EARTH);
return new THREE.Vector3(
r * Math.cos(latRad) * Math.cos(lonRad),
r * Math.sin(latRad),
-r * Math.cos(latRad) * Math.sin(lonRad)
);
}

async function updateISS() {
if (!el.chkISS.checked) return;
try {
const res = await fetch(`https://api.wheretheiss.at/v1/satellites/25544?time=${Date.now()}`, { cache: "no-store" });
if (!res.ok) throw new Error();
const data = await res.json();

issDisplayData = { 
    lat: data.latitude, 
    lon: data.longitude, 
    alt: data.altitude,
    visibility: data.visibility, 
    footprint: data.footprint,   
    id: data.id                 
};
issVelocityKmS = data.velocity / 3600;
issHasFix = true;

const now = new Date();
const jd = getJulianDate(now);
const gmst = getGMST(jd);

const posWorld = getVector(data.latitude, data.longitude, data.altitude, EARTH_RADIUS_UNITS, gmst);
const posLocal = getVector(data.latitude, data.longitude, data.altitude, EARTH_RADIUS_UNITS, 0);

if (!issFirstFlyover && !camState.isTransitioning && cameraMode === 'global') {
issFirstFlyover = true;
camState.startPos.copy(camera.position);
camState.startTarget.copy(controls.target);
camState.endTarget.set(0, 0, 0);

const camOrbitPos = posWorld.clone().normalize().multiplyScalar(35);
camState.endPos.copy(camOrbitPos);

camState.duration = 3000;
startTransition();
}

if (trailIndex < MAX_POINTS) {
const arr = trailLine.geometry.attributes.position.array;
arr[trailIndex * 3] = posLocal.x;
arr[trailIndex * 3 + 1] = posLocal.y;
arr[trailIndex * 3 + 2] = posLocal.z;
trailIndex++;
trailLine.geometry.setDrawRange(0, trailIndex);
trailLine.geometry.attributes.position.needsUpdate = true;
}

if (!issTargetPos) {
issTargetPos = posWorld.clone();
issModel.position.copy(posWorld);
} else {
issTargetPos.copy(posWorld);
}

el.loading.style.display = "none";
} catch (e) { }
}

function scheduleISS() { if(el.chkISS.checked) updateISS().finally(() => setTimeout(scheduleISS, 10000)); }

el.chkISS.addEventListener("change", (e) => {
issContainer.visible = e.target.checked;
if (e.target.checked) {
issFirstFlyover = false;
  totalDistanceKm = 0;
    trackingDurationSec = 0;
el.loading.innerText = "Поиск МКС..";
el.loading.style.display = "block";
el.data.innerHTML = "Поиск сигнала...";
scheduleISS();
} else {
el.loading.style.display = "none";
if(cameraMode === 'iss') exitISSMode();
el.data.innerHTML = "МКС выключена";
}
});

el.chkClouds.addEventListener("change", (e) => { clouds.visible = e.target.checked; });
el.chkGalaxy.addEventListener("change", (e) => { milkyWay.visible = e.target.checked; });

el.chkMoon.addEventListener("change", (e) => {
moonGroup.visible = e.target.checked;
el.moonInfo.style.display = e.target.checked ? "block" : "none";
});

renderer.domElement.addEventListener('mousemove', (e) => {
if(!el.chkISS.checked || cameraMode === 'iss') { el.issHint.style.opacity = 0; return; }
mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
raycaster.setFromCamera(mouse, camera);
const intersects = raycaster.intersectObjects(issModel.children, true);
if(intersects.length > 0) {
el.issHint.style.opacity = 1;
el.issHint.style.top = (e.clientY - 30) + 'px';
el.issHint.style.left = e.clientX + 'px';
} else { el.issHint.style.opacity = 0; }
});

async function updateGeoLocation(lat, lon) {
const now = Date.now();
if (now - lastGeoCheckTime < 10000) return;
lastGeoCheckTime = now;

try {
const url = `https://nominatim.openstreetmap.org/reverse?format=json&lat=${lat}&lon=${lon}&zoom=10&accept-language=ru`;
const response = await fetch(url);
if (!response.ok) throw new Error();
const data = await response.json();

if (data.error) {
el.hudLocation.innerText = "Нет данных / Океан";
} else {
const addr = data.address;
const city = addr.city || addr.town || addr.village || addr.municipality;
const state = addr.state || addr.region;
const country = addr.country;
let locString = country || "";
if (state && state !== country) locString += `, ${state}`;
if (city && city !== state) locString = `${city}, ${locString}`;
if (!locString) locString = "UNKNOWN TERRAIN";
el.hudLocation.innerText = locString;
}
} catch (e) {
el.hudLocation.innerText = "OCEAN / NO SIGNAL";
}
}

function updateISSHUD() {
    if (cameraMode !== 'iss' || !issHasFix) return;

    el.hudLat.innerText = `Ш ${issDisplayData.lat.toFixed(4)}`;
    el.hudLon.innerText = `Д ${issDisplayData.lon.toFixed(4)}`;
    el.hudAlt.innerText = `${issDisplayData.alt.toFixed(1)} KM`;
    
    // Добавляем ID спутника, если хотите (можно приписать к высоте или скорости)
    // el.hudAlt.innerText += ` [ID:${issDisplayData.id}]`;

    el.hudVel.innerText = `${(issVelocityKmS * 3600).toFixed(0)} км/ч`;

    // --- НОВАЯ ЛОГИКА СТАТУСА (на основе visibility от API) ---
    if (issDisplayData.visibility === 'daylight') {
        el.hudSolar.innerText = "100%";
        el.hudSolar.style.color = "#fff";
        // Добавляем инфо о зоне покрытия (footprint)
        el.hudStatus.innerHTML = 
            "<span style='color:#0f0'>● На солнце</span><br>" + 
            `<span style='color:#8ba4b8; font-size:9px;'>Обзор: ${Math.round(issDisplayData.footprint)} км</span>`;
    } else {
        el.hudSolar.innerText = "0% (Батарея)";
        el.hudSolar.style.color = "#ff3366";
        el.hudStatus.innerHTML = 
            "<span class='hud-warn'>⚠ В тени</span><br>" + 
            `<span style='color:#8ba4b8; font-size:9px;'>Обзор: ${Math.round(issDisplayData.footprint)} км</span>`;
    }

    // Обновляем название местности
    updateGeoLocation(issDisplayData.lat, issDisplayData.lon);
}

function updateCelestialPositions() {
const now = new Date();
el.timeNow.innerText = now.toLocaleTimeString('ru-RU', { hour12: false });
el.dateNow.innerText = now.toLocaleDateString('ru-RU');

const jd = getJulianDate(now);
const gmst = getGMST(jd);

earth.rotation.y = gmst;
earthNight.rotation.y = gmst;
cloudOffset += 0.00001;
clouds.rotation.y = gmst + cloudOffset;

if (el.chkSun.checked) {
lensflare.visible = true; earthNight.visible = true;
const sunCoords = getSolarCoordinates(jd);
const sunVec = new THREE.Vector3(sunCoords.x, sunCoords.z, -sunCoords.y).normalize().multiplyScalar(200);

sunLight.position.copy(sunVec);
nightUniforms.sunDirection.value.copy(sunVec).normalize();
sunLight.intensity = 2.5; ambientLight.intensity = 0.02;
} else {
sunLight.position.copy(camera.position);
sunLight.intensity = 1.0; ambientLight.intensity = 1.5;
lensflare.visible = false; earthNight.visible = false;
}

if (el.chkMoon.checked) {
const moonC = getLunarCoordinates(jd);
const moonPos = new THREE.Vector3(moonC.x, moonC.z, -moonC.y).normalize().multiplyScalar(60);
moonGroup.position.copy(moonPos);
moon.lookAt(0,0,0);

const angleSun = Math.atan2(sunLight.position.z, sunLight.position.x);
const angleMoon = Math.atan2(moonGroup.position.z, moonGroup.position.x);
let angleDiff = angleMoon - angleSun;
if (angleDiff < 0) angleDiff += 2*Math.PI;

const phaseFraction = 1.0 - (angleDiff / (2*Math.PI));
drawMoonPhase(phaseFraction);

const sunV = sunLight.position.clone().normalize();
const moonV = moonPos.clone().normalize();
const elongation = Math.acos(sunV.dot(moonV));
const illumination = (1 - Math.cos(elongation)) / 2;

el.moonData.innerHTML =
`<div class="phaseName">${getPhaseName(phaseFraction)}</div>` +
`Освещенность: ${(illumination * 100).toFixed(0)}%<br>` +
`Расстояние: ${moonC.distanceKm.toFixed(0)} км<br>Наклон: 5.14°`;
}

starsContainer.rotation.y = 0;
milkyWay.rotation.y = 0;
}

let lastFrameT = performance.now();
let cloudOffset = 0;

function animate(t) {
requestAnimationFrame(animate);
const dt = Math.min(0.05, (t - lastFrameT) / 1000);
lastFrameT = t;

updateCelestialPositions();

if (el.chkSun.checked) {
mainGlow.size = 1200 + Math.sin(t * 0.0015) * 16 + Math.cos(t * 0.0005) * 10;
mainStar.size = 500 + Math.sin(t * 0.002) * 12 + Math.cos(t * 0.005) * 6;
const intensity = 0.98 + Math.sin(t * 0.002) * 0.02;
mainStar.color.setHSL(0, 0, intensity);
}

if (issHasFix && el.chkISS.checked) {
const now = new Date();
const jd = getJulianDate(now);
const gmst = getGMST(jd);
const targetPos = getVector(issDisplayData.lat, issDisplayData.lon, issDisplayData.alt, EARTH_RADIUS_UNITS, gmst);

if (!issTargetPos) {
issTargetPos = targetPos.clone();
issModel.position.copy(targetPos);
} else {
issTargetPos.copy(targetPos);
const k = 1 - Math.pow(0.02, dt);
issModel.position.lerp(issTargetPos, k);
}

issModel.lookAt(0, 0, 0);

   if (issVelocityKmS > 0) {
        totalDistanceKm += issVelocityKmS * dt;
        trackingDurationSec += dt;
    }
    
    el.data.innerHTML = `Широта : ${issDisplayData.lat.toFixed(4)}°<br>` + 
                        `Долгота: ${issDisplayData.lon.toFixed(4)}°<br>` + 
                        `Высота : ${issDisplayData.alt.toFixed(1)} км<br>` + 
                        `Скорость: ${issVelocityKmS.toFixed(2)} км/с<br>` + 
                        `Трек МКС: ${totalDistanceKm.toFixed(0)} км (${trackingDurationSec.toFixed(0)} сек)`;

updateISSHUD();
}

if (camState.isTransitioning) {
const elapsed = t - camState.startTime;
let alpha = elapsed / camState.duration;

if (alpha >= 1) {
alpha = 1;
camState.isTransitioning = false;
controls.enabled = true;
camState.duration = 2000;

if (cameraMode === 'iss') {
controls.minDistance = 0.2; controls.maxDistance = 20;
} else if (cameraMode === 'moon') {
controls.minDistance = 4; controls.maxDistance = 50;
} else {
controls.minDistance = 12; controls.maxDistance = 200;
}
}
const eased = easeInOutCubic(alpha);

controls.target.lerpVectors(camState.startTarget, camState.endTarget, eased);

const startDist = camState.startPos.length();
const endDist = camState.endPos.length();
const curDist = startDist + (endDist - startDist) * eased;

const arcPos = camState.startPos.clone().lerp(camState.endPos, eased).normalize().multiplyScalar(curDist);
camera.position.copy(arcPos);

} else if (cameraMode === 'iss') {
controls.target.copy(issModel.position);
} else if (cameraMode === 'moon') {
controls.target.copy(moonGroup.position);
}

controls.update();
renderer.render(scene, camera);
}

window.addEventListener("resize", () => {
camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix();
renderer.setSize(window.innerWidth, window.innerHeight);
});







el.loading.style.display = "none";
animate(performance.now());
</script>

</body>
</html>