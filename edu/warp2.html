<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Galaxy Warp</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: sans-serif; }
        canvas { display: block; }
        
        #ui {
            position: fixed;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 10;
            background: rgba(0,0,0,0.7);
            padding: 15px 30px;
            border-radius: 30px;
            border: 1px solid rgba(255,255,255,0.2);
            text-align: center;
            color: white;
        }
        
        input[type=range] {
            width: 200px;
            accent-color: #4da6ff;
        }
        
        #speedVal {
            display: block;
            margin-top: 5px;
            font-family: monospace;
            font-size: 1.2em;
            color: #4da6ff;
        }
    </style>
</head>
<body>

    <div id="ui">
        <label>Скорость Warp-двигателя</label><br>
        <input type="range" id="speedSlider" min="0" max="100" value="5">
        <span id="speedVal">0.05 c</span>
    </div>

    <!-- Подключаем Three.js -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';

        // 1. СЦЕНА
        const scene = new THREE.Scene();
        // Убрали туман (scene.fog), чтобы фон был виден!

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 100000);
        camera.position.z = 0; // Мы в центре

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // 2. ФОН (ГАЛАКТИКА)
        // Создаем огромную сферу
        const geometry = new THREE.SphereGeometry(5000, 64, 64);
        
        // Загружаем текстуру
        const textureLoader = new THREE.TextureLoader();
        const texture = textureLoader.load('textures/milkyway.jpg', 
            // Функция успеха
            () => { console.log('Текстура галактики загружена'); },
            // Прогресс
            undefined,
            // Ошибка
            (err) => { console.error('Ошибка загрузки текстуры. Проверьте путь textures/milkyway.jpg', err); }
        );

        // Материал Basic не реагирует на свет (всегда яркий)
        const material = new THREE.MeshBasicMaterial({
            map: texture,
            side: THREE.BackSide, // Рисуем на внутренней стороне сферы
            fog: false,            // Гарантируем, что туман не скроет фон
            depthWrite: false      // Чтобы звезды рисовались поверх фона
        });

        const skybox = new THREE.Mesh(geometry, material);
        scene.add(skybox);

        // 3. ЗВЕЗДЫ (Линии)
        const starCount = 6000;
        const starGeo = new THREE.BufferGeometry();
        const positions = new Float32Array(starCount * 6); // 2 точки на линию * 3 оси (x,y,z)
        const colors = new Float32Array(starCount * 6);
        const starSpeedData = new Float32Array(starCount); // Индивидуальная скорость звезды
        const offsets = new Float32Array(starCount * 3);   // Исходная позиция

        const color1 = new THREE.Color(0xffffff);
        const color2 = new THREE.Color(0xaaaaff);
        const color3 = new THREE.Color(0xffaa88);

        for(let i=0; i<starCount; i++) {
            // Разбрасываем звезды
            const x = (Math.random() - 0.5) * 4000;
            const y = (Math.random() - 0.5) * 4000;
            const z = (Math.random() - 0.5) * 4000;

            offsets[i*3] = x;
            offsets[i*3+1] = y;
            offsets[i*3+2] = z;

            starSpeedData[i] = Math.random() * 0.5 + 0.5; // Разная скорость для параллакса

            // Случайный цвет
            let c = Math.random() > 0.5 ? (Math.random() > 0.5 ? color1 : color2) : color3;
            
            // Задаем цвет для начала и конца линии
            colors[i*6] = c.r; colors[i*6+1] = c.g; colors[i*6+2] = c.b;
            colors[i*6+3] = c.r; colors[i*6+4] = c.g; colors[i*6+5] = c.b;
        }

        starGeo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        starGeo.setAttribute('color', new THREE.BufferAttribute(colors, 3));

        const starMat = new THREE.LineBasicMaterial({
            vertexColors: true,
            blending: THREE.AdditiveBlending,
            transparent: true,
            opacity: 0.8
        });

        const stars = new THREE.LineSegments(starGeo, starMat);
        scene.add(stars);

        // 4. УПРАВЛЕНИЕ И АНИМАЦИЯ
        let speed = 0.05;
        const slider = document.getElementById('speedSlider');
        const speedText = document.getElementById('speedVal');

        slider.addEventListener('input', (e) => {
            const val = parseFloat(e.target.value);
            speed = val / 100;
            if(speed > 0.9) speedText.innerText = "MAX WARP";
            else speedText.innerText = speed.toFixed(2) + " c";
        });

        // Мышь для вращения камеры
        let mouseX = 0;
        let mouseY = 0;
        document.addEventListener('mousemove', (e) => {
            mouseX = (e.clientX - window.innerWidth / 2) * 0.0005;
            mouseY = (e.clientY - window.innerHeight / 2) * 0.0005;
        });

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        function animate() {
            requestAnimationFrame(animate);

            // Медленное вращение самой галактики для эффекта жизни
            skybox.rotation.y += 0.0002;

            // Поворот камеры от мыши
            camera.rotation.y += (mouseX * -1 - camera.rotation.y) * 0.05;
            camera.rotation.x += (mouseY * -1 - camera.rotation.x) * 0.05;

            // Движение звезд
            const positions = stars.geometry.attributes.position.array;
            // Длина хвоста звезды зависит от скорости
            const tailLength = speed * 400; 
            // Реальная скорость перемещения по Z
            const moveSpeed = speed * 100;

            for(let i=0; i<starCount; i++) {
                let z = offsets[i*3+2];
                
                // Двигаем звезду навстречу камере (увеличиваем Z)
                z += moveSpeed * starSpeedData[i];

                // Если звезда пролетела мимо камеры (Z > 1000) или слишком далеко сзади
                if(z > 1000) {
                    z -= 4000; // Отправляем далеко назад
                    // Меняем X и Y, чтобы не было видно паттерна повторения
                    const newX = (Math.random() - 0.5) * 4000;
                    const newY = (Math.random() - 0.5) * 4000;
                    offsets[i*3] = newX;
                    offsets[i*3+1] = newY;
                }
                
                offsets[i*3+2] = z; // Сохраняем новую Z

                const x = offsets[i*3];
                const y = offsets[i*3+1];

                // Обновляем координаты линии
                // Точка 1 (голова)
                positions[i*6] = x;
                positions[i*6+1] = y;
                positions[i*6+2] = z;

                // Точка 2 (хвост) - растягивается назад
                positions[i*6+3] = x;
                positions[i*6+4] = y;
                positions[i*6+5] = z - tailLength;
            }

            stars.geometry.attributes.position.needsUpdate = true;
            
            renderer.render(scene, camera);
        }

        animate();

    </script>
</body>
</html>