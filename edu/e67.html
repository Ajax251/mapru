<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no, maximum-scale=1.0" />
  <title>Solar System Explorer</title>
  
  <!-- Шрифты для космического стиля -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500&family=Rajdhani:wght@300;400;500;600;700&display=swap" rel="stylesheet">

  <style>
    :root {
      --bg-dark: #05070a;
      --glass-bg: rgba(12, 16, 26, 0.65);
      --glass-border: rgba(255, 255, 255, 0.08);
      --glass-highlight: rgba(255, 255, 255, 0.15);
      
      --accent-cyan: #00f0ff;
      --accent-blue: #2d5af6;
      --accent-danger: #ff2a6d;
      --accent-success: #05ffa1;
      
      --text-main: #e0e6ed;
      --text-muted: #94a3b8;

      --font-tech: 'Rajdhani', sans-serif;
      --font-body: 'Inter', sans-serif;
      
      --ease-out: cubic-bezier(0.215, 0.61, 0.355, 1);
    }

    * { margin: 0; padding: 0; box-sizing: border-box; -webkit-tap-highlight-color: transparent; }

    html, body {
      width: 100%; height: 100%; overflow: hidden;
      background: var(--bg-dark);
      font-family: var(--font-body);
      color: var(--text-main);
    }

    /* Фоновый шум для текстуры интерфейса */
    .noise-overlay {
      position: fixed; top: 0; left: 0; width: 100%; height: 100%;
      background: url('data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI1MTIiIGhlaWdodD0iNTEyIj48ZmlsdGVyIGlkPSJnoiPjxmZVR1cmJ1bGVuY2UgdHlwZT0iZnJhY3RhbE5vaXNlIiBiYXNlRnJlcXVlbmN5PSIwLjY1IiBudW1PY3RhdmVzPSIzIiBzdGl0Y2hUaWxlcz0ic3RpdGNoIi8+PC9maWx0ZXI+PHJlY3Qgd2lkdGg9IjEwMCUiIGhlaWdodD0iMTAwJSIgZmlsdGVyPSJ1cmwoI2cpIiBvcGFjaXR5PSIwLjAzIi8+PC9zdmc+');
      pointer-events: none; z-index: 2; opacity: 0.6;
    }

    canvas { display: block; outline: none; z-index: 1; }

    /* --- UI LAYOUT --- */
    #ui-layer {
      position: absolute; inset: 0; z-index: 10; pointer-events: none;
      display: flex; flex-direction: column; justify-content: space-between;
      padding: 30px;
    }

    /* Header */
    .header {
      pointer-events: auto;
      display: flex; flex-direction: column; gap: 4px;
      text-shadow: 0 4px 20px rgba(0,0,0,0.8);
    }
    .header h1 {
      font-family: var(--font-tech); font-weight: 700; font-size: 28px;
      text-transform: uppercase; letter-spacing: 0.1em;
      background: linear-gradient(90deg, #fff, var(--text-muted));
      -webkit-background-clip: text; -webkit-text-fill-color: transparent;
    }
    .header .subtitle {
      font-size: 11px; color: var(--accent-cyan); letter-spacing: 0.2em; text-transform: uppercase;
      display: flex; align-items: center; gap: 8px;
    }
    .header .subtitle::before {
      content: ''; width: 6px; height: 6px; background: var(--accent-cyan);
      border-radius: 50%; box-shadow: 0 0 10px var(--accent-cyan);
    }

    /* Controls Dock (Bottom) */
    .controls-dock {
      pointer-events: auto;
      align-self: center;
      background: var(--glass-bg);
      backdrop-filter: blur(20px) saturate(180%);
      -webkit-backdrop-filter: blur(20px) saturate(180%);
      border: 1px solid var(--glass-border);
      border-top: 1px solid var(--glass-highlight);
      padding: 12px 20px;
      border-radius: 24px;
      display: flex; align-items: center; gap: 20px;
      box-shadow: 0 20px 50px rgba(0,0,0,0.6);
      transition: transform 0.4s var(--ease-out);
      max-width: 90%;
    }

    .dock-divider { width: 1px; height: 24px; background: var(--glass-border); }

    .planet-list { display: flex; gap: 8px; flex-wrap: wrap; justify-content: center; }

    .planet-chip {
      background: rgba(255,255,255,0.03);
      border: 1px solid transparent;
      padding: 8px 16px;
      border-radius: 12px;
      color: var(--text-muted);
      font-family: var(--font-tech);
      font-size: 13px; font-weight: 600; letter-spacing: 1px; text-transform: uppercase;
      cursor: pointer;
      transition: all 0.3s;
      position: relative; overflow: hidden;
    }
    .planet-chip:hover {
      background: rgba(255,255,255,0.08); color: white;
      transform: translateY(-2px);
    }
    /* Активное состояние */
    .planet-chip.active {
      background: rgba(0, 240, 255, 0.1);
      border-color: rgba(0, 240, 255, 0.4);
      color: var(--accent-cyan);
      box-shadow: 0 0 15px rgba(0, 240, 255, 0.15);
    }
    /* Индикатор активности */
    .planet-chip.active::after {
      content: ''; position: absolute; bottom: 0; left: 0; width: 100%; height: 2px;
      background: var(--accent-cyan);
      box-shadow: 0 -2px 8px var(--accent-cyan);
    }

    .btn-icon {
      width: 40px; height: 40px; border-radius: 12px;
      border: 1px solid var(--glass-border); background: rgba(255,71,87,0.1);
      color: var(--accent-danger); cursor: pointer;
      display: flex; align-items: center; justify-content: center;
      transition: all 0.3s;
    }
    .btn-icon:hover { background: var(--accent-danger); color: white; box-shadow: 0 0 15px var(--accent-danger); }
    .btn-icon svg { width: 18px; height: 18px; fill: currentColor; }

    /* Hints Overlay */
    .hints {
      position: absolute; bottom: 100px; width: 100%; text-align: center;
      font-size: 10px; color: rgba(255,255,255,0.3); letter-spacing: 1px;
      pointer-events: none; opacity: 0; animation: fadeIn 1s 2s forwards;
    }
    @keyframes fadeIn { to { opacity: 1; } }

    /* --- MODAL (Holographic Card) --- */
    .modal-backdrop {
      position: fixed; inset: 0; z-index: 100;
      background: rgba(0,0,0,0.6); backdrop-filter: blur(8px);
      opacity: 0; visibility: hidden; transition: all 0.4s;
      display: flex; align-items: center; justify-content: center;
    }
    .modal-backdrop.visible { opacity: 1; visibility: visible; }

    .holo-card {
      width: 90%; max-width: 500px;
      background: linear-gradient(160deg, rgba(20, 25, 40, 0.95) 0%, rgba(8, 12, 18, 0.98) 100%);
      border: 1px solid var(--glass-border);
      box-shadow: 0 0 0 1px rgba(0, 240, 255, 0.1), 0 50px 100px -20px rgba(0,0,0,0.8);
      border-radius: 24px;
      padding: 0; overflow: hidden;
      transform: scale(0.95) translateY(20px); transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
      position: relative;
    }
    .modal-backdrop.visible .holo-card { transform: scale(1) translateY(0); }

    /* Декоративная линия сверху */
    .holo-card::before {
      content: ''; position: absolute; top: 0; left: 0; width: 100%; height: 2px;
      background: linear-gradient(90deg, transparent, var(--accent-cyan), transparent);
    }

    .card-header {
      padding: 30px 30px 10px; position: relative;
      display: flex; justify-content: space-between; align-items: start;
    }
    .planet-name {
      font-family: var(--font-tech); font-size: 42px; line-height: 1; font-weight: 300;
      text-transform: uppercase; color: white; margin-bottom: 5px;
    }
    .planet-type {
      font-size: 12px; color: var(--accent-cyan); text-transform: uppercase; letter-spacing: 3px; font-weight: 600;
    }
    .close-btn {
      background: none; border: none; color: rgba(255,255,255,0.3); font-size: 28px; cursor: pointer;
      transition: color 0.2s; line-height: 0.5;
    }
    .close-btn:hover { color: white; }

    .card-body { padding: 30px; }
    
    .stats-grid {
      display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-bottom: 25px;
    }
    .stat-box {
      background: rgba(255,255,255,0.03); border-radius: 12px; padding: 12px 16px;
      border: 1px solid rgba(255,255,255,0.05);
    }
    .stat-label {
      font-size: 10px; text-transform: uppercase; color: var(--text-muted); letter-spacing: 1px; margin-bottom: 4px;
    }
    .stat-value {
      font-family: var(--font-tech); font-size: 16px; color: var(--text-main); font-weight: 500;
    }

    .fact-box {
      border-left: 3px solid var(--accent-cyan);
      background: linear-gradient(90deg, rgba(0, 240, 255, 0.05), transparent);
      padding: 15px 20px; border-radius: 0 12px 12px 0;
    }
    .fact-text { font-size: 14px; line-height: 1.6; color: rgba(255,255,255,0.9); }

    /* --- MOBILE ADAPTATION --- */
    @media (max-width: 768px) {
      #ui-layer { padding: 20px; }
      .controls-dock {
        width: 100%; max-width: 100%;
        flex-direction: column-reverse; /* Кнопка сброса снизу */
        gap: 15px; padding: 15px;
        border-radius: 20px;
        backdrop-filter: blur(30px);
      }
      .dock-divider { width: 100%; height: 1px; }
      .planet-list {
        display: grid; grid-template-columns: repeat(4, 1fr); gap: 6px; width: 100%;
      }
      .planet-chip {
        font-size: 10px; padding: 10px 4px; text-align: center;
        display: flex; align-items: center; justify-content: center;
      }
      .btn-icon { width: 100%; height: 36px; border-radius: 10px; }
      .hints { display: none; }
      .planet-name { font-size: 32px; }
    }
  </style>
</head>
<body>

  <!-- Шум для текстуры -->
  <div class="noise-overlay"></div>

  <!-- Three.js Canvas Container -->
  <div id="canvas-container"></div>

  <!-- UI Interface -->
  <div id="ui-layer">
    <div class="header">
      <h1>Cosmos Explorer</h1>
      <div class="subtitle">Интерактивная модель</div>
    </div>

    <div class="hints">
      <div>ЛКМ — Вращение &nbsp;•&nbsp; Колесо — Зум &nbsp;•&nbsp; Двойной клик — Данные</div>
    </div>

    <div class="controls-dock">
      <button class="btn-icon" onclick="clearAll()" title="Сбросить всё">
        <svg viewBox="0 0 24 24"><path d="M6 19c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V7H6v12zM19 4h-3.5l-1-1h-5l-1 1H5v2h14V4z"/></svg>
      </button>
      <div class="dock-divider"></div>
      <div class="planet-list" id="planetButtons">
        <!-- Buttons generated by JS -->
      </div>
    </div>
  </div>

  <!-- Modal -->
  <div class="modal-backdrop" id="modal">
    <div class="holo-card">
      <div class="card-header">
        <div>
          <h2 class="planet-name" id="modalTitle">MARS</h2>
          <div class="planet-type" id="modalSubtitle">Планета земной группы</div>
        </div>
        <button class="close-btn" onclick="closeModal()">×</button>
      </div>
      <div class="card-body">
        <div class="stats-grid" id="statsGrid"></div>
        <div class="fact-box">
          <p class="fact-text" id="factText"></p>
        </div>
      </div>
    </div>
  </div>

  <script type="importmap">
    { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js", "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/" } }
  </script>

  <script type="module">
    import * as THREE from "three";
    import { OrbitControls } from "three/addons/controls/OrbitControls.js";
    import { UnrealBloomPass } from "three/addons/postprocessing/UnrealBloomPass.js";
    import { EffectComposer } from "three/addons/postprocessing/EffectComposer.js";
    import { RenderPass } from "three/addons/postprocessing/RenderPass.js";

    // --- DATA ---
    const PLANETS = {
      Меркурий: { order: 1, radius: 2439, tex: 'textures/mercury2.jpg', bump: 'textures/mercury2.jpg', type: 'Земная группа', color: '#A5A5A5', info: { mass: '3.3 × 10²³ кг', temp: '-173°C / +427°C', day: '58.6 дн.', distance: '57.9 млн км', fact: 'Меркурий не имеет атмосферы, поэтому небо там всегда черное, а звезды видны даже днем.' } },
      Венера: { order: 2, radius: 6051, tex: 'textures/venus.jpg', bump: 'textures/venus.jpg', glow: 0xffaa55, type: 'Земная группа', color: '#E3BB76', info: { mass: '4.87 × 10²⁴ кг', temp: '+462°C', day: '243 дн.', distance: '108.2 млн км', fact: 'Самая горячая планета. Давление на поверхности в 92 раза выше земного.' } },
      Земля: { order: 3, radius: 6371, tex: 'textures/earth-blue-marble.jpg', spec: 'textures/earth2.jpg', glow: 0x4488ff, type: 'Земная группа', color: '#2E81F6', info: { mass: '5.97 × 10²⁴ кг', temp: '-89°C / +58°C', day: '24 ч.', distance: '149.6 млн км', fact: 'Единственное известное место во Вселенной, где есть жизнь. 71% поверхности покрыто водой.' } },
      Луна: { order: 3.5, radius: 1737, tex: 'textures/moon.png', bump: 'textures/moon.png', type: 'Спутник', color: '#CCCCCC', info: { mass: '7.35 × 10²² кг', temp: '-173°C / +127°C', day: '27.3 дн.', distance: '384 400 км', fact: 'Луна удаляется от Земли на 3.8 см каждый год.' } },
      Марс: { order: 4, radius: 3389, tex: 'textures/mars.jpg', bump: 'textures/mars2.jpg', glow: 0xff4422, type: 'Земная группа', color: '#FF5733', info: { mass: '6.42 × 10²³ кг', temp: '-87°C / -5°C', day: '24.6 ч.', distance: '227.9 млн км', fact: 'Красный цвет обусловлен оксидом железа (ржавчиной) в почве.' } },
      Юпитер: { order: 5, radius: 69911, tex: 'textures/jupiter.jpg', glow: 0xffcc99, type: 'Газовый гигант', color: '#D9A066', info: { mass: '1.9 × 10²⁷ кг', temp: '-108°C', day: '9.9 ч.', distance: '778.5 млн км', fact: 'Юпитер — "пылесос" Солнечной системы, он притягивает к себе множество комет и астероидов.' } },
      Сатурн: { order: 6, radius: 58232, tex: 'textures/saturn.jpg', glow: 0xeeddcc, type: 'Газовый гигант', ring: { tex: 'textures/saturn2.png', inner: 74500, outer: 140220 }, color: '#E4CD9A', info: { mass: '5.68 × 10²⁶ кг', temp: '-139°C', day: '10.7 ч.', distance: '1.43 млрд км', fact: 'Его кольца состоят из миллиардов кусков льда и камня, размером от пылинки до дома.' } },
      Уран: { order: 7, radius: 25362, tex: 'textures/uranus.jpg', glow: 0x66ccff, type: 'Ледяной гигант', color: '#66CCFF', info: { mass: '8.68 × 10²⁵ кг', temp: '-197°C', day: '17.2 ч.', distance: '2.87 млрд км', fact: 'Самая холодная планетарная атмосфера в Солнечной системе (-224°C).' } },
      Нептун: { order: 8, radius: 24622, tex: 'textures/neptune.jpg', glow: 0x3355ff, type: 'Ледяной гигант', color: '#3355FF', info: { mass: '1.02 × 10²⁶ кг', temp: '-201°C', day: '16.1 ч.', distance: '4.5 млрд км', fact: 'Ветры на Нептуне самые сильные в системе — до 2100 км/ч.' } },
      Плутон: { order: 9, radius: 1188, tex: 'textures/pluto.jpg', bump: 'textures/pluto.jpg', type: 'Карликовая', color: '#AA8877', info: { mass: '1.3 × 10²² кг', temp: '-223°C', day: '6.4 дн.', distance: '5.9 млрд км', fact: 'Плутон меньше Луны. Площадь его поверхности сопоставима с площадью России.' } }
    };

    const BASE_SCALE = 1 / 5000;
    
    // --- SETUP ---
    const scene = new THREE.Scene();
    // Глубокий темный цвет фона (почти черный с синевой)
    scene.background = new THREE.Color(0x020205);
    scene.fog = new THREE.FogExp2(0x020205, 0.002);
    
    const camera = new THREE.PerspectiveCamera(55, window.innerWidth / window.innerHeight, 0.1, 50000);
    const renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.0;
    document.getElementById('canvas-container').appendChild(renderer.domElement);

    // --- POST PROCESSING (BLOOM) ---
    const composer = new EffectComposer(renderer);
    composer.addPass(new RenderPass(scene, camera));
    const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.2, 0.5, 0.7);
    composer.addPass(bloomPass);

    // --- CONTROLS ---
    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;
    controls.minDistance = 5;
    controls.maxDistance = 1200;
    controls.maxPolarAngle = Math.PI * 0.85;
    controls.enableZoom = false; // Custom zoom

    // --- LIGHTING ---
    const ambientLight = new THREE.AmbientLight(0x404060, 0.8); // Холодный заполняющий свет
    scene.add(ambientLight);
    
    const mainLight = new THREE.DirectionalLight(0xffffff, 1.5);
    mainLight.position.set(100, 20, 50);
    scene.add(mainLight);
    
    // Подсветка снизу для объема
    const rimLight = new THREE.DirectionalLight(0x4455ff, 0.3);
    rimLight.position.set(-50, -50, -10);
    scene.add(rimLight);

    // --- STARS ---
    function createStars() {
      const geo = new THREE.BufferGeometry();
      const count = 4000; 
      const pos = new Float32Array(count * 3);
      const sizes = new Float32Array(count);
      const colors = new Float32Array(count * 3);
      const colorOptions = [new THREE.Color(0xffffff), new THREE.Color(0xaaccff), new THREE.Color(0xffddaa)];

      for (let i = 0; i < count; i++) {
        const r = 900 + Math.random() * 1500; 
        const theta = Math.random() * Math.PI * 2; 
        const phi = Math.acos(2 * Math.random() - 1);
        pos[i * 3] = r * Math.sin(phi) * Math.cos(theta); 
        pos[i * 3 + 1] = r * Math.cos(phi); 
        pos[i * 3 + 2] = r * Math.sin(phi) * Math.sin(theta);
        
        sizes[i] = Math.random() * 1.5;
        
        const col = colorOptions[Math.floor(Math.random() * colorOptions.length)];
        colors[i * 3] = col.r;
        colors[i * 3 + 1] = col.g;
        colors[i * 3 + 2] = col.b;
      }
      geo.setAttribute("position", new THREE.BufferAttribute(pos, 3));
      geo.setAttribute("size", new THREE.BufferAttribute(sizes, 1));
      geo.setAttribute("color", new THREE.BufferAttribute(colors, 3));
      
      const mat = new THREE.PointsMaterial({ 
        size: 1, vertexColors: true, map: getStarTexture(), transparent: true, opacity: 0.8, blending: THREE.AdditiveBlending 
      });
      return new THREE.Points(geo, mat);
    }
    
    function getStarTexture() {
      const canvas = document.createElement('canvas'); canvas.width = 32; canvas.height = 32;
      const ctx = canvas.getContext('2d');
      const grad = ctx.createRadialGradient(16,16,0,16,16,16);
      grad.addColorStop(0, 'rgba(255,255,255,1)');
      grad.addColorStop(1, 'rgba(0,0,0,0)');
      ctx.fillStyle = grad; ctx.fillRect(0,0,32,32);
      const tex = new THREE.Texture(canvas); tex.needsUpdate = true;
      return tex;
    }
    scene.add(createStars());

    // --- ASSETS & OBJECTS ---
    const loadingManager = new THREE.LoadingManager();
    const textureLoader = new THREE.TextureLoader(loadingManager);
    
    let activePlanets = [];
    const addedPlanetKeys = new Set();
    const planetsGroup = new THREE.Group();
    scene.add(planetsGroup);

    let cameraTarget = { position: new THREE.Vector3(0, 30, 80), target: new THREE.Vector3(0, 0, 0) };
    let userInteracted = false;

    // --- INTERACTION LOGIC ---
    controls.addEventListener('start', () => { userInteracted = true; });
    renderer.domElement.addEventListener('wheel', (e) => {
        e.preventDefault();
        userInteracted = true;
        const scale = e.deltaY > 0 ? 1.1 : 0.9;
        const currentDist = camera.position.distanceTo(controls.target);
        let newDist = currentDist * scale;
        newDist = Math.max(controls.minDistance, Math.min(controls.maxDistance, newDist));
        const dir = new THREE.Vector3().subVectors(camera.position, controls.target).normalize();
        camera.position.copy(controls.target).add(dir.multiplyScalar(newDist));
    }, { passive: false });

    // --- PLANET CREATION ---
    function createPlanet(key) {
      const data = PLANETS[key];
      const radius = data.radius * BASE_SCALE;
      const geometry = new THREE.SphereGeometry(radius, 64, 64);
      
      const materialProps = { 
        map: textureLoader.load(data.tex), 
        shininess: 15,
        emissive: new THREE.Color(0x000000),
      };
      
      if (data.bump) { materialProps.bumpMap = textureLoader.load(data.bump); materialProps.bumpScale = 0.02; }
      if (data.spec) { materialProps.specularMap = textureLoader.load(data.spec); materialProps.specular = new THREE.Color(0x222222); }
      
      const mesh = new THREE.Mesh(geometry, new THREE.MeshPhongMaterial(materialProps));
      const container = new THREE.Group();
      container.add(mesh);

      // Atmospheric Glow (Fresnel Shader)
      const glowColor = data.glow ? new THREE.Color(data.glow) : new THREE.Color(0x4488ff);
      const glowMat = new THREE.ShaderMaterial({
          uniforms: { 
            c: { type: "f", value: 0.5 },
            p: { type: "f", value: 4.0 },
            glowColor: { type: "c", value: glowColor },
            viewVector: { type: "v3", value: camera.position }
          },
          vertexShader: `
            uniform vec3 viewVector;
            uniform float c;
            uniform float p;
            varying float intensity;
            void main() {
              vec3 vNormal = normalize( normalMatrix * normal );
              vec3 vNormel = normalize( normalMatrix * viewVector );
              intensity = pow( c - dot(vNormal, vNormel), p );
              gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
            }
          `,
          fragmentShader: `
            uniform vec3 glowColor;
            varying float intensity;
            void main() {
              vec3 glow = glowColor * intensity;
              gl_FragColor = vec4( glow, 1.0 );
            }
          `,
          side: THREE.BackSide, blending: THREE.AdditiveBlending, transparent: true, depthWrite: false
      });
      
      const glowMesh = new THREE.Mesh(new THREE.SphereGeometry(radius * 1.2, 64, 64), glowMat);
      container.add(glowMesh);
      // Store ref to update uniforms
      container.userData.glowMesh = glowMesh;

      // Rings
      if (data.ring) {
        const ringGeo = new THREE.RingGeometry(data.ring.inner * BASE_SCALE, data.ring.outer * BASE_SCALE, 128);
        const ringMat = new THREE.MeshStandardMaterial({ 
          map: textureLoader.load(data.ring.tex), 
          side: THREE.DoubleSide, transparent: true, opacity: 0.9,
          roughness: 0.8, metalness: 0.1
        });
        const pos = ringGeo.attributes.position;
        const v3 = new THREE.Vector3();
        for (let i = 0; i < pos.count; i++){
          v3.fromBufferAttribute(pos, i);
          ringGeo.attributes.uv.setXY(i, 0.5 + v3.x / (data.ring.outer * BASE_SCALE * 2), 0.5 + v3.y / (data.ring.outer * BASE_SCALE * 2));
        }
        const ringMesh = new THREE.Mesh(ringGeo, ringMat);
        ringMesh.rotation.x = -Math.PI / 2;
        container.add(ringMesh);
      }

      container.userData = { name: key, radius: radius, info: data.info, type: data.type, realRadius: data.radius };
      return container;
    }

    // --- LAYOUT LOGIC ---
    function recalculatePositions() {
      if (activePlanets.length === 0) { fitCamera(); return; }
      activePlanets.sort((a, b) => PLANETS[a.userData.name].order - PLANETS[b.userData.name].order);

      let currentX = 0;
      const padding = 2.5;

      activePlanets.forEach((obj, i) => {
        const hasRing = !!PLANETS[obj.userData.name].ring;
        const r = obj.userData.radius;
        const width = hasRing ? r * 2.3 : r; 
        
        if (i > 0) {
          const prev = activePlanets[i - 1];
          const prevRing = !!PLANETS[prev.userData.name].ring;
          const prevWidth = prevRing ? prev.userData.radius * 2.3 : prev.userData.radius;
          currentX += prevWidth + width + padding;
        }
        obj.userData.targetX = currentX;
      });

      const totalWidth = activePlanets[activePlanets.length - 1].userData.targetX;
      activePlanets.forEach(obj => obj.userData.targetX -= totalWidth / 2);
      fitCamera();
    }

    function fitCamera() {
      if (activePlanets.length === 0) return;
      
      const box = new THREE.Box3();
      activePlanets.forEach(obj => {
         const r = obj.userData.radius;
         const hasRing = !!PLANETS[obj.userData.name].ring;
         const size = hasRing ? r * 2.5 : r;
         const center = new THREE.Vector3(obj.userData.targetX || obj.position.x, 0, 0);
         box.expandByPoint(center.clone().addScalar(size));
         box.expandByPoint(center.clone().subScalar(size));
      });

      const size = new THREE.Vector3(); box.getSize(size);
      const center = new THREE.Vector3(); box.getCenter(center);
      
      // Адаптация под мобильные (UI снизу, планеты выше)
      const fovRad = camera.fov * (Math.PI / 180);
      const aspect = camera.aspect;
      const isMobile = window.innerWidth < 768;
      
      let cameraZ = Math.max(
        size.y / (2 * Math.tan(fovRad / 2)),
        size.x / (2 * Math.tan(fovRad / 2) * aspect)
      ) * (isMobile ? 1.6 : 1.3);
      
      cameraZ = Math.max(cameraZ, 20);

      const verticalOffset = isMobile ? -cameraZ * 0.15 : 0;

      cameraTarget.position.set(center.x, center.y + cameraZ * 0.3, cameraZ);
      cameraTarget.target.set(center.x, center.y + verticalOffset, center.z);
      userInteracted = false;
    }

    // --- API ---
    window.addPlanet = (key) => {
      if (addedPlanetKeys.has(key)) return;
      const planet = createPlanet(key);
      planet.scale.set(0, 0, 0);
      planet.position.y = -20;
      
      planetsGroup.add(planet);
      activePlanets.push(planet);
      addedPlanetKeys.add(key);
      
      recalculatePositions();
      updateUI();

      // Elastic Animation In
      let p = 0;
      function tick() {
        p += 0.03;
        const s = Math.min(p, 1);
        // Elastic ease out
        const ease = s === 1 ? 1 : 1 - Math.pow(2, -10 * s);
        
        planet.scale.setScalar(ease);
        planet.position.y = -20 * (1 - ease);
        if (p < 1) requestAnimationFrame(tick);
      }
      tick();
    };

    window.removePlanet = (key) => {
      const planet = activePlanets.find(p => p.userData.name === key);
      if (!planet) return;
      
      let p = 0;
      function tick() {
        p += 0.06;
        const s = Math.min(p, 1);
        const ease = s * s;
        planet.scale.setScalar(1 - ease);
        planet.position.y = 20 * ease;
        
        if (p < 1) {
          requestAnimationFrame(tick);
        } else {
          planetsGroup.remove(planet);
          activePlanets = activePlanets.filter(p => p !== planet);
          addedPlanetKeys.delete(key);
          recalculatePositions();
          updateUI();
        }
      }
      tick();
    };

    window.clearAll = () => {
      [...activePlanets].forEach((p, i) => setTimeout(() => window.removePlanet(p.userData.name), i * 30));
    };

    function updateUI() {
      document.querySelectorAll('.planet-chip').forEach(btn => {
        const key = btn.dataset.planet;
        if (addedPlanetKeys.has(key)) btn.classList.add('active');
        else btn.classList.remove('active');
      });
    }

    // --- DOM BUILDER ---
    const btnContainer = document.getElementById("planetButtons");
    Object.keys(PLANETS).sort((a,b) => PLANETS[a].order - PLANETS[b].order).forEach(key => {
      const btn = document.createElement("div"); 
      btn.className = "planet-chip"; 
      btn.textContent = key; 
      btn.dataset.planet = key;
      btn.onclick = () => { 
        if (addedPlanetKeys.has(key)) window.removePlanet(key); 
        else window.addPlanet(key); 
      };
      btnContainer.appendChild(btn);
    });

    // --- MODAL ---
    function showModal(planetObj) {
      const { name, type, realRadius, info } = planetObj.userData;
      document.getElementById('modalTitle').textContent = name;
      document.getElementById('modalSubtitle').textContent = type;
      document.getElementById('statsGrid').innerHTML = `
        <div class="stat-box"><div class="stat-label">Радиус</div><div class="stat-value">${realRadius.toLocaleString()} км</div></div>
        <div class="stat-box"><div class="stat-label">Масса</div><div class="stat-value">${info.mass}</div></div>
        <div class="stat-box"><div class="stat-label">Температура</div><div class="stat-value">${info.temp}</div></div>
        <div class="stat-box"><div class="stat-label">Расстояние</div><div class="stat-value">${info.distance}</div></div>
      `;
      document.getElementById('factText').textContent = info.fact;
      document.getElementById('modal').classList.add('visible');
    }
    window.closeModal = () => document.getElementById('modal').classList.remove('visible');
    document.getElementById('modal').addEventListener('click', (e) => { if (e.target === e.currentTarget) closeModal(); });

    // --- RAYCASTER ---
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();
    renderer.domElement.addEventListener('dblclick', (event) => {
      event.preventDefault();
      mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
      mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
      raycaster.setFromCamera(mouse, camera);
      const intersects = raycaster.intersectObjects(planetsGroup.children, true);
      if (intersects.length > 0) {
        let t = intersects[0].object;
        while (t.parent && t.parent !== planetsGroup) t = t.parent;
        if (activePlanets.includes(t)) showModal(t);
      }
    });

    // Init Scene
    setTimeout(() => { ['Земля', 'Марс', 'Юпитер'].forEach((p, i) => setTimeout(() => window.addPlanet(p), i*200)); }, 500);

    // --- RENDER LOOP ---
    function animate() {
      requestAnimationFrame(animate);
      
      if (!userInteracted) {
        camera.position.lerp(cameraTarget.position, 0.04);
        controls.target.lerp(cameraTarget.target, 0.04);
      }

      activePlanets.forEach(obj => {
        // Move
        if (obj.userData.targetX !== undefined) {
          obj.position.x += (obj.userData.targetX - obj.position.x) * 0.08;
        }
        // Rotate
        if (obj.children[0]) obj.children[0].rotation.y += 0.0015;
        // Update glow shader uniform to look at camera
        if (obj.userData.glowMesh) {
            obj.userData.glowMesh.material.uniforms.viewVector.value = camera.position;
        }
      });

      controls.update();
      composer.render();
    }

    window.addEventListener("resize", () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
      composer.setSize(window.innerWidth, window.innerHeight);
      fitCamera();
    });

    animate();
  </script>
</body>
</html>