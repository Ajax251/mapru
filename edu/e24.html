<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no, maximum-scale=1.0" />
<title>–ü–ª–∞–Ω–µ—Ç–∞—Ä–∏–π Stellarium Style</title>
<style>
    :root {
        --bg-color: #000510;
        --panel-bg: linear-gradient(135deg, rgba(10, 20, 40, 0.95), rgba(5, 15, 35, 0.9));
        --accent: #00e5ff;
        --accent-glow: rgba(0, 229, 255, 0.4);
        --accent-dim: rgba(0, 229, 255, 0.15);
        --gold: #ffd700;
        --text-main: #e0f7fa;
        --border: rgba(0, 229, 255, 0.4);
        --success: #4cff88;
        --warning: #ff9944;
        --iss-color: #00ff88;
    }

    * { box-sizing: border-box; }

    body, html {
        margin: 0; padding: 0; width: 100%; height: 100%;
        background: radial-gradient(ellipse at center, #0a1628 0%, #000510 100%);
        overflow: hidden;
        font-family: 'Segoe UI', Tahoma, sans-serif;
        color: var(--text-main);
        user-select: none;
    }

    canvas { display: block; width: 100%; height: 100%; outline: none; }

    /* –ö–ù–û–ü–ö–ê –ú–ï–ù–Æ */
    #btn-toggle-const {
        position: absolute; top: 20px; left: 20px;
        width: 50px; height: 50px;
        background: var(--panel-bg);
        border: 1px solid var(--border);
        border-radius: 12px; cursor: pointer;
        display: flex; justify-content: center; align-items: center;
        font-size: 26px; z-index: 20; 
        transition: all 0.3s ease;
        box-shadow: 0 4px 20px rgba(0,0,0,0.5), 0 0 20px var(--accent-glow);
    }
    #btn-toggle-const:hover { 
        background: var(--accent-dim); 
        color: var(--accent); 
        border-color: var(--accent);
        transform: scale(1.05);
        box-shadow: 0 4px 30px rgba(0,0,0,0.6), 0 0 30px var(--accent-glow);
    }

    /* –õ–ï–í–ê–Ø –ü–ê–ù–ï–õ–¨ */
    #constellation-panel {
        position: absolute; top: 80px; left: 20px; bottom: 20px;
        width: 300px;
        background: var(--panel-bg);
        border: 1px solid var(--border);
        border-radius: 16px;
        display: none; flex-direction: column;
        backdrop-filter: blur(20px); 
        z-index: 19;
        box-shadow: 0 8px 40px rgba(0,0,0,0.6), inset 0 1px 0 rgba(255,255,255,0.1);
    }
    #constellation-panel.visible { display: flex; animation: slideIn 0.4s cubic-bezier(0.4, 0, 0.2, 1) forwards; }
    @keyframes slideIn { 
        from { opacity: 0; transform: translateX(-30px) scale(0.95); } 
        to { opacity: 1; transform: translateX(0) scale(1); } 
    }

    .panel-header { 
        padding: 18px; 
        border-bottom: 1px solid rgba(255,255,255,0.1); 
        flex-shrink: 0;
        background: rgba(0,0,0,0.2);
        border-radius: 16px 16px 0 0;
    }
    #search-const {
        width: 100%; padding: 12px 16px;
        background: rgba(0,0,0,0.4); 
        border: 1px solid rgba(255,255,255,0.2);
        border-radius: 10px; 
        color: white; 
        font-size: 14px; 
        outline: none;
        transition: all 0.3s;
    }
    #search-const:focus {
        border-color: var(--accent);
        box-shadow: 0 0 15px var(--accent-glow);
    }
    #search-const::placeholder { color: rgba(255,255,255,0.4); }
    
    #const-list {
        flex: 1; overflow-y: auto; padding: 8px;
        scrollbar-width: thin; scrollbar-color: var(--accent) transparent;
    }
    #const-list::-webkit-scrollbar { width: 6px; }
    #const-list::-webkit-scrollbar-track { background: transparent; }
    #const-list::-webkit-scrollbar-thumb { background: var(--accent); border-radius: 3px; }
    
    .const-item {
        padding: 12px 16px; cursor: pointer; font-size: 14px; border-radius: 8px;
        margin-bottom: 4px; transition: all 0.2s; display: flex; justify-content: space-between;
        align-items: center;
        border-left: 3px solid transparent;
    }
    .const-item:hover { 
        background: var(--accent-dim); 
        color: var(--accent);
        border-left-color: var(--accent);
    }
    .const-item.active { 
        background: linear-gradient(90deg, rgba(0, 229, 255, 0.3), transparent);
        color: #fff; 
        font-weight: 600; 
        border-left-color: var(--accent);
        box-shadow: inset 0 0 20px var(--accent-glow);
    }
    .latin-name { font-size: 11px; opacity: 0.5; font-style: italic; }
    
    #btn-reset-view {
        margin: 12px; padding: 12px;
        background: linear-gradient(135deg, rgba(0, 229, 255, 0.2), rgba(0, 229, 255, 0.1));
        border: 1px solid var(--accent);
        color: var(--accent); cursor: pointer; border-radius: 8px;
        text-transform: uppercase; font-size: 12px; font-weight: 700;
        letter-spacing: 1px;
        transition: all 0.3s;
    }
    #btn-reset-view:hover {
        background: var(--accent);
        color: #000;
        box-shadow: 0 0 20px var(--accent-glow);
    }

    /* –ü–†–ê–í–ê–Ø –ü–ê–ù–ï–õ–¨ */
    #controls-panel {
        position: absolute; top: 20px; right: 20px;
        width: 280px;
        background: var(--panel-bg);
        border: 1px solid var(--border);
        border-radius: 16px; padding: 20px;
        backdrop-filter: blur(20px);
        box-shadow: 0 8px 40px rgba(0,0,0,0.6), inset 0 1px 0 rgba(255,255,255,0.1);
    }
    .panel-title {
        font-size: 11px; font-weight: 700; color: var(--accent);
        text-transform: uppercase; letter-spacing: 2px; margin-bottom: 15px;
        text-align: center; 
        padding-bottom: 10px;
        border-bottom: 1px solid rgba(0, 229, 255, 0.2);
        text-shadow: 0 0 10px var(--accent-glow);
    }
    .cam-mode-switch {
        display: flex; 
        background: rgba(0,0,0,0.4); 
        border-radius: 10px; 
        padding: 4px; 
        margin-bottom: 20px;
        border: 1px solid rgba(255,255,255,0.1);
    }
    .cam-btn {
        flex: 1; border: none; background: transparent; color: rgba(255,255,255,0.5);
        padding: 10px; font-size: 12px; cursor: pointer; border-radius: 8px; 
        transition: all 0.3s;
        font-weight: 500;
    }
    .cam-btn:hover { color: white; background: rgba(255,255,255,0.1); }
    .cam-btn.active { 
        background: linear-gradient(135deg, var(--accent), #0088aa);
        color: #000; 
        font-weight: 700;
        box-shadow: 0 4px 15px var(--accent-glow);
    }
    .ctrl-row {
        display: flex; justify-content: space-between; align-items: center;
        margin-bottom: 14px; font-size: 13px;
        padding: 8px 12px;
        background: rgba(0,0,0,0.2);
        border-radius: 8px;
        transition: all 0.2s;
    }
    .ctrl-row:hover { background: rgba(0,0,0,0.3); }
    .ctrl-row span { display: flex; align-items: center; gap: 8px; }
    
    .switch { position: relative; width: 46px; height: 24px; }
    .switch input { opacity: 0; width: 0; height: 0; }
    .slider {
        position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0;
        background-color: rgba(50, 60, 80, 0.8); 
        border-radius: 24px; 
        transition: .3s; 
        border: 1px solid rgba(255,255,255,0.2);
    }
    .slider:before {
        position: absolute; content: ""; height: 18px; width: 18px;
        left: 3px; bottom: 2px; 
        background: linear-gradient(135deg, #fff, #ccc);
        border-radius: 50%; 
        transition: .3s;
        box-shadow: 0 2px 5px rgba(0,0,0,0.3);
    }
    input:checked + .slider { 
        background: linear-gradient(135deg, rgba(0, 229, 255, 0.5), rgba(0, 180, 200, 0.5));
        border-color: var(--accent); 
        box-shadow: 0 0 15px var(--accent-glow);
    }
    input:checked + .slider:before { 
        transform: translateX(22px); 
        background: linear-gradient(135deg, var(--accent), #00ccff);
    }

    /* –ù–ò–ñ–ù–Ø–Ø –ü–ê–ù–ï–õ–¨ */
    #info-panel {
        position: absolute; bottom: 20px; right: 20px;
        background: var(--panel-bg);
        border: 1px solid var(--border);
        border-radius: 16px; padding: 18px 22px;
        backdrop-filter: blur(20px); 
        pointer-events: none;
        text-align: right; 
        min-width: 220px;
        box-shadow: 0 8px 40px rgba(0,0,0,0.6);
    }
    .info-title {
        font-weight: 700; 
        margin-bottom: 8px; 
        font-size: 12px; 
        color: white;
        text-transform: uppercase;
        letter-spacing: 1px;
        opacity: 0.8;
    }
    .info-data { 
        font-family: 'Consolas', 'Monaco', monospace; 
        font-size: 13px; 
        line-height: 1.7;
        color: rgba(255,255,255,0.7);
    }
    .val-gold { 
        color: var(--gold); 
        font-size: 18px;
        font-weight: 700;
        text-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
    }
    #iss-data {
        margin-top: 10px;
        padding-top: 10px;
        border-top: 1px solid rgba(255,255,255,0.1);
        color: var(--iss-color);
        font-weight: 700;
        text-shadow: 0 0 10px rgba(0, 255, 136, 0.5);
    }
    
    /* –ó–ê–ì–†–£–ó–ö–ê */
    #loading {
        position: absolute; top: 0; left: 0; width: 100%; height: 100%;
        background: radial-gradient(ellipse at center, #0a1628 0%, #000510 100%);
        display: flex; flex-direction: column;
        justify-content: center; align-items: center;
        z-index: 9999;
    }
    .loader-text {
        color: var(--accent); 
        font-size: 18px; 
        text-transform: uppercase; 
        letter-spacing: 4px;
        margin-top: 30px;
        animation: pulse 1.5s ease-in-out infinite;
    }
    @keyframes pulse {
        0%, 100% { opacity: 0.5; }
        50% { opacity: 1; }
    }
    .loader-spinner {
        width: 60px; height: 60px;
        border: 3px solid rgba(0, 229, 255, 0.2);
        border-top-color: var(--accent);
        border-radius: 50%;
        animation: spin 1s linear infinite;
    }
    @keyframes spin { to { transform: rotate(360deg); } }

    /* –ü–û–î–°–ö–ê–ó–ö–ê */
    #tooltip {
        position: absolute;
        background: rgba(0, 20, 40, 0.95);
        border: 1px solid var(--accent);
        border-radius: 8px;
        padding: 10px 14px;
        font-size: 12px;
        pointer-events: none;
        display: none;
        z-index: 100;
        box-shadow: 0 4px 20px rgba(0,0,0,0.5), 0 0 20px var(--accent-glow);
        max-width: 200px;
    }
</style>
</head>
<body>

<div id="loading">
    <div class="loader-spinner"></div>
    <div class="loader-text">–ó–∞–≥—Ä—É–∑–∫–∞ –ü–ª–∞–Ω–µ—Ç–∞—Ä–∏—è...</div>
</div>

<div id="btn-toggle-const" title="–°–ø–∏—Å–æ–∫ —Å–æ–∑–≤–µ–∑–¥–∏–π">‚≠ê</div>

<div id="constellation-panel">
    <div class="panel-header">
        <input type="text" id="search-const" placeholder="üîç –ü–æ–∏—Å–∫ —Å–æ–∑–≤–µ–∑–¥–∏—è..." autocomplete="off">
    </div>
    <div id="const-list"></div>
    <button id="btn-reset-view">‚Ü∫ –°–±—Ä–æ—Å –≤—ã–±–æ—Ä–∞</button>
</div>

<div id="controls-panel">
    <div class="panel-title">üé• –†–µ–∂–∏–º –ø—Ä–æ—Å–º–æ—Ç—Ä–∞</div>
    <div class="cam-mode-switch">
        <button class="cam-btn active" id="cam-out">üåç –°–Ω–∞—Ä—É–∂–∏</button>
        <button class="cam-btn" id="cam-in">üëÅ –í —Ü–µ–Ω—Ç—Ä–µ</button>
    </div>

    <div class="panel-title">‚öôÔ∏è –û—Ç–æ–±—Ä–∞–∂–µ–Ω–∏–µ</div>
    <div class="ctrl-row">
        <span>üåê –°–µ—Ç–∫–∞</span>
        <label class="switch"><input type="checkbox" id="chk-grid"><span class="slider"></span></label>
    </div>
    <div class="ctrl-row">
        <span>‚≠ê –ó–≤–µ–∑–¥—ã</span>
        <label class="switch"><input type="checkbox" id="chk-stars"><span class="slider"></span></label>
    </div>
    <div class="ctrl-row">
        <span>‚ú® –õ–∏–Ω–∏–∏ —Å–æ–∑–≤–µ–∑–¥–∏–π</span>
        <label class="switch"><input type="checkbox" id="chk-lines"><span class="slider"></span></label>
    </div>
    <div class="ctrl-row">
        <span>üè∑Ô∏è –ù–∞–∑–≤–∞–Ω–∏—è</span>
        <label class="switch"><input type="checkbox" id="chk-const-names"><span class="slider"></span></label>
    </div>
    <div class="ctrl-row">
        <span>ü™ê –ü–ª–∞–Ω–µ—Ç—ã</span>
        <label class="switch"><input type="checkbox" id="chk-planets"><span class="slider"></span></label>
    </div>
    <div class="ctrl-row">
        <span>„Ä∞Ô∏è –¢—Ä–∞–µ–∫—Ç–æ—Ä–∏–∏</span>
        <label class="switch"><input type="checkbox" id="chk-traj"><span class="slider"></span></label>
    </div>
    <div class="ctrl-row">
        <span>üõ∞Ô∏è –ú–ö–°</span>
        <label class="switch"><input type="checkbox" id="chk-iss"><span class="slider"></span></label>
    </div>
    <div class="ctrl-row">
        <span>üèûÔ∏è –õ–∞–Ω–¥—à–∞—Ñ—Ç</span>
        <label class="switch"><input type="checkbox" id="chk-ground"><span class="slider"></span></label>
    </div>
</div>

<div id="info-panel">
    <div class="info-title">üìç –ù–∞–±–ª—é–¥–∞—Ç–µ–ª—å</div>
    <div class="info-data" id="loc-data">–û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ GPS...</div>
    <div class="info-data val-gold" id="time-data">--:--:--</div>
    <div class="info-data" id="iss-data" style="display:none;">
        üõ∞Ô∏è –ú–ö–°: –ü–æ–∏—Å–∫...
    </div>
</div>

<div id="tooltip"></div>

<script type="importmap">
{
    "imports": {
        "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
    }
}
</script>
<script src="https://cdn.jsdelivr.net/npm/astronomy-engine@2.1.19/astronomy.browser.min.js"></script>
<script src="constellations.js"></script>

<script type="module">
import * as THREE from "three";
import { OrbitControls } from "three/addons/controls/OrbitControls.js";

// === –ù–ê–°–¢–†–û–ô–ö–ò ===
const DEFAULT_SETTINGS = {
    grid: true,
    ground: true,
    stars: true,
    lines: true,
    constNames: false,
    planets: true,
    traj: false,
    iss: true,
    camMode: 'out'
};

let settings = { ...DEFAULT_SETTINGS };

function loadSettings() {
    const saved = localStorage.getItem('planetarium_settings_v3');
    if (saved) {
        try {
            settings = { ...DEFAULT_SETTINGS, ...JSON.parse(saved) };
        } catch (e) { }
    }
}
function saveSettings() {
    localStorage.setItem('planetarium_settings_v3', JSON.stringify(settings));
}

// === –ì–õ–û–ë–ê–õ–¨–ù–´–ï –ü–ï–†–ï–ú–ï–ù–ù–´–ï ===
let scene, camera, renderer, controls;
const SPHERE_RADIUS = 50; 
let observerLat = 55.75, observerLon = 37.61;
let activeConstellation = null;

const PLANETS = ['Mercury', 'Venus', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune'];
const PLANET_COLORS = {
    Mercury: '#b5b5b5', Venus: '#fffde8', Mars: '#ff6b4a',
    Jupiter: '#ffcc88', Saturn: '#f4d59e', Uranus: '#b5f4ea', Neptune: '#5b8dff'
};

const groups = {
    grid: new THREE.Group(),
    stars: new THREE.Group(),
    constellations: new THREE.Group(),
    planets: new THREE.Group(),
    trajectories: new THREE.Group(),
    sunMoon: new THREE.Group(),
    iss: new THREE.Group(),
    ground: new THREE.Group()
};

const constellationMap = {}; 
let landscapeMesh = null;

function init() {
    if (typeof CONSTELLATIONS === 'undefined') {
        alert("–û—à–∏–±–∫–∞: —Ñ–∞–π–ª constellations.js –Ω–µ –Ω–∞–π–¥–µ–Ω!");
        return;
    }
    loadSettings();

    // –°–¶–ï–ù–ê
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x000814);

    // –ö–ê–ú–ï–†–ê
    camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
    
    // –†–ï–ù–î–ï–†–ï–†
    renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.5;
    document.body.appendChild(renderer.domElement);

    // –ö–û–ù–¢–†–û–õ–õ–ï–†
    controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;

    // –û–°–í–ï–©–ï–ù–ò–ï (–£–õ–£–ß–®–ï–ù–ù–û–ï)
    const ambient = new THREE.AmbientLight(0xffffff, 1.0);
    scene.add(ambient);
    
    const hemi = new THREE.HemisphereLight(0x8888ff, 0x444422, 0.8);
    scene.add(hemi);
    
    const dir1 = new THREE.DirectionalLight(0xffffff, 1.0);
    dir1.position.set(50, 100, 50);
    scene.add(dir1);
    
    const dir2 = new THREE.DirectionalLight(0x4488ff, 0.5);
    dir2.position.set(-50, 50, -50);
    scene.add(dir2);

    // –§–æ–Ω–æ–≤—ã–µ –∑–≤–µ–∑–¥—ã (–¥–∞–ª—å–Ω–∏–µ)
    createBackgroundStars();
    
    buildGrid();
    buildGround();
    
    Object.values(groups).forEach(g => scene.add(g));

    applyCameraMode();

    window.addEventListener('resize', onResize);
    setupUI();
    buildConstellationList();

    if(navigator.geolocation) {
        navigator.geolocation.getCurrentPosition(pos => {
            observerLat = pos.coords.latitude;
            observerLon = pos.coords.longitude;
            updateSky();
        }, () => {
            updateSky();
        });
    } else {
        updateSky();
    }

    setInterval(updateSky, 60000); 
    updateISS();
    setInterval(updateISS, 5000); 

    animate();
    
    setTimeout(() => {
        document.getElementById('loading').style.opacity = '0';
        setTimeout(() => {
            document.getElementById('loading').style.display = 'none';
        }, 500);
    }, 500);
}

// –§–æ–Ω–æ–≤—ã–µ –¥–∞–ª–µ–∫–∏–µ –∑–≤–µ–∑–¥—ã
function createBackgroundStars() {
    const geometry = new THREE.BufferGeometry();
    const vertices = [];
    const colors = [];
    
    for (let i = 0; i < 3000; i++) {
        const theta = Math.random() * Math.PI * 2;
        const phi = Math.acos(2 * Math.random() - 1);
        const r = 200 + Math.random() * 100;
        
        vertices.push(
            r * Math.sin(phi) * Math.cos(theta),
            r * Math.sin(phi) * Math.sin(theta),
            r * Math.cos(phi)
        );
        
        const brightness = 0.3 + Math.random() * 0.7;
        colors.push(brightness, brightness, brightness * 1.1);
    }
    
    geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
    geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
    
    const material = new THREE.PointsMaterial({
        size: 0.5,
        vertexColors: true,
        transparent: true,
        opacity: 0.8,
        sizeAttenuation: true
    });
    
    const stars = new THREE.Points(geometry, material);
    scene.add(stars);
}

// === –£–ü–†–ê–í–õ–ï–ù–ò–ï –ö–ê–ú–ï–†–û–ô ===
function applyCameraMode() {
    const btnIn = document.getElementById('cam-in');
    const btnOut = document.getElementById('cam-out');

    if (settings.camMode === 'in') {
        camera.position.set(0, 0.5, 0.1);
        controls.minDistance = 0.1;
        controls.maxDistance = 2.0;
        controls.maxPolarAngle = Math.PI / 2 - 0.05; 
        controls.rotateSpeed = -0.5;
        controls.enablePan = false;
        
        if(landscapeMesh) landscapeMesh.visible = settings.ground;

        btnIn.classList.add('active');
        btnOut.classList.remove('active');
    } else {
        camera.position.set(0, 50, 100);
        controls.minDistance = 20;
        controls.maxDistance = 300;
        controls.maxPolarAngle = Math.PI;
        controls.rotateSpeed = 0.5;
        controls.enablePan = true;
        
        if(landscapeMesh) landscapeMesh.visible = false;

        btnIn.classList.remove('active');
        btnOut.classList.add('active');
    }
    controls.target.set(0, 0, 0);
    controls.update();
}

// === –õ–ê–ù–î–®–ê–§–¢ ===
function createLandscapeTexture() {
    const canvas = document.createElement('canvas');
    canvas.width = 2048; canvas.height = 256;
    const ctx = canvas.getContext('2d');
    
    // –ì—Ä–∞–¥–∏–µ–Ω—Ç –Ω–µ–±–∞ —É –≥–æ—Ä–∏–∑–æ–Ω—Ç–∞
    const skyGrad = ctx.createLinearGradient(0, 0, 0, 256);
    skyGrad.addColorStop(0, 'rgba(0,0,0,0)');
    skyGrad.addColorStop(0.3, 'rgba(10,20,40,0.3)');
    skyGrad.addColorStop(0.5, 'rgba(5,15,30,0.8)');
    skyGrad.addColorStop(1, '#000000');
    ctx.fillStyle = skyGrad;
    ctx.fillRect(0, 0, 2048, 256);
    
    // –°–∏–ª—É—ç—Ç —Å –¥–µ—Ä–µ–≤—å—è–º–∏ –∏ —Ö–æ–ª–º–∞–º–∏
    ctx.fillStyle = '#000000';
    ctx.beginPath();
    ctx.moveTo(0, 256);
    
    let y = 150;
    for(let x = 0; x <= 2048; x += 4) {
        // –•–æ–ª–º—ã
        const hill = Math.sin(x * 0.005) * 30 + Math.sin(x * 0.01) * 15;
        // –î–µ—Ä–µ–≤—å—è
        const tree = Math.random() > 0.7 ? Math.random() * 25 : 0;
        y = 160 + hill - tree;
        ctx.lineTo(x, y);
    }
    ctx.lineTo(2048, 256);
    ctx.lineTo(0, 256);
    ctx.fill();
    
    const tex = new THREE.CanvasTexture(canvas);
    tex.wrapS = THREE.RepeatWrapping;
    tex.repeat.set(3, 1);
    return tex;
}

function buildGround() {
    // –î–∏—Å–∫ –≥–æ—Ä–∏–∑–æ–Ω—Ç–∞
    const diskGeo = new THREE.CircleGeometry(SPHERE_RADIUS * 1.1, 64);
    const diskMat = new THREE.MeshBasicMaterial({ 
        color: 0x020810, 
        transparent: true, 
        opacity: 0.95, 
        side: THREE.DoubleSide 
    });
    const disk = new THREE.Mesh(diskGeo, diskMat);
    disk.rotation.x = -Math.PI / 2;
    disk.position.y = -0.5;
    groups.ground.add(disk);

    // –°–µ—Ç–∫–∞ –∞–∑–∏–º—É—Ç–∞
    const gridHelper = new THREE.PolarGridHelper(SPHERE_RADIUS, 12, 6, 64, 0x0066aa, 0x003366);
    gridHelper.material.opacity = 0.3;
    gridHelper.material.transparent = true;
    groups.ground.add(gridHelper);

    // –õ–∞–Ω–¥—à–∞—Ñ—Ç-—Ü–∏–ª–∏–Ω–¥—Ä
    const cylGeo = new THREE.CylinderGeometry(
        SPHERE_RADIUS * 0.99, SPHERE_RADIUS * 0.99, 
        15, 64, 1, true
    );
    const cylMat = new THREE.MeshBasicMaterial({ 
        map: createLandscapeTexture(), 
        transparent: true, 
        side: THREE.BackSide,
        depthWrite: false
    });
    landscapeMesh = new THREE.Mesh(cylGeo, cylMat);
    landscapeMesh.position.y = 3;
    landscapeMesh.renderOrder = 10;
    groups.ground.add(landscapeMesh);

    // –ù–∏–∂–Ω—è—è –ø–æ–ª—É—Å—Ñ–µ—Ä–∞
    const botGeo = new THREE.SphereGeometry(SPHERE_RADIUS * 0.98, 32, 16, 0, Math.PI * 2, Math.PI / 2, Math.PI / 2);
    const botMat = new THREE.MeshBasicMaterial({ color: 0x000408, side: THREE.DoubleSide });
    const botBowl = new THREE.Mesh(botGeo, botMat);
    groups.ground.add(botBowl);
}

// --- –£–¢–ò–õ–ò–¢–´ ---
function sphericalToCartesian(radius, azDeg, altDeg) {
    const altRad = THREE.MathUtils.degToRad(altDeg);
    const azRad = THREE.MathUtils.degToRad(azDeg);
    return new THREE.Vector3(
        radius * Math.cos(altRad) * Math.sin(azRad),
        radius * Math.sin(altRad),
        -radius * Math.cos(altRad) * Math.cos(azRad)
    );
}

function createTextSprite(text, color, scale = 1, isBold = true) {
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    const fontSize = 64; 
    const fontStr = `${isBold ? 'bold ' : ''}${fontSize}px Arial`;
    ctx.font = fontStr;
    const w = ctx.measureText(text).width + 30;
    canvas.width = w; canvas.height = fontSize + 30;
    
    ctx.font = fontStr;
    ctx.textAlign = 'center'; 
    ctx.textBaseline = 'middle';
    
    // –°–≤–µ—á–µ–Ω–∏–µ
    ctx.shadowColor = color;
    ctx.shadowBlur = 15;
    ctx.fillStyle = color;
    ctx.fillText(text, w / 2, canvas.height / 2);
    ctx.fillText(text, w / 2, canvas.height / 2); // –î–≤–æ–π–Ω–æ–π –ø—Ä–æ—Ö–æ–¥ –¥–ª—è —è—Ä–∫–æ—Å—Ç–∏
    
    const tex = new THREE.CanvasTexture(canvas);
    const mat = new THREE.SpriteMaterial({ 
        map: tex, 
        depthTest: false, 
        depthWrite: false,
        transparent: true
    });
    const sprite = new THREE.Sprite(mat);
    const baseSize = 0.2;
    sprite.scale.set(baseSize * w / 10, baseSize * canvas.height / 10, 1);
    sprite.scale.multiplyScalar(scale);
    return sprite;
}

// –Ø—Ä–∫–∞—è –∑–≤–µ–∑–¥–∞
function createStarSprite(color, size) {
    const canvas = document.createElement('canvas');
    canvas.width = 128; canvas.height = 128;
    const ctx = canvas.getContext('2d');
    const cx = 64, cy = 64;
    
    // –û—Å–Ω–æ–≤–Ω–æ–µ —Å–≤–µ—á–µ–Ω–∏–µ
    const grad = ctx.createRadialGradient(cx, cy, 0, cx, cy, 64);
    grad.addColorStop(0, '#ffffff');
    grad.addColorStop(0.05, color);
    grad.addColorStop(0.2, color);
    grad.addColorStop(0.5, 'rgba(100,150,255,0.2)');
    grad.addColorStop(1, 'rgba(0,0,0,0)');
    ctx.fillStyle = grad;
    ctx.fillRect(0, 0, 128, 128);
    
    // –õ—É—á–∏
    ctx.strokeStyle = 'rgba(255,255,255,0.5)';
    ctx.lineWidth = 1;
    for (let i = 0; i < 4; i++) {
        const angle = (i * Math.PI) / 2;
        ctx.beginPath();
        ctx.moveTo(cx + Math.cos(angle) * 5, cy + Math.sin(angle) * 5);
        ctx.lineTo(cx + Math.cos(angle) * 30, cy + Math.sin(angle) * 30);
        ctx.stroke();
    }
    
    const mat = new THREE.SpriteMaterial({ 
        map: new THREE.CanvasTexture(canvas), 
        blending: THREE.AdditiveBlending, 
        depthTest: true, 
        depthWrite: false,
        transparent: true
    });
    const sprite = new THREE.Sprite(mat);
    sprite.scale.set(size, size, 1);
    return sprite;
}

// –ú–ö–° - —è—Ä–∫–∞—è 3D –º–æ–¥–µ–ª—å
function createISSModel() {
    const group = new THREE.Group();
    
    // –Ø—Ä–∫–∏–µ –º–∞—Ç–µ—Ä–∏–∞–ª—ã
    const bodyMat = new THREE.MeshPhongMaterial({ 
        color: 0xffffff, 
        emissive: 0x00ff88,
        emissiveIntensity: 0.8,
        shininess: 100
    });
    const solarMat = new THREE.MeshPhongMaterial({ 
        color: 0x00ff88, 
        emissive: 0x00ff44,
        emissiveIntensity: 0.5,
        side: THREE.DoubleSide 
    });
    const frameMat = new THREE.MeshPhongMaterial({
        color: 0xcccccc,
        emissive: 0x88ffaa,
        emissiveIntensity: 0.3
    });

    // –ì–ª–∞–≤–Ω—ã–π –º–æ–¥—É–ª—å
    const body = new THREE.Mesh(new THREE.CylinderGeometry(0.5, 0.5, 5, 12), bodyMat);
    body.rotation.z = Math.PI / 2;
    group.add(body);

    // –ü–æ–ø–µ—Ä–µ—á–Ω–∞—è —Ñ–µ—Ä–º–∞
    const truss = new THREE.Mesh(new THREE.BoxGeometry(0.8, 10, 0.5), frameMat);
    group.add(truss);

    // –°–æ–ª–Ω–µ—á–Ω—ã–µ –ø–∞–Ω–µ–ª–∏ (8 —à—Ç—É–∫)
    const panelGeo = new THREE.BoxGeometry(2.5, 5, 0.1);
    const panelPositions = [
        [1.5, 4], [-1.5, 4], [1.5, -4], [-1.5, -4],
        [1.5, 2], [-1.5, 2], [1.5, -2], [-1.5, -2]
    ];
    panelPositions.forEach(([x, y]) => {
        const panel = new THREE.Mesh(panelGeo, solarMat);
        panel.position.set(x * 1.2, y, 0);
        group.add(panel);
    });

    // –¢–æ—á–µ—á–Ω—ã–π —Å–≤–µ—Ç –Ω–∞ –ú–ö–°
    const light = new THREE.PointLight(0x00ff88, 2, 20);
    group.add(light);

    group.scale.set(0.5, 0.5, 0.5);
    return group;
}

function buildGrid() {
    const r = SPHERE_RADIUS;
    const mat = new THREE.LineBasicMaterial({ 
        color: 0x0088cc, 
        transparent: true, 
        opacity: 0.25 
    });
    
    // –ü–∞—Ä–∞–ª–ª–µ–ª–∏
    for(let alt = -80; alt <= 80; alt += 20) {
        const pts = [];
        for(let az = 0; az <= 360; az += 5) {
            pts.push(sphericalToCartesian(r, az, alt));
        }
        groups.grid.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints(pts), mat));
    }
    
    // –ú–µ—Ä–∏–¥–∏–∞–Ω—ã
    for(let az = 0; az < 360; az += 30) {
        const pts = [];
        for(let alt = -90; alt <= 90; alt += 5) {
            pts.push(sphericalToCartesian(r, az, alt));
        }
        groups.grid.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints(pts), mat));
    }
    
    // –°—Ç–æ—Ä–æ–Ω—ã —Å–≤–µ—Ç–∞
    const directions = [
        { text: '–°', az: 0, color: '#ff4444' },
        { text: '–í', az: 90, color: '#ff6644' },
        { text: '–Æ', az: 180, color: '#ff4444' },
        { text: '–ó', az: 270, color: '#ff6644' }
    ];
    
    directions.forEach(d => {
        const sprite = createTextSprite(d.text, d.color, 4, true);
        const pos = sphericalToCartesian(r * 1.02, d.az, 2);
        sprite.position.copy(pos);
        groups.grid.add(sprite);
    });
}

// --- –û–ë–ù–û–í–õ–ï–ù–ò–ï –ù–ï–ë–ê ---
function updateSky() {
    const now = new Date();
    document.getElementById('loc-data').innerText = `LAT: ${observerLat.toFixed(3)}¬∞ LON: ${observerLon.toFixed(3)}¬∞`;
    document.getElementById('time-data').innerText = now.toLocaleTimeString('ru-RU');
    
    const observer = new Astronomy.Observer(observerLat, observerLon, 0);

    // –û—á–∏—Å—Ç–∫–∞ –≥—Ä—É–ø–ø
    ['stars', 'constellations', 'planets', 'trajectories', 'sunMoon'].forEach(k => {
        const g = groups[k];
        while(g.children.length) {
            const o = g.children[0];
            g.remove(o);
            if(o.geometry) o.geometry.dispose();
            if(o.material) {
                if(o.material.map) o.material.map.dispose();
                o.material.dispose();
            }
        }
    });
    
    for (const key in constellationMap) delete constellationMap[key];

    // –°–û–ó–í–ï–ó–î–ò–Ø –ò –ó–í–ï–ó–î–´
    const starPosCache = {};

    Object.keys(CONSTELLATIONS).forEach(cName => {
        const cData = CONSTELLATIONS[cName];
        
        const cLines = new THREE.Group();
        const cLabels = new THREE.Group(); 
        const cStarLabels = new THREE.Group(); 

        let starCount = 0;
        const cCenter = new THREE.Vector3();

        cData.stars.forEach(star => {
            const hor = Astronomy.Horizon(now, observer, star.ra, star.dec, 'normal');
            const pos = sphericalToCartesian(SPHERE_RADIUS, hor.azimuth, hor.altitude);
            starPosCache[star.name] = pos;
            
            // –†–∞–∑–º–µ—Ä –∏ —è—Ä–∫–æ—Å—Ç—å –∑–≤–µ–∑–¥
            const size = Math.max(0.8, 4.5 - star.mag * 0.7); 
            
            // –¶–≤–µ—Ç –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç —Ç–∏–ø–∞
            let starColor = '#ffffff';
            if (star.mag < 1) starColor = '#ffffcc';
            else if (star.mag < 2) starColor = '#ffffff';
            else starColor = '#ccddff';
            
            const starSprite = createStarSprite(starColor, size);
            starSprite.position.copy(pos);
            groups.stars.add(starSprite);

            // –ú–µ—Ç–∫–∞ –∑–≤–µ–∑–¥—ã
            const label = createTextSprite(star.name, '#99ccff', 0.8, false);
            label.position.copy(pos.clone().multiplyScalar(1.03));
            label.visible = false; 
            cStarLabels.add(label);

            cCenter.add(pos);
            starCount++;
        });

        // –õ–∏–Ω–∏–∏ —Å–æ–∑–≤–µ–∑–¥–∏—è
        if(cData.lines) {
            const points = [];
            cData.lines.forEach(pair => {
                const p1 = starPosCache[pair[0]];
                const p2 = starPosCache[pair[1]];
                if(p1 && p2) points.push(p1.clone(), p2.clone());
            });
            if(points.length > 0) {
                const geo = new THREE.BufferGeometry().setFromPoints(points);
                const mat = new THREE.LineBasicMaterial({ 
                    color: 0xaa66ff, 
                    opacity: 0.6, 
                    transparent: true 
                });
                const lineSeg = new THREE.LineSegments(geo, mat);
                lineSeg.visible = settings.lines;
                cLines.add(lineSeg);
            }
        }

        // –ú–µ—Ç–∫–∞ —Å–æ–∑–≤–µ–∑–¥–∏—è
        if(starCount > 0) {
            cCenter.divideScalar(starCount).normalize().multiplyScalar(SPHERE_RADIUS * 1.08);
            const constLabel = createTextSprite(cName, '#cc99ff', 1.8);
            constLabel.position.copy(cCenter);
            constLabel.visible = settings.constNames;
            cLabels.add(constLabel);
        }

        groups.constellations.add(cLines);
        groups.constellations.add(cLabels);
        groups.constellations.add(cStarLabels);

        constellationMap[cName] = {
            linesGroup: cLines,
            constLabelGroup: cLabels,
            starLabelsGroup: cStarLabels
        };
    });

    if(activeConstellation) highlightConstellation(activeConstellation);

    // –ü–õ–ê–ù–ï–¢–´
    PLANETS.forEach(p => {
        try {
            const eq = Astronomy.Equator(p, now, observer, false, true);
            const hor = Astronomy.Horizon(now, observer, eq.ra, eq.dec, 'normal');
            const pos = sphericalToCartesian(SPHERE_RADIUS, hor.azimuth, hor.altitude);
            
            const col = PLANET_COLORS[p] || '#ffffff';
            
            const planetSprite = createStarSprite(col, 5.0);
            planetSprite.position.copy(pos);
            groups.planets.add(planetSprite);
            
            const label = createTextSprite(p, col, 1.3);
            label.position.copy(pos.clone().multiplyScalar(1.06));
            groups.planets.add(label);
        } catch(e) {}
    });

    // –°–û–õ–ù–¶–ï
    try {
        const sunEq = Astronomy.Equator('Sun', now, observer, false, true);
        const sunHor = Astronomy.Horizon(now, observer, sunEq.ra, sunEq.dec, 'normal');
        const sunPos = sphericalToCartesian(SPHERE_RADIUS, sunHor.azimuth, sunHor.altitude);
        
        const sunSprite = createStarSprite('#ffcc00', 10);
        sunSprite.position.copy(sunPos);
        groups.sunMoon.add(sunSprite);
        
        const sunLabel = createTextSprite('‚òÄ –°–æ–ª–Ω—Ü–µ', '#ffcc00', 2);
        sunLabel.position.copy(sunPos.clone().multiplyScalar(1.12));
        groups.sunMoon.add(sunLabel);
    } catch(e) {}

    // –õ–£–ù–ê
    try {
        const moonEq = Astronomy.Equator('Moon', now, observer, false, true);
        const moonHor = Astronomy.Horizon(now, observer, moonEq.ra, moonEq.dec, 'normal');
        const moonPos = sphericalToCartesian(SPHERE_RADIUS, moonHor.azimuth, moonHor.altitude);
        
        const moonSprite = createStarSprite('#ffffff', 7);
        moonSprite.position.copy(moonPos);
        groups.sunMoon.add(moonSprite);
        
        const moonLabel = createTextSprite('üåô –õ—É–Ω–∞', '#ffffff', 1.6);
        moonLabel.position.copy(moonPos.clone().multiplyScalar(1.1));
        groups.sunMoon.add(moonLabel);
    } catch(e) {}

    // –¢—Ä–∞–µ–∫—Ç–æ—Ä–∏–∏
    if(settings.traj) {
        drawTrajectory('Sun', 0xffaa00, now, observer);
        drawTrajectory('Moon', 0xaaaaff, now, observer);
    }

    applyVisibilitySettings();
}

function drawTrajectory(body, color, date, obs) {
    const pts = [];
    const d = new Date(date);
    d.setHours(0, 0, 0, 0);
    
    for(let i = 0; i <= 24; i += 0.5) {
        try {
            const t = new Date(d.getTime() + i * 3600000);
            const eq = Astronomy.Equator(body, t, obs, false, true);
            const h = Astronomy.Horizon(t, obs, eq.ra, eq.dec, 'normal');
            if(h.altitude > -10) {
                pts.push(sphericalToCartesian(SPHERE_RADIUS, h.azimuth, h.altitude));
            }
        } catch(e) {}
    }
    
    if(pts.length > 1) {
        const geo = new THREE.BufferGeometry().setFromPoints(pts);
        const mat = new THREE.LineBasicMaterial({ 
            color: color, 
            opacity: 0.6, 
            transparent: true,
            linewidth: 2
        });
        groups.trajectories.add(new THREE.Line(geo, mat));
    }
}

// --- –ú–ö–° ---
function getTopo(obsLat, obsLon, satLat, satLon, satAltKm) {
    const R = 6371;
    const D2R = Math.PI / 180;
    const R2D = 180 / Math.PI;
    
    const lat1 = obsLat * D2R, lon1 = obsLon * D2R;
    const lat2 = satLat * D2R, lon2 = satLon * D2R;
    const r1 = R, r2 = R + satAltKm;
    
    const x1 = r1 * Math.cos(lat1) * Math.cos(lon1);
    const y1 = r1 * Math.cos(lat1) * Math.sin(lon1);
    const z1 = r1 * Math.sin(lat1);
    
    const x2 = r2 * Math.cos(lat2) * Math.cos(lon2);
    const y2 = r2 * Math.cos(lat2) * Math.sin(lon2);
    const z2 = r2 * Math.sin(lat2);
    
    const dx = x2 - x1, dy = y2 - y1, dz = z2 - z1;
    const sl = Math.sin(lat1), cl = Math.cos(lat1);
    const slo = Math.sin(lon1), clo = Math.cos(lon1);
    
    const e = -slo * dx + clo * dy;
    const n = -sl * clo * dx - sl * slo * dy + cl * dz;
    const u = cl * clo * dx + cl * slo * dy + sl * dz;
    
    let az = Math.atan2(e, n) * R2D;
    if(az < 0) az += 360;
    
    const alt = Math.asin(u / Math.sqrt(e * e + n * n + u * u)) * R2D;
    return { az, alt, visible: alt > 0 };
}

async function updateISS() {
    if(!settings.iss) {
        groups.iss.visible = false;
        document.getElementById('iss-data').style.display = 'none';
        return;
    }
    
    try {
        const response = await fetch('https://api.wheretheiss.at/v1/satellites/25544');
        if(!response.ok) throw new Error();
        const data = await response.json();
        
        // –û—á–∏—Å—Ç–∫–∞ –≥—Ä—É–ø–ø—ã –ú–ö–°
        while(groups.iss.children.length) {
            const c = groups.iss.children[0];
            groups.iss.remove(c);
        }

        const topo = getTopo(observerLat, observerLon, data.latitude, data.longitude, data.altitude);
        const pos = sphericalToCartesian(SPHERE_RADIUS * 0.95, topo.az, topo.alt);
        
        const model = createISSModel();
        model.position.copy(pos);
        model.lookAt(0, 0, 0);
        groups.iss.add(model);

        const label = createTextSprite('üõ∞Ô∏è –ú–ö–°', '#00ff88', 1.5);
        label.position.copy(pos.clone().multiplyScalar(1.15));
        groups.iss.add(label);

        groups.iss.visible = true;
        
        const issDiv = document.getElementById('iss-data');
        issDiv.style.display = 'block';
        
        if(topo.visible) {
            issDiv.innerHTML = `üõ∞Ô∏è –ú–ö–°: Az ${topo.az.toFixed(0)}¬∞ Alt ${topo.alt.toFixed(0)}¬∞ <span style="color:#00ff88">‚óè –í–ò–î–ù–ê</span>`;
        } else {
            issDiv.innerHTML = `üõ∞Ô∏è –ú–ö–°: Az ${topo.az.toFixed(0)}¬∞ Alt ${topo.alt.toFixed(0)}¬∞ <span style="color:#ff6666">‚óã –ó–∞ –≥–æ—Ä–∏–∑–æ–Ω—Ç–æ–º</span>`;
            model.traverse(c => { 
                if(c.material) { 
                    c.material.opacity = 0.4; 
                    c.material.transparent = true; 
                }
            });
        }
    } catch (e) {
        document.getElementById('iss-data').innerHTML = 'üõ∞Ô∏è –ú–ö–°: –ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö';
    }
}

// --- –ò–ù–¢–ï–†–ê–ö–¢–ò–í ---
function buildConstellationList() {
    const list = document.getElementById('const-list');
    const names = Object.keys(CONSTELLATIONS).sort();
    list.innerHTML = '';
    
    names.forEach(name => {
        const data = CONSTELLATIONS[name];
        const div = document.createElement('div');
        div.className = 'const-item';
        div.dataset.name = name;
        div.innerHTML = `<span>${name}</span><span class="latin-name">${data.latin}</span>`;
        div.onclick = () => selectConstellation(name);
        list.appendChild(div);
    });
}

function selectConstellation(name) {
    activeConstellation = name;
    document.querySelectorAll('.const-item').forEach(el => {
        el.classList.toggle('active', el.dataset.name === name);
    });
    highlightConstellation(name);
}

function highlightConstellation(name) {
    const target = constellationMap[name];
    
    // –ü—Ä–∏–≥–ª—É—à–∞–µ–º –≤—Å–µ
    Object.values(constellationMap).forEach(obj => {
        obj.linesGroup.children.forEach(l => {
            if(l.material) {
                l.material.opacity = 0.15;
                l.material.color.setHex(0x6644aa);
            }
        });
        obj.constLabelGroup.children.forEach(lbl => lbl.visible = false);
        obj.starLabelsGroup.children.forEach(lbl => lbl.visible = false);
    });

    // –ü–æ–¥—Å–≤–µ—á–∏–≤–∞–µ–º –≤—ã–±—Ä–∞–Ω–Ω–æ–µ
    if(target) {
        target.linesGroup.children.forEach(l => {
            if(l.material) {
                l.material.opacity = 1.0;
                l.material.color.setHex(0x00ffff);
            }
        });
        target.constLabelGroup.children.forEach(lbl => lbl.visible = true);
        target.starLabelsGroup.children.forEach(lbl => lbl.visible = true);
    }
}

function resetView() {
    activeConstellation = null;
    document.querySelectorAll('.const-item').forEach(el => el.classList.remove('active'));
    
    Object.values(constellationMap).forEach(obj => {
        obj.linesGroup.children.forEach(l => {
            if(l.material) {
                l.material.opacity = 0.6;
                l.material.color.setHex(0xaa66ff);
            }
        });
        obj.constLabelGroup.children.forEach(lbl => lbl.visible = settings.constNames);
        obj.starLabelsGroup.children.forEach(lbl => lbl.visible = false);
    });
}

function applyVisibilitySettings() {
    groups.grid.visible = settings.grid;
    groups.stars.visible = settings.stars;
    
    Object.values(constellationMap).forEach(c => {
        c.linesGroup.children.forEach(l => l.visible = settings.lines);
        if(!activeConstellation) {
            c.constLabelGroup.children.forEach(lbl => lbl.visible = settings.constNames);
        }
    });

    groups.planets.visible = settings.planets;
    groups.trajectories.visible = settings.traj;
    groups.iss.visible = settings.iss;
    
    const isGroundOn = settings.ground;
    if(landscapeMesh) {
        landscapeMesh.visible = (settings.camMode === 'in') && isGroundOn;
    }
    groups.ground.children.forEach(c => {
        if(c !== landscapeMesh) c.visible = isGroundOn;
    });
}

// UI
document.getElementById('btn-toggle-const').addEventListener('click', () => {
    document.getElementById('constellation-panel').classList.toggle('visible');
});

document.getElementById('search-const').addEventListener('input', (e) => {
    const term = e.target.value.toLowerCase();
    document.querySelectorAll('.const-item').forEach(el => {
        el.style.display = el.innerText.toLowerCase().includes(term) ? 'flex' : 'none';
    });
});

document.getElementById('btn-reset-view').addEventListener('click', resetView);

function setupUI() {
    const bind = (id, key) => {
        const el = document.getElementById(id);
        if(!el) return;
        el.checked = settings[key];
        el.addEventListener('change', e => {
            settings[key] = e.target.checked;
            saveSettings();
            applyVisibilitySettings();
            if(key === 'iss') updateISS();
        });
    };

    bind('chk-grid', 'grid');
    bind('chk-stars', 'stars');
    bind('chk-lines', 'lines');
    bind('chk-const-names', 'constNames');
    bind('chk-planets', 'planets');
    bind('chk-traj', 'traj');
    bind('chk-iss', 'iss');
    bind('chk-ground', 'ground');

    document.getElementById('cam-out').addEventListener('click', () => {
        settings.camMode = 'out';
        saveSettings();
        applyCameraMode();
        applyVisibilitySettings();
    });
    
    document.getElementById('cam-in').addEventListener('click', () => {
        settings.camMode = 'in';
        saveSettings();
        applyCameraMode();
        applyVisibilitySettings();
    });
}

function onResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
}

function animate() {
    requestAnimationFrame(animate);
    controls.update();
    
    // –í—Ä–∞—â–µ–Ω–∏–µ –ú–ö–° –¥–ª—è –∫—Ä–∞—Å–æ—Ç—ã
    groups.iss.children.forEach(c => {
        if(c.type === 'Group') {
            c.rotation.z += 0.01;
        }
    });
    
    renderer.render(scene, camera);
}

init();

</script>
</body>
</html>