<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Карта Татарстана - Оптимизированная</title>
    
    <script src="https://api-maps.yandex.ru/2.1/?apikey=dde71a0e-b612-44b7-b53b-82533420240f&lang=ru_RU"></script>
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/proj4js/2.9.0/proj4.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">

    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        html, body {
            height: 100%; width: 100%;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #1a1a2e; overflow: hidden;
        }
        
        #map { width: 100%; height: 100%; position: absolute; top: 0; left: 0; z-index: 1; }
        
        .control-panel {
            position: absolute; top: 15px; left: 15px; z-index: 1000;
            background: rgba(255,255,255,0.95); backdrop-filter: blur(10px);
            padding: 15px; border-radius: 12px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.15);
            display: flex; flex-direction: column; gap: 10px; width: 320px;
        }
        
        .counter {
            background: linear-gradient(135deg, #28a745 0%, #20883a 100%);
            color: white; padding: 10px 16px; border-radius: 8px;
            font-size: 14px; font-weight: 600; display: flex; align-items: center; gap: 8px;
        }
        
        .stats {
            display: grid; grid-template-columns: 1fr 1fr; gap: 8px;
        }
        
        .stat-item {
            background: #f8f9fa; padding: 8px; border-radius: 6px;
            font-size: 11px; text-align: center;
        }
        .stat-value { font-size: 16px; font-weight: 700; color: #007bff; }
        .stat-label { color: #666; }

        .db-status {
            font-size: 12px; color: #666; background: #f0f0f0;
            padding: 8px; border-radius: 6px; text-align: center;
        }
        
        .local-status {
            font-size: 11px; color: #17a2b8; background: #e3f2fd;
            padding: 6px 8px; border-radius: 6px; text-align: center;
        }
        
        .btn {
            padding: 10px 16px; border: none; border-radius: 8px;
            font-size: 13px; font-weight: 500; cursor: pointer;
            transition: all 0.2s ease; display: flex; align-items: center; 
            justify-content: center; gap: 8px; color: white;
        }
        .btn:hover { transform: translateY(-1px); box-shadow: 0 4px 12px rgba(0,0,0,0.2); }
        .btn:disabled { opacity: 0.6; cursor: not-allowed; transform: none; }
        .btn-primary { background: linear-gradient(135deg, #007bff 0%, #0056b3 100%); }
        .btn-success { background: linear-gradient(135deg, #28a745 0%, #20883a 100%); }
        .btn-danger { background: linear-gradient(135deg, #dc3545 0%, #c82333 100%); }
        .btn-warning { background: linear-gradient(135deg, #ffc107 0%, #e0a800 100%); color: #333; }
        
        .btn-group { display: flex; gap: 8px; }
        .btn-group .btn { flex: 1; padding: 8px 10px; font-size: 12px; }
        
        .progress-container {
            display: none; background: #e9ecef; border-radius: 8px; 
            overflow: hidden; height: 24px; position: relative;
        }
        .progress-bar {
            height: 100%; background: linear-gradient(135deg, #007bff 0%, #0056b3 100%);
            transition: width 0.3s ease; display: flex; align-items: center;
            justify-content: center; color: white; font-size: 11px; font-weight: 600;
        }
        
        .zoom-info {
            font-size: 11px; color: #666; background: #fff3cd;
            padding: 6px 8px; border-radius: 6px; text-align: center;
        }
        
        #context-menu {
            position: absolute; display: none; z-index: 2000;
            background: white; min-width: 260px; border-radius: 12px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.25); padding: 8px 0;
        }
        #context-menu ul { list-style: none; }
        #context-menu li {
            padding: 12px 18px; font-size: 14px; cursor: pointer;
            display: flex; align-items: center; gap: 10px; color: #333;
            transition: background 0.2s;
        }
        #context-menu li:hover { background: #f0f4f8; }
        #context-menu .separator { height: 1px; background: #eee; margin: 4px 0; padding: 0; pointer-events: none; }
        
        .icon-db { color: #007bff; }
        .icon-cloud { color: #fd7e14; }
        
        #notifications {
            position: fixed; bottom: 20px; right: 20px; z-index: 9999;
            display: flex; flex-direction: column; gap: 10px;
        }
        .notification {
            padding: 14px 20px; border-radius: 10px; color: white;
            font-size: 14px; font-weight: 500; box-shadow: 0 4px 20px rgba(0,0,0,0.2);
            transform: translateX(120%); transition: transform 0.3s ease;
            display: flex; align-items: center; gap: 10px; max-width: 400px;
        }
        .notification.show { transform: translateX(0); }
        .notification.success { background: linear-gradient(135deg, #28a745 0%, #20883a 100%); }
        .notification.error { background: linear-gradient(135deg, #dc3545 0%, #c82333 100%); }
        .notification.info { background: linear-gradient(135deg, #17a2b8 0%, #138496 100%); }
        .notification.warning { background: linear-gradient(135deg, #ffc107 0%, #e0a800 100%); color: #333; }
        
        .loader-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.6); display: none;
            justify-content: center; align-items: center; z-index: 10000;
        }
        .loader-spinner {
            width: 50px; height: 50px; border: 4px solid rgba(255,255,255,0.3);
            border-top-color: white; border-radius: 50%;
            animation: spin 1s linear infinite; margin-bottom: 10px;
        }
        .loader-content { text-align: center; color: white; }
        @keyframes spin { to { transform: rotate(360deg); } }
        
        .divider { height: 1px; background: #e0e0e0; margin: 5px 0; }
    </style>
</head>
<body>

<div id="map"></div>

<div class="control-panel">
    <div class="counter">
        <i class="fas fa-layer-group"></i>
        <span id="counter-text">0 объектов на карте</span>
    </div>
    
    <div class="stats">
        <div class="stat-item">
            <div class="stat-value" id="stat-points">0</div>
            <div class="stat-label">точек</div>
        </div>
        <div class="stat-item">
            <div class="stat-value" id="stat-time">0</div>
            <div class="stat-label">мс рендер</div>
        </div>
    </div>
    
    <div class="zoom-info" id="zoom-info">
        <i class="fas fa-search-plus"></i> Зум: <span id="zoom-level">7</span> | Tolerance: <span id="tolerance-value">0.005</span>
    </div>
    
    <div class="db-status" id="db-status">
        <i class="fas fa-database"></i> Подключение к Supabase...
    </div>
    
    <div class="local-status" id="local-status">
        <i class="fas fa-hdd"></i> IndexedDB: проверка...
    </div>
    
    <div class="progress-container" id="progress-container">
        <div class="progress-bar" id="progress-bar">0%</div>
    </div>

    <button class="btn btn-primary" id="btn-load-all">
        <i class="fas fa-cloud-download-alt"></i> Загрузить всё из Supabase
    </button>
    
    <button class="btn btn-success" id="btn-load-local">
        <i class="fas fa-hdd"></i> Загрузить из локальной БД
    </button>
    
    <div class="divider"></div>
    
    <div class="btn-group">
        <button class="btn btn-danger" id="btn-clear">
            <i class="fas fa-eraser"></i> Очистить
        </button>
        <button class="btn btn-warning" id="btn-delete-local">
            <i class="fas fa-trash"></i> Удалить лок. БД
        </button>
    </div>
</div>

<div id="context-menu">
    <ul>
        <li id="ctx-smart">
            <i class="fas fa-magic icon-db"></i>
            Умный поиск (Кэш + NSPD)
        </li>
        <li class="separator"></li>
        <li id="ctx-force-nspd">
            <i class="fas fa-cloud-download-alt icon-cloud"></i>
            Прямой запрос к Росреестру
        </li>
    </ul>
</div>

<div id="notifications"></div>

<div class="loader-overlay" id="loader">
    <div class="loader-content">
        <div class="loader-spinner"></div>
        <div class="loader-text" id="loader-text">Загрузка...</div>
    </div>
</div>

<script>
// ============================================================
// 1. КОНФИГУРАЦИЯ
// ============================================================
const CONFIG = {
    supabase: {
        url: 'https://qgycxcmxlbyrjpdikyyz.supabase.co',
        key: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InFneWN4Y214bGJ5cmpwZGlreXl6Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjQzOTAxNTgsImV4cCI6MjA3OTk2NjE1OH0.UtamcsWCKPpMJwH1cWJhRhh8TL7Jb_NPA0-xLpyk_YU'
    },
    nspd: {
        url: 'https://nspd.gov.ru/api/aeggis/v3',
        layer: 36278
    },
    indexedDB: {
        name: 'TatarstanMapDB',
        version: 3,
        storeName: 'districts'
    },
    styles: {
        district: { 
            fillColor: 'rgba(0, 123, 255, 0.25)', 
            strokeColor: '#0056b3', 
            strokeWidth: 2,
            strokeOpacity: 0.9
        },
        settlement: { 
            fillColor: 'rgba(40, 167, 69, 0.3)', 
            strokeColor: '#28a745', 
            strokeWidth: 2,
            strokeOpacity: 0.9
        }
    }
};

proj4.defs('EPSG:3857', '+proj=merc +a=6378137 +b=6378137 +lat_ts=0.0 +lon_0=0.0 +x_0=0.0 +y_0=0 +k=1.0 +units=m +nadgrids=@null +wktext +no_defs');
proj4.defs('EPSG:4326', '+proj=longlat +datum=WGS84 +no_defs');

const supabaseClient = window.supabase.createClient(CONFIG.supabase.url, CONFIG.supabase.key);

// ============================================================
// 2. INDEXEDDB МЕНЕДЖЕР
// ============================================================
const LocalDB = {
    db: null,
    
    async init() {
        return new Promise((resolve, reject) => {
            const request = indexedDB.open(CONFIG.indexedDB.name, CONFIG.indexedDB.version);
            
            request.onerror = () => reject(request.error);
            
            request.onsuccess = () => {
                this.db = request.result;
                console.log('IndexedDB открыта');
                resolve(this.db);
            };
            
            request.onupgradeneeded = (event) => {
                const db = event.target.result;
                if (db.objectStoreNames.contains(CONFIG.indexedDB.storeName)) {
                    db.deleteObjectStore(CONFIG.indexedDB.storeName);
                }
                const store = db.createObjectStore(CONFIG.indexedDB.storeName, { keyPath: 'id' });
                store.createIndex('name', 'name', { unique: false });
                console.log('IndexedDB store создан');
            };
        });
    },
    
    async saveMany(districts) {
        if (!this.db) await this.init();
        
        return new Promise((resolve, reject) => {
            const transaction = this.db.transaction([CONFIG.indexedDB.storeName], 'readwrite');
            const store = transaction.objectStore(CONFIG.indexedDB.storeName);
            
            let saved = 0;
            districts.forEach(district => {
                const request = store.put(district);
                request.onsuccess = () => saved++;
            });
            
            transaction.oncomplete = () => {
                console.log(`IndexedDB: сохранено ${saved} записей`);
                resolve(saved);
            };
            transaction.onerror = () => reject(transaction.error);
        });
    },
    
    async getAll() {
        if (!this.db) await this.init();
        
        return new Promise((resolve, reject) => {
            const transaction = this.db.transaction([CONFIG.indexedDB.storeName], 'readonly');
            const store = transaction.objectStore(CONFIG.indexedDB.storeName);
            const request = store.getAll();
            
            request.onsuccess = () => resolve(request.result || []);
            request.onerror = () => reject(request.error);
        });
    },
    
    async getCount() {
        if (!this.db) await this.init();
        
        return new Promise((resolve, reject) => {
            const transaction = this.db.transaction([CONFIG.indexedDB.storeName], 'readonly');
            const store = transaction.objectStore(CONFIG.indexedDB.storeName);
            const request = store.count();
            
            request.onsuccess = () => resolve(request.result);
            request.onerror = () => reject(request.error);
        });
    },
    
    async getSize() {
        if (!this.db) await this.init();
        
        return new Promise((resolve, reject) => {
            const transaction = this.db.transaction([CONFIG.indexedDB.storeName], 'readonly');
            const store = transaction.objectStore(CONFIG.indexedDB.storeName);
            const request = store.getAll();
            
            request.onsuccess = () => {
                const data = request.result || [];
                const jsonString = JSON.stringify(data);
                const bytes = new Blob([jsonString]).size;
                resolve(bytes);
            };
            request.onerror = () => reject(request.error);
        });
    },
    
    async clear() {
        if (!this.db) await this.init();
        
        return new Promise((resolve, reject) => {
            const transaction = this.db.transaction([CONFIG.indexedDB.storeName], 'readwrite');
            const store = transaction.objectStore(CONFIG.indexedDB.storeName);
            const request = store.clear();
            
            request.onsuccess = () => resolve();
            request.onerror = () => reject(request.error);
        });
    },
    
    async deleteDatabase() {
        if (this.db) {
            this.db.close();
            this.db = null;
        }
        
        return new Promise((resolve, reject) => {
            const request = indexedDB.deleteDatabase(CONFIG.indexedDB.name);
            request.onsuccess = () => resolve();
            request.onerror = () => reject(request.error);
        });
    }
};

// ============================================================
// 3. УТИЛИТЫ
// ============================================================
const UI = {
    notify(message, type = 'info') {
        const container = document.getElementById('notifications');
        const div = document.createElement('div');
        div.className = `notification ${type}`;
        const icons = { success: 'check-circle', error: 'exclamation-circle', warning: 'exclamation-triangle', info: 'info-circle' };
        div.innerHTML = `<i class="fas fa-${icons[type] || 'info-circle'}"></i> ${message}`;
        container.appendChild(div);
        setTimeout(() => div.classList.add('show'), 10);
        setTimeout(() => { div.classList.remove('show'); setTimeout(() => div.remove(), 300); }, 4000);
    },
    
    showLoader(text = 'Загрузка...') {
        document.getElementById('loader-text').textContent = text;
        document.getElementById('loader').style.display = 'flex';
    },
    
    hideLoader() { 
        document.getElementById('loader').style.display = 'none'; 
    },
    
    updateCounter(count) { 
        document.getElementById('counter-text').textContent = `${count} объектов на карте`; 
    },
    
    updateStats(points, time) {
        document.getElementById('stat-points').textContent = points.toLocaleString();
        document.getElementById('stat-time').textContent = time;
    },
    
    updateZoomInfo(zoom) {
        document.getElementById('zoom-level').textContent = zoom;
        const tolerance = zoom <= 6 ? 0.01 : zoom <= 8 ? 0.005 : zoom <= 10 ? 0.002 : zoom <= 12 ? 0.001 : 0.0005;
        document.getElementById('tolerance-value').textContent = tolerance;
    },
    
    updateStatus(text) { 
        document.getElementById('db-status').innerHTML = `<i class="fas fa-database"></i> ${text}`; 
    },
    
    updateLocalStatus(text) {
        document.getElementById('local-status').innerHTML = `<i class="fas fa-hdd"></i> ${text}`;
    },
    
    showProgress(percent, text = '') {
        const container = document.getElementById('progress-container');
        const bar = document.getElementById('progress-bar');
        container.style.display = 'block';
        bar.style.width = `${percent}%`;
        bar.textContent = text || `${Math.round(percent)}%`;
    },
    
    hideProgress() {
        document.getElementById('progress-container').style.display = 'none';
    },
    
    formatBytes(bytes) {
        if (bytes < 1024) return bytes + ' B';
        if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + ' KB';
        return (bytes / (1024 * 1024)).toFixed(2) + ' MB';
    }
};

const GeoUtils = {
    toMercator(latLon) { 
        return proj4('EPSG:4326', 'EPSG:3857', [latLon[1], latLon[0]]); 
    },
    
    convertForDB(geometry) {
        const processCoord = (coord) => {
            if (!coord || coord.length < 2) return null;
            const [lon, lat] = proj4('EPSG:3857', 'EPSG:4326', coord);
            return [Math.round(lon * 1e9) / 1e9, Math.round(lat * 1e9) / 1e9];
        };
        
        const processRing = (ring) => {
            if (!ring || !Array.isArray(ring)) return [];
            return ring.map(processCoord).filter(c => c !== null);
        };
        
        if (geometry.type === 'Polygon') {
            return { type: 'Polygon', coordinates: geometry.coordinates.map(processRing).filter(r => r.length >= 3) };
        } else if (geometry.type === 'MultiPolygon') {
            return { 
                type: 'MultiPolygon', 
                coordinates: geometry.coordinates
                    .map(poly => poly.map(processRing).filter(r => r.length >= 3))
                    .filter(poly => poly.length > 0)
            };
        }
        return { type: geometry.type, coordinates: geometry.coordinates };
    },

   convertForYandex(geometry) {
    let pointCount = 0;
    
    // Глубокая валидация координаты
    const isValidCoord = (c) => {
        return c && 
               Array.isArray(c) && 
               c.length >= 2 && 
               typeof c[0] === 'number' && 
               typeof c[1] === 'number' && 
               !isNaN(c[0]) && 
               !isNaN(c[1]) &&
               isFinite(c[0]) &&
               isFinite(c[1]);
    };
    
    const swap = (c) => {
        if (!isValidCoord(c)) return null;
        pointCount++;
        return [c[1], c[0]];
    };
    
    // Валидация кольца (ring) полигона
    const processRing = (ring) => {
        if (!ring || !Array.isArray(ring)) return null;
        const processed = ring.map(swap).filter(c => c !== null);
        // Кольцо должно иметь минимум 4 точки (3 + замыкающая)
        return processed.length >= 4 ? processed : null;
    };
    
    // Валидация полигона
    const processPolygon = (polygon) => {
        if (!polygon || !Array.isArray(polygon)) return null;
        const rings = polygon.map(processRing).filter(r => r !== null);
        // Полигон должен иметь хотя бы внешнее кольцо
        return rings.length > 0 ? rings : null;
    };
    
    const newGeom = { type: geometry.type, coordinates: [] };
    
    if (geometry.type === 'Polygon') {
        const processed = processPolygon(geometry.coordinates);
        if (!processed) return { geometry: null, pointCount: 0 };
        newGeom.coordinates = processed;
    } 
    else if (geometry.type === 'MultiPolygon') {
        const polygons = geometry.coordinates
            .map(processPolygon)
            .filter(p => p !== null);
        if (polygons.length === 0) return { geometry: null, pointCount: 0 };
        newGeom.coordinates = polygons;
    }
    else {
        return { geometry: null, pointCount: 0 };
    }
    
    return { geometry: newGeom, pointCount };
}
};

// ============================================================
// 4. DATA SERVICE
// ============================================================
const DataService = {
    async findInDB(lat, lon) {
        const { data, error } = await supabaseClient.rpc('find_districts_at_point', { lat, lon });
        if (error) throw new Error('Ошибка БД: ' + error.message);
        return data || [];
    },

    async fetchFromNSPD(lat, lon) {
        const [x, y] = GeoUtils.toMercator([lat, lon]);
        const delta = 0.05;
        const bbox = `${x - delta},${y - delta},${x + delta},${y + delta}`;
        
        const params = new URLSearchParams({
            REQUEST: 'GetFeatureInfo', 
            QUERY_LAYERS: CONFIG.nspd.layer, 
            SERVICE: 'WMS', 
            VERSION: '1.3.0',
            FORMAT: 'image/png', 
            STYLES: '', 
            TRANSPARENT: 'true', 
            LAYERS: CONFIG.nspd.layer,
            RANDOM: Math.random(), 
            INFO_FORMAT: 'application/json',
            FEATURE_COUNT: '10', 
            I: '256', J: '256', WIDTH: '512', HEIGHT: '512', 
            CRS: 'EPSG:3857', 
            BBOX: bbox
        });
        
        const url = `${CONFIG.nspd.url}/${CONFIG.nspd.layer}/wms?${params}`;
        console.log('Запрос URL:', url);
        
        const res = await fetch(url);
        if (!res.ok) throw new Error(`НСПД вернул статус ${res.status}`);
        const data = await res.json();
        
        if (data.code && data.message) {
            throw new Error(`НСПД API Ошибка: ${data.message}`);
        }
        
        return data.features || [];
    },

    async saveToDB(features) {
        if (!features.length) return [];
        
        const items = features.map(f => {
            const props = f.properties || {};
            const name = props.name || props.options?.name || '';
            const cadastral = props.label || props.options?.label || props.options?.code || '';
            return {
                feature: f,
                name: name,
                cadastral: cadastral,
                nameLower: name.toLowerCase(),
                geomSize: JSON.stringify(f.geometry).length
            };
        });
        
        items.sort((a, b) => b.geomSize - a.geomSize);
        
        let districtName = null;
        for (const item of items) {
            if (item.nameLower.includes('район') && !item.nameLower.includes('поселение')) {
                districtName = item.name;
                console.log('>>> НАЙДЕН РАЙОН:', districtName);
                break;
            }
        }
        
        const rows = [];
        
        for (const item of items) {
            const props = item.feature.properties || {};
            const id = item.cadastral || `temp-${Date.now()}-${Math.random().toString(36).substr(2, 5)}`;
            
            let finalName = item.name;
            
            const isPoselenie = item.nameLower.includes('поселение');
            const isRayon = item.nameLower.includes('район') && !item.nameLower.includes('поселение');
            
            if (isPoselenie && districtName && !item.name.includes(districtName)) {
                finalName = districtName + ' - ' + item.name;
            }
            
            console.log(`[${isRayon ? 'РАЙОН' : 'ПОСЕЛЕНИЕ'}] "${item.name}" => "${finalName}"`);
            
            rows.push({
                id: id,
                name: finalName,
                geom: GeoUtils.convertForDB(item.feature.geometry),
                properties: {
                    ...props,
                    descr: finalName,
                    originalName: item.name,
                    parentDistrict: isRayon ? null : districtName
                }
            });
        }
        
        const { data, error } = await supabaseClient.rpc('upsert_districts', { 
            districts_data: rows 
        });
        
        if (error) throw new Error('Ошибка сохранения: ' + error.message);
        
        console.log('Сохранено в БД:', data);
        return rows;
    },
    
    async loadAllFromSupabase(zoom = 10, onProgress) {
        const startTime = performance.now();
        
        if (onProgress) onProgress(10, 'Запрос к Supabase...');
        
        const { data, error } = await supabaseClient.rpc('get_all_districts_for_zoom', { 
            zoom_level: zoom 
        });
        
        if (error) throw new Error('Ошибка загрузки: ' + error.message);
        
        const loadTime = Math.round(performance.now() - startTime);
        console.log(`Загружено ${data?.length || 0} записей за ${loadTime}мс`);
        
        if (onProgress) onProgress(100, `Загружено за ${loadTime}мс`);
        
        return data || [];
    }
};

// ============================================================
// 5. ПРИЛОЖЕНИЕ
// ============================================================
const App = {
    map: null,
    objectManager: null,
    clickedCoords: null,
    totalPoints: 0,

    async init() {
        UI.showLoader('Инициализация...');
        
        try {
            await LocalDB.init();
            await this.updateLocalStatus();
        } catch (e) {
            console.error('Ошибка IndexedDB:', e);
        }
        
        ymaps.ready(() => {
            this.map = new ymaps.Map('map', {
                center: [55.35, 50.75], 
                zoom: 7,
                controls: ['zoomControl', 'typeSelector']
            });
            
            this.initObjectManager();
            this.setupEvents();
            this.checkConnection();
            UI.updateZoomInfo(7);
            UI.hideLoader();
        });
    },
    
    initObjectManager() {
        this.objectManager = new ymaps.ObjectManager({
            clusterize: false,
            gridSize: 64
        });
        
        this.map.geoObjects.add(this.objectManager);
        console.log('ObjectManager инициализирован');
    },

    async checkConnection() {
        const { count, error } = await supabaseClient.from('districts').select('*', { count: 'exact', head: true });
        if (error) {
            UI.updateStatus('Ошибка подключения');
        } else {
            UI.updateStatus(`Supabase: ${count || 0} записей`);
        }
    },
    
    async updateLocalStatus() {
        try {
            const count = await LocalDB.getCount();
            const bytes = await LocalDB.getSize();
            const sizeStr = UI.formatBytes(bytes);
            UI.updateLocalStatus(`IndexedDB: ${count} записей (${sizeStr})`);
        } catch (e) {
            UI.updateLocalStatus('IndexedDB: ошибка');
        }
    },

    setupEvents() {
        this.map.events.add('boundschange', () => {
            const zoom = this.map.getZoom();
            UI.updateZoomInfo(Math.round(zoom));
        });
        
        this.map.events.add('contextmenu', (e) => {
            this.clickedCoords = e.get('coords');
            const menu = document.getElementById('context-menu');
            const [x, y] = e.get('position');
            menu.style.left = x + 'px';
            menu.style.top = y + 'px';
            menu.style.display = 'block';
        });

        const hideMenu = () => document.getElementById('context-menu').style.display = 'none';
        this.map.events.add('click', hideMenu);
        document.getElementById('map').addEventListener('click', hideMenu);

     document.getElementById('btn-clear').addEventListener('click', () => {
    this.objectManager.removeAll();
    this.totalPoints = 0;
    UI.updateCounter(0);
    UI.updateStats(0, 0);
    UI.notify('Карта очищена', 'info');
});

        document.getElementById('ctx-smart').addEventListener('click', () => {
            hideMenu();
            this.handleSmartSearch(this.clickedCoords);
        });

        document.getElementById('ctx-force-nspd').addEventListener('click', () => {
            hideMenu();
            this.handleForceNSPDSearch(this.clickedCoords);
        });
        
        document.getElementById('btn-load-all').addEventListener('click', () => {
            this.handleLoadAllFromSupabase();
        });
        
        document.getElementById('btn-load-local').addEventListener('click', () => {
            this.handleLoadFromLocal();
        });
        
        document.getElementById('btn-delete-local').addEventListener('click', () => {
            this.handleDeleteLocalDB();
        });
    },

    async handleSmartSearch([lat, lon]) {
        UI.showLoader('Поиск в базе данных...');
        try {
            let districts = await DataService.findInDB(lat, lon);
            
            if (districts.length < 2) {
                UI.showLoader('Запрос к Росреестру...');
                const rawFeatures = await DataService.fetchFromNSPD(lat, lon);
                
                if (rawFeatures.length > 0) {
                    await DataService.saveToDB(rawFeatures);
                    districts = await DataService.findInDB(lat, lon);
                    UI.notify(`Найдено и сохранено: ${rawFeatures.length}`, 'success');
                } else {
                    if (districts.length === 0) UI.notify('Ничего не найдено', 'warning');
                }
            } else {
                UI.notify('Данные загружены из кэша', 'success');
            }
            
            this.renderDistricts(districts);
            
            if (districts.length > 0) {
                await LocalDB.saveMany(districts);
                await this.updateLocalStatus();
            }
        } catch (e) {
            console.error(e);
            UI.notify(e.message, 'error');
        } finally {
            UI.hideLoader();
        }
    },

    async handleForceNSPDSearch([lat, lon]) {
        UI.showLoader('Прямой запрос к Росреестру...');
        try {
            const rawFeatures = await DataService.fetchFromNSPD(lat, lon);
            
            if (rawFeatures.length > 0) {
                UI.showLoader('Сохранение в базу...');
                await DataService.saveToDB(rawFeatures);
                const districts = await DataService.findInDB(lat, lon);
                this.renderDistricts(districts);
                UI.notify(`Загружено из НСПД: ${rawFeatures.length}`, 'success');
                
                await LocalDB.saveMany(districts);
                await this.updateLocalStatus();
            } else {
                UI.notify('Росреестр не вернул данных', 'warning');
            }
        } catch (e) {
            console.error(e);
            UI.notify('Ошибка НСПД: ' + e.message, 'error');
        } finally {
            UI.hideLoader();
        }
    },
    
    async handleLoadAllFromSupabase() {
        const btn = document.getElementById('btn-load-all');
        btn.disabled = true;
        
        UI.showProgress(0, 'Загрузка из Supabase...');
        
        try {
            const zoom = Math.round(this.map.getZoom());
            const districts = await DataService.loadAllFromSupabase(zoom, (progress, text) => {
                UI.showProgress(progress, text);
            });
            
            if (districts.length === 0) {
                UI.notify('База данных Supabase пуста', 'warning');
                UI.hideProgress();
                btn.disabled = false;
                return;
            }
            
            UI.showProgress(50, 'Сохранение в IndexedDB...');
            await LocalDB.saveMany(districts);
            await this.updateLocalStatus();
            
            UI.showProgress(75, 'Отрисовка на карте...');
            this.renderDistricts(districts);
            
            UI.notify(`Загружено ${districts.length} объектов`, 'success');
        } catch (e) {
            console.error(e);
            UI.notify('Ошибка загрузки: ' + e.message, 'error');
        } finally {
            UI.hideProgress();
            btn.disabled = false;
        }
    },
    
    async handleLoadFromLocal() {
        const btn = document.getElementById('btn-load-local');
        btn.disabled = true;
        
        UI.showLoader('Загрузка из IndexedDB...');
        
        try {
            const districts = await LocalDB.getAll();
            
            if (districts.length === 0) {
                UI.notify('Локальная база пуста', 'warning');
            } else {
                this.renderDistricts(districts);
                UI.notify(`Загружено ${districts.length} объектов из локальной БД`, 'success');
            }
        } catch (e) {
            console.error(e);
            UI.notify('Ошибка загрузки: ' + e.message, 'error');
        } finally {
            UI.hideLoader();
            btn.disabled = false;
        }
    },
    
    async handleDeleteLocalDB() {
        if (!confirm('Удалить локальную базу данных?')) return;
        
        try {
            await LocalDB.deleteDatabase();
            await LocalDB.init();
            await this.updateLocalStatus();
            UI.notify('Локальная БД удалена', 'success');
        } catch (e) {
            console.error(e);
            UI.notify('Ошибка удаления: ' + e.message, 'error');
        }
    },

renderDistricts(districts) {
    if (!districts.length) return;
    
    const startTime = performance.now();
    
    // Очищаем ObjectManager
    this.objectManager.removeAll();
    
    // Сортируем по размеру (безопасно)
    districts.sort((a, b) => {
        const sizeA = a.geom ? JSON.stringify(a.geom).length : 0;
        const sizeB = b.geom ? JSON.stringify(b.geom).length : 0;
        return sizeB - sizeA;
    });

    const features = [];
    let totalPoints = 0;
    let skipped = 0;
    
    for (let index = 0; index < districts.length; index++) {
        const d = districts[index];
        const rawGeom = d.geom;
        
        // Базовые проверки
        if (!rawGeom || !rawGeom.type || !rawGeom.coordinates) {
            console.warn('Пропуск - нет геометрии:', d.id);
            skipped++;
            continue;
        }
        
        if (!Array.isArray(rawGeom.coordinates) || rawGeom.coordinates.length === 0) {
            console.warn('Пропуск - пустые координаты:', d.id);
            skipped++;
            continue;
        }
        
        try {
            const { geometry: yandexGeom, pointCount } = GeoUtils.convertForYandex(rawGeom);
            
            // Проверка результата конвертации
            if (!yandexGeom || !yandexGeom.coordinates || yandexGeom.coordinates.length === 0) {
                console.warn('Пропуск - невалидная геометрия:', d.id);
                skipped++;
                continue;
            }
            
            // Финальная проверка структуры
            if (yandexGeom.type === 'Polygon') {
                if (!yandexGeom.coordinates[0] || yandexGeom.coordinates[0].length < 4) {
                    console.warn('Пропуск - мало точек в Polygon:', d.id);
                    skipped++;
                    continue;
                }
                // Проверяем первую точку первого кольца
                const firstPoint = yandexGeom.coordinates[0][0];
                if (!firstPoint || !Array.isArray(firstPoint) || firstPoint.length < 2) {
                    console.warn('Пропуск - битая первая точка:', d.id);
                    skipped++;
                    continue;
                }
            }
            
            if (yandexGeom.type === 'MultiPolygon') {
                if (!yandexGeom.coordinates[0] || 
                    !yandexGeom.coordinates[0][0] || 
                    yandexGeom.coordinates[0][0].length < 4) {
                    console.warn('Пропуск - мало точек в MultiPolygon:', d.id);
                    skipped++;
                    continue;
                }
                // Проверяем первую точку первого кольца первого полигона
                const firstPoint = yandexGeom.coordinates[0][0][0];
                if (!firstPoint || !Array.isArray(firstPoint) || firstPoint.length < 2) {
                    console.warn('Пропуск - битая первая точка MultiPolygon:', d.id);
                    skipped++;
                    continue;
                }
            }
            
            totalPoints += pointCount;
            
            const nameLower = (d.name || '').toLowerCase();
            const isDistrict = nameLower.includes('район') && !nameLower.includes('поселение');
            const style = isDistrict ? CONFIG.styles.district : CONFIG.styles.settlement;
            
            const featureId = String(d.id || `f-${index}-${Date.now()}`);
            
            features.push({
                type: 'Feature',
                id: featureId,
                geometry: yandexGeom,
                properties: {
                    hintContent: d.name || 'Без названия',
                    balloonContentHeader: d.name || 'Без названия',
                    balloonContentBody: `
                        <div style="font-size:13px">
                            <strong>ID:</strong> ${d.id}<br>
                            <strong>Тип:</strong> ${isDistrict ? 'Район' : 'Поселение'}<br>
                            <strong>Точек:</strong> ${pointCount.toLocaleString()}
                        </div>
                    `
                },
                options: {
                    fillColor: style.fillColor,
                    strokeColor: style.strokeColor,
                    strokeWidth: style.strokeWidth,
                    strokeOpacity: style.strokeOpacity
                }
            });
            
        } catch (e) {
            console.error('Ошибка обработки:', d.id, e);
            skipped++;
        }
    }

    console.log(`Валидных: ${features.length}, пропущено: ${skipped}`);

    if (features.length === 0) {
        UI.notify('Нет валидных объектов', 'warning');
        return;
    }

    // Добавляем порциями для избежания ошибок
    const BATCH_SIZE = 50;
    for (let i = 0; i < features.length; i += BATCH_SIZE) {
        const batch = features.slice(i, i + BATCH_SIZE);
        try {
            this.objectManager.add({
                type: 'FeatureCollection',
                features: batch
            });
        } catch (e) {
            console.error(`Ошибка добавления батча ${i}-${i + batch.length}:`, e);
            // Пробуем добавить по одному
            batch.forEach((feature, idx) => {
                try {
                    this.objectManager.add({
                        type: 'FeatureCollection',
                        features: [feature]
                    });
                } catch (e2) {
                    console.error(`Ошибка добавления объекта ${feature.id}:`, e2);
                }
            });
        }
    }

    const renderTime = Math.round(performance.now() - startTime);
    this.totalPoints = totalPoints;
    
    const addedCount = this.objectManager.objects.getLength();
    UI.updateCounter(addedCount);
    UI.updateStats(totalPoints, renderTime);
    
    console.log(`Отрисовано ${addedCount} объектов, ${totalPoints.toLocaleString()} точек за ${renderTime}мс`);
    
    // Центрируем карту
    if (addedCount > 0) {
        try {
            const bounds = this.objectManager.getBounds();
            if (bounds) {
                this.map.setBounds(bounds, { checkZoomRange: true, duration: 300 });
            }
        } catch (e) {
            console.warn('Не удалось центрировать:', e);
        }
    }
}
};

App.init();
</script>
</body>
</html>