<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>–ö–æ–Ω–≤–µ—Ä—Ç–µ—Ä XML –ö–ü–¢ (–≤ v10) - –ò—Å–ø—Ä–∞–≤–ª–µ–Ω–æ</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            line-height: 1.6;
            margin: 0;
            padding: 20px;
            background-color: #f0f2f5;
            color: #333;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
        }
        .container {
            max-width: 800px;
            width: 100%;
            background: #fff;
            padding: 30px 40px;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.1);
            text-align: center;
        }
        h1 {
            color: #0056b3;
            margin-bottom: 10px;
        }
        p {
            color: #555;
            margin-bottom: 30px;
        }
        .upload-area {
            border: 2px dashed #007bff;
            border-radius: 8px;
            padding: 40px;
            cursor: pointer;
            transition: background-color 0.3s, border-color 0.3s;
        }
        .upload-area.highlight {
            background-color: #f0f8ff;
            border-color: #0056b3;
        }
        .upload-area__icon {
            font-size: 48px;
            color: #007bff;
        }
        .upload-area__text {
            font-size: 18px;
            font-weight: 500;
            margin-top: 15px;
        }
        input[type="file"] {
            display: none;
        }
        #result {
            margin-top: 30px;
            text-align: left;
            padding: 20px;
            background-color: #e9f7ef;
            border: 1px solid #28a745;
            border-radius: 8px;
            display: none;
        }
        #result a {
            display: inline-block;
            background-color: #28a745;
            color: white;
            padding: 12px 20px;
            text-decoration: none;
            border-radius: 5px;
            font-weight: bold;
            transition: background-color 0.3s;
        }
        #result a:hover {
            background-color: #218838;
        }
        #errorMessage {
            color: #dc3545;
            margin-top: 20px;
            font-weight: bold;
            display: none;
        }
        #loader {
            display: none;
            margin-top: 20px;
        }
    </style>
</head>
<body>

    <div class="container">
        <h1>–ö–æ–Ω–≤–µ—Ä—Ç–µ—Ä –≤—ã–ø–∏—Å–∫–∏ –ö–ü–¢</h1>
        <p>–ü—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ XML-—Ñ–∞–π–ª–∞ –∏–∑ —Å—Ç–∞—Ä–æ–≥–æ —Ñ–æ—Ä–º–∞—Ç–∞ –≤ –Ω–æ–≤—ã–π (—Å—Ö–µ–º–∞ KPT v.10)</p>

        <input type="file" id="fileInput" accept=".xml">
        <label for="fileInput" class="upload-area" id="uploadArea">
            <div class="upload-area__icon">üì§</div>
            <div class="upload-area__text" id="uploadText">–ù–∞–∂–º–∏—Ç–µ –∏–ª–∏ –ø–µ—Ä–µ—Ç–∞—â–∏—Ç–µ —Å—é–¥–∞ XML-—Ñ–∞–π–ª</div>
        </label>
        
        <div id="loader">–û–±—Ä–∞–±–æ—Ç–∫–∞ —Ñ–∞–π–ª–∞...</div>
        <div id="errorMessage"></div>
        <div id="result">
            <p>‚úÖ <strong>–ö–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏—è —É—Å–ø–µ—à–Ω–æ –∑–∞–≤–µ—Ä—à–µ–Ω–∞!</strong></p>
            <a href="#" id="downloadLink" download="KPT_v10_converted.xml">–°–∫–∞—á–∞—Ç—å –Ω–æ–≤—ã–π XML-—Ñ–∞–π–ª</a>
        </div>
    </div>

<script>
// --- Polyfill for older browsers ---
if (!Element.prototype.matches) {
    Element.prototype.matches = Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;
}
if (!Element.prototype.closest) {
    Element.prototype.closest = function(s) {
        var el = this;
        do {
            if (el.matches(s)) return el;
            el = el.parentElement || el.parentNode;
        } while (el !== null && el.nodeType === 1);
        return null;
    };
}
// --- End Polyfill ---


const fileInput = document.getElementById('fileInput');
const uploadArea = document.getElementById('uploadArea');
const uploadText = document.getElementById('uploadText');
const resultDiv = document.getElementById('result');
const downloadLink = document.getElementById('downloadLink');
const errorMessageDiv = document.getElementById('errorMessage');
const loader = document.getElementById('loader');

// --- Event Listeners for file input and drag-and-drop ---

// **–ò–°–ü–†–ê–í–õ–ï–ù–ò–ï:** –≠—Ç–∞ —Å—Ç—Ä–æ–∫–∞ –±—ã–ª–∞ —É–¥–∞–ª–µ–Ω–∞. –¢–µ–ø–µ—Ä—å –∫–ª–∏–∫ –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç—Å—è —Ç–æ–ª—å–∫–æ —á–µ—Ä–µ–∑ HTML-–∞—Ç—Ä–∏–±—É—Ç for="fileInput"
// uploadArea.addEventListener('click', () => fileInput.click()); 

fileInput.addEventListener('change', () => {
    if (fileInput.files.length > 0) {
        handleFile(fileInput.files[0]);
    }
});
['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
    uploadArea.addEventListener(eventName, preventDefaults, false);
});
['dragenter', 'dragover'].forEach(eventName => {
    uploadArea.addEventListener(eventName, () => uploadArea.classList.add('highlight'), false);
});
['dragleave', 'drop'].forEach(eventName => {
    uploadArea.addEventListener(eventName, () => uploadArea.classList.remove('highlight'), false);
});
uploadArea.addEventListener('drop', (e) => {
    if (e.dataTransfer.files.length > 0) {
        fileInput.files = e.dataTransfer.files;
        handleFile(e.dataTransfer.files[0]);
    }
}, false);

function preventDefaults(e) {
    e.preventDefault();
    e.stopPropagation();
}

// --- Main file handling function ---
function handleFile(file) {
    uploadText.textContent = `–í—ã–±—Ä–∞–Ω —Ñ–∞–π–ª: ${file.name}`;
    resultDiv.style.display = 'none';
    errorMessageDiv.style.display = 'none';
    loader.style.display = 'block';

    const reader = new FileReader();
    reader.onload = (event) => {
        try {
            const xmlString = event.target.result;
            const parser = new DOMParser();
            const oldXmlDoc = parser.parseFromString(xmlString, "application/xml");
            
            const parserError = oldXmlDoc.querySelector("parsererror");
            if (parserError) {
                throw new Error(`–û—à–∏–±–∫–∞ —Ä–∞–∑–±–æ—Ä–∞ XML: ${parserError.textContent}`);
            }

            const newXmlString = convertXml(oldXmlDoc);
            
            const blob = new Blob([newXmlString], { type: 'application/xml;charset=utf-8' });
            downloadLink.href = URL.createObjectURL(blob);
            
            const cadNumber = oldXmlDoc.querySelector('cadastral_block > cadastral_number')?.textContent || 'unknown';
            downloadLink.download = `KPT_${cadNumber.replace(/:/g, '_')}_v10.xml`;
            
            resultDiv.style.display = 'block';
        } catch (error) {
            console.error(error);
            errorMessageDiv.textContent = `–û—à–∏–±–∫–∞: ${error.message}`;
            errorMessageDiv.style.display = 'block';
        } finally {
            loader.style.display = 'none';
        }
    };
    reader.onerror = () => {
        errorMessageDiv.textContent = '–ù–µ —É–¥–∞–ª–æ—Å—å –ø—Ä–æ—á–∏—Ç–∞—Ç—å —Ñ–∞–π–ª.';
        errorMessageDiv.style.display = 'block';
        loader.style.display = 'none';
    };
    reader.readAsText(file, 'UTF-8');
}


// --- XML Conversion Logic (–±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π) ---

// Namespace constants for clarity
const NS_KPT = "urn://x-artefacts-rosreestr-ru/outgoing/kpt/10.0.1";
const NS_ADR = "urn://x-artefacts-rosreestr-ru/commons/complex-types/address-output/4.0.1";
const NS_SPATIAL = "urn://x-artefacts-rosreestr-ru/commons/complex-types/entity-spatial/5.0.1";
const NS_OKS = "urn://x-artefacts-rosreestr-ru/commons/complex-types/parameters-oks/2.0.1";
const NS_CERT = "urn://x-artefacts-rosreestr-ru/commons/complex-types/certification-doc/1.0";

// Helper to get text content safely
const getNodeValue = (parent, selector) => parent.querySelector(selector)?.textContent.trim() || '';

// Main conversion function
function convertXml(oldDoc) {
    const newDoc = document.implementation.createDocument(NS_KPT, 'KPT', null);
    const root = newDoc.documentElement;

    // Set all necessary namespaces on the root element
    root.setAttribute('xmlns:adrOut4', NS_ADR);
    root.setAttribute('xmlns:ns3', NS_SPATIAL);
    root.setAttribute('xmlns:ns4', NS_OKS);
    root.setAttribute('xmlns:ns5', "urn://x-artefacts-rosreestr-ru/commons/complex-types/document-output/4.0.1");
    root.setAttribute('xmlns:ns6', NS_CERT);
    root.setAttribute('xmlns:ns7', "urn://x-artefacts-smev-gov-ru/supplementary/commons/1.0.1");

    const coordSystems = new Map();
    let csCounter = { value: 1 };

    // --- Cadastral Blocks ---
    const cadastralBlocks = newDoc.createElementNS(NS_KPT, 'CadastralBlocks');
    oldDoc.querySelectorAll('cadastral_block').forEach(oldBlock => {
        const newBlock = newDoc.createElementNS(NS_KPT, 'CadastralBlock');
        newBlock.setAttribute('CadastralNumber', getNodeValue(oldBlock, 'cadastral_number'));
        
        const area = newDoc.createElementNS(NS_KPT, 'Area');
        const total = newDoc.createElementNS(NS_KPT, 'Total');
        total.textContent = getNodeValue(oldBlock, 'area_quarter area');
        area.appendChild(total);
        const unit = newDoc.createElementNS(NS_KPT, 'Unit');
        unit.textContent = getNodeValue(oldBlock, 'area_quarter unit');
        area.appendChild(unit);
        newBlock.appendChild(area);

        // Process different types of records
        newBlock.appendChild(convertParcels(oldBlock, newDoc, coordSystems, csCounter));
        newBlock.appendChild(convertObjectsRealty(oldBlock, newDoc, coordSystems, csCounter));
        newBlock.appendChild(convertSpatialData(oldBlock, newDoc, coordSystems, csCounter));
        newBlock.appendChild(convertBounds(oldBlock, newDoc, coordSystems, csCounter));
        newBlock.appendChild(convertZones(oldBlock, newDoc, coordSystems, csCounter));
        
        cadastralBlocks.appendChild(newBlock);
    });
    root.appendChild(cadastralBlocks);

    // --- Coordinate Systems (at the end) ---
    root.appendChild(createCoordSystemsNode(newDoc, coordSystems));

    // --- Certification Document ---
    root.appendChild(createCertificationDocNode(oldDoc, newDoc));

    // Serialize and format the new XML
    const serializer = new XMLSerializer();
    let xmlString = serializer.serializeToString(newDoc);
    
    // Add XML declaration manually for proper formatting
    return '<?xml version="1.0" encoding="UTF-8"?>\n' + xmlString;
}


// --- Component Conversion Functions ---

function createCertificationDocNode(oldDoc, newDoc) {
    const certDoc = newDoc.createElementNS(NS_KPT, 'CertificationDoc');
    const statement = oldDoc.querySelector('details_statement');
    if (!statement) return certDoc;
    
    const org = newDoc.createElementNS(NS_CERT, 'ns6:Organization');
    org.textContent = getNodeValue(statement, 'organ_registr_rights');
    certDoc.appendChild(org);
    
    const date = newDoc.createElementNS(NS_CERT, 'ns6:Date');
    date.textContent = getNodeValue(statement, 'date_formation');
    certDoc.appendChild(date);
    
    const number = newDoc.createElementNS(NS_CERT, 'ns6:Number');
    number.textContent = getNodeValue(statement, 'registration_number');
    certDoc.appendChild(number);

    return certDoc;
}

function convertParcels(oldBlock, newDoc, coordSystems, csCounter) {
    const parcelsNode = newDoc.createElementNS(NS_KPT, 'Parcels');
    oldBlock.querySelectorAll('land_record').forEach(oldParcel => {
        const newParcel = newDoc.createElementNS(NS_KPT, 'Parcel');
        newParcel.setAttribute('CadastralNumber', getNodeValue(oldParcel, 'object common_data cad_number'));
        newParcel.setAttribute('State', '01'); // Assuming state is always 01

        // Area
        const areaNode = newDoc.createElementNS(NS_KPT, 'Area');
        const areaVal = newDoc.createElementNS(NS_KPT, 'Area');
        areaVal.textContent = getNodeValue(oldParcel, 'params area value');
        areaNode.appendChild(areaVal);
        areaNode.appendChild(createElementWithText(newDoc, NS_KPT, 'Unit', '055')); // Unit for parcel area is 'sq.m'
        const inaccuracy = getNodeValue(oldParcel, 'params area inaccuracy');
        if (inaccuracy) areaNode.appendChild(createElementWithText(newDoc, NS_KPT, 'Inaccuracy', inaccuracy));
        newParcel.appendChild(areaNode);

        // Name (from subtype)
        const subtypeVal = getNodeValue(oldParcel, 'object subtype value');
        if (subtypeVal.toLowerCase().includes('–∑–µ–º–ª–µ–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ')) {
             newParcel.appendChild(createElementWithText(newDoc, NS_KPT, 'Name', '01'));
        }
        
        // Location (Address)
        const location = newDoc.createElementNS(NS_KPT, 'Location');
        location.appendChild(createAddressNode(oldParcel.querySelector('address_location'), newDoc));
        newParcel.appendChild(location);

        // Category
        newParcel.appendChild(createElementWithText(newDoc, NS_KPT, 'Category', getNodeValue(oldParcel, 'params category type code')));

        // Utilization
        const utilNode = newDoc.createElementNS(NS_KPT, 'Utilization');
        utilNode.setAttribute('ByDoc', getNodeValue(oldParcel, 'params permitted_use by_document'));
        newParcel.appendChild(utilNode);
        
        // Cadastral Cost
        const cost = getNodeValue(oldParcel, 'cost value');
        if (cost) newParcel.appendChild(createCadastralCostNode(newDoc, cost));

        // Entity Spatial (Coordinates)
        const oldSpatial = oldParcel.querySelector('contours_location, entity_spatial');
        if (oldSpatial) newParcel.appendChild(createEntitySpatialNode(oldSpatial, newDoc, coordSystems, csCounter));
        
        // Parent Cadastral Numbers
        const parentNumbersNode = newDoc.createElementNS(NS_KPT, 'ParentCadastralNumbers');
        const oldLinks = oldParcel.querySelectorAll('cad_links common_land cad_number');
        oldLinks.forEach(link => {
            parentNumbersNode.appendChild(createElementWithText(newDoc, NS_KPT, 'CadastralNumber', link.textContent));
        });
        if(parentNumbersNode.hasChildNodes()) newParcel.appendChild(parentNumbersNode);

        parcelsNode.appendChild(newParcel);
    });
    return parcelsNode.childNodes.length > 0 ? parcelsNode : newDoc.createDocumentFragment();
}

function convertObjectsRealty(oldBlock, newDoc, coordSystems, csCounter) {
    const objectsNode = newDoc.createElementNS(NS_KPT, 'ObjectsRealty');
    
    // Buildings
    oldBlock.querySelectorAll('build_record').forEach(oldBuild => {
        const objectRealty = newDoc.createElementNS(NS_KPT, 'ObjectRealty');
        const building = newDoc.createElementNS(NS_KPT, 'Building');
        building.setAttribute('CadastralNumber', getNodeValue(oldBuild, 'object common_data cad_number'));

        building.appendChild(createElementWithText(newDoc, NS_KPT, 'ObjectType', getNodeValue(oldBuild, 'object common_data type code')));
        building.appendChild(createElementWithText(newDoc, NS_KPT, 'AssignationBuilding', getNodeValue(oldBuild, 'params purpose code')));
        building.appendChild(createElementWithText(newDoc, NS_KPT, 'Area', getNodeValue(oldBuild, 'params area')));
        
        building.appendChild(createAddressNode(oldBuild.querySelector('address_location'), newDoc));
        const cost = getNodeValue(oldBuild, 'cost value');
        if(cost) building.appendChild(createCadastralCostNode(newDoc, cost));
        
        const oldSpatial = oldBuild.querySelector('contours, entity_spatial');
        if (oldSpatial) building.appendChild(createEntitySpatialNode(oldSpatial, newDoc, coordSystems, csCounter));

        objectRealty.appendChild(building);
        objectsNode.appendChild(objectRealty);
    });
    
    // Constructions
    oldBlock.querySelectorAll('construction_record').forEach(oldConstr => {
        const objectRealty = newDoc.createElementNS(NS_KPT, 'ObjectRealty');
        const constr = newDoc.createElementNS(NS_KPT, 'Construction');
        constr.setAttribute('CadastralNumber', getNodeValue(oldConstr, 'object common_data cad_number'));

        constr.appendChild(createElementWithText(newDoc, NS_KPT, 'ObjectType', getNodeValue(oldConstr, 'object common_data type code')));
        constr.appendChild(createElementWithText(newDoc, NS_KPT, 'AssignationName', getNodeValue(oldConstr, 'params purpose')));
        
        const extension = getNodeValue(oldConstr, 'base_parameters extension');
        if (extension) {
            const keyParams = newDoc.createElementNS(NS_KPT, 'KeyParameters');
            const keyParam = newDoc.createElementNS(NS_OKS, 'ns4:KeyParameter');
            keyParam.setAttribute('Type', '01'); // Assuming 'extension' maps to Type '01'
            keyParam.setAttribute('Value', extension);
            keyParams.appendChild(keyParam);
            constr.appendChild(keyParams);
        }
        
        constr.appendChild(createAddressNode(oldConstr.querySelector('address_location'), newDoc));
        const cost = getNodeValue(oldConstr, 'cost value');
        if(cost) constr.appendChild(createCadastralCostNode(newDoc, cost));
        
        const oldSpatial = oldConstr.querySelector('contours, entity_spatial');
        if (oldSpatial) constr.appendChild(createEntitySpatialNode(oldSpatial, newDoc, coordSystems, csCounter));
        
        objectRealty.appendChild(constr);
        objectsNode.appendChild(objectRealty);
    });

    return objectsNode.childNodes.length > 0 ? objectsNode : newDoc.createDocumentFragment();
}

function convertSpatialData(oldBlock, newDoc, coordSystems, csCounter) {
    const spatialNode = newDoc.createElementNS(NS_KPT, 'SpatialData');
    const oldSpatial = oldBlock.querySelector(':scope > spatial_data > entity_spatial');
    if (oldSpatial) {
        spatialNode.appendChild(createEntitySpatialNode(oldSpatial, newDoc, coordSystems, csCounter));
        return spatialNode;
    }
    return newDoc.createDocumentFragment();
}

function convertBounds(oldBlock, newDoc, coordSystems, csCounter) {
    const boundsNode = newDoc.createElementNS(NS_KPT, 'Bounds');
    
    oldBlock.querySelectorAll('municipal_boundary_record, inhabited_locality_boundary_record').forEach(oldBoundRec => {
        const boundNode = newDoc.createElementNS(NS_KPT, 'Bound');
        const bObject = oldBoundRec.querySelector('b_object');
        
        boundNode.appendChild(createElementWithText(newDoc, NS_KPT, 'Description', getNodeValue(bObject, 'type_boundary value')));
        boundNode.appendChild(createElementWithText(newDoc, NS_KPT, 'AccountNumber', getNodeValue(bObject, 'reg_numb_border')));
        
        const boundaries = newDoc.createElementNS(NS_KPT, 'Boundaries');
        const oldSpatial = oldBoundRec.querySelector('b_contours_location');
        if (oldSpatial) {
            const boundary = newDoc.createElementNS(NS_KPT, 'Boundary');
            boundary.appendChild(createEntitySpatialNode(oldSpatial, newDoc, coordSystems, csCounter));
            boundaries.appendChild(boundary);
        }
        boundNode.appendChild(boundaries);
        boundsNode.appendChild(boundNode);
    });
    
    return boundsNode.childNodes.length > 0 ? boundsNode : newDoc.createDocumentFragment();
}

function convertZones(oldBlock, newDoc, coordSystems, csCounter) {
    const zonesNode = newDoc.createElementNS(NS_KPT, 'Zones');
    
    oldBlock.querySelectorAll('zones_and_territories_record').forEach(oldZoneRec => {
        const zoneNode = newDoc.createElementNS(NS_KPT, 'Zone');
        const bObject = oldZoneRec.querySelector('b_object_zones_and_territories');
        
        zoneNode.appendChild(createElementWithText(newDoc, NS_KPT, 'Description', getNodeValue(bObject, 'type_boundary value')));
        zoneNode.appendChild(createElementWithText(newDoc, NS_KPT, 'AccountNumber', getNodeValue(bObject, 'b_object reg_numb_border')));
        
        const oldSpatial = oldZoneRec.querySelector('b_contours_location');
        if(oldSpatial) zoneNode.appendChild(createEntitySpatialNode(oldSpatial, newDoc, coordSystems, csCounter));
        
        const specialZone = newDoc.createElementNS(NS_KPT, 'SpecialZone');
        const content = `${getNodeValue(bObject, 'type_zone code')} ${getNodeValue(bObject, 'type_zone value')}`;
        specialZone.appendChild(createElementWithText(newDoc, NS_KPT, 'ContentRestrictions', content.trim()));
        zoneNode.appendChild(specialZone);
        
        zonesNode.appendChild(zoneNode);
    });
    
    return zonesNode.childNodes.length > 0 ? zonesNode : newDoc.createDocumentFragment();
}


// --- Helper functions for creating common nodes ---

function createAddressNode(oldAddress, newDoc) {
    const addressNode = newDoc.createElementNS(NS_KPT, 'Address');
    if (!oldAddress) return addressNode;
    
    const addr = oldAddress.querySelector('address, location');
    if (!addr) return addressNode;

    const createAdrEl = (name, val) => {
        if (!val) return null;
        return createElementWithText(newDoc, NS_ADR, `adrOut4:${name}`, val);
    }
    const createAdrElWithAttr = (name, attrs) => {
        const hasValues = Object.values(attrs).some(v => v);
        if (!hasValues) return null;
        const el = newDoc.createElementNS(NS_ADR, `adrOut4:${name}`);
        Object.entries(attrs).forEach(([key, value]) => value && el.setAttribute(key, value));
        return el;
    };
    
    const elements = [
        createAdrEl('OKATO', getNodeValue(addr, 'okato')),
        createAdrEl('KLADR', getNodeValue(addr, 'kladr')),
        createAdrEl('OKTMO', getNodeValue(addr, 'oktmo')),
        createAdrEl('PostalCode', getNodeValue(addr, 'postal_code')),
        createAdrEl('Region', getNodeValue(addr, 'region code')),
        createAdrElWithAttr('District', { Type: getNodeValue(addr, 'district type_district'), Name: getNodeValue(addr, 'district name_district')}),
        createAdrElWithAttr('City', { Type: getNodeValue(addr, 'city type_city'), Name: getNodeValue(addr, 'city name_city')}),
        createAdrElWithAttr('Locality', { Type: getNodeValue(addr, 'locality type_locality'), Name: getNodeValue(addr, 'locality name_locality')}),
        createAdrElWithAttr('Street', { Type: getNodeValue(addr, 'street type_street'), Name: getNodeValue(addr, 'street name_street')}),
        createAdrElWithAttr('Level1', { Type: getNodeValue(addr, 'level1 type_level1'), Value: getNodeValue(addr, 'level1 name_level1')}),
        createAdrElWithAttr('Level2', { Type: getNodeValue(addr, 'level2 type_level2'), Value: getNodeValue(addr, 'level2 name_level2')}),
        createAdrElWithAttr('Level3', { Type: getNodeValue(addr, 'level3 type_level3'), Value: getNodeValue(addr, 'level3 name_level3')}),
        createAdrEl('Note', getNodeValue(oldAddress, 'readable_address, position_description'))
    ];
    
    elements.forEach(el => el && addressNode.appendChild(el));
    return addressNode;
}

function createEntitySpatialNode(oldSpatial, newDoc, coordSystems, csCounter) {
    const entSpatial = newDoc.createElementNS(NS_KPT, 'EntitySpatial');
    if (!oldSpatial) return entSpatial;

    let csId = getNodeValue(oldSpatial, 'entity_spatial sk_id');
    if (!csId) csId = 'UNKNOWN';

    let sysId;
    if (coordSystems.has(csId)) {
        sysId = coordSystems.get(csId);
    } else {
        sysId = `ID${csCounter.value++}`;
        coordSystems.set(csId, sysId);
    }
    entSpatial.setAttribute('EntSys', sysId);
    
    const spatialElement = newDoc.createElementNS(NS_SPATIAL, 'ns3:SpatialElement');
    
    oldSpatial.querySelectorAll('spatial_element, contour').forEach(oldElement => {
        let pointCounter = 1;
        oldElement.querySelectorAll('ordinates ordinate').forEach(ord => {
            const spelementUnit = newDoc.createElementNS(NS_SPATIAL, 'ns3:SpelementUnit');
            spelementUnit.setAttribute('TypeUnit', '–¢–æ—á–∫–∞');
            spelementUnit.setAttribute('SuNmb', getNodeValue(ord, 'number_pp, ord_nmb') || pointCounter++);
            
            const ordinate = newDoc.createElementNS(NS_SPATIAL, 'ns3:Ordinate');
            ordinate.setAttribute('X', getNodeValue(ord, 'x'));
            ordinate.setAttribute('Y', getNodeValue(ord, 'y'));
            
            const ordNmb = getNodeValue(ord, 'ord_nmb');
            if(ordNmb) ordinate.setAttribute('OrdNmb', ordNmb);
            
            const numGeopoint = getNodeValue(ord, 'num_geopoint');
            if (numGeopoint) ordinate.setAttribute('NumGeopoint', numGeopoint);
            
            const delta = getNodeValue(ord, 'delta_geopoint');
            if(delta) ordinate.setAttribute('DeltaGeopoint', delta);
            
            const zacrep = getNodeValue(ord, 'geopoint_zacrep');
            if(zacrep && zacrep !== "–ó–∞–∫—Ä–µ–ø–ª–µ–Ω–∏–µ –æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç" && zacrep !== "-") ordinate.setAttribute('GeopointZacrep', zacrep);
            
            spelementUnit.appendChild(ordinate);
            spatialElement.appendChild(spelementUnit);
        });
    });
    
    entSpatial.appendChild(spatialElement);
    return entSpatial;
}

function createCoordSystemsNode(newDoc, coordSystems) {
    const csNode = newDoc.createElementNS(NS_KPT, 'CoordSystems');
    for (const [name, id] of coordSystems.entries()) {
        const system = newDoc.createElementNS(NS_SPATIAL, 'ns3:CoordSystem');
        system.setAttribute('Name', name);
        system.setAttribute('CsId', id);
        csNode.appendChild(system);
    }
    return csNode;
}

function createCadastralCostNode(newDoc, value) {
    const costNode = newDoc.createElementNS(NS_KPT, 'CadastralCost');
    costNode.setAttribute('Value', value);
    costNode.setAttribute('Unit', '383'); // Russian Ruble code
    return costNode;
}

function createElementWithText(doc, ns, name, text) {
    const el = doc.createElementNS(ns, name);
    if(text) el.textContent = text;
    return el;
}

</script>
</body>
</html>