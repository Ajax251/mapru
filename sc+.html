<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Подготовка чертежей</title>
   
    <link href="webfonts/all.min.css" rel="stylesheet">

    <script src="webfonts/jszip.min.js"></script>
    <script src="sk.js"></script>
    <script src="msk.js"></script>
    <!-- ДОБАВЛЕНЫ СКРИПТЫ ДЛЯ КАРТЫ -->
    <script src="https://api-maps.yandex.ru/2.1/?apikey=dde71a0e-b612-44b7-b53b-82533420240f&lang=ru_RU" type="text/javascript"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/proj4js/2.7.5/proj4.js"></script>

    <style>
        :root {
            --bg-main: #f0f2f5;
            --text-main: #2c3e50;
            --text-label: #34495e;
            --border-strong: #4facfe;
            --shadow-glow: rgba(79, 172, 254, 0.2);
            --shadow-deep: rgba(0,0,0,0.1);
            --panel-bg: rgba(255, 255, 255, 0.75);
            --panel-border: rgba(255, 255, 255, 0.4);
            --input-bg: rgba(255, 255, 255, 0.8);
            --input-border: rgba(52, 73, 94, 0.15);
            --input-shadow: rgba(0,0,0,0.05);
            
            --accent-color: #2196F3;
            --accent-dark: #1976D2;
            --text-secondary: #6c757d;
            --border-color: #e0e0e0;
            --right-sidebar-width: 80px;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }

        html, body { height: 100%; overflow: hidden; font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; color: var(--text-main); background-color: var(--bg-main); }

        .container { width: 100vw; height: 100vh; padding: 25px; display: flex; flex-direction: column; position: relative; }

        .main-layout { display: grid; grid-template-columns: 450px 1fr var(--right-sidebar-width); gap: 25px; flex: 1; min-height: 0; z-index: 1; }

        .column { background: var(--panel-bg); border-radius: 20px; box-shadow: 0 10px 30px var(--shadow-deep); border: 1px solid var(--panel-border); backdrop-filter: blur(15px); position: relative; overflow: hidden; display: flex; flex-direction: column; min-height: 0; }
        .column-controls { padding: 25px; gap: 20px; text-align: center; }
        .column-canvas { padding: 0; }

        .control-group { display: flex; flex-direction: column; }
        .control-group.flex-grow { flex: 1; display: flex; flex-direction: column; min-height: 0; }
        
        label { display: block; margin-bottom: 12px; font-weight: 600; color: var(--text-label); font-size: 0.95rem; text-align: center; }

        .textarea-wrapper { position: relative; flex: 1; display: flex; flex-direction: column; min-height: 200px; }
        textarea { width: 100%; padding: 16px; border: 1px solid var(--input-border); border-radius: 15px; font-size: 0.9rem; transition: all 0.3s ease; background: #fff; box-shadow: 0 4px 15px var(--input-shadow); flex: 1; resize: none; text-align: center; font-family: monospace; }
        textarea:focus { outline: none; border-color: var(--border-strong); box-shadow: 0 0 0 4px var(--shadow-glow); }

        .textarea-controls { position: absolute; top: 12px; right: 12px; z-index: 10; display: flex; flex-direction: column; gap: 8px; }
        .textarea-control-btn { width: 32px; height: 32px; border: none; border-radius: 50%; display: flex; align-items: center; justify-content: center; cursor: pointer; color: white; transition: all 0.3s ease; box-shadow: 0 4px 15px rgba(0,0,0,0.2); font-size: 14px; }
        .textarea-control-btn:hover { box-shadow: 0 6px 25px rgba(0,0,0,0.3); transform: scale(1.1); }
        .textarea-control-btn i { transition: transform 0.3s ease; }
        .textarea-control-btn:hover i { transform: scale(1.2); }

        .button-container { display: flex; flex-direction: column; gap: 15px; margin-top: 20px; }
        .action-btn { padding: 15px; border: none; border-radius: 15px; cursor: pointer; font-size: 16px; color: white; transition: all 0.3s ease; box-shadow: 0 8px 20px rgba(0,0,0,0.15); display: flex; align-items: center; justify-content: center; background: linear-gradient(135deg, #6a82fb 0%, #fc5c7d 100%); }
        .action-btn:hover { transform: translateY(-3px); box-shadow: 0 12px 25px rgba(0,0,0,0.25); filter: brightness(1.1); }

        .canvas-wrapper { position: relative; width: 100%; height: 100%; border-radius: 20px; overflow: hidden; }
        
        #canvas, #annotationCanvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: block; }
        #canvas { background-color: #ffffff; z-index: 1; cursor: grab; touch-action: none; }
        #annotationCanvas { z-index: 2; pointer-events: none; }

        #eyeButton { position: absolute; top: 20px; right: 20px; width: 48px; height: 48px; background: var(--panel-bg); border: 1px solid var(--panel-border); backdrop-filter: blur(10px); border-radius: 50%; cursor: pointer; display: flex; align-items: center; justify-content: center; box-shadow: 0 4px 15px rgba(0,0,0,0.15); z-index: 10; transition: all 0.3s ease; }
        #eyeButton:hover { transform: scale(1.1); }
        #eyeButton::before { content: ''; width: 20px; height: 20px; background-image: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="%2334495e"><path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5C21.27 7.61 17 4.5 12 4.5zm0 12c-2.48 0-4.5-2.02-4.5-4.5S9.52 7.5 12 7.5s4.5 2.02 4.5 4.5-2.02 4.5-4.5 4.5zm0-7c-1.38 0-2.5 1.12-2.5 2.5s1.12 2.5 2.5 2.5 2.5-1.12 2.5-2.5-1.12-2.5-2.5-2.5z"/></svg>'); background-size: contain; opacity: 0.8; }
        
        .floating-btn { position: fixed; width: 60px; height: 60px; border-radius: 50%; border: none; color: white; display: flex; align-items: center; justify-content: center; box-shadow: 0 8px 25px rgba(0,0,0,0.2); cursor: pointer; z-index: 1000; transition: all 0.3s ease; }
        .floating-btn:hover { transform: translateY(-3px) scale(1.08); box-shadow: 0 12px 30px rgba(0,0,0,0.3); }
        .floating-btn i { font-size: 22px; }
        
        #importButton { bottom: 25px; right: calc(var(--right-sidebar-width) + 35px); background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); }
        #notification { position: fixed; bottom: 25px; left: 50%; transform: translateX(-50%); background: linear-gradient(135deg, #2af598 0%, #009efd 100%); color: white; padding: 12px 25px; border-radius: 15px; box-shadow: 0 8px 20px rgba(0,0,0,0.2); display: none; z-index: 10001; font-weight: 600; }

        .right-sidebar { background: var(--panel-bg); padding: 15px 5px; display: flex; flex-direction: column; align-items: center; gap: 12px; overflow-y: auto; }
        .sidebar-btn { width: 55px; height: 55px; border-radius: 16px; border: none; background: #e3f2fd; color: var(--accent-color); cursor: pointer; transition: all 0.3s ease; display: flex; align-items: center; justify-content: center; position: relative; box-shadow: 0 2px 8px rgba(0,0,0,0.05); flex-shrink: 0; }
        .sidebar-btn:disabled { cursor: not-allowed; opacity: 0.5; background-color: #e9ecef; color: #adb5bd; }
        .sidebar-btn:disabled i { color: #adb5bd; }
        .sidebar-btn.active { background-color: var(--accent-color); color: white; }
        .sidebar-btn.active i { color: white; }
        .sidebar-btn:hover:not(.active):not(:disabled) { transform: translateY(-3px) scale(1.05); }
        .sidebar-btn i { font-size: 1.6em; }
        .sidebar-separator { width: 80%; height: 1px; background-color: var(--border-color); margin: 8px 0; }
        .sidebar-control-group { display: flex; flex-direction: column; align-items: center; gap: 6px; width: 100%; }
        .sidebar-control-group label { font-size: 0.75em; color: var(--text-secondary); }
        .sidebar-control-group input, .sidebar-control-group select { width: 60px; padding: 5px; border: 1px solid var(--border-color); border-radius: 8px; text-align: center; font-size: 0.8em; background: #fff; }
        .sidebar-control-group input[type="color"] { width: 45px; height: 30px; padding: 2px; }
        
        .modal-backdrop { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.4); z-index: 2000; display: none; align-items: center; justify-content: center; }
        .modal-content { background: white; padding: 25px; border-radius: 16px; box-shadow: 0 10px 30px rgba(0,0,0,0.2); width: 90%; max-width: 450px; }
        .modal-content h3 { margin-bottom: 15px; }
        .modal-content input[type="text"] { width: 100%; padding: 12px; border-radius: 8px; border: 1px solid var(--border-color); font-size: 1em; margin-bottom: 20px; }
        .modal-buttons { display: flex; justify-content: flex-end; gap: 10px; }
        .modal-btn { padding: 10px 20px; border: none; border-radius: 8px; font-size: 1em; cursor: pointer; }
        #modalOkBtn { background: var(--accent-color); color: white; }
        #modalCancelBtn { background: #e9ecef; }
        .modal-options-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-bottom: 20px; }
        .modal-option-group { display: flex; flex-direction: column; gap: 8px; }
        .modal-checkbox-label { display: flex; align-items: center; cursor: pointer; gap: 8px; }
        .modal-radio-group { display: flex; flex-direction: column; gap: 10px; padding-left: 25px; }
        .context-menu { position: fixed; background: white; border-radius: 8px; padding: 5px; box-shadow: 0 5px 15px rgba(0,0,0,0.15); display: none; z-index: 1001; min-width: 180px; }
        .context-menu-item { padding: 8px 12px; cursor: pointer; transition: background-color 0.2s; display: flex; align-items: center; gap: 8px; border-radius: 4px; }
        .context-menu-item:hover { background: #f1f3f5; }
        .context-menu-item i { width: 16px; text-align: center; color: var(--text-secondary); }

        /* --- НОВЫЕ СТИЛИ ДЛЯ МОДАЛЬНОГО ОКНА С КАРТОЙ --- */
        .map-modal-backdrop { position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; background-color: rgba(0, 0, 0, 0.6); backdrop-filter: blur(5px); z-index: 5000; display: flex; align-items: center; justify-content: center; padding: 20px; }
        .map-modal-content { position: relative; width: 95%; height: 95%; background: #fff; border-radius: 20px; box-shadow: 0 10px 40px rgba(0,0,0,0.3); overflow: hidden; }
        #mapContainer { width: 100%; height: 100%; }
        .map-modal-close-btn { position: absolute; top: 15px; right: 15px; width: 40px; height: 40px; background: rgba(255, 255, 255, 0.8); border: none; border-radius: 50%; font-size: 24px; font-weight: bold; color: #333; cursor: pointer; z-index: 5010; display: flex; align-items: center; justify-content: center; transition: all 0.2s ease; }
        .map-modal-close-btn:hover { transform: scale(1.1); background: white; }

        /* Панель управления на карте */
        .map-controls-panel { position: absolute; top: 15px; left: 15px; background: rgba(255, 255, 255, 0.85); backdrop-filter: blur(8px); border-radius: 12px; box-shadow: 0 4px 15px rgba(0,0,0,0.2); padding: 10px; z-index: 5005; display: flex; flex-direction: column; gap: 8px; }
        .map-control-button { padding: 8px 12px; border: 1px solid #ccc; background-color: #fff; border-radius: 8px; cursor: pointer; font-size: 12px; display: flex; align-items: center; gap: 6px; transition: background-color 0.2s, box-shadow 0.2s; }
        .map-control-button:hover { background-color: #f0f0f0; box-shadow: 0 2px 5px rgba(0,0,0,0.1); }
        .map-control-button i { color: #555; }
        .map-control-fill-toggle { display: flex; align-items: center; gap: 8px; padding: 8px 12px; font-size: 12px; cursor: pointer; user-select: none; }
        
        @media (max-width: 1200px) { .main-layout { grid-template-columns: 350px 1fr var(--right-sidebar-width); } }
        @media (max-width: 1024px) { html, body { overflow: auto; } .container { height: auto; padding: 15px; } .main-layout { grid-template-columns: 1fr; gap: 20px; } .column-canvas { min-height: 50vh; } .right-sidebar { order: 3; flex-direction: row; width: 100%; height: auto; overflow-x: auto; padding: 5px; justify-content: center; } #importButton { bottom: 15px; right: 15px; } }
    </style>
</head>
<body>
    <div class="container">
        <div class="main-layout">
            <div class="column column-controls">
                <div class="control-group flex-grow">
                    <label for="coordsInput">Исходные данные</label>
                    <div class="textarea-wrapper">
                        <textarea id="coordsInput" placeholder="Вставьте координаты..."></textarea>
                        <div class="textarea-controls">
                            <button class="textarea-control-btn" id="swapSourceBtn" title="Поменять X и Y"><i class="fas fa-exchange-alt"></i></button>
                            <button class="textarea-control-btn" id="copySourceBtn" title="Копировать"><i class="fas fa-copy"></i></button>
                            <button class="textarea-control-btn" id="vSwapSourceBtn" title="Обратный порядок"><i class="fas fa-sort-amount-down-alt"></i></button>
                            <button class="textarea-control-btn" id="pasteFromClipboardBtn" title="Вставить"><i class="fas fa-paste"></i></button>
                        </div>
                    </div>
                </div>
                <div class="control-group">
                    <div class="button-container">
                        <button class="action-btn" id="drawInitialBtn">Исходный</button>
                        <button class="action-btn" id="drawLandPlotsBtn">Чертеж земельных участков</button>
                       <button class="action-btn" id="drawGeodeticConstructionsBtn" onclick="activateGeodeticMode()">Схема геодезических построений</button>
                        <button class="action-btn" id="drawLayoutSchemeBtn">Схема расположения</button>
                    </div>
                </div>
            </div>

            <div class="column column-canvas">
                <div class="canvas-wrapper" id="canvasWrapper">
                    <canvas id="canvas"></canvas>
                    <canvas id="annotationCanvas"></canvas>
                    <div id="eyeButton" title="Режим отображения"></div>
                </div>
            </div>
            
            <div class="right-sidebar column">
                <button id="toggleAnnotationModeBtn" class="sidebar-btn" title="Режим редактирования"><i class="fas fa-paint-brush"></i></button>
                <div class="sidebar-separator"></div>
                <button class="sidebar-btn" onclick="undoLastAction()" id="undoBtn" title="Отменить (Ctrl+Z)"><i class="fas fa-undo"></i></button>
                <button class="sidebar-btn" onclick="redoLastAction()" id="redoBtn" title="Повторить (Ctrl+Y)"><i class="fas fa-redo"></i></button>
                <div class="sidebar-separator"></div>
                <button id="arrowModeBtn" class="sidebar-btn" onclick="setActiveMode('arrow')" title="Стрелка (A)"><i class="fas fa-long-arrow-alt-up"></i></button>
                <button id="lineModeBtn" class="sidebar-btn" onclick="setActiveMode('line')" title="Линия (L)"><i class="fas fa-pencil-alt"></i></button>
                <button id="textModeBtn" class="sidebar-btn" onclick="setActiveMode('text')" title="Текст (T)"><i class="fas fa-font"></i></button>
                <div class="sidebar-separator"></div>
                <div class="sidebar-control-group">
                    <label for="annotationColorPicker">Цвет</label>
                    <input type="color" id="annotationColorPicker" value="#FF0000" title="Цвет аннотации">
                </div>
                <div class="sidebar-control-group">
                    <label for="fontFamilySelect">Шрифт</label>
                    <select id="fontFamilySelect">
                        <option value="Arial">Arial</option>
                        <option value="Verdana">Verdana</option>
                        <option value="Times New Roman" selected>Times</option>
                    </select>
                    <label for="fontSizeInput">Размер</label>
                    <input type="number" id="fontSizeInput" value="30" min="8" max="300">
                    <label for="arrowThicknessInput">Толщина</label>
                    <input type="number" id="arrowThicknessInput" value="2" min="1" max="50">
                    <label for="textRotationInput">Поворот</label>
                    <input type="number" id="textRotationInput" value="0" min="0" max="360">
                </div>
                <div class="sidebar-separator"></div>
                <button class="sidebar-btn" onclick="saveAsPNG()" title="Сохранить как PNG"><i class="fas fa-save"></i></button>
                <button class="sidebar-btn" onclick="saveAsJPG()" title="Сохранить как JPG"><i class="fas fa-file-image"></i></button>
                <div class="sidebar-separator"></div>
                <button class="sidebar-btn" onclick="exportAnnotationsAsJSON()" id="exportAnnotationsBtn" title="Экспорт аннотаций"><i class="fas fa-file-export"></i></button>
                <button class="sidebar-btn" onclick="importAnnotationsFromJSON()" id="importAnnotationsBtn" title="Импорт аннотаций"><i class="fas fa-file-import"></i></button>
            </div>
        </div>
    </div>
    
    <button class="floating-btn" id="importButton" title="Импорт из файла">
        <i class="fas fa-file-import"></i>
    </button>
    <input type="file" id="jsonInput" accept="application/json" style="display: none;">
    <div id="notification"></div>
 
    <div class="modal-backdrop" id="textModal">
        <div class="modal-content">
            <h3>Ввод текста</h3>
            <input type="text" id="textInput" placeholder="Введите текст...">
            <div class="modal-options-grid">
                <div class="modal-option-group">
                    <label class="modal-checkbox-label"><input type="checkbox" id="textStrokeCheckbox"> <span>Обводка</span></label>
                    <div id="strokeOptionsContainer" class="modal-radio-group" style="display: none;">
                        <label><input type="radio" name="strokeColor" value="#000000" checked> Черная</label>
                        <label><input type="radio" name="strokeColor" value="#FFFFFF"> Белая</label>
                    </div>
                </div>
                <div class="modal-option-group">
                     <label class="modal-checkbox-label"><input type="checkbox" id="textShadowCheckbox"> <span>Тень</span></label>
                    <div id="shadowOptionsContainer" class="modal-radio-group" style="display: none;">
                        <label><input type="radio" name="shadowColor" value="rgba(0,0,0,0.5)" checked> Черная</label>
                        <label><input type="radio" name="shadowColor" value="rgba(255,255,255,0.7)"> Белая</label>
                    </div>
                </div>
            </div>
            <div class="modal-buttons">
                <button class="modal-btn" id="modalCancelBtn">Отмена</button>
                <button class="modal-btn" id="modalOkBtn">OK</button>
            </div>
        </div>
    </div>
    
    <div class="context-menu" id="textContextMenu">
        <div class="context-menu-item" onclick="editText()"><i class="fas fa-pencil-alt"></i>Редактировать</div>
        <div class="context-menu-item" onclick="deleteSelectedText()"><i class="fas fa-trash-alt"></i>Удалить</div>
    </div>
    
    <div class="map-modal-backdrop" id="mapModal" style="display: none;">
        <div class="map-modal-content">
            <div id="mapContainer"></div>
            <button class="map-modal-close-btn" id="mapModalCloseBtn">&times;</button>
        </div>
    </div>

<script>
// --- ГЛОБАЛЬНЫЕ ПЕРЕМЕННЫЕ ---
let zoomLevel = 1, panX = 0, panY = 0, isDragging = false, lastX = 0, lastY = 0;
let savedContours = [], currentDrawingMode = 'initial';
let eyeState = 0, showLabels = true, showPoints = true;
let isAnnotationModeActive = false;
let activeMode = null, arrows = [], lines = [], texts = [];
let isDrawingArrow = false, currentArrowStart = {};
let isDrawingLine = false, currentLineStart = {};
let historyStack = [], redoStack = [];
let selectedTextId = null, textModalCallback = null;
let isDraggingText = false, isRotatingText = false, textDragOffset = {};

let coordsInput, swapSourceBtn, copySourceBtn, vSwapSourceBtn, pasteBtn, importButton,
    drawInitialBtn, drawLandPlotsBtn, drawLayoutSchemeBtn, canvasWrapper, canvas, annotationCanvas,
    ctx, annotationCtx, eyeButton, notification, textModal, textInput, undoBtn, redoBtn,
    jsonInput, exportAnnotationsBtn, importAnnotationsBtn, textContextMenu;
    
let geodeticConstructionState = 'inactive';
let geodeticConstructionPoints = [];
let geodeticConstructions = [];

// --- НОВЫЕ ГЛОБАЛЬНЫЕ ПЕРЕМЕННЫЕ ДЛЯ КАРТЫ ---
let yandexMap = null;
const mapOffsetX = -1;
const mapOffsetY = -4.5;
let globalAbortController = null; // Для отмены запросов
const sevenDigitsRegions = ['06', '07', '09', '10', '11', '12', '13', '14', '17', '23', '24', '27', '31', '32', '35', '36', '41', '42', '47', '48', '50', '52', '53', '56', '57', '58', '59', '60', '61', '62', '63', '64', '65', '66', '67', '69', '70', '71', '72', '74', '77', '78', '79'];


// --- ИНИЦИАЛИЗАЦИЯ ---
document.addEventListener('DOMContentLoaded', () => {
    coordsInput = document.getElementById('coordsInput');
    swapSourceBtn = document.getElementById('swapSourceBtn');
    copySourceBtn = document.getElementById('copySourceBtn');
    vSwapSourceBtn = document.getElementById('vSwapSourceBtn');
    pasteBtn = document.getElementById('pasteFromClipboardBtn');
    importButton = document.getElementById('importButton');
    drawInitialBtn = document.getElementById('drawInitialBtn');
    drawLandPlotsBtn = document.getElementById('drawLandPlotsBtn');
    drawLayoutSchemeBtn = document.getElementById('drawLayoutSchemeBtn');
    canvasWrapper = document.getElementById('canvasWrapper');
    canvas = document.getElementById('canvas');
    annotationCanvas = document.getElementById('annotationCanvas');
    ctx = canvas.getContext('2d');
    annotationCtx = annotationCanvas.getContext('2d');
    eyeButton = document.getElementById('eyeButton');
    notification = document.getElementById('notification');
    textModal = document.getElementById('textModal');
    textInput = document.getElementById('textInput');
    undoBtn = document.getElementById('undoBtn');
    redoBtn = document.getElementById('redoBtn');
    jsonInput = document.getElementById('jsonInput');
    exportAnnotationsBtn = document.getElementById('exportAnnotationsBtn');
    importAnnotationsBtn = document.getElementById('importAnnotationsBtn');
    textContextMenu = document.getElementById('textContextMenu');

    setupEventListeners();
    setRandomTextareaControlColors();
    checkClipboardOnLoad();
    handleInput();
    saveStateToHistory();
    updateAnnotationToolsState();
});

function setupEventListeners() {
    swapSourceBtn.addEventListener('click', () => swapTextareaColumns(coordsInput));
    copySourceBtn.addEventListener('click', () => copyTextarea(coordsInput));
    vSwapSourceBtn.addEventListener('click', () => vSwapTextarea(coordsInput));
    pasteBtn.addEventListener('click', handlePasteBtnClick);
    coordsInput.addEventListener('input', () => handleInput(false));
    importButton.addEventListener('click', () => importFile(false));

    drawInitialBtn.addEventListener('click', () => { currentDrawingMode = 'initial'; redrawAll(); showNotification('Исходный чертеж'); });
    drawLandPlotsBtn.addEventListener('click', () => { if (!savedContours.length) { showNotification('Нет данных'); return; } currentDrawingMode = 'land_plot'; redrawAll(); showNotification('Чертеж земельных участков'); });
    
    drawLayoutSchemeBtn.addEventListener('click', showLayoutSchemeOnMap);
    document.getElementById('mapModalCloseBtn').addEventListener('click', closeMapModal);
    
    initializeZoom(canvasWrapper);
    initializeTouchZoom(canvasWrapper);
    initializeEyeButton();
    setupCanvasMouseEvents(canvasWrapper);
    
    document.getElementById('toggleAnnotationModeBtn').addEventListener('click', toggleAnnotationMode);
    document.querySelectorAll('.sidebar-control-group input, .sidebar-control-group select').forEach(control => {
        control.addEventListener('input', () => {
            if (selectedTextId) {
                const text = texts.find(t => t.id === selectedTextId);
                if (text) {
                    Object.assign(text, getCurrentTextStyles());
                    redrawAnnotations();
                }
            }
        });
    });

    document.getElementById('modalOkBtn').onclick = () => { if (textModalCallback) { textModalCallback({ text: textInput.value, strokeEnabled: document.getElementById('textStrokeCheckbox').checked, strokeColor: document.querySelector('input[name="strokeColor"]:checked').value, shadowEnabled: document.getElementById('textShadowCheckbox').checked, shadowColor: document.querySelector('input[name="shadowColor"]:checked').value }); } textModal.style.display = 'none'; };
    document.getElementById('modalCancelBtn').onclick = () => { textModal.style.display = 'none'; };
    jsonInput.addEventListener('change', handleJsonImport);
    document.addEventListener('click', () => textContextMenu.style.display = 'none');
}

// --- НОВЫЕ ФУНКЦИИ ДЛЯ РАБОТЫ С КАРТОЙ ---

function showLayoutSchemeOnMap() {
    const inputText = coordsInput.value.trim();
    if (inputText === '') {
        showNotification('Нет исходных данных для построения схемы');
        return;
    }

    const mapModal = document.getElementById('mapModal');
    mapModal.style.display = 'flex';
    
    showNotification('Загрузка карты...');

    const populateMapWithObjects = () => {
        try {
            yandexMap.geoObjects.removeAll();
            const mainContoursCollection = new ymaps.GeoObjectCollection(null, {
                // Коллекция для основных контуров, чтобы легко управлять заливкой
            });
            yandexMap.geoObjects.add(mainContoursCollection);


            const coordGroups = parseCoordinates(inputText);
            const { system, swap } = determineCoordinateSystem(coordGroups);
            if (system === 'unknown') throw new Error("Не удалось определить систему координат.");
            
            const geoCoordGroups = convertCoordinatesToGeo(coordGroups, system, swap);
            if (geoCoordGroups.length === 0) throw new Error("Ошибка конвертации координат.");

            geoCoordGroups.forEach(group => {
                if (group.length > 1) {
                    const offsetCoords = group.map(coord => [
                        coord[0] - mapOffsetY * 0.000008983,
                        coord[1] - mapOffsetX * 0.000008983
                    ]);
                    const isClosed = isContourClosed(offsetCoords.map(c => `${c[1]}\t${c[0]}`));
                    const object = isClosed
                        ? new ymaps.Polygon([offsetCoords], {}, { strokeColor: "#ff0000", strokeWidth: 2, fillColor: "#ff000033" })
                        : new ymaps.Polyline(offsetCoords, {}, { strokeColor: "#ff0000", strokeWidth: 2 });
                    mainContoursCollection.add(object);
                }
            });
            
            const annotations = [...arrows, ...lines, ...texts, ...geodeticConstructions];
            annotations.forEach(item => {
                const itemColor = (item.color && typeof item.color === 'string' && item.color.startsWith('#')) ? item.color : '#0000FF';
                if (item.start && item.end) {
                    const geoStart = convertMskPointToGeo(item.start, system, swap);
                    const geoEnd = convertMskPointToGeo(item.end, system, swap);
                    if (geoStart && geoEnd) {
                        yandexMap.geoObjects.add(new ymaps.Polyline([geoStart, geoEnd], {}, { strokeColor: itemColor, strokeWidth: item.thickness || 2 }));
                    }
                } else if (item.text) {
                    const geoPos = convertMskPointToGeo({x: item.x, y: item.y}, system, swap);
                    if (geoPos) {
                        yandexMap.geoObjects.add(new ymaps.Placemark(geoPos, { iconContent: item.text || '' }, { preset: 'islands#blackStretchyIcon', iconColor: itemColor }));
                    }
                } else if (item.p1 && item.center && item.p3) {
                    const geoP1 = convertMskPointToGeo(item.p1, system, swap);
                    const geoCenter = convertMskPointToGeo(item.center, system, swap);
                    const geoP3 = convertMskPointToGeo(item.p3, system, swap);
                    if(geoP1 && geoCenter && geoP3) {
                         yandexMap.geoObjects.add(new ymaps.Polyline([geoP1, geoCenter], {}, { strokeColor: itemColor, strokeStyle: 'dash' }));
                         yandexMap.geoObjects.add(new ymaps.Polyline([geoCenter, geoP3], {}, { strokeColor: itemColor, strokeStyle: 'dash' }));
                         yandexMap.geoObjects.add(new ymaps.Placemark(geoCenter, {}, {preset: 'islands#blueCircleIcon'}));
                    }
                }
            });

            if (yandexMap.geoObjects.getLength() > 0) {
                yandexMap.setBounds(yandexMap.geoObjects.getBounds(), {
                    checkZoomRange: true,
                    zoomMargin: 20
                });
            } else {
                 throw new Error("Не найдено объектов для отображения на карте.");
            }
            showNotification('Схема расположения построена');
            createMapControls(mainContoursCollection); // Создаем контролы после отрисовки

        } catch (error) {
            console.error("Ошибка при построении карты:", error);
            showNotification(error.message, 'error');
            closeMapModal();
        }
    };

    if (yandexMap) {
        populateMapWithObjects();
    } else {
        ymaps.ready(() => {
            yandexMap = new ymaps.Map('mapContainer', {
                center: [55.751574, 37.573856],
                zoom: 10,
                controls: ['zoomControl', 'fullscreenControl', 'typeSelector'],
                behaviors: ['drag', 'scrollZoom', 'multiTouch']
            });
            populateMapWithObjects();
        });
    }
}

function closeMapModal() {
    const mapModal = document.getElementById('mapModal');
    mapModal.style.display = 'none';
    const controls = document.getElementById('mapControlsPanel');
    if(controls) controls.remove();
}

function createMapControls(mainContoursCollection) {
    let panel = document.getElementById('mapControlsPanel');
    if (panel) panel.remove();

    panel = document.createElement('div');
    panel.id = 'mapControlsPanel';
    panel.className = 'map-controls-panel';
    panel.innerHTML = `
        <label class="map-control-fill-toggle">
            <input type="checkbox" id="fillToggleCheckbox" checked>
            Заливка
        </label>
        <button id="loadParcelsBtn" class="map-control-button"><i class="fas fa-layer-group"></i>ЗУ в квартале</button>
        <button id="loadOksBtn" class="map-control-button"><i class="fas fa-building"></i>Границы ОКС</button>
        <button id="loadQuarterBtn" class="map-control-button"><i class="fas fa-th-large"></i>Границы квартала</button>
        <button id="loadTerrZoneBtn" class="map-control-button"><i class="fas fa-globe-europe"></i>Тер. зоны</button>
    `;
    document.querySelector('.map-modal-content').appendChild(panel);

    document.getElementById('fillToggleCheckbox').addEventListener('change', (e) => {
        const fillColor = e.target.checked ? '#FF000033' : '#FF000000';
        mainContoursCollection.each(obj => {
            if (obj instanceof ymaps.Polygon) {
                obj.options.set('fillColor', fillColor);
            }
        });
    });
    
    document.getElementById('loadParcelsBtn').addEventListener('click', () => handleParcelsInQuarter(yandexMap.getCenter()));
    document.getElementById('loadOksBtn').addEventListener('click', () => loadLayerByCenter(36049, 'ОКС', '#9370DB'));
    document.getElementById('loadQuarterBtn').addEventListener('click', () => loadLayerByCenter(36048, 'Квартал', '#AAAAAA', true));
    document.getElementById('loadTerrZoneBtn').addEventListener('click', () => loadLayerByCenter(36315, 'Тер. зона', '#4682B4'));
}

async function handleParcelsInQuarter(centerCoords) {
    if (globalAbortController) globalAbortController.abort();
    globalAbortController = new AbortController();
    const { signal } = globalAbortController;
    try {
        showLoader("Определение квартала...");
        const wmsData = await queryNSPD_WMS(centerCoords, 36048, signal);
        if (signal.aborted) throw new DOMException('Aborted');
        if (!wmsData?.features?.length) { showNotification('Не удалось определить ЗУ в центре карты', 'warning'); return; }
        
        const quarterNumber = wmsData.features[0].properties.descr.split(':').slice(0, 3).join(':');
        
        showLoader(`Загрузка ЗУ в квартале ${quarterNumber}...`);
        const quarterFeature = await queryNSPD_Search(quarterNumber, 2, signal);
        if (signal.aborted) throw new DOMException('Aborted');
        if (!quarterFeature) { showNotification(`Квартал ${quarterNumber} не найден`, 'error'); return; }

        const requestBody = { "geom": { "type": "FeatureCollection", "features": [{"type": "Feature", "geometry": quarterFeature.geometry}] }, "categories": [{"id": 36368}] };
        const intersectsResponse = await fetch('/api/geoportal/v1/intersects?typeIntersect=fullObject', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(requestBody), signal });

        if (signal.aborted) throw new DOMException('Aborted');
        if (!intersectsResponse.ok) { showNotification(`Ошибка запроса участков для ${quarterNumber}`, 'error'); return; }
        const parcelsData = await intersectsResponse.json();
        if (signal.aborted) throw new DOMException('Aborted');

        if (!parcelsData.features || parcelsData.features.length === 0) {
            showNotification(`Участки в квартале ${quarterNumber} не найдены`, 'info');
            return;
        }
        
        parcelsData.features.forEach(f => drawNspdFeature(f, { 
            baseColorType: isZuDeclared(f.properties?.options) ? '#FF0000' : '#00FF00', 
            hintText: f.properties?.descr
        }));
        showNotification(`Загружено ${parcelsData.features.length} ЗУ`, 'success');

    } catch (error) {
        if (error.name !== 'AbortError') { showNotification('Ошибка при загрузке ЗУ в квартале', 'error'); }
    } finally {
        hideLoader();
    }
}

async function loadLayerByCenter(layerId, layerName, color, isOutline = false) {
    if (globalAbortController) globalAbortController.abort();
    globalAbortController = new AbortController();
    const { signal } = globalAbortController;
    try {
        showLoader(`Поиск "${layerName}"...`);
        const data = await queryNSPD_WMS(yandexMap.getCenter(), layerId, signal);
        if (signal.aborted) throw new DOMException('Aborted');
        if (!data?.features?.length) { showNotification(`"${layerName}" в центре карты не найден`, 'warning'); return; }
        
        const feature = data.features[0];
        const featureName = feature.properties?.options?.name_by_doc || feature.properties?.descr || layerName;
        
        const options = {
            baseColorType: color,
            hintText: featureName,
            fillColorOpacity: isOutline ? 0 : 0.2
        };

        const drawnObject = drawNspdFeature(feature, options);
        
        if (layerId === 36315 && drawnObject) { // Если это тер. зона
            const textPlacemark = new ymaps.Placemark(yandexMap.getCenter(), {
                iconContent: featureName
            }, {
                preset: 'islands#blueStretchyIcon',
                draggable: true
            });
            yandexMap.geoObjects.add(textPlacemark);
        }

    } catch(e) {
        if (e.name !== 'AbortError') showNotification(`Ошибка при загрузке слоя "${layerName}"`, 'error');
    } finally {
        hideLoader();
    }
}

function drawNspdFeature(feature, options = {}) {
    let { baseColorType, fillColorOpacity = 0.2, hintText } = options;
    const geometry = feature.geometry;
    if (!geometry || !geometry.coordinates) return null;

    const yandexPolygonsGeometries = [];
    const contours = geometry.type === "Polygon" ? [geometry.coordinates] : geometry.coordinates;

    contours.forEach(polygonRings => {
        const rings = Array.isArray(polygonRings[0][0]) ? polygonRings : [polygonRings];
        rings.forEach(ring => {
            const wgsCoords = ring.map(coord => {
                const p = proj4('EPSG:3857', 'EPSG:4326', coord);
                return [p[1], p[0]]; // lat, lon
            });
            const offsetCoords = wgsCoords.map(c => [c[0] - mapOffsetY * 0.000008983, c[1] - mapOffsetX * 0.000008983]);
            yandexPolygonsGeometries.push(offsetCoords);
        });
    });

    if (yandexPolygonsGeometries.length > 0) {
        const fillColor = `${baseColorType}${Math.round(fillColorOpacity * 255).toString(16).padStart(2, '0')}`;
        const mapPolygon = new ymaps.Polygon(yandexPolygonsGeometries, 
            { hintContent: hintText }, 
            { strokeColor: baseColorType, strokeWidth: 2, fillColor: fillColor, strokeOpacity: 0.8 }
        );
        yandexMap.geoObjects.add(mapPolygon);
        return mapPolygon;
    }
    return null;
}

// Утилиты для запросов к API
async function queryNSPD_WMS(coords, layerId, signal) { /* ... скопировать из примера Карта Мини ... */ return new Promise(r => r({features:[]})); }
async function queryNSPD_Search(query, thematicSearchId, signal) { /* ... скопировать из примера Карта Мини ... */ return null; }
function isZuDeclared(opts) { return !opts?.specified_area && !opts?.land_record_area_verified && (opts?.declared_area || opts?.land_record_area_declaration || opts?.land_record_area); }

// Код для запросов к API (можно скопировать из вашего примера `Карта Мини`)
async function fetch(url, options = {}) {
    // Вставьте сюда вашу реализацию fetchWithFallback, если она нужна
    return window.fetch(url, options);
}
async function queryNSPD_WMS(coords, layerId, signal) {
    const centerPoint = toEPSG3857(coords[0], coords[1]);
    const bboxSize = 0.15;
    const bbox = `${centerPoint.x - bboxSize / 2},${centerPoint.y - bboxSize / 2},${centerPoint.x + bboxSize / 2},${centerPoint.y + bboxSize / 2}`;
    const path = `/api/aeggis/v3/${layerId}/wms?REQUEST=GetFeatureInfo&QUERY_LAYERS=${layerId}&SERVICE=WMS&VERSION=1.3.0&FORMAT=image%2Fpng&STYLES=&TRANSPARENT=true&LAYERS=${layerId}&INFO_FORMAT=application%2Fjson&FEATURE_COUNT=10&I=256&J=256&WIDTH=512&HEIGHT=512&CRS=EPSG%3A3857&BBOX=${bbox}`;
    const response = await fetch(`https://nspd.gov.ru${path}`, { signal });
    if (!response.ok) throw new Error(`HTTP error ${response.status}`);
    return await response.json();
}
async function queryNSPD_Search(query, thematicSearchId, signal) {
    const path = `/api/geoportal/v2/search/geoportal?thematicSearchId=${thematicSearchId}&query=${encodeURIComponent(query)}`;
    const response = await fetch(`https://nspd.gov.ru${path}`, { signal });
    if (!response.ok) throw new Error(`HTTP error ${response.status}`);
    const data = await response.json();
    return data?.data?.features?.[0] || null;
}
function toEPSG3857(latitude, longitude) { const R = 6378137; return { x: R * longitude * Math.PI / 180, y: R * Math.log(Math.tan(Math.PI / 4 + latitude * Math.PI / 360)) }; }


function convertMskPointToGeo(point, system, swap) {
    if(!point || typeof point.x === 'undefined' || typeof point.y === 'undefined') return null;
    const geoCoords = convertCoordinatesToGeo([[`${point.x}\t${point.y}`]], system, swap);
    if (geoCoords.length > 0 && geoCoords[0].length > 0) {
        const result = geoCoords[0][0];
        return [
            result[0] - mapOffsetY * 0.000008983,
            result[1] - mapOffsetX * 0.000008983
        ];
    }
    return null;
}

proj4.defs("EPSG:3857", "+proj=merc +a=6378137 +b=6378137 +lat_ts=0.0 +lon_0=0.0 +x_0=0.0 +y_0=0 +k=1.0 +units=m +nadgrids=@null +wktext +no_defs");
proj4.defs("EPSG:4326", "+proj=longlat +datum=WGS84 +no_defs");

function parseCoordinates(text) {
    if (!text || typeof text !== 'string') return [];
    const groups = text.split(/\n\s*\n/).map(g => g.trim()).filter(g => g !== '');
    return groups.map(group => {
        return group.split('\n').map(line => {
            const parts = line.trim().split(/[\s\t]+/);
            if (parts.length < 2) return null;
            const x = parseFloat(parts[0].replace(',', '.'));
            const y = parseFloat(parts[1].replace(',', '.'));
            if (!isFinite(x) || !isFinite(y)) return null;
            return [x, y];
        }).filter(c => c !== null);
    }).filter(g => g.length > 0);
}

function determineCoordinateSystem(coordGroups) {
    let system = 'unknown', swap = false;
    if (!coordGroups || coordGroups.length === 0 || coordGroups[0].length === 0) return { system, swap };
    const firstCoord = coordGroups[0][0];
    const x = firstCoord[0], y = firstCoord[1];
    
    if (String(Math.trunc(Math.abs(x))).length >= 7 && String(Math.trunc(Math.abs(y))).length >= 7) { 
        system = 'EPSG:3857'; swap = false; 
    }
    else if (Math.abs(x) <= 90 && Math.abs(y) <= 180) { system = 'EPSG:4326'; swap = false; } 
    else if (Math.abs(x) <= 180 && Math.abs(y) <= 90) { system = 'EPSG:4326'; swap = true; }
    else { 
        system = 'EPSG:6331602';
        swap = false;
    }
    return { system, swap };
}

function convertCoordinatesToGeo(coordGroups, coordSystem, needSwapXY) {
    if (typeof COORDINATE_SYSTEMS !== 'undefined') {
        COORDINATE_SYSTEMS.forEach(sys => {
            if (!proj4.defs[sys.value]) {
                proj4.defs(sys.value, sys.def);
            }
        });
    }
    const geoGroups = [];
    for (const group of coordGroups) {
        const geoGroup = group.map(coord => {
            try {
                let x = coord[0], y = coord[1];
                if (needSwapXY) [x, y] = [y, x];
                let wgs84Coords;
                if (coordSystem === 'EPSG:4326') {
                    wgs84Coords = [y, x]; 
                } else {
                    wgs84Coords = proj4(coordSystem, "EPSG:4326", [y, x]);
                }
                return [wgs84Coords[1], wgs84Coords[0]];
            } catch (e) {
                console.error('Ошибка конвертации:', e, coord, coordSystem);
                return null;
            }
        }).filter(c => c !== null);
        if (geoGroup.length > 0) geoGroups.push(geoGroup);
    }
    return geoGroups;
}

function toggleAnnotationMode() {
    isAnnotationModeActive = !isAnnotationModeActive;
    const btn = document.getElementById('toggleAnnotationModeBtn');
    if (isAnnotationModeActive) {
        btn.classList.add('active');
        if (activeMode) setActiveMode(null);
        showNotification('Режим редактирования');
        canvasWrapper.style.cursor = 'default';
        annotationCanvas.style.pointerEvents = 'auto';
    } else {
        btn.classList.remove('active');
        setActiveMode(null);
        showNotification('Режим навигации');
        canvasWrapper.style.cursor = 'grab';
        annotationCanvas.style.pointerEvents = 'none';
    }
    updateAnnotationToolsState();
}

function updateAnnotationToolsState() {
    const toolButtons = [undoBtn, redoBtn, ...document.querySelectorAll('#arrowModeBtn, #lineModeBtn, #textModeBtn'), ...document.querySelectorAll('.sidebar-control-group input, .sidebar-control-group select'), ...document.querySelectorAll('button[onclick^="saveAs"], button[onclick^="exportAnnotations"], button[onclick^="importAnnotations"]') ];
    toolButtons.forEach(btn => btn.disabled = !isAnnotationModeActive);
    if (savedContours.length === 0) {
        exportAnnotationsBtn.disabled = true;
        importAnnotationsBtn.disabled = true;
    }
}

function activateGeodeticMode() {
    if (!isAnnotationModeActive) {
        showNotification("Сначала включите режим редактирования (кнопка с кистью)");
        return;
    }
    setActiveMode('geodetic');
    geodeticConstructionState = 'waiting_first';
    geodeticConstructionPoints = [];
    canvasWrapper.style.cursor = 'crosshair';
    showNotification("Выберите начальную точку на чертеже");
}

function handleGeodeticClick(dataSpacePos) {
    const snapThreshold = 15;
    switch (geodeticConstructionState) {
        case 'waiting_first':
            const nearestFirst = findNearestPoint(dataSpacePos, snapThreshold);
            if (nearestFirst) {
                geodeticConstructionPoints.push(nearestFirst);
                geodeticConstructionState = 'waiting_center';
                showNotification("Выберите положение опорной точки (прицела)");
            } else {
                showNotification("Кликните ближе к одной из точек чертежа");
            }
            break;
        case 'waiting_center':
            geodeticConstructionPoints.push(dataSpacePos);
            geodeticConstructionState = 'waiting_third';
            showNotification("Выберите конечную точку на чертеже");
            break;
        case 'waiting_third':
            const nearestThird = findNearestPoint(dataSpacePos, snapThreshold);
            if (nearestThird) {
                geodeticConstructionPoints.push(nearestThird);
                geodeticConstructions.push({ p1: geodeticConstructionPoints[0], center: geodeticConstructionPoints[1], p3: geodeticConstructionPoints[2] });
                saveStateToHistory();
                geodeticConstructionState = 'inactive';
                geodeticConstructionPoints = [];
                setActiveMode(null);
                showNotification("Построение завершено");
            } else {
                showNotification("Кликните ближе к одной из точек чертежа");
            }
            break;
    }
    redrawAll();
}

function findNearestPoint(clickDataPos, threshold) {
    const { toDrawingSpace } = getCoordinateTransformers();
    const clickDrawingPos = toDrawingSpace(clickDataPos);
    let closestPoint = null;
    let minDistance = Infinity;
    savedContours.forEach(contour => {
        contour.forEach(coordStr => {
            const [x, y] = coordStr.split(/\s+|\t/).map(Number);
            const pointDataPos = { x, y };
            const pointDrawingPos = toDrawingSpace(pointDataPos);
            const distance = Math.hypot(clickDrawingPos.x - pointDrawingPos.x, clickDrawingPos.y - pointDrawingPos.y);
            if (distance < minDistance) {
                minDistance = distance;
                closestPoint = pointDataPos;
            }
        });
    });
    if (minDistance * zoomLevel < threshold) return closestPoint;
    return null;
}

function drawCrosshairSymbol(ctx, point, color) {
    const radius = 8 / zoomLevel;
    const tickLength = 5 / zoomLevel;
    ctx.strokeStyle = color;
    ctx.lineWidth = 1.5 / zoomLevel;
    ctx.beginPath();
    ctx.arc(point.x, point.y, radius, 0, 2 * Math.PI);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(point.x - radius - tickLength, point.y);
    ctx.lineTo(point.x + radius + tickLength, point.y);
    ctx.moveTo(point.x, point.y - radius - tickLength);
    ctx.lineTo(point.x, point.y + radius + tickLength);
    ctx.stroke();
}

function drawGeodeticConstruction(ctx, construction, color) {
    const { toDrawingSpace } = getCoordinateTransformers();
    const p1 = toDrawingSpace(construction.p1);
    const center = toDrawingSpace(construction.center);
    const p3 = toDrawingSpace(construction.p3);
    drawCrosshairSymbol(ctx, center, color);
    ctx.save();
    ctx.strokeStyle = color;
    ctx.lineWidth = 1.5 / zoomLevel;
    ctx.setLineDash([8 / zoomLevel, 8 / zoomLevel]);
    ctx.beginPath();
    ctx.moveTo(p1.x, p1.y);
    ctx.lineTo(center.x, center.y);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(center.x, center.y);
    ctx.lineTo(p3.x, p3.y);
    ctx.stroke();
    ctx.restore();
}

function redrawAll() { drawContour(savedContours); redrawAnnotations(); }
function handleInput(showNotifications = true) { /* ... */ }
function clearAll() { /* ... */ }
function drawContour(contours) { /* ... */ }
function redrawAnnotations(tempObject = null) { /* ... */ }
function drawArrow(ctx, start, end, color, thickness) { /* ... */ }
function drawLine(ctx, start, end, color, thickness) { /* ... */ }
function drawText(ctx, t) { /* ... */ }
function drawTextSelectionHandles(ctx, t) { /* ... */ }
function setupCanvasMouseEvents(wrapper) { /* ... */ }
function setActiveMode(mode) { /* ... */ }
function resetAnnotationsAndState() { /* ... */ }
function saveStateToHistory() { /* ... */ }
function applyState(state) { /* ... */ }
function undoLastAction() { /* ... */ }
function redoLastAction() { /* ... */ }
function updateUndoRedoButtons() { /* ... */ }
function getCurrentTextStyles() { /* ... */ }
function showTextModal(textObject, callback) { /* ... */ }
function editText() { /* ... */ }
function deleteSelectedText() { /* ... */ }
function updateControlsForSelectedText() { /* ... */ }
function getCoordinateTransformers() { /* ... */ }
function screenToDrawingSpace(e) { /* ... */ }
function screenToDataSpace(e) { /* ... */ }
function checkTextInteraction(mouseDrawingPos) { /* ... */ }
function initializeZoom(wrapper) { /* ... */ }
function initializeTouchZoom(w){}
function initializeEyeButton() { /* ... */ }
function swapTextareaColumns(t) { /* ... */ }
function vSwapTextarea(t) { /* ... */ }
function copyTextarea(t) { /* ... */ }
async function handlePasteBtnClick() { /* ... */ }
async function checkClipboardOnLoad() { /* ... */ }
function setRandomTextareaControlColors() { /* ... */ }
function isContourClosed(c) { if (!c || c.length < 3) return false; try { const [x1,y1]=c[0].split(/\s+|\t/).map(Number), [x2,y2]=c[c.length-1].split(/\s+|\t/).map(Number); return Math.abs(x1-x2)<0.01 && Math.abs(y1-y2)<0.01;} catch(e){return false;}}
function getRandomColor() { return '#' + Math.floor(Math.random()*16777215).toString(16).padStart(6, '0'); }
function showNotification(msg, type = 'success') { notification.textContent = msg; notification.style.background = type === 'error' ? 'linear-gradient(135deg, #ff6b6b, #d9534f)' : 'linear-gradient(135deg, #2af598, #009efd)'; notification.style.display = 'block'; setTimeout(() => notification.style.display = 'none', 2500); }
function importFile(isAppend = false) { /* ... */ }
function handleZipFile(file, isAppend) { /* ... */ }
function appendCoordinates(newCoordinates) { /* ... */ }
function extractCoordinatesEntitySpatial(t){return[]} function extractCoordinatesNewContour(t){return[]} function searchInTabs(t){return[]} function importGeo(t){return[]} function extractCoordinatesFromTextWithDescription(t){return[]} function extractCoordinatesFromSpelementUnit(t){return[]} function extractSingleNumberPerLine(t){return[]}
function extractCoordinatesFromXML(text) { /* ... */ }
function extractCoordinatesFromXMLType1(text) { /* ... */ }
function extractCoordinatesFromXMLType2(text) { /* ... */ }
function extractCoordinatesFromInteractEntryBoundaries(text) { /* ... */ }
function extractCoordinatesFromGeoJSON(c){/* ... */}
function extractCoordinatesFromDXF(c){/* ... */}
function processDXFContour(c,r,isC){/* ... */}
function extractCoordinatesFromMIF(c){/* ... */}
function extractCoordinatesFromText(c){/* ... */}
function saveAsPNG() { saveWithAnnotations('image/png'); }
function saveAsJPG() { saveWithAnnotations('image/jpeg', 0.92); }
function saveWithAnnotations(format, quality) { /* ... */ }
function exportAnnotationsAsJSON() { /* ... */ }
function importAnnotationsFromJSON() { /* ... */ }
function handleJsonImport(e) { /* ... */ }

// Я скопировал только измененные и новые функции,
// чтобы сохранить краткость. Остальные функции (без изменений)
// просто скопируйте из вашего предыдущего полного кода.
// Заполните функции-заглушки (...) кодом из предыдущего ответа.

</script>
</body>
</html>