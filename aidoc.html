<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI File Processor</title>
    <link rel="shortcut icon" href="https://vsemap.ru/img/worker.png" type="image/x-icon">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.11.338/pdf.min.js"></script>
    <script src="https://unpkg.com/docx@8.5.0/build/index.js"></script>
    
    <style>
        :root {
            --primary: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            --primary-solid: #667eea;
            --primary-hover: #5a67d8;
            --secondary: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            --success: #48bb78;
            --error: #f56565;
            --warning: #ed8936;
            --gray-50: #f7fafc;
            --gray-100: #edf2f7;
            --gray-200: #e2e8f0;
            --gray-300: #cbd5e1;
            --gray-400: #a0aec0;
            --gray-500: #718096;
            --gray-600: #4a5568;
            --gray-700: #2d3748;
            --gray-800: #1a202c;
            --gray-900: #171923;
            --shadow-sm: 0 1px 3px 0 rgba(0, 0, 0, 0.1), 0 1px 2px 0 rgba(0, 0, 0, 0.06);
            --shadow-md: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -2px rgba(0, 0, 0, 0.06);
            --shadow-lg: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            --shadow-xl: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 2rem 1rem;
            color: var(--gray-800);
            position: relative;
        }

        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1000 1000"><defs><radialGradient id="a" cx="50%" cy="50%"><stop offset="0%" stop-color="%23ffffff" stop-opacity="0.1"/><stop offset="100%" stop-color="%23ffffff" stop-opacity="0"/></radialGradient></defs><circle cx="200" cy="200" r="150" fill="url(%23a)"/><circle cx="800" cy="300" r="100" fill="url(%23a)"/><circle cx="300" cy="700" r="120" fill="url(%23a)"/><circle cx="700" cy="800" r="80" fill="url(%23a)"/></svg>') no-repeat center center;
            background-size: cover;
            pointer-events: none;
            z-index: -1;
        }

        .container {
            max-width: 1000px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(20px);
            border-radius: 24px;
            box-shadow: var(--shadow-xl);
            overflow: hidden;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .header {
            background: var(--primary);
            color: white;
            padding: 2rem;
            text-align: center;
            position: relative;
        }

        .header::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 1px;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.3), transparent);
        }

        .header h1 {
            font-size: 2.5rem;
            font-weight: 700;
            margin-bottom: 0.5rem;
            text-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .header p {
            font-size: 1.1rem;
            opacity: 0.9;
            font-weight: 400;
        }

        .main-content {
            padding: 3rem;
        }

        .form-section {
            margin-bottom: 2.5rem;
            opacity: 0;
            transform: translateY(20px);
            animation: slideUp 0.6s ease forwards;
        }

        .form-section:nth-child(2) { animation-delay: 0.1s; }
        .form-section:nth-child(3) { animation-delay: 0.2s; }
        .form-section:nth-child(4) { animation-delay: 0.3s; }

        @keyframes slideUp {
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .section-title {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            font-size: 1.2rem;
            font-weight: 600;
            color: var(--gray-700);
            margin-bottom: 1rem;
        }

        .section-title i {
            width: 24px;
            height: 24px;
            background: var(--primary);
            color: white;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.9rem;
        }

        .step-number {
            background: var(--primary);
            color: white;
            width: 28px;
            height: 28px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 600;
            font-size: 0.9rem;
        }

        #drop-zone {
            border: 3px dashed var(--gray-300);
            border-radius: 20px;
            padding: 3rem 2rem;
            text-align: center;
            color: var(--gray-500);
            transition: all 0.3s ease;
            cursor: pointer;
            background: linear-gradient(145deg, #f8fafc, #edf2f7);
            position: relative;
            overflow: hidden;
        }

        #drop-zone::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(103, 126, 234, 0.1), transparent);
            transition: left 0.5s;
        }

        #drop-zone:hover::before {
            left: 100%;
        }

        #drop-zone.drag-over {
            border-color: var(--primary-solid);
            background: linear-gradient(145deg, rgba(103, 126, 234, 0.05), rgba(118, 75, 162, 0.05));
            transform: scale(1.02);
        }

        #drop-zone i {
            font-size: 3rem;
            margin-bottom: 1rem;
            background: var(--primary);
            background-clip: text;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        #drop-zone p {
            font-size: 1.1rem;
            margin-bottom: 0.5rem;
        }

        #drop-zone small {
            color: var(--gray-400);
            font-size: 0.9rem;
        }

        #file-input {
            display: none;
        }

        #file-preview {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
            gap: 1.5rem;
            margin-top: 2rem;
            max-height: 400px;
            overflow-y: auto;
            padding: 1rem;
            background: var(--gray-50);
            border-radius: 16px;
            border: 1px solid var(--gray-200);
        }

        .preview-item {
            position: relative;
            border: 2px solid var(--gray-200);
            border-radius: 12px;
            overflow: hidden;
            aspect-ratio: 3/4;
            transition: all 0.3s ease;
            background: white;
        }

        .preview-item:hover {
            transform: translateY(-4px);
            box-shadow: var(--shadow-lg);
            border-color: var(--primary-solid);
        }

        .preview-item img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .preview-item .file-name {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: linear-gradient(transparent, rgba(0,0,0,0.8));
            color: white;
            padding: 0.5rem;
            font-size: 0.75rem;
            text-align: center;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .preview-item .remove-btn {
            position: absolute;
            top: 8px;
            right: 8px;
            width: 28px;
            height: 28px;
            background: rgba(0,0,0,0.7);
            color: white;
            border: none;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1rem;
            opacity: 0;
            transition: all 0.2s ease;
            backdrop-filter: blur(4px);
        }

        .preview-item:hover .remove-btn {
            opacity: 1;
        }

        .remove-btn:hover {
            background: var(--error);
            transform: scale(1.1);
        }

        #user-prompt {
            width: 100%;
            padding: 1.25rem;
            border: 2px solid var(--gray-200);
            border-radius: 16px;
            font-size: 1rem;
            font-family: inherit;
            resize: vertical;
            min-height: 120px;
            transition: all 0.3s ease;
            background: white;
        }

        #user-prompt:focus {
            outline: none;
            border-color: var(--primary-solid);
            box-shadow: 0 0 0 4px rgba(103, 126, 234, 0.1);
        }

        .mode-selector {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
            gap: 1rem;
            background: var(--gray-100);
            padding: 1rem;
            border-radius: 16px;
            border: 1px solid var(--gray-200);
        }

        .mode-btn {
            padding: 1rem;
            border: 2px solid transparent;
            border-radius: 12px;
            background: white;
            color: var(--gray-600);
            font-size: 0.95rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.75rem;
            position: relative;
            overflow: hidden;
        }

        .mode-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: var(--primary);
            opacity: 0.1;
            transition: left 0.3s ease;
        }

        .mode-btn:hover::before {
            left: 0;
        }

        .mode-btn:hover {
            border-color: var(--primary-solid);
            color: var(--primary-solid);
            transform: translateY(-2px);
            box-shadow: var(--shadow-md);
        }

        .mode-btn.active {
            background: var(--primary);
            color: white;
            border-color: var(--primary-solid);
            box-shadow: var(--shadow-md);
        }

        .mode-btn i {
            font-size: 1.1rem;
        }

        #process-btn {
            width: 100%;
            padding: 1.25rem 2rem;
            background: var(--primary);
            color: white;
            border: none;
            border-radius: 16px;
            font-size: 1.1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.75rem;
            margin-top: 2rem;
            position: relative;
            overflow: hidden;
        }

        #process-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
            transition: left 0.5s;
        }

        #process-btn:hover::before {
            left: 100%;
        }

        #process-btn:hover:not(:disabled) {
            transform: translateY(-3px);
            box-shadow: var(--shadow-xl);
        }

        #process-btn.is-cancellable {
            background: var(--secondary);
        }

        #process-btn:disabled {
            opacity: 0.7;
            cursor: not-allowed;
        }

        .progress-section {
            margin-top: 2rem;
            display: none;
            background: var(--gray-50);
            padding: 2rem;
            border-radius: 16px;
            border: 1px solid var(--gray-200);
        }

        #progress-bar-container {
            width: 100%;
            background: var(--gray-200);
            border-radius: 12px;
            overflow: hidden;
            height: 16px;
            position: relative;
        }

        #progress-bar {
            width: 0%;
            height: 100%;
            background: var(--primary);
            transition: width 0.3s ease;
            border-radius: 12px;
            position: relative;
        }

        #progress-bar::after {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.4), transparent);
            animation: shimmer 2s infinite;
        }

        @keyframes shimmer {
            0% { left: -100%; }
            100% { left: 100%; }
        }

        #progress-status {
            margin-top: 1rem;
            text-align: center;
            color: var(--gray-600);
            font-weight: 500;
            font-size: 0.95rem;
        }

        .results-section {
            margin-top: 2rem;
            display: none;
        }

        #results-output {
            width: 100%;
            min-height: 200px;
            padding: 2rem;
            border: 2px solid var(--gray-200);
            border-radius: 16px;
            background: white;
            font-size: 0.95rem;
            line-height: 1.6;
            white-space: pre-wrap;
            word-wrap: break-word;
            box-shadow: var(--shadow-sm);
        }

        .spinner {
            width: 24px;
            height: 24px;
            border: 3px solid rgba(255,255,255,0.3);
            border-top-color: white;
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            100% { transform: rotate(360deg); }
        }

        /* Адаптивность */
        @media (max-width: 768px) {
            body {
                padding: 1rem;
            }
            
            .main-content {
                padding: 2rem;
            }
            
            .header h1 {
                font-size: 2rem;
            }
            
            .mode-selector {
                grid-template-columns: 1fr;
            }
            
            #drop-zone {
                padding: 2rem 1rem;
            }
        }

        /* Анимации появления */
        .fade-in {
            animation: fadeIn 0.5s ease forwards;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1><i class="fas fa-magic"></i> AI File Processor</h1>
            <p>Интеллектуальная обработка документов с помощью искусственного интеллекта</p>
        </div>
        
        <main class="main-content">
            <div class="form-section">
                <div class="section-title">
                    <div class="step-number">1</div>
                    <span>Загрузите файлы</span>
                </div>
                <div id="drop-zone">
                    <i class="fas fa-cloud-upload-alt"></i>
                    <p><strong>Перетащите файлы сюда</strong></p>
                    <p>или нажмите, чтобы выбрать</p>
                    <small>Поддерживаются: PDF, JPG, PNG, WEBP (до 10 файлов)</small>
                </div>
                <input type="file" id="file-input" multiple accept=".pdf,.jpg,.jpeg,.png,.webp">
                <div id="file-preview"></div>
            </div>

            <div class="form-section">
                <div class="section-title">
                    <div class="step-number">2</div>
                    <span>Задайте инструкцию</span>
                </div>
                <textarea id="user-prompt" 
                          placeholder="Например: найди УИН и дату и выведи столбиком для каждого файла&#10;&#10;Или: извлеки все номера телефонов и email адреса&#10;&#10;Или: составь краткое резюме содержания каждого документа"></textarea>
            </div>
            
            <div class="form-section">
                <div class="section-title">
                    <div class="step-number">3</div>
                    <span>Выберите формат вывода</span>
                </div>
                <div class="mode-selector" id="output-selector">
                    <button class="mode-btn active" data-output="program">
                        <i class="fas fa-desktop"></i>
                        <span>В программе</span>
                    </button>
                    <button class="mode-btn" data-output="txt">
                        <i class="fas fa-file-alt"></i>
                        <span>TXT файл</span>
                    </button>
                    <button class="mode-btn" data-output="docx">
                        <i class="fas fa-file-word"></i>
                        <span>DOCX файл</span>
                    </button>
                </div>
            </div>

            <button id="process-btn">
                <i class="fas fa-cogs"></i>
                <span>Начать обработку</span>
            </button>

            <div class="progress-section" id="progress-section">
                <div id="progress-bar-container">
                    <div id="progress-bar"></div>
                </div>
                <p id="progress-status">Ожидание...</p>
            </div>

            <div class="results-section" id="results-section">
                <div class="section-title">
                    <i class="fas fa-poll-h"></i>
                    <span>Результат обработки</span>
                </div>
                <div id="results-output"></div>
            </div>
        </main>
    </div>

    <script>
        class FileProcessor {
            constructor() {
                this.elements = {
                    dropZone: document.getElementById('drop-zone'),
                    fileInput: document.getElementById('file-input'),
                    filePreview: document.getElementById('file-preview'),
                    userPrompt: document.getElementById('user-prompt'),
                    processBtn: document.getElementById('process-btn'),
                    outputSelector: document.getElementById('output-selector'),
                    progressSection: document.getElementById('progress-section'),
                    progressBar: document.getElementById('progress-bar'),
                    progressStatus: document.getElementById('progress-status'),
                    resultsSection: document.getElementById('results-section'),
                    resultsOutput: document.getElementById('results-output'),
                };

                this.state = {
                    files: [], 
                    isProcessing: false,
                    isCancelled: false,
                    selectedOutput: 'program',
                };
                
                this.abortController = null;
                this.originalButtonContent = this.elements.processBtn.innerHTML;
                
                // Настройка PDF.js
                if (typeof pdfjsLib !== 'undefined') {
                    pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.11.338/pdf.worker.min.js';
                }
                
                this.init();
            }

            init() {
                this.bindEvents();
                this.animateFormSections();
            }

            animateFormSections() {
                const sections = document.querySelectorAll('.form-section');
                sections.forEach((section, index) => {
                    setTimeout(() => {
                        section.classList.add('fade-in');
                    }, index * 100);
                });
            }

            bindEvents() {
                const dz = this.elements.dropZone;
                
                // Drop zone events
                dz.addEventListener('click', () => this.elements.fileInput.click());
                dz.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    dz.classList.add('drag-over');
                });
                dz.addEventListener('dragleave', (e) => {
                    if (!dz.contains(e.relatedTarget)) {
                        dz.classList.remove('drag-over');
                    }
                });
                dz.addEventListener('drop', (e) => {
                    e.preventDefault();
                    dz.classList.remove('drag-over');
                    if (e.dataTransfer.files) {
                        this.handleFiles(e.dataTransfer.files);
                    }
                });

                // File input change
                this.elements.fileInput.addEventListener('change', (e) => {
                    if (e.target.files) {
                        this.handleFiles(e.target.files);
                    }
                });

                // Process button
                this.elements.processBtn.addEventListener('click', () => {
                    if (this.state.isProcessing) {
                        this.cancelProcessing();
                    } else {
                        this.startProcessing();
                    }
                });

                // Output selector
                this.elements.outputSelector.addEventListener('click', (e) => {
                    const button = e.target.closest('.mode-btn');
                    if (!button || button.classList.contains('active')) return;
                    
                    this.elements.outputSelector.querySelector('.active')?.classList.remove('active');
                    button.classList.add('active');
                    this.state.selectedOutput = button.dataset.output;
                });
            }

            handleFiles(files) {
                const allowedTypes = ['application/pdf', 'image/jpeg', 'image/png', 'image/webp'];
                const maxFiles = 10;
                
                if (this.state.files.length >= maxFiles) {
                    alert(`Максимальное количество файлов: ${maxFiles}`);
                    return;
                }
                
                for (const file of files) {
                    if (this.state.files.length >= maxFiles) break;
                    
                    if (allowedTypes.includes(file.type) && 
                        !this.state.files.some(f => f.file.name === file.name && f.file.size === file.size)) {
                        
                        const fileId = Date.now() + Math.random();
                        const previewSrc = URL.createObjectURL(file);
                        this.state.files.push({ id: fileId, file, previewSrc });
                    }
                }
                
                this.renderPreviews();
            }
            
            renderPreviews() {
                this.elements.filePreview.innerHTML = '';
                
                if (this.state.files.length === 0) {
                    this.elements.filePreview.style.display = 'none';
                    return;
                }
                
                this.elements.filePreview.style.display = 'grid';
                
                this.state.files.forEach(fileData => {
                    const item = document.createElement('div');
                    item.className = 'preview-item';
                    item.dataset.id = fileData.id;
                    
                    const img = document.createElement('img');
                    img.src = fileData.file.type === 'application/pdf' 
                        ? 'https://upload.wikimedia.org/wikipedia/commons/thumb/8/87/PDF_file_icon.svg/1200px-PDF_file_icon.svg.png' 
                        : fileData.previewSrc;
                    img.alt = fileData.file.name;
                    
                    const fileName = document.createElement('div');
                    fileName.className = 'file-name';
                    fileName.textContent = fileData.file.name;
                    
                    const removeBtn = document.createElement('button');
                    removeBtn.className = 'remove-btn';
                    removeBtn.innerHTML = '×';
                    removeBtn.title = 'Удалить файл';
                    removeBtn.onclick = (e) => {
                        e.stopPropagation();
                        this.removeFile(fileData.id);
                    };
                    
                    item.appendChild(img);
                    item.appendChild(fileName);
                    item.appendChild(removeBtn);
                    this.elements.filePreview.appendChild(item);
                });
            }
            
            removeFile(id) {
                const fileData = this.state.files.find(f => f.id === id);
                if (fileData && fileData.previewSrc) {
                    URL.revokeObjectURL(fileData.previewSrc);
                }
                
                this.state.files = this.state.files.filter(f => f.id !== id);
                this.renderPreviews();
            }
            
            updateProgress(percentage, status) {
                if (this.state.isCancelled) return;
                
                this.elements.progressBar.style.width = `${Math.max(0, Math.min(100, percentage))}%`;
                this.elements.progressStatus.textContent = status;
            }
            
            setLoadingState(isLoading) {
                this.state.isProcessing = isLoading;
                
                if (isLoading) {
                    this.abortController = new AbortController();
                    this.state.isCancelled = false;
                    this.elements.processBtn.innerHTML = `<div class="spinner"></div><span>Отменить</span>`;
                    this.elements.processBtn.classList.add('is-cancellable');
                    this.elements.progressSection.style.display = 'block';
                    this.elements.progressSection.classList.add('fade-in');
                    this.elements.resultsSection.style.display = 'none';
                    this.elements.resultsOutput.innerHTML = '';
                    this.elements.progressBar.style.background = 'var(--primary)';
                    this.elements.processBtn.disabled = false;
                } else {
                    this.abortController = null;
                    this.elements.processBtn.innerHTML = this.originalButtonContent;
                    this.elements.processBtn.classList.remove('is-cancellable');
                    this.elements.processBtn.disabled = false;
                }
            }

            cancelProcessing() {
                if (this.abortController) {
                    this.state.isCancelled = true;
                    this.abortController.abort();
                    this.updateProgress(100, 'Процесс отменен пользователем');
                    this.elements.progressBar.style.background = 'var(--warning)';
                    this.setLoadingState(false);
                }
            }

            async startProcessing() {
                // Валидация
                if (this.state.files.length === 0) {
                    alert('Пожалуйста, загрузите хотя бы один файл.');
                    return;
                }
                
                if (!this.elements.userPrompt.value.trim()) {
                    alert('Пожалуйста, введите инструкцию для обработки.');
                    this.elements.userPrompt.focus();
                    return;
                }

                this.setLoadingState(true);
                const allExtractedTexts = [];
               

const skippedFiles = [];
               
               try {
                   // 1. Конвертация PDF в изображения
                   const imageTasks = [];
                   for (let i = 0; i < this.state.files.length; i++) {
                       if (this.state.isCancelled) break;
                       
                       const fileData = this.state.files[i];
                       const progress = (i / this.state.files.length) * 20; // 20% на конвертацию
                       
                       if (fileData.file.type === 'application/pdf') {
                           this.updateProgress(progress, `Конвертация PDF: ${fileData.file.name}...`);
                           try {
                               const imagesFromPdf = await this.convertPdfToImages(fileData.file);
                               imagesFromPdf.forEach((imgBlob, index) => {
                                   imageTasks.push({ 
                                       blob: imgBlob, 
                                       sourceName: `${fileData.file.name} (стр. ${index + 1})` 
                                   });
                               });
                           } catch (error) {
                               console.error(`Failed to convert PDF ${fileData.file.name}:`, error);
                               skippedFiles.push(`${fileData.file.name} (ошибка конвертации PDF)`);
                           }
                       } else {
                           imageTasks.push({ 
                               blob: fileData.file, 
                               sourceName: fileData.file.name 
                           });
                       }
                   }

                   if (this.state.isCancelled) return;

                   // 2. Распознавание текста с изображений
                   for (let i = 0; i < imageTasks.length; i++) {
                       if (this.state.isCancelled) break;
                       
                       const task = imageTasks[i];
                       const progress = 20 + ((i + 1) / imageTasks.length) * 60; // 60% на распознавание
                       this.updateProgress(progress, `Распознавание: ${i + 1}/${imageTasks.length} (${task.sourceName})`);
                       
                       try {
                           const base64Image = await this.toBase64(task.blob);
                           const ocrPrompt = "Внимательно распознай и выведи весь текст с этого изображения. Сохрани структуру и форматирование. Выводи только текст без комментариев.";
                           const recognizedText = await this.sendToAI(ocrPrompt, base64Image, 'gemini-2.5-flash', 3);
                           
                           if (recognizedText && recognizedText.trim()) {
                               allExtractedTexts.push(`--- Начало документа: ${task.sourceName} ---\n${recognizedText.trim()}\n--- Конец документа: ${task.sourceName} ---`);
                           } else {
                               skippedFiles.push(`${task.sourceName} (не удалось распознать текст)`);
                           }
                       } catch (error) {
                           console.error(`Failed to process ${task.sourceName}:`, error);
                           skippedFiles.push(`${task.sourceName} (ошибка распознавания)`);
                       }
                       
                       // Небольшая пауза между запросами
                       if (i < imageTasks.length - 1) {
                           await new Promise(resolve => setTimeout(resolve, 500));
                       }
                   }

                   if (this.state.isCancelled) return;

                   if (allExtractedTexts.length === 0) {
                       throw new Error("Не удалось извлечь текст ни из одного файла. Проверьте качество изображений.");
                   }

                   // 3. Финальный анализ с помощью AI
                   this.updateProgress(85, 'Анализ и обработка текста с помощью ИИ...');
                   
                   const combinedText = allExtractedTexts.join('\n\n');
                   const finalUserPrompt = this.elements.userPrompt.value.trim();
                   
                   const systemPrompt = `Ты — профессиональный ассистент по обработке документов. Тебе предоставлен текст, извлеченный из документов пользователя.

ВАЖНО: 
- Внимательно изучи весь предоставленный текст
- Точно следуй инструкции пользователя
- Если нужно найти определенную информацию, ищи ее во всех документах
- Структурируй ответ четко и понятно
- Если информация не найдена, честно об этом сообщи

Текст из документов:
<documents>
${combinedText}
</documents>

Инструкция пользователя: "${finalUserPrompt}"

Выведи результат в виде HTML-фрагмента с базовым форматированием (используй теги <p>, <br>, <b>, <i>, <ul>, <li>, <table>, <tr>, <td>). Не используй теги <html>, <head>, <body> - только содержимое.`;

                   let finalResultHtml = await this.sendToAI(systemPrompt, null, 'gemini-2.5-flash', 2);
                   
                   // Добавляем информацию о пропущенных файлах
                   if (skippedFiles.length > 0) {
                       finalResultHtml += `<br><br><p><b>⚠️ Внимание:</b> Следующие файлы не удалось обработать:</p><ul>`;
                       skippedFiles.forEach(name => {
                           finalResultHtml += `<li>${this.escapeHtml(name)}</li>`;
                       });
                       finalResultHtml += '</ul>';
                   }

                   // 4. Вывод результата
                   this.updateProgress(95, 'Формирование результата...');
                   await this.handleOutput(finalResultHtml);
                   this.updateProgress(100, `Готово! Обработано файлов: ${allExtractedTexts.length}`);

               } catch (error) {
                   if (error.name !== 'AbortError' && !this.state.isCancelled) {
                       console.error('Processing error:', error);
                       this.updateProgress(100, `Ошибка: ${error.message}`);
                       this.elements.progressBar.style.background = 'var(--error)';
                       alert(`Произошла ошибка: ${error.message}`);
                   }
               } finally {
                   if (!this.state.isCancelled) {
                       this.setLoadingState(false);
                   }
               }
           }
           
           async handleOutput(htmlContent) {
               switch (this.state.selectedOutput) {
                   case 'program':
                       this.elements.resultsOutput.innerHTML = htmlContent;
                       this.elements.resultsSection.style.display = 'block';
                       this.elements.resultsSection.classList.add('fade-in');
                       this.elements.resultsSection.scrollIntoView({ behavior: 'smooth' });
                       break;
                       
                   case 'txt':
                       await this.downloadAsTxt(htmlContent);
                       break;
                       
                   case 'docx':
                       await this.downloadAsDocx(htmlContent);
                       break;
               }
           }

           async downloadAsTxt(htmlContent) {
               try {
                   // Конвертируем HTML в обычный текст
                   const tempDiv = document.createElement('div');
                   tempDiv.innerHTML = htmlContent;
                   
                   // Заменяем HTML теги на текстовые эквиваленты
                   const textContent = this.htmlToText(tempDiv);
                   
                   const blob = new Blob([textContent], { 
                       type: 'text/plain;charset=utf-8' 
                   });
                   
                   this.triggerDownload(blob, `result_${this.getTimestamp()}.txt`);
               } catch (error) {
                   console.error('Error creating TXT file:', error);
                   alert('Ошибка при создании TXT файла');
               }
           }

           async downloadAsDocx(htmlContent) {
               try {
                   // Используем библиотеку docx для создания настоящего DOCX файла
                   if (typeof docx === 'undefined') {
                       // Fallback к RTF если docx недоступна
                       await this.downloadAsRtf(htmlContent);
                       return;
                   }

                   const { Document, Packer, Paragraph, TextRun } = docx;
                   
                   // Конвертируем HTML в структуру документа
                   const paragraphs = this.htmlToDocxParagraphs(htmlContent);
                   
                   const doc = new Document({
                       sections: [{
                           properties: {},
                           children: paragraphs,
                       }],
                   });

                   const buffer = await Packer.toBuffer(doc);
                   const blob = new Blob([buffer], { 
                       type: 'application/vnd.openxmlformats-officedocument.wordprocessingml.document' 
                   });
                   
                   this.triggerDownload(blob, `result_${this.getTimestamp()}.docx`);
                   
               } catch (error) {
                   console.error('Error creating DOCX file:', error);
                   // Fallback к RTF
                   await this.downloadAsRtf(htmlContent);
               }
           }

           async downloadAsRtf(htmlContent) {
               try {
                   // Создаем RTF документ (совместим с Word)
                   const rtfContent = this.htmlToRtf(htmlContent);
                   
                   const blob = new Blob([rtfContent], { 
                       type: 'application/rtf;charset=utf-8' 
                   });
                   
                   this.triggerDownload(blob, `result_${this.getTimestamp()}.rtf`);
               } catch (error) {
                   console.error('Error creating RTF file:', error);
                   alert('Ошибка при создании файла документа');
               }
           }

           htmlToText(element) {
               let text = '';
               
               for (const node of element.childNodes) {
                   if (node.nodeType === Node.TEXT_NODE) {
                       text += node.textContent;
                   } else if (node.nodeType === Node.ELEMENT_NODE) {
                       const tagName = node.tagName.toLowerCase();
                       
                       switch (tagName) {
                           case 'br':
                               text += '\n';
                               break;
                           case 'p':
                           case 'div':
                               if (text && !text.endsWith('\n')) text += '\n';
                               text += this.htmlToText(node);
                               text += '\n';
                               break;
                           case 'li':
                               text += '• ' + this.htmlToText(node) + '\n';
                               break;
                           case 'b':
                           case 'strong':
                               text += this.htmlToText(node);
                               break;
                           case 'i':
                           case 'em':
                               text += this.htmlToText(node);
                               break;
                           case 'ul':
                           case 'ol':
                               text += '\n' + this.htmlToText(node) + '\n';
                               break;
                           default:
                               text += this.htmlToText(node);
                       }
                   }
               }
               
               return text;
           }

           htmlToRtf(htmlContent) {
               // Простой конвертер HTML в RTF
               let rtf = '{\\rtf1\\ansi\\deff0 {\\fonttbl {\\f0 Times New Roman;}}\\f0\\fs24 ';
               
               // Убираем HTML теги и заменяем на RTF форматирование
               let text = htmlContent
                   .replace(/<br\s*\/?>/gi, '\\line ')
                   .replace(/<\/p>/gi, '\\par ')
                   .replace(/<p[^>]*>/gi, '\\par ')
                   .replace(/<b[^>]*>(.*?)<\/b>/gi, '{\\b $1}')
                   .replace(/<strong[^>]*>(.*?)<\/strong>/gi, '{\\b $1}')
                   .replace(/<i[^>]*>(.*?)<\/i>/gi, '{\\i $1}')
                   .replace(/<em[^>]*>(.*?)<\/em>/gi, '{\\i $1}')
                   .replace(/<li[^>]*>/gi, '\\bullet ')
                   .replace(/<\/li>/gi, '\\line ')
                   .replace(/<ul[^>]*>/gi, '')
                   .replace(/<\/ul>/gi, '\\par ')
                   .replace(/<[^>]*>/g, ''); // Убираем остальные теги
               
               rtf += text + '}';
               return rtf;
           }

           htmlToDocxParagraphs(htmlContent) {
               if (typeof docx === 'undefined') return [];
               
               const { Paragraph, TextRun } = docx;
               const tempDiv = document.createElement('div');
               tempDiv.innerHTML = htmlContent;
               
               const paragraphs = [];
               
               for (const node of tempDiv.childNodes) {
                   if (node.nodeType === Node.TEXT_NODE && node.textContent.trim()) {
                       paragraphs.push(new Paragraph({
                           children: [new TextRun(node.textContent.trim())],
                       }));
                   } else if (node.nodeType === Node.ELEMENT_NODE) {
                       const para = this.nodeToDocxParagraph(node);
                       if (para) paragraphs.push(para);
                   }
               }
               
               return paragraphs.length > 0 ? paragraphs : [new Paragraph({
                   children: [new TextRun("Результат обработки")],
               })];
           }

           nodeToDocxParagraph(node) {
               if (typeof docx === 'undefined') return null;
               
               const { Paragraph, TextRun } = docx;
               const children = [];
               
               for (const child of node.childNodes) {
                   if (child.nodeType === Node.TEXT_NODE && child.textContent.trim()) {
                       children.push(new TextRun({
                           text: child.textContent.trim(),
                           bold: node.tagName === 'B' || node.tagName === 'STRONG',
                           italics: node.tagName === 'I' || node.tagName === 'EM',
                       }));
                   }
               }
               
               return children.length > 0 ? new Paragraph({ children }) : null;
           }

           triggerDownload(blob, filename) {
               const url = URL.createObjectURL(blob);
               const a = document.createElement('a');
               a.href = url;
               a.download = filename;
               a.style.display = 'none';
               document.body.appendChild(a);
               a.click();
               document.body.removeChild(a);
               URL.revokeObjectURL(url);
               
               // Показываем уведомление об успешной загрузке
               this.showNotification(`Файл ${filename} успешно загружен`, 'success');
           }

           async sendToAI(prompt, base64Image = null, model = 'gemini-2.5-flash', maxRetries = 2) {
               for (let attempt = 1; attempt <= maxRetries; attempt++) {
                   if (this.state.isCancelled) {
                       throw new Error('Operation cancelled by user');
                   }
                   
                   try {
                       let content = [{ type: 'text', text: prompt }];
                       
                       if (base64Image) {
                           content.push({
                               type: 'image_url',
                               image_url: { url: base64Image }
                           });
                       }
                       
                       const body = {
                           model: model,
                           messages: [{
                               role: 'user',
                               content: content
                           }],
                           max_tokens: 4096,
                           temperature: 0.1
                       };
                       
                       const response = await fetch("https://mapruapp.ru/ai/api/v1/chat/completions", {
                           method: 'POST',
                           headers: {
                               'Content-Type': 'application/json',
                           },
                           body: JSON.stringify(body),
                           signal: this.abortController?.signal,
                       });
                       
                       if (!response.ok) {
                           const errorData = await response.json().catch(() => ({}));
                           throw new Error(`API Error: ${errorData.error?.message || response.statusText}`);
                       }
                       
                       const data = await response.json();
                       const result = data.choices?.[0]?.message?.content;
                       
                       if (!result) {
                           throw new Error('Пустой ответ от AI');
                       }
                       
                       return result;
                       
                   } catch (error) {
                       if (error.name === 'AbortError') {
                           throw error;
                       }
                       
                       console.error(`AI request attempt ${attempt} failed:`, error);
                       
                       if (attempt === maxRetries) {
                           throw new Error(`Не удалось получить ответ от AI после ${maxRetries} попыток: ${error.message}`);
                       }
                       
                       // Экспоненциальная задержка между попытками
                       await new Promise(resolve => 
                           setTimeout(resolve, Math.pow(2, attempt) * 1000)
                       );
                   }
               }
           }

           async convertPdfToImages(pdfFile) {
               if (typeof pdfjsLib === 'undefined') {
                   throw new Error('PDF.js не загружен. Невозможно конвертировать PDF файлы.');
               }
               
               const images = [];
               const data = await pdfFile.arrayBuffer();
               const pdf = await pdfjsLib.getDocument(data).promise;
               
               for (let i = 1; i <= pdf.numPages; i++) {
                   if (this.state.isCancelled) break;
                   
                   try {
                       const page = await pdf.getPage(i);
                       const viewport = page.getViewport({ scale: 2.0 }); // Увеличиваем разрешение
                       
                       const canvas = document.createElement('canvas');
                       canvas.height = viewport.height;
                       canvas.width = viewport.width;
                       
                       const renderContext = {
                           canvasContext: canvas.getContext('2d'),
                           viewport: viewport
                       };
                       
                       await page.render(renderContext).promise;
                       
                       const blob = await new Promise(resolve => 
                           canvas.toBlob(resolve, 'image/jpeg', 0.95)
                       );
                       
                       images.push(blob);
                       page.cleanup();
                       
                   } catch (error) {
                       console.error(`Error converting PDF page ${i}:`, error);
                       throw new Error(`Ошибка конвертации страницы ${i} PDF файла`);
                   }
               }
               
               return images;
           }

           toBase64(file) {
               return new Promise((resolve, reject) => {
                   const reader = new FileReader();
                   reader.readAsDataURL(file);
                   reader.onload = () => resolve(reader.result);
                   reader.onerror = error => reject(error);
               });
           }

           escapeHtml(text) {
               const div = document.createElement('div');
               div.textContent = text;
               return div.innerHTML;
           }

           getTimestamp() {
               const now = new Date();
               return now.toISOString().slice(0, 19).replace(/[:.]/g, '-');
           }

           showNotification(message, type = 'info') {
               // Простое уведомление
               const notification = document.createElement('div');
               notification.style.cssText = `
                   position: fixed;
                   top: 20px;
                   right: 20px;
                   padding: 1rem 1.5rem;
                   background: ${type === 'success' ? 'var(--success)' : 'var(--primary-solid)'};
                   color: white;
                   border-radius: 8px;
                   box-shadow: var(--shadow-lg);
                   z-index: 10000;
                   animation: slideInRight 0.3s ease;
               `;
               notification.textContent = message;
               
               document.body.appendChild(notification);
               
               setTimeout(() => {
                   notification.style.animation = 'slideOutRight 0.3s ease';
                   setTimeout(() => {
                       document.body.removeChild(notification);
                   }, 300);
               }, 3000);
           }
       }

       // Инициализация при загрузке страницы
       document.addEventListener('DOMContentLoaded', () => {
           new FileProcessor();
       });

       // Добавляем стили для анимации уведомлений
       const style = document.createElement('style');
       style.textContent = `
           @keyframes slideInRight {
               from { transform: translateX(100%); opacity: 0; }
               to { transform: translateX(0); opacity: 1; }
           }
           
           @keyframes slideOutRight {
               from { transform: translateX(0); opacity: 1; }
               to { transform: translateX(100%); opacity: 0; }
           }
       `;
       document.head.appendChild(style);
   </script>
</body>
</html>                