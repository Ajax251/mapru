<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Конвертер координат</title>
    <link rel="icon" href="img/coor.png" type="image/png">
    <!-- 1. ПОДКЛЮЧАЕМ БИБЛИОТЕКУ PROJ4JS ДЛЯ ЛОКАЛЬНОЙ КОНВЕРТАЦИИ -->
    <script src="webfonts/proj4.js"></script>
    <style>
        /* --- Общие стили --- */
        * { margin: 0; padding: 0; box-sizing: border-box; }
        html, body { height: 100%; overflow: hidden; }
        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; line-height: 1.6; color: #2c3e50; background-color: #f0f2f5; }

        .container { width: 100vw; height: 100vh; padding: 25px; display: flex; flex-direction: column; position: relative; transition: background 0.8s ease-in-out; }
        .container::before { content: ''; position: absolute; top: 0; left: 0; right: 0; bottom: 0; background: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><defs><pattern id="grain" width="100" height="100" patternUnits="userSpaceOnUse"><circle cx="20" cy="20" r="1" fill="%23000" opacity="0.03"/><circle cx="80" cy="40" r="1" fill="%23000" opacity="0.03"/><circle cx="40" cy="80" r="1" fill="%23000" opacity="0.03"/></pattern></defs><rect width="100%" height="100%" fill="url(%23grain)"/></svg>'); pointer-events: none; z-index: 0; }

        /* --- Стили макета (Grid + Flexbox) --- */
        .main-layout { display: grid; grid-template-columns: 1fr 1fr 120px; gap: 25px; flex: 1; min-height: 0; z-index: 1; }
        .column, .actions-panel { background: rgba(255, 255, 255, 0.6); border-radius: 20px; box-shadow: 0 10px 30px rgba(0,0,0,0.1); border: 1px solid rgba(255,255,255,0.3); backdrop-filter: blur(15px); position: relative; overflow: hidden; }
        .column { display: flex; flex-direction: column; min-height: 0; padding: 25px; }

        /* --- Стили элементов форм --- */
        .textarea-container { position: relative; flex: 1; display: flex; flex-direction: column; min-height: 0; margin-bottom: 15px; }
        
        .textarea-icon-stack {
            position: absolute;
            top: 12px;
            right: 12px;
            z-index: 10;
            display: flex;
            flex-direction: column;
            gap: 8px;
            align-items: center;
        }

        .icon-btn {
            border: none;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            color: white;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            background: linear-gradient(135deg, #6a82fb 0%, #fc5c7d 100%);
        }
        .icon-btn:hover {
            box-shadow: 0 6px 25px rgba(0, 0, 0, 0.3);
            transform: scale(1.1);
        }

        .main-icon {
            width: 32px;
            height: 32px;
            font-size: 14px;
        }
        .main-icon:hover {
             transform: scale(1.1) rotate(180deg);
        }

        .sub-icon {
            width: 28px;
            height: 28px;
            background: linear-gradient(135deg, #8999f0 0%, #f78b9f 100%);
            font-size: 14px; 
            transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }
  
        .sub-icon svg { width: 14px; height: 14px; fill: white; }
        .sub-icon.rotate-vertical { transform: rotate(180deg); }
        .sub-icon.rotate-copy { transform: scale(1.2); }
        
        label { display: block; margin-bottom: 12px; font-weight: 600; color: #34495e; font-size: 0.95rem; letter-spacing: 0.5px; text-align: center; }
        textarea, input[type="text"], input[type="number"], select { width: 100%; padding: 16px 20px; border: 1px solid rgba(52, 73, 94, 0.15); border-radius: 15px; font-size: 0.95rem; transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1); background: rgba(255, 255, 255, 0.8); box-shadow: 0 4px 15px rgba(0,0,0,0.05); }
        textarea:focus, input[type="text"]:focus, input[type="number"]:focus, select:focus { outline: none; border-color: #4facfe; box-shadow: 0 0 0 4px rgba(79, 172, 254, 0.2), 0 8px 25px rgba(0,0,0,0.1); transform: translateY(-2px); }
        textarea { flex: 1; resize: none; font-family: 'SF Mono', 'Monaco', 'Inconsolata', 'Roboto Mono', monospace; font-size: 0.9rem; line-height: 1.5; padding-top: 25px; overflow-y: auto; min-height: 0; text-align: center; background: #ffffff; }
        select { margin-bottom: 15px; cursor: pointer; appearance: none; background-image: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="%234facfe" stroke-width="2"><polyline points="6,9 12,15 18,9"/></svg>'); background-repeat: no-repeat; background-position: right 15px center; background-size: 18px; padding-right: 45px; text-align: center; text-align-last: center; }
        select option { text-align: left; }

        .offset-indicator { display: none; text-align: center; font-size: 0.85rem; color: #2c3e50; background-color: rgba(46, 204, 113, 0.15); border: 1px solid rgba(46, 204, 113, 0.3); padding: 8px; border-radius: 10px; margin-bottom: 15px; }
        .offset-indicator span { font-weight: bold; }

        /* --- Вертикальная панель действий --- */
        .actions-panel { padding: 25px 15px; display: flex; flex-direction: column; gap: 15px; align-items: center; }
        .action-btn { width: 60px; height: 60px; padding: 15px; margin: 0; border: 1px solid rgba(255, 255, 255, 0.2); border-radius: 50%; display: flex; align-items: center; justify-content: center; transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1); cursor: pointer; box-shadow: 0 8px 25px rgba(0,0,0,0.15); }
        .action-btn:hover { border-color: rgba(255, 255, 255, 0.3); transform: translateY(-5px) scale(1.08); box-shadow: 0 15px 35px rgba(0,0,0,0.25); filter: brightness(1.1); }
        .action-btn:disabled { cursor: not-allowed; background: #ccc !important; transform: none !important; box-shadow: 0 4px 10px rgba(0,0,0,0.1) !important; filter: grayscale(1); }
        .action-btn img { width: 30px; height: 30px; transition: all 0.4s ease; filter: brightness(0) invert(1) drop-shadow(0 2px 4px rgba(0,0,0,0.2)); }
        .action-btn:hover img { transform: scale(1.2) rotate(5deg); }

        /* --- Стили модального окна --- */
        .modal-overlay { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.6); z-index: 100; }
        .modal { display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 90%; max-width: 600px; background: white; padding: 30px; border-radius: 20px; box-shadow: 0 15px 40px rgba(0,0,0,0.2); z-index: 101; text-align: center; }
        .modal h3 { margin-bottom: 15px; color: #34495e; }
        .modal #modal-initial-view p { text-align: left; margin-bottom: 20px; font-size: 0.9rem; line-height: 1.5; background-color: #f8f9fa; padding: 15px; border-radius: 8px; border: 1px solid #e9ecef; color: #2c3e50; }
        .modal p b { color: #e74c3c; }
        .modal-inputs { display: flex; gap: 15px; margin-bottom: 25px; }
        .modal-inputs div { flex: 1; }
        .modal input[type="text"] { padding: 12px; text-align: center; }
        .modal-actions { display: flex; justify-content: center; gap: 15px; }
        .modal-btn { padding: 12px 25px; border: none; border-radius: 10px; color: white; cursor: pointer; font-weight: 600; transition: all 0.3s ease; }
        .modal-btn.primary { background-color: #3498db; }
        .modal-btn.secondary { background-color: #2ecc71; }
        .modal-btn.tertiary { background-color: #95a5a6; }
        .modal-btn:hover { transform: translateY(-2px); box-shadow: 0 5px 15px rgba(0,0,0,0.2); }
        #modal-results { display: none; max-height: 40vh; overflow-y: auto; margin-bottom: 15px; }
        #modal-results table { width: 100%; border-collapse: collapse; font-size: 0.9rem; }
        #modal-results th, #modal-results td { padding: 8px 12px; border: 1px solid #ddd; }
        #modal-results th { background-color: #f2f2f2; font-weight: 600; }
        #modal-results .delta-pos { color: #27ae60; }
        #modal-results .delta-neg { color: #c0392b; }
        .modal-summary { font-weight: bold; margin-top: 15px; background-color: #ecf0f1; padding: 10px; border-radius: 8px; }

        .modal-option { display: flex; align-items: center; justify-content: center; margin-bottom: 20px; font-size: 0.9rem; user-select: none; }
        .modal-option input[type="checkbox"] { width: auto; height: auto; margin-right: 10px; transform: scale(1.2); cursor: pointer; }
        .modal-option label { margin-bottom: 0; cursor: pointer; }
        
        /* --- Стили для прогресс-бара --- */
        #progressBarContainer { display: none; z-index: 5; margin-top: 20px; width: 100%; text-align: center; }
        #progressBarLabel { font-size: 0.9rem; color: #34495e; margin-bottom: 8px; }
        #progressBar { width: 100%; background-color: #e0e0e0; border-radius: 10px; overflow: hidden; height: 10px; box-shadow: inset 0 1px 3px rgba(0,0,0,0.1); }
        #progressBarFill { width: 0%; height: 100%; background: linear-gradient(90deg, #66a6ff, #89f7fe); transition: width 0.4s ease; border-radius: 10px; }

        /* --- Прочее --- */
        .error { color: #e74c3c !important; border-color: #e74c3c !important; background: #fff5f5 !important; box-shadow: 0 0 0 4px rgba(231, 76, 60, 0.15) !important; }
        .custom-input { display: none; margin-bottom: 15px; }
        textarea::-webkit-scrollbar { width: 8px; }
        textarea::-webkit-scrollbar-track { background: rgba(0,0,0,0.05); border-radius: 10px; }
        textarea::-webkit-scrollbar-thumb { background: linear-gradient(135deg, #89f7fe 0%, #66a6ff 100%); border-radius: 10px; }

        /* --- Адаптивность --- */
        @media (max-width: 1200px) { .main-layout { grid-template-columns: 1fr 1fr 100px; } .action-btn { width: 55px; height: 55px; } .action-btn img { width: 28px; height: 28px; } }
        @media (max-width: 768px) { .container { padding: 15px; } .main-layout { grid-template-columns: 1fr; gap: 20px; } .actions-panel { flex-direction: row; padding: 15px; justify-content: space-around; } .column { min-height: 250px; padding: 20px; } }
    </style>
</head>
<body>

    <div class="container">
        <div class="main-layout">
            <div class="column">
                <label for="sourceText">Исходные данные (координаты или кадастровые номера):</label>
                <div class="textarea-container">
                    <textarea id="sourceText" placeholder="Координаты X Y или список кадастровых номеров"></textarea>
                    <div class="textarea-icon-stack">
                        <button class="icon-btn main-icon" id="swapSourceBtn" title="Поменять колонки местами">↔</button>
                        <button class="icon-btn sub-icon" id="copySourceBtn" title="Копировать"><svg viewBox="0 0 24 24"><path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12V1zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm0 16H8V7h11v14z"></path></svg></button>
                        <button class="icon-btn sub-icon" id="vSwapSourceBtn" title="Поменять порядок строк">↕</button>
                        <button class="icon-btn sub-icon" id="separateContoursSourceBtn" title="Разделить на контуры"><svg viewBox="0 0 24 24" fill="white"><path d="M17 13h-4v4h-2v-4H7v-2h4V7h2v4h4v2zM5 21V3h14v7h2V3c0-1.1-.9-2-2-2H5c-1.1 0-2 .9-2 2v18c0 1.1.9 2 2 2h7v-2H5z"></path></svg></button>
                    </div>
                </div>
                <label for="sourceScSelect">Исходная система координат:</label>
                <div id="sourceOffsetIndicator" class="offset-indicator"></div>
                <select id="sourceScSelect"></select>
                <input type="text" id="sourceScInput" class="custom-input" placeholder="Введите код EPSG или строку Proj4">
            </div>

            <div class="column">
                <label for="result-area">Результат:</label>
                <div class="textarea-container">
                    <textarea id="result-area" readonly placeholder="Результат конвертации или фактические координаты для расчета смещения"></textarea>
                    <div class="textarea-icon-stack">
                        <button class="icon-btn main-icon" id="swapResultBtn" title="Поменять колонки местами">↔</button>
                        <button class="icon-btn sub-icon" id="copyResultBtn" title="Копировать"><svg viewBox="0 0 24 24"><path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12V1zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm0 16H8V7h11v14z"></path></svg></button>
                        <button class="icon-btn sub-icon" id="vSwapResultBtn" title="Поменять порядок строк">↕</button>
                        <button class="icon-btn sub-icon" id="separateContoursResultBtn" title="Разделить на контуры"><svg viewBox="0 0 24 24" fill="white"><path d="M17 13h-4v4h-2v-4H7v-2h4V7h2v4h4v2zM5 21V3h14v7h2V3c0-1.1-.9-2-2-2H5c-1.1 0-2 .9-2 2v18c0 1.1.9 2 2 2h7v-2H5z"></path></svg></button>
                    </div>
                </div>
                <label for="destScSelect">Целевая система координат:</label>
                <select id="destScSelect"></select>
                <div id="offsetIndicator" class="offset-indicator"></div>
                <input type="text" id="destScInput" class="custom-input" placeholder="Введите код EPSG или строку Proj4">
            </div>
            
            <div class="actions-panel">
                <button class="action-btn" id="convertBtn" title="Конвертировать координаты"><img src="img/play.png" alt="Конвертировать"></button>
                <button class="action-btn" id="saveFileBtn" title="Схема"><img src="img/xy.png" alt="Схема"></button>
                <button class="action-btn" id="saveXmlBtn" title="Схема XML"><img src="img/sxml.png" alt="Схема XML"></button>
                <button class="action-btn" id="showOnMapBtn" title="Карта"><img src="img/map.png" alt="Карта"></button>
                <button class="action-btn" id="openEditorBtn" title="Редактор"><img src="img/ed.png" alt="Редактор"></button>
                <button class="action-btn" id="offsetBtn" title="Рассчитать и применить смещение"><img src="img/move.png" alt="Смещение"></button>
            </div>
        </div>
        
        <!-- Прогресс-бар для обработки кадастровых номеров -->
        <div id="progressBarContainer">
            <div id="progressBarLabel"></div>
            <div id="progressBar">
                <div id="progressBarFill"></div>
            </div>
        </div>

    </div>

    <div id="modalOverlay" class="modal-overlay"></div>
    <div id="offsetModal" class="modal">
        <h3>Настройка</h3>
        <div id="modal-initial-view">
            <div class="mode-switch-container" style="display: none;">
                <label>Режим конвертации:</label>
                <label class="switch"><input type="checkbox" id="conversionModeSwitch"><span class="slider"></span></label>
            </div>
            <p>
                <b>Для автоматического расчета смещения (на примере XML файла):</b><br>
                1. Вставьте <b>ранее сконвертированные</b> (например из EPSG:3857-НСПД в МСК) координаты  в левое поле на главном экране.<br>
                2. Вставьте <b>фактические</b> (из XML файла) координаты в правое поле.<br>
                3. Нажмите кнопку "Рассчитать по данным".<br>
                <b style="color: #c0392b;">Важно:</b> порядок точек в обоих списках должен совпадать.
            </p>
            <p style="text-align: center; margin-bottom: 20px; font-size: 0.9rem; color: #34495e; background-color: #ecf0f1; padding: 10px; border-radius: 8px; border: 1px solid #bdc3c7;">
               Настройки смещения в этом окне применяются <b>только к Целевым координатам (в МСК)</b> (правое поле).
            </p>
            <div class="modal-inputs">
                <div><label for="offsetXInput">Смещение по X (метры):</label><input type="text" id="offsetXInput" value="0"></div>
                <div><label for="offsetYInput">Смещение по Y (метры):</label><input type="text" id="offsetYInput" value="0"></div>
            </div>
            <div class="modal-option">
                <input type="checkbox" id="autoLoadOffsetSwitch"><label for="autoLoadOffsetSwitch">Автозагрузка смещения из Proj4</label>
            </div>
        </div>
        <div id="modal-results"></div>
        <div class="modal-actions">
            <button id="modalPrimaryBtn" class="modal-btn primary">Рассчитать по данным</button>
            <button id="modalSecondaryBtn" class="modal-btn secondary">Сбросить</button>
            <button id="closeModalBtn" class="modal-btn tertiary">Закрыть</button>
        </div>
    </div>
    
      <div id="notification" style="display: none; position: fixed; bottom: 25px; right: 25px; background: linear-gradient(135deg, #2af598 0%, #009efd 100%); color: white; padding: 12px 25px; border-radius: 15px; box-shadow: 0 8px 20px rgba(0,0,0,0.2); z-index: 10001; font-weight: 600;"></div>
    
    <!-- *** ИЗМЕНЕНИЕ: sk.js ПЕРЕНЕСЕН СЮДА, ПЕРЕД ОСНОВНЫМ СКРИПТОМ *** -->
    <script src="sk.js"></script>

    <script>
        // --- ИЗМЕНЕНИЕ: Удалена обертка DOMContentLoaded, скрипт и так в конце body ---
        // document.addEventListener('DOMContentLoaded', function() { ... });

        // --- Получение всех элементов DOM ---
        const sourceTextArea = document.getElementById('sourceText');
        const resultArea = document.getElementById('result-area');
        const sourceScSelect = document.getElementById('sourceScSelect');
        const sourceScInput = document.getElementById('sourceScInput');
        const destScSelect = document.getElementById('destScSelect');
        const destScInput = document.getElementById('destScInput');
        const offsetIndicator = document.getElementById('offsetIndicator');
        const sourceOffsetIndicator = document.getElementById('sourceOffsetIndicator');
        
        // Модальное окно
        const modalOverlay = document.getElementById('modalOverlay');
        const offsetModal = document.getElementById('offsetModal');
        const offsetXInput = document.getElementById('offsetXInput');
        const offsetYInput = document.getElementById('offsetYInput');
        const modalInitialView = document.getElementById('modal-initial-view');
        const modalResultsView = document.getElementById('modal-results');
        const modalPrimaryBtn = document.getElementById('modalPrimaryBtn');
        const modalSecondaryBtn = document.getElementById('modalSecondaryBtn');
        const closeModalBtn = document.getElementById('closeModalBtn');
        const conversionModeSwitch = document.getElementById('conversionModeSwitch');
        const autoLoadOffsetSwitch = document.getElementById('autoLoadOffsetSwitch');
        
        // Кнопки
        const convertBtn = document.getElementById('convertBtn');
        const offsetBtn = document.getElementById('offsetBtn');
        const swapSourceBtn = document.getElementById('swapSourceBtn');
        const copySourceBtn = document.getElementById('copySourceBtn');
        const vSwapSourceBtn = document.getElementById('vSwapSourceBtn');
        const swapResultBtn = document.getElementById('swapResultBtn');
        const copyResultBtn = document.getElementById('copyResultBtn');
        const vSwapResultBtn = document.getElementById('vSwapResultBtn');
        const saveFileBtn = document.getElementById('saveFileBtn');
        const saveXmlBtn = document.getElementById('saveXmlBtn');
        const showOnMapBtn = document.getElementById('showOnMapBtn');
        const openEditorBtn = document.getElementById('openEditorBtn');
        const separateContoursSourceBtn = document.getElementById('separateContoursSourceBtn');
        const separateContoursResultBtn = document.getElementById('separateContoursResultBtn');
        
        // Элементы прогресс-бара
        const progressBarContainer = document.getElementById('progressBarContainer');
        const progressBarLabel = document.getElementById('progressBarLabel');
        const progressBarFill = document.getElementById('progressBarFill');

        let calculatedOffset = null;
        let isConversionInProgress = false; // Флаг для блокировки кнопки

        // --- Дизайн ---
        const gradients = [ 'linear-gradient(135deg, #a1c4fd 0%, #c2e9fb 100%)', 'linear-gradient(135deg, #fbc2eb 0%, #a6c1ee 100%)', 'linear-gradient(135deg, #84fab0 0%, #8fd3f4 100%)', 'linear-gradient(135deg, #f6d365 0%, #fda085 100%)' ];
        const buttonGradients = [ 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)','linear-gradient(135deg, #2af598 0%, #009efd 100%)', 'linear-gradient(135deg, #ff9a9e 0%, #fecfef 100%)','linear-gradient(135deg, #f6d365 0%, #fda085 100%)' ];
        function setRandomContainerGradient() { document.querySelector('.container').style.background = gradients[Math.floor(Math.random() * gradients.length)]; }
        function setRandomButtonGradients() { document.querySelectorAll('.action-btn').forEach(button => { button.style.background = buttonGradients[Math.floor(Math.random() * buttonGradients.length)]; }); }
        function setRandomIconGradients() { document.querySelectorAll('.icon-btn').forEach(icon => { icon.style.background = buttonGradients[Math.floor(Math.random() * buttonGradients.length)]; }); }
        
        // --- Вспомогательные функции ---
        function populateSelectWithOptions(selectElement, optionsArray) { if(!selectElement) return; selectElement.innerHTML = ''; optionsArray.forEach(system => { const option = document.createElement('option'); option.value = system.value; option.textContent = system.text; selectElement.appendChild(option); }); }
        function toggleCustomInput(selectElement, inputElement) { if(inputElement) inputElement.style.display = (selectElement.value === 'custom') ? 'block' : 'none'; }
        function swapTextareaColumns(textarea) { const text = textarea.value; if (!text) return; const isReadonly = textarea.readOnly; if (isReadonly) textarea.readOnly = false; const lines = text.split('\n'); const swappedLines = lines.map(line => { const parts = line.trim().split(/\s+/); if (parts.length === 2) return `${parts[1]}\t${parts[0]}`; return line; }); textarea.value = swappedLines.join('\n'); if (isReadonly) textarea.readOnly = true; }
        function vSwapTextarea(textarea) { const text = textarea.value; if (!text) return; const isReadonly = textarea.readOnly; if (isReadonly) textarea.readOnly = false; const lines = text.split('\n'); textarea.value = lines.reverse().join('\n'); if (isReadonly) textarea.readOnly = true; }
        function copyTextarea(textarea) { return navigator.clipboard.writeText(textarea.value).then(() => true).catch(() => false); }
        function getScValue(selectElement, inputElement) { const val = selectElement.value; if (val === 'custom') { const customVal = inputElement.value.trim(); return customVal.startsWith('+proj') ? customVal : `EPSG:${customVal}`; } return val; }
        function processPastedText(pastedText, targetTextarea) { let lines = pastedText.trim().split('\n'); if (lines.length > 0) { const firstLine = lines[0].trim(); if (!firstLine.includes('\t')) { const hasSingleComma = (firstLine.match(/,/g) || []).length === 1; const hasSingleSemicolon = (firstLine.match(/;/g) || []).length === 1; if (hasSingleComma || hasSingleSemicolon) { const separator = hasSingleComma ? ',' : ';'; lines = lines.map(line => line.includes(separator) ? line.replace(separator, '\t') : line); } } } let processedText = lines.join('\n').replace(/,/g, '.'); targetTextarea.value = processedText; }
        function separateContoursInTextarea(textarea) { const text = textarea.value; if (text.trim().length === 0) { showNotification('Поле ввода пустое'); return; } const lines = text.split('\n'); const processedLines = []; for (let i = 0; i < lines.length; i++) { processedLines.push(lines[i]); const currentLine = lines[i].trim(); if (currentLine === '') { continue; } const firstOccurrenceIndex = lines.findIndex(line => line.trim() === currentLine); const isClosingPoint = firstOccurrenceIndex < i; const isNotLastLine = i < lines.length - 1; if (isClosingPoint && isNotLastLine) { const nextLineIsAlreadySeparator = lines[i + 1].trim() === ''; if (!nextLineIsAlreadySeparator) { processedLines.push(''); } } } textarea.value = processedLines.join('\n'); showNotification('Координаты разделены на контуры'); }
        function showNotification(message) { const notification = document.getElementById('notification'); if (!notification) return; notification.textContent = message; notification.style.display = 'block'; setTimeout(() => { notification.style.display = 'none'; }, 2000); }
        function updateOffsetIndicator() { const offsetX = parseFloat(localStorage.getItem('offsetX')) || 0; const offsetY = parseFloat(localStorage.getItem('offsetY')) || 0; if (offsetX !== 0 || offsetY !== 0) { offsetIndicator.innerHTML = `Активно смещение: <span>X: ${offsetX.toFixed(3)} м, Y: ${offsetY.toFixed(3)} м</span>`; offsetIndicator.style.backgroundColor = ''; offsetIndicator.style.borderColor = ''; } else { offsetIndicator.innerHTML = `Смещение не настроено`; offsetIndicator.style.backgroundColor = 'rgba(252, 92, 125, 0.15)'; offsetIndicator.style.borderColor = 'rgba(252, 92, 125, 0.3)'; } offsetIndicator.style.display = 'block'; }
        function updateSourceOffsetIndicator() { const selectedSystem = COORDINATE_SYSTEMS.find(s => s.value === sourceScSelect.value); const offsetX = (selectedSystem && selectedSystem.offsetX) || 0; const offsetY = (selectedSystem && selectedSystem.offsetY) || 0; if (offsetX !== 0 || offsetY !== 0) { sourceOffsetIndicator.innerHTML = `Применено смещение: <span>X: ${offsetX.toFixed(3)} м, Y: ${offsetY.toFixed(3)} м</span>`; sourceOffsetIndicator.style.display = 'block'; } else { sourceOffsetIndicator.style.display = 'none'; } }
        function copyAndOpen(textarea, url) { const textToCopy = textarea.value; if (textToCopy.trim() === '') { window.open(url, '_blank'); return; } navigator.clipboard.writeText(textToCopy).catch(err => console.error('Ошибка копирования: ', err)).finally(() => window.open(url, '_blank')); }
        function setModalState(state) { if (state === 'initial') { modalInitialView.style.display = 'block'; modalResultsView.style.display = 'none'; modalPrimaryBtn.textContent = 'Рассчитать по данным'; modalSecondaryBtn.textContent = 'Сбросить'; modalSecondaryBtn.style.backgroundColor = '#e74c3c'; calculatedOffset = null; } else if (state === 'results') { modalInitialView.style.display = 'none'; modalResultsView.style.display = 'block'; modalPrimaryBtn.textContent = 'Применить среднее'; modalSecondaryBtn.textContent = 'Назад'; modalSecondaryBtn.style.backgroundColor = '#2ecc71'; } }
        function normalizeDecimal(inputElement) { inputElement.value = inputElement.value.replace(',', '.'); }
        function openOffsetModal() { setModalState('initial'); offsetXInput.value = (localStorage.getItem('offsetX') || '0').replace('.', ','); offsetYInput.value = (localStorage.getItem('offsetY') || '0').replace('.', ','); modalOverlay.style.display = 'block'; offsetModal.style.display = 'block'; }
        function closeOffsetModal() { normalizeDecimal(offsetXInput); normalizeDecimal(offsetYInput); localStorage.setItem('offsetX', offsetXInput.value || '0'); localStorage.setItem('offsetY', offsetYInput.value || '0'); modalOverlay.style.display = 'none'; offsetModal.style.display = 'none'; updateOffsetIndicator(); }
        function resetOffset() { if (confirm("Вы уверены, что хотите сбросить смещение до 0?")) { offsetXInput.value = '0'; offsetYInput.value = '0'; localStorage.setItem('offsetX', '0'); localStorage.setItem('offsetY', '0'); updateOffsetIndicator(); alert("Смещение сброшено."); destScSelect.dispatchEvent(new Event('change')); } }
        function calculateAndDisplayOffsets() { const sourceLines = sourceTextArea.value.trim().split('\n').filter(line => line.trim() !== ''); const resultLines = resultArea.value.trim().split('\n').filter(line => line.trim() !== ''); if (sourceLines.length === 0 || resultLines.length === 0) { alert("Ошибка: для расчета смещения оба поля должны быть заполнены."); return; } if (sourceLines.length !== resultLines.length) { alert(`Ошибка: количество строк не совпадает!\nИсходные: ${sourceLines.length}, Результат: ${resultLines.length}.`); return; } let deltas = [], sumDeltaX = 0, sumDeltaY = 0; for (let i = 0; i < sourceLines.length; i++) { const sourceParts = sourceLines[i].trim().split(/\s+/); const resultParts = resultLines[i].trim().split(/\s+/); if (sourceParts.length !== 2 || resultParts.length !== 2) continue; const sourceX = parseFloat(sourceParts[0]); const sourceY = parseFloat(sourceParts[1]); const resultX = parseFloat(resultParts[0]); const resultY = parseFloat(resultParts[1]); if (isNaN(sourceX) || isNaN(sourceY) || isNaN(resultX) || isNaN(resultY)) continue; const deltaX = resultX - sourceX; const deltaY = resultY - sourceY; sumDeltaX += deltaX; sumDeltaY += deltaY; deltas.push({ index: i + 1, deltaX, deltaY }); } if (deltas.length === 0) { alert("Не удалось найти ни одной корректной пары координат для расчета."); return; } const avgDeltaX = sumDeltaX / deltas.length; const avgDeltaY = sumDeltaY / deltas.length; calculatedOffset = { x: avgDeltaX, y: avgDeltaY }; let tableHTML = `<table><thead><tr><th>№</th><th>ΔX (м)</th><th>ΔY (м)</th></tr></thead><tbody>`; deltas.forEach(d => { const dxClass = d.deltaX > 0 ? 'delta-pos' : (d.deltaX < 0 ? 'delta-neg' : ''); const dyClass = d.deltaY > 0 ? 'delta-pos' : (d.deltaY < 0 ? 'delta-neg' : ''); tableHTML += `<tr><td>${d.index}</td><td class="${dxClass}">${d.deltaX.toFixed(3)}</td><td class="${dyClass}">${d.deltaY.toFixed(3)}</td></tr>`; }); tableHTML += `</tbody></table><div class="modal-summary">Среднее смещение: ΔX= ${avgDeltaX.toFixed(3)} м, ΔY= ${avgDeltaY.toFixed(3)} м</div>`; modalResultsView.innerHTML = tableHTML; setModalState('results'); }
        
        // --- Новые и измененные функции ---

        function isCadastralList(text) {
            if (!text) return false;
            const firstLine = text.trim().split('\n')[0].trim();
            const knRegex = /^\d{2}:\d{2}:\d{6,7}:\d+$/;
            return knRegex.test(firstLine);
        }
        
        async function fetchNspd(url) {
            const requestHeaders = { 'Referer': 'https://nspd.gov.ru/' };
            try {
                const directResponse = await fetch(url, { headers: requestHeaders });
                if (!directResponse.ok) throw new Error(`Прямой запрос не удался со статусом: ${directResponse.status}`);
                return await directResponse.json();
            } catch (error) {
                console.warn(`Прямой запрос не удался: ${error.message}. Переключаюсь на прокси.`);
                const vercelProxyUrl = 'https://nsp-two.vercel.app/';
                const urlObject = new URL(url);
                const targetPath = `${urlObject.pathname}${urlObject.search}`;
                const proxyRequestUrl = `${vercelProxyUrl}?target=${encodeURIComponent(targetPath)}`;
                const proxyResponse = await fetch(proxyRequestUrl, { headers: requestHeaders });
                if (!proxyResponse.ok) {
                    const errorText = await proxyResponse.text();
                    throw new Error(`Запрос через прокси также не удался: ${proxyResponse.statusText}. Ответ сервера: ${errorText}`);
                }
                return await proxyResponse.json();
            }
        }

        async function fetchCadastralData(cadastralNumber) {
            const url = `https://nspd.gov.ru/api/geoportal/v2/search/geoportal?thematicSearchId=1&query=${cadastralNumber}`;
            const data = await fetchNspd(url);
            if (!data.data || !data.data.features || data.data.features.length === 0) {
                throw new Error(`Объект с КН ${cadastralNumber} не найден в ЕГРН.`);
            }
            return data.data.features[0];
        }

        async function performLocalConversion(sourceText, sourceSc, destSc) {
            resultArea.value = 'Локальная обработка координат...';
            try {
                const sourceDefObj = COORDINATE_SYSTEMS.find(s => s.value === sourceSc);
                const destDefObj = COORDINATE_SYSTEMS.find(s => s.value === destSc);
                if (sourceDefObj && sourceDefObj.def) proj4.defs(sourceSc, sourceDefObj.def);
                if (destDefObj && destDefObj.def) proj4.defs(destSc, destDefObj.def);

                const sourceSystem = COORDINATE_SYSTEMS.find(s => s.value === sourceSc);
                const sourceOffsetX = (sourceSystem && sourceSystem.offsetX) || 0;
                const sourceOffsetY = (sourceSystem && sourceSystem.offsetY) || 0;
                const destOffsetX = parseFloat((localStorage.getItem('offsetX') || '0').replace(',', '.')) || 0;
                const destOffsetY = parseFloat((localStorage.getItem('offsetY') || '0').replace(',', '.')) || 0;
                const lines = sourceText.split('\n');
                let results = [];
                const decimalPlaces = (destSc === 'EPSG:3857') ? 4 : 2;
                
                for(const line of lines) {
                    if (line.trim() === '') { results.push(''); continue; }
                    const parts = line.trim().split(/\s+/);
                    if (parts.length === 2) {
                        const x = parseFloat(parts[0]);
                        const y = parseFloat(parts[1]);
                        if (!isNaN(x) && !isNaN(y)) {
                            try {
                                const x_adj = x - sourceOffsetX;
                                const y_adj = y - sourceOffsetY;
                                const convertedPoint = proj4(sourceSc, destSc, [x_adj, y_adj]);
                                
                                let pureFinalX, pureFinalY;
                                
                                if (sourceSc === 'EPSG:3857' && destSc !== 'EPSG:3857' && destSc !== 'EPSG:4326') {
                                    pureFinalX = convertedPoint[1];
                                    pureFinalY = convertedPoint[0];
                                } else {
                                    pureFinalX = convertedPoint[0];
                                    pureFinalY = convertedPoint[1];
                                }
                                
                                const finalX = pureFinalX + destOffsetX;
                                const finalY = pureFinalY + destOffsetY;

                                results.push(`${finalX.toFixed(decimalPlaces)}\t${finalY.toFixed(decimalPlaces)}`);
                            } catch (e) { results.push(`Ошибка конвертации: ${e.message}`); }
                        } else { results.push("Ошибка: некорректные данные в строке"); }
                    } else { results.push("Ошибка: строка должна содержать 2 координаты"); }
                }
                resultArea.value = results.join('\n');
            } catch (error) {
                resultArea.value = `Произошла ошибка локальной конвертации: ${error.message}`;
                resultArea.classList.add('error');
            }
        }
        
        async function handleCadastralNumberConversion() {
            const kns = sourceTextArea.value.trim().split('\n').filter(kn => kn.trim() !== '');
            if (kns.length > 100) {
                showNotification("Превышен лимит в 100 кадастровых номеров.");
                return;
            }

            isConversionInProgress = true;
            convertBtn.disabled = true;
            resultArea.value = '';
            progressBarContainer.style.display = 'block';

            sourceScSelect.value = "EPSG:3857";
            sourceScSelect.dispatchEvent(new Event('change'));
            
            const destScId = getScValue(destScSelect, destScInput);
            const destSystem = COORDINATE_SYSTEMS.find(s => s.value === destScId);
            if (!destSystem || !destSystem.def) {
                showNotification(`Не найдено определение для целевой СК: ${destScId}`);
                isConversionInProgress = false;
                convertBtn.disabled = false;
                progressBarContainer.style.display = 'none';
                return;
            }
            proj4.defs(destSystem.value, destSystem.def);
            proj4.defs("EPSG:3857", COORDINATE_SYSTEMS.find(s => s.value === "EPSG:3857").def);
            proj4.defs("EPSG:4326", COORDINATE_SYSTEMS.find(s => s.value === "EPSG:4326").def);

            const allResults = [];
            const destOffsetX = parseFloat((localStorage.getItem('offsetX') || '0').replace(',', '.')) || 0;
            const destOffsetY = parseFloat((localStorage.getItem('offsetY') || '0').replace(',', '.')) || 0;
            const decimalPlaces = (destScId === 'EPSG:3857') ? 4 : 2;

            for (let i = 0; i < kns.length; i++) {
                const kn = kns[i].trim();
                const progress = ((i + 1) / kns.length) * 100;
                progressBarFill.style.width = `${progress}%`;
                progressBarLabel.textContent = `Обработка: ${i + 1} из ${kns.length} (${kn})`;

                try {
                    const feature = await fetchCadastralData(kn);
                    if (!feature.geometry || !feature.geometry.coordinates) {
                        throw new Error('У объекта отсутствуют координаты в ЕГРН.');
                    }
                    
                    const allContoursText = [];
                    const geometryType = feature.geometry.type;
                    const polygonsData = geometryType === 'MultiPolygon' ? feature.geometry.coordinates : [feature.geometry.coordinates];

                    polygonsData.forEach(polygonRings => {
                        const contourCoordsText = [];
                        polygonRings.forEach(ring => {
                            const mskCoords = ring.map(coord_3857 => {
                                const wgs84 = proj4('EPSG:3857', 'EPSG:4326', coord_3857);
                                const msk = proj4('EPSG:4326', destSystem.value, wgs84);
                                const finalX = msk[1] + destOffsetX;
                                const finalY = msk[0] + destOffsetY;
                                return `${finalX.toFixed(decimalPlaces)}\t${finalY.toFixed(decimalPlaces)}`;
                            });
                            contourCoordsText.push(mskCoords.join('\n'));
                        });
                        allContoursText.push(contourCoordsText.join('\n\n'));
                    });
                    allResults.push(allContoursText.join('\n\n'));

                } catch (error) {
                    console.error(`Ошибка для КН ${kn}:`, error);
                    allResults.push(`--- Ошибка для ${kn}: ${error.message} ---`);
                }

                if (i < kns.length - 1) {
                    await new Promise(resolve => setTimeout(resolve, 1000));
                }
            }

            resultArea.value = allResults.join('\n\n');
            isConversionInProgress = false;
            convertBtn.disabled = false;
            progressBarContainer.style.display = 'none';
            showNotification(`Обработка ${kns.length} КН завершена.`);
        }

        async function performConversion() {
            if (isConversionInProgress) return;
            
            const sourceText = sourceTextArea.value.trim();
            if (!sourceText) {
                showNotification("Исходное поле пусто.");
                return;
            }
            
            if (isCadastralList(sourceText)) {
                await handleCadastralNumberConversion();
            } else {
                const sourceSc = getScValue(sourceScSelect, sourceScInput);
                const destSc = getScValue(destScSelect, destScInput);
                if (!sourceSc || !destSc) {
                    resultArea.value = 'Ошибка: Выберите исходную и целевую системы координат.';
                    resultArea.classList.add('error');
                    return;
                }
                resultArea.classList.remove('error');
                await performLocalConversion(sourceText, sourceSc, destSc);
            }
        }
        
        function saveLastUsedMsk(selectedValue) {
            if (selectedValue && selectedValue.startsWith('EPSG:') && selectedValue !== 'EPSG:3857' && selectedValue !== 'EPSG:4326') {
                localStorage.setItem('lastUsedMSK', selectedValue);
            }
        }

        async function checkClipboardAndPasteOnLoad() { 
            try { 
                const text = await navigator.clipboard.readText(); 
                if (!text) return; 
                
                if (isCadastralList(text)) {
                    sourceTextArea.value = text.trim();
                    return;
                }

                const lines = text.trim().split('\n'); 
                if (lines.length < 2) return; 
                const isValid = lines.every(line => { const trimmedLine = line.trim(); if (trimmedLine === '') return true; if (/[a-zA-Zа-яА-Я]/.test(trimmedLine)) return false; return (trimmedLine.match(/[\t,;]/g) || []).length === 1; }); 
                
                if (isValid) { 
                    processPastedText(text, sourceTextArea); 
                    
                    const firstLineProcessed = sourceTextArea.value.split('\n')[0].trim();
                    const parts = firstLineProcessed.split(/\s+/);

                    if (parts.length === 2) {
                        const lastUsedMsk = localStorage.getItem('lastUsedMSK') || 'EPSG:6331602';
                        const hasLongDecimal = (coord) => (coord.includes('.') && coord.split('.')[1].length > 3);
                        
                        if (hasLongDecimal(parts[0]) || hasLongDecimal(parts[1])) {
                            sourceScSelect.value = 'EPSG:3857';
                            destScSelect.value = lastUsedMsk;
                        } else {
                            sourceScSelect.value = lastUsedMsk;
                            destScSelect.value = 'EPSG:3857';
                        }
                        
                        localStorage.setItem('savedSourceSC', sourceScSelect.value);
                        localStorage.setItem('savedDestSC', destScSelect.value);
                        
                        sourceScSelect.dispatchEvent(new Event('change'));
                        destScSelect.dispatchEvent(new Event('change'));
                    }
                } 
            } catch (err) { 
                console.log('Не удалось прочитать буфер обмена:', err.name, err.message); 
            } 
        }

        // --- Назначение всех обработчиков событий ---
        convertBtn.addEventListener('click', performConversion);
        offsetBtn.addEventListener('click', openOffsetModal);
        closeModalBtn.addEventListener('click', closeOffsetModal);
        modalOverlay.addEventListener('click', closeOffsetModal);
        modalPrimaryBtn.addEventListener('click', () => { if (modalInitialView.style.display === 'block') { calculateAndDisplayOffsets(); } else { if (calculatedOffset) { offsetXInput.value = calculatedOffset.x.toFixed(3); offsetYInput.value = calculatedOffset.y.toFixed(3); closeOffsetModal(); } } });
        modalSecondaryBtn.addEventListener('click', () => { if (modalInitialView.style.display === 'block') { resetOffset(); } else { setModalState('initial'); } });

        sourceScSelect.addEventListener('change', () => { 
            toggleCustomInput(sourceScSelect, sourceScInput); 
            localStorage.setItem('savedSourceSC', sourceScSelect.value);
            saveLastUsedMsk(sourceScSelect.value);
            updateSourceOffsetIndicator();
        });

        destScSelect.addEventListener('change', () => {
            toggleCustomInput(destScSelect, destScInput);
            localStorage.setItem('savedDestSC', destScSelect.value);
            saveLastUsedMsk(destScSelect.value);
            
            if (!autoLoadOffsetSwitch.checked) { return; }
            const selectedSystem = COORDINATE_SYSTEMS.find(s => s.value === destScSelect.value);
            let newOffsetX = 0;
            let newOffsetY = 0;
            if (selectedSystem && (selectedSystem.hasOwnProperty('offsetX') || selectedSystem.hasOwnProperty('offsetY'))) {
                newOffsetX = selectedSystem.offsetX || 0;
                newOffsetY = selectedSystem.offsetY || 0;
            }
            localStorage.setItem('offsetX', newOffsetX);
            localStorage.setItem('offsetY', newOffsetY);
            offsetXInput.value = String(newOffsetX).replace('.', ',');
            offsetYInput.value = String(newOffsetY).replace('.', ',');
            updateOffsetIndicator();
        });
        
        swapSourceBtn.addEventListener('click', () => swapTextareaColumns(sourceTextArea));
        copySourceBtn.addEventListener('click', () => copyTextarea(sourceTextArea).then(s => s && copySourceBtn.classList.add('rotate-copy', setTimeout(() => copySourceBtn.classList.remove('rotate-copy'), 300))));
        vSwapSourceBtn.addEventListener('click', () => { vSwapTextarea(sourceTextArea); vSwapSourceBtn.classList.add('rotate-vertical', setTimeout(() => vSwapSourceBtn.classList.remove('rotate-vertical'), 300)); });
        swapResultBtn.addEventListener('click', () => swapTextareaColumns(resultArea));
        copyResultBtn.addEventListener('click', () => copyTextarea(resultArea).then(s => s && copyResultBtn.classList.add('rotate-copy', setTimeout(() => copyResultBtn.classList.remove('rotate-copy'), 300))));
        vSwapResultBtn.addEventListener('click', () => { vSwapTextarea(resultArea); vSwapResultBtn.classList.add('rotate-vertical', setTimeout(() => vSwapResultBtn.classList.remove('rotate-vertical'), 300)); });
        saveFileBtn.addEventListener('click', () => copyAndOpen(resultArea, 'схема.html'));
        saveXmlBtn.addEventListener('click', () => copyAndOpen(resultArea, 'схема_xml.html'));
        showOnMapBtn.addEventListener('click', () => copyAndOpen(resultArea, 'map.html'));
        openEditorBtn.addEventListener('click', () => copyAndOpen(resultArea, 'editor.html'));
        sourceTextArea.addEventListener('paste', (e) => { e.preventDefault(); processPastedText((e.clipboardData || window.clipboardData).getData('text'), sourceTextArea); });
        resultArea.addEventListener('paste', (e) => { e.preventDefault(); processPastedText((e.clipboardData || window.clipboardData).getData('text'), resultArea); });
        conversionModeSwitch.addEventListener('change', () => { localStorage.setItem('conversionMode', conversionModeSwitch.checked ? 'local' : 'api'); });
        autoLoadOffsetSwitch.addEventListener('change', () => { localStorage.setItem('autoLoadOffset', autoLoadOffsetSwitch.checked); if (autoLoadOffsetSwitch.checked) { destScSelect.dispatchEvent(new Event('change')); } });

        // --- Инициализация при загрузке страницы ---
        function initializeApp() {
            setRandomContainerGradient(); setRandomButtonGradients(); setRandomIconGradients();
            if (typeof COORDINATE_SYSTEMS !== 'undefined') { populateSelectWithOptions(sourceScSelect, COORDINATE_SYSTEMS); populateSelectWithOptions(destScSelect, COORDINATE_SYSTEMS); } else { console.error("Файл sk.js не загружен"); alert("Не удалось загрузить список систем координат."); }
            
            const lastUsedMsk = localStorage.getItem('lastUsedMSK') || 'EPSG:6331602';
            
            sourceScSelect.value = localStorage.getItem('savedSourceSC') || 'EPSG:3857';
            destScSelect.value = localStorage.getItem('savedDestSC') || lastUsedMsk;
          
            if (sourceScSelect.value === destScSelect.value) {
                if (sourceScSelect.value === 'EPSG:3857') {
                    destScSelect.value = lastUsedMsk;
                } else {
                    destScSelect.value = 'EPSG:3857';
                }
            }

            toggleCustomInput(sourceScSelect, sourceScInput);
            toggleCustomInput(destScSelect, destScInput);
            
            conversionModeSwitch.checked = true; // Принудительно локальный режим
            autoLoadOffsetSwitch.checked = (localStorage.getItem('autoLoadOffset') !== 'false');
            
            sourceScSelect.dispatchEvent(new Event('change'));
            destScSelect.dispatchEvent(new Event('change'));
            
               if (separateContoursSourceBtn) {
                separateContoursSourceBtn.addEventListener('click', () => separateContoursInTextarea(sourceTextArea));
            }
            if (separateContoursResultBtn) {
                separateContoursResultBtn.addEventListener('click', () => separateContoursInTextarea(resultArea));
            }
            
            updateSourceOffsetIndicator();
            updateOffsetIndicator();
            checkClipboardAndPasteOnLoad();
        }
        initializeApp();
    </script>

</body>
</html>