<!DOCTYPE html>
<html lang="ru">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Карта</title>

    <link id="favicon" rel="icon" href="img/map.png"   type="image/png">

   <link rel="stylesheet" href="webfonts/all.min.css" />
    <script src="webfonts/proj4.js"></script>
       <script src="webfonts/xlsx.full.min.js"></script>
       <script src="webfonts/jszip.min.js"></script>
       <script src="webfonts/html2canvas.min.js"></script>
<script src="webfonts/FileSaver.min.js"></script>
    <script src="webfonts/supabase-js@2.js"></script>
 <style>
    body {
        margin: 0;
        overflow: hidden;
        font-family: sans-serif;
        display: flex;
        height: 100vh;
    }

    #map {
        flex-grow: 1;
        z-index: 1;
        transition: opacity 0.5s ease;
        border: 3px solid rgba(110, 142, 251, 0.8);
        border-radius: 12px;
        overflow: hidden;
        box-sizing: border-box;
        box-shadow: 0 0 10px rgba(110, 142, 251, 0.5);
        min-height: 200px;
        position: relative;
        cursor: default !important;
    }

    /* Enhanced widget appearance */
    .widget {
        background: linear-gradient(135deg, #3B82F6, #60A5FA, #1E3A8A);
        padding: 12px;
        box-shadow: 0 6px 20px rgba(0, 0, 0, 0.2), 0 0 25px rgba(59, 130, 246, 0.3);
        color: #F9FAFB;
        z-index: 10;
        display: flex;
        flex-direction: column;
        border-radius: 12px;
        transition: transform 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275), 
                    opacity 0.3s ease, 
                    box-shadow 0.4s ease;
        box-sizing: border-box;
        max-height: 90vh;
        width: 350px;
        cursor: default; /* Обычный курсор по умолчанию */
        border: 2px solid rgba(96, 165, 250, 0.8);
        backdrop-filter: blur(5px);
        animation: widgetAppear 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards;
    }

    .widget:hover {
        box-shadow: 0 12px 24px rgba(0, 0, 0, 0.25), 0 0 30px rgba(59, 130, 246, 0.4);
        transform: translateY(-4px) scale(1.02);
    }

    .widget.hidden {
        opacity: 0;
    }

    .widget-desktop,
    .widget-mobile {
        position: absolute;
        left: 10px;
        top: 10px;
        border-radius: 15px;
    }

    /* Enhanced city input */
    .input-container {
        position: relative;
        width: 100%;
        margin-top: 8px;
    }

    #city-input {
        margin-top: 0;
        padding: 8px 30px;
        border: 1px solid rgba(255, 255, 255, 0.25);
        border-radius: 10px;
        width: calc(100% - 60px);
        text-align: center;
        color: #1E3A8A;
        background-color: rgba(255, 255, 255, 0.95);
        font-size: 0.9rem;
        outline: none;
        transition: all 0.3s ease;
        box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.05), 0 0 5px rgba(96, 165, 250, 0.2);
    }

    #city-input::placeholder {
        color: #666;
    }

    #city-input:focus {
        border-color: #60A5FA;
        box-shadow: 0 0 10px rgba(96, 165, 250, 0.5), inset 0 1px 5px rgba(0, 0, 0, 0.05);
        transform: translateY(-2px);
    }

    /* Make city-name-display non-selectable like an image */
    .city-name {
        font-size: 1.1rem;
        color: #F9FAFB;
        font-weight: 600;
        text-decoration: none;
        word-wrap: break-word;
        white-space: normal;
        line-height: 1.3;
        text-align: center;
        text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        user-select: none;
        -webkit-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
        cursor: default; /* Обычный курсор по умолчанию */
        position: relative;
        padding: 5px 0;
        transition: color 0.3s ease, text-shadow 0.3s ease;
    }

    .city-name::after {
        content: '';
        position: absolute;
        bottom: 0;
        left: 50%;
        width: 0;
        height: 2px;
        background: rgba(255, 255, 255, 0.7);
        transition: width 0.3s ease, left 0.3s ease;
    }

    .city-name:hover {
        color: #ffffff;
        text-shadow: 0 2px 8px rgba(255, 255, 255, 0.5);
    }

    .city-name:hover::after {
        width: 80%;
        left: 10%;
    }

    /* Enhanced date-time */
    .date-time {
        margin: 8px 0;
        font-size: 0.9rem;
        font-weight: 500;
        text-align: center;
        text-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);
        position: relative;
        overflow: hidden;
        transition: all 0.3s ease;
    }

    .date-time::before {
        content: '';
        position: absolute;
        left: 0;
        bottom: -2px;
        width: 100%;
        height: 1px;
        background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.5), transparent);
        transform: translateX(-100%);
        transition: transform 0.5s ease;
    }

    .widget:hover .date-time::before {
        transform: translateX(100%);
    }

    .map-mode-switcher {
        margin-top: auto;
        padding-top: 5px;
        display: flex;
        gap: 3px;
        justify-content: center;
        width: 100%;
        flex-wrap: wrap;
    }

    /* Enhanced buttons */
    .map-mode-button, .convert-button, #add-text-button {
        padding: 6px;
        border: none;
        border-radius: 50%;
        background-color: rgba(255, 255, 255, 0.15);
        color: #F9FAFB;
        font-size: 0.9rem;
        cursor: pointer;
        transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        display: flex;
        align-items: center;
        justify-content: center;
        width: 32px;
        height: 32px;
        position: relative;
        overflow: hidden;
    }

    .map-mode-button::before, .convert-button::before, #add-text-button::before {
        content: '';
        position: absolute;
        top: 50%;
        left: 50%;
        width: 0;
        height: 0;
        background-color: rgba(255, 255, 255, 0.2);
        border-radius: 50%;
        transform: translate(-50%, -50%);
        transition: width 0.4s ease, height 0.4s ease;
    }

    .map-mode-button:hover, .convert-button:hover, #add-text-button:hover {
        background-color: rgba(255, 255, 255, 0.25);
        transform: scale(1.2) rotate(5deg);
        box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2), 0 0 15px rgba(96, 165, 250, 0.4);
    }

    .map-mode-button:hover::before, .convert-button:hover::before, #add-text-button:hover::before {
        width: 150%;
        height: 150%;
    }


    .map-mode-button i, .convert-button i, #add-text-button i {
        position: relative;
        z-index: 2;
        transition: all 0.3s ease;
    }

    .map-mode-button:hover i, .convert-button:hover i, #add-text-button:hover i {
        transform: scale(1.2);
        color: #ffffff;
        text-shadow: 0 0 10px rgba(255, 255, 255, 0.7);
    }

    .coords-input,
    .result-textarea {
        margin-top: 3px;
        width: calc(100% - 12px);
        height: 50px;
        padding: 5px;
        border: 1px solid rgba(255, 255, 255, 0.3);
        border-radius: 4px;
        background-color: rgba(255, 255, 255, 0.9);
        color: #333;
        font-family: monospace;
        resize: none;
        white-space: pre;
        overflow-x: auto;
        display: none;
        font-size: 0.8rem;
    }

    .coords-input::placeholder {
        color: #666;
    }

    .convert-buttons {
        margin-top: 3px;
        display: flex;
        gap: 3px;
        justify-content: center;
    }

    .style-modal {
        display: none;
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        z-index: 1000;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.5);
        overflow: auto;
    }

    .style-modal-content {
        background: linear-gradient(135deg, #7f7fd5, #86a8e7, #2D68C4);
        margin: 20px auto;
        padding: 15px;
        border-radius: 8px;
        width: 90%;
        max-width: 300px;
        color: white;
        position: relative;
    }

    .style-setting {
        margin: 8px 0;
        display: flex;
        align-items: center;
        gap: 3px;
    }

    .style-setting label {
        font-size: 0.8rem;
    }

    .style-setting input[type="color"] {
        width: 30px;
        height: 20px;
        border: none;
        border-radius: 4px;
    }

    .style-setting input[type="range"] {
        flex: 1;
    }

    .convert-button i {
        margin-right: 3px;
    }

    .custom-context-menu {
        position: absolute;
        background: white;
        border-radius: 8px;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
        padding: 5px 0;
        min-width: 150px;
        z-index: 1000;
        display: none;
    }

    .custom-context-menu-item {
        padding: 8px 15px;
        cursor: pointer;
        transition: background-color 0.2s;
        color: #333;
        font-size: 14px;
        display: flex;
        align-items: center;
        position: relative;
    }

    .custom-context-menu-item i {
        margin-right: 8px;
        color: #4a6cf7;
    }

    .custom-context-menu-item:hover {
        background-color: #f0f0f0;
    }

    .custom-context-submenu {
        display: none;
        position: absolute;
        left: 100%;
        top: 0;
        background: white;
        border-radius: 8px;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
        padding: 5px 0;
        min-width: 150px;
    }

    .custom-context-menu-item:hover > .custom-context-submenu {
        display: block;
    }

    .notification {
        position: fixed;
        bottom: 20px;
        right: 20px;
        padding: 15px 25px;
        color: white;
        border-radius: 8px;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        opacity: 0;
        transform: translateY(20px);
        transition: opacity 0.3s, transform 0.3s;
        z-index: 9999;
        font-size: 14px;
        display: flex;
        align-items: center;
        gap: 10px;
    }

    .notification.success {
        background: linear-gradient(135deg, #43cea2, #185a9d);
    }

    .notification.error {
        background: linear-gradient(135deg, #ff6b6b, #ff3d3d);
    }
    
      .notification.info {
        background: linear-gradient(135deg, #3a7bd5, #00d2ff);
    }

    .notification.show {
        opacity: 1;
        transform: translateY(0);
    }

    .notification i {
        font-size: 16px;
    }

    @media (max-width: 768px) {
        body {
            flex-direction: column;
        }

        .widget {
            width: 230px;
        }

        .widget-desktop,
        .widget-mobile {
            position: absolute;
            width: 230px;
        }

        .style-modal-content {
            margin: 30% auto;
        }
    }

    @media (min-width: 769px) {
        body {
            flex-direction: row;
        }

        #map {
            flex-grow: 1;
        }
    }

    .hidden {
        transform: translateY(100%);
        opacity: 0;
        transition: transform 0.3s ease, opacity 0.3s ease;
    }

    .widget-mobile.hidden {
        transform: translateY(100%);
        opacity: 0;
    }

    .widget-desktop.hidden {
        transform: translateX(-100%);
        opacity: 0;
    }

    .draggable-text {
        position: absolute;
        z-index: 1000;
        background-color: rgba(255, 255, 255, 0.9);
        padding: 5px;
        border: 1px solid #ccc;
        border-radius: 2px;
        cursor: move;
        user-select: none;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    }

    .draggable-text span {
        font-size: 16px;
    }

    .draggable-text button {
        margin-left: 5px;
        padding: 2px 5px;
        font-size: 12px;
        cursor: pointer;
        display: none;
    }

    .draggable-text.active button {
        display: inline-block;
    }

    .search-icon, .history-icon {
        position: absolute;
        top: 50%;
        transform: translateY(-50%);
        width: 20px;
        height: 20px;
        cursor: pointer;
        opacity: 0.7;
        transition: all 0.3s ease;
        z-index: 11;
    }

    .search-icon {
        right: 8px;
    }

    .history-icon {
        left: 8px;
    }

    .search-icon:hover, .history-icon:hover {
        opacity: 1;
        transform: translateY(-50%) scale(1.2);
        filter: drop-shadow(0 0 3px rgba(255, 255, 255, 0.5));
    }

    .widget i {
        transition: color 0.3s ease, transform 0.2s ease;
    }

    .widget i:hover {
        transform: scale(1.1);
    }

    .widget .city-name,
    .widget .date-time {
        transition: color 0.3s ease;
    }

    #history-modal {
        display: none;
        position: absolute;
        top: 45px;
        left: 10px;
        background: linear-gradient(135deg, #7f7fd5, #86a8e7, #2D68C4);
        border-radius: 8px;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
        padding: 10px;
        z-index: 1001;
        max-height: 200px;
        overflow-y: auto;
        width: calc(100% - 20px);
    }

    .history-item {
        padding: 8px;
        cursor: pointer;
        transition: background-color 0.2s;
        color: white;
        border-bottom: 1px solid rgba(255, 255, 255, 0.2);
        font-size: 0.8rem;
        display: flex;
        align-items: center;
        justify-content: space-between;
    }

    .history-item:last-child {
        border-bottom: none;
    }

    .history-item:hover {
        background-color: rgba(255, 255, 255, 0.2);
    }

.loader-container {
position: fixed;
top: 0;
left: 0;
width: 100%;
height: 100%;
background-color: rgba(0, 0, 0, 0.5);
display: none;
justify-content: center;
align-items: center;
z-index: 10002; /* <-- ИЗМЕНЕНО ЗНАЧЕНИЕ (было 10000) */
backdrop-filter: blur(3px);
flex-direction: column;
}

    .loader {
        /* Adjust styling as necessary to position the spinner and text */
        position: relative; /* Add this line */
        display: flex; /* Add this line */
        flex-direction: column; /* Add this line */
        align-items: center; /* Add this line */
        justify-content: center; /* Add this line */
    }

    .spinner-container {
        width: 80px;
        height: 80px;
        position: relative;
    }

    .spinner-ring {
        position: absolute;
        width: 100%;
        height: 100%;
        border-radius: 50%;
        border: 6px solid transparent;
        border-top-color: #3498db;
        animation: spin 1.2s cubic-bezier(0.5, 0, 0.5, 1) infinite;
        box-sizing: border-box;
    }

    .spinner-ring:before,
    .spinner-ring:after {
        content: '';
        position: absolute;
        border-radius: 50%;
        border: 6px solid transparent;
        box-sizing: border-box;
    }

    .spinner-ring:before {
        top: -6px;
        left: -6px;
        right: -6px;
        bottom: -6px;
        border-top-color: #2980b9;
        animation: spin 2s cubic-bezier(0.5, 0, 0.5, 1) infinite;
    }

    .spinner-ring:after {
        top: 6px;
        left: 6px;
        right: 6px;
        bottom: 6px;
        border-top-color: #6ab7e2;
        animation: spin 0.8s cubic-bezier(0.5, 0, 0.5, 1) infinite;
    }

    @keyframes spin {
        0% {
            transform: rotate(0deg);
        }

        100% {
            transform: rotate(360deg);
        }
    }

    .loading-text {
        color: #2c3e50;
        font-size: 18px;
        font-weight: bold;
        margin-top: 30px;
        letter-spacing: 1px;
        text-shadow: 0 1px 2px rgba(255, 255, 255, 0.5);
        animation: pulse 1.5s ease infinite;
    }

    @keyframes pulse {
        0%,
        100% {
            opacity: 0.7;
        }

        50% {
            opacity: 1;
        }
    }

    .circular {
        animation: rotate 2s linear infinite;
        height: 100%;
        transform-origin: center center;
        width: 100%;
        position: absolute;
        top: 0;
        bottom: 0;
        left: 0;
        right: 0;
        margin: auto;
    }

    .path {
        stroke-dasharray: 150,200; /* Adjust as needed */
        stroke-dashoffset: -10;  /* Adjust as needed */
        stroke: #3498db;
        stroke-linecap: round;
        animation: dash 1.5s ease-in-out infinite;
    }

    @keyframes rotate {
        100% {
            transform: rotate(360deg);
        }
    }

    @keyframes dash {
        0% {
            stroke-dasharray: 1,200;
            stroke-dashoffset: 0;
        }

        50% {
            stroke-dasharray: 90,200;
            stroke-dashoffset: -35px;
        }

        100% {
            stroke-dashoffset: -125px;
        }
    }

    .notification.warning {
        background: linear-gradient(135deg, #ffc107, #ff9800);
    }

    .color-modal {
        display: none;
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: linear-gradient(135deg, #ffffff, #f0f0f0);
        padding: 25px;
        border-radius: 15px;
        box-shadow: 0 8px 16px rgba(0, 0, 0, 0.2);
        z-index: 10000;
        width: 350px;
        text-align: center;
        font-family: sans-serif;
        overflow: hidden;
    }

    .color-modal-content {
        display: flex;
        flex-direction: column;
        gap: 20px;
        align-items: center;
    }

    .color-modal h3 {
        margin: 0;
        font-size: 1.2rem;
        color: #333;
        font-weight: 600;
    }

    .color-modal input[type="color"] {
        width: 100px;
        height: 40px;
        border: none;
        border-radius: 8px;
        cursor: pointer;
        transition: transform 0.2s ease;
    }

    .color-modal input[type="color"]:hover {
        transform: scale(1.05);
    }

    .color-modal .toggle-fill {
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 15px;
    }

    .color-modal .toggle-fill label {
        font-size: 0.9rem;
        color: #555;
        font-weight: 500;
    }

    .color-modal .toggle-fill input[type="checkbox"] {
        width: 20px;
        height: 20px;
        cursor: pointer;
        accent-color: #4a90e2;
    }

    .color-modal .opacity-slider {
        display: flex;
        flex-direction: column;
        gap: 10px;
        align-items: center;
        width: 100%;
    }

    .color-modal .opacity-slider label {
        font-size: 0.9rem;
        color: #555;
        font-weight: 500;
    }

    .color-modal .opacity-slider input[type="range"] {
        width: 80%;
        accent-color: #4a90e2;
    }

    .color-modal .opacity-slider #opacity-value {
        font-size: 0.9rem;
        color: #333;
        font-weight: 500;
    }

    .color-modal .buttons {
        display: flex;
        justify-content: space-around;
        gap: 15px;
        margin-top: 20px;
        width: 100%;
    }

    .color-modal .buttons button {
        padding: 10px 20px;
        border: none;
        border-radius: 8px;
        cursor: pointer;
        transition: background-color 0.3s ease, transform 0.2s ease;
        font-size: 0.9rem;
        width: 80px;
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 5px;
    }

    .color-modal .buttons button i {
        font-size: 1rem;
    }

    .color-modal .buttons .apply-btn {
        background-color: #4CBB17;
        color: white;
    }

    .color-modal .buttons .apply-btn:hover {
        background-color: #4CBB17;
        transform: scale(1.05);
    }

    .color-modal .buttons .cancel-btn {
        background-color: #9D00FF;
        color: white;
    }

    .color-modal .buttons .cancel-btn:hover {
        background-color: #9D00FF;
        transform: scale(1.05);
    }

    .color-modal .buttons .delete-btn {
        background-color: #FF2C2C;
        color: white;
    }

    .color-modal .buttons .delete-btn:hover {
        background-color: #FF2C2C;
        transform: scale(1.05);
    }

    .color-modal .buttons .copy-btn {
        background-color: #f39c12;
        color: white;
    }

    .color-modal .buttons .copy-btn:hover {
        background-color: #e67e22;
        transform: scale(1.05);
    }

    #map {
        transition: transform 0.5s ease-in-out, opacity 0.5s ease-in-out;
    }

    .map-zoom-in {
        animation: zoomIn 0.5s ease-in-out forwards;
    }

    @keyframes zoomIn {
        0% {
            transform: scale(0);
            opacity: 0;
        }
        100% {
            transform: scale(1);
            opacity: 1;
        }
    }

    .gradient-modal {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.5);
        z-index: 1000;
    }

    .gradient-modal-content {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: linear-gradient(135deg, #305cde, #86a8e7, #2D68C4);
        padding: 20px;
        border-radius: 12px;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
        text-align: center;
    }

    .color-pickers {
        display: flex;
        justify-content: center;
        gap: 10px;
        margin: 20px 0;
    }

    .color-pickers input[type="color"] {
        width: 50px;
        height: 50px;
        border: none;
        border-radius: 8px;
        cursor: pointer;
    }

    .gradient-modal-content button {
        margin: 5px;
        padding: 8px 16px;
        border: none;
        border-radius: 8px;
        background-color: rgba(255, 255, 255, 0.2);
        color: white;
        cursor: pointer;
        transition: background-color 0.3s ease;
    }

    .gradient-modal-content button:hover {
        background-color: rgba(255, 255, 255, 0.3);
    }

    .gradient-button {
        margin-top: 10px;
        padding: 10px 20px;
        background: linear-gradient(135deg, #6a11cb, #2575fc);
        color: white;
        border: none;
        border-radius: 8px;
        cursor: pointer;
        font-size: 14px;
        font-weight: bold;
        text-transform: uppercase;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.2);
        transition: all 0.3s ease;
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 8px;
    }

    .gradient-button i {
        font-size: 18px;
        transition: transform 0.3s ease;
    }

    .gradient-button:hover {
        background: linear-gradient(135deg, #2575fc, #6a11cb);
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.3);
        transform: translateY(-2px);
    }

    .gradient-button:hover i {
        transform: rotate(15deg);
    }

    .gradient-button:active {
        transform: translateY(0);
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.2);
    }

    .external-map-button {
        width: 36px;
        height: 36px;
        background-color: rgba(255, 255, 255, 0.7);
        border: 1px solid rgba(0, 0, 0, 0.1);
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        transition: transform 0.2s ease, background-color 0.2s ease;
        margin: 0 2px;
        padding: 0;
        overflow: hidden;
        border-radius: 8px;
    }

    .external-map-button:hover {
        background-color: rgba(240, 240, 240, 0.9);
        transform: scale(1.1);
    }

    .external-map-button-animation {
        opacity: 0;
        transform: translateY(-10px);
        animation: slideIn 0.3s ease forwards;
    }

    .external-maps-container {
        position: absolute;
        display: flex;
        justify-content: flex-start;
        gap: 5px;
        z-index: 1001;
        background-color: rgba(255, 255, 255, 0);
        border-radius: 8px;
        padding: 5px;
        box-shadow: none;
    }

    @keyframes slideIn {
        from {
            opacity: 0;
            transform: translateY(-10px);
        }
        to {
            opacity: 1;
            transform: translateY(0);
        }
    }

    /* Animation for widget appearance */
    @keyframes widgetAppear {
        0% {
            opacity: 0;
            transform: translateY(20px) scale(0.95);
        }
        100% {
            opacity: 1;
            transform: translateY(0) scale(1);
        }
    }

    /* Pulsating effect for active buttons */
    @keyframes pulse {
        0% {
            box-shadow: 0 0 0 0 rgba(96, 165, 250, 0.7);
        }
        70% {
            box-shadow: 0 0 0 10px rgba(96, 165, 250, 0);
        }
        100% {
            box-shadow: 0 0 0 0 rgba(96, 165, 250, 0);
        }
    }
    
    .color-modal .buttons .clear-all-placemarks-btn {
    background-color: #e74c3c;
    color: white;
}

.color-modal .buttons .clear-all-placemarks-btn:hover {
    background-color: #c0392b;
    transform: scale(1.05);
}

/* Добавляем новый класс для кнопок карты с пульсацией */
.map-mode-button.map-type.active {
    background-color: rgba(255, 255, 255, 0.35);
    font-weight: bold;
    box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2), inset 0 0 10px rgba(255, 255, 255, 0.2);
    transform: scale(1.15);
    animation: pulse 2s infinite;
}

/* Оригинальный класс active для остальных кнопок без пульсации */
.map-mode-button.active:not(.map-type) {
    background-color: rgba(255, 255, 255, 0.35);
    font-weight: bold;
    box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2), inset 0 0 10px rgba(255, 255, 255, 0.2);
    transform: scale(1.15);
}




/* Snowy background with black text tooltip styles */
.custom-hint {
    background: linear-gradient(135deg, rgba(240, 245, 255, 0.9), rgba(225, 235, 250, 0.9)); /* Snowy, frosty white background */
    border-radius: 10px;
    padding: 14px 18px;
    box-shadow: 0 6px 16px rgba(180, 200, 225, 0.3), 0 2px 6px rgba(180, 200, 225, 0.2); /* Soft blue-tinted shadow */
    font-family: 'Inter', 'Roboto', -apple-system, sans-serif;
    color: #1a1a2e; /* Rich dark blue-black text */
    max-width: 280px;
    min-width: 180px;
    width: fit-content;
    text-align: left;
    white-space: normal;
    overflow-wrap: break-word;
    line-height: 1.5;
    font-size: 13px;
    letter-spacing: 0.2px;
    backdrop-filter: blur(6px);
    border: 1px solid rgba(255, 255, 255, 0.8); /* Bright white border */
    transform: translateY(0);
    transition: transform 0.2s ease, box-shadow 0.2s ease;
}

.custom-hint:hover {
    transform: translateY(-2px);
    box-shadow: 0 8px 20px rgba(180, 200, 225, 0.4), 0 3px 8px rgba(180, 200, 225, 0.3);
}

.custom-hint strong {
    font-weight: 600;
    color: #000814; /* Deeper black for emphasis */
}

/* Optional time/header styling */
.custom-hint::before {
    content: attr(data-time);
    display: block;
    font-size: 11px;
    margin-bottom: 8px;
    color: #4a5568; /* Subtle gray for secondary information */
    letter-spacing: 0.5px;
}

/* Enhanced styles for custom placemark */
.custom-placemark {
    position: absolute;
    font-size: 18px; /* Good readable size */
    font-weight: 700; /* Bolder text */
    color: #ffff00; /* Bright yellow - high contrast against most backgrounds */
    text-shadow: 
        -2px -2px 1px rgba(0,0,0,0.9),  
        2px -2px 1px rgba(0,0,0,0.9),
        -2px 2px 1px rgba(0,0,0,0.9),
        2px 2px 1px rgba(0,0,0,0.9),
        0 0 6px rgba(0,0,0,0.8); /* Multiple shadows for better outline */
    font-family: 'Arial', sans-serif;
    user-select: none;
    letter-spacing: 0.7px; /* Improved letter spacing */
    transform: scale(1.05); /* Slight scaling for emphasis */
}

/* Optional hover effect for interactive maps */
.custom-placemark:hover {
    transform: scale(1.15);
    transition: transform 0.2s ease;
}

/* --- Стили для боковой панели результатов --- */
.parcel-results-sidebar {
    position: fixed;
    top: 10px;
    right: 10px;
    width: 280px; /* Уменьшена ширина панели */
    height: calc(100vh - 20px);
    background: linear-gradient(135deg, #f8fafc, #eef2f7 80%);
    border-radius: 12px;
    box-shadow: -5px 0 15px rgba(0, 0, 0, 0.1);
    z-index: 1005;
    display: flex;
    flex-direction: column;
    overflow: hidden;
    transition: width 0.3s ease, transform 0.3s ease, opacity 0.3s ease;
    border: 1px solid #e2e8f0;
    opacity: 1;
    transform: translateX(0);
}

.parcel-results-sidebar.collapsed {
    width: 40px; /* Уменьшена ширина свернутой панели */
    background: #eef2f7;
}


.parcel-results-sidebar.hidden {
    opacity: 0;
    transform: translateX(100%);
    width: 0; /* Схлопываем при скрытии */
    pointer-events: none; /* Неактивна, когда скрыта */
}


.sidebar-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 10px 15px;
    border-bottom: 1px solid #e2e8f0;
    background-color: rgba(255, 255, 255, 0.5);
    flex-shrink: 0; /* Заголовок не сжимается */
}

.sidebar-header h3 {
    margin: 0;
    font-size: 1.1rem;
    color: #1e293b;
    font-weight: 600;
    white-space: nowrap; /* Заголовок не переносится */
    overflow: hidden;
    transition: opacity 0.2s ease;
}

.parcel-results-sidebar.collapsed .sidebar-header h3 {
    opacity: 0; /* Скрываем заголовок при сворачивании */
    width: 0;
}

.toggle-sidebar-btn {
    background: none;
    border: none;
    color: #4b5563;
    font-size: 1.2rem;
    cursor: pointer;
    padding: 5px;
    transition: color 0.2s ease, transform 0.3s ease;
}

.toggle-sidebar-btn:hover {
    color: #1e293b;
}



.parcel-results-sidebar.collapsed .toggle-sidebar-btn i {
    transform: rotate(180deg); /* Поворачиваем стрелку */
}

.toggle-sidebar-btn i {
    font-weight: 900; /* Критично для solid (fas) иконок Font Awesome */
    transition: transform 0.3s ease; /* Для плавного вращения */
    display: inline-block; /* Убедимся, что элемент отображается корректно */
}



.parcel-list-content {
    flex-grow: 1; /* Занимает все доступное место */
    overflow-y: auto; /* Вертикальная прокрутка */
    padding: 5px 0; /* Небольшие отступы сверху/снизу */
    transition: opacity 0.2s ease;
}

.parcel-results-sidebar.collapsed .parcel-list-content {
    opacity: 0; /* Скрываем контент при сворачивании */
    pointer-events: none;
}

.sidebar-item {
    padding: 12px 15px;
    margin: 8px 10px;
    border-radius: 8px;
    background-color: #ffffff;
    box-shadow: 0 1px 3px rgba(0,0,0,0.05);
    cursor: pointer;
    transition: background-color 0.2s ease, box-shadow 0.2s ease;
    border: 1px solid #f1f5f9;
}

.sidebar-item:hover {
    background-color: #f8fafc;
    box-shadow: 0 2px 5px rgba(0,0,0,0.08);
}

.sidebar-item p {
    margin: 0 0 6px 0;
    font-size: 0.9rem;
    color: #4b5563;
    line-height: 1.4;
}

.sidebar-item p:first-child { /* Кадастровый номер */
    font-weight: 600;
    font-size: 1rem;
    color: #1d4ed8; /* Синий */
}
.sidebar-item p:last-child {
    margin-bottom: 0;
}

.sidebar-footer {
    padding: 10px 15px;
    border-top: 1px solid #e2e8f0;
    background-color: rgba(255, 255, 255, 0.7); /* Немного прозрачнее */
    flex-shrink: 0;
    display: flex; /* Используем flexbox */
    align-items: center; /* Выравниваем по центру вертикально */
    gap: 10px; /* Отступ между элементами */
    transition: opacity 0.2s ease;
}
.parcel-results-sidebar.collapsed .sidebar-footer {
     opacity: 0;
     pointer-events: none;
}
#filter-cadnum-input {
    flex-grow: 1; /* Занимает доступное пространство */
    padding: 8px 12px;
    border: 1px solid #cbd5e1;
    border-radius: 6px;
    font-size: 0.9rem;
    background-color: #fff;
    box-shadow: inset 0 1px 2px rgba(0,0,0,0.05);
}
#filter-cadnum-input:focus {
    outline: none;
    border-color: #3b82f6;
    box-shadow: inset 0 1px 2px rgba(0,0,0,0.05), 0 0 0 2px rgba(59, 130, 246, 0.3);
}

.sidebar-btn {
    width: 100%;
    padding: 10px 15px;
    border-radius: 8px;
    border: none;
    font-size: 0.95rem;
    font-weight: 500;
    color: white;
    cursor: pointer;
    transition: all 0.2s ease;
    box-shadow: 0 2px 5px rgba(0,0,0,0.1);
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 8px;
}

.sidebar-icon-btn {
    flex-shrink: 0; /* Кнопка не сжимается */
    width: 36px;
    height: 36px;
    border-radius: 50%; /* Круглая кнопка */
    border: none;
    background-color: #3b82f6; /* Синий */
    color: white;
    font-size: 1rem; /* Размер иконки */
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    transition: background-color 0.2s ease, transform 0.1s ease;
    box-shadow: 0 1px 3px rgba(0,0,0,0.1);
}

.sidebar-icon-btn:hover {
    background-color: #2563eb;
    transform: translateY(-1px);
     box-shadow: 0 2px 5px rgba(0,0,0,0.15);
}
.sidebar-icon-btn:active {
     transform: translateY(0);
     background-color: #1d4ed8;
}

/* Добавляем стиль для скрытых элементов при фильтрации */
.sidebar-item.filtered-out {
    display: none !important;
}

#copy-all-sidebar-btn {
    background-color: #3b82f6; /* Синий */
}
#copy-all-sidebar-btn:hover {
    background-color: #2563eb;
    transform: translateY(-1px);
    box-shadow: 0 3px 6px rgba(0,0,0,0.15);
}

/* Адаптация под мобильные устройства - можно уменьшить ширину панели */
@media (max-width: 768px) {
    .parcel-results-sidebar {
        width: 240px; /* Уменьшена ширина панели на мобильных */
    }
     .parcel-results-sidebar.collapsed {
        width: 35px; /* Уменьшена ширина свернутой панели на мобильных */
    }
}


        /* --- Styles for Legends --- */
.map-legend {
    position: absolute;
    bottom: 10px;
    /* Изменено: уменьшаем отступ, чтобы легенда была ближе к панели */
    /* Ширина боковой панели 280px + ее отступ справа 10px + небольшой зазор 5px = 295px */
    right: 295px; 
    background-color: rgba(255, 255, 255, 0.85);
    backdrop-filter: blur(4px);
    padding: 10px 15px;
    border-radius: 8px;
    box-shadow: 0 2px 5px rgba(0,0,0,0.2);
    z-index: 900;
    max-width: 250px;
    max-height: 40vh;
    overflow-y: auto;
    font-size: 12px;
    color: #333;
    display: none; /* Hide by default */
}

    .map-legend h4,
    .map-legend .legend-title-multiline { /* Добавляем новый класс */
        margin-top: 0;
        margin-bottom: 8px;
        font-size: 13px; /* Или ваш размер */
        text-align: center;
        border-bottom: 1px solid #ddd;
        padding-bottom: 5px;
        color: #333; /* Цвет текста заголовка */
    }
    
   .camera-height-label {
        position: absolute;
        bottom: 45px;
        left: 10px;
        background-color: transparent;
        color: #ffffff;
        padding: 5px 8px;
        border-radius: 4px;
        font-size: 13px;
        font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
        font-weight: 500;
        z-index: 1000;
        pointer-events: none;
        text-shadow:
            -1px -1px 1px rgba(0,0,0,0.75),
             1px -1px 1px rgba(0,0,0,0.75),
            -1px  1px 1px rgba(0,0,0,0.75),
             1px  1px 1px rgba(0,0,0,0.75),
            0px 0px 5px rgba(0,0,0,0.5);
        transition: opacity 0.3s ease;
        display: none; /* СКРЫТЬ ПО УМОЛЧАНИЮ */
    }

    .camera-height-label.visible { /* НОВЫЙ КЛАСС ДЛЯ ОТОБРАЖЕНИЯ */
        display: block;
    }
    
        #cost-legend .legend-gradient {
            height: 15px;
            border-radius: 3px;
            margin-bottom: 5px;
            border: 1px solid #ccc;
        }
        #cost-legend .legend-labels {
            display: flex;
            justify-content: space-between;
            font-size: 11px;
        }
        #vri-legend-list {
            list-style: none;
            padding: 0;
            margin: 0;
        }
        #vri-legend-list li {
            display: flex;
            align-items: center;
            margin-bottom: 4px;
            line-height: 1.3;
        }
        #vri-legend-list .legend-color-box {
            width: 14px;
            height: 14px;
            border-radius: 3px;
            margin-right: 8px;
            flex-shrink: 0;
            border: 1px solid rgba(0,0,0,0.2);
        }
@media (max-width: 768px) {
      .map-legend {
         max-width: calc(100% - 40px);
         bottom: 60px; /* Adjust if needed based on other elements */
         /* На мобильных устройствах легенда позиционируется слева, поэтому 'right' сбрасывается */
         left: 10px;
         right: auto; 
      }
 }
 
 #vri-legend-list li.legend-item-selected {
    background-color: rgba(0, 0, 0, 0.1); /* Light gray background */
    font-weight: bold;
    border-radius: 4px; /* Optional: rounded corners for highlight */
    box-shadow: inset 0 0 3px rgba(0,0,0,0.1); /* Optional: inner shadow */
}

/* Ensure cursor indicates clickability */
#vri-legend-list li {
    cursor: pointer; /* Add this if not already present */
    /* ... other li styles ... */
}

/* --- Styles for Ownership Legend --- */
#ownership-legend {
    /* Inherits general .map-legend styles */
    /* Specific adjustments if needed */
}

#ownership-legend-list {
    list-style: none;
    padding: 0;
    margin: 0;
}

#ownership-legend-list li {
    display: flex;
    align-items: center;
    margin-bottom: 4px;
    line-height: 1.3;
    cursor: pointer; /* Indicate clickability */
    padding: 2px 4px; /* Add slight padding for better click target and highlight */
    border-radius: 3px; /* Rounded corners for potential highlight */
    transition: background-color 0.1s ease; /* Smooth background transition */
}

#ownership-legend-list .legend-color-box {
    width: 14px;
    height: 14px;
    border-radius: 3px;
    margin-right: 8px;
    flex-shrink: 0;
    border: 1px solid rgba(0,0,0,0.2);
}

 /* Style for selected ownership legend item */
 #ownership-legend-list li.legend-item-selected {
    background-color: rgba(0, 0, 0, 0.1); /* Light gray background */
    font-weight: bold;
    /* box-shadow: inset 0 0 3px rgba(0,0,0,0.1); Optional: inner shadow */
 }
 
 /* ... existing legend styles ... */

#vri-legend-list,
#ownership-legend-list,
#registration-date-legend-list { /* Added new legend list */
    list-style: none;
    padding: 0;
    margin: 0;
}
#vri-legend-list li,
#ownership-legend-list li,
#registration-date-legend-list li { /* Added new legend list */
    display: flex;
    align-items: center;
    margin-bottom: 4px;
    line-height: 1.3;
    cursor: pointer; /* Indicate clickability for all list-based legends */
    padding: 2px 4px;
    border-radius: 3px;
    transition: background-color 0.1s ease;
}
#vri-legend-list li:hover,
#ownership-legend-list li:hover,
#registration-date-legend-list li:hover { /* Added new legend list */
     background-color: rgba(0, 0, 0, 0.05);
}

#vri-legend-list .legend-color-box,
#ownership-legend-list .legend-color-box,
#registration-date-legend-list .legend-color-box { /* Added new legend list */
    width: 14px;
    height: 14px;
    border-radius: 3px;
    margin-right: 8px;
    flex-shrink: 0;
    border: 1px solid rgba(0,0,0,0.2);
}
 /* ... media query for legends ... */

#vri-legend-list li.legend-item-selected,
#ownership-legend-list li.legend-item-selected,
#registration-date-legend-list li.legend-item-selected { /* Added new legend list */
    background-color: rgba(0, 0, 0, 0.1); /* Light gray background */
    font-weight: bold;
    /* Optional: inner shadow */
    box-shadow: inset 0 0 3px rgba(0,0,0,0.1);
}


/* --- Styles for Ownership Legend --- */
#ownership-legend {
    /* Inherits general .map-legend styles */
    /* Specific adjustments if needed */
}
 /* Style for selected ownership legend item */


/* --- Styles for Registration Date Legend --- */
#registration-date-legend {
    /* Inherits general .map-legend styles */
}

#ulu-legend {
    /* ... any specific styles ... */
}

#ulu-legend-list {
    list-style: none;
    padding: 0;
    margin: 0;
}

#ulu-legend-list li {
    display: flex;
    align-items: center;
    margin-bottom: 4px;
    line-height: 1.3;
    /* cursor: pointer; Add if you make legend items clickable for filtering */
    padding: 2px 4px;
    border-radius: 3px;
     cursor: pointer; 
}

#ulu-legend-list .legend-color-box {
    width: 14px;
    height: 14px;
    border-radius: 3px;
    margin-right: 8px;
    flex-shrink: 0;
    border: 1px solid rgba(0,0,0,0.2);
}
#ulu-legend-list li.legend-item-selected {
    background-color: rgba(0, 0, 0, 0.1); /* Light gray background */
    font-weight: bold;
    /* box-shadow: inset 0 0 3px rgba(0,0,0,0.1); Optional: inner shadow */
}

/* Общий стиль для заголовка легенды, если еще нет */
.map-legend h4,
.map-legend .legend-title-multiline { /* Добавляем новый класс */
    margin-top: 0;
    margin-bottom: 8px;
    font-size: 13px; /* Или ваш размер */
    text-align: center;
    border-bottom: 1px solid #ddd;
    padding-bottom: 5px;
    color: #333; /* Цвет текста заголовка */
}

/* Стили для многострочного заголовка */
.legend-title-multiline span {
    display: block; /* Каждая часть заголовка будет на новой строке */
    line-height: 1.2; /* Межстрочный интервал, если нужно */
}

/* Можно сделать вторую строку чуть меньше или светлее, если хотите */
.legend-title-multiline span:last-child {
    font-size: 11px; /* Например, немного меньше */
    color: #555;    /* Например, немного светлее */
    margin-top: 2px; /* Небольшой отступ сверху для второй строки */
}



.numbered-point-label {
    color: #FF0000; /* Красный цвет текста */
    font-size: 16px; /* Размер шрифта */
    font-weight: bold; /* Жирный шрифт */
    font-family: Arial, sans-serif;
    /* Белый контур для лучшей читаемости на любом фоне */
    text-shadow: -1px -1px 0 #fff, 1px -1px 0 #fff, -1px 1px 0 #fff, 1px 1px 0 #fff;
    user-select: none; /* Запретить выделение текста */
    pointer-events: none; /* Метка не будет перехватывать клики мыши */
}



.custom-red-dot {
    width: 10px;
    height: 10px;
    background-color: #FF0000;
    border-radius: 50%;
    border: 1px solid #B20000; /* Темно-красная рамка для четкости */
}



/* ЗАМЕНИТЕ ВСЕ СТИЛИ ДЛЯ МОДАЛЬНОГО ОКНА ОКС НА ЭТИ */

/* Стилизация основного контейнера модального окна */
#oksModalContent {
    background: #ffffff !important;
    width: 90% !important;
    max-width: 480px !important; /* Немного шире для кнопок */
    border-radius: 12px !important;
    box-shadow: 0 5px 20px rgba(0,0,0,0.15) !important;
    padding: 15px !important;
    display: flex;
    flex-direction: column;
}

/* Контейнер списка с динамической высотой и скроллбаром */
#oksListContainer {
    max-height: 70vh;
    overflow-y: auto;
    padding: 5px;
    margin-bottom: 15px;
}

/* Стилизация красивого скроллбара */
#oksListContainer::-webkit-scrollbar { width: 8px; }
#oksListContainer::-webkit-scrollbar-track { background: #f1f1f1; border-radius: 10px; }
#oksListContainer::-webkit-scrollbar-thumb { background: #888; border-radius: 10px; }
#oksListContainer::-webkit-scrollbar-thumb:hover { background: #555; }

/* Стиль для каждого элемента списка (синяя "кнопка") */
#oksListContainer .oks-item {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 12px 18px;
    margin: 8px 0;
    border-radius: 8px;
    background-color: #3B82F6;
    color: white;
    font-size: 1rem;
    font-weight: 500;
    box-shadow: 0 2px 5px rgba(0,0,0,0.1);
    transition: all 0.2s ease-in-out;
}
#oksListContainer .oks-item:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 10px rgba(0,0,0,0.15);
    background-color: #2563EB;
}

/* Контейнер для двух кнопок в строке */
.oks-item-buttons {
    display: flex;
    align-items: center;
    gap: 8px; /* Расстояние между иконками */
    margin-left: 15px;
}

/* Общий стиль для иконок-кнопок в строке */
.oks-icon-btn {
    background: rgba(255, 255, 255, 0.2);
    border: none;
    border-radius: 50%;
    width: 32px;
    height: 32px;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    transition: all 0.2s ease;
    flex-shrink: 0;
    color: white; /* Цвет иконки FontAwesome */
    font-size: 14px; /* Размер иконки FontAwesome */
}

.oks-icon-btn:hover {
    background: rgba(255, 255, 255, 0.4);
    transform: scale(1.1);
}

.oks-icon-btn img {
    width: 20px;
    height: 20px;
}

/* Контейнер для нижних кнопок ("Копировать все" и "Закрыть") */
.oks-footer-buttons {
    display: flex;
    justify-content: center;
    gap: 15px; /* Расстояние между кнопками */
    margin-top: 10px;
    flex-wrap: wrap; /* Перенос кнопок на новую строку на маленьких экранах */
}

/* Общий стиль для нижних кнопок */
.oks-footer-btn {
    padding: 12px 20px;
    border: none;
    border-radius: 8px;
    color: white;
    font-size: 1rem;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.2s ease;
    box-shadow: 0 2px 5px rgba(0,0,0,0.15);
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 8px;
}
.oks-footer-btn:hover {
    box-shadow: 0 4px 10px rgba(0,0,0,0.2);
    transform: translateY(-1px);
}

/* Стиль для кнопки "Копировать все" */
#oksCopyAllBtn {
    background-color: #1E88E5; /* Другой оттенок синего */
}
#oksCopyAllBtn:hover {
    background-color: #1565C0;
}

/* Стиль для кнопки "Закрыть" (переименован из .oks-close-btn для единообразия) */
#closeOksModalBtn {
    background-color: #F44336; /* Красный */
}
#closeOksModalBtn:hover {
    background-color: #D32F2F;
}

/* Сообщение, если ОКС не найдены */
#oksListContainer .no-oks-found {
    padding: 20px;
    text-align: center;
    color: #6b7280;
    font-style: italic;
    background: #f8f9fa;
    border-radius: 8px;
}

/* --- Стили для модального окна конвертера (финальная версия) --- */
.converter-modal {
    position: fixed;
    z-index: 10001;
    left: 0;
    top: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0,0,0,0.5);
    backdrop-filter: blur(8px);
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 20px;
    box-sizing: border-box;
}

.converter-modal-content {
    /* Градиент будет применен через JS */
    padding: 20px 25px;
    border-radius: 24px;
    width: 100%;
    max-width: 450px;
    min-width: 320px;
    box-shadow: 0 15px 40px rgba(0,0,0,0.2);
    border: 1.5px solid rgba(255,255,255,0.2);
    display: flex;
    flex-direction: column;
    gap: 18px;
    position: relative;
    animation: fadeInScale 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
    box-sizing: border-box;
}

@keyframes fadeInScale {
    from { opacity: 0; transform: translateY(10px) scale(0.95); }
    to { opacity: 1; transform: translateY(0) scale(1); }
}

.converter-modal-content h3 {
    text-align: center;
    color: #333;
    margin: 0;
    font-weight: 600;
    font-size: 1.1rem;
    padding: 0 20px;
}

.converter-modal-content select,
.converter-modal-content textarea {
    width: 100%;
    padding: 12px 18px;
    border-radius: 16px;
    border: none;
    font-size: 0.95rem;
    background: rgba(255, 255, 255, 0.7);
    color: #444;
    box-shadow: inset 0 2px 4px rgba(0,0,0,0.05);
    transition: all 0.3s ease;
    box-sizing: border-box;
}

.converter-modal-content select::placeholder,
.converter-modal-content textarea::placeholder {
    color: #888;
}

.converter-modal-content select:focus,
.converter-modal-content textarea:focus {
    outline: none;
    background: rgba(255, 255, 255, 0.9);
    box-shadow: 0 0 0 3px rgba(120, 100, 255, 0.25), inset 0 2px 4px rgba(0,0,0,0.05);
}

.converter-modal-content textarea {
    min-height: 120px;
    resize: vertical;
    font-family: monospace;
}

.converter-modal-actions {
    display: flex;
    justify-content: space-between;
    align-items: center;
    gap: 15px;
}

.converter-modal-actions select {
    flex-grow: 1;
    text-align: center;
    text-align-last: center;
    appearance: none;
    background-image: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="%238a98b4" stroke-width="2" stroke-linecap="round"><polyline points="6,9 12,15 18,9"/></svg>');
    background-repeat: no-repeat;
    background-position: right 15px center;
    background-size: 18px;
    padding-right: 40px;
}

.converter-modal-actions .action-btn {
    width: 48px;
    height: 48px;
    flex-shrink: 0;
    border: none;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.3s cubic-bezier(0.25, 0.8, 0.25, 1);
    cursor: pointer;
    box-shadow: 0 6px 15px rgba(0,0,0,0.15);
}

.converter-modal-actions .action-btn:hover {
    transform: translateY(-2px) scale(1.05);
    box-shadow: 0 8px 20px rgba(0,0,0,0.2);
    filter: brightness(1.1);
}

.converter-modal-actions .action-btn img {
    width: 20px;
    height: 20px;
    filter: invert(1) drop-shadow(0 1px 2px rgba(0,0,0,0.2));
}

.converter-modal-content .close-btn {
    position: absolute;
    top: 18px;
    right: 20px;
    background: transparent;
    border: none;
    font-size: 1.6rem;
    color: rgba(0,0,0,0.3);
    cursor: pointer;
    transition: all 0.2s ease;
    padding: 0;
    line-height: 1;
}

.converter-modal-content .close-btn:hover {
    color: rgba(0,0,0,0.6);
    transform: scale(1.1);
}

/* Для мобильных устройств */
@media (max-width: 480px) {
    .converter-modal {
        padding: 15px;
    }
    
    .converter-modal-content {
        min-width: auto;
        width: 100%;
        padding: 18px 20px;
    }
}

.converter-mode-switch {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 15px;
    margin-bottom: 15px; /* Отступ снизу */
}
.converter-mode-switch label {
    margin: 0;
    color: #444;
    font-weight: 500;
}
.switch { position: relative; display: inline-block; width: 140px; height: 34px; }
.switch input { opacity: 0; width: 0; height: 0; }
.slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #ccc; transition: .4s; border-radius: 34px; }
.slider:before { position: absolute; content: ""; height: 26px; width: 70px; left: 4px; bottom: 4px; background-color: white; transition: .4s; border-radius: 34px; }
/* Текст на переключателе */
.slider:after { content: 'Запрос'; color: white; position: absolute; right: 15px; top: 50%; transform: translateY(-50%); font-size: 0.85rem; font-weight: bold; }
input:checked + .slider { background-color: #2196F3; }
input:checked + .slider:before { transform: translateX(62px); }
input:checked + .slider:after { content: 'Proj4'; left: 15px; right: auto; }

/* Стили для полей смещения */
.converter-offset-inputs {
    display: flex;
    gap: 15px;
    margin-top: -5px; /* Уменьшаем отступ сверху, т.к. у textarea свой отступ */
    margin-bottom: 18px;
}
.converter-offset-inputs div {
    flex: 1;
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 8px;
}
.converter-offset-inputs label {
    font-size: 0.9rem;
    color: #555;
    font-weight: 500;
}
.converter-offset-inputs input[type="number"] {
    width: 100%;
    padding: 10px;
    border-radius: 12px;
    border: none;
    text-align: center;
    font-size: 0.95rem;
    background: rgba(255, 255, 255, 0.7);
    color: #444;
    box-shadow: inset 0 2px 4px rgba(0,0,0,0.05);
}
.converter-offset-inputs input[type="number"]:focus {
     outline: none;
     background: rgba(255, 255, 255, 0.9);
     box-shadow: 0 0 0 3px rgba(120, 100, 255, 0.25), inset 0 2px 4px rgba(0,0,0,0.05);
}

.modal-option {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 10px;
    margin-bottom: 15px; /* Отступ снизу */
    user-select: none;
}
.modal-option input[type="checkbox"] {
    width: auto;
    height: auto;
    transform: scale(1.2);
    cursor: pointer;
    margin: 0;
}
.modal-option label {
    margin: 0;
    cursor: pointer;
    font-size: 0.9rem;
    color: #444;
}


.sidebar-stats {
    padding: 8px 15px;
    font-size: 0.85rem;
    color: #4b5563;
    background-color: rgba(255, 255, 255, 0.5);
    border-bottom: 1px solid #e2e8f0;
    line-height: 1.5;
    flex-shrink: 0; /* Запрещаем сжиматься */
    transition: opacity 0.2s ease;
    display: none; /* Скрыт по умолчанию, пока нет данных */
}
.parcel-results-sidebar.collapsed .sidebar-stats {
    opacity: 0;
    pointer-events: none;
}



.raster-controls-panel {
    position: absolute;
    top: 150px;
    right: 10px;
    background: linear-gradient(135deg, #f8fafc, #eef2f7 80%);
    border-radius: 12px;
    box-shadow: 0 5px 15px rgba(0, 0, 0, 0.15);
    z-index: 1005;
    padding: 15px;
    width: 200px;
    border: 1px solid #e2e8f0;
    cursor: grab;
    display: flex;
    flex-direction: column;
    gap: 10px;
}
.raster-controls-panel:active {
    cursor: grabbing;
}
.raster-controls-panel h4 {
    margin: 0 0 10px 0;
    text-align: center;
    color: #1e293b;
    font-size: 1rem;
    cursor: default;
}
.raster-controls-panel .control-group {
    display: grid;
    grid-template-columns: 1fr auto 1fr;
    justify-items: center;
    align-items: center;
    gap: 5px;
}
.raster-controls-panel button {
    background: #3b82f6;
    color: white;
    border: none;
    border-radius: 50%;
    width: 30px;
    height: 30px;
    font-size: 1rem;
    cursor: pointer;
    transition: background-color 0.2s, transform 0.1s;
}
.raster-controls-panel button:hover {
    background: #2563eb;
}
.raster-controls-panel button:active {
    transform: scale(0.9);
}
.raster-controls-panel input[type="range"] {
    width: 100%;
    margin: 10px 0;
    -webkit-appearance: none;
    appearance: none;
    height: 8px;
    background: #d1d5db;
    border-radius: 4px;
    outline: none;
}
.raster-controls-panel input[type="range"]::-webkit-slider-thumb {
    -webkit-appearance: none;
    appearance: none;
    width: 20px;
    height: 20px;
    background: #3b82f6;
    cursor: pointer;
    border-radius: 50%;
    border: 2px solid white;
    box-shadow: 0 0 5px rgba(0,0,0,0.2);
}
.raster-controls-panel input[type="range"]::-moz-range-thumb {
    width: 20px;
    height: 20px;
    background: #3b82f6;
    cursor: pointer;
    border-radius: 50%;
    border: 2px solid white;
    box-shadow: 0 0 5px rgba(0,0,0,0.2);
}
.raster-controls-panel .close-btn {
    position: absolute;
    top: 5px;
    right: 5px;
    width: 20px;
    height: 20px;
    font-size: 0.8rem;
    background-color: #ef4444;
}
.raster-controls-panel .close-btn:hover {
    background-color: #dc2626;
}


/* Стили для кнопок радиуса в лоадере */
.loader-radius-buttons {
    display: flex;
    gap: 8px;
    margin-top: 15px;
    z-index: 10003; /* Поверх лоадера */
}

.radius-btn {
    padding: 6px 12px;
    border: 1px solid #ccc;
    background-color: rgba(255, 255, 255, 0.8);
    border-radius: 20px;
    cursor: pointer;
    font-size: 13px;
    font-weight: 600;
    color: #333;
    transition: all 0.2s ease;
    outline: none;
}

.radius-btn:hover {
    background-color: #fff;
    transform: translateY(-2px);
    box-shadow: 0 2px 5px rgba(0,0,0,0.2);
}

.radius-btn.active {
    background-color: #3b82f6; /* Синий цвет активной кнопки */
    color: white;
    border-color: #3b82f6;
    box-shadow: 0 0 10px rgba(59, 130, 246, 0.5);
}


</style>

</head>

<body>
    



     <div id="map"></div>

    <!-- LOADER (оставляем только один) -->
    <div class="loader-container" id="loaderContainer">
        <div class="loader">
            <div class="spinner-container">
                <div class="spinner-ring"></div>
            </div>
                <div class="loading-text">Загрузка...</div> 
        </div>
    </div>

    <!-- КОНТЕКСТНОЕ МЕНЮ (оставляем только одно, обычно здесь или перед </body>) -->
    <div class="custom-context-menu" style="display: none;">
       <!-- Содержимое контекстного меню (которое вы добавили ранее) будет здесь при инициализации карты -->
    </div>

    <!-- ЛЕГЕНДЫ КАРТЫ (их положение здесь нормальное) -->
    <div id="cost-legend" class="map-legend">
        <h4>Стоимость (руб./кв.м)</h4>
        <div class="legend-gradient"></div>
        <div class="legend-labels">
            <span id="legend-min-cost">0</span>
            <span id="legend-max-cost">0</span>
        </div>
    </div>
    <div id="vri-legend" class="map-legend">
        <h4>Вид разрешенного использования</h4>
        <ul id="vri-legend-list"></ul>
    </div>

    <div id="ownership-legend" class="map-legend">
        <h4>Форма собственности | Тип права</h4>
        <ul id="ownership-legend-list"></ul>
    </div>

    <!-- NEW LEGEND FOR REGISTRATION DATE - Corrected placement -->
    <div id="registration-date-legend" class="map-legend">
        <h4>Дата внесения в ЕГРН</h4>
        <ul id="registration-date-legend-list"></ul>
    </div>
    
    <div id="ulu-legend" class="map-legend">
       <div class="legend-title-multiline">
    <span>Единое землепользование</span>
    <span></span>
</div>
    <ul id="ulu-legend-list"></ul>
</div>
    <!-- End NEW LEGEND -->
  <div id="camera-height-label" class="camera-height-label">Обзор: ...</div>
    <!-- Конец легенд -->

    <!-- ВИДЖЕТ (оставляем только одну копию) -->
    <div class="widget widget-desktop" id="widget">
        <a class="city-name" id="city-name-display" target="_blank"></a>
        <div class="date-time"></div>
        <textarea class="coords-input" id="coords-input" placeholder="Введите координаты (X Y или X[tab]Y)"></textarea>
        <textarea class="result-textarea" id="converted-textarea" placeholder="Конвертированные координаты" readonly></textarea>
        <textarea class="result-textarea" id="geo-textarea" placeholder="Географические координаты" readonly></textarea>
        
      
        
        <div class="map-mode-switcher">
            <button class="map-mode-button map-type" data-mode="map" title="Схема">
                <i class="fas fa-map"></i>
            </button>
            <button class="map-mode-button map-type" data-mode="satellite" title="Спутник">
                <i class="fas fa-satellite"></i>
            </button>
            <button class="map-mode-button map-type" data-mode="hybrid" title="Схема - Спутник">
                <i class="fas fa-layer-group"></i>
            </button>
            <button class="map-mode-button map-type" data-mode="blank" title="Пустая карта">
                <i class="fas fa-square"></i>
            </button>
        <button class="convert-button" onclick="findAndConvert()" title="Найти по координатам (F9)">
                <i class="fas fa-play"></i>
            </button>
        <button class="map-mode-button" id="open-converter-btn" title="МСК">
    <i class="fas fa-exchange-alt"></i>
</button>
            <button class="map-mode-button" data-mode="style" title="Настройки" onclick="openStyleSettings()">
                <i class="fas fa-cog"></i>
            </button>
            <button id="add-text-button" title="Добавить текст">
                <i class="fas fa-pencil-alt"></i>
            </button>
            <button class="map-mode-button" data-mode="yandex-google" title="Карты" onclick="openExternalMaps(event)">
                <i class="fas fa-map-marker-alt"></i>
            </button>
        </div>
        <div class="input-container">
            <img src="img/history.png" alt="History" class="history-icon" id="history-icon">
            <input type="text" id="city-input" placeholder="">
            <img src="img/find.png" alt="Search" class="search-icon" id="search-icon">
        </div>
        <div id="history-modal" class="history-modal"></div>
    </div>
    <!-- Конец виджета -->

    <!-- МОДАЛЬНЫЕ ОКНА (выносим за пределы виджета, обычно размещают перед </body>) -->
     <div id="styleModal" class="style-modal">
        <div class="style-modal-content">
            <h3>Настройки</h3>
            <div class="style-setting">
                <label>Линия:</label>
                <input type="color" id="lineColor" onchange="updatePolygonStyle()">
            </div>
            <div class="style-setting">
                <label>Уточненные ЗУ:</label>
                <input type="color" id="parcelsColor" onchange="updatePolygonStyle()">
            </div>
            <div class="style-setting">
                <label>Декларированные ЗУ:</label>
                <input type="color" id="declaredParcelsColor" onchange="updatePolygonStyle()">
            </div>
            
              <div class="style-setting">
                <label>Здания:</label>
                <input type="color" id="buildingsColor" onchange="updatePolygonStyle()">
            </div>
            
               <div class="style-setting">
                <label>Сооружения:</label>
                <input type="color" id="structuresColor" onchange="updatePolygonStyle()">
            </div>
            
       
            
            <div class="style-setting">
                <label>Толщина линии:</label>
                <input type="range" id="lineWidth" min="1" max="10" value="2" onchange="updatePolygonStyle()">
            </div>
            <div class="style-setting">
                <label>Смещение по широте (-4.5):</label>
                <input type="number" id="mapOffsetX" value="-4.5" step="0.1" onchange="updateMapOffset()">
            </div>
            <div class="style-setting">
                <label>Смещение по долготе (-1):</label>
                <input type="number" id="mapOffsetY" value="-1" step="0.1" onchange="updateMapOffset()">
            </div>
            
                 <div class="style-setting">
                <label>KML Смещение по широте (0):</label>
                <input type="number" id="kmlMapOffsetX" value="0" step="0.1" onchange="updateKmlMapOffset()">
            </div>
            <div class="style-setting">
                <label>KML Смещение по долготе (0):</label>
                <input type="number" id="kmlMapOffsetY" value="0" step="0.1" onchange="updateKmlMapOffset()">
            </div>
            
              <div class="style-setting">
                <label for="toggleOpenGoogleEarth">Web-версия Google Earth:</label>
                <input type="checkbox" id="toggleOpenGoogleEarth" onchange="updateGoogleEarthSetting()">
            </div>
            
             <div class="style-setting">
                <label for="toggleVercelProxy">Мобильный режим:</label>
                <input type="checkbox" id="toggleVercelProxy" onchange="updateVercelProxySetting()">
            </div>
            
            <!-- НОВАЯ НАСТРОЙКА ДЛЯ МЕТКИ ВЫСОТЫ -->
            <div class="style-setting">
                <label for="toggleHeightLabel">Высота/Обзор:</label>
                <input type="checkbox" id="toggleHeightLabel" onchange="toggleCameraHeightLabelVisibility()">
            </div>
            <!-- КОНЕЦ НОВОЙ НАСТРОЙКИ -->
            <button class="gradient-button" onclick="openGradientModal()">
                <i class="fas fa-palette"></i>
            </button>
             <!-- СЮДА можно добавить input для thematicCostColor, если нужно -->
             <!-- <div class="style-setting">
                 <label>Цвет (Стоимость):</label>
                 <input type="color" id="thematicCostColorInputId" onchange="updatePolygonStyle()">
             </div> -->
        </div>
    </div>

    <div id="gradientModal" class="gradient-modal">
        <div class="gradient-modal-content">
            <h3>Градиент виджета</h3>
            <div class="color-pickers">
                <input type="color" id="color1" value="#3B82F6">
                <input type="color" id="color2" value="#60A5FA">
                <input type="color" id="color3" value="#1E3A8A">
                <input type="color" id="fontColor" value="#F9FAFB">
            </div>
            <button onclick="resetGradient()"><i class="fas fa-redo"></i></button>
            <button onclick="applyGradient()" aria-label="Применить градиент"><i class="fas fa-check"></i></button>
            <button onclick="closeGradientModal()" aria-label="Отменить"><i class="fas fa-times"></i></button>
        </div>
    </div>
    <!-- Конец модальных окон -->

    <!-- БОКОВАЯ ПАНЕЛЬ (положение в конце нормальное) -->
    <div id="parcel-results-sidebar" class="parcel-results-sidebar hidden">
        <div class="sidebar-header">
            <h3 id="sidebar-title">Найденные участки</h3>
            <button id="toggle-sidebar-btn" class="toggle-sidebar-btn" title="Свернуть/Развернуть">
                <i class="fas fa-chevron-right"></i>
            </button>
        </div>
        <!-- НОВЫЙ БЛОК ДЛЯ СТАТИСТИКИ -->
        <div id="sidebar-stats" class="sidebar-stats"></div>
        <!-- КОНЕЦ НОВОГО БЛОКА -->
        <div id="parcel-list-content" class="parcel-list-content">
            <div class="no-results-message" style="display: none; padding: 20px; text-align: center; color: #6b7280;">
                Нет пересекающихся участков.
            </div>
        </div>
        <div class="sidebar-footer">
            <input type="text" id="filter-cadnum-input" placeholder="Фильтр">
            <button id="copy-filtered-btn" class="sidebar-icon-btn" title="Копировать видимые">
                <i class="fas fa-copy"></i>
            </button>
        </div>
    </div>
    
    

<!-- Модальное окно для отображения списка ОКС на ЗУ -->
<div id="oksModal" class="style-modal">
    <div class="style-modal-content" id="oksModalContent">
        <div id="oksListContainer">
            <!-- Сюда будет динамически добавлен список ОКС -->
        </div>
      
    </div>
</div>



<script type="text/javascript">
    (function(m,e,t,r,i,k,a){
        m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};
        m[i].l=1*new Date();
        for (var j = 0; j < document.scripts.length; j++) {if (document.scripts[j].src === r) { return; }}
        k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)
    })(window, document,'script','https://mc.yandex.ru/metrika/tag.js', 'ym');

    ym(102727374, 'init', {clickmap:true, accurateTrackBounce:true, trackLinks:true});
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/102727374" style="position:absolute; left:-9999px;" alt="" /></div></noscript>


 <!--  <script src="cb.js"></script>  -->
    
  <script src="msk.js"></script> 
      <script src="sk.js"></script>
    <script src="https://api-maps.yandex.ru/2.1/?apikey=dde71a0e-b612-44b7-b53b-82533420240f&lang=ru_RU"
        type="text/javascript"></script>
        <script src="webfonts/turf.min.js"></script>

    <script>

        const cityInput = document.getElementById('city-input');
        const cityNameElement = document.getElementById('city-name-display');
        const dateTimeElement = document.querySelector('.date-time');
        const mapElement = document.getElementById('map');
        const coordsInput = document.getElementById('coords-input');
        const convertedTextarea = document.getElementById('converted-textarea');
        const geoTextarea = document.getElementById('geo-textarea');
        const widget = document.getElementById('widget');

const sevenDigitsRegions = [
  '06', '07', '09', '10', '11', '12', '13', '14', '17', '23',
  '24', '27', '31', '32', '35', '36', '41', '42', '47', '48',
  '50', '52', '53', '56', '57', '58', '59', '60', '61', '62',
  '63', '64', '65', '66', '67', '69', '70', '71', '72', '74',
  '77', '78', '79'];
  
  const CATEGORY_IDS = {
            ZU: 36368, BUILDINGS: 36369, CONSTRUCTIONS: 36383,
            ZOUIT: 36940, TERR_ZONES: 36315, SETTLEMENTS: 36281, MUNICIPAL: 36278
        };

        let isMobile = window.innerWidth <= 768;
        let isSearching = false
        let isEzProcessingAborted = false;
        let currentCity = '';
        let map;
        let polygons = [];
        let lastPolygonCenter = null;
        let distanceLine = null;
        let distanceLabel = null;
        let distancePoints = [];
        let distanceMeasurementActive = false;
        let debounceTimer = null;
        let numberedDotSize = 10;
            let numberedPointSize = 14;
        let loaderTextEl = null;
        let zuToEzMapGlobal = new Map();
          let isCameraHeightLabelVisible = false; 
             let openGoogleEarthAfterExport = true;

        
        let ownershipColorMap = new Map(); // Map<"Ownership|RightType", colorHex>
const ownershipLegendDiv = document.getElementById('ownership-legend'); // Legend div
let selectedOwnershipFromLegend = null; // Tracks the selected ownership combination, null means show all
let ownershipFilterPlacemarks = new Map(); // Stores temporary placemarks for ownership filter: Map<cadastralNumber, ymaps.Placemark>
 let selectedRegistrationDateFromLegend = null; 
        
         let parcelFeaturesData = []; 
      let buildingFeaturesData = [];
          let structureFeaturesData = []; // To store raw feature data for themes
          let zouitFeaturesData = []; 
        let currentTheme = 'none'; // 'none', 'cost', 'use'
        let vriColorMap = new Map(); // Map VRI names to colors
        const costLegendDiv = document.getElementById('cost-legend'); // Legend divs
        const vriLegendDiv = document.getElementById('vri-legend');
        
        let registrationDateColorMap = new Map(); // Map registration dates to colors
    const registrationDateLegendDiv = document.getElementById('registration-date-legend'); // New legend div
    
     let registrationDateFilterPlacemarks = new Map();
    
        let vriFilterPlacemarks = new Map(); // Stores temporary placemarks: Map<cadastralNumber, ymaps.Placemark>
        let currentQuarterNumber = null; 

let polygonStyle = {
    color: localStorage.getItem('polygonColor') || '#ffff00',
    width: parseInt(localStorage.getItem('polygonWidth')) || 4,
    parcelsColor: localStorage.getItem('parcelsColor') || '#2CFF05', 
    declaredParcelsColor: localStorage.getItem('declaredParcelsColor') || '#FF0000', 
    buildingsColor: localStorage.getItem('buildingsColor') || '#00BFFF', 
    structuresColor: localStorage.getItem('structuresColor') || '#00BFFF', 
    thematicCostColor: localStorage.getItem('thematicCostColor') || '#0000FF', 
    thematicRegistrationDateColor1: localStorage.getItem('thematicRegistrationDateColor1') || '#FFFF00',
    thematicRegistrationDateColor2: localStorage.getItem('thematicRegistrationDateColor2') || '#00FF00'
};

let currentSearchRadius = parseInt(localStorage.getItem('nearbySearchRadius')) || 50; 
let nearbySearchSessionId = 0;
        
   let areaMeasurementActive = false;
let areaPoints = [];
let areaPolygon = null;
let areaLabel = null;
let areaObjects = []; // Новый массив для объектов измерения площади
let allAreaMeasurements = [];
let selectedPlacemark = null;

const uluLegendDiv = document.getElementById('ulu-legend');
let uluColorMap = new Map(); // Map<EZ_CadastralNumber, colorHex>
let selectedUluFromLegend = null; // If you implement filtering by legend click later
let uluFilterPlacemarks = new Map(); 

let currentLineColor = '#ff2c2c'; // Default line color, can be changed
let currentLineWidth = 4;       // Default line width, can be changed

let selectedVriFromLegend = null; // Tracks the VRI selected in the legend, null means show all
        // Смещения по осям
        let mapOffsetX = parseFloat(localStorage.getItem('mapOffsetX')) || -4.5;
        let mapOffsetY = parseFloat(localStorage.getItem('mapOffsetY')) || -1;
        
         let kmlMapOffsetX = parseFloat(localStorage.getItem('kmlMapOffsetX')) || 0;
        let kmlMapOffsetY = parseFloat(localStorage.getItem('kmlMapOffsetY')) || 0;
        
        let isSidebarCollapsed = false; // Глобальная переменная для состояния панели
          let cameraHeightLabelElement = null;
        const ALTITUDE_CORRECTION_FACTOR = 3; // Новый коэффициент
        let selectedLine = null;
        
        let useVercelProxyFeature = false; 
       let useVercelProxy = false;
       let isVercelProxyBlocked = false;
       let lastVercelBlockTime = 0;
       
       let rasterOverlay = null;
      let manualObjectOpacity = parseFloat(localStorage.getItem('manualObjectOpacity')) || 0.8;
      let loadedObjectOpacity = parseFloat(localStorage.getItem('loadedObjectOpacity')) || 0.8;
let rasterControlsPanel = null;
let rasterImageSize = { width: 0, height: 0 };

let bindingState = 0; // 0: inactive, 1: wait for raster P1, 2: wait for raster P2, 3: wait for map P1, 4: wait for map P2
let bindingPoints = {
    raster: [], // Will store relative [x, y] coords (0.0 to 1.0)
    map: []     // Will store geo [lat, lon] coords
};

const vercelProxyUrl = 'https://nsp-two.vercel.app/';


async function fetchNspd(url, options = {}) {
 const delay = Math.floor(Math.random() * 1000) + 1000;
    await new Promise(resolve => setTimeout(resolve, delay));

    if (!useVercelProxyFeature) {
        try {
            return await fetch(url, options);
        } catch (directError) {
            console.error("Direct fetch failed:", directError);
            throw directError;
        }
    }


    if (isVercelProxyBlocked) {
        return new Response(JSON.stringify({ error: "Vercel proxy is blocked" }), {
            status: 403,
            headers: { 'Content-Type': 'application/json' }
        });
    }
    
    const urlObject = new URL(url);
    const targetPath = `${urlObject.pathname}${urlObject.search}`;
    
    const refererParam = encodeURIComponent('https://nspd.gov.ru/map');
    const originParam = encodeURIComponent('https://nspd.gov.ru');
    const proxyRequestUrl = `${vercelProxyUrl}?target=${encodeURIComponent(targetPath)}&referer=${refererParam}&origin=${originParam}`;
   
    const proxyOptions = { ...options };
   
    try {
        const response = await fetch(proxyRequestUrl, proxyOptions); 

        if (!response.ok && response.status === 403) {
            isVercelProxyBlocked = true;
            const currentTime = Date.now();
            if (currentTime - lastVercelBlockTime > 30000) {
                lastVercelBlockTime = currentTime;
            }
        }
        
        if (response.ok) {
            const clonedResponse = response.clone(); 
            try {
                const data = await clonedResponse.json();
                if (data && data.error) {
                    throw new Error(data.error); 
                }
            } catch (e) {
              
            }
        }
        
        return response; 

    } catch (error) {
        console.error("Fetch via Vercel proxy failed:", error);
        return new Response(JSON.stringify({ error: `Proxy request failed: ${error.message}` }), {
            status: 502,
            headers: { 'Content-Type': 'application/json' }
        });
    }
}

function setLoadedObjectOpacity(opacity) {
    loadedObjectOpacity = opacity; // Обновляем глобальное значение
    localStorage.setItem('loadedObjectOpacity', opacity); // Сохраняем в localStorage

    // Базовый уровень непрозрачности, который задают темы (например, 'E6' в hex = 230, ~90%)
    const baseThemeAlpha = 230; 

    // Проходим по всем гео-объектам на карте
    map.geoObjects.each(function(geoObject) {
        // Проверяем, что это полигон или линия и у него есть свойства
        if (geoObject.properties && (geoObject instanceof ymaps.Polygon || geoObject instanceof ymaps.Polyline)) {
            const props = geoObject.properties;
            
            // Определяем, является ли объект "загруженным"
            const isLoadedObject =
                props.get('isParcelInQuarter') ||
                props.get('isFoundInArea') ||
                props.get('isBuilding') ||
                props.get('isStructure') ||
                props.get('isZouit') ||
                props.get('isParcelFromSingleSearch');

            if (isLoadedObject) {
                // 1. Применяем прозрачность к КОНТУРУ (обводке). Это работает для всех.
                geoObject.options.set('strokeOpacity', opacity);

                // 2. Применяем прозрачность к ЗАЛИВКЕ (только для полигонов)
                if (geoObject instanceof ymaps.Polygon) {
                    const currentFill = geoObject.options.get('fillColor');

                    // Если у полигона есть цвет заливки (не полностью прозрачный)
                    if (currentFill && currentFill !== '#00000000') {
                        // Отделяем RGB часть цвета (первые 7 символов, включая #)
                        const rgbPart = currentFill.substring(0, 7);
                        
                        // Вычисляем новый альфа-канал, умножая базовый на значение слайдера
                        const newAlphaDecimal = Math.round(baseThemeAlpha * opacity);
                        
                        // Преобразуем в двухзначное шестнадцатеричное число (00, 0F, FF и т.д.)
                        const newAlphaHex = newAlphaDecimal.toString(16).padStart(2, '0');
                        
                        // Собираем новый цвет и устанавливаем его
                        geoObject.options.set('fillColor', `${rgbPart}${newAlphaHex}`);
                    }
                }
            }
        }
    });
}


function setManualObjectOpacity(opacity) {
    manualObjectOpacity = opacity; // Обновляем глобальное значение
    localStorage.setItem('manualObjectOpacity', opacity); // Сохраняем в localStorage

    // Делаем заливку более прозрачной, чем контур
    const fillOpacity = opacity * 0.4;

    // Проходим по всем гео-объектам на карте
    map.geoObjects.each(function(geoObject) {
        if (geoObject instanceof ymaps.Polygon || geoObject instanceof ymaps.Polyline) {
            const props = geoObject.properties;
            
            // Флаги, указывающие на то, что объект нарисован вручную
            const isManualObject = props.get('isManuallyDrawn') ||
                                   props.get('isAreaMeasurement') ||
                                   props.get('isDrawableLine') ||
                                   props.get('isSearchShape');

            if (isManualObject) {
                geoObject.options.set('strokeOpacity', opacity);

                const currentFill = geoObject.options.get('fillColor');
                if (currentFill && currentFill !== '#00000000') {
                    geoObject.options.set('fillOpacity', fillOpacity);
                }
            }
        }
    });
}



function isZeroQuarterRequest(numberString) {
    if (!numberString || typeof numberString !== 'string') {
        return false;
    }

    const parts = numberString.trim().split(':');
    
  
    if (parts.length !== 3) {
        return false;
    }

    const regionPart = parts[0];
    const blockPart = parts[2]; 
    
   
    const isSevenDigitsRegion = sevenDigitsRegions.includes(regionPart);
    const expectedZerosLength = isSevenDigitsRegion ? 7 : 6;

    
    if (/^0+$/.test(blockPart) && blockPart.length === expectedZerosLength) {
        return true; 
    }

    return false;
}
        
        const sidebar = document.getElementById('parcel-results-sidebar');
const toggleBtn = document.getElementById('toggle-sidebar-btn');


const standardColors = [
    'blue',    // Синий
    'green',   // Зелёный
    'red',     // Красный
    'yellow',  // Жёлтый
    'black',   // Чёрный
    'gray',    // Серый
    'orange',  // Оранжевый
    'violet'   // Фиолетовый
];

// Объект для хранения счётчиков цвета для каждой метки
const placemarkColorIndices = new Map();

                // Определяем кастомный макет для метки

let ownershipFilterState = 0; // 0: все с заливкой, 1: отфильтрованные с заливкой, 2: отфильтрованные без заливки

// Функция для получения следующего цвета по порядку
function getNextStandardColor(placemark) {
    let colorIndex = placemarkColorIndices.get(placemark) || 0;
    colorIndex = (colorIndex + 1) % standardColors.length; // Циклический переход
    placemarkColorIndices.set(placemark, colorIndex);
    return standardColors[colorIndex];
}

let parcelPlacemarks = [];

function updatePlacemarksVisibility() {
    if (!map || !parcelPlacemarks.length) return;

    const zoom = map.getZoom();
    const projection = map.options.get('projection');
    const visiblePlacemarks = [];

    // Filter placemarks first based on theme/selection
     let filteredPlacemarks = parcelPlacemarks.filter(pm => {
         if (currentTheme === 'use' && selectedVriFromLegend !== null) {
             const vri = pm.polygon?.properties.get('vri') || '(Не указано)';
             return vri === selectedVriFromLegend;
         }
          // --- NEW --- Filter for Ownership
          if (currentTheme === 'ownership' && selectedOwnershipFromLegend !== null) {
               const options = pm.polygon?.properties.get('featureData')?.properties?.options || {};
               const ownership = options.ownership_type || 'Не указано';
               const rightType = options.right_type || 'Не указано';
               const key = `${ownership}|${rightType}`;
               return key === selectedOwnershipFromLegend;
          }
          // --- END NEW ---
           // --- NEW --- Filter for Registration Date
          if (currentTheme === 'registration_date' && selectedRegistrationDateFromLegend !== null) {
               const options = pm.polygon?.properties.get('featureData')?.properties?.options || {};
               const regDate = options.land_record_reg_date || 'Не указана';
               // Check if the date string starts with the selected filter string (allows filtering by year, year-month, or full date)
               return regDate.startsWith(selectedRegistrationDateFromLegend);
          }
          // --- END NEW ---

         return true; // Show all if no filter or theme
     });




    filteredPlacemarks.forEach(placemark => {
        const polygon = placemark.polygon;
        if (!polygon) {
             // console.warn("Placemark without linked polygon:", placemark);
             return; // Skip placemarks without linked polygons
        }

        const coords = placemark.geometry.getCoordinates();
        const pixelCoords = projection.toGlobalPixels(coords, zoom);

        const bounds = polygon.geometry.getBounds();
        if (!bounds || !bounds[0] || !bounds[1]) {
            // console.warn("Polygon without valid bounds:", polygon);
            placemark.options.set('visible', false); // Hide if bounds are invalid
            return;
        }
        const pixelBounds = [
            projection.toGlobalPixels(bounds[0], zoom),
            projection.toGlobalPixels(bounds[1], zoom)
        ];
        const width = Math.abs(pixelBounds[1][0] - pixelBounds[0][0]);
        const height = Math.abs(pixelBounds[1][1] - pixelBounds[0][1]);
        const areaInPixels = width * height;

        // Adjust visibility threshold based on zoom level and pixel area
        const isVisible = (areaInPixels > 500 || zoom > 16); // Labels visible for larger polygons or zoomed in

        if (isVisible) {
            // Check if the placemark is already on the map (prevent re-adding filter placemarks)
            if (map.geoObjects.indexOf(placemark) !== -1) {
                 placemark.options.set('visible', true);
                 const fontSize = Math.max(10, Math.min(16, 8 + zoom * 0.4));
                 const element = placemark.getOverlaySync()?.getLayoutSync()?.getElement()?.querySelector('.custom-placemark');
                 if (element) {
                     element.style.fontSize = `${fontSize}px`;
                 }

                 const textWidth = fontSize * (placemark.properties.get('iconContent')?.length || 0) * 0.6;
                 const textHeight = fontSize * 1.5;
                 visiblePlacemarks.push({
                     placemark,
                     bbox: {
                         left: pixelCoords[0] - textWidth / 2,
                         right: pixelCoords[0] + textWidth / 2,
                         top: pixelCoords[1] - textHeight / 2,
                         bottom: pixelCoords[1] + textHeight / 2
                     }
                 });
            } else {
                 // Should not happen if placemarks are managed correctly
                 // console.warn("Placemark is not on map but should be visible:", placemark);
                 placemark.options.set('visible', false);
            }
        } else {
            placemark.options.set('visible', false);
        }
    });

    // Basic overlap removal for visible labels
    for (let i = 0; i < visiblePlacemarks.length; i++) {
        const current = visiblePlacemarks[i];
        if (!current.placemark.options.get('visible')) continue; // Skip if already hidden by filter or size

        for (let j = 0; j < i; j++) {
            const other = visiblePlacemarks[j];
            if (!other.placemark.options.get('visible')) continue; // Skip if already hidden

            if (
                current.bbox.left < other.bbox.right &&
                current.bbox.right > other.bbox.left &&
                current.bbox.top < other.bbox.bottom &&
                current.bbox.bottom > other.bbox.top
            ) {
                // Overlap detected
                const currentArea = turf.area(turf.polygon([current.placemark.polygon.geometry.getCoordinates()[0].map(coord => [coord[1], coord[0]])]));
                const otherArea = turf.area(turf.polygon([other.placemark.polygon.geometry.getCoordinates()[0].map(coord => [coord[1], coord[0]])]));

                if (currentArea < otherArea) {
                    current.placemark.options.set('visible', false);
                } else {
                    other.placemark.options.set('visible', false);
                }
            }
        }
    }
}


     


      function closeStyleModal() {
    document.getElementById('styleModal').style.display = 'none';
}

        window.addEventListener('click', function (event) {
            const modal = document.getElementById('styleModal');
            if (event.target === modal) {
                modal.style.display = 'none';
            }
        });

function toEPSG3857(latitude, longitude) {
    const RADIUS = 6378137;
    const x = RADIUS * longitude * Math.PI / 180;
    const y = RADIUS * Math.log(Math.tan(Math.PI / 4 + latitude * Math.PI / 360));
    return { x: x, y: y };
}

async function queryCadastralInfo(latitude, longitude) {
    const centerPoint = toEPSG3857(latitude, longitude);
    const centerX = centerPoint.x;
    const centerY = centerPoint.y;
    const polygonSizeMeters = 0.15;
    const halfSize = polygonSizeMeters / 2;
    const minX = centerX - halfSize;
    const minY = centerY - halfSize;
    const maxX = centerX + halfSize;
    const maxY = centerY + halfSize;
    const width = 512;
    const height = 512;
    const i = width / 2;
    const j = height / 2;
    const bbox = `${minX},${minY},${maxX},${maxY}`;
    
    // СТАРАЯ ВЕРСИЯ (v4)
    // const url = `https://nspd.gov.ru/api/aeggis/v4/36048/wms?REQUEST=GetFeatureInfo&QUERY_LAYERS=36048&SERVICE=WMS&VERSION=1.3.0&FORMAT=image%2Fpng%2F&STYLES=&TRANSPARENT=true&LAYERS=36048&RANDOM=${Math.random()}&INFO_FORMAT=application%2Fjson&FEATURE_COUNT=10&I=${i}&J=${j}&WIDTH=${width}&HEIGHT=${height}&CRS=EPSG%3A3857&BBOX=${bbox}`;
    
    // НОВАЯ ВЕРСИЯ (v3)
    const url = `https://nspd.gov.ru/api/aeggis/v3/36048/wms?REQUEST=GetFeatureInfo&QUERY_LAYERS=36048&SERVICE=WMS&VERSION=1.3.0&FORMAT=image%2Fpng&STYLES=&TRANSPARENT=true&LAYERS=36048&RANDOM=${Math.random()}&INFO_FORMAT=application%2Fjson&FEATURE_COUNT=10&I=${i}&J=${j}&WIDTH=${width}&HEIGHT=${height}&CRS=EPSG%3A3857&BBOX=${bbox}`;

    try {
        const response = await fetchNspd(url); 
        const data = await response.json();
        return data;
    } catch (error) {
        console.error('Error fetching cadastral data:', error);
        return null;
    }
}


        function animateMapZoom() {
            const mapElement = document.getElementById('map');

            // Добавляем класс для анимации
            mapElement.classList.add('map-zoom-in');

            // Убираем класс после завершения анимации
            setTimeout(() => {
                mapElement.classList.remove('map-zoom-in');
            }, 500); // Длительность анимации в миллисекундах
        }


        let externalMapsContainer = null;
        
      

function openExternalMaps(event) {
    if (!map) return;

    const button = event.target.closest('.map-mode-button');
    const widgetRect = widget.getBoundingClientRect();

    if (!externalMapsContainer) {
        externalMapsContainer = document.createElement('div');
        externalMapsContainer.className = 'external-maps-container';
        document.body.appendChild(externalMapsContainer);

        const nspdButton = createExternalMapButton('nspd', 'img/nspd.png', '');
        const yandexButton = createExternalMapButton('yandex', 'img/ymap.png', '');
        const googleButton = createExternalMapButton('google', 'img/gmap.png', '');
        const twoGisButton = createExternalMapButton('2gis', 'img/2gis.png', '');
        const exportAllKmlButton = createExternalMapButton('export_all_kml', 'img/emap.png', '');

        [nspdButton, yandexButton, googleButton, twoGisButton, exportAllKmlButton].forEach((btn, index) => {
            btn.classList.add('external-map-button-animation');
            btn.style.animationDelay = `${index * 0.1}s`;
            externalMapsContainer.appendChild(btn);
        });

        document.addEventListener('click', closeExternalMapsContainerOnClickOutside);
    }

    const top = widgetRect.bottom + 10;
    const left = widgetRect.right - externalMapsContainer.offsetWidth;

    externalMapsContainer.style.top = `${top}px`;
    externalMapsContainer.style.left = `${left}px`;
    externalMapsContainer.style.display = 'flex';

    void externalMapsContainer.offsetWidth;
    externalMapsContainer.style.left = `${widgetRect.right - externalMapsContainer.offsetWidth}px`;
}


        function closeExternalMapsContainerOnClickOutside(event) {
            if (externalMapsContainer && !externalMapsContainer.contains(event.target) && event.target.closest('[data-mode="yandex-google"]') === null) {
                externalMapsContainer.style.display = 'none';
            }
        }
        
        
        



function cleanAndFormatAICoordinates(aiText) {
    if (!aiText || aiText.trim() === "") {
        return "";
    }
    // Remove potential markdown backticks
    aiText = aiText.replace(/```plaintext|```csv|```/gi, '').trim();

    const lines = aiText.trim().split('\n');
    const formattedCoords = [];

    for (const line of lines) {
        const parts = line.trim().split(/\s+/); // Split by any whitespace (tab, space)
        if (parts.length === 2) {
            let xStr = parts[0].replace(',', '.');
            let yStr = parts[1].replace(',', '.');
            
            let x = parseFloat(xStr);
            let y = parseFloat(yStr);

            if (!isNaN(x) && !isNaN(y)) {
                // Ensure x < y
                if (x > y) {
                    [x, y] = [y, x];
                }
                // Format to 2 decimal places
                formattedCoords.push(`${x.toFixed(2)}\t${y.toFixed(2)}`);
            }
        }
    }
    return formattedCoords.join('\n');
}
// --- End AI Helper Functions ---
        

function createExternalMapButton(type, imgSrc, hintText) {
    const button = document.createElement('button');
    button.className = 'map-mode-button external-map-button';

    if (hintText) {
        button.title = hintText;
    }

    const img = document.createElement('img');
    img.src = imgSrc;
    img.style.width = '32px';
    img.style.height = '32px';
    button.appendChild(img);

    button.addEventListener('click', (event) => {
        event.stopPropagation();
        const mapCenter = map.getCenter();
        const lat = mapCenter[0];
        const lon = mapCenter[1];
        let url = '';

        if (type === 'yandex') {
            url = `https://yandex.ru/maps/?pt=${lon},${lat}&z=15`;
        } else if (type === 'google') {
            url = `https://www.google.com/maps?q=${lat},${lon}&z=15`;
        } else if (type === '2gis') {
            url = `https://2gis.ru/search/${lat},${lon}/center/${lon},${lat}/zoom/18`;
        } else if (type === 'nspd') {
            const epsg3857Coords = proj4("EPSG:4326", "EPSG:3857", [lon, lat]);
            url = `https://nspd.gov.ru/map?zoom=20&coordinate_x=${epsg3857Coords[0]}&coordinate_y=${epsg3857Coords[1]}&theme_id=1&is_copy_url=true&active_layers=36329%2C36328%2C36049%2C36048`;
        } else if (type === 'export_all_kml') {
            exportAllMapObjectsToKml();
            if (externalMapsContainer) {
                externalMapsContainer.style.display = 'none';
            }
            return;
        }

        if (url) {
            window.open(url, '_blank');
            if (externalMapsContainer) {
                externalMapsContainer.style.display = 'none';
            }
        }
    });

    return button;
}
  


function generateKmlForPlacemark(placemarkObject, placemarkName) {
    const yandexCoords = placemarkObject.geometry.getCoordinates(); // [lat, lon]

    // Корректируем координаты Yandex карты до "истинных" WGS84
    const trueLat = yandexCoords[0] + (mapOffsetY * 0.000008983);
    const trueLon = yandexCoords[1] + (mapOffsetX * 0.000008983);

    // Применяем KML смещения
    const kmlLat = trueLat + (kmlMapOffsetY * 0.000008983);
    const kmlLon = trueLon + (kmlMapOffsetX * 0.000008983);

    const kmlCoordsString = `${kmlLon},${kmlLat},0`; // lon,lat,alt

       let kmlStyleXml = `
      <Style>
        <IconStyle>
          <Icon>
            <href>http://maps.google.com/mapfiles/kml/pushpin/ylw-pushpin.png</href>
          </Icon>
          <hotSpot x="20" y="2" xunits="pixels" yunits="pixels"/>
        </IconStyle>
        <LabelStyle>
          <color>ffffffff</color> <!-- white text -->
          <scale>0.8</scale>
        </LabelStyle>
      </Style>`;

    const preset = placemarkObject.options.get('preset');
    if (preset && preset.includes('StretchyIcon')) {
        let kmlColor = "ffffffff"; // AABBGGRR for KML IconStyle color
        let labelColor = "ffffffff"; // Default label color to white

        if (preset.includes('blue')) { kmlColor = "ffff0000"; labelColor = "ffffffff"; } // Blue icon, white text
        else if (preset.includes('red')) { kmlColor = "ff0000ff"; labelColor = "ffffffff"; } // Red icon, white text
        else if (preset.includes('green')) { kmlColor = "ff00ff00"; labelColor = "ffffffff"; } // Green icon, white text
        else if (preset.includes('yellow')) { kmlColor = "ff00ffff"; labelColor = "ff000000"; } // Yellow icon, black text for contrast
        else if (preset.includes('orange')) { kmlColor = "ff00a5ff"; labelColor = "ffffffff"; } // Orange icon, white text
        else if (preset.includes('violet')) { kmlColor = "ffee82ee"; labelColor = "ffffffff"; } // Violet icon, white text
        
        kmlStyleXml = `
          <Style>
            <IconStyle>
              <color>${kmlColor}</color>
              <Icon><href>http://maps.google.com/mapfiles/kml/paddle/wht-blank.png</href></Icon>
            </IconStyle>
            <LabelStyle>
              <color>${labelColor}</color>
              <scale>0.9</scale>
            </LabelStyle>
          </Style>`;
    } else if (placemarkObject.options.get('iconLayout') === customPlacemarkLayout) {
        // For custom text placemarks, hide icon, style label
        kmlStyleXml = `
          <Style>
            <IconStyle><scale>0</scale></IconStyle> <!-- Hide icon -->
            <LabelStyle>
              <color>ffffffff</color> <!-- ИЗМЕНЕНО: Белый цвет текста для кастомных меток -->
              <scale>1.0</scale>
            </LabelStyle>
          </Style>`;
    }


    return `
    <Placemark>
      <name>${escapeXml(placemarkName)}</name>
      ${kmlStyleXml}
      <Point>
        <coordinates>${kmlCoordsString}</coordinates>
      </Point>
    </Placemark>`;
}

// Вспомогательная функция для генерации KML для draggableText
function generateKmlForDraggableText(draggableTextElement, mapInstance, defaultName) {
    const textContent = draggableTextElement.querySelector('span')?.textContent || defaultName;

    const rect = draggableTextElement.getBoundingClientRect();
    const pageX = rect.left + rect.width / 2 + window.scrollX;
    const pageY = rect.top + rect.height / 2 + window.scrollY;

    let geoCoords; // Это координаты, отображаемые на Yandex карте
    try {
        const globalPixelCoords = mapInstance.converter.pageToGlobal([pageX, pageY]);
        geoCoords = mapInstance.options.get('projection').fromGlobalPixels(globalPixelCoords, mapInstance.getZoom());
    } catch (e) {
        console.error("Error converting draggableText position:", e, draggableTextElement);
        return '';
    }

    if (!geoCoords) return '';

    // Корректируем до "истинных" WGS84
    const trueLatText = geoCoords[0] + (mapOffsetY * 0.000008983);
    const trueLonText = geoCoords[1] + (mapOffsetX * 0.000008983);

    // Применяем KML смещения
    const kmlLatText = trueLatText + (kmlMapOffsetY * 0.000008983);
    const kmlLonText = trueLonText + (kmlMapOffsetX * 0.000008983);

    const kmlCoordsString = `${kmlLonText},${kmlLatText},0`;

    const kmlStyle = `
      <Style>
        <IconStyle>
          <scale>0</scale>
        </IconStyle>
        <LabelStyle>
          <color>ffffffff</color> <!-- ИЗМЕНЕНО: Белый цвет текста для draggableText -->
          <scale>1.0</scale>
        </LabelStyle>
      </Style>`;
    // ... остальная часть функции ...
    return `
    <Placemark>
      <name>${escapeXml(textContent)}</name>
      ${kmlStyle}
      <Point>
        <coordinates>${kmlCoordsString}</coordinates>
      </Point>
    </Placemark>`;
}


     

function openStyleSettings() {
    const styleModal = document.getElementById('styleModal');
    styleModal.style.display = 'block';
    document.getElementById('lineColor').value = polygonStyle.color;
    document.getElementById('parcelsColor').value = polygonStyle.parcelsColor;
    document.getElementById('declaredParcelsColor').value = polygonStyle.declaredParcelsColor;
    document.getElementById('buildingsColor').value = polygonStyle.buildingsColor;
    document.getElementById('structuresColor').value = polygonStyle.structuresColor;

    document.getElementById('lineWidth').value = polygonStyle.width;
    document.getElementById('mapOffsetX').value = mapOffsetX;
    document.getElementById('mapOffsetY').value = mapOffsetY;

    document.getElementById('kmlMapOffsetX').value = kmlMapOffsetX;
    document.getElementById('kmlMapOffsetY').value = kmlMapOffsetY;

   
    const toggleOpenGoogleEarthCheckbox = document.getElementById('toggleOpenGoogleEarth');
    if (toggleOpenGoogleEarthCheckbox) {
        const savedGoogleEarthSetting = localStorage.getItem('openGoogleEarthAfterExport');
        openGoogleEarthAfterExport = savedGoogleEarthSetting === null ? true : (savedGoogleEarthSetting === 'true');
        toggleOpenGoogleEarthCheckbox.checked = openGoogleEarthAfterExport;
    }
  
    const toggleVercelProxyCheckbox = document.getElementById('toggleVercelProxy');
    if (toggleVercelProxyCheckbox) {
     
        toggleVercelProxyCheckbox.checked = useVercelProxyFeature;
    }
  
    const toggleHeightLabelCheckbox = document.getElementById('toggleHeightLabel');
    if (toggleHeightLabelCheckbox) {
        toggleHeightLabelCheckbox.checked = isCameraHeightLabelVisible;
    }
 
}
        
 function updateKmlMapOffset() {
            // --- НАЧАЛО ИЗМЕНЕНИЙ ---
            // Принудительно заменяем запятую на точку перед парсингом
            const kmlOffsetXValue = document.getElementById('kmlMapOffsetX').value.replace(',', '.');
            const kmlOffsetYValue = document.getElementById('kmlMapOffsetY').value.replace(',', '.');

            kmlMapOffsetX = parseFloat(kmlOffsetXValue) || 0;
            kmlMapOffsetY = parseFloat(kmlOffsetYValue) || 0;
            // --- КОНЕЦ ИЗМЕНЕНИЙ ---
            
            localStorage.setItem('kmlMapOffsetX', kmlMapOffsetX);
            localStorage.setItem('kmlMapOffsetY', kmlMapOffsetY);
            // Не вызываем findAndConvert(), так как это только для KML экспорта
        }

        // START: New function to update Google Earth setting
        function updateGoogleEarthSetting() {
            const checkbox = document.getElementById('toggleOpenGoogleEarth');
            if (checkbox) {
                openGoogleEarthAfterExport = checkbox.checked;
                localStorage.setItem('openGoogleEarthAfterExport', openGoogleEarthAfterExport);
            }
        }
        
function showLoader(message = "Загрузка...") {
    const loaderContainer = document.getElementById('loaderContainer');
    const loadingText = document.querySelector('.loading-text'); // Make sure this element exists in your HTML
    if (loadingText) loadingText.textContent = message;
    if (loaderContainer) loaderContainer.style.display = 'flex';
}

function hideLoader() {
    const loaderContainer = document.getElementById('loaderContainer');
    if (loaderContainer) loaderContainer.style.display = 'none';
}



const STORAGE_API_URL = 'https://mapruapp.ru/storage';
const BUCKET_NAME = 'kpt';

const supabaseUrl = 'https://vznsatvyikahngdfvqho.supabase.co'; 
const supabaseAnonKey = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InZ6bnNhdHZ5aWthaG5nZGZ2cWhvIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDU0MjM3MDMsImV4cCI6MjA2MDk5OTcwM30.FJmk0lgIjqvcdV7p6C0riaxqS9QWKAuIHDZtkMYMJe4';

const { createClient } = supabase;
const supabaseClient = createClient(supabaseUrl, supabaseAnonKey);

// Helper function to generate the ZIP blob (extracted from export function)
async function generateParcelDataZipBlob(features, internalJsonFilename) {
    if (!features || features.length === 0) {
        throw new Error("Нет данных для создания ZIP.");
    }

    const jsonData = JSON.stringify(features, null, 2);

    const zip = new JSZip();
    zip.file(internalJsonFilename, jsonData);

    const zipBlob = await zip.generateAsync({
        type: "blob",
        compression: "DEFLATE",
        compressionOptions: {
            level: 9 // Max compression level
        }
    });

    return zipBlob;
}

async function uploadNspdDataToLocalServer(features, quarterNumber) {
    if (!features || features.length === 0) {

        return;
    }
    if (!quarterNumber) {
        console.error("Не указан номер квартала для создания имени файла, выгрузка отменена.");
        return;
    }


    try {
        const quarterName = quarterNumber.replace(/:/g, '_');
        const today = new Date();
        const dateString = today.getFullYear() + '-' +
                       String(today.getMonth() + 1).padStart(2, '0') + '-' +
                       String(today.getDate()).padStart(2, '0');
        
        const zipFilename = `${quarterName}.nspd`;
        const internalJsonFilename = `${quarterName} ${dateString}.json`;

        const jsonData = JSON.stringify(features, null, 2);
        const zip = new JSZip();
        zip.file(internalJsonFilename, jsonData);
        
        const zipBlob = await zip.generateAsync({
            type: "blob",
            compression: "DEFLATE",
            compressionOptions: {
                level: 9
            }
        });

        const formData = new FormData();
        formData.append('file', new File([zipBlob], zipFilename, { type: 'application/zip' }));

        const response = await fetch(`${STORAGE_API_URL}/nspd/upload`, {
            method: 'POST',
            body: formData,
        });

        if (!response.ok) {
            // Если сервер вернул ошибку, пытаемся прочитать ее и выбросить
            const errorData = await response.json().catch(() => null); // .catch на случай, если ответ не JSON
            throw new Error(errorData?.error || `Сервер ответил ошибкой: ${response.statusText}`);
        }
        
        const responseData = await response.json();

       

    } catch (error) {
       
        console.error(`ФОНОВАЯ ОШИБКА: Не удалось выгрузить данные. Причина:`, error.message);
    }
}


function updatePolygonStyle() {
    // Получаем значения из элементов управления
    polygonStyle.color = document.getElementById('lineColor').value;
    polygonStyle.width = parseInt(document.getElementById('lineWidth').value);
    polygonStyle.parcelsColor = document.getElementById('parcelsColor').value;
    polygonStyle.declaredParcelsColor = document.getElementById('declaredParcelsColor').value;
    polygonStyle.buildingsColor = document.getElementById('buildingsColor').value;
    polygonStyle.structuresColor = document.getElementById('structuresColor').value;
     
    // Сохраняем актуальные значения в localStorage
    localStorage.setItem('polygonColor', polygonStyle.color);
    localStorage.setItem('polygonWidth', polygonStyle.width);
    localStorage.setItem('parcelsColor', polygonStyle.parcelsColor);
    localStorage.setItem('declaredParcelsColor', polygonStyle.declaredParcelsColor);
    localStorage.setItem('buildingsColor', polygonStyle.buildingsColor); // Гарантированное сохранение
    localStorage.setItem('structuresColor', polygonStyle.structuresColor); // Гарантированное сохранение
 
    // Перерисовываем объекты на карте с новыми стилями
    if (polygons && polygons.length > 0) {
        polygons.forEach(polygon => {
            if (polygon instanceof ymaps.Polygon) {
                if (polygon.properties.get('isParcelInQuarter') || polygon.properties.get('isFoundInArea')) {
                     const featureData = polygon.properties.get('featureData');
                     const parcelOptions = featureData?.properties?.options || {};
                     const isVerified = parcelOptions.specified_area || parcelOptions.land_record_area_verified;
                     const hasDeclaredField = parcelOptions.declared_area || parcelOptions.land_record_area_declaration || parcelOptions.land_record_area;
                     const isDeclared = !isVerified && hasDeclaredField;
                     const strokeColor = isDeclared ? polygonStyle.declaredParcelsColor : polygonStyle.parcelsColor;
                    
                    polygon.options.set({
                        strokeColor: strokeColor,
                        strokeWidth: polygonStyle.width - 1
                    });
                } 
                else if (polygon.properties.get('isBuilding')) { // Проверяем флаг для Зданий
                    polygon.options.set({
                        strokeColor: polygonStyle.buildingsColor, // Применяем цвет для Зданий
                        strokeWidth: polygonStyle.width - 1
                    });
                } 
                else if (polygon.properties.get('isStructure')) { // Проверяем флаг для Сооружений
                    polygon.options.set({
                        strokeColor: polygonStyle.structuresColor, // Применяем цвет для Сооружений
                        strokeWidth: polygonStyle.width - 1
                    });
                } 
                else if (polygon.options.get('strokeStyle') !== 'dash') {
                    polygon.options.set({
                        strokeColor: polygonStyle.color,
                        strokeWidth: polygonStyle.width
                    });
                }
            }
        });
    }
    // Применяем текущую тематическую раскраску, если она активна
    applyCurrentTheme(); 
}

function updateMapOffset() {
            // --- НАЧАЛО ИЗМЕНЕНИЙ ---
            // Принудительно заменяем запятую на точку перед парсингом
            const offsetXValue = document.getElementById('mapOffsetX').value.replace(',', '.');
            const offsetYValue = document.getElementById('mapOffsetY').value.replace(',', '.');

            mapOffsetX = parseFloat(offsetXValue) || 0; // Используем || 0 для защиты от NaN
            mapOffsetY = parseFloat(offsetYValue) || 0;
            // --- КОНЕЦ ИЗМЕНЕНИЙ ---
            
            localStorage.setItem('mapOffsetX', mapOffsetX);
            localStorage.setItem('mapOffsetY', mapOffsetY);
            findAndConvert();
        }


        proj4.defs("EPSG:3857", "+proj=merc +a=6378137 +b=6378137 +lat_ts=0.0 +lon_0=0.0 +x_0=0.0 +y_0=0 +k=1.0 +units=m +nadgrids=@null +wktext +no_defs");
        proj4.defs("EPSG:4326", "+proj=longlat +datum=WGS84 +no_defs");
        proj4.defs("MSK16_ZONE2",
            "+proj=tmerc " +
            "+lat_0=0 " +
            "+lon_0=52.033333333333 " +
            "+k=1 " +
            "+x_0=2300000 " +
            "+y_0=-5709414.70 " +
            "+ellps=krass " +
            "+towgs84=23.57,-140.95,-79.8,0,-0.35,-0.79,-0.22 " +
            "+units=m " +
            "+no_defs " +
            "+axis=enu"
        );

        proj4.defs("MSK16_ZONE1",
            "+proj=tmerc " +
            "+lat_0=0 " +
            "+lon_0=49.033333333333 " +
            "+k=1 " +
            "+x_0=1300000 " +
            "+y_0=-5709414.70 " +
            "+ellps=krass " +
            "+towgs84=23.57,-140.95,-79.8,0,-0.35,-0.79,-0.22 " +
            "+units=m " +
            "+no_defs " +
            "+axis=enu"
        );


function parseCoordinates(text) {
    if (!text || typeof text !== 'string') {
        return [];
    }
    
    try {
        // Разделяем на группы по пустым строкам
        const groups = text.split(/\n\s*\n/)
            .map(group => group.trim())
            .filter(group => group !== '');
        
        return groups.map(group => {
            const lines = group.split('\n')
                .map(line => line.trim())
                .filter(line => line !== '');
            
            return lines.map(line => {
                const parts = line.split(/[\s\t]+/);
                
                if (parts.length < 2) {
                    console.warn(`Пропущена некорректная строка: "${line}"`);
                    return null;
                }
                
                const x = parseFloat(parts[0]);
                const y = parseFloat(parts[1]);
                
                if (!isFinite(x) || !isFinite(y)) {
                    console.warn(`Пропущены некорректные координаты: x=${parts[0]}, y=${parts[1]}`);
                    return null;
                }
                
                return [x, y];
            }).filter(coord => coord !== null);
        }).filter(group => group.length > 0);
    } catch (e) {
        console.error('Ошибка при разборе координат:', e);
        return [];
    }
}


function generateKmlForSinglePolygon(polygonObject, placemarkNameOverride = null) {
    const yandexCoordsSmeschennyeNaKarte = polygonObject.geometry.getCoordinates()[0];

    // --- ВОЗВРАЩАЕМ КООРДИНАТЫ К ИСТИННЫМ WGS84, "УБИРАЯ" ТВОЮ КОМПЕНСАЦИЮ ---
    const istinnyeWGS84Coords = yandexCoordsSmeschennyeNaKarte.map(coord => {
        return [
            coord[0] + (mapOffsetY * 0.000008983),
            coord[1] + (mapOffsetX * 0.000008983)
        ];
    });

    // --- ПРИМЕНЯЕМ KML СМЕЩЕНИЯ К "ИСТИННЫМ" WGS84 КООРДИНАТАМ ---
    const kmlAdjustedWGS84Coords = istinnyeWGS84Coords.map(coord => {
        return [
            coord[0] + (kmlMapOffsetY * 0.000008983), // KML широта (+/- в зависимости от знака kmlMapOffsetY)
            coord[1] + (kmlMapOffsetX * 0.000008983)  // KML долгота (+/- в зависимости от знака kmlMapOffsetX)
        ];
    });
    // --- КОНЕЦ ПРИМЕНЕНИЯ KML СМЕЩЕНИЙ ---

    // Используем kmlAdjustedWGS84Coords для генерации KML
    const kmlCoordsArray = kmlAdjustedWGS84Coords.map(coord => `${coord[1]},${coord[0]},0`);

    // --- Важно: Убедимся, что полигон замкнут с kmlAdjustedWGS84Coords ---
    if (kmlCoordsArray.length > 0 &&
        (kmlAdjustedWGS84Coords[0][0] !== kmlAdjustedWGS84Coords[kmlAdjustedWGS84Coords.length - 1][0] ||
         kmlAdjustedWGS84Coords[0][1] !== kmlAdjustedWGS84Coords[kmlAdjustedWGS84Coords.length - 1][1])) {
        kmlCoordsArray.push(`${kmlAdjustedWGS84Coords[0][1]},${kmlAdjustedWGS84Coords[0][0]},0`);
    }
    // --- КОНЕЦ ВАЖНОЙ ПРОВЕРКИ ---

    const kmlCoordsString = kmlCoordsArray.join(' ');

    const placemarkName = placemarkNameOverride ||
                          polygonObject.properties.get('cadastralNumber') ||
                          polygonObject.properties.get('hintContent')?.cadastralNumber ||
                          'Polygon';
    const safePlacemarkName = placemarkName.replace(/[^a-zA-Z0-9_.:-]/g, '_');

    let kmlStrokeColor = "ff0000ff";
    let kmlFillColor = "00000000";
    let kmlFillEnabled = 0;
    const kmlStrokeWidth = polygonObject.options.get('strokeWidth') || 2;

    const originalStrokeColor = polygonObject.options.get('strokeColor');
    if (originalStrokeColor) {
        if (originalStrokeColor.length === 7) {
            kmlStrokeColor = `ff${originalStrokeColor.substring(5, 7)}${originalStrokeColor.substring(3, 5)}${originalStrokeColor.substring(1, 3)}`;
        } else if (originalStrokeColor.length === 9) {
            kmlStrokeColor = `${originalStrokeColor.substring(7, 9)}${originalStrokeColor.substring(5, 7)}${originalStrokeColor.substring(3, 5)}${originalStrokeColor.substring(1, 3)}`;
        }
    }

    const originalFillColor = polygonObject.options.get('fillColor');
    if (originalFillColor && originalFillColor !== '#00000000') {
        kmlFillEnabled = 1;
        if (originalFillColor.length === 7) {
            kmlFillColor = `ff${originalFillColor.substring(5, 7)}${originalFillColor.substring(3, 5)}${originalFillColor.substring(1, 3)}`;
        } else if (originalFillColor.length === 9) {
            kmlFillColor = `${originalFillColor.substring(7, 9)}${originalFillColor.substring(5, 7)}${originalFillColor.substring(3, 5)}${originalFillColor.substring(1, 3)}`;
        } else if (originalFillColor.length === 4) {
            const r = originalFillColor[1]; const g = originalFillColor[2]; const b = originalFillColor[3];
            kmlFillColor = `ff${b}${b}${g}${g}${r}${r}`;
        } else if (originalFillColor.length === 5) {
            const r = originalFillColor[1]; const g = originalFillColor[2]; const b = originalFillColor[3]; const a = originalFillColor[4];
            kmlFillColor = `${a}${a}${b}${b}${g}${g}${r}${r}`;
        }
    }

    return `
    <Placemark>
      <name>${escapeXml(placemarkName)}</name>
      <Style>
        <LineStyle>
          <color>${kmlStrokeColor}</color>
          <width>${kmlStrokeWidth}</width>
        </LineStyle>
        <PolyStyle>
          <color>${kmlFillColor}</color>
          <fill>${kmlFillEnabled}</fill>
          <outline>1</outline>
        </PolyStyle>
      </Style>
      <Polygon>
        <outerBoundaryIs>
          <LinearRing>
            <coordinates>
              ${kmlCoordsString}
            </coordinates>
          </LinearRing>
        </outerBoundaryIs>
      </Polygon>
    </Placemark>`;
}


// Helper to escape XML special characters for KML content
function escapeXml(unsafe) {
    if (typeof unsafe !== 'string') return '';
    return unsafe.replace(/[<>&'"]/g, function (c) {
        switch (c) {
            case '<': return '&lt;';
            case '>': return '&gt;';
            case '&': return '&amp;';
            case '\'': return '&apos;';
            case '"': return '&quot;';
        }
        return c; // Должно быть здесь, на случай если символ не требует замены
    });
}

function autoUpdateMskSettings(cadastralNumber) {
    // 1. Проверяем, включена ли опция в настройках.
    // Читаем из localStorage, так как модальное окно может быть не открыто.
    const isAutoLoadEnabled = (localStorage.getItem('autoLoadMskOffset') !== 'false');
    if (!isAutoLoadEnabled) {
        console.log("Автообновление МСК отключено в настройках.");
        return; // Выходим, если опция выключена
    }

    // 2. Проверяем, что все нужные скрипты загружены
    if (typeof MskFinder === 'undefined' || typeof COORDINATE_SYSTEMS === 'undefined') {
        console.error("Необходимые для автоопределения МСК данные (MskFinder или COORDINATE_SYSTEMS) не загружены.");
        return;
    }

    // 3. Используем MskFinder для поиска кода (например, "16-2")
    const mskCode = MskFinder.findMskCode(cadastralNumber);
    if (!mskCode) {
        console.log(`Код МСК для '${cadastralNumber}' не найден в msk-data.js.`);
        return; // Ничего не делаем, если код не найден
    }

    // 4. Ищем соответствующую систему координат в sk.js
    const searchString = `МСК ${mskCode}`; // Формируем строку для поиска, например, "МСК 16-2"
    const foundSystem = COORDINATE_SYSTEMS.find(system => system.text.includes(searchString));

    if (foundSystem) {
        const currentDefaultMsk = localStorage.getItem('savedDefaultMskSystem');
        
        // 5. Обновляем настройки, только если найденная система отличается от текущей
        if (currentDefaultMsk !== foundSystem.value) {
            // Сохраняем новую МСК по умолчанию
            localStorage.setItem('savedDefaultMskSystem', foundSystem.value);

            // Сохраняем смещения, связанные с этой новой МСК
            const newOffsetX = String(foundSystem.offsetX || '0').replace(',', '.');
            const newOffsetY = String(foundSystem.offsetY || '0').replace(',', '.');
            localStorage.setItem('savedMskOffsetX', newOffsetX);
            localStorage.setItem('savedMskOffsetY', newOffsetY);
            
            // Уведомляем пользователя
            const systemName = foundSystem.text.split('(')[0].trim();
            showNotification(`МСК по умолчанию обновлена: ${systemName}`, 'success', 'info-circle');
            console.log(`Настройки МСК обновлены на ${foundSystem.value}. Смещения: X=${newOffsetX}, Y=${newOffsetY}`);
        }
    } else {
        console.warn(`Не удалось найти СК для кода '${mskCode}' в файле sk.js.`);
    }
}

       function showNotification(message, type = 'success', icon = 'info-circle', duration = 3000) {
            // Удаляем предыдущее уведомление, если оно есть
            const existingNotification = document.querySelector('.notification');
            if (existingNotification) {
                existingNotification.remove();
            }

            // Создаем новое уведомление
            const notification = document.createElement('div');
            notification.className = `notification ${type}`;
            notification.innerHTML = `
        <i class="fas fa-${icon}"></i>
        ${message}
    `;
            document.body.appendChild(notification);

            // Показываем уведомление
            setTimeout(() => notification.classList.add('show'), 10);

            // Скрываем и удаляем через заданное время (duration)
            setTimeout(() => {
                notification.classList.remove('show');
                setTimeout(() => notification.remove(), 500);
            }, duration);
        }
        
        function removeEmptyLinesFromCoordsInput() {
    const coordsText = coordsInput.value;
    const cleanedCoordsText = coordsText.split('\n')
                                       .filter(line => line.trim() !== '')
                                       .join('\n');
    coordsInput.value = cleanedCoordsText;
}

function findAndConvert() {
    if (!map) {
        console.error('Карта не инициализирована');
        return;
    }

    try {
        const coordsText = coordsInput.value.trim();
        if (!coordsText) return;

        animateMapZoom();
        const coordGroups = parseCoordinates(coordsText);
        if (coordGroups.length === 0) return;

        let geoGroups = [];
        const detectedMskSystem = findMskSystemByTemplate(coordsText);

        if (detectedMskSystem) {
            // Эта часть кода для автоопределения по шаблону, она уже работает с учетом смещений,
            // поэтому оставляем ее как есть.
            const sourceSc = detectedMskSystem;
            console.log(`Применяется СК, найденная по шаблону: ${sourceSc}`);
            const sourceDef = COORDINATE_SYSTEMS.find(s => s.value === sourceSc)?.def;
            if (!sourceDef) throw new Error(`Определение для ${sourceSc} не найдено в sk.js`);
            proj4.defs(sourceSc, sourceDef);
            const selectedSystem = COORDINATE_SYSTEMS.find(s => s.value === sourceSc);
            const offsetX = selectedSystem?.offsetX || 0;
            const offsetY = selectedSystem?.offsetY || 0;
            coordGroups.forEach(group => {
                const geoGroup = group.map(coord => {
                    const inputForProj4 = [coord[1], coord[0]];
                    const point3857 = proj4(sourceSc, "EPSG:3857", inputForProj4);
                    point3857[0] += offsetX;
                    point3857[1] += offsetY;
                    const finalWgs84 = proj4("EPSG:3857", "EPSG:4326", point3857);
                    return [finalWgs84[1], finalWgs84[0]];
                });
                geoGroups.push(geoGroup);
            });
        
        } else {
            // --- ОСНОВНАЯ ЛОГИКА И ИСПРАВЛЕНИЯ ЗДЕСЬ ---
            console.log("Шаблоны не сработали, используется стандартное определение СК.");
            const firstCoord = coordGroups[0][0];
            const x = firstCoord[0];
            const y = firstCoord[1];
            
            const hasLongDecimal = (num) => num.toString().includes('.') && num.toString().split('.')[1].length > 3;

            if (Math.abs(x) > 100 && Math.abs(y) > 100 && (hasLongDecimal(x) || hasLongDecimal(y))) {
                console.log("Определена система: EPSG:3857 (по формату)");
                coordGroups.forEach(group => {
                    const geoGroup = group.map(coord => {
                        const wgs84 = proj4("EPSG:3857", "EPSG:4326", [coord[0], coord[1]]);
                        return [wgs84[1], wgs84[0]];
                    });
                    geoGroups.push(geoGroup);
                });
            }
            else if ((Math.abs(x) <= 90 && Math.abs(y) <= 180) || (Math.abs(x) <= 180 && Math.abs(y) <= 90)) {
                console.log("Определена система: WGS84 (географические)");
                const needsSwap = Math.abs(x) > 90;
                coordGroups.forEach(group => {
                    const geoGroup = group.map(coord => {
                        const lon = needsSwap ? coord[0] : coord[1];
                        const lat = needsSwap ? coord[1] : coord[0];
                        return [lat, lon];
                    });
                    geoGroups.push(geoGroup);
                });
            }
            else {
                // --- НАЧАЛО ИСПРАВЛЕНИЙ ---
                const sourceSc = localStorage.getItem('savedDefaultMskSystem') || 'EPSG:6331602';
                console.log(`Определена система: МСК (по умолчанию из localStorage), используется ${sourceSc}`);

                const destSystem = COORDINATE_SYSTEMS.find(s => s.value === sourceSc);
                if (!destSystem || !destSystem.def) {
                    throw new Error(`Определение для ${sourceSc} не найдено в sk.js`);
                }

                let mskOffsetX = 0;
                let mskOffsetY = 0;
                const isAutoLoadEnabled = (localStorage.getItem('autoLoadMskOffset') !== 'false');

                if (isAutoLoadEnabled) {
                    mskOffsetX = destSystem.offsetX || 0;
                    mskOffsetY = destSystem.offsetY || 0;
                    console.log(`[findAndConvert] Автозагрузка смещения: включена. Смещения из sk.js для ${sourceSc}: X=${mskOffsetX}, Y=${mskOffsetY}`);
                } else {
                    const offsetXRaw = localStorage.getItem('savedMskOffsetX') || '0';
                    const offsetYRaw = localStorage.getItem('savedMskOffsetY') || '0';
                    mskOffsetX = parseFloat(offsetXRaw.replace(',', '.')) || 0;
                    mskOffsetY = parseFloat(offsetYRaw.replace(',', '.')) || 0;
                    console.log(`[findAndConvert] Автозагрузка смещения: выключена. Используются сохраненные вручную смещения: X=${mskOffsetX}, Y=${mskOffsetY}`);
                }
                
                const sourceDef = destSystem.def;
                proj4.defs(sourceSc, sourceDef);
                // --- КОНЕЦ ИСПРАВЛЕНИЙ ---

                geoGroups = coordGroups.map(group => {
                    return group.map(coord => {
                        const x_input_msk = coord[0]; 
                        const y_input_msk = coord[1];

                        console.log(`--- [findAndConvert] Начало конвертации точки ---`);
                        console.log(`Шаг 1: Исходные МСК: X=${x_input_msk.toFixed(4)}, Y=${y_input_msk.toFixed(4)}`);
                        console.log(`Шаг 2: Загруженное смещение: mskOffsetX = ${mskOffsetX}, mskOffsetY = ${mskOffsetY}`);

                        const corrected_x_msk = x_input_msk - mskOffsetX;
                        const corrected_y_msk = y_input_msk - mskOffsetY;

                        console.log(`Шаг 3: Скорректированные МСК (X-mskOffsetX, Y-mskOffsetY): X=${corrected_x_msk.toFixed(4)}, Y=${corrected_y_msk.toFixed(4)}`);

                        const point3857 = proj4(sourceSc, "EPSG:3857", [corrected_y_msk, corrected_x_msk]);
                        
                        console.log(`Шаг 4: Промежуточный результат в EPSG:3857: X=${point3857[0].toFixed(4)}, Y=${point3857[1].toFixed(4)}`);

                        const finalWgs84 = proj4("EPSG:3857", "EPSG:4326", point3857);
                        console.log(`Шаг 5: Финальный результат в WGS84 (для карты): lat=${finalWgs84[1].toFixed(8)}, lon=${finalWgs84[0].toFixed(8)}`);
                        console.log(`--- [findAndConvert] Конец конвертации точки ---`);
                        
                        return [finalWgs84[1], finalWgs84[0]]; // [lat, lon]
                    });
                });
            }
        }
        
        fillAuxiliaryTextareas(coordGroups, geoGroups);
        drawFeatures(geoGroups);

    } catch (error) {
        console.error('Ошибка обработки координат:', error);
        convertedTextarea.value = "Ошибка: " + error.message;
        geoTextarea.value = "";
        showNotification('Ошибка обработки координат', 'error', 'exclamation-circle');
    }
}



function startBindingProcess() {
    
    if (!rasterOverlay) {
        showNotification('Сначала добавьте растровое изображение', 'warning');
        return;
    }
    if (bindingState !== 0) {
        stopBindingProcess(); // Отменяем предыдущий процесс, если он был запущен
    }

    bindingState = 1;
    bindingPoints = { raster: [], map: [] };
    
    // <<< ИСПРАВЛЕНО: Растр должен быть ПРОЗРАЧНЫМ для кликов, чтобы событие дошло до карты >>>
    rasterOverlay.options.set('interactivityModel', 'default#transparent');
    
    map.behaviors.disable('drag'); // Отключаем перетаскивание карты
    map.options.set('cursor', 'crosshair'); // Устанавливаем курсор-перекрестие

    showNotification('Шаг 1: Укажите первую точку на РАСТРЕ', 'info', 'mouse-pointer', 10000);
    map.events.add('click', handleBindingClick);
    document.addEventListener('keydown', handleBindingKeyDown);
}

function stopBindingProcess() {
    bindingState = 0;
    if (rasterOverlay) {
        // Возвращаем растр в неинтерактивное состояние
        rasterOverlay.options.set('interactivityModel', 'default#transparent');
    }
    map.behaviors.enable('drag'); // Включаем перетаскивание карты обратно
    map.options.set('cursor', 'grab'); // <<< ИСПРАВЛЕНО: Возвращаем стандартный курсор-руку
    map.events.remove('click', handleBindingClick);
    document.removeEventListener('keydown', handleBindingKeyDown);
    showNotification('Процесс привязки отменен', 'warning');
}

function handleBindingKeyDown(e) {
    if (e.key === 'Escape') {
        stopBindingProcess();
    }
}

function handleBindingClick(e) {
    e.preventDefault();
    const clickCoords = e.get('coords'); // Гео-координаты клика

    switch (bindingState) {
        case 1: // Ожидание первой точки на растре
        case 2: // Ожидание второй точки на растре
            // Проверяем, был ли клик внутри растра
            if (!rasterOverlay.geometry.contains(clickCoords)) {
                showNotification(`Клик был вне растра. Пожалуйста, укажите точку на ИЗОБРАЖЕНИИ`, 'error', 5000);
                return;
            }
            
            // Конвертируем гео-координаты клика в относительные координаты растра (от 0.0 до 1.0)
            const projection = map.options.get('projection');
            const zoom = map.getZoom();
            const rasterBounds = rasterOverlay.geometry.getBounds(); 
            
            // <<< НАЧАЛО ИСПРАВЛЕНИЯ: Корректное определение углов из getBounds() >>>
            // getBounds() возвращает [[minLat, minLon], [maxLat, maxLon]] (юго-запад, северо-восток).
            // Нам нужны левый верхний и правый нижний углы для правильного расчета.
            const minLat = rasterBounds[0][0], minLon = rasterBounds[0][1];
            const maxLat = rasterBounds[1][0], maxLon = rasterBounds[1][1];

            const topLeftGeo = [maxLat, minLon];       // Верхний-левый угол
            const bottomRightGeo = [minLat, maxLon];   // Нижний-правый угол
            // <<< КОНЕЦ ИСПРАВЛЕНИЯ >>>

            const topLeftPixel = projection.toGlobalPixels(topLeftGeo, zoom);
            const bottomRightPixel = projection.toGlobalPixels(bottomRightGeo, zoom);
            const clickPixel = projection.toGlobalPixels(clickCoords, zoom);

            const pixelWidth = Math.abs(bottomRightPixel[0] - topLeftPixel[0]);
            const pixelHeight = Math.abs(bottomRightPixel[1] - topLeftPixel[1]);

            // Проверяем, чтобы не было деления на ноль
            if (pixelWidth === 0 || pixelHeight === 0) {
                showNotification('Ошибка: растр имеет нулевой размер.', 'error');
                stopBindingProcess();
                return;
            }

            const relativeX = (clickPixel[0] - topLeftPixel[0]) / pixelWidth;
            const relativeY = (clickPixel[1] - topLeftPixel[1]) / pixelHeight;

            bindingPoints.raster.push([relativeX, relativeY]);

            if (bindingState === 1) {
                bindingState = 2;
                showNotification('Шаг 2: Укажите вторую точку на РАСТРЕ', 'info', 'mouse-pointer', 10000);
            } else {
                bindingState = 3;
                showNotification('Шаг 3: Укажите первую точку на КАРТЕ', 'info', 'map-marker-alt', 10000);
            }
            break;

        case 3: // Ожидание первой точки на карте
            bindingPoints.map.push(clickCoords);
            bindingState = 4;
            showNotification('Шаг 4: Укажите вторую точку на КАРТЕ', 'info', 'map-marker-alt', 10000);
            break;

        case 4: // Ожидание второй точки на карте и выполнение привязки
            bindingPoints.map.push(clickCoords);
            performRasterBinding();
            break;
    }
}

function performRasterBinding() {
    showLoader('Выполняется привязка растра...');
    try {
        const { raster, map: mapPoints } = bindingPoints;
        const projection = map.options.get('projection');
        const zoom = map.getZoom();

        // 1. Вектор на растре в относительных единицах
        const rasterVectorRel = [raster[1][0] - raster[0][0], raster[1][1] - raster[0][1]];
        // Вектор на растре в пикселях исходного изображения
        const rasterVectorImgPx = [rasterVectorRel[0] * rasterImageSize.width, rasterVectorRel[1] * rasterImageSize.height];

        // 2. Вектор на карте в глобальных пикселях
        const mapP1_px = projection.toGlobalPixels(mapPoints[0], zoom);
        const mapP2_px = projection.toGlobalPixels(mapPoints[1], zoom);
        const mapVectorPx = [mapP2_px[0] - mapP1_px[0], mapP2_px[1] - mapP1_px[1]];

        // 3. Рассчитываем масштаб
        const rasterVectorLength = Math.sqrt(rasterVectorImgPx[0]**2 + rasterVectorImgPx[1]**2);
        const mapVectorLength = Math.sqrt(mapVectorPx[0]**2 + mapVectorPx[1]**2);
        const scale = mapVectorLength / rasterVectorLength;

        // 4. Рассчитываем угол поворота (в радианах)
        const rasterAngle = Math.atan2(rasterVectorImgPx[1], rasterVectorImgPx[0]);
        const mapAngle = Math.atan2(mapVectorPx[1], mapVectorPx[0]);
        const rotationRad = mapAngle - rasterAngle;
        const rotationDeg = rotationRad * 180 / Math.PI;

        // 5. Рассчитываем новые координаты углов растра
        const cornersRel = [[0, 0], [1, 0], [1, 1], [0, 1]]; // TL, TR, BR, BL
        const newCornersGeo = cornersRel.map(corner => {
            // Вектор от первой точки растра до угла в пикселях изображения
            const cornerVecImgPx = [(corner[0] - raster[0][0]) * rasterImageSize.width, (corner[1] - raster[0][1]) * rasterImageSize.height];
            // Масштабируем
            const scaledVec = [cornerVecImgPx[0] * scale, cornerVecImgPx[1] * scale];
            // Поворачиваем
            const rotatedVec = [
                scaledVec[0] * Math.cos(rotationRad) - scaledVec[1] * Math.sin(rotationRad),
                scaledVec[0] * Math.sin(rotationRad) + scaledVec[1] * Math.cos(rotationRad)
            ];
            // Находим итоговую позицию угла в глобальных пикселях
            const finalCornerPx = [mapP1_px[0] + rotatedVec[0], mapP1_px[1] + rotatedVec[1]];
            // Конвертируем обратно в гео-координаты
            return projection.fromGlobalPixels(finalCornerPx, zoom);
        });

        // 6. Создаем новый полигон с изображением
        const newPolygonOverlay = new ymaps.Polygon([newCornersGeo], {}, {
            fillImageHref: rasterOverlay.options.get('fillImageHref'),
            fillMethod: 'stretch',
            stroke: false,
            opacity: rasterOverlay.options.get('opacity'),
           interactivityModel: 'default#transparent', // Возвращаем в неинтерактивное состояние
zIndex: 400
        });
        
        // 7. Заменяем старый оверлей новым
        map.geoObjects.remove(rasterOverlay);
        rasterOverlay = newPolygonOverlay;
        map.geoObjects.add(rasterOverlay);
        
        showNotification('Растр успешно привязан!', 'success');

    } catch (error) {
        console.error("Ошибка привязки растра:", error);
        showNotification('Ошибка привязки растра', 'error');
    } finally {
        bindingState = 0;
        map.behaviors.enable('drag'); // Включаем перетаскивание карты
        map.options.set('cursor', 'grab'); // <<< ИСПРАВЛЕНО: Возвращаем стандартный курсор-руку
        map.events.remove('click', handleBindingClick);
        document.removeEventListener('keydown', handleBindingKeyDown);
        hideLoader();
    }
}


function getRasterCorners() {
    if (!rasterOverlay) return null;

    const geometry = rasterOverlay.geometry;
    const coords = geometry.getCoordinates();
    const type = geometry.getType();

    if (type === 'Rectangle') {
        const topLeft = coords[0];
        const bottomRight = coords[1];
        // Рассчитываем остальные углы
        const topRight = [topLeft[0], bottomRight[1]]; // maxLat, maxLon
        const bottomLeft = [bottomRight[0], topLeft[1]]; // minLat, minLon
        return [topLeft, topRight, bottomRight, bottomLeft]; // Возвращаем в порядке обхода
    } else if (type === 'Polygon') {
        // Полигон уже хранит все 4 угла (и пятую замыкающую точку)
        return coords[0].slice(0, 4); // Возвращаем первые 4 точки
    }
    return null;
}


// Вспомогательная функция для конвертации Data URL в Blob
function dataURLToBlob(dataURL) {
    const parts = dataURL.split(',');
    const byteString = atob(parts[1]);
    const mimeString = parts[0].split(':')[1].split(';')[0];
    const ab = new ArrayBuffer(byteString.length);
    const ia = new Uint8Array(ab);
    for (let i = 0; i < byteString.length; i++) {
        ia[i] = byteString.charCodeAt(i);
    }
    return new Blob([ab], { type: mimeString });
}


// Функция для экспорта настроек
async function exportRasterSettingsToFile() {
    if (!rasterOverlay) {
        showNotification('Нет растра для экспорта настроек', 'warning');
        return;
    }

    const corners = getRasterCorners();
    const imageUrl = rasterOverlay.options.get('fillImageHref');

    if (!corners || !imageUrl) {
        showNotification('Не удалось получить данные растра для экспорта', 'error');
        return;
    }
    
    showLoader('Создание архива растра...');

    try {
        const settings = {
            type: "RasterBindingData",
            version: 1,
            imageSize: rasterImageSize,
            opacity: rasterOverlay.options.get('opacity'),
            corners: corners
        };

        const imageBlob = dataURLToBlob(imageUrl);
        const imageExtension = imageBlob.type.split('/')[1] || 'jpg';

        // Создаем ZIP
        const zip = new JSZip();
        zip.file('raster-settings.json', JSON.stringify(settings, null, 2));
        zip.file(`raster.${imageExtension}`, imageBlob);

           const zipBlob = await zip.generateAsync({
            type: "blob",
            compression: "DEFLATE",
            compressionOptions: { level: 9 }
        });

        saveAs(zipBlob, 'raster-archive.rst'); 
        showNotification('Архив с растром и настройками сохранен', 'success');

    } catch (error) {
        console.error("Ошибка при экспорте растра:", error);
        showNotification('Ошибка при создании архива растра', 'error');
    } finally {
        hideLoader();
    }
}


async function pasteRasterFromClipboard() {
    showLoader('Поиск изображения в буфере...');
    try {
        const clipboardItems = await navigator.clipboard.read();
        let imageBlob = null;

        for (const item of clipboardItems) {
            const imageType = item.types.find(type => type.startsWith('image/'));
            if (imageType) {
                imageBlob = await item.getType(imageType);
                break;
            }
        }

        if (imageBlob) {
            // Если изображение найдено, создаем/обновляем подложку
            await createRasterOverlay(imageBlob);
            showNotification('Растр вставлен из буфера обмена', 'success');
        } else {
            // Если изображений нет, просто показываем уведомление
            showNotification('Изображение в буфере не найдено.', 'info');
        }
    } catch (err) {
        console.error('Ошибка доступа к буферу обмена:', err);
        showNotification('Ошибка доступа к буферу. Используйте импорт.', 'warning');
    } finally {
        hideLoader();
    }
}

async function exportRasterToCloud() {
    if (!rasterOverlay) {
        showNotification('Нет растра для экспорта в облако', 'warning');
        return;
    }

    // Запрашиваем у пользователя номер квартала
    const quarterNumber = await promptForQuarterNumber(currentQuarterNumber);
    if (!quarterNumber) {
        showNotification('Экспорт отменен', 'info');
        return;
    }

    showLoader(`Экспорт растра для ${quarterNumber}...`);

    try {
        // Собираем данные для .rst архива
        const corners = getRasterCorners();
        const imageUrl = rasterOverlay.options.get('fillImageHref');
        if (!corners || !imageUrl) throw new Error('Не удалось получить данные растра.');

        const settings = {
            type: "RasterBindingData", version: 1, imageSize: rasterImageSize,
            opacity: rasterOverlay.options.get('opacity'), corners: corners
        };
        const imageBlob = dataURLToBlob(imageUrl);
        const imageExtension = imageBlob.type.split('/')[1] || 'jpg';

        const zip = new JSZip();
        zip.file('raster-settings.json', JSON.stringify(settings, null, 2));
        zip.file(`raster.${imageExtension}`, imageBlob);
        const zipBlob = await zip.generateAsync({ type: "blob", compression: "DEFLATE", level: 9 });

        const filename = quarterNumber.replace(/:/g, '_') + '.rst';
        const formData = new FormData();
        formData.append('file', new File([zipBlob], filename, { type: 'application/zip' }));

        // Отправляем на тот же эндпоинт, что и для *.nspd
        const response = await fetch(`${STORAGE_API_URL}/nspd/upload`, {
            method: 'POST',
            body: formData,
        });

        if (!response.ok) {
            const errorData = await response.json().catch(() => ({ error: `Сервер ответил ошибкой: ${response.statusText}` }));
            throw new Error(errorData.error);
        }

        showNotification(`Растр для квартала ${quarterNumber} успешно загружен`, 'success');
    } catch (error) {
        console.error("Ошибка экспорта растра в облако:", error);
        showNotification(`Ошибка экспорта: ${error.message}`, 'error');
    } finally {
        hideLoader();
    }
}

// Функция для импорта растра с сервера
async function importRasterFromCloud() {
    let quarterNumber = currentQuarterNumber;

    if (!quarterNumber) {
        quarterNumber = await promptForQuarterNumber();
    }
    
    if (!quarterNumber) {
        showNotification('Импорт отменен', 'info');
        return;
    }

    showLoader(`Поиск растра для ${quarterNumber}...`);

    try {
        const filename = quarterNumber.replace(/:/g, '_') + '.rst';
        // Запрашиваем файл с того же эндпоинта, что и для *.nspd
        const response = await fetch(`${STORAGE_API_URL}/nspd/${filename}`);

        if (!response.ok) {
            if (response.status === 404) {
                throw new Error(`Привязанный растр для квартала ${quarterNumber} не найден`);
            } else {
                throw new Error(`Ошибка сервера: ${response.statusText}`);
            }
        }

        const zipBlob = await response.blob();
        
        // Передаем blob в существующую логику импорта
        await processImportedZipBlob(zipBlob);

    } catch (error) {
        console.error("Ошибка импорта растра из облака:", error);
        showNotification(`Ошибка импорта: ${error.message}`, 'error');
    } finally {
        hideLoader();
    }
}

// Новая вспомогательная функция для запроса номера квартала
async function promptForQuarterNumber(defaultValue = '') {
    return new Promise((resolve) => {
        const modal = document.createElement('div');
        modal.className = 'color-modal';
        modal.style.width = '400px';
        modal.innerHTML = `
            <div class="color-modal-content">
                <h3 style="margin-top:0;">Введите номер квартала</h3>
                <input type="text" id="quarter-prompt-input" value="${defaultValue}" style="width: 80%; padding: 10px; border-radius: 8px; border: 1px solid #ccc; margin-bottom: 20px; text-align: center; font-size: 1rem;">
                <div class="buttons">
                    <button id="prompt-ok-btn" class="apply-btn"><i class="fas fa-check"></i> OK</button>
                    <button id="prompt-cancel-btn" class="cancel-btn"><i class="fas fa-times"></i> Отмена</button>
                </div>
            </div>
        `;
        document.body.appendChild(modal);
        modal.style.display = 'block';

        const input = document.getElementById('quarter-prompt-input');
        const okBtn = document.getElementById('prompt-ok-btn');
        const cancelBtn = document.getElementById('prompt-cancel-btn');
        input.focus();
        input.select();

        const close = (value) => {
            document.body.removeChild(modal);
            resolve(value);
        };

        okBtn.onclick = () => {
            const value = input.value.trim();
            if (value && isCadastralQuarter(value)) {
                close(value);
            } else {
                showNotification('Введите корректный номер квартала', 'warning');
            }
        };
        cancelBtn.onclick = () => close(null);
        modal.addEventListener('click', e => { if (e.target === modal) close(null); });
        input.onkeydown = (e) => { if (e.key === 'Enter') okBtn.click(); if (e.key === 'Escape') cancelBtn.click(); };
    });
}


async function processImportedZipBlob(zipBlob) {
    const zip = await JSZip.loadAsync(zipBlob);
    const settingsFile = zip.file('raster-settings.json');

    let imageFile = zip.file(/^raster\.(?!json).+$/i)[0];
  

    if (!settingsFile || !imageFile) {
        throw new Error('Архив не содержит необходимых файлов (settings.json и изображения).');
    }

    const settingsText = await settingsFile.async('string');
    const imageBlob = await imageFile.async('blob');
    const settings = JSON.parse(settingsText);

    if (settings.type !== "RasterBindingData" || !settings.corners || settings.corners.length !== 4) {
        throw new Error('Некорректный формат файла настроек.');
    }

    const imageReader = new FileReader();
    imageReader.readAsDataURL(imageBlob);
    await new Promise((resolve, reject) => {
        imageReader.onload = (imgEvent) => {
            const newPolygonOverlay = new ymaps.Polygon([settings.corners], {}, {
                fillImageHref: imgEvent.target.result,
                fillMethod: 'stretch',
                stroke: false,
                opacity: settings.opacity || 0.8,
               interactivityModel: 'default#transparent',
zIndex: 400
            });

            if (rasterOverlay) map.geoObjects.remove(rasterOverlay);
            if (!rasterControlsPanel) createRasterControls();

            rasterOverlay = newPolygonOverlay;
            rasterImageSize = settings.imageSize;
            map.geoObjects.add(rasterOverlay);

            rasterControlsPanel.querySelector('#raster-opacity').value = settings.opacity || 0.8;
            showNotification('Растр и настройки успешно импортированы!', 'success');
            resolve();
        };
        imageReader.onerror = () => reject(new Error('Не удалось прочитать файл изображения из архива.'));
    });
}

// Функция для импорта настроек и изображения из ZIP
function importRasterSettingsFromFile() {
    const input = document.createElement('input');
    input.type = 'file';
    input.accept = '.rst';

    input.onchange = e => {
        const file = e.target.files[0];
        if (!file) return;

        showLoader('Импорт архива растра...');
        const reader = new FileReader();
        reader.onload = async (event) => {
            try {
                // Просто передаем blob в новую общую функцию
                await processImportedZipBlob(new Blob([event.target.result]));
            } catch (error) {
                console.error("Ошибка импорта настроек из файла:", error);
                showNotification(`Ошибка импорта: ${error.message}`, 'error');
            } finally {
                hideLoader();
            }
        };
        reader.readAsArrayBuffer(file);
    };
    input.click();
}

function fillAuxiliaryTextareas(originalCoordGroups, geoGroups) {
    let convertedText = '';
    let geoText = '';

    geoGroups.forEach((group, groupIndex) => {
        group.forEach(geoCoord => {
            const result3857 = proj4("EPSG:4326", "EPSG:3857", [geoCoord[1], geoCoord[0]]); // [lon, lat]
            convertedText += `${result3857[0].toFixed(4)}\t${result3857[1].toFixed(4)}\n`;
            geoText += `${geoCoord[0].toFixed(8)}\t${geoCoord[1].toFixed(8)}\n`;
        });
        if (groupIndex < geoGroups.length - 1) {
            convertedText += '\n';
            geoText += '\n';
        }
    });

    convertedTextarea.value = convertedText.trim();
    geoTextarea.value = geoText.trim();
}


   function isValidCadastralNumber(text) {
    const pattern = new RegExp(`^\\d{2}:\\d{2}:\\d{6,7}:\\d+$`);
    return pattern.test(text);
}


  // Глобальная переменная для кастомного макета метки
let customPlacemarkLayout;
let numberedPointLayout; 
let redDotLayout; 

document.addEventListener('DOMContentLoaded', async () => {
    
    
    try {
        await navigator.permissions.query({ name: 'clipboard-read' });
        ymaps.ready(function () {
            try {
                if (!ymaps || !ymaps.templateLayoutFactory) {
                    console.error('Yandex Maps API не загружен. Проверьте ключ API и подключение.');
                    return;
                }

                // Кастомный макет для метки
                customPlacemarkLayout = ymaps.templateLayoutFactory.createClass(
                    '<div class="custom-placemark" style="position: absolute; font-family: sans-serif; user-select: none; transform: scale(1); transform-origin: center; text-align: center;">$[properties.iconContent]</div>',
                    {
                        build: function () {
                            this.constructor.superclass.build.call(this);
                            const element = this.getParentElement().querySelector('.custom-placemark');
                            // Устанавливаем начальный размер текста по умолчанию, если карта еще не доступна
                            const defaultFontSize = 12; // Начальный размер текста
                            element.style.fontSize = `${defaultFontSize}px`;
                            element.style.color = '#000';
                            element.style.textShadow = '-1px -1px 0 #fff, 1px -1px 0 #fff, -1px 1px 0 #fff, 1px 1px 0 #fff, 0 0 2px #fff';
                            
                            // Проверяем, доступна ли карта, и обновляем размер текста
                            const map = this.getData().options.get('map');
                            if (map) {
                                const zoom = map.getZoom();
                                const fontSize = Math.max(10, Math.min(16, 8 + zoom * 0.4));
                                element.style.fontSize = `${fontSize}px`;
                            }
                        },
                        // Обновление при изменении карты
                        onMapChange: function () {
                            const element = this.getParentElement().querySelector('.custom-placemark');
                            const map = this.getData().options.get('map');
                            if (map) {
                                const zoom = map.getZoom();
                                const fontSize = Math.max(10, Math.min(16, 8 + zoom * 0.4));
                                element.style.fontSize = `${fontSize}px`;
                            }
                        },
                        // Убедимся, что форма применяется корректно
                        update: function () {
                            this.constructor.superclass.update.call(this);
                            const element = this.getParentElement().querySelector('.custom-placemark');
                            const map = this.getData().options.get('map');
                            if (map) {
                                const zoom = map.getZoom();
                                const fontSize = Math.max(10, Math.min(16, 8 + zoom * 0.4));
                                element.style.fontSize = `${fontSize}px`;
                            }
                        }
                    }
                );
                
            
                              // Кастомный макет для нумерованных точек (н1, н2...)
                numberedPointLayout = ymaps.templateLayoutFactory.createClass(
                    // Добавляем инлайновый стиль для размера шрифта, который берется из свойств метки
                    '<div class="numbered-point-label" style="font-size: $[properties.fontSize]px;">$[properties.iconContent]</div>'
                );

  redDotLayout = ymaps.templateLayoutFactory.createClass(
                    // <-- ИЗМЕНЕНО: Добавляем инлайновые стили для ширины и высоты
                    '<div class="custom-red-dot" style="width: $[properties.dotSize]px; height: $[properties.dotSize]px;"></div>'
                );
                
                // Кастомный макет для подсказки (без изменений)
                    customHintLayout = ymaps.templateLayoutFactory.createClass(
                    '<div class="custom-hint" style="min-width: 220px;">' +
                        '<strong>$[properties.hintContent.cadastralNumber]</strong>' +
                        '<div class="hint-address">$[properties.hintContent.address]</div>' +
                        '<div class="hint-area">$[properties.hintContent.area]</div>' +
                        // --- НАЧАЛО ИЗМЕНЕНИЙ: Добавляем новые поля для ОКС и ЗУ ---
                        '{% if properties.hintContent.cost %} <div class="hint-cost">Стоимость: $[properties.hintContent.cost] руб./м²</div> {% endif %}' +
                        '{% if properties.hintContent.vri %} <div class="hint-vri" style="color: #1e88e5;">ВРИ: $[properties.hintContent.vri]</div> {% endif %}' +
                        '{% if properties.hintContent.purpose %} <div class="hint-purpose" style="color: #1e88e5;">Назначение: $[properties.hintContent.purpose]</div> {% endif %}' +
                        '{% if properties.hintContent.ownershipType %} <div class="hint-ownership" style="color: #4a5568;">Форма собственности: $[properties.hintContent.ownershipType]</div> {% endif %}' +
                        '{% if properties.hintContent.rightType %} <div class="hint-right" style="color: #4a5568;">Тип права: $[properties.hintContent.rightType]</div> {% endif %}' +
                        '{% if properties.hintContent.yearBuilt %} <div class="hint-year" style="color: #4a5568;">Год постройки: $[properties.hintContent.yearBuilt]</div> {% endif %}' +
                        '{% if properties.hintContent.materials %} <div class="hint-materials" style="color: #4a5568;">Материал стен: $[properties.hintContent.materials]</div> {% endif %}' +
                        '{% if properties.hintContent.floors %} <div class="hint-floors" style="color: #4a5568;">Этажность: $[properties.hintContent.floors]</div> {% endif %}' +
                        // --- КОНЕЦ ИЗМЕНЕНИЙ ---
                    '</div>',
                    {
                        build: function () {
                            this.constructor.superclass.build.call(this);
                        },
                        clear: function () {
                            this.constructor.superclass.clear.call(this);
                        }
                    }
                );
                
            

                initMap();
                readFromClipboard().then(() => {
                    if (isValidCadastralNumber(cityInput.value.trim())) {
                        const event = new KeyboardEvent('keydown', {
                            key: 'Enter',
                            code: 'Enter',
                            which: 13,
                            keyCode: 13,
                            bubbles: true
                        });
                        cityInput.dispatchEvent(event);
                    } else {
                        findAndConvert();
                    }
                });
            } catch (error) {
                console.error('Error initializing map:', error);
            }
        });
    } catch (error) {
        console.error('Clipboard permission error:', error);
    }
});


async function fetchCadastralData(cadastralNumber) {
    const url = `https://nspd.gov.ru/api/geoportal/v2/search/geoportal?thematicSearchId=1&query=${encodeURIComponent(cadastralNumber)}`;

    try {
      
        const response = await fetchNspd(url);

     
        
 
        if (!response.ok) {
          
            console.warn(`Запрос для ${cadastralNumber} завершился со статусом ${response.status}`);
            return null;
        }

        const data = await response.json();

       
        if (data && data.data && data.data.features && data.data.features.length > 0) {
            return data.data.features[0];
        } else {
            // Если ответ успешный, но пустой (такое тоже бывает)
            return null;
        }
    

    } catch (error) {
     
        console.error(`Ошибка при получении данных для ${cadastralNumber}:`, error);
        return null; // Возвращаем null при любой ошибке
    }
}



        function getAddressByCoords(coords) {
            return ymaps.geocode(coords).then(function (res) {
                const firstGeoObject = res.geoObjects.get(0);
                if (firstGeoObject) {
                    return firstGeoObject.getAddressLine();
                }
                return 'Адрес не найден';
            });
        }

        async function getCadastralNumber(lat, lon) {
            const cadastralData = await queryCadastralInfo(lat, lon);
            if (cadastralData && cadastralData.features && cadastralData.features.length > 0) {
                return cadastralData.features[0].properties.descr;
            }
            return null;
        }




    



async function drawFeatures(geoCoordinates) {
    try {
        if (!geoCoordinates || !Array.isArray(geoCoordinates) || geoCoordinates.length === 0) {
            console.warn('Нет координат для отрисовки');
            return;
        }

        let allBounds = [];
        
        for (const coordGroup of geoCoordinates) {
            if (!Array.isArray(coordGroup) || coordGroup.length === 0) continue;

            const validCoords = coordGroup
                .map(coord => {
                    if (Array.isArray(coord) && coord.length === 2 && isFinite(coord[0]) && isFinite(coord[1])) {
                        return [coord[0] - mapOffsetY * 0.000008983, coord[1] - mapOffsetX * 0.000008983];
                    }
                    return null;
                })
                .filter(Boolean);

            if (validCoords.length === 0) continue;

            const isPolygon = validCoords.length > 2 &&
                Math.abs(validCoords[0][0] - validCoords[validCoords.length - 1][0]) < 1e-9 &&
                Math.abs(validCoords[0][1] - validCoords[validCoords.length - 1][1]) < 1e-9;

            if (isPolygon) {
                const polygonObj = new ymaps.Polygon([validCoords], {
                    isManuallyDrawn: true // Новый флаг для идентификации
                }, {
                    strokeColor: polygonStyle.color,
                    strokeWidth: polygonStyle.width,
                    strokeOpacity: manualObjectOpacity, 
                    fillColor: '#00000000',
                      zIndex: 900 
                });

                map.geoObjects.add(polygonObj);
                polygons.push(polygonObj);
                const bounds = polygonObj.geometry.getBounds();
                if (bounds) allBounds.push(bounds);

          } else if (validCoords.length > 1) {
    const polyline = new ymaps.Polyline(validCoords, {
        isDrawableLine: true // <<< ДОБАВЬТЕ ЭТО СВОЙСТВО
    }, {
        strokeColor: polygonStyle.color,
        strokeWidth: polygonStyle.width,
        strokeOpacity: 0.8,
        interactivityModel: 'default#geoObject',
         zIndex: 900 
    });
    map.geoObjects.add(polyline);
    polygons.push(polyline);
    const bounds = polyline.geometry.getBounds();
    if (bounds) allBounds.push(bounds);
} else if (validCoords.length === 1) {
                const placemark = new ymaps.Placemark(validCoords[0], {}, {
                    preset: 'islands#blueDotIcon'
                });
                map.geoObjects.add(placemark);
                polygons.push(placemark);
                allBounds.push([validCoords[0], validCoords[0]]);
            }
        }

        if (allBounds.length > 0) {
            let minLat = Infinity, minLng = Infinity, maxLat = -Infinity, maxLng = -Infinity;
            allBounds.forEach(bounds => {
                minLat = Math.min(minLat, bounds[0][0]);
                minLng = Math.min(minLng, bounds[0][1]);
                maxLat = Math.max(maxLat, bounds[1][0]);
                maxLng = Math.max(maxLng, bounds[1][1]);
            });

            if (isFinite(minLat)) {
                const latMargin = (maxLat - minLat) * 0.1 || 0.001;
                const lonMargin = (maxLng - minLng) * 0.1 || 0.001;
                const viewBounds = [
                    [minLat - latMargin, minLng - lonMargin],
                    [maxLat + latMargin, maxLng + lonMargin]
                ];
                map.setBounds(viewBounds, { checkZoomRange: true, duration: 200 });
            }
        }
    } catch (error) {
        console.error('Ошибка отрисовки объекта:', error);
        showNotification('Ошибка отрисовки объекта', 'error', 'exclamation-circle');
    }
}


        function formatDistance(distance) {
            if (distance < 1000) {
                return `${distance.toFixed(2)} м`;
            } else {
                return `${(distance / 1000).toFixed(2)} км`;
            }
        }

        let totalDistance = 0;
        let segments = [];

function measureDistance() {
    if (distanceMeasurementActive) {
        stopDistanceMeasurement();
        return;
    }
    distanceMeasurementActive = true;
    distancePoints = [];
    totalDistance = 0;
    segments = [];
    // Не вызываем clearDistanceMeasurement(), чтобы не удалять все объекты
    mapElement.classList.add('measuring-distance');
    map.events.add('click', onMapClickForDistance);
    map.events.add('dblclick', onMapDoubleClickForDistance);
}

// НОВАЯ ФУНКЦИЯ для генерации KML для полилинии
function generateKmlForPolyline(polylineObject, placemarkName) {
    const yandexCoordsSmeschennyeNaKarte = polylineObject.geometry.getCoordinates(); // Это массив точек [lat, lon]

    // --- ВОЗВРАЩАЕМ КООРДИНАТЫ К ИСТИННЫМ WGS84 ---
    const istinnyeWGS84Coords = yandexCoordsSmeschennyeNaKarte.map(coord => {
        return [
            coord[0] + (mapOffsetY * 0.000008983),
            coord[1] + (mapOffsetX * 0.000008983)
        ];
    });

    // --- ПРИМЕНЯЕМ KML СМЕЩЕНИЯ К "ИСТИННЫМ" WGS84 КООРДИНАТАМ ---
    const kmlAdjustedWGS84Coords = istinnyeWGS84Coords.map(coord => {
        return [
            coord[0] + (kmlMapOffsetY * 0.000008983), // KML широта
            coord[1] + (kmlMapOffsetX * 0.000008983)  // KML долгота
        ];
    });

    const kmlCoordsArray = kmlAdjustedWGS84Coords.map(coord => `${coord[1]},${coord[0]},0`); // lon,lat,alt
    const kmlCoordsString = kmlCoordsArray.join(' ');

    const safePlacemarkName = placemarkName.replace(/[^a-zA-Z0-9_.:-]/g, '_');

    let kmlStrokeColor = "ff0000ff"; // AABBGGRR - Красный по умолчанию
    const kmlStrokeWidth = polylineObject.options.get('strokeWidth') || 2;

    const originalStrokeColor = polylineObject.options.get('strokeColor');
    if (originalStrokeColor) {
        if (originalStrokeColor.length === 7) { // #RRGGBB
            kmlStrokeColor = `ff${originalStrokeColor.substring(5, 7)}${originalStrokeColor.substring(3, 5)}${originalStrokeColor.substring(1, 3)}`;
        } else if (originalStrokeColor.length === 9) { // #AARRGGBB
            kmlStrokeColor = `${originalStrokeColor.substring(7, 9)}${originalStrokeColor.substring(5, 7)}${originalStrokeColor.substring(3, 5)}${originalStrokeColor.substring(1, 3)}`;
        }
    }
    
    // Для LineString LabelStyle не используется для отображения имени вдоль линии в Google Earth,
    // имя отображается в списке объектов.
    // Если нужен текст прямо на карте рядом с линией, это делается отдельным Placemark с Point.
    const kmlStyleXml = `
      <Style>
        <LineStyle>
          <color>${kmlStrokeColor}</color>
          <width>${kmlStrokeWidth}</width>
        </LineStyle>
        <IconStyle><scale>0</scale></IconStyle> <!-- Скрываем иконку по умолчанию для линий -->
         <LabelStyle><scale>0.8</scale></LabelStyle> <!-- Масштаб имени в списке -->
      </Style>`;

    return `
    <Placemark>
      <name>${escapeXml(safePlacemarkName)}</name>
      ${kmlStyleXml}
      <LineString>
        <tessellate>1</tessellate>
        <coordinates>
          ${kmlCoordsString}
        </coordinates>
      </LineString>
    </Placemark>`;
}


// ИЗМЕНЕННАЯ ФУНКЦИЯ exportAllMapObjectsToKml
function exportAllMapObjectsToKml() {
    if (!map) {
        showNotification('Карта не инициализирована', 'error');
        return;
    }

    const kmlPlacemarks = [];
    let polygonIndex = 1;
    let lineIndex = 1; // Индекс для линий
    let placemarkIndex = 1;
    let textIndex = 1;

    const uniqueYandexGeoObjects = new Set();

    // Собираем все полигоны, полилинии и метки из polygons
    polygons.forEach(obj => {
        if (obj instanceof ymaps.GeoObject) { // Убеждаемся, что это геообъект Яндекса
            uniqueYandexGeoObjects.add(obj);
        }
    });

    // Собираем все полигоны из areaObjects (если там могут быть полилинии, их тоже)
    areaObjects.forEach(obj => {
        if (obj instanceof ymaps.GeoObject) {
            uniqueYandexGeoObjects.add(obj);
        }
    });

    // Собираем все метки из parcelPlacemarks
    parcelPlacemarks.forEach(obj => {
        if (obj instanceof ymaps.GeoObject) {
            uniqueYandexGeoObjects.add(obj);
        }
    });


    uniqueYandexGeoObjects.forEach(obj => {
        if (obj instanceof ymaps.Polygon) {
            const placemarkName = obj.properties.get('cadastralNumber') ||
                                  obj.properties.get('hintContent')?.cadastralNumber ||
                                  obj.properties.get('hintContent')?.iconContent ||
                                  `Полигон_${polygonIndex++}`;
            kmlPlacemarks.push(generateKmlForSinglePolygon(obj, placemarkName));
        } else if (obj instanceof ymaps.Polyline) { // <--- ДОБАВЛЕНА ОБРАБОТКА ПОЛИЛИНИЙ
            const placemarkName = obj.properties.get('hintContent') || // Попытка получить имя из подсказки
                                  (obj.properties.get('iconContent') && typeof obj.properties.get('iconContent') === 'string' ? obj.properties.get('iconContent') : null) || // Если имя в iconContent (для меток расстояния)
                                  `Линия_${lineIndex++}`;
            kmlPlacemarks.push(generateKmlForPolyline(obj, placemarkName));
        } else if (obj instanceof ymaps.Placemark) {
            // Пропускаем метки, которые являются частью измерения расстояния или площади,
            // так как сама линия/полигон уже будет экспортирована.
            // Это условие можно настроить, если нужно экспортировать и метки измерений.
            if (obj === distanceLabel || obj === areaLabel || (obj.properties && (obj.properties.get('isVertexPoint') || obj.properties.get('isDistanceSegmentLabel')))) {
                 // Пропускаем метки вершин и сегментов расстояний, если они специально помечены
            } else {
                const name = obj.properties.get('iconContent') ||
                             obj.properties.get('hintContent')?.cadastralNumber ||
                             (typeof obj.properties.get('hintContent') === 'string' ? obj.properties.get('hintContent') : null) ||
                             (typeof obj.properties.get('balloonContent') === 'string' ? obj.properties.get('balloonContent') : null) ||
                             `Метка_${placemarkIndex++}`;
                kmlPlacemarks.push(generateKmlForPlacemark(obj, name));
            }
        }
    });

    draggableTexts.forEach(textEl => {
        kmlPlacemarks.push(generateKmlForDraggableText(textEl, map, `Текст_${textIndex++}`));
    });


    if (kmlPlacemarks.length === 0) {
        showNotification('Нет объектов для экспорта в KML', 'warning', 'exclamation-triangle');
        return;
    }

    const kmlDocumentName = 'Все_объекты_карты';
    const kmlContent = `<?xml version="1.0" encoding="UTF-8"?>
<kml xmlns="http://www.opengis.net/kml/2.2">
  <Document>
    <name>${escapeXml(kmlDocumentName)}</name>
    ${kmlPlacemarks.join('\n')}
  </Document>
</kml>`;

    const blob = new Blob([kmlContent], { type: 'application/vnd.google-earth.kml+xml;charset=utf-8' });
    saveAs(blob, `${kmlDocumentName}.kml`);
    // Подсчитываем общее количество уникальных геообъектов Яндекса (не KML Placemarks) + текстовые метки
    showNotification(`Экспортировано ${uniqueYandexGeoObjects.size + draggableTexts.length} объектов в KML Google Earth`, 'success', 'check-circle');
    
    if (openGoogleEarthAfterExport) {
        window.open('https://earth.google.com/web/@0,-0.67350016,0a,22251752.77375655d,35y,0h,0t,0r/data=CgRCAggBOgMKATBCAggASg0I____________ARAA', '_blank');
    }
}

// ИЗМЕНЕННАЯ ФУНКЦИЯ onMapClickForDistance (добавляем свойство для метки сегмента)
function onMapClickForDistance(e) {
    const coords = e.get('coords');
    distancePoints.push(coords);

    const placemark = new ymaps.Placemark(coords, {}, {
        preset: 'islands#smallGreenDotIcon'
    });
    map.geoObjects.add(placemark);
    polygons.push(placemark);

    if (distancePoints.length > 1) {
        const lastIndex = distancePoints.length - 1;
        const p1 = distancePoints[lastIndex - 1];
        const p2 = distancePoints[lastIndex];
        const segmentDistance = ymaps.coordSystem.geo.getDistance(p1, p2);
        totalDistance += segmentDistance;
        segments.push(segmentDistance);

        const segmentLine = new ymaps.Polyline([p1, p2], {}, {
            strokeColor: '#4cbb17',
            strokeWidth: 3,
            opacity: 0.8
        });
        map.geoObjects.add(segmentLine);
        polygons.push(segmentLine);

        const midPoint = [(p1[0] + p2[0]) / 2, (p1[1] + p2[1]) / 2];
        const formattedDistance = formatDistance(segmentDistance);

        const segmentLabel = new ymaps.Placemark(midPoint, {
            iconContent: formattedDistance,
            balloonContent: formattedDistance,
            isDistanceSegmentLabel: true // <--- ДОБАВЛЕНО СВОЙСТВО
        }, {
            preset: 'islands#greenStretchyIcon',
            iconColor: '#4cbb17',
            iconSize: [20, 20]
        });
        map.geoObjects.add(segmentLabel);
        polygons.push(segmentLabel);

        updateTotalDistanceLabel();
    }
}

function onMapDoubleClickForDistance(e) {
    e.preventDefault();
    stopDistanceMeasurement();
    
    // Ensure only the total distance label (red) remains, and no duplicates are left
    updateTotalDistanceLabel();
    
    // Optionally, you can clear or re-evaluate distancePoints if needed, but this should suffice
    distancePoints = [...distancePoints]; // Keep the points for reference but don’t duplicate labels
}


function updateTotalDistanceLabel() {
    if (distanceLabel) {
        map.geoObjects.remove(distanceLabel);
        polygons = polygons.filter(p => p !== distanceLabel);
    }

    if (distancePoints.length > 0) {
        const lastPoint = distancePoints[distancePoints.length - 1];
        const formattedTotal = formatDistance(totalDistance);

        // Use only the red StretchyIcon preset for the total distance label
        distanceLabel = new ymaps.Placemark(lastPoint, {
            iconContent: formattedTotal,
            balloonContent: formattedTotal
        }, {
            preset: 'islands#redStretchyIcon' // Ensure only the red label is used
        });
        map.geoObjects.add(distanceLabel);
        polygons.push(distanceLabel);
    }
}

async function terrZoneMenuItemHandler(contextMenu, map, polygons, polygonStyle, mapOffsetY, mapOffsetX, getAddressByCoords, proj4, ymaps, showNotification) {
    const lat = parseFloat(contextMenu.dataset.lat);
    const lon = parseFloat(contextMenu.dataset.lon);

    try {
        const terrZoneData = await queryTerrZoneInfo(lat, lon);

        if (!terrZoneData || !terrZoneData.features || terrZoneData.features.length === 0) {
            showNotification('Территориальная зона не найдена', 'error', 'exclamation-circle');
            contextMenu.style.display = 'none';
            return;
        }

        const feature = terrZoneData.features[0];

        if (!feature.geometry || !feature.geometry.coordinates) {
            throw new Error('Геометрия или координаты отсутствуют в данных');
        }

        let combinedBounds = null;
        const turfPolygons = [];
        let clickedContourCentroid = null;

        const isMultiPolygon = feature.geometry.type === 'MultiPolygon';
        const polygonsCoords = isMultiPolygon ? feature.geometry.coordinates : [feature.geometry.coordinates];

        const cadastralNumber = feature.properties.options && feature.properties.options.reg_numb_border
            ? feature.properties.options.reg_numb_border
            : 'Не указан';
        const name = feature.properties.options && feature.properties.options.name_by_doc
            ? feature.properties.options.name_by_doc
            : 'Не указано';
        const registrationDate = feature.properties.options && feature.properties.options.registration_date
            ? feature.properties.options.registration_date
            : 'Не указана';
        const labelContent = `${cadastralNumber} - ${name} (${registrationDate})`;

        for (let polygonIndex = 0; polygonIndex < polygonsCoords.length; polygonIndex++) {
            const polygonCoords = polygonsCoords[polygonIndex];

            for (let contourIndex = 0; contourIndex < polygonCoords.length; contourIndex++) {
                const contour = polygonCoords[contourIndex];
                if (!Array.isArray(contour)) {
                    console.error(`Некорректный формат контура в полигоне:`, contour);
                    continue;
                }

                const coords = [];
                for (const coord of contour) {
                    if (!Array.isArray(coord) || coord.length !== 2 || typeof coord[0] !== 'number' || typeof coord[1] !== 'number' || !Number.isFinite(coord[0]) || !Number.isFinite(coord[1])) {
                        console.error(`Некорректная координата перед преобразованием:`, coord);
                        continue;
                    }

                    try {
                        const point = proj4('EPSG:3857', 'EPSG:4326', coord);
                        if (!Number.isFinite(point[0]) || !Number.isFinite(point[1])) {
                            console.error(`Преобразование дало некорректные значения:`, coord, '->', point);
                            continue;
                        }
                        coords.push([point[1], point[0]]);
                    } catch (e) {
                        console.error(`Ошибка преобразования координаты:`, coord, e);
                        continue;
                    }
                }

                if (coords.length > 0) {
                    const offsetCoords = coords.map(coord => [
                        coord[0] - mapOffsetY * 0.000008983,
                        coord[1] - mapOffsetX * 0.000008983
                    ]);

                    const polygonObj = new ymaps.Polygon([offsetCoords], {}, {
                        strokeColor: '#0000FF',
                        strokeWidth: polygonStyle.width,
                        strokeOpacity: 0.8,
                        fillColor: '#00000000',
                        hintEnabled: false,
                        hasBalloon: false,
                        interactivityModel: 'default#transparent'
                    });

                    map.geoObjects.add(polygonObj);
                    polygons.push(polygonObj);

                    const bounds = polygonObj.geometry.getBounds();
                    if (!combinedBounds) {
                        combinedBounds = bounds;
                    } else {
                        combinedBounds[0][0] = Math.min(combinedBounds[0][0], bounds[0][0]);
                        combinedBounds[0][1] = Math.min(combinedBounds[0][1], bounds[0][1]);
                        combinedBounds[1][0] = Math.max(combinedBounds[1][0], bounds[1][0]);
                        combinedBounds[1][1] = Math.max(combinedBounds[1][1], bounds[1][1]);
                    }

                    const turfContour = turf.polygon([coords.map(coord => [coord[1], coord[0]])]);
                    turfPolygons.push(turfContour);

                    const clickPoint = turf.point([lon, lat]);
                    const isPointInContour = turf.booleanPointInPolygon(clickPoint, turfContour);

                    if (isPointInContour) {
                        const centroidFeature = turf.centroid(turfContour);
                        const centroidCoordsGeo = centroidFeature.geometry.coordinates;
                        clickedContourCentroid = [
                            centroidCoordsGeo[1] - mapOffsetY * 0.000008983,
                            centroidCoordsGeo[0] - mapOffsetX * 0.000008983
                        ];
                    }
                }
            }
        }

        if (!combinedBounds) {
            throw new Error('Не удалось определить границы полигона');
        }

        map.setBounds(combinedBounds, {
            checkZoomRange: true,
            duration: 200
        });

        const centerGeo = [
            (combinedBounds[0][0] + combinedBounds[1][0]) / 2,
            (combinedBounds[0][1] + combinedBounds[1][1]) / 2
        ];

        getAddressByCoords(centerGeo).then(address => {
            document.getElementById('city-name-display').innerHTML = address;
        });

        const center3857 = proj4("EPSG:4326", "EPSG:3857", [centerGeo[1], centerGeo[0]]);

        lastPolygonCenter = {
            geo: {
                lat: centerGeo[0],
                lon: centerGeo[1]
            },
            epsg3857: {
                x: center3857[0],
                y: center3857[1]
            },
            native: {
                x: feature.geometry.coordinates[0]?.[0]?.[0]?.[0] || 0,
                y: feature.geometry.coordinates[0]?.[0]?.[0]?.[1] || 0
            }
        };

        if (clickedContourCentroid) {
            const terrZoneText = new ymaps.Placemark(clickedContourCentroid, {
                iconContent: labelContent,
                hintContent: labelContent
            }, {
                preset: 'islands#blueStretchyIcon',
                draggable: true // Добавлено: метка перетаскиваемая
            });

            map.geoObjects.add(terrZoneText);
            polygons.push(terrZoneText);
        } else {
            console.warn('Выбранная точка не попала ни в один из контуров');
        }
    } catch (error) {
        console.error('Ошибка при получении тер. зоны:', error);
        showNotification('Ошибка обработки данных территориальной зоны', 'error', 'exclamation-circle');
    }
    contextMenu.style.display = 'none';
}




async function getAllParcelsInQuarter(lat, lon, isSearchMode = false, directQuarterNumber = null, quarterAlreadyDrawn = false) {
    if (!isSearchMode) {
        if (directQuarterNumber) {
            showLoader(`Загрузка ${directQuarterNumber}...`);
        } else {
            showLoader("Поиск квартала ...");
        }
    }

    try {
        let quarterFeature = null;
        let quarterNumberToQuery = null;

        async function fetchNSPDQuarterGeometry(qn) {
            const url = `https://nspd.gov.ru/api/geoportal/v2/search/geoportal?thematicSearchId=2&query=${encodeURIComponent(qn)}`;
            try {
                const response = await fetchNspd(url); // Используем fetchNspd
                if (!response.ok) {
                    console.warn(`NSPD: HTTP error ${response.status} при запросе геометрии для квартала ${qn}`);
                    return null;
                }
                const data = await response.json();
                if (data && data.data && data.data.features && data.data.features.length > 0) {
                    return data.data.features[0];
                }
            } catch (error) {
                console.error(`NSPD: Ошибка при запросе геометрии для квартала ${qn}:`, error);
            }
            return null;
        }

        if (directQuarterNumber) {
            quarterNumberToQuery = directQuarterNumber;
        } else if (lat !== null && lon !== null) {
            async function tryGetQuarterDataByPoint(latitude, longitude) {
                const cadastralData = await queryCadastralInfo(latitude, longitude);
                if (!cadastralData?.features?.length) return null;
                const feature = cadastralData.features[0];
                const cadastralNumberOfPoint = feature.properties?.descr;
                if (!cadastralNumberOfPoint || cadastralNumberOfPoint.split(':').length < 3) return null;
                const qnForPoint = cadastralNumberOfPoint.split(':').slice(0, 3).join(':');
                return await fetchNSPDQuarterGeometry(qnForPoint);
            }

            quarterFeature = await tryGetQuarterDataByPoint(lat, lon);
            let foundByPoint = !!quarterFeature;
            let attempts = 0;
            const maxAttempts = 3;
            const squareWidthMeters = 50;
            const timeoutMs = 500;

            if (!foundByPoint) {
                const earthRadius = 6378137;
                const latRadians = lat * Math.PI / 180;
                const squareWidthLat = squareWidthMeters / earthRadius * (180 / Math.PI);
                const squareWidthLon = squareWidthMeters / (earthRadius * Math.cos(latRadians)) * (180 / Math.PI);

                while (!foundByPoint && attempts < maxAttempts) {
                    attempts++;
                    const offsetLat = (Math.random() - 0.5) * squareWidthLat;
                    const offsetLon = (Math.random() - 0.5) * squareWidthLon;
                    const newLat = lat + offsetLat;
                    const newLon = lon + offsetLon;
                    quarterFeature = await tryGetQuarterDataByPoint(newLat, newLon);
                    foundByPoint = !!quarterFeature;
                    if (!foundByPoint && attempts < maxAttempts) {
                        await new Promise(resolve => setTimeout(resolve, timeoutMs));
                    }
                }
            }
            
             if (!quarterFeature && !foundByPoint) {
                 if (!isSearchMode) showNotification('Данные не найдены, выберите для клика место с полигоном', 'error');
                 hideLoader();
                 return { quarterFeature: null, parcelFeatures: [] };
            }
            
            if (quarterFeature && quarterFeature.properties && quarterFeature.properties.descr) {
                quarterNumberToQuery = quarterFeature.properties.descr.split(':').slice(0, 3).join(':');
            }
        }

        if (!quarterNumberToQuery) {
            if (!isSearchMode) showNotification('Не удалось определить кадастровый квартал.', 'error');
            hideLoader();
            return { quarterFeature: null, parcelFeatures: [] };
        }


        if (isZeroQuarterRequest(quarterNumberToQuery)) {
            showNotification('Поиск в нулевом квартале не выполняется', 'warning');
            hideLoader();
            return { quarterFeature: null, parcelFeatures: [] }; // Прерываем выполнение
        }
    

  autoUpdateMskSettings(quarterNumberToQuery); 
        currentQuarterNumber = quarterNumberToQuery;

        if (!quarterFeature && directQuarterNumber) {
            quarterFeature = await fetchNSPDQuarterGeometry(directQuarterNumber);
        }

        let combinedBounds = null;
        if (!quarterAlreadyDrawn && quarterFeature && quarterFeature.geometry && quarterFeature.geometry.coordinates) {
            try {
                const geometryType = quarterFeature.geometry.type;
                const nspdQuarterCoords = quarterFeature.geometry.coordinates;
                const yandexPolygons = [];
                const processNspdPolygon = (rings) => {
                    const wgsCoords = rings[0].map(coord => {
                        const p = proj4('EPSG:3857', 'EPSG:4326', coord);
                        return [p[1], p[0]];
                    });
                    return wgsCoords.map(c => [c[0] - mapOffsetY * 0.000008983, c[1] - mapOffsetX * 0.000008983]);
                };
                if (geometryType === "Polygon") {
                    yandexPolygons.push(processNspdPolygon(nspdQuarterCoords));
                } else if (geometryType === "MultiPolygon") {
                    nspdQuarterCoords.forEach(polygonRings => yandexPolygons.push(processNspdPolygon(polygonRings)));
                }
                if (yandexPolygons.length > 0) {
                    const quarterPolygonNSPD = new ymaps.Polygon(yandexPolygons, {}, {
                        strokeColor: '#AAAAAA', strokeWidth: polygonStyle.width > 1 ? polygonStyle.width - 1 : 1,
                        strokeStyle: 'dash', strokeOpacity: 0.7, fillColor: '#00000000', zIndex: 100
                    });
                    map.geoObjects.add(quarterPolygonNSPD);
                    polygons.push(quarterPolygonNSPD);
                    combinedBounds = quarterPolygonNSPD.geometry.getBounds();
                    const centerGeo = [(combinedBounds[0][0] + combinedBounds[1][0]) / 2, (combinedBounds[0][1] + combinedBounds[1][1]) / 2];
                    getAddressByCoords(centerGeo).then(address => { document.getElementById('city-name-display').innerHTML = address || `Квартал: ${quarterNumberToQuery} (с НСПД)`; });
                }
            } catch (e) { console.error("Ошибка отрисовки контура квартала:", e); }
        } else if (quarterAlreadyDrawn) {
            const existingQuarterPoly = polygons.find(p => p.properties && p.properties.get('hintContent')?.includes(currentQuarterNumber) && p.options.get('strokeColor') === '#00DD00');
            if (existingQuarterPoly) combinedBounds = existingQuarterPoly.geometry.getBounds();
        }

        if (!quarterFeature || !quarterFeature.geometry) {
            if (!isSearchMode) showNotification(`Нет геометрии для квартала ${quarterNumberToQuery}, чтобы запросить участки.`, 'error');
            hideLoader();
            return { quarterFeature: null, parcelFeatures: [] };
        }
        
        const requestBody = {
            "geom": { "type": "FeatureCollection", "features": [{ "type": "Feature", "geometry": { "crs": { "type": "name", "properties": { "name": "EPSG:3857" } }, "type": quarterFeature.geometry.type, "coordinates": quarterFeature.geometry.coordinates }, "properties": {} }] },
            "categories": [{ "id": 36368 }]
        };
        const response = await fetchNspd('https://nspd.gov.ru/api/geoportal/v1/intersects?typeIntersect=fullObject', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(requestBody) });
        if (!response.ok) throw new Error(`HTTP error ${response.status} при запросе участков для ${quarterNumberToQuery}`);
        const nspdParcelsData = await response.json();

        if (!nspdParcelsData?.features?.length) {
            if (!isSearchMode) showNotification(`Земельные участки в квартале ${quarterNumberToQuery} не найдены`, 'warning');
            if (combinedBounds) map.setBounds(combinedBounds, { checkZoomRange: true, duration: 300 });
            hideLoader();
            return { quarterFeature: quarterFeature, parcelFeatures: [] };
        }
        
        parcelFeaturesData = nspdParcelsData.features;
        await processAndDrawParcels(nspdParcelsData.features, 'quarter');
        await populateSidebarWithParcels(nspdParcelsData.features);
        
        updatePlacemarksVisibility();
        applyCurrentTheme();
        showNotification(`Загружено участков: ${parcelFeaturesData.length} для ${quarterNumberToQuery}`, 'success');
        hideLoader();

        // Фоновое сохранение данных
        saveQuarterGeometryToSupabase(quarterNumberToQuery, quarterFeature.geometry)
            .catch(err => console.error(`Фоновая ошибка сохранения геометрии :`, err));

        uploadNspdDataToLocalServer(parcelFeaturesData, currentQuarterNumber)
            .catch(err => console.error(`Фоновая ошибка выгрузки данных :`, err));
        
        return { quarterFeature: quarterFeature, parcelFeatures: parcelFeaturesData };

    } catch (error) {
        console.error('Ошибка в getAllParcelsInQuarter:', error);
        if (!isSearchMode) {
            showNotification(`НСПД: ${error.message || 'Ошибка сети или обработки данных'}`, 'error');
        }
        hideLoader();
        return { quarterFeature: null, parcelFeatures: [] };
    }
}

 

   async function saveQuarterGeometryToSupabase(quarterNumber, geometryGeoJSON) {
    if (!supabaseClient) {
        console.error("Клиент Supabase не инициализирован для сохранения геометрии.");
        return false;
    }
    if (!quarterNumber || !geometryGeoJSON) {
        console.error("Отсутствует номер квартала или геометрия для сохранения.");
        return false;
    }

    // Проверка на "нулевой" квартал, чтобы не сохранять его геометрию
    const quarterParts = quarterNumber.split(':');
    if (quarterParts.length === 3) {
        const regionPart = quarterParts[0];
        const blockPart = quarterParts[2];
        const isSevenDigitsRegion = sevenDigitsRegions.includes(regionPart);
        const expectedZerosLength = isSevenDigitsRegion ? 7 : 6;

        if (/^0+$/.test(blockPart) && blockPart.length === expectedZerosLength) {
             console.warn(`Нулевой квартал ${quarterNumber} - геометрия не будет сохранена в БД.`);
             return false;
        }
    }

    try {
        const { data, error } = await supabaseClient
            .from('cadastral_quarters')
            .upsert(
                {
                    quarter_number: quarterNumber,
                    geometry: geometryGeoJSON,
                },
                {
                    onConflict: 'quarter_number' // Обновляем, если квартал уже существует
                }
            )
            .select();

        if (error) {
        //    console.error(`Ошибка Supabase при сохранении геометрии квартала ${quarterNumber}:`, error);
            showNotification(`Ошибка сохранения геометрии квартала ${quarterNumber} в БД`, 'error');
            return false;
        }
     //   console.log(`Геометрия квартала ${quarterNumber} успешно сохранена/обновлена в Supabase.`);
        return true;
    } catch (dbError) {
    //    console.error(`Исключение при сохранении геометрии квартала ${quarterNumber}:`, dbError);
        showNotification(`Исключение при сохранении геометрии квартала ${quarterNumber} в БД`, 'error');
        return false;
    }
}


async function municipalMenuItemHandler(contextMenu, map, polygons, polygonStyle, mapOffsetY, mapOffsetX, getAddressByCoords, proj4, ymaps, showNotification) {
    const lat = parseFloat(contextMenu.dataset.lat);
    const lon = parseFloat(contextMenu.dataset.lon);

    try {
        const municipalData = await queryMunicipalInfo(lat, lon);

        if (!municipalData || !municipalData.features || municipalData.features.length === 0) {
            showNotification('Муниципальное образование не найдено', 'error', 'exclamation-circle');
            contextMenu.style.display = 'none';
            return;
        }

        let combinedBounds = null;
        const turfPolygons = [];

        for (const feature of municipalData.features) {
            if (!feature.geometry || !feature.geometry.coordinates) {
                console.error('Геометрия или координаты отсутствуют в данных:', feature);
                continue;
            }

            const isMultiPolygon = feature.geometry.type === 'MultiPolygon';
            const polygonsCoords = isMultiPolygon ? feature.geometry.coordinates : [feature.geometry.coordinates];

            const label = feature.properties.label || "Без названия";
            const descr = feature.properties.descr || "Без описания";
            const labelContent = `${label} - ${descr}`;

            for (let polygonIndex = 0; polygonIndex < polygonsCoords.length; polygonIndex++) {
                const polygonCoords = polygonsCoords[polygonIndex];

                for (let contourIndex = 0; contourIndex < polygonCoords.length; contourIndex++) {
                    const contour = polygonCoords[contourIndex];
                    if (!Array.isArray(contour)) {
                        console.error(`Некорректный формат контура в полигоне:`, contour);
                        continue;
                    }

                    const coords = [];
                    for (const coord of contour) {
                        if (!Array.isArray(coord) || coord.length !== 2 || typeof coord[0] !== 'number' || typeof coord[1] !== 'number' || !Number.isFinite(coord[0]) || !Number.isFinite(coord[1])) {
                            console.error(`Некорректная координата перед преобразованием:`, coord);
                            continue;
                        }

                        try {
                            const point = proj4('EPSG:3857', 'EPSG:4326', coord);
                            if (!Number.isFinite(point[0]) || !Number.isFinite(point[1])) {
                                console.error(`Преобразование дало некорректные значения:`, coord, '->', point);
                                continue;
                            }
                            coords.push([point[1], point[0]]);
                        } catch (e) {
                            console.error(`Ошибка преобразования координаты:`, coord, e);
                            continue;
                        }
                    }

                    if (coords.length > 0) {
                        const offsetCoords = coords.map(coord => [
                            coord[0] - mapOffsetY * 0.000008983,
                            coord[1] - mapOffsetX * 0.000008983
                        ]);

                        const polygonObj = new ymaps.Polygon([offsetCoords], {}, {
                            strokeColor: '#FFA500',
                            strokeWidth: polygonStyle.width,
                            strokeOpacity: 0.8,
                            fillColor: '#00000000',
                            hintEnabled: false,
                            hasBalloon: false,
                            interactivityModel: 'default#transparent'
                        });

                        map.geoObjects.add(polygonObj);
                        polygons.push(polygonObj);

                        const bounds = polygonObj.geometry.getBounds();
                        if (!combinedBounds) {
                            combinedBounds = bounds;
                        } else {
                            combinedBounds[0][0] = Math.min(combinedBounds[0][0], bounds[0][0]);
                            combinedBounds[0][1] = Math.min(combinedBounds[0][1], bounds[0][1]);
                            combinedBounds[1][0] = Math.max(combinedBounds[1][0], bounds[1][0]);
                            combinedBounds[1][1] = Math.max(combinedBounds[1][1], bounds[1][1]);
                        }

                        const turfContour = turf.polygon([coords.map(coord => [coord[1], coord[0]])]);
                        turfPolygons.push(turfContour);

                        const centroidFeature = turf.centroid(turfContour);
                        const centroidCoordsGeo = centroidFeature.geometry.coordinates;
                        const contourCentroid = [
                            centroidCoordsGeo[1] - mapOffsetY * 0.000008983,
                            centroidCoordsGeo[0] - mapOffsetX * 0.000008983
                        ];

                        const municipalText = new ymaps.Placemark(contourCentroid, {
                            iconContent: labelContent,
                            hintContent: labelContent
                        }, {
                            preset: 'islands#orangeStretchyIcon',
                            draggable: true // Добавлено: метка перетаскиваемая
                        });

                        map.geoObjects.add(municipalText);
                        polygons.push(municipalText);
                    }
                }
            }
        }

        if (!combinedBounds) {
            throw new Error('Не удалось определить границы полигонов');
        }

        map.setBounds(combinedBounds, {
            checkZoomRange: true,
            duration: 200
        });

        const centerGeo = [
            (combinedBounds[0][0] + combinedBounds[1][0]) / 2,
            (combinedBounds[0][1] + combinedBounds[1][1]) / 2
        ];

        getAddressByCoords(centerGeo).then(address => {
            document.getElementById('city-name-display').innerHTML = address;
        });

        const center3857 = proj4("EPSG:4326", "EPSG:3857", [centerGeo[1], centerGeo[0]]);

        lastPolygonCenter = {
            geo: { lat: centerGeo[0], lon: centerGeo[1] },
            epsg3857: { x: center3857[0], y: center3857[1] },
            native: {
                x: municipalData.features[0].geometry.coordinates[0]?.[0]?.[0]?.[0] || 0,
                y: municipalData.features[0].geometry.coordinates[0]?.[0]?.[0]?.[1] || 0
            }
        };
    } catch (error) {
        console.error('Ошибка при получении муниципального образования:', error);
        showNotification('Ошибка обработки данных муниципального образования', 'error', 'exclamation-circle');
    }
    contextMenu.style.display = 'none';
}

async function settlementsMenuItemHandler(contextMenu, map, polygons, polygonStyle, mapOffsetY, mapOffsetX, getAddressByCoords, proj4, ymaps, showNotification) {
    const lat = parseFloat(contextMenu.dataset.lat);
    const lon = parseFloat(contextMenu.dataset.lon);

    try {
        const settlementsData = await querySettlementsInfo(lat, lon);

        if (!settlementsData || !settlementsData.features || settlementsData.features.length === 0) {
            showNotification('Населённый пункт не найден', 'error', 'exclamation-circle');
            contextMenu.style.display = 'none';
            return;
        }

        let combinedBounds = null;
        const turfPolygons = [];

        for (const feature of settlementsData.features) {
            if (!feature.geometry || !feature.geometry.coordinates) {
                console.error('Геометрия или координаты отсутствуют в данных:', feature);
                continue;
            }

            const isMultiPolygon = feature.geometry.type === 'MultiPolygon';
            const polygonsCoords = isMultiPolygon ? feature.geometry.coordinates : [feature.geometry.coordinates];

            const label = feature.properties.label || "Без названия";
            const name = feature.properties.options && feature.properties.options.name 
                ? feature.properties.options.name 
                : 'Не указано';
            const labelContent = `${label} - ${name}`;

          //  console.log('Сформированная метка:', labelContent);

            for (let polygonIndex = 0; polygonIndex < polygonsCoords.length; polygonIndex++) {
                const polygonCoords = polygonsCoords[polygonIndex];

                for (let contourIndex = 0; contourIndex < polygonCoords.length; contourIndex++) {
                    const contour = polygonCoords[contourIndex];
                    if (!Array.isArray(contour)) {
                        console.error(`Некорректный формат контура в полигоне:`, contour);
                        continue;
                    }

                    const coords = [];
                    for (const coord of contour) {
                        if (!Array.isArray(coord) || coord.length !== 2 || typeof coord[0] !== 'number' || typeof coord[1] !== 'number' || !Number.isFinite(coord[0]) || !Number.isFinite(coord[1])) {
                            console.error(`Некорректная координата перед преобразованием:`, coord);
                            continue;
                        }

                        try {
                            const point = proj4('EPSG:3857', 'EPSG:4326', coord);
                            if (!Number.isFinite(point[0]) || !Number.isFinite(point[1])) {
                                console.error(`Преобразование дало некорректные значения:`, coord, '->', point);
                                continue;
                            }
                            coords.push([point[1], point[0]]);
                        } catch (e) {
                            console.error(`Ошибка преобразования координаты:`, coord, e);
                            continue;
                        }
                    }

                    if (coords.length > 0) {
                        const offsetCoords = coords.map(coord => [
                            coord[0] - mapOffsetY * 0.000008983,
                            coord[1] - mapOffsetX * 0.000008983
                        ]);

                        const polygonObj = new ymaps.Polygon([offsetCoords], {}, {
                            strokeColor: '#FFED29',
                            strokeWidth: polygonStyle.width,
                            strokeOpacity: 0.8,
                            fillColor: '#00000000',
                            hintEnabled: false,
                            hasBalloon: false,
                            interactivityModel: 'default#transparent'
                        });

                        map.geoObjects.add(polygonObj);
                        polygons.push(polygonObj);

                        const bounds = polygonObj.geometry.getBounds();
                        if (!combinedBounds) {
                            combinedBounds = bounds;
                        } else {
                            combinedBounds[0][0] = Math.min(combinedBounds[0][0], bounds[0][0]);
                            combinedBounds[0][1] = Math.min(combinedBounds[0][1], bounds[0][1]);
                            combinedBounds[1][0] = Math.max(combinedBounds[1][0], bounds[1][0]);
                            combinedBounds[1][1] = Math.max(combinedBounds[1][1], bounds[1][1]);
                        }

                        const turfContour = turf.polygon([coords.map(coord => [coord[1], coord[0]])]);
                        turfPolygons.push(turfContour);

                        const centroidFeature = turf.centroid(turfContour);
                        const centroidCoordsGeo = centroidFeature.geometry.coordinates;
                        const contourCentroid = [
                            centroidCoordsGeo[1] - mapOffsetY * 0.000008983,
                            centroidCoordsGeo[0] - mapOffsetX * 0.000008983
                        ];

                        const settlementText = new ymaps.Placemark(contourCentroid, {
                            iconContent: labelContent,
                            hintContent: labelContent
                        }, {
                            preset: 'islands#yellowStretchyIcon',
                            draggable: true // Добавлено: метка перетаскиваемая
                        });

                        map.geoObjects.add(settlementText);
                        polygons.push(settlementText);
                    }
                }
            }
        }

        if (!combinedBounds) {
            throw new Error('Не удалось определить границы полигонов');
        }

        map.setBounds(combinedBounds, {
            checkZoomRange: true,
            duration: 200
        });

        const centerGeo = [
            (combinedBounds[0][0] + combinedBounds[1][0]) / 2,
            (combinedBounds[0][1] + combinedBounds[1][1]) / 2
        ];

        getAddressByCoords(centerGeo).then(address => {
            document.getElementById('city-name-display').innerHTML = address;
        });

        const center3857 = proj4("EPSG:4326", "EPSG:3857", [centerGeo[1], centerGeo[0]]);

        lastPolygonCenter = {
            geo: { lat: centerGeo[0], lon: centerGeo[1] },
            epsg3857: { x: center3857[0], y: center3857[1] },
            native: {
                x: settlementsData.features[0].geometry.coordinates[0]?.[0]?.[0]?.[0] || 0,
                y: settlementsData.features[0].geometry.coordinates[0]?.[0]?.[0]?.[1] || 0
            }
        };
    } catch (error) {
        console.error('Ошибка при получении населённого пункта:', error);
        showNotification('Ошибка обработки данных населённого пункта', 'error', 'exclamation-circle');
    }
    contextMenu.style.display = 'none';
}


function copyPolygonCoordinatesAndOpenSite(targetPolygon) {
    const coordinates = targetPolygon.geometry.getCoordinates()[0];
    const coordsText = coordinates.map(coord => `${coord[0].toFixed(8)}\t${coord[1].toFixed(8)}`).join('\n');

    navigator.clipboard.writeText(coordsText).then(() => {
        showNotification('Координаты скопированы', 'success', 'check-circle');
        window.open('https://polygon.top/ws/csc/', '_blank');
    }).catch(err => {
        console.error('Ошибка при копировании координат:', err);
        showNotification('Ошибка при копировании координат', 'error', 'exclamation-circle');
    });
}


function getApproximateAltitude(zoom) {
    const altitudes = { // zoom: altitude_in_meters
        0: 40000000, 1: 20000000, 2: 10000000, 3: 5000000,
        4: 2500000,  5: 1200000,  6: 600000,   7: 300000,
        8: 150000,   9: 75000,    10: 35000,   11: 15000,
        12: 7000,    13: 3500,    14: 1700,    15: 850,
        16: 400,     17: 200,     18: 100,     19: 50,
        20: 25,      21: 12,
    };
    let baseAlt = altitudes[zoom] || (zoom < 0 ? altitudes[0] : altitudes[21]);
    const correctedAlt = baseAlt * ALTITUDE_CORRECTION_FACTOR;

    let formattedAlt;
    if (correctedAlt >= 1000) {
        // Используем toFixed для контроля над разделителем и затем заменяем, если нужно
        formattedAlt = (correctedAlt / 1000).toFixed(1).replace(',', '.') + ' км'; // Используем replace(',', '.') на всякий случай, если toFixed вернет запятую в какой-то локали
    } else {
        formattedAlt = Math.round(correctedAlt).toString() + ' м';
    }
    // Возвращаем только значение, префикс "Высота: ~" НЕ добавляем здесь
    return formattedAlt;
}


        // NEW FUNCTION: Update the camera height label
  function toggleCameraHeightLabelVisibility() {
            const checkbox = document.getElementById('toggleHeightLabel');
            isCameraHeightLabelVisible = checkbox.checked;
            localStorage.setItem('isCameraHeightLabelVisible', isCameraHeightLabelVisible);
            applyCameraHeightLabelVisibility();
        }

        // НОВАЯ ФУНКЦИЯ для применения сохраненной видимости
        function applyCameraHeightLabelVisibility() {
            if (cameraHeightLabelElement) {
                if (isCameraHeightLabelVisible) {
                    cameraHeightLabelElement.classList.add('visible');
                    updateCameraHeightLabel(); // Обновить текст, если метка становится видимой
                } else {
                    cameraHeightLabelElement.classList.remove('visible');
                }
            }
        }

        // МОДИФИКАЦИЯ: Update the camera height and map overview label
function updateCameraHeightLabel() {
    if (!map || !cameraHeightLabelElement || !isCameraHeightLabelVisible) {
        if (cameraHeightLabelElement) cameraHeightLabelElement.classList.remove('visible');
        return;
    }
    cameraHeightLabelElement.classList.add('visible'); // Убедимся, что класс есть

    const zoom = map.getZoom();
    const altitudeValue = getApproximateAltitude(zoom); // Получаем ТОЛЬКО значение высоты

    let overviewText = "н/д"; // Значение по умолчанию для обзора
    try {
        const bounds = map.getBounds();
        if (bounds && bounds[0] && bounds[1]) {
            const southWest = bounds[0];
            const northEast = bounds[1];

            const widthPoint1 = [southWest[0], southWest[1]];
            const widthPoint2 = [southWest[0], northEast[1]];
            const visibleWidthMeters = ymaps.coordSystem.geo.getDistance(widthPoint1, widthPoint2);

            const heightPoint1 = [southWest[0], southWest[1]];
            const heightPoint2 = [northEast[0], southWest[1]];
            const visibleHeightMeters = ymaps.coordSystem.geo.getDistance(heightPoint1, heightPoint2);

            const formatDimension = (meters) => {
                if (meters >= 1000) {
                    return (meters / 1000).toFixed(1).replace(',', '.') + ' км';
                } else {
                    return Math.round(meters).toString() + ' м';
                }
            };
            overviewText = `${formatDimension(visibleWidthMeters)} × ${formatDimension(visibleHeightMeters)}`;
        }
    } catch (error) {
        console.error("Ошибка при расчете обзора карты:", error);
        // overviewText останется "н/д"
    }

    // Формируем HTML для метки с иконками и значениями
    cameraHeightLabelElement.innerHTML = `
        <i class="fas fa-mountain" title="Высота камеры"></i> ${altitudeValue}
        <span style="margin: 0 5px;">|</span>
        <i class="fas fa-expand-arrows-alt" title="Обзор карты"></i> ${overviewText}
    `;
}


function stopDistanceMeasurement() {
    distanceMeasurementActive = false;
    mapElement.classList.remove('measuring-distance');
    map.events.remove('click', onMapClickForDistance);
    map.events.remove('dblclick', onMapDoubleClickForDistance);
    // Don’t clear polygons here to preserve the distance objects, but ensure labels are handled correctly in updateTotalDistanceLabel
}
    

function initMap() {
    // Загружаем сохраненный центр и масштаб из localStorage
    const savedCenterStr = localStorage.getItem('mapCenter');
    const savedZoomStr = localStorage.getItem('mapZoom');

    // Если данные есть - используем их, иначе - значения по умолчанию
    const initialCenter = savedCenterStr ? JSON.parse(savedCenterStr) : [54.8492, 50.7910];
    const initialZoom = savedZoomStr ? parseInt(savedZoomStr, 10) : 9;

    map = new ymaps.Map('map', {
        center: initialCenter,
        zoom: initialZoom,
        controls: [],
        behaviors: ['default']
    });

    // Получаем ссылку на метку высоты
    cameraHeightLabelElement = document.getElementById('camera-height-label');

    const savedVisibility = localStorage.getItem('isCameraHeightLabelVisible');
    isCameraHeightLabelVisible = savedVisibility === 'true';
    applyCameraHeightLabelVisibility();

    map.behaviors.enable(['scrollZoom', 'drag', 'multiTouch']);

    // ЕДИНЫЙ обработчик события boundschange
    map.events.add('boundschange', function (e) {
        // Debounce для сохранения состояния карты, чтобы не делать это слишком часто
        clearTimeout(debounceTimer);
        debounceTimer = setTimeout(() => {
            if (map) { // Убедимся, что карта все еще существует
                localStorage.setItem('mapCenter', JSON.stringify(map.getCenter()));
                localStorage.setItem('mapZoom', map.getZoom());
            }
        }, 500); // Сохраняем через 500ms после последнего изменения

        // Существующая логика из старых обработчиков
        if (e.get('newZoom') !== e.get('oldZoom')) {
            updatePlacemarksVisibility();
        }
        if (isCameraHeightLabelVisible) {
            updateCameraHeightLabel();
        }
    });
    

numberedPointSize = parseInt(localStorage.getItem('numberedPointSize'), 10) || 14;
  numberedDotSize = parseInt(localStorage.getItem('numberedDotSize'), 10) || 10;

    // Обновляем метки при добавлении на карту
    map.geoObjects.events.add('add', function (e) {
        const target = e.get('child');
        if (target instanceof ymaps.Placemark && target.options.get('iconLayout') === customPlacemarkLayout) {
            target.events.add('mapchange', function () {
                const layout = target.getOverlaySync()?.getLayoutSync();
                if (layout) {
                    layout.onMapChange();
                }
            });
        }
    });

    map.events.add('click', function (e) {
        if (selectedPlacemark) {
            selectedPlacemark = null;
        }
    });

    map.geoObjects.events.add('dragstart', function (e) {
        const target = e.get('target');
        if (target instanceof ymaps.Placemark) {
            // console.log('Начало перетаскивания метки:', target.properties.get('iconContent'));
        }
    });

    map.geoObjects.events.add('dragend', function (e) {
        const target = e.get('target');
        if (target instanceof ymaps.Placemark) {
            const newCoords = target.geometry.getCoordinates();
            const content = target.properties.get('iconContent') || 'Метка';
            //     console.log('Метка перемещена в:', newCoords);
            //   showNotification(`Метка ${content} перемещена`, 'success', 'check-circle');
        }
    });

    // Обработчик клика по объектам на карте
    map.geoObjects.events.add('click', function (e) {
        const target = e.get('target');

        // --- ЛОГИКА ВЫДЕЛЕНИЯ ЛИНИИ ---
        if (target && target.isDrawableLine === true && target instanceof ymaps.Polyline) {
            if (selectedLine && selectedLine !== target) {
                if (selectedLine.originalStyle) {
                    selectedLine.options.set({
                        strokeColor: selectedLine.originalStyle.strokeColor,
                        strokeWidth: selectedLine.originalStyle.strokeWidth
                    });
                } else {
                     selectedLine.options.set({
                         strokeColor: currentLineColor,
                         strokeWidth: currentLineWidth
                     });
                }
            }
            selectedLine = target;
            if (!selectedLine.originalStyle) {
                 selectedLine.originalStyle = {
                     strokeColor: selectedLine.options.get('strokeColor', currentLineColor),
                     strokeWidth: selectedLine.options.get('strokeWidth', currentLineWidth)
                 };
            }
            selectedLine.options.set({
                strokeColor: '#FFFF00',
                strokeWidth: selectedLine.originalStyle.strokeWidth + 2
            });
            if (selectedPlacemark) {
                 selectedPlacemark = null;
            }
            e.stopPropagation();
            return;
        }
        // --- КОНЕЦ ЛОГИКИ ВЫДЕЛЕНИЯ ЛИНИИ ---

        if (target instanceof ymaps.Placemark) {
            if (selectedLine) {
                if (selectedLine.originalStyle) {
                    selectedLine.options.set({
                        strokeColor: selectedLine.originalStyle.strokeColor,
                        strokeWidth: selectedLine.originalStyle.strokeWidth
                    });
                } else {
                    selectedLine.options.set({
                        strokeColor: currentLineColor,
                        strokeWidth: currentLineWidth
                    });
                }
                 selectedLine = null;
            }

            if (selectedPlacemark && selectedPlacemark !== target) {
                 selectedPlacemark = null;
            }
            selectedPlacemark = target;
            const nextColor = getNextStandardColor(target);
            const currentContent = target.properties.get('iconContent') || '';
            target.options.set({ preset: `islands#${nextColor}StretchyIcon` });
            if (currentContent) { target.properties.set('iconContent', currentContent); }
            e.stopPropagation();
            return;
        }

        if (selectedLine) {
            if (selectedLine.originalStyle) {
                selectedLine.options.set({
                    strokeColor: selectedLine.originalStyle.strokeColor,
                    strokeWidth: selectedLine.originalStyle.strokeWidth
                });
            } else {
                 selectedLine.options.set({
                     strokeColor: currentLineColor,
                     strokeWidth: currentLineWidth
                 });
            }
            selectedLine = null;
        }
    });

    const vriLegendList = document.getElementById('vri-legend-list');
    if (vriLegendList) {
        vriLegendList.addEventListener('click', handleVriLegendClick);
    } else {
        console.error("VRI Legend list element not found!");
    }

    map.events.add('click', function(e) {
        if (selectedLine) {
            if (selectedLine.originalStyle) {
                selectedLine.options.set({
                    strokeColor: selectedLine.originalStyle.strokeColor,
                    strokeWidth: selectedLine.originalStyle.strokeWidth
                });
            } else {
                 selectedLine.options.set({
                     strokeColor: currentLineColor,
                     strokeWidth: currentLineWidth
                 });
            }
            selectedLine = null;
        }
         if (selectedPlacemark) {
              selectedPlacemark = null;
         }
    });

    map.events.add('dblclick', function (e) {
        const coords = e.get('coords');
        ymaps.geocode(coords).then(function (res) {
            const firstGeoObject = res.geoObjects.get(0);
            if (firstGeoObject) {
                const address = firstGeoObject.getAddressLine();
                document.getElementById('city-name-display').innerHTML = address;
            } else {
                document.getElementById('city-name-display').innerHTML = 'Адрес не найден';
            }
        });
    });

    // Создание контекстного меню
    const contextMenu = document.createElement('div');
    contextMenu.className = 'custom-context-menu';
    contextMenu.style.display = 'none';
    document.body.appendChild(contextMenu);

   // НАЙДИТЕ ЭТОТ БЛОК ВНУТРИ ФУНКЦИИ initMap() И ЗАМЕНИТЕ ЕГО ПОЛНОСТЬЮ

contextMenu.innerHTML = `
     
    <!-- Меню Квартал (Тематика) -->
    <div class="custom-context-menu-item" id="theme-main-menu-item">
        <i class="fas fa-city"></i>Квартал
        <div class="custom-context-submenu">
   <div class="custom-context-menu-item" id="parcels-nearby-menu-item">
                <i class="fas fa-bullseye"></i>Земельные участки рядом 
            </div>
                       

 <div class="custom-context-menu-item" id="all-parcels-in-quarter-menu-item">
                <i class="fas fa-layer-group"></i>Земельные участки в квартале
            </div>
            
           
            <div class="custom-context-menu-item" id="all-buildings-in-quarter-menu-item">
                <i class="fas fa-building"></i>Здания в квартале
            </div>
            <div class="custom-context-menu-item" id="all-structures-in-quarter-menu-item">
                <i class="fas fa-project-diagram"></i>Сооружения в квартале
            </div>
            <div class="custom-context-menu-item" id="all-zouits-in-quarter-menu-item">
                <i class="fas fa-exclamation-triangle"></i>ЗОУИТ в квартале
            </div>
            <div class="custom-context-menu-item" id="quarter-menu-item">
                <i class="fas fa-th"></i>Границы квартала
            </div>
            <div class="custom-context-menu-item" id="theme-ownership-item">
                <i class="fas fa-home"></i>Собственность
            </div>
            <div class="custom-context-menu-item" id="theme-use-item">
                <i class="fas fa-map-marked-alt"></i>Разрешенное использование
            </div>
            <div class="custom-context-menu-item" id="theme-cost-item">
                <i class="fas fa-dollar-sign"></i>Стоимость
            </div>
            <div class="custom-context-menu-item" id="theme-registration-date-item">
                <i class="far fa-calendar-alt"></i>Дата внесения
            </div>
            <div class="custom-context-menu-item" id="theme-ulu-item">
                <i class="fas fa-network-wired"></i>Единое землепользование
            </div>
            <div class="custom-context-menu-item" id="theme-none-item">
                <i class="fas fa-ban"></i>Сбросить
            </div>
            <div class="custom-context-menu-item" id="theme-import-item">
                <i class="fas fa-file-upload"></i>Архив КПТ
            </div>
            
                <div class="custom-context-menu-item" id="update-ez-menu-item">
                <i class="fas fa-sync-alt"></i>Обновить ЕЗ
            </div>
            
            <div class="custom-context-menu-item" id="theme-export-item">
                <i class="fas fa-file-excel"></i>Экспорт
            </div>
        </div>
    </div>

<!-- Меню Объект -->
<div class="custom-context-menu-item" id="object-menu-item">
    <i class="fas fa-file-alt"></i>Объект
    <div class="custom-context-submenu">
        <div class="custom-context-menu-item" id="egrn-html-menu-item">
            <i class="fas fa-file-alt"></i>ЕГРН
        </div>
        <div class="custom-context-menu-item" id="egrn-xml-menu-item">
            <i class="fas fa-file-code"></i>Открыть КН в XML
        </div>
        
          <div class="custom-context-menu-item" id="oks-on-zu-menu-item">
        <i class="fas fa-list-ol"></i>Связанные ОКС на ЗУ
    </div>
    
        <div class="custom-context-menu-item" id="all-oks-on-object-menu-item">
            <i class="fas fa-building"></i>ОКС на объекте
        </div>
        <div class="custom-context-menu-item" id="all-structures-on-object-menu-item">
            <i class="fas fa-project-diagram"></i>Сооружения на объекте
        </div>
        <div class="custom-context-menu-item" id="all-zouits-on-object-menu-item">
            <i class="fas fa-search-plus"></i>ЗОУИТ на объекте
        </div>
        
        <div class="custom-context-menu-item" id="consolidated-report-menu-item">
            <i class="fas fa-file-invoice"></i>Отчет (площадной)
        </div>
        <div class="custom-context-menu-item" id="linear-report-menu-item">
            <i class="fas fa-road"></i>Отчет (линейный)
        </div>

     <div class="custom-context-menu-item" id="export-current-polygon-to-kml-menu-item">
                <i class="fas fa-file-export"></i> Экспорт в KML Google Earth
            </div>
            
    </div>
</div>

<!-- Меню Координаты -->


    <!-- Меню Границы -->
    <div class="custom-context-menu-item" id="boundaries-menu-item">
        <i class="fas fa-border-style"></i>Границы
        <div class="custom-context-submenu">
            <div class="custom-context-menu-item" id="cadastre-menu-item">
                <i class="fas fa-draw-polygon"></i>Открыть ЗУ
            </div>
            <div class="custom-context-menu-item" id="oks-menu-item">
                <i class="fas fa-building"></i>Открыть ОКС
            </div>
            <div class="custom-context-menu-item" id="terr-zone-menu-item">
                <i class="fas fa-globe"></i>Территориальные зоны
            </div>
            <div class="custom-context-menu-item" id="zouit-menu-item">
                <i class="fas fa-exclamation-triangle"></i>ЗОУИТ
            </div>
            <div class="custom-context-menu-item" id="settlements-menu-item">
                <i class="fas fa-home"></i>Населенные пункты
            </div>
            <div class="custom-context-menu-item" id="municipal-menu-item">
                <i class="fas fa-city"></i>Муниципальные образования
            </div>
            <div class="custom-context-menu-item" id="forestry-menu-item">
                <i class="fas fa-tree"></i>Лесничество
            </div>
       
            <div class="custom-context-menu-item" id="arbitrary-response-menu-item">
<i class="fas fa-paste"></i>Импорт из JSON
</div>
        </div>
    </div>
    
    
    <div class="custom-context-menu-item" id="coordinates-menu-item">
    <i class="fas fa-map-marked-alt"></i>МСК
    <div class="custom-context-submenu">
     
        <div class="custom-context-menu-item" id="coords-msk-menu-item">
            <i class="fas fa-ruler-combined"></i>Объект в МСК
        </div>
        <div class="custom-context-menu-item" id="convert-all-msk-menu-item">
            <i class="fas fa-layer-group"></i>Все объекты в МСК
        </div>
        
           <div class="custom-context-menu-item" id="georedaсtor-all-objects-menu-item">
            <i class="fas fa-drafting-compass"></i>Георедактор
        </div>
        
        <div class="custom-context-menu-item" id="quarter-msk-xml-menu-item">
            <i class="fas fa-file-archive"></i>ЗУ в XML КПТ
        </div>
        <div class="custom-context-menu-item" id="schema-xml-all-objects-menu-item">
            <i class="fas fa-sitemap"></i>Все объекты в XML
        </div>
    </div>
</div>
    
    <!-- Остальные пункты -->
  
    <div class="custom-context-menu-item" id="distance-menu-item">
        <i class="fas fa-ruler"></i>Расстояние
    </div>
    <div class="custom-context-menu-item" id="area-menu-item">
        <i class="fas fa-vector-square"></i>Площадь
    </div>
    <div class="custom-context-menu-item" id="location-menu-item">
        <i class="fas fa-map-pin"></i>Местоположение
    </div>
    <div class="custom-context-menu-item" id="find-on-map-menu-item">
        <i class="fas fa-search-location"></i>Наложения
    </div>
    <div class="custom-context-menu-item" id="copy-cadastre-number-menu-item">
        <i class="fas fa-copy"></i>Копировать
    </div>
    <div class="custom-context-menu-item" id="copy-coords-menu-item">
        <i class="far fa-copy"></i>Координаты
        <div class="custom-context-submenu">
            <div class="custom-context-menu-item" id="copy-coords-menu-item">
                <i class="fas fa-map-marker-alt"></i>Точка в WGS84
            </div>
            
              <div class="custom-context-menu-item" id="open-mapmini-menu-item">
            <i class="fas fa-map"></i>Карта Мини
        </div>
            <div class="custom-context-menu-item" id="copy-all-epsg3857-menu-item">
                <i class="fas fa-ruler-combined"></i>Все в EPSG:3857
            </div>
        </div>
    </div>
    <div class="custom-context-menu-item" id="screenshot-menu-item">
        <i class="fas fa-camera"></i>Экран
    </div>
    
     <div class="custom-context-menu-item" id="raster-menu-item">
        <i class="fas fa-image"></i>Растр
    </div>
    
    
    <div class="custom-context-menu-item" id="change-color-menu-item">
        <i class="fas fa-edit"></i>Изменить
    </div>
`;

    // Показ контекстного меню при правом клике
    map.events.add('contextmenu', function (e) {
        e.preventDefault();
        const coords = e.get('coords');
        const position = e.get('position');
        contextMenu.style.left = position[0] + 'px';
        contextMenu.style.top = position[1] + 'px';
        contextMenu.style.display = 'block';

        contextMenu.dataset.lat = coords[0].toFixed(8);
        contextMenu.dataset.lon = coords[1].toFixed(8);
    });

    // Закрытие контекстного меню при клике вне его
    document.addEventListener('click', function (e) {
        if (!contextMenu.contains(e.target)) {
            contextMenu.style.display = 'none';
        }
    });

    document.addEventListener('touchstart', function (e) {
        if (!contextMenu.contains(e.target)) {
            contextMenu.style.display = 'none';
        }
    });

    // Обработка кликов по элементам контекстного меню
        // Обработка кликов по элементам контекстного меню
contextMenu.addEventListener('click', async function (event) {
        if (event.target.id === 'area-menu-item') {
            contextMenu.style.display = 'none';
            measureArea();
        }
        
        if (event.target.id === 'linear-report-menu-item') {
    contextMenu.style.display = 'none';
    
    // Сначала ищем выделенную линию
    let targetObject = selectedLine;
    
    // Если линия не выделена, ищем под курсором
    if (!targetObject) {
        const lat = parseFloat(contextMenu.dataset.lat);
        const lon = parseFloat(contextMenu.dataset.lon);
        targetObject = findLineAtPoint(lat, lon);
    }
    
    // Если конкретная линия не найдена, ищем все линии на карте
    if (!targetObject) {
        const linearObjects = polygons.filter(obj => 
            obj instanceof ymaps.Polyline && obj.properties.get('isDrawableLine')
        );
        
        if (linearObjects.length === 0) {
            showNotification('На карте нет добавленных линейных объектов для отчета', 'warning');
        } else if (linearObjects.length === 1) {
            generateLinearObjectReport(linearObjects[0]); // Если линия одна, сразу отчет
        } else {
            showLineSelectionModal(linearObjects); // Если несколько, предлагаем выбор
        }
    } else {
        generateLinearObjectReport(targetObject); // Если нашли конкретную, отчет для нее
    }
}

     if (event.target.id === 'arbitrary-response-menu-item') {
            contextMenu.style.display = 'none';
            showArbitraryResponseModal(); // Вызываем новую функцию для показа окна
        }


if (event.target.id === 'raster-menu-item') {
    contextMenu.style.display = 'none';

    // Просто создаем и показываем панель, если ее еще нет.
    if (!rasterControlsPanel) {
        createRasterControls();
    }
    // Больше ничего не делаем.
}
        
          if (event.target.id === 'consolidated-report-menu-item') {
            const lat = parseFloat(contextMenu.dataset.lat);
            const lon = parseFloat(contextMenu.dataset.lon);
            
            // --- НАЧАЛО НОВОЙ ЛОГИКИ ---
            showLoader("Поиск объекта для отчета...");
            contextMenu.style.display = 'none';

            try {
                let targetPolygon = findPolygonAtPoint(lat, lon);
                
                // Если полигон не найден на карте, пытаемся его загрузить
                if (!targetPolygon) {
                    showLoader("Объект не найден, загрузка из ЕГРН...");
                    
                    // Используем логику из пункта "Открыть ЗУ"
                    const cadastralData = await queryCadastralInfo(lat, lon);
                    if (!cadastralData || !cadastralData.features || cadastralData.features.length === 0) {
                        throw new Error('Не удалось найти или загрузить объект для формирования отчета.');
                    }
                    const feature = cadastralData.features[0];
                    
                    // Отрисовываем объект и получаем ссылку на него
                    targetPolygon = await drawFeatureFromNspd(feature);
                }

                // Если после всех попыток полигон есть, генерируем отчет
                if (targetPolygon) {
                    await generateConsolidatedReport(targetPolygon);
                } else {
                    throw new Error("Не удалось найти или загрузить объект для отчета.");
                }

            } catch (error) {
                console.error("Ошибка при подготовке отчета:", error);
                showNotification(error.message, 'error', 'exclamation-circle');
                hideLoader(); // Убедимся, что лоадер скрыт в случае ошибки
            }
            // hideLoader() теперь вызывается внутри generateConsolidatedReport или в блоке catch
            // --- КОНЕЦ НОВОЙ ЛОГИКИ ---

        }
        
        
        
        if (event.target.id === 'open-mapmini-menu-item') {
    // Действие 1: Копируем логику из пункта "Точка в WGS84"
    const lat = parseFloat(contextMenu.dataset.lat);
    const lon = parseFloat(contextMenu.dataset.lon);
    navigator.clipboard.writeText(`${lat} ${lon}`);
    showNotification('Координаты скопированы, открывается Карта Мини...', 'success', 'check-circle');

    const placemark = new ymaps.Placemark([lat, lon], {
        iconContent: `Широта: ${lat}\nДолгота: ${lon}`
    }, {
        preset: 'islands#orangeStretchyIcon',
        draggable: true
    });
    map.geoObjects.add(placemark);
    polygons.push(placemark);

    // Действие 2: Открываем новую вкладку с mapmini.html
    window.open('mapmini.html', '_blank');

    contextMenu.style.display = 'none';
}

        
             if (event.target.id === 'screenshot-menu-item') {
            contextMenu.style.display = 'none';
            takeScreenshot(); // Просто вызываем новую функцию
        }
        
           if (event.target.id === 'theme-export-item') {
             contextMenu.style.display = 'none'; // Закрываем меню
            handleExportAction(); // <--- ИЗМЕНЕНО ЗДЕСЬ
        }
        
        
           if (event.target.id === 'update-ez-menu-item') {
            contextMenu.style.display = 'none';
            handleEzUpdateWorkflow();
        }
        
             // Обновляем ID для существующего обработчика ЗОУИТ
        if (event.target.id === 'all-zouits-on-object-menu-item') { // <-- ID ИЗМЕНЕН
            const lat = parseFloat(contextMenu.dataset.lat);
            const lon = parseFloat(contextMenu.dataset.lon);
            await getAllZouitsInObject(lat, lon); 
            contextMenu.style.display = 'none';
        }

        // НОВЫЙ ОБРАБОТЧИК ДЛЯ ОКС
        if (event.target.id === 'all-oks-on-object-menu-item') {
            const lat = parseFloat(contextMenu.dataset.lat);
            const lon = parseFloat(contextMenu.dataset.lon);
            await getAllOksInObject(lat, lon); // Вызываем новую функцию для ОКС
            contextMenu.style.display = 'none';
        }

        // НОВЫЙ ОБРАБОТЧИК ДЛЯ СООРУЖЕНИЙ
        if (event.target.id === 'all-structures-on-object-menu-item') {
            const lat = parseFloat(contextMenu.dataset.lat);
            const lon = parseFloat(contextMenu.dataset.lon);
            await getAllStructuresInObject(lat, lon); // Вызываем новую функцию для Сооружений
            contextMenu.style.display = 'none';
        }
        
            if (event.target.id === 'oks-on-zu-menu-item') {
            const lat = parseFloat(contextMenu.dataset.lat);
            const lon = parseFloat(contextMenu.dataset.lon);
            // Вызываем новую основную функцию для этого действия
            fetchOksOnZuHandler(lat, lon);
            contextMenu.style.display = 'none';
        }
        
        
        
          if (event.target.id === 'theme-import-item') {
            contextMenu.style.display = 'none';
            const clickedLat = parseFloat(contextMenu.dataset.lat);
            const clickedLon = parseFloat(contextMenu.dataset.lon);

            showLoader("Определение квартала...");
            const { x: pointX, y: pointY } = toEPSG3857(clickedLat, clickedLon); // Ensure you have toEPSG3857
            const quarterInfoFromSupabase = await findQuarterByPointSupabase(pointX, pointY);

            if (quarterInfoFromSupabase && quarterInfoFromSupabase.found_quarter_number) {
                // Quarter found in Supabase by point.
                // Set cityInput which will be picked up by triggerSupabaseImport
                cityInput.value = quarterInfoFromSupabase.found_quarter_number;
                
               //  console.log("cityInput.value SET TO (from Supabase point search):", cityInput.value); 
                // Store geometry to be drawn after map clear in triggerSupabaseImport
                window.pendingQuarterGeometryToDraw = quarterInfoFromSupabase.quarter_geometry_geojson;
                window.pendingQuarterNumber = quarterInfoFromSupabase.found_quarter_number; // Also store the number
              //  console.log(`Контекстное меню: Квартал ${quarterInfoFromSupabase.found_quarter_number} найден по точке.`);
            } else {
                // Point not in any Supabase quarter based on RPC.
                // Clear cityInput; triggerSupabaseImport will then rely on currentQuarterNumber
                // or, if archive for that fails, NSPD will try to find quarter by the clicked point.
                cityInput.value = '';
                window.pendingQuarterGeometryToDraw = null;
                window.pendingQuarterNumber = null;
                showNotification("Квартал по точке не найден в Архиве КПТ. Будет использован текущий квартал из поля ввода или поиск...", "info");
            }
            await triggerSupabaseImport(); // This will use the (potentially updated) cityInput value
        }
        
        if (event.target.id === 'theme-ulu-item') {
    setActiveTheme('ulu'); // Set the new theme
    contextMenu.style.display = 'none'; // Close the menu
}
        
            if (event.target.id === 'theme-registration-date-item') {
             setActiveTheme('registration_date'); // Set the new theme
             contextMenu.style.display = 'none'; // Close the menu
         }
         
         
         if (event.target.id === 'export-current-polygon-to-kml-menu-item') { // <--- THIS IS THE CORRECT ID
            contextMenu.style.display = 'none';
            const lat = parseFloat(contextMenu.dataset.lat);
            const lon = parseFloat(contextMenu.dataset.lon);

            // --- Логика поиска targetPolygon (остается такой же, как была для 'export-kml-zu-menu-item') ---
            // ... (existing code for finding targetPolygon) ...
            const candidatePolygons = [];
            for (const polygon of polygons) {
                if (polygon instanceof ymaps.Polygon) {
                    try {
                        const coords = polygon.geometry.getCoordinates()[0];
                        const turfPolygon = turf.polygon([coords.map(coord => [coord[1], coord[0]])]);
                        const point = turf.point([lon, lat]);
                        if (turf.booleanPointInPolygon(point, turfPolygon)) {
                            candidatePolygons.push(polygon);
                        }
                    } catch (turfError) {
                        if (polygon.geometry.contains([lat, lon])) { candidatePolygons.push(polygon); }
                    }
                }
            }
            for (const obj of areaObjects) {
                 if (obj instanceof ymaps.Polygon) {
                     try {
                        const coords = obj.geometry.getCoordinates()[0];
                        const turfPolygon = turf.polygon([coords.map(coord => [coord[1], coord[0]])]);
                        const point = turf.point([lon, lat]);
                        if (turf.booleanPointInPolygon(point, turfPolygon)) {
                            candidatePolygons.push(obj);
                        }
                    } catch(turfError) {
                         if (obj.geometry.contains([lat, lon])) { candidatePolygons.push(obj); }
                    }
                 }
            }

            if (candidatePolygons.length === 0) {
                showNotification('Контур для экспорта в KML не найден', 'warning', 'exclamation-triangle');
                return;
            }

            let targetPolygon = candidatePolygons[0];
            if (candidatePolygons.length > 1) {
                let minArea = Infinity;
                candidatePolygons.forEach(polygon => {
                    try {
                        const coords = polygon.geometry.getCoordinates()[0];
                        if (coords.length < 3) return;
                        const turfPolygon = turf.polygon([coords.map(coord => [coord[1], coord[0]])]);
                        const area = turf.area(turfPolygon);
                        if (isFinite(area) && area < minArea) {
                            minArea = area;
                            targetPolygon = polygon;
                        }
                    } catch (e) { console.error("Error calculating area for KML target polygon:", polygon, e); }
                });
            }

            if (targetPolygon) {
                const kmlContent = generateKmlForSinglePolygon(targetPolygon);
                const placemarkName = targetPolygon.properties.get('cadastralNumber') ||
                                      targetPolygon.properties.get('hintContent')?.cadastralNumber ||
                                      'Exported_Polygon';
                const safePlacemarkName = placemarkName.replace(/[^a-zA-Z0-9_.:-]/g, '_');
                const blob = new Blob([kmlContent], { type: 'application/vnd.google-earth.kml+xml;charset=utf-8' });
                saveAs(blob, `${safePlacemarkName}.kml`);
                showNotification(`KML файл для '${safePlacemarkName}' успешно создан`, 'success', 'check-circle');
                
                // START: Check setting before opening Google Earth
                if (openGoogleEarthAfterExport) {
                    window.open('https://earth.google.com/web/@0,-0.67350016,0a,22251752.77375655d,35y,0h,0t,0r/data=CgRCAggBOgMKATBCAggASg0I____________ARAA', '_blank');
                }
                // END: Check setting
            } else {
                showNotification('Не удалось определить полигон для экспорта в KML', 'error', 'exclamation-circle');
            }
        }
         
             if (event.target.id === 'theme-cost-item') {
            setActiveTheme('cost');
            contextMenu.style.display = 'none';
        }
        if (event.target.id === 'theme-use-item') {
            setActiveTheme('use');
            contextMenu.style.display = 'none';
        }
        
          if (event.target.id === 'theme-ownership-item') {
        setActiveTheme('ownership');
        contextMenu.style.display = 'none';
    }
    
        if (event.target.id === 'theme-none-item') {
            setActiveTheme('none');
            contextMenu.style.display = 'none';
        }

        if (event.target.id === 'distance-menu-item') {
            contextMenu.style.display = 'none';
            measureDistance();
        }
        
     if (event.target.id === 'theme-ulu-item') {
    setActiveTheme('ulu'); // Set the new theme
    contextMenu.style.display = 'none'; // Close the menu
}
        
if (event.target.id === 'find-on-map-menu-item') {
    showFindOnMapDialog();
    contextMenu.style.display = 'none';
}

           if (event.target.id === 'cadastre-menu-item') {
            const lat = parseFloat(contextMenu.dataset.lat);
            const lon = parseFloat(contextMenu.dataset.lon);

            try {
                // Вспомогательная функция для поиска объекта
                async function tryGetCadastralData(latitude, longitude) {
                    const cadastralData = await queryCadastralInfo(latitude, longitude);
                    if (!cadastralData || !cadastralData.features || cadastralData.features.length === 0) {
                        return null;
                    }
                    return cadastralData.features[0];
                }

                // Поиск объекта с несколькими попытками
                let feature = await tryGetCadastralData(lat, lon);
                let found = !!feature;
                let attempts = 0;
                const maxAttempts = 3;
                const squareWidthMeters = 50;
                const timeoutMs = 500;

                if (!found) {
                    const earthRadius = 6378137;
                    const latRadians = lat * Math.PI / 180;
                    const squareWidthLat = squareWidthMeters / earthRadius * (180 / Math.PI);
                    const squareWidthLon = squareWidthMeters / (earthRadius * Math.cos(latRadians)) * (180 / Math.PI);

                    while (!found && attempts < maxAttempts) {
                        attempts++;
                        const offsetLat = (Math.random() - 0.5) * squareWidthLat;
                        const offsetLon = (Math.random() - 0.5) * squareWidthLon;
                        const newLat = lat + offsetLat;
                        const newLon = lon + offsetLon;
                        feature = await tryGetCadastralData(newLat, newLon);
                        found = !!feature;
                        if (!found && attempts < maxAttempts) {
                            await new Promise(resolve => setTimeout(resolve, timeoutMs));
                        }
                    }
                }

                if (!found) {
                     showNotification('Данные не найдены, выберите для клика место с полигоном', 'error', 'exclamation-circle');
                    contextMenu.style.display = 'none';
                    return;
                }
                
                // Вместо дублирования кода отрисовки, вызываем уже исправленную функцию
                await drawFeatureFromNspd(feature);

            } catch (error) {
                console.error('Ошибка при получении участка:', error);
                showNotification('Ошибка подключения, попробуйте позже', 'error', 'exclamation-circle');
            }
            contextMenu.style.display = 'none';
        }

        if (event.target.id === 'oks-menu-item') {
            const lat = parseFloat(contextMenu.dataset.lat);
            const lon = parseFloat(contextMenu.dataset.lon);

            try {
                const oksData = await queryOKSInfo(lat, lon);

                if (!oksData || !oksData.features || oksData.features.length === 0) {
                    showNotification('Объект капитального строительства не найден', 'error', 'exclamation-circle');
                    contextMenu.style.display = 'none';
                    return;
                }

                const feature = oksData.features[0];

                if (feature.geometry && feature.geometry.coordinates) {
                    const coordinates = feature.geometry.coordinates[0].map(coord => {
                        const point = proj4('EPSG:3857', 'EPSG:4326', coord);
                        return [point[1], point[0]];
                    });

                    const offsetCoordinates = coordinates.map(coord => [
                        coord[0] - mapOffsetY * 0.000008983,
                        coord[1] - mapOffsetX * 0.000008983
                    ]);

                    const polygon = new ymaps.Polygon([offsetCoordinates], {}, {
                        strokeColor: '#00FF00',
                        strokeWidth: polygonStyle.width,
                        strokeOpacity: 0.8,
                        fillColor: '#00000000',
                        hintEnabled: false,
                        hasBalloon: false,
                        interactivityModel: 'default#transparent'
                    });

                    map.geoObjects.add(polygon);
                    polygons.push(polygon);

                    const bounds = polygon.geometry.getBounds();
                    const centerGeo = [
                        (bounds[0][0] + bounds[1][0]) / 2,
                        (bounds[0][1] + bounds[1][1]) / 2
                    ];

                    getAddressByCoords(centerGeo).then(address => {
                        document.getElementById('city-name-display').innerHTML = address;
                    });

                    const center3857 = proj4("EPSG:4326", "EPSG:3857", [centerGeo[1], centerGeo[0]]);

                    lastPolygonCenter = {
                        geo: {
                            lat: centerGeo[0],
                            lon: centerGeo[1]
                        },
                        epsg3857: {
                            x: center3857[0],
                            y: center3857[1]
                        },
                        native: {
                            x: feature.geometry.coordinates[0][0][0],
                            y: feature.geometry.coordinates[0][0][1]
                        }
                    };

                    const cadastralNumber = feature.properties.options && feature.properties.options.cad_num
                        ? feature.properties.options.cad_num
                        : 'Не указан';
                    const name = feature.properties.descr || 'Не указано';
                    const labelContent = `${cadastralNumber} - ${name}`;

                    const oksText = new ymaps.Placemark([
                        centerGeo[0] - mapOffsetY * 0.000008983,
                        centerGeo[1] - mapOffsetX * 0.000008983
                    ], {
                        iconContent: labelContent
                    }, {
                        preset: 'islands#greenStretchyIcon',
                        draggable: true
                    });

                    map.geoObjects.add(oksText);
                    polygons.push(oksText);

                    map.setBounds(bounds, {
                        checkZoomRange: true,
                        duration: 200
                    });
                }
            } catch (error) {
                console.error('Ошибка при получении ОКС:', error);
                showNotification('Ошибка подключения, попробуйте позже', 'error', 'exclamation-circle');
            }
            contextMenu.style.display = 'none';
        }

        if (event.target.id === 'terr-zone-menu-item') {
            terrZoneMenuItemHandler(contextMenu, map, polygons, polygonStyle, mapOffsetY, mapOffsetX, getAddressByCoords, proj4, ymaps, showNotification);
        }

        //ЗОУИТ
        if (event.target.id === 'zouit-menu-item') {
            zouitMenuItemHandler(contextMenu, map, polygons, polygonStyle, mapOffsetY, mapOffsetX, getAddressByCoords, proj4, ymaps, showNotification);
        }

        if (event.target.id === 'municipal-menu-item') {
            municipalMenuItemHandler(contextMenu, map, polygons, polygonStyle, mapOffsetY, mapOffsetX, getAddressByCoords, proj4, ymaps, showNotification);
        }

        if (event.target.id === 'settlements-menu-item') {
            settlementsMenuItemHandler(contextMenu, map, polygons, polygonStyle, mapOffsetY, mapOffsetX, getAddressByCoords, proj4, ymaps, showNotification);
        }
        
        if (event.target.id === 'forestry-menu-item') {
            forestryMenuItemHandler(contextMenu, map, polygons, polygonStyle, mapOffsetY, mapOffsetX, getAddressByCoords, proj4, ymaps, showNotification);
        }

    if (event.target.id === 'egrn-html-menu-item') {
            const lat = parseFloat(contextMenu.dataset.lat);
            const lon = parseFloat(contextMenu.dataset.lon);
            await handleEgrnRelatedAction(lat, lon, 'egrn.html');
            contextMenu.style.display = 'none';
        }
        // END: НОВЫЙ ОБРАБОТЧИК

        if (event.target.id === 'egrn-xml-menu-item') { // Обработчик для пункта "XML схема"
            const lat = parseFloat(contextMenu.dataset.lat);
            const lon = parseFloat(contextMenu.dataset.lon);
            await handleEgrnRelatedAction(lat, lon, 'схема_xml.html');
            contextMenu.style.display = 'none';
        }

        if (event.target.id === 'egrn-xml-menu-item') { // Обработчик для пункта "XML схема"
            const lat = parseFloat(contextMenu.dataset.lat);
            const lon = parseFloat(contextMenu.dataset.lon);
            await handleEgrnRelatedAction(lat, lon, 'схема_xml.html');
            contextMenu.style.display = 'none';
        }
        
        
          if (event.target.id === 'schema-xml-all-objects-menu-item') {
            await generateXmlForAllObjects();
            contextMenu.style.display = 'none';
        }
        
        
          if (event.target.id === 'georedaсtor-all-objects-menu-item') {
            await exportAllObjectsToGeoredaсtor();
            contextMenu.style.display = 'none';
        }
        
           if (event.target.id === 'convert-all-msk-menu-item') {
            // Вызываем новую функцию для конвертации всех объектов
            await convertAllObjectsToMskAndCopy();
            contextMenu.style.display = 'none';
        }
        
        
        if (event.target.id === 'coords-msk-menu-item') {
    const lat = parseFloat(contextMenu.dataset.lat);
    const lon = parseFloat(contextMenu.dataset.lon);
    
    // 1. Находим полигон под точкой клика
    const targetPolygon = findPolygonAtPoint(lat, lon);

    if (!targetPolygon) {
        showNotification('Объект для конвертации не найден', 'warning', 'exclamation-triangle');
        contextMenu.style.display = 'none';
        return;
    }
    
    

    // 2. Вызываем новую функцию для конвертации и копирования
    await convertAndCopyMskCoords(targetPolygon);
    contextMenu.style.display = 'none';
}

if (event.target.id === 'quarter-msk-xml-menu-item') {
    // Вызываем новую основную функцию-обработчик
    handleGenerateQuarterMskXml();
    contextMenu.style.display = 'none';
}

        if (event.target.id === 'quarter-menu-item') {
            const lat = parseFloat(contextMenu.dataset.lat);
            const lon = parseFloat(contextMenu.dataset.lon);
            getQuarterCadastre(lat, lon);
            contextMenu.style.display = 'none';
        }

        if (event.target.id === 'all-parcels-in-quarter-menu-item') {
            const lat = parseFloat(contextMenu.dataset.lat);
            const lon = parseFloat(contextMenu.dataset.lon);
         
            const quarterData = await getAllParcelsInQuarter(lat, lon); 
    /*        if (quarterData && quarterData.quarterFeature && quarterData.quarterFeature.geometry) {
                 await saveQuarterGeometryToSupabase(quarterData.quarterFeature.properties.descr, quarterData.quarterFeature.geometry);
            }
            */
         
            contextMenu.style.display = 'none';
        }
        
         if (event.target.id === 'parcels-nearby-menu-item') {
            const lat = parseFloat(contextMenu.dataset.lat);
            const lon = parseFloat(contextMenu.dataset.lon);
            await getParcelsNearby(lat, lon);
            contextMenu.style.display = 'none';
        }
        
        
    if (event.target.id === 'all-buildings-in-quarter-menu-item') { // ID изменен
    const lat = parseFloat(contextMenu.dataset.lat);
    const lon = parseFloat(contextMenu.dataset.lon);
    await getAllBuildingsInQuarter(lat, lon); // Функция переименована
    contextMenu.style.display = 'none';
}

          if (event.target.id === 'all-structures-in-quarter-menu-item') {
            const lat = parseFloat(contextMenu.dataset.lat);
            const lon = parseFloat(contextMenu.dataset.lon);
            await getAllStructuresInQuarter(lat, lon); // Вызываем новую функцию для Сооружений
            contextMenu.style.display = 'none';
        }
        
        if (event.target.id === 'all-zouits-in-quarter-menu-item') {
            const lat = parseFloat(contextMenu.dataset.lat);
            const lon = parseFloat(contextMenu.dataset.lon);
            await getAllZouitsInQuarter(lat, lon);
            contextMenu.style.display = 'none';
        }

 
const ownershipLegendList = document.getElementById('ownership-legend-list');
if (ownershipLegendList) {
    ownershipLegendList.addEventListener('click', handleOwnershipLegendClick);
} else {
    console.error("Ownership Legend list element not found!");
}

        if (event.target.id === 'location-menu-item') {
            if (navigator.geolocation) {
                navigator.geolocation.getCurrentPosition(
                    function (position) {
                        const latitude = position.coords.latitude;
                        const longitude = position.coords.longitude;

                        map.setCenter([latitude, longitude], 15);

                        const placemark = new ymaps.Placemark([latitude, longitude], {
                            hintContent: 'Ваше местоположение'
                        }, {
                            preset: 'islands#redDotIcon',
                            draggable: true
                        });
                        map.geoObjects.add(placemark);
                        polygons.push(placemark);

                        getAddressByCoords([latitude, longitude]).then(address => {
                            document.getElementById('city-name-display').innerHTML = address;
                        });



                        showNotification('Ваше местоположение найдено', 'success', 'check-circle');
                    },
                    function (error) {
                        console.error('Ошибка при получении местоположения:', error);
                        showNotification('Не удалось определить местоположение', 'error', 'exclamation-circle');
                    }
                );
            } else {
                showNotification('Браузер не поддерживает Geolocation API', 'error', 'exclamation-circle');
            }
            contextMenu.style.display = 'none';
        }

      if (event.target.id === 'copy-cadastre-number-menu-item') {
    try {
        let candidateNumbers = [];
        map.geoObjects.each(function (geoObject) {
            if (geoObject instanceof ymaps.Placemark && geoObject.properties.get('iconContent')) {
                const content = geoObject.properties.get('iconContent');
                // Исключаем номера, начинающиеся с двоеточия и следующих за ним цифр
                if (!/^\s*:\d+/.test(content) && !candidateNumbers.includes(content)) {
                    candidateNumbers.push(content);
                }
            }
        });

        // --- НАЧАЛО ИЗМЕНЕНИЙ ---
        // Получаем координаты клика и ищем полигон под ними
        const lat = parseFloat(contextMenu.dataset.lat);
        const lon = parseFloat(contextMenu.dataset.lon);
        const targetPolygon = findPolygonAtPoint(lat, lon); // Используем существующую функцию

        if (targetPolygon) {
            const polygonCadNum = targetPolygon.properties.get('cadastralNumber');
            // Если у полигона есть КН и его еще нет в списке, добавляем в начало
            if (polygonCadNum && !candidateNumbers.includes(polygonCadNum)) {
                candidateNumbers.unshift(polygonCadNum);
            }
        }
        // --- КОНЕЦ ИЗМЕНЕНИЙ ---

        // Получаем текст из city-name-display
        const cityNameDisplayElement = document.getElementById('city-name-display');
        const cityName = cityNameDisplayElement.textContent.trim();

        // Добавляем текст city-name-display в список кандидатов, если он не пустой и еще не включен
        if (cityName && !candidateNumbers.includes(cityName)) {
            candidateNumbers = [cityName, ...candidateNumbers]; // Добавляем в начало списка
        }

        if (candidateNumbers.length === 1) {
            await navigator.clipboard.writeText(candidateNumbers[0]);
            showNotification(`Скопировано: ${candidateNumbers[0]}`, 'success', 'check-circle');
        } else if (candidateNumbers.length > 1) {
            showSelectionModal(candidateNumbers);
        } else {
            showNotification('Текст для копирования не найден', 'error', 'exclamation-circle');
        }
    } catch (error) {
        console.error('Ошибка при копировании:', error);
        showNotification('Ошибка при копировании', 'error', 'exclamation-circle');
    }
    contextMenu.style.display = 'none';
}


if (event.target.id === 'copy-all-epsg3857-menu-item') {
        await copyAllObjectsToEPSG3857();
        contextMenu.style.display = 'none';
    }
    
    
        if (event.target.id === 'copy-coords-menu-item') {
            const lat = parseFloat(contextMenu.dataset.lat);
            const lon = parseFloat(contextMenu.dataset.lon);
            navigator.clipboard.writeText(`${lat} ${lon}`);
            showNotification('Координаты скопированы', 'success', 'check-circle');

            const placemark = new ymaps.Placemark([lat, lon], {
                iconContent: `Широта: ${lat}\nДолгота: ${lon}`
            }, {
                preset: 'islands#orangeStretchyIcon',
                draggable: true
            });
            map.geoObjects.add(placemark);
            polygons.push(placemark);

            contextMenu.style.display = 'none';
        }



if (event.target.id === 'change-color-menu-item') {
    const lat = parseFloat(contextMenu.dataset.lat);
    const lon = parseFloat(contextMenu.dataset.lon);

    const candidatePolygons = [];
    for (const polygon of polygons) {
        if (polygon instanceof ymaps.Polygon) {
            try {
                const coords = polygon.geometry.getCoordinates()[0];
                const turfPolygon = turf.polygon([coords.map(coord => [coord[1], coord[0]])]);
                const point = turf.point([lon, lat]);
                if (turf.booleanPointInPolygon(point, turfPolygon)) {
                    candidatePolygons.push(polygon);
                }
            } catch (turfError) {
                if (polygon.geometry.contains([lat, lon])) {
                    candidatePolygons.push(polygon);
                }
            }
        }
    }
    for (const obj of areaObjects) {
        if (obj instanceof ymaps.Polygon) {
             try {
                const coords = obj.geometry.getCoordinates()[0];
                const turfPolygon = turf.polygon([coords.map(coord => [coord[1], coord[0]])]);
                const point = turf.point([lon, lat]);
                if (turf.booleanPointInPolygon(point, turfPolygon)) {
                    candidatePolygons.push(obj);
                }
            } catch(turfError) {
                 if (obj.geometry.contains([lat, lon])) { candidatePolygons.push(obj); }
            }
        }
    }

    if (candidatePolygons.length === 0) {
        showNotification('Контур не найден в выбранной точке', 'warning', 'exclamation-triangle');
    } else if (candidatePolygons.length === 1) {
        openColorEditorModal(candidatePolygons[0]);
    } else {
        showPolygonSelectionModal(candidatePolygons, (selectedPolygon) => {
            if (selectedPolygon) {
                openColorEditorModal(selectedPolygon);
            }
        });
    }
    
    contextMenu.style.display = 'none';
}

    });

    // Установка сохраненного режима карты
 const savedMode = localStorage.getItem('mapMode') || 'map';
    setMapMode(savedMode);

    document.querySelectorAll('.map-mode-button').forEach(button => {
        if (button.getAttribute('data-mode') === savedMode) {
            button.classList.add('active');
        }
    });

    mapOffsetX = parseFloat(localStorage.getItem('mapOffsetX')) || -4.5;
    mapOffsetY = parseFloat(localStorage.getItem('mapOffsetY')) || -1;
    document.getElementById('mapOffsetX').value = mapOffsetX;
    document.getElementById('mapOffsetY').value = mapOffsetY;

    // Инициализация метки высоты
    if (isCameraHeightLabelVisible) {
        updateCameraHeightLabel();
    }
}






let lineDrawingActive = false;
let linePoints = [];
let currentLine = null;

function startLineDrawing(lineColor, lineWidth) {
    if (distanceMeasurementActive) {
        stopDistanceMeasurement();
    }
    if (areaMeasurementActive) {
        stopAreaMeasurement();
    }

    lineDrawingActive = true;
    linePoints = [];
    currentLine = null;
    mapElement.classList.add('drawing-line');

    currentLineColor = lineColor || '#ff0000';
    currentLineWidth = parseInt(lineWidth) || 3;

    // Используем map.geoObjects.each для итерации
    map.geoObjects.each(function (obj) {
        if (obj instanceof ymaps.Polygon && obj.options) {
            // obj.originalInteractivity = obj.options.get('interactivityModel', 'default#geoObject'); // Если нужно сохранять разную интерактивность
            obj.options.set('interactivityModel', 'default#transparent');
        }
         // else if (obj instanceof ymaps.Polyline && obj.options) { // Можно добавить для линий
         //    obj.options.set('interactivityModel', 'default#transparent');
         // }
    });

    map.events.add('click', onMapClickForLineDrawing);
    map.events.add('dblclick', onMapDoubleClickForLineDrawing);
}






function updateCurrentLine() {
    if (currentLine) {
        map.geoObjects.remove(currentLine);
        polygons = polygons.filter(p => p !== currentLine);
    }

    // Используем сохраненные/установленные стили
    currentLine = new ymaps.Polyline(linePoints, {}, {
        strokeColor: currentLineColor,
        strokeWidth: currentLineWidth,
       strokeOpacity: manualObjectOpacity, 
        zIndex: 900 
    });

    map.geoObjects.add(currentLine);
    polygons.push(currentLine);
}


function onMapClickForLineDrawing(e) {
    if (!lineDrawingActive) return;

    const coords = e.get('coords');
    linePoints.push(coords);

    /* --- НАЧАЛО ИЗМЕНЕНИЙ: Удаление маркера точки ---
    // Добавляем маркер точки (не обязательно, но полезно для визуализации)
    // const pointMarker = new ymaps.Placemark(coords, {}, {
    //     preset: 'islands#redDotIcon', // Маленькая красная точка
    //     // Убедимся, что маркеры не мешают кликам для рисования
    //     interactivityModel: 'default#transparent'
    // });
    // map.geoObjects.add(pointMarker);
    // polygons.push(pointMarker); // Добавляем маркер в общий список для возможной очистки
    --- КОНЕЦ ИЗМЕНЕНИЙ --- */

    // Обновляем полилинию, если есть хотя бы 2 точки
    if (linePoints.length >= 2) {
        updateCurrentLine();
    }
}

function onMapDoubleClickForLineDrawing(e) {
    if (!lineDrawingActive) return;

    e.preventDefault();
    if (linePoints.length >= 2) {
        updateCurrentLine();
    }
    stopLineDrawing();
}

function stopLineDrawing() {
    if (!lineDrawingActive) return;

    lineDrawingActive = false;
    mapElement.classList.remove('drawing-line');
    map.events.remove('click', onMapClickForLineDrawing);
    map.events.remove('dblclick', onMapDoubleClickForLineDrawing);

    if (currentLine && currentLine instanceof ymaps.Polyline) {
        currentLine.originalStyle = {
            strokeColor: currentLine.options.get('strokeColor', currentLineColor),
            strokeWidth: currentLine.options.get('strokeWidth', currentLineWidth)
        };
        // Устанавливаем флаг и делаем линию интерактивной
        currentLine.properties.set('isDrawableLine', true);
        currentLine.options.set('interactivityModel', 'default#geoObject');
    }

    map.geoObjects.each(function (obj) {
         if (obj instanceof ymaps.Polygon && obj.options) {
            obj.options.set('interactivityModel', 'default#geoObject');
         }
    });

    currentLine = null;
}





        function setMapMode(mode) {
            switch (mode) {
                case 'map':
                    map.setType('yandex#map');
                    break;
                case 'satellite':
                    map.setType('yandex#satellite');
                    break;
                case 'hybrid':
                    map.setType('yandex#hybrid');
                    break;
                    
                    case 'blank': 
                    map.setType(null); 
                    break;
            }
            localStorage.setItem('mapMode', mode);
        }

        function updateCity(address) {
            ymaps.geocode(address, {
                results: 1
            }).then(function (result) {
                const firstGeoObject = result.geoObjects.get(0);
                if (firstGeoObject) {
                    const coords = firstGeoObject.geometry.getCoordinates();

                    // Запускаем анимацию
                    animateMapZoom();

                    // Устанавливаем новый центр карты
                    map.setCenter(coords, 19);

                    // Обновляем адрес
                    const addressComponents = firstGeoObject.getAddressLine().split(', ');
                    let formattedAddress = '';
                    for (let i = 0; i < addressComponents.length; i++) {
                        formattedAddress += addressComponents[i] + '<br>';
                    }
                    document.getElementById('city-name-display').innerHTML = formattedAddress;
                    localStorage.setItem('city', formattedAddress);

                    // Очищаем старые объекты и добавляем новый маркер
                    map.geoObjects.removeAll();
                    const placemark = new ymaps.Placemark(coords, {
                        hintContent: firstGeoObject.getAddressLine()
                    });
                    map.geoObjects.add(placemark);
                } else {
                    document.getElementById('city-name-display').textContent = 'Адрес не найден';
                }
            });
        }

        // Открытие модального окна
        function openGradientModal() {
            const gradientModal = document.getElementById('gradientModal');
            gradientModal.style.display = 'block';

            // Восстановление сохраненных цветов, если они есть
            const savedColors = JSON.parse(localStorage.getItem('widgetGradientColors'));
            if (savedColors && savedColors.length === 3) {
                document.getElementById('color1').value = savedColors[0];
                document.getElementById('color2').value = savedColors[1];
                document.getElementById('color3').value = savedColors[2];
            }
        }

        // Закрытие модального окна
        function closeGradientModal() {
            const gradientModal = document.getElementById('gradientModal');
            gradientModal.style.display = 'none';
        }

        // Восстановление цветов при загрузке страницы
     function loadGradientColors() {
    const savedColors = JSON.parse(localStorage.getItem('widgetGradientColors'));
    const savedFontColor = localStorage.getItem('widgetFontColor');
    const widget = document.querySelector('.widget');
    const styleModalContent = document.querySelector('.style-modal-content');
    const cityNameDisplay = document.getElementById('city-name-display');
    const fontColorInput = document.getElementById('fontColor');
    const map = document.getElementById('map');
    // Add this line where you load other styles from localStorage
polygonStyle.thematicCostColor = localStorage.getItem('thematicCostColor') || polygonStyle.thematicCostColor;

    if (savedColors && savedColors.length === 3) {
        widget.style.background = `linear-gradient(135deg, ${savedColors[0]}, ${savedColors[1]}, ${savedColors[2]})`;
        styleModalContent.style.background = `linear-gradient(135deg, ${savedColors[0]}, ${savedColors[1]}, ${savedColors[2]})`;
        map.style.borderColor = savedColors[1];
    } else {
        const defaultColors = ["#3B82F6", "#60A5FA", "#1E3A8A"]; // Новая палитра
        widget.style.background = `linear-gradient(135deg, ${defaultColors[0]}, ${defaultColors[1]}, ${defaultColors[2]})`;
        styleModalContent.style.background = `linear-gradient(135deg, ${defaultColors[0]}, ${defaultColors[1]}, ${defaultColors[2]})`;
        map.style.borderColor = defaultColors[1];
    }

    if (savedFontColor) {
        widget.style.color = savedFontColor;
        styleModalContent.style.color = savedFontColor;
        cityNameDisplay.style.color = savedFontColor;
        fontColorInput.value = savedFontColor;
        widget.querySelectorAll('i').forEach(icon => {
            icon.style.color = savedFontColor;
        });
        widget.style.setProperty('--widget-border-color', savedFontColor);
    } else {
        const defaultFontColor = "#F9FAFB";
        widget.style.color = defaultFontColor;
        styleModalContent.style.color = defaultFontColor;
        cityNameDisplay.style.color = defaultFontColor;
        fontColorInput.value = defaultFontColor;
        widget.querySelectorAll('i').forEach(icon => {
            icon.style.color = defaultFontColor;
        });
        widget.style.setProperty('--widget-border-color', defaultFontColor);
    }
}


function copyPolygonWithMap(originalPolygon, strokeColor, opacityHex) {
    // Получаем координаты исходного полигона
    const originalCoords = originalPolygon.geometry.getCoordinates()[0];
    const bounds = originalPolygon.geometry.getBounds();

    // Получаем текущие стили оригинального полигона
    const originalFillColor = originalPolygon.options.get('fillColor') || '#00000000';
    const originalStrokeWidth = originalPolygon.options.get('strokeWidth') || 2;
    const originalStrokeOpacity = originalPolygon.options.get('strokeOpacity') || 0.8;

    // Создаем копию полигона с текущими стилями или новыми из модального окна
  const copiedPolygon = new ymaps.Polygon([originalCoords], {
        isManuallyDrawn: true // <--- ДОБАВЛЕНО
    }, {
        strokeColor: strokeColor, // Новый цвет линии из модального окна
        strokeWidth: originalStrokeWidth, // Сохраняем толщину линии
       strokeOpacity: manualObjectOpacity, // Сохраняем прозрачность линии
        fillColor: originalFillColor, // Сохраняем заливку (если была)
        hintEnabled: false,
        hasBalloon: false,
        interactivityModel: 'default#transparent',
        draggable: true, // Делаем полигон перетаскиваемым
        zIndex: 900 // <--- ДОБАВЛЕНО
    });

    // Добавляем копию полигона на карту
    map.geoObjects.add(copiedPolygon);

    // Сохраняем копию в polygons для дальнейшего управления
    polygons.push(copiedPolygon);

    // Переменные для перетаскивания
    let isDragging = false;
    let startPixelCoords = null; // Пиксельные координаты начала перетаскивания
    let originalGeoCoords = null; // Географические координаты полигона при начале перетаскивания

    copiedPolygon.events.add('dragstart', function (e) {
        isDragging = true;
        // Получаем пиксельные координаты начала перетаскивания
        startPixelCoords = e.get('pixelCoordinates');
        // Сохраняем исходные географические координаты полигона
        originalGeoCoords = copiedPolygon.geometry.getCoordinates()[0].slice();
    });

    copiedPolygon.events.add('drag', function (e) {
        if (!isDragging || !startPixelCoords || !originalGeoCoords) return;

        // Получаем текущие пиксельные координаты курсора
        const currentPixelCoords = e.get('pixelCoordinates');

        // Вычисляем смещение в пикселях
        const deltaPixelX = currentPixelCoords[0] - startPixelCoords[0];
        const deltaPixelY = currentPixelCoords[1] - startPixelCoords[1];

        // Преобразуем пиксельное смещение в географические координаты
        const projection = map.options.get('projection');
        const zoomLevel = map.getZoom();

        // Получаем центр полигона как базовую точку
        const centerGeo = [
            (bounds[0][0] + bounds[1][0]) / 2,
            (bounds[0][1] + bounds[1][1]) / 2
        ];
        const centerPixel = projection.toGlobalPixels(centerGeo, zoomLevel);

        // Вычисляем новые пиксельные координаты центра
        const newCenterPixel = [
            centerPixel[0] + deltaPixelX,
            centerPixel[1] + deltaPixelY
        ];

        // Преобразуем новые пиксельные координаты обратно в географические
        const newCenterGeo = projection.fromGlobalPixels(newCenterPixel, zoomLevel);

        // Вычисляем смещение в географических координатах
        const deltaLat = newCenterGeo[0] - centerGeo[0];
        const deltaLon = newCenterGeo[1] - centerGeo[1];

        // Применяем смещение ко всем координатам полигона
        const newCoords = originalGeoCoords.map(coord => [
            coord[0] + deltaLat,
            coord[1] + deltaLon
        ]);

        copiedPolygon.geometry.setCoordinates([newCoords]);
    });

    copiedPolygon.events.add('dragend', function () {
        isDragging = false;
        startPixelCoords = null;
        originalGeoCoords = null;
    });

    // Уведомление о копировании
    showNotification('Объект скопирован для перемещения', 'success', 'check-circle');
}

        // Применение выбранных цветов
     function applyGradient() {
    const color1 = document.getElementById('color1').value;
    const color2 = document.getElementById('color2').value;
    const color3 = document.getElementById('color3').value;
    const fontColor = document.getElementById('fontColor').value;

    const widget = document.querySelector('.widget');
    const styleModalContent = document.querySelector('.style-modal-content');
    const cityNameDisplay = document.getElementById('city-name-display');
    const map = document.getElementById('map');

    // Применяем градиент
    widget.style.background = `linear-gradient(135deg, ${color1}, ${color2}, ${color3})`;
    styleModalContent.style.background = `linear-gradient(135deg, ${color1}, ${color2}, ${color3})`;
    map.style.borderColor = color2;

    // Применяем цвет шрифта и иконок
    widget.style.color = fontColor;
    styleModalContent.style.color = fontColor;
    widget.querySelectorAll('i').forEach(icon => {
        icon.style.color = fontColor;
    });
    cityNameDisplay.style.color = fontColor;

    // Устанавливаем цвет рамки
    widget.style.setProperty('--widget-border-color', fontColor);

    // Сохранение цветов в localStorage
    localStorage.setItem('widgetGradientColors', JSON.stringify([color1, color2, color3]));
    localStorage.setItem('widgetFontColor', fontColor);

    closeGradientModal();
    showHistoryModal(); // Добавлено: обновляем вид истории
}

        // Сброс цветов (обновленная)
    function resetGradient() {
    const defaultColors = ["#3B82F6", "#60A5FA", "#1E3A8A"]; // Новая палитра
    const defaultFontColor = "#F9FAFB"; // Новый цвет шрифта
    const fontColorInput = document.getElementById('fontColor');
    const map = document.getElementById('map');

    document.getElementById('color1').value = defaultColors[0];
    document.getElementById('color2').value = defaultColors[1];
    document.getElementById('color3').value = defaultColors[2];
    document.getElementById('fontColor').value = defaultFontColor;
    fontColorInput.value = defaultFontColor;

    const cityNameDisplay = document.getElementById('city-name-display');

    const widget = document.querySelector('.widget');
    const styleModalContent = document.querySelector('.style-modal-content');
    widget.style.background = `linear-gradient(135deg, ${defaultColors[0]}, ${defaultColors[1]}, ${defaultColors[2]})`;
    styleModalContent.style.background = `linear-gradient(135deg, ${defaultColors[0]}, ${defaultColors[1]}, ${defaultColors[2]})`;
    widget.style.color = defaultFontColor;
    styleModalContent.style.color = defaultFontColor;
    cityNameDisplay.style.color = defaultFontColor;
    map.style.borderColor = defaultColors[1]; // Средний цвет для границы карты

    widget.querySelectorAll('i').forEach(icon => {
        icon.style.color = defaultFontColor;
    });

    widget.style.setProperty('--widget-border-color', defaultFontColor);

    localStorage.removeItem('widgetGradientColors');
    localStorage.removeItem('widgetFontColor');
    showHistoryModal(); // Обновляем вид истории
}


        document.addEventListener('DOMContentLoaded', () => {
    
    const savedGoogleEarthSetting = localStorage.getItem('openGoogleEarthAfterExport');
    openGoogleEarthAfterExport = savedGoogleEarthSetting === null ? true : (savedGoogleEarthSetting === 'true');
    const toggleOpenGoogleEarthCheckbox = document.getElementById('toggleOpenGoogleEarth');
    if (toggleOpenGoogleEarthCheckbox) {
        toggleOpenGoogleEarthCheckbox.checked = openGoogleEarthAfterExport;
        if (!toggleOpenGoogleEarthCheckbox.onchange) {
             toggleOpenGoogleEarthCheckbox.addEventListener('change', updateGoogleEarthSetting);
        }
    }

    loadGradientColors();
    
    const importInput = document.getElementById('importFileInput');
    if (importInput) {
        importInput.addEventListener('change', handleImportFile);
    }

    // --- ИСПРАВЛЕНИЕ: Назначаем обработчик здесь ---
    const converterBtn = document.getElementById('open-converter-btn');
    if (converterBtn) {
        converterBtn.addEventListener('click', openMskConverterModal);
    } else {
        // Это сообщение больше не должно появляться после исправления HTML
        console.error('Кнопка конвертера #open-converter-btn не найдена!');
    }
    // --- КОНЕЦ ИСПРАВЛЕНИЯ ---

    const cityInput = document.getElementById('city-input');
    loaderTextEl = document.querySelector('.loading-text');

   
});

 document.querySelectorAll('.map-mode-button').forEach(button => {
    button.addEventListener('click', () => {
        const mode = button.getAttribute('data-mode');

        // Если это кнопка переключения типа карты
        if (['map', 'satellite', 'hybrid', 'blank'].includes(mode)) { // Добавили 'blank'
            setMapMode(mode);

            // Удаляем класс active у всех кнопок
            document.querySelectorAll('.map-mode-button').forEach(btn => {
                btn.classList.remove('active');
            });

            // Добавляем active только к текущей кнопке
            button.classList.add('active');
        }
    });
});

        function containsLetters(text) {
            return /[a-zA-Zа-яА-Я]/.test(text);
        }



        document.addEventListener('paste', function (event) {
            const text = event.clipboardData.getData('text');
            if (text) {
                coordsInput.value = text;
                findAndConvert();
            }
        });


      
    
         // Обработчик события paste для city-input
      cityInput.addEventListener('paste', async (event) => {
          event.preventDefault(); // Предотвращаем стандартное поведение вставки

          const text = (event.clipboardData || window.clipboardData).getData('text');
          if (!text) return;
          
          const trimmedText = text.trim();
          
          // Проверка на географические координаты (2 числа через пробел/запятую/табуляцию)
          const coordRegex = /^(-?\d+\.?\d*)\s*[,\s]\s*(-?\d+\.?\d*)$/;
          const coordMatch = trimmedText.match(coordRegex);
          
          if (coordMatch) {
              // Это координаты - извлекаем числа
              const firstNum = parseFloat(coordMatch[1]);
              const secondNum = parseFloat(coordMatch[2]);
              
              // Проверяем, может ли это быть "широта долгота"
              if (Math.abs(firstNum) <= 90 && Math.abs(secondNum) <= 180) {
              //    console.log(`Вставка координат (широта, долгота): ${firstNum}, ${secondNum}`);
                  
                  // Используем координаты в правильном порядке "широта долгота"
                  cityInput.value = trimmedText;
                  
                  // Имитируем нажатие Enter для обработки координат нашим основным обработчиком
                  const enterEvent = new KeyboardEvent('keydown', {
                      key: 'Enter',
                      code: 'Enter',
                      which: 13,
                      keyCode: 13,
                      bubbles: true
                  });
                  cityInput.dispatchEvent(enterEvent);
                  return;
              }
          }
          
          // Проверка на разделенные координаты другими способами
          const spaceSeparated = trimmedText.split(/\s+/);
          if (spaceSeparated.length === 2) {
              const lat = parseFloat(spaceSeparated[0]);
              const lon = parseFloat(spaceSeparated[1]);
              
              if (!isNaN(lat) && !isNaN(lon) && 
                  Math.abs(lat) <= 90 && Math.abs(lon) <= 180) {
                  // Это вероятно координаты в формате "широта долгота"
             //     console.log(`Вставка координат (форма 2): ${lat}, ${lon}`);
                  
                  cityInput.value = trimmedText;
                  
                  // Имитируем нажатие Enter
                  const enterEvent = new KeyboardEvent('keydown', {
                      key: 'Enter',
                      code: 'Enter',
                      which: 13,
                      keyCode: 13,
                      bubbles: true
                  });
                  cityInput.dispatchEvent(enterEvent);
                  return;
              }
          }

          // Если это не координаты, проверяем кадастровый номер
          if (isValidCadastralNumber(trimmedText)) {
              const formattedText = formatPotentialCadastralNumber(trimmedText);
              cityInput.value = formattedText;
              
              // Имитируем нажатие Enter
              const enterEvent = new KeyboardEvent('keydown', {
                  key: 'Enter',
                  code: 'Enter',
                  which: 13,
                  keyCode: 13,
                  bubbles: true
              });
              cityInput.dispatchEvent(enterEvent);
          } else {
              // Обычный текст - просто устанавливаем значение
              cityInput.value = text;
          }
      });
      


async function handleGenerateQuarterMskXml() {
    // 1. Проверяем, загружены ли данные квартала
    if (!currentQuarterNumber || !parcelFeaturesData || parcelFeaturesData.length === 0) {
        showNotification('Пожалуйста, загрузите земельные участки для кадастрового квартала', 'warning', 'exclamation-triangle');
        return;
    }

    const converterMode = localStorage.getItem('mskConverterMode');
    if (converterMode === 'api') {
        showNotification('XML КПТ генерируется только в режиме Proj4. Пожалуйста, переключите режим в окне конвертера (кнопка "МСК").', 'warning', 'exclamation-triangle', 5000);
        return;
    }

    showLoader('Подготовка XML...');

    try {
        // --- НАЧАЛО ИЗМЕНЕНИЙ: Логика получения смещения, аналогичная предыдущим функциям ---
        const destSc = localStorage.getItem('savedDefaultMskSystem') || 'EPSG:6331602';
        const destSystem = COORDINATE_SYSTEMS.find(s => s.value === destSc);
        if (!destSystem) {
            throw new Error(`Определение для ${destSc} не найдено в sk.js`);
        }

        let offsetX = 0;
        let offsetY = 0;
        const isAutoLoadEnabled = (localStorage.getItem('autoLoadMskOffset') !== 'false');

        if (isAutoLoadEnabled) {
            offsetX = destSystem.offsetX || 0;
            offsetY = destSystem.offsetY || 0;
            console.log(`[handleGenerateQuarterMskXml] Смещения загружены из sk.js для ${destSc}: X=${offsetX}, Y=${offsetY}`);
        } else {
            const offsetXRaw = localStorage.getItem('savedMskOffsetX') || '0';
            const offsetYRaw = localStorage.getItem('savedMskOffsetY') || '0';
            offsetX = parseFloat(offsetXRaw.replace(',', '.')) || 0;
            offsetY = parseFloat(offsetYRaw.replace(',', '.')) || 0;
            console.log(`[handleGenerateQuarterMskXml] Используются сохраненные вручную смещения: X=${offsetX}, Y=${offsetY}`);
        }
        // --- КОНЕЦ ИЗМЕНЕНИЙ ---

        const nspdData = { features: parcelFeaturesData };
        // Используем значения по умолчанию, как в xml_kpt.html
        const swapCoords = true;
        const reverseDirection = true;

        // 3. Конвертируем данные в XML-строку (offsetX и offsetY уже определены выше)
        const { xmlContent, filenameBase } = convertJsonToXml(
            nspdData, 
            currentQuarterNumber,
            destSc,
            offsetX, // Передаем правильное смещение
            offsetY, // Передаем правильное смещение
            swapCoords,
            reverseDirection
        );

        // 4. Создаем и скачиваем ZIP-архив
        await createAndDownloadZip(xmlContent, filenameBase);

        // 5. Копируем XML в буфер обмена
        await navigator.clipboard.writeText(xmlContent);
        showNotification('XML скопирован в буфер обмена', 'success', 'check-circle');

        // 6. Открываем схема_xml.html
        window.open('схема_xml.html', '_blank');
        
    } catch (error) {
        console.error("Ошибка при генерации XML квартала:", error);
        showNotification(`Ошибка: ${error.message}`, 'error', 'exclamation-circle');
    } finally {
        hideLoader();
    }
}

function convertJsonToXml(nspdData, quarterNumber, targetCS_value, offsetX, offsetY, swapXmlCoords, reverseDirection) {
    if (typeof COORDINATE_SYSTEMS === 'undefined') { 
        throw new Error("Список систем координат (sk.js) не загружен."); 
    }

    const targetSystem = COORDINATE_SYSTEMS.find(s => s.value === targetCS_value);
    const sourceSystem = COORDINATE_SYSTEMS.find(s => s.value === 'EPSG:3857');

    if (!targetSystem || !sourceSystem) {
        throw new Error(`Определение для ${targetCS_value} или EPSG:3857 не найдено.`);
    }
    
    proj4.defs(targetSystem.value, targetSystem.def); 
    proj4.defs(sourceSystem.value, sourceSystem.def);
    
    const today = new Date();
    const dateString = `${today.getFullYear()}-${String(today.getMonth() + 1).padStart(2, '0')}-${String(today.getDate()).padStart(2, '0')}`;
    const quarterSafe = quarterNumber.replace(/:/g, '_');
    const filenameBase = `${quarterSafe} ${dateString} EPSG3857`;

    const escapeXml = (unsafe) => unsafe ? String(unsafe).replace(/[<>&'"]/g, c => ({'<':'&lt;','>':'&gt;','&':'&amp;','\'':'&apos;','"':'&quot;'}[c])) : '-';

    const landRecordsXml = nspdData.features.map(feature => {
        const props = feature.properties.options || {};
        const geometry = feature.geometry;
        const finalSkId = targetSystem.text.split('(')[0].trim();

        // --- НАЧАЛО ИЗМЕНЕНИЙ ---
        const contoursXml = (geometry && geometry.coordinates) ? (() => {
            const polygonsData = geometry.type === 'MultiPolygon' ? geometry.coordinates : [geometry.coordinates];
            let contourCounter = 0; // Нумератор для тега <contour><number_pp>
            
            return polygonsData.map(polygonRings => {
                contourCounter++; // Увеличиваем счетчик для каждого полигона (внешнего контура)
                
                // polygonRings - это массив контуров [[внешний], [внутренний1], ...]
                const spatialsXml = polygonRings.map(ring => {
                    let points = ring; // ring - это массив точек [ [x1, y1], [x2, y2], ... ]
                    if (reverseDirection) { 
                        // Для внешнего контура оставляем как есть, внутренние - в обратном порядке
                        // (Согласно некоторым требованиям XML)
                        // Но API НСПД, скорее всего, уже дает правильное направление, так что пока не будем менять
                        // points = [...points].reverse(); 
                    }
                    
                    const ordinatesXml = points.map((point, i) => {
                        const convertedPoint = proj4(sourceSystem.value, targetSystem.value, point);
                        const decimalPlaces = targetCS_value === 'EPSG:4326' ? 8 : 2;
                        
                        const y_from_proj = convertedPoint[0];
                        const x_from_proj = convertedPoint[1];

                        const final_Y_with_offset = y_from_proj + offsetY;
                        const final_X_with_offset = x_from_proj + offsetX;

                        let xml_tag_x_value, xml_tag_y_value;
                        if (swapXmlCoords) {
                            xml_tag_x_value = final_X_with_offset.toFixed(decimalPlaces);
                            xml_tag_y_value = final_Y_with_offset.toFixed(decimalPlaces);
                        } else {
                            xml_tag_x_value = final_Y_with_offset.toFixed(decimalPlaces);
                            xml_tag_y_value = final_X_with_offset.toFixed(decimalPlaces);
                        }

                        return `<ordinate><x>${xml_tag_x_value}</x><y>${xml_tag_y_value}</y><ord_nmb>${i + 1}</ord_nmb><num_geopoint>${i + 1}</num_geopoint><delta_geopoint>0.0</delta_geopoint></ordinate>`;
                    }).join('');

                    return `<spatial_element><ordinates>${ordinatesXml}</ordinates></spatial_element>`;
                }).join('');

                return `<contour><number_pp>${contourCounter}</number_pp><entity_spatial><sk_id>${escapeXml(finalSkId)}</sk_id><spatials_elements>${spatialsXml}</spatials_elements></entity_spatial></contour>`;
            }).join('');
        })() : '';
        // --- КОНЕЦ ИЗМЕНЕНИЙ ---
        
        const isAreaSpecified = props.specified_area || props.land_record_area_verified;
        const areaValue = isAreaSpecified || props.declared_area || props.land_record_area_declaration || props.land_record_area;
        const areaXmlBlock = isAreaSpecified ?
            `<area><value>${escapeXml(areaValue)}</value><inaccuracy>0</inaccuracy></area>` :
            `<area><value>${escapeXml(areaValue)}</value></area>`;

        return `<land_record><object><common_data><type><code>002001001000</code><value>${escapeXml(props.land_record_type||'Земельный участок')}</value></type><cad_number>${escapeXml(props.cad_num)}</cad_number></common_data></object><params><category><type><code>003002000000</code><value>${escapeXml(props.land_record_category_type)}</value></type></category><permitted_use><permitted_use_established><by_document>${escapeXml(props.permitted_use_established_by_document)}</by_document></permitted_use_established></permitted_use>${areaXmlBlock}</params><address_location><address><readable_address>${escapeXml(props.readable_address)}</readable_address></address></address_location><cost><value>${escapeXml(props.cost_value)}</value></cost><contours_location><contours>${contoursXml}</contours></contours_location></land_record>`;
    }).join('');
    
    const fullXml = `<?xml version="1.0" encoding="UTF-8"?><extract_cadastral_plan_territory><details_statement><group_top_requisites><organ_registr_rights>EPSG3857-КОНВЕРТЕР</organ_registr_rights><date_formation>${dateString}</date_formation><registration_number></registration_number></group_top_requisites></details_statement><cadastral_blocks><cadastral_block><cadastral_number>${escapeXml(quarterNumber)}</cadastral_number><record_data><base_data><land_records>${landRecordsXml}</land_records></base_data></record_data></cadastral_block></cadastral_blocks></extract_cadastral_plan_territory>`;
    
    return { xmlContent: fullXml, filenameBase };
}





async function convertAllObjectsToMskAndCopy() {
    try {
        // 1. Собираем все объекты для конвертации
        const allDrawableObjects = new Set([...polygons, ...areaObjects]);
        const objectsToConvert = Array.from(allDrawableObjects).filter(obj => 
            obj instanceof ymaps.Polygon || obj instanceof ymaps.Polyline
        );

        if (objectsToConvert.length === 0) {
            showNotification('На карте нет объектов для конвертации', 'warning', 'exclamation-triangle');
            return;
        }
        
        showLoader(`Конвертация ${objectsToConvert.length} объектов...`);

        // --- НАЧАЛО ИЗМЕНЕНИЙ: Логика получения смещения, аналогичная convertAndCopyMskCoords ---
        const destSc = localStorage.getItem('savedDefaultMskSystem') || 'EPSG:6331602';
        const destSystem = COORDINATE_SYSTEMS.find(s => s.value === destSc);
        if (!destSystem || !destSystem.def) {
            throw new Error(`Определение для ${destSc} не найдено в sk.js`);
        }

        let offsetX = 0;
        let offsetY = 0;
        const isAutoLoadEnabled = (localStorage.getItem('autoLoadMskOffset') !== 'false');

        if (isAutoLoadEnabled) {
            offsetX = destSystem.offsetX || 0;
            offsetY = destSystem.offsetY || 0;
            console.log(`[convertAllObjects] Смещения загружены из sk.js для ${destSc}: X=${offsetX}, Y=${offsetY}`);
        } else {
            const offsetXRaw = localStorage.getItem('savedMskOffsetX') || '0';
            const offsetYRaw = localStorage.getItem('savedMskOffsetY') || '0';
            offsetX = parseFloat(offsetXRaw.replace(',', '.')) || 0;
            offsetY = parseFloat(offsetYRaw.replace(',', '.')) || 0;
            console.log(`[convertAllObjects] Используются сохраненные вручную смещения: X=${offsetX}, Y=${offsetY}`);
        }
        // --- КОНЕЦ ИЗМЕНЕНИЙ ---
        
        const allMskBlocks = [];

        // 3. Проходим по каждому объекту
        for (const targetObject of objectsToConvert) {
            if (targetObject instanceof ymaps.Polygon) {
                const yandexCoordRings = targetObject.geometry.getCoordinates();
                const currentObjectMskBlocks = [];

                for (const ring of yandexCoordRings) {
                    const reversedYandexCoords = [...ring].reverse();
                    const wgs84Coords = reversedYandexCoords.map(coord => {
                        const trueLat = coord[0] + (mapOffsetY * 0.000008983);
                        const trueLon = coord[1] + (mapOffsetX * 0.000008983);
                        return [trueLon, trueLat];
                    });
                    const mskCoordsText = convertWgs84ToMskWithOffset(wgs84Coords, destSc, destSystem.def, offsetX, offsetY);
                    currentObjectMskBlocks.push(mskCoordsText);
                }
                allMskBlocks.push(currentObjectMskBlocks.join('\n\n'));

            } else { // Polyline
                const yandexCoords = targetObject.geometry.getCoordinates();
                const reversedYandexCoords = [...yandexCoords].reverse();
                const wgs84Coords = reversedYandexCoords.map(coord => {
                    const trueLat = coord[0] + (mapOffsetY * 0.000008983);
                    const trueLon = coord[1] + (mapOffsetX * 0.000008983);
                    return [trueLon, trueLat];
                });
                const mskCoordsText = convertWgs84ToMskWithOffset(wgs84Coords, destSc, destSystem.def, offsetX, offsetY);
                allMskBlocks.push(mskCoordsText);
            }
        }

        // 4. Объединяем результаты, копируем и открываем новую вкладку
        const finalStringToCopy = allMskBlocks.join('\n\n');
        await navigator.clipboard.writeText(finalStringToCopy);
        
        let notificationMessage = `Координаты ${objectsToConvert.length} объектов скопированы в ${destSystem.text}`;
        if (offsetX !== 0 || offsetY !== 0) {
            notificationMessage += ` (со смещением)`;
        }
        showNotification(notificationMessage, 'success', 'check-circle');
        window.open('схема.html', '_blank');

    } catch (error) {
        console.error("Ошибка при конвертации всех объектов в МСК:", error);
        showNotification(`Ошибка конвертации: ${error.message}`, 'error', 'exclamation-circle');
    } finally {
        hideLoader();
    }
}


async function exportAllObjectsToGeoredaсtor() {
    try {
        const allDrawableObjects = new Set([...polygons, ...areaObjects]);
        const draggableTextElements = Array.from(document.querySelectorAll('.draggable-text'));

        // ***** НАЧАЛО ИЗМЕНЕНИЯ: ФИЛЬТРУЕМ ТОЧЕЧНЫЕ ОБЪЕКТЫ *****
        const objectsToConvert = Array.from(allDrawableObjects).filter(obj => 
            obj instanceof ymaps.Polygon || obj instanceof ymaps.Polyline
        );
        // ***** КОНЕЦ ИЗМЕНЕНИЯ *****

        if (objectsToConvert.length === 0 && draggableTextElements.length === 0) {
            showNotification('На карте нет площадных или линейных объектов для экспорта в Георедактор', 'warning', 'exclamation-triangle');
            return;
        }
        
        showLoader(`Подготовка данных для Георедактора...`);

        const destSc = localStorage.getItem('savedDefaultMskSystem') || 'EPSG:6331602';
        const destSystem = COORDINATE_SYSTEMS.find(s => s.value === destSc);
        if (!destSystem || !destSystem.def) {
            throw new Error(`Определение для ${destSc} не найдено в sk.js`);
        }

        let offsetX = 0;
        let offsetY = 0;
        const isAutoLoadEnabled = (localStorage.getItem('autoLoadMskOffset') !== 'false');

        if (isAutoLoadEnabled) {
            offsetX = destSystem.offsetX || 0;
            offsetY = destSystem.offsetY || 0;
        } else {
            const offsetXRaw = localStorage.getItem('savedMskOffsetX') || '0';
            const offsetYRaw = localStorage.getItem('savedMskOffsetY') || '0';
            offsetX = parseFloat(offsetXRaw.replace(',', '.')) || 0;
            offsetY = parseFloat(offsetYRaw.replace(',', '.')) || 0;
        }
        
        const formattedBlocks = [];
        let objectCounter = 1;

        // ***** НАЧАЛО ИЗМЕНЕНИЯ: ИСПОЛЬЗУЕМ ОТФИЛЬТРОВАННЫЙ МАССИВ *****
        for (const targetObject of objectsToConvert) {
        // ***** КОНЕЦ ИЗМЕНЕНИЯ *****
            let identifier;
            let yandexCoords;

            if (targetObject instanceof ymaps.Polygon) {
                identifier = targetObject.properties.get('cadastralNumber') || `Площадной_объект_${objectCounter++}`;
                yandexCoords = targetObject.geometry.getCoordinates()[0];
            } else if (targetObject instanceof ymaps.Polyline) {
                identifier = targetObject.properties.get('hintContent') || `Линейный_объект_${objectCounter++}`;
                yandexCoords = targetObject.geometry.getCoordinates();
            } else {
                continue; // Пропускаем все, что не полигон и не линия (включая Placemark)
            }

            if (!yandexCoords || yandexCoords.length === 0) continue;

            const reversedYandexCoords = [...yandexCoords].reverse();
            const wgs84Coords = reversedYandexCoords.map(coord => {
                const trueLat = coord[0] + (mapOffsetY * 0.000008983);
                const trueLon = coord[1] + (mapOffsetX * 0.000008983);
                return [trueLon, trueLat];
            });
            const mskCoordsText = convertWgs84ToMskWithOffset(wgs84Coords, destSc, destSystem.def, offsetX, offsetY);
            
            if (mskCoordsText) {
                formattedBlocks.push(`${identifier}\n${mskCoordsText}`);
            }
        }

        // Обработка текстовых меток (как точечных объектов)
        for (const textEl of draggableTextElements) {
            const textContent = textEl.querySelector('span')?.textContent || `Текст_${objectCounter++}`;
            const rect = textEl.getBoundingClientRect();
            let geoCoords;
            try {
                const globalPixelCoords = map.converter.pageToGlobal([rect.left + rect.width / 2, rect.top + rect.height / 2]);
                geoCoords = map.options.get('projection').fromGlobalPixels(globalPixelCoords, map.getZoom());
            } catch (e) {
                continue;
            }

            if (!geoCoords) continue;

            const trueLat = geoCoords[0] + (mapOffsetY * 0.000008983);
            const trueLon = geoCoords[1] + (mapOffsetX * 0.000008983);
            const mskCoordsText = convertWgs84ToMskWithOffset([[trueLon, trueLat]], destSc, destSystem.def, offsetX, offsetY);
            
            if (mskCoordsText) {
                formattedBlocks.push(`${textContent}\n${mskCoordsText}`);
            }
        }

        if (formattedBlocks.length === 0) {
            throw new Error('Не удалось получить координаты ни для одного объекта.');
        }

        const finalStringToCopy = formattedBlocks.join('\n\n');
        await navigator.clipboard.writeText(finalStringToCopy);
        
        showNotification(`Координаты ${formattedBlocks.length} объектов для Георедактора скопированы`, 'success', 'check-circle');
        window.open('editor.html', '_blank');

    } catch (error) {
        console.error("Ошибка при экспорте в Георедактор:", error);
        showNotification(`Ошибка: ${error.message}`, 'error', 'exclamation-circle');
    } finally {
        hideLoader();
    }
}





async function generateXmlForAllObjects() {
    try {
        const allDrawableObjects = new Set([...polygons, ...areaObjects]);
        const draggableTextElements = Array.from(document.querySelectorAll('.draggable-text'));

        // ***** НАЧАЛО ИЗМЕНЕНИЯ: ФИЛЬТРУЕМ ТОЧЕЧНЫЕ ОБЪЕКТЫ *****
        const objectsToConvert = Array.from(allDrawableObjects).filter(obj => 
            obj instanceof ymaps.Polygon || obj instanceof ymaps.Polyline
        );
        // ***** КОНЕЦ ИЗМЕНЕНИЯ *****

        if (objectsToConvert.length === 0 && draggableTextElements.length === 0) {
            showNotification('На карте нет площадных или линейных объектов для формирования XML', 'warning', 'exclamation-triangle');
            return;
        }
        
        showLoader('Формирование XML схемы...');

        const destSc = localStorage.getItem('savedDefaultMskSystem') || 'EPSG:6331602';
        const destSystemObject = (typeof COORDINATE_SYSTEMS !== 'undefined') ? COORDINATE_SYSTEMS.find(s => s.value === destSc) : null;
        if (!destSystemObject || !destSystemObject.def) {
            throw new Error(`Определение для СК ${destSc} не найдено в sk.js`);
        }
        const destSystemDef = destSystemObject.def;
        const destSystemText = destSystemObject.text;
        
        let offsetX = 0, offsetY = 0;
        const isAutoLoadEnabled = (localStorage.getItem('autoLoadMskOffset') !== 'false');
        if (isAutoLoadEnabled) {
            offsetX = destSystemObject.offsetX || 0;
            offsetY = destSystemObject.offsetY || 0;
        } else {
            offsetX = parseFloat((localStorage.getItem('savedMskOffsetX') || '0').replace(',', '.')) || 0;
            offsetY = parseFloat((localStorage.getItem('savedMskOffsetY') || '0').replace(',', '.')) || 0;
        }
        
        const escapeXml = (unsafe) => unsafe ? String(unsafe).replace(/[<>&'"]/g, c => ({'<':'&lt;','>':'&gt;','&':'&amp;','\'':'&apos;','"':'&quot;'}[c])) : '';
        const skIdText = destSystemText.split('(')[0].trim();
        const today = new Date();
        const dateString = `${today.getFullYear()}-${String(today.getMonth() + 1).padStart(2, '0')}-${String(today.getDate()).padStart(2, '0')}`;
        
        proj4.defs(destSc, destSystemDef);
        proj4.defs("EPSG:4326", "+proj=longlat +datum=WGS84 +no_defs");

        const generateOrdinatesXml = (wgs84Coords) => {
            return wgs84Coords.map((coord, i) => {
                const mskPoint = proj4("EPSG:4326", destSc, coord);
                const y_msk = mskPoint[0] + offsetY;
                const x_msk = mskPoint[1] + offsetX;
                return `<ordinate><x>${x_msk.toFixed(2)}</x><y>${y_msk.toFixed(2)}</y><ord_nmb>${i + 1}</ord_nmb></ordinate>`;
            }).join('');
        };
        
        const generateEntitySpatialXml = (wgs84Coords) => {
            const ordinatesXml = generateOrdinatesXml(wgs84Coords);
            return `<entity_spatial><sk_id>${escapeXml(skIdText)}</sk_id><spatials_elements><spatial_element><ordinates>${ordinatesXml}</ordinates></spatial_element></spatials_elements></entity_spatial>`;
        };

        const generateLandRecordXml = (f, entitySpatial) => {
            const p = f.properties.options || {};
            const areaVal = p.specified_area || p.land_record_area_verified || p.declared_area || p.land_record_area_declaration || p.land_record_area;
            const areaBlock = areaVal ? ((p.specified_area || p.land_record_area_verified) ? `<area><value>${escapeXml(areaVal)}</value><inaccuracy>0</inaccuracy></area>` : `<area><value>${escapeXml(areaVal)}</value></area>`) : '';
            return `<land_record><object><common_data><type><code>002001001000</code><value>Земельный участок</value></type><cad_number>${escapeXml(p.cad_num || f.properties.descr)}</cad_number></common_data></object><params>${areaBlock}<category><type><code>-</code><value>${escapeXml(p.land_record_category_type)}</value></type></category><permitted_use><permitted_use_established><by_document>${escapeXml(p.permitted_use_established_by_document)}</by_document></permitted_use_established></permitted_use></params><address_location><address><readable_address>${escapeXml(p.readable_address)}</readable_address></address></address_location><cost><value>${escapeXml(p.cost_value)}</value></cost><contours_location><contours><contour>${entitySpatial}</contour></contours></contours_location></land_record>`;
        };
        const generateBuildRecordXml = (f, entitySpatial) => {
            const p = f.properties.options || {};
            return `<build_record><object><common_data><type><code>002001002000</code><value>Здание</value></type><cad_number>${escapeXml(p.cad_num || f.properties.descr)}</cad_number></common_data></object><params><area>${escapeXml(p.build_record_area)}</area><purpose><code>-</code><value>${escapeXml(p.purpose)}</value></purpose></params><address_location><address><readable_address>${escapeXml(p.readable_address)}</readable_address></address></address_location><cost><value>${escapeXml(p.cost_value)}</value></cost><contours><contour>${entitySpatial}</contour></contours></build_record>`;
        };
        const generateConstructionRecordXml = (f, entitySpatial) => {
            const p = f.properties.options || {};
            const baseParam = p.params_extension ? `<extension>${escapeXml(p.params_extension)}</extension>` : (p.params_area ? `<area>${escapeXml(p.params_area)}</area>` : '');
            return `<construction_record><object><common_data><type><code>002001004000</code><value>Сооружение</value></type><cad_number>${escapeXml(p.cad_number || p.cad_num || f.properties.descr)}</cad_number></common_data></object><params><base_parameters><base_parameter>${baseParam}</base_parameter></base_parameters><purpose>${escapeXml(p.params_purpose)}</purpose></params><address_location><address><readable_address>${escapeXml(p.address_readable_address || p.readable_address)}</readable_address></address></address_location><cost><value>${escapeXml(p.cost_value)}</value></cost><contours><contour>${entitySpatial}</contour></contours></construction_record>`;
        };

        let landRecordsXml = '', buildRecordsXml = '', constructionRecordsXml = '', spatialDataXml = '';
        let objectCounter = 1;
        
        // ***** НАЧАЛО ИЗМЕНЕНИЯ: ИСПОЛЬЗУЕМ ОТФИЛЬТРОВАННЫЙ МАССИВ *****
        for (const targetObject of objectsToConvert) {
        // ***** КОНЕЦ ИЗМЕНЕНИЯ *****
            let yandexCoords, isPolygon = false, isLine = false;
            let identifier, featureData;

            if (targetObject instanceof ymaps.Polygon) {
                if (targetObject.options.get('strokeStyle') === 'dash') {
                    const quarterCoords = targetObject.geometry.getCoordinates()[0];
                    const wgs84CoordsForQuarter = [...quarterCoords].reverse().map(coord => [coord[1] + (mapOffsetX * 0.000008983), coord[0] + (mapOffsetY * 0.000008983)]);
                    spatialDataXml = `<spatial_data>${generateEntitySpatialXml(wgs84CoordsForQuarter)}</spatial_data>`;
                    continue; 
                }
                isPolygon = true;
                yandexCoords = targetObject.geometry.getCoordinates()[0]; 
                featureData = targetObject.properties.get('featureData');
                identifier = targetObject.properties.get('cadastralNumber');
            } else if (targetObject instanceof ymaps.Polyline) {
                isLine = true;
                yandexCoords = targetObject.geometry.getCoordinates();
                featureData = targetObject.properties.get('featureData');
                identifier = targetObject.properties.get('cadastralNumber') || targetObject.properties.get('hintContent');
            } else {
                continue; // Пропускаем все, что не полигон и не линия
            }

            if (!yandexCoords || yandexCoords.length === 0) continue;

            const wgs84Coords = [...yandexCoords].reverse().map(coord => {
                const trueLat = coord[0] + (mapOffsetY * 0.000008983);
                const trueLon = coord[1] + (mapOffsetX * 0.000008983);
                return [trueLon, trueLat];
            });

            const entitySpatial = generateEntitySpatialXml(wgs84Coords);
            const finalIdentifier = identifier || (isPolygon ? `Площадной_объект_${objectCounter++}` : `Линейный_объект_${objectCounter++}`);
            
            let recordType = 'unknown';
            if (featureData && featureData.properties) {
                const category = featureData.properties.category;
                if (category === CATEGORY_IDS.ZU) recordType = 'land';
                else if (category === CATEGORY_IDS.BUILDINGS) recordType = 'building';
                else if (category === CATEGORY_IDS.CONSTRUCTIONS) recordType = 'construction';
            }
            if (recordType === 'unknown') {
                recordType = isPolygon ? 'land' : 'construction';
            }
            
            if (recordType === 'land') {
                landRecordsXml += (featureData ? generateLandRecordXml(featureData, entitySpatial) : `<land_record><object><common_data><type><code>002001001000</code><value>Земельный участок</value></type><cad_number>${escapeXml(finalIdentifier)}</cad_number></common_data></object><contours_location><contours><contour>${entitySpatial}</contour></contours></contours_location></land_record>`) + '\n';
            } else if (recordType === 'building') {
                buildRecordsXml += (featureData ? generateBuildRecordXml(featureData, entitySpatial) : `<build_record><object><common_data><type><code>002001002000</code><value>Здание</value></type><cad_number>${escapeXml(finalIdentifier)}</cad_number></common_data></object><contours><contour>${entitySpatial}</contour></contours></build_record>`) + '\n';
            } else if (recordType === 'construction') {
                constructionRecordsXml += (featureData ? generateConstructionRecordXml(featureData, entitySpatial) : `<construction_record><object><common_data><type><code>002001004000</code><value>Сооружение</value></type><cad_number>${escapeXml(finalIdentifier)}</cad_number></common_data></object><contours><contour>${entitySpatial}</contour></contours></construction_record>`) + '\n';
            }
        }
        
        for (const textEl of draggableTextElements) {
            const textContent = textEl.querySelector('span')?.textContent || `Текст_${objectCounter++}`;
            const rect = textEl.getBoundingClientRect();
            let geoCoords;
            try {
                const globalPixelCoords = map.converter.pageToGlobal([rect.left + rect.width / 2, rect.top + rect.height / 2]);
                geoCoords = map.options.get('projection').fromGlobalPixels(globalPixelCoords, map.getZoom());
            } catch (e) { continue; }
            if (!geoCoords) continue;
            const trueLat = geoCoords[0] + (mapOffsetY * 0.000008983);
            const trueLon = geoCoords[1] + (mapOffsetX * 0.000008983);
            const entitySpatial = generateEntitySpatialXml([[trueLon, trueLat]]);
            constructionRecordsXml += generateConstructionRecordXml({ properties: { descr: textContent } }, entitySpatial) + '\n';
        }

        const uniqueQuarters = new Set();
        if (currentQuarterNumber) uniqueQuarters.add(currentQuarterNumber);
        objectsToConvert.forEach(obj => { // Используем отфильтрованный массив
            const cadNum = obj.properties?.get('cadastralNumber');
            if (cadNum && cadNum.includes(':')) {
                const parts = cadNum.split(':');
                if (parts.length >= 3 && !isZeroQuarterRequest(parts.slice(0,3).join(':'))) {
                    uniqueQuarters.add(parts.slice(0, 3).join(':'));
                }
            }
        });

        let quarterForXml, filenameQuarterPart;
        if (uniqueQuarters.size === 1) {
            quarterForXml = Array.from(uniqueQuarters)[0];
            filenameQuarterPart = quarterForXml.replace(/:/g, '_');
        } else if (uniqueQuarters.size > 1) {
            const sortedQuarters = Array.from(uniqueQuarters).sort();
            quarterForXml = sortedQuarters[0];
            filenameQuarterPart = sortedQuarters.map(q => q.replace(/:/g, '_')).join(' ');
        } else {
            quarterForXml = '00:00:000000';
            filenameQuarterPart = '00_00_000000';
        }
        const filenameBase = `Схема_XML_${filenameQuarterPart}_${dateString}`;
            
        const fullXml = `<?xml version="1.0" encoding="UTF-8"?><extract_cadastral_plan_territory><details_statement><group_top_requisites><organ_registr_rights>Схема XML</organ_registr_rights><date_formation>${dateString}</date_formation></group_top_requisites></details_statement><cadastral_blocks><cadastral_block><cadastral_number>${escapeXml(quarterForXml)}</cadastral_number>${spatialDataXml}<record_data><base_data>${landRecordsXml ? `<land_records>${landRecordsXml}</land_records>` : ''}${buildRecordsXml ? `<build_records>${buildRecordsXml}</build_records>` : ''}${constructionRecordsXml ? `<construction_records>${constructionRecordsXml}</construction_records>` : ''}</base_data></record_data></cadastral_block></cadastral_blocks></extract_cadastral_plan_territory>`;
        
        const minifiedXml = fullXml.replace(/>\s+</g, '><').replace(/(\r\n|\n|\r)/gm, "");
        await navigator.clipboard.writeText(minifiedXml);
        
        await createAndDownloadZip(fullXml, filenameBase);
        
        showNotification('XML скопирован и скачан', 'success', 'check-circle');
        window.open('схема_xml.html', '_blank');

    } catch (error) {
        console.error("Ошибка при генерации XML схемы:", error);
        showNotification(`Ошибка: ${error.message}`, 'error', 'exclamation-circle');
    } finally {
        hideLoader();
    }
}

async function createAndDownloadZip(xmlContent, filenameBase) {
    const zip = new JSZip();
    zip.file(`${filenameBase}.xml`, xmlContent);
    const blob = await zip.generateAsync({
        type: "blob",
        compression: "DEFLATE",
        compressionOptions: { level: 9 }
    });
    const link = document.createElement('a');
    link.href = URL.createObjectURL(blob);
    link.download = `${filenameBase}.zip`;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    URL.revokeObjectURL(link.href);
}



function isCoordinates(text) {
    if (!text || text.trim() === "") {
        return false;
    }
    const allowedChars = /^[0-9\s\t\n.,-]+$/; // Digits, spaces, tabs, newlines, dot, comma, minus
    const hasColon = text.includes(':');
    return allowedChars.test(text) && !hasColon;
}

async function processAndDrawParcels(features, source) {
    if (!map) {
        console.error('Карта не инициализирована');
        return [];
    }

    const newlyDrawnObjects = [];
    let combinedBounds = null;
    const isQuarterSource = source === 'quarter';
    const isAreaSearchSource = source === 'areaSearch'; // Flag for search results

    for (const feature of features) {
        try {
            if (!feature?.properties?.descr || !feature?.geometry?.coordinates) {
                 console.warn("Skipping feature due to missing properties or geometry:", feature);
                 continue;
            }

            const geometryType = feature.geometry.type;
            
            // --- ИЗМЕНЕНИЕ ЗДЕСЬ ---
            const polygonsData = [];
            if (geometryType === 'Polygon' && feature.geometry.coordinates) {
                polygonsData.push(feature.geometry.coordinates);
            } else if (geometryType === 'MultiPolygon' && Array.isArray(feature.geometry.coordinates)) {
                feature.geometry.coordinates.forEach(polyCoords => polygonsData.push(polyCoords));
            } else {
                continue;
            }

            for (const polygonRings of polygonsData) {
                const allProcessedRings = polygonRings.map(ring => {
                    if (!Array.isArray(ring) || ring.length < 3) return null;

                    const coordinates = ring.map(coord => {
                        if (!Array.isArray(coord) || coord.length !== 2 || typeof coord[0] !== 'number' || typeof coord[1] !== 'number') return null;
                        try {
                            const p = proj4('EPSG:3857', 'EPSG:4326', coord);
                            return (!p || !isFinite(p[0]) || !isFinite(p[1])) ? null : [p[1], p[0]];
                        } catch { return null; }
                    }).filter(p => p !== null);
                    
                    if (coordinates.length < 3) return null;

                    return coordinates.map(coord => [coord[0] - mapOffsetY * 0.000008983, coord[1] - mapOffsetX * 0.000008983]);
                }).filter(r => r !== null);
                
                if (allProcessedRings.length === 0) continue;

                const cadastralNumber = feature.properties.descr;
                const parcelOptions = feature.properties.options || {};
                const address = parcelOptions.readable_address || 'Адрес не указан';
                const areaText = getAreaText(parcelOptions);
                const costIndex = parcelOptions.cost_index !== undefined && parcelOptions.cost_index !== null && isFinite(parseFloat(parcelOptions.cost_index)) ? parseFloat(parcelOptions.cost_index) : null;
                const vri = parcelOptions.permitted_use_established_by_document || null;
                const ownershipType = parcelOptions.ownership_type || '-';
                const rightType = parcelOptions.right_type || '-';
                const isVerified = parcelOptions.specified_area || parcelOptions.land_record_area_verified;
                const hasDeclaredField = parcelOptions.declared_area || parcelOptions.land_record_area_declaration || parcelOptions.land_record_area;
                const isDeclared = !isVerified && hasDeclaredField;
                const finalStrokeColor = isAreaSearchSource ? '#FF4500' : (isDeclared ? polygonStyle.declaredParcelsColor : polygonStyle.parcelsColor);

                const hintContent = {
                     cadastralNumber: `${cadastralNumber}`,
                     address: `${address}`,
                     area: `Площадь: ${areaText}`,
                     cost: costIndex !== null ? costIndex.toLocaleString('ru-RU', { maximumFractionDigits: 2 }) : null,
                     vri: vri,
                     ownershipType: ownershipType,
                     rightType: rightType
                 };

                 const polygonProperties = {
                     hintContent: hintContent,
                     cadastralNumber: cadastralNumber,
                     address: address,
                     areaText: areaText,
                     costIndex: costIndex,
                     vri: vri,
                     featureData: feature,
                     isParcelInQuarter: isQuarterSource,
                     isFoundInArea: isAreaSearchSource
                 };

                 const parcelPolygon = new ymaps.Polygon(allProcessedRings, polygonProperties, {
                     strokeColor: finalStrokeColor,
                     strokeWidth: polygonStyle.width - 1,
                       strokeOpacity: loadedObjectOpacity,
                     fillColor: '#00000000',
                     hintLayout: customHintLayout,
                     hintOpenTimeout: 100, hintCloseTimeout: 50,
                     cursor: 'pointer',
                     zIndex: isAreaSearchSource ? 800 : 500
                 });
                
                 parcelPolygon.events.add('click', function (e) {
                      if (e.get('altKey')) {
                           const options = parcelPolygon.properties.get('featureData')?.properties?.options || {};
                           const isDeclared = !options.specified_area && !options.land_record_area_verified && !options.land_record_area && (options.land_record_area_declaration || options.declared_area);
                           const baseColor = isDeclared ? polygonStyle.declaredParcelsColor : polygonStyle.parcelsColor;
                          parcelPolygon.options.set('fillColor', `${baseColor}33`);
                      }
                      else {
                         const hintData = parcelPolygon.properties.get('hintContent');
                         let balloonContent = `<strong>${hintData.cadastralNumber}</strong><br>${hintData.address}<br>${hintData.area}`;
                         if (hintData.cost) balloonContent += `<br>Стоимость: ${hintData.cost} руб./м²`;
                         if (hintData.vri) balloonContent += `<br>Разрешенное использование: ${hintData.vri}`;
                         if (hintData.ownershipInfo) balloonContent += `<br>Собственность: ${hintData.ownershipInfo}`;
                         map.balloon.open(e.get('coords'), balloonContent);
                     }
                 });
                 parcelPolygon.events.add('dblclick', async function (e) {
                     try { await navigator.clipboard.writeText(cadastralNumber); showNotification(`Скопировано: ${cadastralNumber}`, 'success', 'check-circle'); }
                     catch (err) { console.error('Ошибка копирования КН:', err); showNotification('Ошибка копирования КН', 'error', 'exclamation-circle'); }
                 });

                 map.geoObjects.add(parcelPolygon);
                 polygons.push(parcelPolygon);
                 newlyDrawnObjects.push(parcelPolygon);

                 const parcelBounds = parcelPolygon.geometry.getBounds();
                 if (parcelBounds?.[0]?.[0] !== undefined && isFinite(parcelBounds[0][0])) {
                     if (!combinedBounds) { combinedBounds = [[parcelBounds[0][0], parcelBounds[0][1]], [parcelBounds[1][0], parcelBounds[1][1]]]; }
                     else { combinedBounds[0][0] = Math.min(combinedBounds[0][0], parcelBounds[0][0]); combinedBounds[0][1] = Math.min(combinedBounds[0][1], parcelBounds[0][1]); combinedBounds[1][0] = Math.max(combinedBounds[1][0], parcelBounds[1][0]); combinedBounds[1][1] = Math.max(combinedBounds[1][1], parcelBounds[1][1]); }
                 }

                  if (parcelBounds?.[0]?.[0] !== undefined && isFinite(parcelBounds[0][0])) {
                     const parcelCenterGeo = [(parcelBounds[0][0] + parcelBounds[1][0]) / 2, (parcelBounds[0][1] + parcelBounds[1][1]) / 2];
                     const parts = cadastralNumber.split(':');
                     const hasSixOrSevenZeros = parts.length >= 3 && /^0{6,7}$/.test(parts[2]);
                     const displayNumber = hasSixOrSevenZeros ? cadastralNumber : (parts.length > 3 ? ':' + parts.pop() : cadastralNumber);

                     const labelProperties = {
                         iconContent: displayNumber,
                         hintContent: hintContent,
                         cadastralNumber: cadastralNumber
                     };
                      if (isQuarterSource) labelProperties.isParcelInQuarter = true;
                      if (isAreaSearchSource) labelProperties.isFoundInArea = true;

                     const parcelText = new ymaps.Placemark(parcelCenterGeo, labelProperties, {
                         iconLayout: customPlacemarkLayout,
                         hintLayout: customHintLayout,
                         hasBalloon: false,
                         draggable: false,
                         visible: map.getZoom() > 14,
                         zIndex: isAreaSearchSource ? 850 : 550
                     });
                     parcelText.polygon = parcelPolygon;
                     map.geoObjects.add(parcelText);
                     parcelPlacemarks.push(parcelText);
                     polygons.push(parcelText);
                     newlyDrawnObjects.push(parcelText);
                  }
            }
        } catch (error) {
            console.error('Ошибка при отрисовке земельного участка:', error, feature);
        }
    }

    if (combinedBounds && combinedBounds[0] && combinedBounds[1] && combinedBounds[0].length === 2 && combinedBounds[1].length === 2 && isFinite(combinedBounds[0][0])) {
        const currentBounds = map.getBounds();
        let shouldSetBounds = true;
        if (currentBounds && currentBounds[0] && currentBounds[1]) {
             const margin = 0.0001;
             if (combinedBounds[0][0] >= currentBounds[0][0] - margin &&
                 combinedBounds[0][1] >= currentBounds[0][1] - margin &&
                 combinedBounds[1][0] <= currentBounds[1][0] + margin &&
                 combinedBounds[1][1] <= currentBounds[1][1] + margin) {
                    shouldSetBounds = false;
             }
        }

        if (shouldSetBounds) {
            const latMargin = (combinedBounds[1][0] - combinedBounds[0][0]) * 0.15 || 0.0005;
            const lonMargin = (combinedBounds[1][1] - combinedBounds[0][1]) * 0.15 || 0.0005;
            const viewBounds = [[combinedBounds[0][0] - latMargin, combinedBounds[0][1] - lonMargin], [combinedBounds[1][0] + latMargin, combinedBounds[1][1] + lonMargin]];
            try { map.setBounds(viewBounds, { checkZoomRange: true, duration: 300 }); }
            catch (setBoundsError) { console.error("Ошибка установки границ:", setBoundsError, viewBounds); }
        }
    } else if (newlyDrawnObjects.length === 1 && newlyDrawnObjects[0] instanceof ymaps.Placemark) {
         map.setCenter(newlyDrawnObjects[0].geometry.getCoordinates(), map.getZoom() > 16 ? map.getZoom() : 17);
    }

    return newlyDrawnObjects;
}



// --- НОВЫЕ ФУНКЦИИ ДЛЯ ОТЧЕТА ПО ЛИНЕЙНЫМ ОБЪЕКТАМ ---

/**
 * Находит ближайшую линию к точке клика.
 */
function findLineAtPoint(lat, lon) {
    let closestLine = null;
    let minDistance = Infinity;
    const clickPoint = [lat, lon];
    const pixelThreshold = 10; // Допуск в 10 пикселей

    polygons.forEach(obj => {
        if (obj instanceof ymaps.Polyline && obj.properties.get('isDrawableLine')) {
            const closest = obj.geometry.getClosest(clickPoint);
            const dist = closest.distance; // API Яндекс.Карт возвращает расстояние в пикселях
            if (dist < pixelThreshold && dist < minDistance) {
                minDistance = dist;
                closestLine = obj;
            }
        }
    });
    return closestLine;
}


/**
 * Показывает модальное окно для выбора линии, если на карте их несколько.
 */
function showLineSelectionModal(lines) {
    const modal = document.createElement('div');
    modal.className = 'style-modal';
    modal.style.display = 'flex';

    const modalContent = document.createElement('div');
    modalContent.className = 'style-modal-content';
    modalContent.style.width = '400px';
    modalContent.innerHTML = '<h3>Выберите объект для отчета</h3>';
    
    // Кнопка для анализа всех линий как единого объекта
    const analyzeAllButton = document.createElement('button');
    analyzeAllButton.textContent = `Анализировать все ${lines.length} контура как один объект`;
    Object.assign(analyzeAllButton.style, {
        display: 'block', width: '100%', padding: '12px', marginTop: '10px', marginBottom: '20px',
        cursor: 'pointer', backgroundColor: '#4CAF50', color: 'white', border: 'none', borderRadius: '5px'
    });
    
    analyzeAllButton.onclick = () => {
        document.body.removeChild(modal);
        generateLinearObjectReport(lines); 
    };
    modalContent.appendChild(analyzeAllButton);

    // Кнопки для каждой отдельной линии
    lines.forEach((line, index) => {
        const coords = line.geometry.getCoordinates();
        const turfLine = turf.lineString(coords.map(c => [c[1], c[0]]));
        const length = turf.length(turfLine, { units: 'meters' });

        const button = document.createElement('button');
        button.textContent = `Только контур ${index + 1} (Протяженность: ${length.toFixed(2)} м)`;
        Object.assign(button.style, {
            display: 'block', width: '100%', padding: '10px', marginTop: '10px', cursor: 'pointer'
        });
        
        button.onclick = () => {
            document.body.removeChild(modal);
            generateLinearObjectReport(line);
        };
        modalContent.appendChild(button);
    });

    const cancelBtn = document.createElement('button');
    cancelBtn.textContent = 'Отмена';
    Object.assign(cancelBtn.style, { marginTop: '20px', padding: '10px', cursor: 'pointer' });
    cancelBtn.onclick = () => document.body.removeChild(modal);
    modalContent.appendChild(cancelBtn);

    modal.appendChild(modalContent);
    document.body.appendChild(modal);

    modal.addEventListener('click', (e) => {
        if (e.target === modal) document.body.removeChild(modal);
    });
}


async function generateLinearObjectReport(targetObject) {
    const delay = ms => new Promise(res => setTimeout(res, ms));
    showLoader("Формирование отчета по линии...");

    try {
        const isMultiContour = Array.isArray(targetObject);
        const lines = isMultiContour ? targetObject : [targetObject];
        if (lines.length === 0) throw new Error('Нет линий для анализа.');

        const allCoords = [];
        const turfLines = lines.map(line => {
            const coords = line.geometry.getCoordinates();
            allCoords.push(...coords);
            return turf.lineString(coords.map(c => [c[1], c[0]]));
        });
        
        const multiLineString = turf.multiLineString(turfLines.map(l => l.geometry.coordinates));
        const totalLength = turf.length(multiLineString, { units: 'meters' });
        
        const mainObjectData = {
            type: isMultiContour ? `Многоконтурный линейный объект (${lines.length} контура)` : 'Линейный объект',
            totalLength: totalLength.toFixed(2),
            pointsCount: allCoords.length,
            coordinates: allCoords
        };

        showLoader('Поиск пересекаемых объектов...');

        const bufferedLine = turf.buffer(multiLineString, 100, {units: 'meters'});
        const totalBbox = turf.bbox(bufferedLine);
        const bounds = [ [totalBbox[1], totalBbox[0]], [totalBbox[3], totalBbox[2]] ];

        const searchPolygonForApi = [
            [bounds[0][1], bounds[0][0]],
            [bounds[1][1], bounds[0][0]],
            [bounds[1][1], bounds[1][0]],
            [bounds[0][1], bounds[1][0]],
            [bounds[0][1], bounds[0][0]]
        ].map(coord => proj4("EPSG:4326", "EPSG:3857", coord));

        const parcelsInArea = await searchObjectsByArea(searchPolygonForApi, 36368);
        await delay(100);
        const oksInArea = await searchObjectsByArea(searchPolygonForApi, 36369);
        await delay(100);
        const zouitsInArea = await searchObjectsByArea(searchPolygonForApi, 36940);

        showLoader('Анализ наложений...');
        
        const underlyingParcelsResults = findLinearIntersections(turfLines, parcelsInArea);
        const oksResults = findLinearIntersections(turfLines, oksInArea);
        const zouitResults = findLinearIntersections(turfLines, zouitsInArea);

        const allIntersectedObjectsForMainScheme = [
            ...underlyingParcelsResults.map(r => r.feature), 
            ...oksResults.map(r => r.feature),
            ...zouitResults.map(r => r.feature)
        ];
        const { image, coordsTable } = await drawLinearObjectToCanvas(lines, allIntersectedObjectsForMainScheme);
        
        let oksScheme = null;
        if (oksResults.length > 0) {
            const { image: generatedOksScheme } = await drawLinearObjectToCanvas(lines, oksResults.map(r => r.feature));
            oksScheme = generatedOksScheme;
        }
        
       const { html } = buildLinearReportHtml(mainObjectData, underlyingParcelsResults, oksResults, zouitResults, image, oksScheme, coordsTable);
        
        const reportWindow = window.open('', '_blank');
        if (reportWindow) {
            // Сначала пишем только HTML
            reportWindow.document.write(html);
            // Закрываем документ, так как скрипта для добавления нет
            reportWindow.document.close();
        } else {
            throw new Error('Не удалось открыть новое окно. Возможно, оно заблокировано браузером.');
        }

    } catch (error) {
        console.error("Ошибка при формировании отчета по линии:", error);
        showNotification(error.message, 'error', 'exclamation-circle', 5000);
    } finally {
        hideLoader();
    }
}


/**
 * Универсальная функция для поиска объектов по области.
 */
async function searchObjectsByArea(searchPolygonCoordsEPSG3857, categoryId) {
    const requestBody = {
        "geom": { "type": "FeatureCollection", "features": [{"type": "Feature", "geometry": {"crs": { "type": "name", "properties": { "name": "EPSG:3857" } }, "type": "Polygon", "coordinates": [searchPolygonCoordsEPSG3857]}, "properties": {}}] },
        "categories": [{"id": categoryId}]
    };
    try {
        const response = await fetchNspd('https://nspd.gov.ru/api/geoportal/v1/intersects?typeIntersect=fullObject', {
            method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(requestBody)
        });
        const text = await response.text();
        if (!text) return [];
        const data = JSON.parse(text);
        return data.features || [];
    } catch (error) {
        console.error(`Ошибка при запросе объектов для категории ${categoryId}:`, error);
        return [];
    }
}


function findLinearIntersections(turfLines, targetFeatures) {
    const results = [];
    const processedFeatureIds = new Set();

    targetFeatures.forEach(feature => {
        // Универсальное получение ID для ЗУ, ОКС и ЗОУИТ
        const featureId = feature.properties.descr || feature.properties.options?.reg_numb_border || feature.properties.options?.cad_num;
        
        if (!featureId || processedFeatureIds.has(featureId) || !feature.geometry || !['Polygon', 'MultiPolygon'].includes(feature.geometry.type)) {
            return;
        }

        let isIntersecting = false;

        // Вспомогательная функция для проверки пересечения двух отрезков [p1, p2] и [p3, p4]
        const doLineSegmentsIntersect = (p1, p2, p3, p4) => {
            const ccw = (a, b, c) => (c[1] - a[1]) * (b[0] - a[0]) > (b[1] - a[1]) * (c[0] - a[0]);
            return ccw(p1, p3, p4) !== ccw(p2, p3, p4) && ccw(p1, p2, p3) !== ccw(p1, p2, p4);
        };

        const processPolygonRings = (rings) => {
            if (isIntersecting) return;
            
            try {
                // --- ГЛАВНОЕ ИСПРАВЛЕНИЕ ---
                // Преобразуем координаты полигона-кандидата в WGS-84 и ОДИН РАЗ применяем к ним смещение карты.
                // Теперь эти координаты находятся в той же системе, что и `turfLines`.
                const polygonWgsCoordsWithOffset = rings[0].map(coord3857 => {
                    const wgsCoord = proj4('EPSG:3857', 'EPSG:4326', coord3857);
                    // turf.js работает с [долгота, широта]
                    const lonWithOffset = wgsCoord[0] - (mapOffsetX * 0.000008983);
                    const latWithOffset = wgsCoord[1] - (mapOffsetY * 0.000008983);
                    return [lonWithOffset, latWithOffset];
                });

                // Проходим по каждой линии из нашего объекта
                for (const lineFeature of turfLines) {
                    const lineCoords = lineFeature.geometry.coordinates; // Координаты линии [долгота, широта]

                    // Проверка 1: Попадание вершины линии внутрь полигона
                    for (const point of lineCoords) {
                        if (turf.booleanPointInPolygon(point, turf.polygon([polygonWgsCoordsWithOffset]))) {
                            isIntersecting = true;
                            break;
                        }
                    }
                    if (isIntersecting) break;

                    // Проверка 2: Пересечение отрезков линии с границами полигона
                    for (let i = 0; i < lineCoords.length - 1; i++) {
                        const p1 = lineCoords[i];
                        const p2 = lineCoords[i + 1];

                        for (let j = 0; j < polygonWgsCoordsWithOffset.length - 1; j++) {
                            const p3 = polygonWgsCoordsWithOffset[j];
                            const p4 = polygonWgsCoordsWithOffset[j + 1];

                            if (doLineSegmentsIntersect(p1, p2, p3, p4)) {
                                isIntersecting = true;
                                break;
                            }
                        }
                        if (isIntersecting) break;
                    }
                    if (isIntersecting) break;
                }
            } catch (e) {
                console.error(`Ошибка при обработке полигона ${featureId} для анализа пересечений:`, e);
            }
        };
        
        if (feature.geometry.type === 'Polygon') {
            processPolygonRings(feature.geometry.coordinates);
        } else { // MultiPolygon
            for (const polyRings of feature.geometry.coordinates) {
                processPolygonRings(polyRings);
                if (isIntersecting) break;
            }
        }

        if (isIntersecting) {
            results.push({ feature: feature, length: 0 });
            processedFeatureIds.add(featureId);
        }
    });
    
    return results;
}


    function updateVercelProxySetting() {
            const checkbox = document.getElementById('toggleVercelProxy');
            if (checkbox) {
                useVercelProxyFeature = checkbox.checked;
         
             
            }
        }

async function drawLinearObjectToCanvas(mainLines, otherObjects) {
    const canvasWidth = 800;
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    const padding = 40;

    const destSc = localStorage.getItem('savedDefaultMskSystem') || 'EPSG:6331602';
    const destSystem = COORDINATE_SYSTEMS.find(s => s.value === destSc);
    if (!destSystem) throw new Error(`Определение для ${destSc} не найдено.`);
    const mskName = destSystem.text || 'МСК';

    const isAutoLoadEnabled = (localStorage.getItem('autoLoadMskOffset') !== 'false');
    const mskOffsetX = isAutoLoadEnabled ? (destSystem.offsetX || 0) : (parseFloat((localStorage.getItem('savedMskOffsetX') || '0').replace(',', '.')) || 0);
    const mskOffsetY = isAutoLoadEnabled ? (destSystem.offsetY || 0) : (parseFloat((localStorage.getItem('savedMskOffsetY') || '0').replace(',', '.')) || 0);

    const bboxCoords = [];
    mainLines.forEach(line => {
        line.geometry.getCoordinates().forEach(c => {
            const trueLat = c[0] + (mapOffsetY * 0.000008983);
            const trueLon = c[1] + (mapOffsetX * 0.000008983);
            bboxCoords.push(proj4('EPSG:4326', 'EPSG:3857', [trueLon, trueLat]));
        });
    });

    const minX = Math.min(...bboxCoords.map(p => p[0]));
    const maxX = Math.max(...bboxCoords.map(p => p[0]));
    const minY = Math.min(...bboxCoords.map(p => p[1]));
    const maxY = Math.max(...bboxCoords.map(p => p[1]));
    
    const projectedWidth = maxX - minX;
    const projectedHeight = maxY - minY;
    
    const scale = (canvasWidth - padding * 2) / (projectedWidth > 0 ? projectedWidth : 1);
    canvas.width = canvasWidth;
    canvas.height = projectedHeight * scale + padding * 2;
    
    const cOffsetX = (canvas.width - projectedWidth * scale) / 2;
    const cOffsetY = (canvas.height - projectedHeight * scale) / 2;
    
    ctx.fillStyle = '#FFFFFF';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    const drawnLabelBounds = [];

    otherObjects.forEach(feature => {
        if (!feature.geometry || !['Polygon', 'MultiPolygon'].includes(feature.geometry.type)) return;
        
        const props = feature.properties;
        const opts = props.options || {};

        const isZouit = !!opts.reg_numb_border;
        const isBuilding = props.categoryName === 'Здания';
        
        let color, name;

        if (isBuilding) {
            color = polygonStyle.buildingsColor;
            name = opts.cad_num || props.descr || 'ОКС';
        } else if (isZouit) {
            color = getZouitColor(opts.name_by_doc);
            name = `${opts.reg_numb_border || ''} ${opts.name_by_doc || ''}`.trim();
        } else {
            color = '#cccccc';
            name = props.descr || 'Объект';
        }

        const processPolygon = (polygonRings) => {
            let canvasPoints = [];
            ctx.beginPath();
            
            polygonRings.forEach(ring => {
                ring.forEach((coord3857, index) => {
                    const x = cOffsetX + (coord3857[0] - minX) * scale;
                    const y = canvas.height - (cOffsetY + (coord3857[1] - minY) * scale);
                    if (ring === polygonRings[0]) {
                        canvasPoints.push({x, y});
                    }
                    if (index === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
                });
                ctx.closePath();
            });

            ctx.strokeStyle = color;
            ctx.lineWidth = 1;
            ctx.stroke();
            ctx.fillStyle = `${color}1A`;
            ctx.fill();
            
            if (name) {
                ctx.fillStyle = '#555';
                ctx.font = '10px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                
                const textMetrics = ctx.measureText(name);
                const labelWidth = textMetrics.width + 8;
                const labelHeight = 10 + 8;

                const isOverlapping = (x, y) => {
                    const box = { left: x - labelWidth / 2, right: x + labelWidth / 2, top: y - labelHeight / 2, bottom: y + labelHeight / 2 };
                    return drawnLabelBounds.some(b => box.left < b.right && box.right > b.left && box.top < b.bottom && box.bottom > b.top);
                };
                
                const visiblePoints = canvasPoints.filter(p => p.x >= 0 && p.x <= canvas.width && p.y >= 0 && p.y <= canvas.height);
                if (visiblePoints.length === 0) return;

                const visMinX = Math.min(...visiblePoints.map(p => p.x));
                const visMaxX = Math.max(...visiblePoints.map(p => p.x));
                const visMinY = Math.min(...visiblePoints.map(p => p.y));
                const visMaxY = Math.max(...visiblePoints.map(p => p.y));
                const centerX = (visMinX + visMaxX) / 2;
                const centerY = (visMinY + visMaxY) / 2;

                let finalX, finalY;
                const offsets = [{x:0,y:0}, {x:0,y:-15}, {x:0,y:15}, {x:-20,y:0}, {x:20,y:0}];
                
                for (const offset of offsets) {
                    if (!isOverlapping(centerX + offset.x, centerY + offset.y)) {
                        finalX = centerX + offset.x;
                        finalY = centerY + offset.y;
                        break;
                    }
                }

                if (finalX !== undefined) {
                     ctx.strokeStyle = 'white';
                     ctx.lineWidth = 2;
                     ctx.strokeText(name, finalX, finalY);
                     ctx.fillText(name, finalX, finalY);
                     drawnLabelBounds.push({ left: finalX - labelWidth / 2, right: finalX + labelWidth / 2, top: finalY - labelHeight / 2, bottom: finalY + labelHeight / 2 });
                }
            }
        };

        if (feature.geometry.type === 'Polygon') {
            processPolygon(feature.geometry.coordinates);
        } else {
            feature.geometry.coordinates.forEach(poly => processPolygon(poly));
        }
    });

    let totalPointCounter = 1;
    let currentObjectTableBody = '';

    mainLines.forEach((line) => {
        ctx.beginPath();
        line.geometry.getCoordinates().forEach((coord, index) => {
            const trueLat = coord[0] + (mapOffsetY * 0.000008983);
            const trueLon = coord[1] + (mapOffsetX * 0.000008983);
            const projected = proj4('EPSG:4326', 'EPSG:3857', [trueLon, trueLat]);
            
            const x = cOffsetX + (projected[0] - minX) * scale;
            const y = canvas.height - (cOffsetY + (projected[1] - minY) * scale);
            
            if (index === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
            
            ctx.fillStyle = '#000000';
            ctx.fillRect(x - 2, y - 2, 4, 4);
            ctx.font = '10px Arial';
            ctx.fillText(`т${totalPointCounter}`, x + 5, y - 5);
            
            const mskCoords = convertWgs84ToMskWithOffset([[trueLon, trueLat]], destSc, destSystem.def, mskOffsetX, mskOffsetY).split('\t');
            currentObjectTableBody += `<tr><td>т${totalPointCounter}</td><td>${mskCoords[0]}</td><td>${mskCoords[1]}</td></tr>`;
            totalPointCounter++;
        });
        ctx.strokeStyle = '#FF0000';
        ctx.lineWidth = 3;
        ctx.stroke();
    });

    const coordsTable = `
        <div class="section-title">Каталог координат поворотных точек</div>
        <table>
            <thead><tr><th class="point-col">Номер точки</th><th>X (${mskName})</th><th>Y (${mskName})</th></tr></thead>
            <tbody>${currentObjectTableBody}</tbody>
        </table>`;

    return { image: canvas.toDataURL('image/png'), coordsTable };
}


function buildLinearReportHtml(mainObjectData, parcelsResults, oksResults, zouitResults, schemeImage, oksSchemeImage, coordsTableHtml) {
    const reportDate = new Date().toLocaleDateString('ru-RU');

    const generateResultTable = (title, items, headers, rowGenerator) => {
        let tableHtml = `<div class="section-title">${title}</div>`;
        if (!items || items.length === 0) return tableHtml + '<p style="text-align: center; margin: 10px 0;">Объекты не найдены.</p>';
        
        tableHtml += `<table><thead><tr>`;
        headers.forEach(h => tableHtml += `<th>${h}</th>`);
        tableHtml += '</tr></thead><tbody>';
        items.forEach(item => tableHtml += rowGenerator(item));
        tableHtml += '</tbody></table>';
        return tableHtml;
    };
    
    const parcelRowGenerator = (item) => `<tr>
        <td>${item.feature.properties.descr || '-'}</td>
        <td colspan="2">${item.feature.properties.options.readable_address || '-'}</td>
    </tr>`;

    const oksRowGenerator = (item) => `<tr>
        <td>${item.feature.properties.options.cad_num || '-'}</td>
        <td colspan="2">${item.feature.properties.options.purpose || item.feature.properties.descr || '-'}</td>
    </tr>`;

    const zouitRowGenerator = (item) => `<tr>
        <td>${item.feature.properties.options.reg_numb_border || '-'}</td>
        <td colspan="2">${item.feature.properties.options.name_by_doc || '-'}</td>
    </tr>`;

    // Возвращаем объект с разделенным HTML и JS
    const html = `<!DOCTYPE html><html lang="ru"><head><meta charset="UTF-8"><title>Отчет по линейному объекту</title><link rel="icon" href="img/report.png">
    <style>
        body{font-family: 'Liberation Serif', 'Times New Roman', Times, serif; margin: 0; background: #e9ecef; color: #212224; font-size: 11pt; line-height: 1.5;}
        .page{background: white; box-shadow: 0 4px 16px rgba(0,0,0,0.1); margin: 20px auto; padding: 20mm; box-sizing: border-box; width: 210mm; max-width: 98%;}
        table{width: 100%; border-collapse: collapse; margin: 15px 0 20px 0; table-layout: fixed;}
        th, td{border: 1px solid #ccc; padding: 8px 10px; text-align: left; vertical-align: middle; word-break: break-word;}
        th{background-color: #eaf0ff; color: #002a5c; font-weight: bold; text-align: center;}
        tbody tr:nth-child(even){background-color: #f8f9fa;}
        .main-info-table td:first-child{width: 35%; font-weight: bold; background-color: #f4f8ff;}
        .header{text-align: center; margin-bottom: 30px; padding-top: 15px; border-top: 4px solid #003366;}
        .header h3{font-size: 16pt; color: #002a5c; margin: 10px 0 5px 0; font-weight: 600; letter-spacing: 0.5px;}
        .header h4{font-size: 11pt; font-weight: normal; color: #555; margin: 0; font-style: italic;}
        .section-title{text-align: center; font-weight: bold; margin: 35px 0 15px 0; font-size: 12pt; page-break-after: avoid; color: #002a5c; border-bottom: 1px solid #d6e4ff; padding-bottom: 8px; text-transform: uppercase; letter-spacing: 1px;}
        .scheme-container{text-align: center; margin-top: 25px; page-break-inside: avoid;}
        .scheme-container img{max-width: 100%; border: 1px solid #ccc;}
        @media print{body{background: none;}.page{box-shadow: none; border: none; margin: 0; padding: 15mm; width: 100%;}}
    </style>
    </head>
    <body><div class="page">
        <div class="header">
            <h3>Отчет по линейному объекту</h3>
            <h4>сформирован ${reportDate}</h4>
        </div>
        <div class="section-title">Общие характеристики</div>
        <table class="main-info-table">
            <tr><td>Тип объекта</td><td>${mainObjectData.type}</td></tr>
            <tr><td>Общая протяженность</td><td>${mainObjectData.totalLength} м</td></tr>
            <tr><td>Количество поворотных точек</td><td>${mainObjectData.pointsCount}</td></tr>
        </table>
        ${generateResultTable( 'Пересекаемые земельные участки', parcelsResults, ['Кадастровый номер', 'Адрес'], parcelRowGenerator )}
        ${generateResultTable( 'Пересекаемые ОКС', oksResults, ['Кадастровый номер', 'Назначение'], oksRowGenerator )}
        ${generateResultTable( 'Пересекаемые ЗОУИТ', zouitResults, ['Рег. номер', 'Наименование'], zouitRowGenerator )}
        
        <div class="scheme-container"><div class="section-title">Общая схема расположения</div><img src="${schemeImage}" alt="Общая схема расположения"></div>
        ${oksSchemeImage ? `<div class="scheme-container"><div class="section-title">Схема пересекаемых ОКС</div><img src="${oksSchemeImage}" alt="Схема пересекаемых ОКС"></div>` : ''}

        ${coordsTableHtml}
    </div></body></html>`;

    // Возвращаем объект, где HTML и JS разделены
    return { html };
}


// Add this function to populate the sidebar with all currently loaded parcel features
function populateSidebarWithParcels(features, loadDate = null) {
     const sidebar = document.getElementById('parcel-results-sidebar');
     const contentDiv = document.getElementById('parcel-list-content');
     const statsDiv = document.getElementById('sidebar-stats');
     const sidebarTitle = document.getElementById('sidebar-title');
     const toggleBtn = document.getElementById('toggle-sidebar-btn');
     const filterInput = document.getElementById('filter-cadnum-input');
     const copyFilteredBtn = document.getElementById('copy-filtered-btn');

     if (!sidebar || !contentDiv || !sidebarTitle || !toggleBtn || !filterInput || !copyFilteredBtn || !statsDiv) {
         console.error("Sidebar elements not found!");
         return;
     }

     contentDiv.querySelectorAll('.sidebar-item').forEach(item => item.remove());
     statsDiv.innerHTML = '';
     if(filterInput) filterInput.value = '';

     const totalParcels = features.length;
     if(sidebar) sidebar.dataset.totalCount = totalParcels;

     if (loadDate) {
         if(sidebar) sidebar.dataset.titlePrefix = 'Архив: ' +loadDate;
     } else {
         if(sidebar) sidebar.dataset.titlePrefix = 'ЗУ в квартале';
     }

     if(sidebarTitle && sidebar.dataset.titlePrefix) {
        sidebarTitle.textContent = `${sidebar.dataset.titlePrefix} (${totalParcels}/${sidebar.dataset.totalCount})`;
     }
     
     let noResultsMsg = contentDiv.querySelector('.no-results-message');
     if (!noResultsMsg) {
         noResultsMsg = document.createElement('div');
         noResultsMsg.className = 'no-results-message';
         noResultsMsg.style.display = 'none';
         noResultsMsg.style.padding = '20px';
         noResultsMsg.style.textAlign = 'center';
         noResultsMsg.style.color = '#6b7280';
         contentDiv.prepend(noResultsMsg);
     }


     if (features.length > 0) {
         if (noResultsMsg) noResultsMsg.style.display = 'none';

         let declaredCount = 0;
         let specifiedCount = 0;

         features.forEach((feature, index) => {
            const properties = feature.properties || {};
            const options = properties.options || {};
            const cadNumber = properties.descr || 'Не указан';
            const address = options.readable_address || 'Адрес не указан';
            const areaText = getAreaText(options);

             // --- Логика подсчета статистики ---
             const isVerified = options.specified_area || options.land_record_area_verified;
             const hasDeclaredField = options.declared_area || options.land_record_area_declaration || options.land_record_area;
             const isDeclared = !isVerified && hasDeclaredField;

             if (isDeclared) {
                 declaredCount++;
             } else {
                 specifiedCount++;
             }
             // --- Конец логики подсчета ---

             const itemDiv = document.createElement('div');
             itemDiv.className = 'sidebar-item';
             itemDiv.dataset.cadnum = cadNumber.toLowerCase();
             itemDiv.innerHTML = `
                 <p>${index + 1}. ${cadNumber}</p>
                 <p>${address}</p>
                 <p>${areaText}</p>
             `;

             const correspondingPolygon = polygons.find(p =>
                 p instanceof ymaps.Polygon &&
                 p.properties?.get('cadastralNumber') === cadNumber &&
                 (p.properties?.get('isParcelInQuarter') === true || p.properties?.get('isFoundInArea') === true)
             );

             if (correspondingPolygon) {
                 itemDiv.addEventListener('dblclick', () => {
                      if (map) {
                         try {
                             const bounds = correspondingPolygon.geometry.getBounds();
                             if (bounds && bounds[0] && bounds[1]) {
                                 const latPadding = (bounds[1][0] - bounds[0][0]) * 0.15 || 0.0005;
                                 const lonPadding = (bounds[1][1] - bounds[0][1]) * 0.15 || 0.0005;
                                 const paddedBounds = [
                                      [bounds[0][0] - latPadding, bounds[0][1] - lonPadding],
                                      [bounds[1][0] + latPadding, bounds[1][1] + lonPadding]
                                 ];
                                 map.setBounds(paddedBounds, { checkZoomRange: true, duration: 500 });

                                  const originalFill = correspondingPolygon.options.get('fillColor') || '#00000000';
                                   const originalStroke = correspondingPolygon.options.get('strokeColor');
                                   const originalStrokeWidth = correspondingPolygon.options.get('strokeWidth');
                                   const originalStrokeOpacity = correspondingPolygon.options.get('strokeOpacity');

                                  correspondingPolygon.options.set({
                                      fillColor: '#FFFF0080',
                                      strokeColor: '#FFA500',
                                      strokeWidth: (correspondingPolygon.options.get('strokeWidth') || 2) + 2
                                  });
                                  setTimeout(() => {
                                      correspondingPolygon.options.set({
                                           fillColor: originalFill,
                                           strokeColor: originalStroke,
                                           strokeWidth: originalStrokeWidth,
                                           strokeOpacity: originalStrokeOpacity
                                      });
                                  }, 1500);

                             } else {
                                  console.warn("Не удалось получить границы для полигона:", correspondingPolygon);
                                  const coords = correspondingPolygon.geometry.getCoordinates()?.[0]?.[0];
                                  if (coords) map.setCenter(coords, 18, { duration: 500 });
                             }
                         } catch (e) {
                             console.error("Ошибка при позиционировании карты:", e);
                             const coords = correspondingPolygon.geometry.getCoordinates()?.[0]?.[0];
                             if (coords) map.setCenter(coords, 18, { duration: 500 });
                         }
                     }
                 });
             }
             contentDiv.appendChild(itemDiv);
         });

         // --- Отображение статистики ---
         const declaredPercent = totalParcels > 0 ? ((declaredCount / totalParcels) * 100).toFixed(0) : 0;
         const specifiedPercent = totalParcels > 0 ? ((specifiedCount / totalParcels) * 100).toFixed(0) : 0;
         
         statsDiv.innerHTML = `
             Декларированных ЗУ: <b>${declaredCount}</b> (${declaredPercent}%)<br>
             Уточненных ЗУ: <b>${specifiedCount}</b> (${specifiedPercent}%)
         `;
         statsDiv.style.display = 'block';
         // --- Конец отображения ---

         const footer = sidebar.querySelector('.sidebar-footer');
         if(footer) footer.style.display = 'flex';

     } else {
         if (noResultsMsg) {
            noResultsMsg.style.display = 'block';
            noResultsMsg.textContent = 'Нет загруженных участков в квартале.';
         }
         statsDiv.style.display = 'none'; // Скрываем статистику, если нет данных
         const footer = sidebar.querySelector('.sidebar-footer');
         if(footer) footer.style.display = 'none';
     }

     if(sidebar) sidebar.classList.remove('hidden', 'collapsed');
     if(toggleBtn) toggleBtn.innerHTML = '<i class="fas fa-chevron-right"></i>';
     isSidebarCollapsed = false;


     if(filterInput) filterInput.removeEventListener('input', function filterParcelList() {
    const filterInput = document.getElementById('filter-cadnum-input');
    const contentDiv = document.getElementById('parcel-list-content');
    const sidebar = document.getElementById('parcel-results-sidebar');
    
    if (!filterInput || !contentDiv || !sidebar) return;

    // Приводим поисковый запрос к нижнему регистру и убираем лишние пробелы
    const filterText = filterInput.value.toLowerCase().trim();
    // Разбиваем запрос на отдельные слова (чтобы находить и по номеру, и по улице одновременно)
    const searchTerms = filterText.split(/\s+/).filter(term => term.length > 0);

    const items = contentDiv.querySelectorAll('.sidebar-item');
    let visibleCount = 0;

    items.forEach(item => {
        // Получаем ВЕСЬ текст внутри карточки (номер, адрес, площадь и т.д.)
        const itemFullText = item.innerText.toLowerCase(); // Используем innerText для поиска видимого текста

        let isVisible = false;

        if (searchTerms.length === 0) {
            // Если фильтр пустой, показываем всё
            isVisible = true;
        } else {
            // Проверяем: ВСЕ ли слова из запроса есть в тексте карточки?
            // Например, запрос "нурлат советская" найдет карточку, где есть и "нурлат", и "советская"
            isVisible = searchTerms.every(term => itemFullText.includes(term));
        }

        // Переключаем класс видимости
        if (isVisible) {
            item.classList.remove('filtered-out');
            visibleCount++;
        } else {
            item.classList.add('filtered-out');
        }
    });

    // Обновляем заголовок с количеством
    const sidebarTitle = document.getElementById('sidebar-title');
    const totalCount = sidebar.dataset.totalCount || items.length;
    const prefix = sidebar.dataset.titlePrefix || 'Список';

    if (sidebarTitle) {
        sidebarTitle.textContent = `${prefix} (${visibleCount}/${totalCount})`;
    }
}


async function populateSidebarWithFoundObjects(features, objectType) {
    const sidebar = document.getElementById('parcel-results-sidebar');
    const contentDiv = document.getElementById('parcel-list-content');
    const sidebarTitle = document.getElementById('sidebar-title');
    const statsDiv = document.getElementById('sidebar-stats');
    const toggleBtn = document.getElementById('toggle-sidebar-btn');
    const filterInput = document.getElementById('filter-cadnum-input');
    const copyFilteredBtn = document.getElementById('copy-filtered-btn');
    const footer = sidebar ? sidebar.querySelector('.sidebar-footer') : null;

    if (!sidebar || !contentDiv || !sidebarTitle) {
        console.error("Элементы боковой панели не найдены");
        return;
    }
    
    // Очистка контента
    contentDiv.innerHTML = ''; 
    if (statsDiv) {
        statsDiv.innerHTML = '';
        statsDiv.style.display = 'none'; 
    }
    
    // Сброс поля фильтра
    if (filterInput) {
        filterInput.value = '';
    }

    const totalCount = features ? features.length : 0;
    
    // Сохраняем данные для заголовка
    sidebar.dataset.totalCount = totalCount;
    sidebar.dataset.titlePrefix = `Найденные ${objectType}`;
    sidebarTitle.textContent = `${sidebar.dataset.titlePrefix} (${totalCount})`;
    
    // Сообщение "нет результатов"
    let noResultsMsg = contentDiv.querySelector('.no-results-message');
    if (!noResultsMsg) {
        noResultsMsg = document.createElement('div');
        noResultsMsg.className = 'no-results-message';
        noResultsMsg.style.display = 'none';
        noResultsMsg.style.padding = '20px';
        noResultsMsg.style.textAlign = 'center';
        noResultsMsg.style.color = '#6b7280';
        contentDiv.appendChild(noResultsMsg);
    }

    if (features && features.length > 0) {
        noResultsMsg.style.display = 'none';
        
        features.forEach((feature, index) => {
            const properties = feature.properties || {};
            const options = properties.options || {};
            
            let cadNumber, primaryDesc, secondaryDesc, thirdDesc;

            // Логика отображения полей в зависимости от типа объекта
            if (objectType.startsWith('ЗУ')) {
                cadNumber = properties.descr || 'Без номера';
                primaryDesc = options.readable_address || 'Адрес не указан';
                secondaryDesc = (typeof getAreaText === 'function') ? getAreaText(options) : (options.area ? `${options.area} м²` : '');
                thirdDesc = null;
            } 
            else if (objectType.startsWith('Здания')) {
                cadNumber = options.cad_num || properties.descr || 'Без номера';
                primaryDesc = properties.descr || 'Тип не указан';
                secondaryDesc = options.readable_address || 'Адрес не указан';
                const areaValue = options.build_record_area;
                thirdDesc = (areaValue && isFinite(parseFloat(areaValue))) 
                    ? `Площадь: ${parseFloat(areaValue).toLocaleString('ru-RU')} м²` 
                    : 'Площадь не указана';
            } 
            else if (objectType.startsWith('Сооружения')) {
                cadNumber = options.cad_number || properties.descr || 'Без номера';
                primaryDesc = options.params_name || properties.descr || 'Тип не указан';
                secondaryDesc = options.address_readable_address || 'Адрес не указан';
                thirdDesc = options.params_extension ? `Протяженность: ${options.params_extension} м` : null;
            }
            else if (objectType.startsWith('ЗОУИТ')) {
                cadNumber = options.reg_numb_border || properties.descr || 'Без номера';
                primaryDesc = options.name_by_doc || 'Название не указано';
                secondaryDesc = options.content_restrict_encumbrances || 'Ограничения не указаны';
                thirdDesc = `Дата рег.: ${options.registration_date || 'не указана'}`;
            }
            else {
                cadNumber = options.cad_number || options.cad_num || properties.descr || 'Объект';
                primaryDesc = options.readable_address || options.name_by_doc || 'Описание отсутствует';
                secondaryDesc = '';
                thirdDesc = null;
            }
            
            const itemDiv = document.createElement('div');
            itemDiv.className = 'sidebar-item';
            // Сохраняем КН в data-атрибут (хотя фильтр теперь ищет по всему тексту)
            itemDiv.dataset.cadnum = cadNumber ? cadNumber.toLowerCase() : '';

            let html = `
                <p><strong>${index + 1}. ${cadNumber}</strong></p>
                <p style="color: #1e88e5;">${primaryDesc}</p> 
                <p>${secondaryDesc}</p>`;
            if (thirdDesc) {
                html += `<p style="font-size: 0.85em; color: #666;">${thirdDesc}</p>`;
            }
            itemDiv.innerHTML = html;

            // Привязка клика для зума на карте
            // Ищем полигон, соответствующий этому КН
            const correspondingPolygon = polygons.find(p => {
                if (!(p instanceof ymaps.Polygon)) return false;
                const pCadNum = p.properties?.get('cadastralNumber');
                return pCadNum && pCadNum === cadNumber;
            });

            if (correspondingPolygon) {
                itemDiv.addEventListener('dblclick', () => {
                    if (map) {
                        try {
                            const bounds = correspondingPolygon.geometry.getBounds();
                            map.setBounds(bounds, { checkZoomRange: true, duration: 500 });
                            // Эффект мигания
                            const oldFill = correspondingPolygon.options.get('fillColor');
                            correspondingPolygon.options.set('fillColor', '#FFFF0080'); // Желтый полупрозрачный
                            setTimeout(() => correspondingPolygon.options.set('fillColor', oldFill), 1000);
                        } catch(e) {}
                    }
                });
                itemDiv.style.cursor = "pointer";
                itemDiv.title = "Двойной клик - показать на карте";
            }
            
            contentDiv.appendChild(itemDiv);
        });
        
        // ВАЖНО: Принудительно показываем подвал с фильтром
        if (footer) footer.style.display = 'flex';

    } else {
        noResultsMsg.style.display = 'block';
        noResultsMsg.textContent = 'Объекты не найдены.';
        // Скрываем фильтр, если список пуст
        if (footer) footer.style.display = 'none';
    }

    sidebar.classList.remove('hidden', 'collapsed');
    if (toggleBtn) toggleBtn.innerHTML = '<i class="fas fa-chevron-right"></i>';
    isSidebarCollapsed = false;

    // ПРИВЯЗКА СОБЫТИЙ (самая надежная часть)
    if (filterInput) {
        // Используем oninput - это перезаписывает любой старый обработчик и гарантирует работу
        filterInput.oninput = filterParcelList;
        filterInput.focus(); // Фокус на поле ввода для удобства
    }
    
    if (copyFilteredBtn) {
        copyFilteredBtn.onclick = copyFilteredCadnums; // Тоже используем onclick для надежности
    }
}

async function createRasterOverlay(imageBlob) {
    return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = (event) => {
            const img = new Image();
            img.onload = () => {
                if (rasterOverlay) {
                    map.geoObjects.remove(rasterOverlay);
                }

                rasterImageSize = { width: img.width, height: img.height };
                const mapSize = map.container.getSize();
                const mapAspectRatio = mapSize[0] / mapSize[1];
                const imageAspectRatio = img.width / img.height;

                let overlayWidth, overlayHeight;
                if (mapAspectRatio > imageAspectRatio) {
                    overlayHeight = mapSize[1] * 0.8;
                    overlayWidth = overlayHeight * imageAspectRatio;
                } else {
                    overlayWidth = mapSize[0] * 0.8;
                    overlayHeight = overlayWidth / imageAspectRatio;
                }

                const center = map.getCenter();
                const projection = map.options.get('projection');
                const zoom = map.getZoom();
                const centerPixel = projection.toGlobalPixels(center, zoom);

                const halfWidthPixel = overlayWidth / 2;
                const halfHeightPixel = overlayHeight / 2;

                const topLeftPixel = [centerPixel[0] - halfWidthPixel, centerPixel[1] - halfHeightPixel];
                const bottomRightPixel = [centerPixel[0] + halfWidthPixel, centerPixel[1] + halfHeightPixel];

                const topLeftGeo = projection.fromGlobalPixels(topLeftPixel, zoom);
                const bottomRightGeo = projection.fromGlobalPixels(bottomRightPixel, zoom);

                const bounds = [topLeftGeo, bottomRightGeo];

                rasterOverlay = new ymaps.Rectangle(bounds, {}, {
                    fillImageHref: event.target.result,
                    fillMethod: 'stretch',
                    stroke: false,
                    opacity: 0.8,
                  interactivityModel: 'default#transparent',
zIndex: 400
                });

                map.geoObjects.add(rasterOverlay);
                resolve();
            };
            img.onerror = () => reject(new Error('Не удалось загрузить изображение.'));
            img.src = event.target.result;
        };
        reader.onerror = () => reject(new Error('Не удалось прочитать данные изображения.'));
        reader.readAsDataURL(imageBlob);
    });
}

// --- НАЧАЛО БЛОКА ФУНКЦИЙ ДЛЯ ОБРАБОТКИ ЕЗ ---

function delay(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
}

async function handleEzUpdateWorkflow() {
    const ezNumber = cityInput.value.trim();
    
    if (!isPotentialEzNumber(ezNumber)) {
        showNotification('Для обновления введите в поле поиска кадастровый номер ЕЗ.', 'warning', 7000);
        return;
    }

    showLoader('Сравнение архива с ЕГРН...');
    logMessage(`Запущена проверка актуальности для ЕЗ: ${ezNumber}`, 'info');

    try {
        const archivePromise = fetchZipFromLocalServer('EZ', ezNumber.replace(/:/g, '_') + '.nspd');
        const nspdPromise = getZuListForEzFromNspd(ezNumber);

        const [archiveBlob, nspdZuList] = await Promise.all([archivePromise, nspdPromise]);

        if (!nspdZuList) {
            throw new Error("Не удалось получить актуальный список обособленных участков (возможно не ЕЗ)");
        }

        let archiveZuList = [];
        let archiveDate = "неизвестна";
        if (archiveBlob) {
            const { features, date } = await loadAndParseZipBlob(archiveBlob);
            archiveZuList = features.map(f => f.properties.descr).filter(Boolean); // Добавлена фильтрация
            archiveDate = date || archiveDate;
            logMessage(`В архиве (от ${archiveDate}) найдено ${archiveZuList.length} участков.`, 'info');
        } else {
            logMessage('Локальный архив для этого ЕЗ не найден.', 'warning');
        }
        
        logMessage(`В ЕГРН найдено ${nspdZuList.length} участков.`, 'info');

        const countsAreEqual = archiveZuList.length === nspdZuList.length;
        let contentIsEqual = false;

        if (countsAreEqual && archiveZuList.length > 0) {
            const archiveSet = new Set(archiveZuList);
            const nspdSet = new Set(nspdZuList);
            contentIsEqual = [...archiveSet].every(value => nspdSet.has(value));
        }

        if (countsAreEqual && contentIsEqual) {
            logMessage('Данные в архиве актуальны. Загрузка из локального архива...', 'success');
            showNotification('Данные в архиве актуальны. Обновление не требуется.', 'success');
            if (archiveBlob) {
                const { features, date } = await loadAndParseZipBlob(archiveBlob);
                clearMapAndResetTheme();
                await processAndDrawParcels(features, 'quarter');
                populateSidebarWithParcels(features, date);
                document.getElementById('city-name-display').innerHTML = `ЕЗ (данные от ${date}):<br>${ezNumber}`;
            }
        } else {
            const today = new Date();
            const todayString = `${today.getFullYear()}-${String(today.getMonth() + 1).padStart(2, '0')}-${String(today.getDate()).padStart(2, '0')}`;

            if (archiveDate === todayString) {
                showNotification('Дата архива актуальная, обновление отменено', 'warning', 7000);
                logMessage('Архив уже обновлялся сегодня, но расхождение в данных сохраняется. Обновление отменено', 'warning');
                return;
            }

            hideLoader();
            const message = !countsAreEqual
                ? `Количество участков отличается (${archiveZuList.length} в архиве, ${nspdZuList.length} в ЕГРН).`
                : `Количество участков совпадает, но состав отличается.`;
            
            const confirmed = confirm(`${message}\n\nОбновить архив?`);
            
            if (confirmed) {
                logMessage('Пользователь подтвердил обновление. Запуск полной обработки...', 'info');
                await processEzFromNspdAndUpload(ezNumber);
            } else {
                logMessage('Обновление отменено пользователем.', 'info');
            }
        }
    } catch (error) {
        logMessage(`Ошибка в процессе обновления ЕЗ: ${error.message}`, 'error');
        showNotification(`Ошибка обновления: ${error.message}`, 'error');
    } finally {
        hideLoader();
    }
}

function logMessage(message, type = 'info') {
    const statusLog = document.getElementById('statusLog');
    if (!statusLog) {
        console.log(`[${type.toUpperCase()}] ${message}`);
        return;
    }
    const entry = document.createElement('div');
    entry.className = `log-entry log-${type}`;
    const timestamp = new Date().toLocaleTimeString();
    entry.textContent = `[${timestamp}] ${message}`;
    statusLog.appendChild(entry);
    statusLog.scrollTop = statusLog.scrollHeight;
}

async function fetchParcelDataForQuarter(quarterNumber) {
    try {
        const quarterGeomUrl = `https://nspd.gov.ru/api/geoportal/v2/search/geoportal?thematicSearchId=2&query=${quarterNumber}`;
        const quarterResponse = await fetch(quarterGeomUrl);
        if (!quarterResponse.ok) {
            throw new Error(`HTTP ${quarterResponse.status} при запросе геометрии`);
        }

        const quarterData = await quarterResponse.json();
        const quarterFeature = quarterData?.data?.features?.[0];
        if (!quarterFeature?.geometry) {
            throw new Error('Геометрия квартала не найдена.');
        }

        const requestBody = {
            "geom": { "type": "FeatureCollection", "features": [{ "type": "Feature", "geometry": quarterFeature.geometry, "properties": {} }] },
            "categories": [{ "id": 36368 }]
        };
        const parcelsUrl = 'https://nspd.gov.ru/api/geoportal/v1/intersects?typeIntersect=fullObject';
        const parcelsResponse = await fetch(parcelsUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(requestBody) });
        if (!parcelsResponse.ok) {
            throw new Error(`HTTP ${parcelsResponse.status} при запросе участков`);
        }

        const parcelsData = await parcelsResponse.json();
        return parcelsData.features || [];
    } catch (error) {
        logMessage(`Ошибка при полной загрузке квартала ${quarterNumber}: ${error.message}`, 'error');
        // Не логируем в консоль, так как logMessage уже это делает.
        return null; // Возвращаем null, чтобы вызывающая функция знала об ошибке.
    }
}

async function generateZipBlob(features, internalJsonFilename) {
    if (!features || features.length === 0) {
        throw new Error("Нет данных для создания ZIP-архива.");
    }
    const jsonData = JSON.stringify(features);
    const zip = new JSZip();
    zip.file(internalJsonFilename, jsonData);
    return await zip.generateAsync({
        type: "blob",
        compression: "DEFLATE",
        compressionOptions: {
            level: 9
        }
    });
}

function isPotentialEzNumber(cn) {
    if (!cn) return false;
    const pattern = /^\d{2}:\d{2}:0{6,7}:\d+$/;
    return pattern.test(cn.trim());
}

async function handleEzWorkflow(ezNumber) {
    showLoader(`Проверка типа объекта: ${ezNumber}...`);
    try {
        const initialFeature = await fetchCadastralData(ezNumber);
        const subtype = initialFeature?.properties?.options?.subtype || initialFeature?.properties?.options?.land_record_subtype;
        const isEzStructure = ["Единое землепользование", "Обособленный участок", "Условный участок"].includes(subtype);

        if (!isEzStructure) {
            await drawFeatureFromNspd(initialFeature);
            return;
        }

        logMessage(`Подтверждено: ${ezNumber} является частью структуры ЕЗ. Поиск в локальном архиве...`, 'success');
        showLoader(`Поиск в архиве: ${ezNumber}...`);

        const archiveFileName = ezNumber.replace(/:/g, '_') + '.nspd';
        const zipBlob = await fetchZipFromLocalServer('EZ', archiveFileName);

        if (zipBlob) {
            logMessage(`Локальный архив ${archiveFileName} найден.`, 'success');
            showLoader('Распаковка архива...');
            const { features, date } = await loadAndParseZipBlob(zipBlob);
            
            clearMapAndResetTheme();
            await processAndDrawParcels(features, 'quarter');
            populateSidebarWithParcels(features, date);
             document.getElementById('city-name-display').innerHTML = `ЕЗ (данные от ${date}):<br>${ezNumber}`;
            
            showNotification(`Данные ЕЗ ${ezNumber} загружены из архива от ${date}.`, 'success');
            return;
        }

    
        await processEzFromNspdAndUpload(ezNumber);

    } catch (error) {
        logMessage(`Критическая ошибка при обработке ЕЗ ${ezNumber}: ${error.message}`, 'error');
        showNotification(`Ошибка при обработке ЕЗ: ${error.message}`, 'error');
    } finally {
        hideLoader();
    }
}

async function processEzFromNspdAndUpload(ezNumber) {
    isEzProcessingAborted = false;

    const loaderContainer = document.getElementById('loaderContainer');
    let cancelButton = null;

    try {
        showLoader(`Запрос состава ЕЗ: ${ezNumber}...`);
        const zuList = await getZuListForEzFromNspd(ezNumber);

        if (!zuList) {
            throw new Error("Не удалось получить список входящих участков.");
        }

        const quartersGrouped = groupZusByQuarter(zuList);
        const quarterQueue = Array.from(quartersGrouped.keys()).sort();

        if (quarterQueue.length === 0) {
            showNotification("В составе ЕЗ не найдено участков с корректными номерами кварталов.", "warning");
            return;
        }

        let totalRequests = 0;
        quartersGrouped.forEach(zusInQuarter => {
            totalRequests += (zusInQuarter.length > 5) ? 1 : zusInQuarter.length;
        });

        if (totalRequests > 30) {
            hideLoader();
            const confirmed = confirm(`ЕЗ имеет большое количество участков (${totalRequests} запросов). Загрузка в архив будет выполнена один раз. Продолжить?`);
            if (!confirmed) {
                showNotification('Загрузка отменена пользователем.', 'info');
                return;
            }
        }

        cancelButton = document.createElement('button');
        cancelButton.textContent = 'Отменить';
        Object.assign(cancelButton.style, {
            marginTop: '20px',
            padding: '8px 16px',
            border: 'none',
            borderRadius: '5px',
            backgroundColor: '#dc3545',
            color: 'white',
            cursor: 'pointer',
            fontSize: '14px'
        });
        cancelButton.onclick = () => {
            isEzProcessingAborted = true;
            showNotification('Отмена операции...', 'warning');
            if (cancelButton) cancelButton.disabled = true;
        };
        if (loaderContainer) {
            loaderContainer.appendChild(cancelButton);
        }

        let aggregatedParcels = [];
        let requestCounter = 0;

        for (const quarter of quarterQueue) {
            if (isEzProcessingAborted) break;

            const zusInQuarter = quartersGrouped.get(quarter);
            const parcelCount = zusInQuarter.length;

            if (parcelCount > 5) {
                requestCounter++;
                showLoader(`Обработка ${requestCounter}/${totalRequests}: ${quarter}`);
                const allParcelsInQuarter = await fetchParcelDataForQuarter(quarter);
                if (allParcelsInQuarter) {
                    const targetZuSet = new Set(zusInQuarter);
                    const filteredParcels = allParcelsInQuarter.filter(f => targetZuSet.has(f.properties?.descr));
                    aggregatedParcels.push(...filteredParcels);
                }
            } else {
                for (const zu of zusInQuarter) {
                    if (isEzProcessingAborted) break;
                    requestCounter++;
                    showLoader(`Обработка ${requestCounter}/${totalRequests}: ${zu}`);
                    const parcelFeature = await fetchSingleParcelData(zu);
                    if (parcelFeature) {
                        aggregatedParcels.push(parcelFeature);
                    }
                    await delay(1000);
                }
            }
            if (!isEzProcessingAborted) await delay(2000);
        }

        if (isEzProcessingAborted) {
            showNotification('Загрузка данных была отменена.', 'info');
            return;
        }

        if (aggregatedParcels.length > 0) {
            showLoader('Создание архива...');
            const ezNameSafe = ezNumber.replace(/:/g, '_');
            const today = new Date();
            const dateString = `${today.getFullYear()}-${String(today.getMonth() + 1).padStart(2, '0')}-${String(today.getDate()).padStart(2, '0')}`;
            const zipFilename = `${ezNameSafe}.nspd`;
            const internalJsonFilename = `${ezNameSafe} ${dateString}.json`;

            const zipBlob = await generateZipBlob(aggregatedParcels, internalJsonFilename);
            
            showLoader('Загрузка архива на сервер...');
            await uploadEzFileToServer(zipBlob, zipFilename);
            
            clearMapAndResetTheme();
            await processAndDrawParcels(aggregatedParcels, 'quarter');
            populateSidebarWithParcels(aggregatedParcels, dateString);
            document.getElementById('city-name-display').innerHTML = `ЕЗ (Данные от ${dateString}):<br>${ezNumber}`;
            showNotification(`Обработка ЕЗ завершена. Найдено ${aggregatedParcels.length} участков.`, 'success');
        } else {
            showNotification('Не удалось загрузить данные для участков ЕЗ.', 'warning');
        }

    } finally {
        if (cancelButton && cancelButton.parentNode) {
            cancelButton.parentNode.removeChild(cancelButton);
        }
        hideLoader();
    }
}

async function getZuListForEzFromNspd(ezNumber) {
    try {
        const searchUrl = `https://nspd.gov.ru/api/geoportal/v2/search/geoportal?query=${encodeURIComponent(ezNumber)}&thematicSearchId=1`;
        const searchResponse = await fetch(searchUrl);
        if (!searchResponse.ok) throw new Error(`Ошибка ${searchResponse.status} при поиске объекта ЕЗ`);
        
        const searchData = await searchResponse.json();
        const feature = searchData?.data?.features?.[0];
        if (!feature) throw new Error('Объект ЕЗ не найден в НСПД.');
        
        const objdocId = feature.id;
        const registersId = feature.properties?.options?.registersId;
        if (!objdocId || !registersId) throw new Error('Не удалось получить ID для запроса состава ЕЗ.');
        
        const compositionUrl = `https://nspd.gov.ru/api/geoportal/v1/tab-values-data?tabClass=compositionLand&objdocId=${objdocId}&registersId=${registersId}`;
        const compositionResponse = await fetch(compositionUrl);
        if (!compositionResponse.ok) throw new Error(`Ошибка ${compositionResponse.status} при запросе состава ЕЗ`);

        const compositionData = await compositionResponse.json();
        const zuList = compositionData?.value;
        if (!zuList || !Array.isArray(zuList) || zuList.length === 0) {
             throw new Error('Не удалось получить список участков (пустой ответ).');
        }
        return zuList;
    } catch(error) {
        logMessage(`NSPDRU: ${error.message}`, 'error');
        return null;
    }
}

function groupZusByQuarter(zuList) {
    const groups = new Map();
    zuList.forEach(zu => {
        const parts = zu.split(':');
        if (parts.length >= 3) {
            const quarter = parts.slice(0, 3).join(':');
            if (!groups.has(quarter)) {
                groups.set(quarter, []);
            }
            groups.get(quarter).push(zu);
        }
    });
    return groups;
}

async function uploadEzFileToServer(zipBlob, zipFilename) {
    const UPLOAD_URL = 'https://mapruapp.ru/storage/EZ/upload';
    logMessage(`Загрузка архива ${zipFilename} в папку EZ...`, 'info');
    try {
        const formData = new FormData();
        formData.append('file', new File([zipBlob], zipFilename, { type: 'application/zip' }));
        
        const response = await fetch(UPLOAD_URL, {
            method: 'POST',
            body: formData,
        });

        if (!response.ok) {
            const errorData = await response.json().catch(() => ({ error: `Сервер ответил ошибкой: ${response.statusText}` }));
            throw new Error(errorData.error);
        }
        
        logMessage(`Архив ${zipFilename} успешно загружен в папку EZ!`, 'success');
    } catch (error) {
        logMessage(`Ошибка загрузки архива в папку EZ: ${error.message}`, 'error');
    }
}

async function fetchSingleParcelData(cadastralNumber) {
    try {
        const url = `https://nspd.gov.ru/api/geoportal/v2/search/geoportal?query=${encodeURIComponent(cadastralNumber)}&thematicSearchId=1`;
        const response = await fetch(url);
        if (!response.ok) throw new Error(`HTTP ${response.status}`);

        const data = await response.json();
        const feature = data?.data?.features?.[0];
        if (!feature) throw new Error('Объект не найден в ответе.');
        
        return feature;
    } catch (error) {
        logMessage(`NSPDRU: Ошибка при загрузке участка ${cadastralNumber}: ${error.message}`, 'error');
        return null;
    }
}

// --- КОНЕЦ БЛОКА ФУНКЦИЙ ДЛЯ ОБРАБОТКИ ЕЗ ---

function disableMapInteractivity() {
    if (!map) return;
    
    // Принудительно закрываем любую открытую подсказку или балун.
    if (map.hints) map.hints.close(true);
    if (map.balloon) map.balloon.close();
    console.log("Принудительно закрыты все активные подсказки и балуны.");

    let processedCount = 0;
    map.geoObjects.each(function(geoObject) {
        if (geoObject.options) {
            // Сохраняем исходную модель интерактивности, чтобы потом ее восстановить.
            // Если она не была задана, по умолчанию используется 'default#geoObject'.
            geoObject.originalInteractivityModel = geoObject.options.get('interactivityModel', 'default#geoObject');
            
            // Устанавливаем "тихую" модель. Объект перестает реагировать на любые события мыши.
            geoObject.options.set('interactivityModel', 'default#silent');
            processedCount++;
        }
    });
    console.log(`Интерактивность отключена для ${processedCount} объектов на время работы с растром.`);
}

/**
 * Восстанавливает исходную интерактивность для всех объектов на карте.
 */
function restoreMapInteractivity() {
    if (!map) return;

    let processedCount = 0;
    map.geoObjects.each(function(geoObject) {
        if (geoObject.options && typeof geoObject.originalInteractivityModel !== 'undefined') {
            // Восстанавливаем сохраненную модель интерактивности.
            geoObject.options.set('interactivityModel', geoObject.originalInteractivityModel);
            
            // Удаляем временное свойство, чтобы не мешать в будущем.
            delete geoObject.originalInteractivityModel;
            processedCount++;
        }
    });
    console.log(`Интерактивность восстановлена для ${processedCount} объектов.`);
}

function createRasterControls() {
        disableMapInteractivity();
    rasterControlsPanel = document.createElement('div');
    rasterControlsPanel.className = 'raster-controls-panel';
    
    rasterControlsPanel.innerHTML = `
        <h4>Растр</h4>
        <button class="close-btn" title="Удалить растр">&times;</button>
        <div class="control-group">
            <div></div><button id="raster-up"><i class="fas fa-arrow-up"></i></button><div></div>
        </div>
        <div class="control-group">
            <button id="raster-left"><i class="fas fa-arrow-left"></i></button>
            <button id="raster-bind-btn" title="Привязка по двум точкам"><i class="fas fa-map-pin"></i></button>
            <button id="raster-right"><i class="fas fa-arrow-right"></i></button>
        </div>
        <div class="control-group">
            <div></div><button id="raster-down"><i class="fas fa-arrow-down"></i></button><div></div>
        </div>
        <div class="control-group" style="justify-content: space-evenly; margin-top: 5px;">
            <button id="raster-export-file-btn" title="Экспорт в файл"><i class="fas fa-download"></i></button>
            <button id="raster-import-file-btn" title="Импорт из файла"><i class="fas fa-upload"></i></button>
            <button id="raster-paste-btn" title="Вставить из буфера обмена"><i class="fas fa-paste"></i></button>
        </div>
        <div class="control-group" style="justify-content: space-evenly; margin-top: 5px;">
             <button id="raster-export-cloud-btn" title="Экспорт в облако"><i class="fas fa-cloud-upload-alt"></i></button>
             <button id="raster-import-cloud-btn" title="Импорт из облака"><i class="fas fa-cloud-download-alt"></i></button>
        </div>
        <input type="range" id="raster-zoom" min="10" max="500" value="100" title="Масштаб">
        <label for="raster-opacity" style="font-size: 0.9em; text-align: center; margin-top: 5px; display: block;">Растр</label>
        <input type="range" id="raster-opacity" min="0" max="1" step="0.05" value="0.8" title="Прозрачность растра">
        
        <!-- ИЗМЕНЕННЫЙ СТАРЫЙ СЛАЙДЕР -->
        <label for="manual-contour-opacity" style="font-size: 0.9em; text-align: center; margin-top: 5px; display: block;">Контуры (созданные)</label>
        <input type="range" id="manual-contour-opacity" min="0" max="1" step="0.05" value="0.8" title="Прозрачность созданных контуров">

        <!-- НОВЫЙ СЛАЙДЕР -->
        <label for="loaded-contour-opacity" style="font-size: 0.9em; text-align: center; margin-top: 5px; display: block;">Контуры (загруженные)</label>
        <input type="range" id="loaded-contour-opacity" min="0" max="1" step="0.05" value="0.8" title="Прозрачность загруженных контуров">
    `;
    document.body.appendChild(rasterControlsPanel);

    // --- ОБНОВЛЕННАЯ ЛОГИКА ОБРАБОТЧИКОВ ---

    // Установка начальных значений слайдеров
    rasterControlsPanel.querySelector('#manual-contour-opacity').value = manualObjectOpacity;
    rasterControlsPanel.querySelector('#loaded-contour-opacity').value = loadedObjectOpacity;

    // Обработчик для слайдера созданных контуров
    rasterControlsPanel.querySelector('#manual-contour-opacity').addEventListener('input', (e) => { 
        e.stopPropagation(); 
        setManualObjectOpacity(parseFloat(e.target.value)); 
    });
    
    // Обработчик для НОВОГО слайдера загруженных контуров
    rasterControlsPanel.querySelector('#loaded-contour-opacity').addEventListener('input', (e) => { 
        e.stopPropagation(); 
        setLoadedObjectOpacity(parseFloat(e.target.value)); 
    });

    // Остальные обработчики без изменений
    rasterControlsPanel.querySelector('#raster-up').addEventListener('click', (e) => { e.stopPropagation(); moveRaster(0, -1); });
    rasterControlsPanel.querySelector('#raster-down').addEventListener('click', (e) => { e.stopPropagation(); moveRaster(0, 1); });
    rasterControlsPanel.querySelector('#raster-left').addEventListener('click', (e) => { e.stopPropagation(); moveRaster(-1, 0); });
    rasterControlsPanel.querySelector('#raster-right').addEventListener('click', (e) => { e.stopPropagation(); moveRaster(1, 0); });
    rasterControlsPanel.querySelector('#raster-zoom').addEventListener('input', (e) => { e.stopPropagation(); zoomRaster(parseFloat(e.target.value) / 100); });
    rasterControlsPanel.querySelector('#raster-opacity').addEventListener('input', (e) => { e.stopPropagation(); if (rasterOverlay) rasterOverlay.options.set('opacity', parseFloat(e.target.value)); });
    
    rasterControlsPanel.querySelector('.close-btn').addEventListener('click', (e) => {
        e.stopPropagation();
        if (rasterOverlay) map.geoObjects.remove(rasterOverlay);
        if (rasterControlsPanel) document.body.removeChild(rasterControlsPanel);
        rasterOverlay = null;
        rasterControlsPanel = null;
           restoreMapInteractivity();
    });
    
    rasterControlsPanel.querySelector('#raster-bind-btn').addEventListener('click', (e) => { e.stopPropagation(); startBindingProcess(); });
    rasterControlsPanel.querySelector('#raster-export-file-btn').addEventListener('click', (e) => { e.stopPropagation(); exportRasterSettingsToFile(); });
    rasterControlsPanel.querySelector('#raster-import-file-btn').addEventListener('click', (e) => { e.stopPropagation(); importRasterSettingsFromFile(); });
    rasterControlsPanel.querySelector('#raster-paste-btn').addEventListener('click', (e) => { e.stopPropagation(); pasteRasterFromClipboard(); });
    rasterControlsPanel.querySelector('#raster-export-cloud-btn').addEventListener('click', (e) => { e.stopPropagation(); exportRasterToCloud(); });
    rasterControlsPanel.querySelector('#raster-import-cloud-btn').addEventListener('click', (e) => { e.stopPropagation(); importRasterFromCloud(); });

    // Логика перетаскивания панели
    let isDraggingPanel = false;
    let panelDragStartX, panelDragStartY;
    rasterControlsPanel.addEventListener('mousedown', (e) => {
        if (e.target.tagName === 'BUTTON' || e.target.tagName === 'INPUT' || e.target.tagName === 'I') return;
        isDraggingPanel = true;
        panelDragStartX = e.clientX - rasterControlsPanel.offsetLeft;
        panelDragStartY = e.clientY - rasterControlsPanel.offsetTop;
    });
    document.addEventListener('mousemove', (e) => {
        if (!isDraggingPanel) return;
        rasterControlsPanel.style.left = `${e.clientX - panelDragStartX}px`;
        rasterControlsPanel.style.top = `${e.clientY - panelDragStartY}px`;
    });
    document.addEventListener('mouseup', () => { isDraggingPanel = false; });
}


function moveRaster(dx, dy) {
    if (!rasterOverlay) return;
    const moveStep = 2; // Шаг перемещения в пикселях
    const projection = map.options.get('projection');
    const zoom = map.getZoom();
    
    // 1. Надежно получаем все 4 текущих угла в гео-координатах
    const currentCornersGeo = getRasterCorners(); 
    if (!currentCornersGeo) {
        console.error("Не удалось получить углы растра для перемещения.");
        return;
    }

    // 2. Конвертируем все 4 угла в пиксели и применяем смещение
    const newCornersPixel = currentCornersGeo.map(geoCoord => {
        const pixelCoord = projection.toGlobalPixels(geoCoord, zoom);
        return [pixelCoord[0] + dx * moveStep, pixelCoord[1] + dy * moveStep];
    });

    // 3. Конвертируем новые пиксельные координаты обратно в гео
    const newCornersGeo = newCornersPixel.map(pixelCoord => {
        return projection.fromGlobalPixels(pixelCoord, zoom);
    });

    // 4. Заменяем старый растр на новый с обновленными координатами
    // Этот подход работает как для прямоугольников, так и для полигонов.
    const newOverlay = new ymaps.Polygon([newCornersGeo], {}, {
        fillImageHref: rasterOverlay.options.get('fillImageHref'),
        fillMethod: 'stretch',
        stroke: false,
        opacity: rasterOverlay.options.get('opacity'),
      interactivityModel: 'default#transparent',
zIndex: 400
    });
    
    map.geoObjects.remove(rasterOverlay);
    rasterOverlay = newOverlay;
    map.geoObjects.add(rasterOverlay);
}

// --- НОВОЕ: Функция масштабирования растра ---
function zoomRaster(scale) {
    if (!rasterOverlay) return;
    const projection = map.options.get('projection');
    const zoom = map.getZoom();
    const bounds = rasterOverlay.geometry.getBounds(); // <<< ИСПРАВЛЕНО: Используем универсальный getBounds()

    // <<< НАЧАЛО КЛЮЧЕВОГО ИСПРАВЛЕНИЯ >>>
    // Корректно определяем углы из результата getBounds() [[minLat, minLon], [maxLat, maxLon]]
    const minLat = bounds[0][0], minLon = bounds[0][1];
    const maxLat = bounds[1][0], maxLon = bounds[1][1];
    
    // Собираем нужные нам углы для расчетов
    const topLeftGeo = [maxLat, minLon];     // Верхний-левый
    const bottomRightGeo = [minLat, maxLon]; // Нижний-правый
    // <<< КОНЕЦ КЛЮЧЕВОГО ИСПРАВЛЕНИЯ >>>

    const topLeftPixel = projection.toGlobalPixels(topLeftGeo, zoom);
    const bottomRightPixel = projection.toGlobalPixels(bottomRightGeo, zoom);

    const centerPixelX = (topLeftPixel[0] + bottomRightPixel[0]) / 2;
    const centerPixelY = (topLeftPixel[1] + bottomRightPixel[1]) / 2;

    const mapSize = map.container.getSize();
    const mapAspectRatio = mapSize[0] / mapSize[1];
    const imageAspectRatio = rasterImageSize.width / rasterImageSize.height;

    let baseSize;
    if(mapAspectRatio > imageAspectRatio) {
        baseSize = mapSize[1] * 0.8;
    } else {
        baseSize = mapSize[0] * 0.8;
    }

    const newWidth = (baseSize * imageAspectRatio) * scale;
    const newHeight = baseSize * scale;

    const newTopLeftPixel = [centerPixelX - newWidth / 2, centerPixelY - newHeight / 2];
    const newBottomRightPixel = [centerPixelX + newWidth / 2, centerPixelY + newHeight / 2];

    const newTopLeftGeo = projection.fromGlobalPixels(newTopLeftPixel, zoom);
    const newBottomRightGeo = projection.fromGlobalPixels(newBottomRightPixel, zoom);

    // Важно: так как после импорта или привязки растр становится полигоном,
    // мы не можем просто изменить его bounds. Нужно пересоздать полигон.
    const newCornersGeo = [
        newTopLeftGeo, // Верхний-левый
        [newTopLeftGeo[0], newBottomRightGeo[1]], // Верхний-правый
        newBottomRightGeo, // Нижний-правый
        [newBottomRightGeo[0], newTopLeftGeo[1]]  // Нижний-левый
    ];

    // Создаем новый полигон с новыми координатами
    const newPolygonOverlay = new ymaps.Polygon([newCornersGeo], {}, {
        fillImageHref: rasterOverlay.options.get('fillImageHref'),
        fillMethod: 'stretch',
        stroke: false,
        opacity: rasterOverlay.options.get('opacity'),
     interactivityModel: 'default#transparent',
zIndex: 400
    });
    
    // Заменяем старый оверлей новым
    map.geoObjects.remove(rasterOverlay);
    rasterOverlay = newPolygonOverlay;
    map.geoObjects.add(rasterOverlay);
}


function copyFilteredCadnums() {
    const contentDiv = document.getElementById('parcel-list-content');
    if (!contentDiv) return;

    const visibleItems = contentDiv.querySelectorAll('.sidebar-item:not(.filtered-out)');
    if (visibleItems.length === 0) {
        showNotification('Нет видимых участков для копирования', 'warning', 'exclamation-triangle');
        return;
    }

    const textToCopy = Array.from(visibleItems)
        .map(item => {
            const pTags = item.querySelectorAll('p');

            // 1. Кадастровый номер (без порядкового номера)
            const fullCadNumberText = pTags[0]?.textContent.trim() || '';
            const cadNumberText = fullCadNumberText.replace(/^\d+\.\s*/, '');

            // 2. Адрес
            const addressText = pTags[1]?.textContent.trim() || '';

            // --- НАЧАЛО ИЗМЕНЕНИЙ ДЛЯ ПЛОЩАДИ ---
            const areaRawText = pTags[2]?.textContent.trim() || '';
            let areaValue = '';
            let areaType = '';

            // Регулярное выражение для разбора строки типа "22 838 м² (уточненная)"
            // Оно захватывает (1) числовую часть и (2) текст в скобках.
            const areaRegex = /^([\d\s ]+)\s*м²\s*\((.*?)\)$/;
            const match = areaRawText.match(areaRegex);

            if (match) {
                // match[1] - это числовая часть, например "22 838". Убираем из нее пробелы.
                areaValue = match[1].replace(/[\s ]/g, '');
                // match[2] - это тип, например "уточненная".
                areaType = match[2];
            } else {
                // Если формат не совпал (например, "площадь не указана"),
                // оставляем значение площади пустым, чтобы не ломать колонки.
                areaValue = areaRawText.includes('не указана') ? '' : areaRawText;
            }
            // --- КОНЕЦ ИЗМЕНЕНИЙ ДЛЯ ПЛОЩАДИ ---

            // 4. Единое землепользование
            const uluElement = item.querySelector('.ulu-info-sidebar');
            const uluText = uluElement 
                ? uluElement.textContent.replace('Единое землепользование:', '').replace(/\s+/g, ' ').trim() 
                : '';

            // Собираем итоговую строку с 5 колонками
            return [cadNumberText, addressText, areaValue, areaType, uluText].join('\t');
        })
        .join('\n');

    navigator.clipboard.writeText(textToCopy)
        .then(() => {
            showNotification(`Скопировано ${visibleItems.length} записей`, 'success', 'check-circle');
        })
        .catch(err => {
            console.error('Ошибка при копировании отфильтрованных данных:', err);
            showNotification('Ошибка при копировании', 'error', 'exclamation-circle');
        });
}








        </script>
</body>

</html>