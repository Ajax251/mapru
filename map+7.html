<!DOCTYPE html>
<html lang="ru">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Карта</title>

    <link id="favicon" rel="icon" href="img/map.png"   type="image/png">

   <link rel="stylesheet" href="webfonts/all.min.css" />
    <script src="webfonts/proj4.js"></script>
       <script src="webfonts/xlsx.full.min.js"></script>
       <script src="webfonts/jszip.min.js"></script>
       <script src="webfonts/html2canvas.min.js"></script>
<script src="webfonts/FileSaver.min.js"></script>
    <script src="webfonts/supabase-js@2.js"></script>
 <style>
    body {
        margin: 0;
        overflow: hidden;
        font-family: sans-serif;
        display: flex;
        height: 100vh;
    }

    #map {
        flex-grow: 1;
        z-index: 1;
        transition: opacity 0.5s ease;
        border: 3px solid rgba(110, 142, 251, 0.8);
        border-radius: 12px;
        overflow: hidden;
        box-sizing: border-box;
        box-shadow: 0 0 10px rgba(110, 142, 251, 0.5);
        min-height: 200px;
        position: relative;
        cursor: default !important;
    }

    /* Enhanced widget appearance */
    .widget {
        background: linear-gradient(135deg, #3B82F6, #60A5FA, #1E3A8A);
        padding: 12px;
        box-shadow: 0 6px 20px rgba(0, 0, 0, 0.2), 0 0 25px rgba(59, 130, 246, 0.3);
        color: #F9FAFB;
        z-index: 10;
        display: flex;
        flex-direction: column;
        border-radius: 12px;
        transition: transform 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275), 
                    opacity 0.3s ease, 
                    box-shadow 0.4s ease;
        box-sizing: border-box;
        max-height: 90vh;
        width: 350px;
        cursor: default; /* Обычный курсор по умолчанию */
        border: 2px solid rgba(96, 165, 250, 0.8);
        backdrop-filter: blur(5px);
        animation: widgetAppear 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards;
    }

    .widget:hover {
        box-shadow: 0 12px 24px rgba(0, 0, 0, 0.25), 0 0 30px rgba(59, 130, 246, 0.4);
        transform: translateY(-4px) scale(1.02);
    }

    .widget.hidden {
        opacity: 0;
    }

    .widget-desktop,
    .widget-mobile {
        position: absolute;
        left: 10px;
        top: 10px;
        border-radius: 15px;
    }

    /* Enhanced city input */
    .input-container {
        position: relative;
        width: 100%;
        margin-top: 8px;
    }

    #city-input {
        margin-top: 0;
        padding: 8px 30px;
        border: 1px solid rgba(255, 255, 255, 0.25);
        border-radius: 10px;
        width: calc(100% - 60px);
        text-align: center;
        color: #1E3A8A;
        background-color: rgba(255, 255, 255, 0.95);
        font-size: 0.9rem;
        outline: none;
        transition: all 0.3s ease;
        box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.05), 0 0 5px rgba(96, 165, 250, 0.2);
    }

    #city-input::placeholder {
        color: #666;
    }

    #city-input:focus {
        border-color: #60A5FA;
        box-shadow: 0 0 10px rgba(96, 165, 250, 0.5), inset 0 1px 5px rgba(0, 0, 0, 0.05);
        transform: translateY(-2px);
    }

    /* Make city-name-display non-selectable like an image */
    .city-name {
        font-size: 1.1rem;
        color: #F9FAFB;
        font-weight: 600;
        text-decoration: none;
        word-wrap: break-word;
        white-space: normal;
        line-height: 1.3;
        text-align: center;
        text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        user-select: none;
        -webkit-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
        cursor: default; /* Обычный курсор по умолчанию */
        position: relative;
        padding: 5px 0;
        transition: color 0.3s ease, text-shadow 0.3s ease;
    }

    .city-name::after {
        content: '';
        position: absolute;
        bottom: 0;
        left: 50%;
        width: 0;
        height: 2px;
        background: rgba(255, 255, 255, 0.7);
        transition: width 0.3s ease, left 0.3s ease;
    }

    .city-name:hover {
        color: #ffffff;
        text-shadow: 0 2px 8px rgba(255, 255, 255, 0.5);
    }

    .city-name:hover::after {
        width: 80%;
        left: 10%;
    }

    /* Enhanced date-time */
    .date-time {
        margin: 8px 0;
        font-size: 0.9rem;
        font-weight: 500;
        text-align: center;
        text-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);
        position: relative;
        overflow: hidden;
        transition: all 0.3s ease;
    }

    .date-time::before {
        content: '';
        position: absolute;
        left: 0;
        bottom: -2px;
        width: 100%;
        height: 1px;
        background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.5), transparent);
        transform: translateX(-100%);
        transition: transform 0.5s ease;
    }

    .widget:hover .date-time::before {
        transform: translateX(100%);
    }

    .map-mode-switcher {
        margin-top: auto;
        padding-top: 5px;
        display: flex;
        gap: 3px;
        justify-content: center;
        width: 100%;
        flex-wrap: wrap;
    }

    /* Enhanced buttons */
    .map-mode-button, .convert-button, #add-text-button {
        padding: 6px;
        border: none;
        border-radius: 50%;
        background-color: rgba(255, 255, 255, 0.15);
        color: #F9FAFB;
        font-size: 0.9rem;
        cursor: pointer;
        transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        display: flex;
        align-items: center;
        justify-content: center;
        width: 32px;
        height: 32px;
        position: relative;
        overflow: hidden;
    }

    .map-mode-button::before, .convert-button::before, #add-text-button::before {
        content: '';
        position: absolute;
        top: 50%;
        left: 50%;
        width: 0;
        height: 0;
        background-color: rgba(255, 255, 255, 0.2);
        border-radius: 50%;
        transform: translate(-50%, -50%);
        transition: width 0.4s ease, height 0.4s ease;
    }

    .map-mode-button:hover, .convert-button:hover, #add-text-button:hover {
        background-color: rgba(255, 255, 255, 0.25);
        transform: scale(1.2) rotate(5deg);
        box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2), 0 0 15px rgba(96, 165, 250, 0.4);
    }

    .map-mode-button:hover::before, .convert-button:hover::before, #add-text-button:hover::before {
        width: 150%;
        height: 150%;
    }


    .map-mode-button i, .convert-button i, #add-text-button i {
        position: relative;
        z-index: 2;
        transition: all 0.3s ease;
    }

    .map-mode-button:hover i, .convert-button:hover i, #add-text-button:hover i {
        transform: scale(1.2);
        color: #ffffff;
        text-shadow: 0 0 10px rgba(255, 255, 255, 0.7);
    }

    .coords-input,
    .result-textarea {
        margin-top: 3px;
        width: calc(100% - 12px);
        height: 50px;
        padding: 5px;
        border: 1px solid rgba(255, 255, 255, 0.3);
        border-radius: 4px;
        background-color: rgba(255, 255, 255, 0.9);
        color: #333;
        font-family: monospace;
        resize: none;
        white-space: pre;
        overflow-x: auto;
        display: none;
        font-size: 0.8rem;
    }

    .coords-input::placeholder {
        color: #666;
    }

    .convert-buttons {
        margin-top: 3px;
        display: flex;
        gap: 3px;
        justify-content: center;
    }

    .style-modal {
        display: none;
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        z-index: 1000;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.5);
        overflow: auto;
    }

    .style-modal-content {
        background: linear-gradient(135deg, #7f7fd5, #86a8e7, #2D68C4);
        margin: 20px auto;
        padding: 15px;
        border-radius: 8px;
        width: 90%;
        max-width: 300px;
        color: white;
        position: relative;
    }

    .style-setting {
        margin: 8px 0;
        display: flex;
        align-items: center;
        gap: 3px;
    }

    .style-setting label {
        font-size: 0.8rem;
    }

    .style-setting input[type="color"] {
        width: 30px;
        height: 20px;
        border: none;
        border-radius: 4px;
    }

    .style-setting input[type="range"] {
        flex: 1;
    }

    .convert-button i {
        margin-right: 3px;
    }

    .custom-context-menu {
        position: absolute;
        background: white;
        border-radius: 8px;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
        padding: 5px 0;
        min-width: 150px;
        z-index: 1000;
        display: none;
    }

    .custom-context-menu-item {
        padding: 8px 15px;
        cursor: pointer;
        transition: background-color 0.2s;
        color: #333;
        font-size: 14px;
        display: flex;
        align-items: center;
        position: relative;
    }

    .custom-context-menu-item i {
        margin-right: 8px;
        color: #4a6cf7;
    }

    .custom-context-menu-item:hover {
        background-color: #f0f0f0;
    }

    .custom-context-submenu {
        display: none;
        position: absolute;
        left: 100%;
        top: 0;
        background: white;
        border-radius: 8px;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
        padding: 5px 0;
        min-width: 150px;
    }

    .custom-context-menu-item:hover > .custom-context-submenu {
        display: block;
    }

    .notification {
        position: fixed;
        bottom: 20px;
        right: 20px;
        padding: 15px 25px;
        color: white;
        border-radius: 8px;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        opacity: 0;
        transform: translateY(20px);
        transition: opacity 0.3s, transform 0.3s;
        z-index: 9999;
        font-size: 14px;
        display: flex;
        align-items: center;
        gap: 10px;
    }

    .notification.success {
        background: linear-gradient(135deg, #43cea2, #185a9d);
    }

    .notification.error {
        background: linear-gradient(135deg, #ff6b6b, #ff3d3d);
    }

    .notification.show {
        opacity: 1;
        transform: translateY(0);
    }

    .notification i {
        font-size: 16px;
    }

    @media (max-width: 768px) {
        body {
            flex-direction: column;
        }

        .widget {
            width: 230px;
        }

        .widget-desktop,
        .widget-mobile {
            position: absolute;
            width: 230px;
        }

        .style-modal-content {
            margin: 30% auto;
        }
    }

    @media (min-width: 769px) {
        body {
            flex-direction: row;
        }

        #map {
            flex-grow: 1;
        }
    }

    .hidden {
        transform: translateY(100%);
        opacity: 0;
        transition: transform 0.3s ease, opacity 0.3s ease;
    }

    .widget-mobile.hidden {
        transform: translateY(100%);
        opacity: 0;
    }

    .widget-desktop.hidden {
        transform: translateX(-100%);
        opacity: 0;
    }

    .draggable-text {
        position: absolute;
        z-index: 1000;
        background-color: rgba(255, 255, 255, 0.9);
        padding: 5px;
        border: 1px solid #ccc;
        border-radius: 2px;
        cursor: move;
        user-select: none;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    }

    .draggable-text span {
        font-size: 16px;
    }

    .draggable-text button {
        margin-left: 5px;
        padding: 2px 5px;
        font-size: 12px;
        cursor: pointer;
        display: none;
    }

    .draggable-text.active button {
        display: inline-block;
    }

    .search-icon, .history-icon {
        position: absolute;
        top: 50%;
        transform: translateY(-50%);
        width: 20px;
        height: 20px;
        cursor: pointer;
        opacity: 0.7;
        transition: all 0.3s ease;
        z-index: 11;
    }

    .search-icon {
        right: 8px;
    }

    .history-icon {
        left: 8px;
    }

    .search-icon:hover, .history-icon:hover {
        opacity: 1;
        transform: translateY(-50%) scale(1.2);
        filter: drop-shadow(0 0 3px rgba(255, 255, 255, 0.5));
    }

    .widget i {
        transition: color 0.3s ease, transform 0.2s ease;
    }

    .widget i:hover {
        transform: scale(1.1);
    }

    .widget .city-name,
    .widget .date-time {
        transition: color 0.3s ease;
    }

    #history-modal {
        display: none;
        position: absolute;
        top: 45px;
        left: 10px;
        background: linear-gradient(135deg, #7f7fd5, #86a8e7, #2D68C4);
        border-radius: 8px;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
        padding: 10px;
        z-index: 1001;
        max-height: 200px;
        overflow-y: auto;
        width: calc(100% - 20px);
    }

    .history-item {
        padding: 8px;
        cursor: pointer;
        transition: background-color 0.2s;
        color: white;
        border-bottom: 1px solid rgba(255, 255, 255, 0.2);
        font-size: 0.8rem;
        display: flex;
        align-items: center;
        justify-content: space-between;
    }

    .history-item:last-child {
        border-bottom: none;
    }

    .history-item:hover {
        background-color: rgba(255, 255, 255, 0.2);
    }

.loader-container {
position: fixed;
top: 0;
left: 0;
width: 100%;
height: 100%;
background-color: rgba(0, 0, 0, 0.5);
display: none;
justify-content: center;
align-items: center;
z-index: 10002; /* <-- ИЗМЕНЕНО ЗНАЧЕНИЕ (было 10000) */
backdrop-filter: blur(3px);
flex-direction: column;
}

    .loader {
        /* Adjust styling as necessary to position the spinner and text */
        position: relative; /* Add this line */
        display: flex; /* Add this line */
        flex-direction: column; /* Add this line */
        align-items: center; /* Add this line */
        justify-content: center; /* Add this line */
    }

    .spinner-container {
        width: 80px;
        height: 80px;
        position: relative;
    }

    .spinner-ring {
        position: absolute;
        width: 100%;
        height: 100%;
        border-radius: 50%;
        border: 6px solid transparent;
        border-top-color: #3498db;
        animation: spin 1.2s cubic-bezier(0.5, 0, 0.5, 1) infinite;
        box-sizing: border-box;
    }

    .spinner-ring:before,
    .spinner-ring:after {
        content: '';
        position: absolute;
        border-radius: 50%;
        border: 6px solid transparent;
        box-sizing: border-box;
    }

    .spinner-ring:before {
        top: -6px;
        left: -6px;
        right: -6px;
        bottom: -6px;
        border-top-color: #2980b9;
        animation: spin 2s cubic-bezier(0.5, 0, 0.5, 1) infinite;
    }

    .spinner-ring:after {
        top: 6px;
        left: 6px;
        right: 6px;
        bottom: 6px;
        border-top-color: #6ab7e2;
        animation: spin 0.8s cubic-bezier(0.5, 0, 0.5, 1) infinite;
    }

    @keyframes spin {
        0% {
            transform: rotate(0deg);
        }

        100% {
            transform: rotate(360deg);
        }
    }

    .loading-text {
        color: #2c3e50;
        font-size: 18px;
        font-weight: bold;
        margin-top: 30px;
        letter-spacing: 1px;
        text-shadow: 0 1px 2px rgba(255, 255, 255, 0.5);
        animation: pulse 1.5s ease infinite;
    }

    @keyframes pulse {
        0%,
        100% {
            opacity: 0.7;
        }

        50% {
            opacity: 1;
        }
    }

    .circular {
        animation: rotate 2s linear infinite;
        height: 100%;
        transform-origin: center center;
        width: 100%;
        position: absolute;
        top: 0;
        bottom: 0;
        left: 0;
        right: 0;
        margin: auto;
    }

    .path {
        stroke-dasharray: 150,200; /* Adjust as needed */
        stroke-dashoffset: -10;  /* Adjust as needed */
        stroke: #3498db;
        stroke-linecap: round;
        animation: dash 1.5s ease-in-out infinite;
    }

    @keyframes rotate {
        100% {
            transform: rotate(360deg);
        }
    }

    @keyframes dash {
        0% {
            stroke-dasharray: 1,200;
            stroke-dashoffset: 0;
        }

        50% {
            stroke-dasharray: 90,200;
            stroke-dashoffset: -35px;
        }

        100% {
            stroke-dashoffset: -125px;
        }
    }

    .notification.warning {
        background: linear-gradient(135deg, #ffc107, #ff9800);
    }

    .color-modal {
        display: none;
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: linear-gradient(135deg, #ffffff, #f0f0f0);
        padding: 25px;
        border-radius: 15px;
        box-shadow: 0 8px 16px rgba(0, 0, 0, 0.2);
        z-index: 10000;
        width: 350px;
        text-align: center;
        font-family: sans-serif;
        overflow: hidden;
    }

    .color-modal-content {
        display: flex;
        flex-direction: column;
        gap: 20px;
        align-items: center;
    }

    .color-modal h3 {
        margin: 0;
        font-size: 1.2rem;
        color: #333;
        font-weight: 600;
    }

    .color-modal input[type="color"] {
        width: 100px;
        height: 40px;
        border: none;
        border-radius: 8px;
        cursor: pointer;
        transition: transform 0.2s ease;
    }

    .color-modal input[type="color"]:hover {
        transform: scale(1.05);
    }

    .color-modal .toggle-fill {
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 15px;
    }

    .color-modal .toggle-fill label {
        font-size: 0.9rem;
        color: #555;
        font-weight: 500;
    }

    .color-modal .toggle-fill input[type="checkbox"] {
        width: 20px;
        height: 20px;
        cursor: pointer;
        accent-color: #4a90e2;
    }

    .color-modal .opacity-slider {
        display: flex;
        flex-direction: column;
        gap: 10px;
        align-items: center;
        width: 100%;
    }

    .color-modal .opacity-slider label {
        font-size: 0.9rem;
        color: #555;
        font-weight: 500;
    }

    .color-modal .opacity-slider input[type="range"] {
        width: 80%;
        accent-color: #4a90e2;
    }

    .color-modal .opacity-slider #opacity-value {
        font-size: 0.9rem;
        color: #333;
        font-weight: 500;
    }

    .color-modal .buttons {
        display: flex;
        justify-content: space-around;
        gap: 15px;
        margin-top: 20px;
        width: 100%;
    }

    .color-modal .buttons button {
        padding: 10px 20px;
        border: none;
        border-radius: 8px;
        cursor: pointer;
        transition: background-color 0.3s ease, transform 0.2s ease;
        font-size: 0.9rem;
        width: 80px;
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 5px;
    }

    .color-modal .buttons button i {
        font-size: 1rem;
    }

    .color-modal .buttons .apply-btn {
        background-color: #4CBB17;
        color: white;
    }

    .color-modal .buttons .apply-btn:hover {
        background-color: #4CBB17;
        transform: scale(1.05);
    }

    .color-modal .buttons .cancel-btn {
        background-color: #9D00FF;
        color: white;
    }

    .color-modal .buttons .cancel-btn:hover {
        background-color: #9D00FF;
        transform: scale(1.05);
    }

    .color-modal .buttons .delete-btn {
        background-color: #FF2C2C;
        color: white;
    }

    .color-modal .buttons .delete-btn:hover {
        background-color: #FF2C2C;
        transform: scale(1.05);
    }

    .color-modal .buttons .copy-btn {
        background-color: #f39c12;
        color: white;
    }

    .color-modal .buttons .copy-btn:hover {
        background-color: #e67e22;
        transform: scale(1.05);
    }

    #map {
        transition: transform 0.5s ease-in-out, opacity 0.5s ease-in-out;
    }

    .map-zoom-in {
        animation: zoomIn 0.5s ease-in-out forwards;
    }

    @keyframes zoomIn {
        0% {
            transform: scale(0);
            opacity: 0;
        }
        100% {
            transform: scale(1);
            opacity: 1;
        }
    }

    .gradient-modal {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.5);
        z-index: 1000;
    }

    .gradient-modal-content {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: linear-gradient(135deg, #305cde, #86a8e7, #2D68C4);
        padding: 20px;
        border-radius: 12px;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
        text-align: center;
    }

    .color-pickers {
        display: flex;
        justify-content: center;
        gap: 10px;
        margin: 20px 0;
    }

    .color-pickers input[type="color"] {
        width: 50px;
        height: 50px;
        border: none;
        border-radius: 8px;
        cursor: pointer;
    }

    .gradient-modal-content button {
        margin: 5px;
        padding: 8px 16px;
        border: none;
        border-radius: 8px;
        background-color: rgba(255, 255, 255, 0.2);
        color: white;
        cursor: pointer;
        transition: background-color 0.3s ease;
    }

    .gradient-modal-content button:hover {
        background-color: rgba(255, 255, 255, 0.3);
    }

    .gradient-button {
        margin-top: 10px;
        padding: 10px 20px;
        background: linear-gradient(135deg, #6a11cb, #2575fc);
        color: white;
        border: none;
        border-radius: 8px;
        cursor: pointer;
        font-size: 14px;
        font-weight: bold;
        text-transform: uppercase;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.2);
        transition: all 0.3s ease;
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 8px;
    }

    .gradient-button i {
        font-size: 18px;
        transition: transform 0.3s ease;
    }

    .gradient-button:hover {
        background: linear-gradient(135deg, #2575fc, #6a11cb);
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.3);
        transform: translateY(-2px);
    }

    .gradient-button:hover i {
        transform: rotate(15deg);
    }

    .gradient-button:active {
        transform: translateY(0);
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.2);
    }

    .external-map-button {
        width: 36px;
        height: 36px;
        background-color: rgba(255, 255, 255, 0.7);
        border: 1px solid rgba(0, 0, 0, 0.1);
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        transition: transform 0.2s ease, background-color 0.2s ease;
        margin: 0 2px;
        padding: 0;
        overflow: hidden;
        border-radius: 8px;
    }

    .external-map-button:hover {
        background-color: rgba(240, 240, 240, 0.9);
        transform: scale(1.1);
    }

    .external-map-button-animation {
        opacity: 0;
        transform: translateY(-10px);
        animation: slideIn 0.3s ease forwards;
    }

    .external-maps-container {
        position: absolute;
        display: flex;
        justify-content: flex-start;
        gap: 5px;
        z-index: 1001;
        background-color: rgba(255, 255, 255, 0);
        border-radius: 8px;
        padding: 5px;
        box-shadow: none;
    }

    @keyframes slideIn {
        from {
            opacity: 0;
            transform: translateY(-10px);
        }
        to {
            opacity: 1;
            transform: translateY(0);
        }
    }

    /* Animation for widget appearance */
    @keyframes widgetAppear {
        0% {
            opacity: 0;
            transform: translateY(20px) scale(0.95);
        }
        100% {
            opacity: 1;
            transform: translateY(0) scale(1);
        }
    }

    /* Pulsating effect for active buttons */
    @keyframes pulse {
        0% {
            box-shadow: 0 0 0 0 rgba(96, 165, 250, 0.7);
        }
        70% {
            box-shadow: 0 0 0 10px rgba(96, 165, 250, 0);
        }
        100% {
            box-shadow: 0 0 0 0 rgba(96, 165, 250, 0);
        }
    }
    
    .color-modal .buttons .clear-all-placemarks-btn {
    background-color: #e74c3c;
    color: white;
}

.color-modal .buttons .clear-all-placemarks-btn:hover {
    background-color: #c0392b;
    transform: scale(1.05);
}

/* Добавляем новый класс для кнопок карты с пульсацией */
.map-mode-button.map-type.active {
    background-color: rgba(255, 255, 255, 0.35);
    font-weight: bold;
    box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2), inset 0 0 10px rgba(255, 255, 255, 0.2);
    transform: scale(1.15);
    animation: pulse 2s infinite;
}

/* Оригинальный класс active для остальных кнопок без пульсации */
.map-mode-button.active:not(.map-type) {
    background-color: rgba(255, 255, 255, 0.35);
    font-weight: bold;
    box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2), inset 0 0 10px rgba(255, 255, 255, 0.2);
    transform: scale(1.15);
}




/* Snowy background with black text tooltip styles */
.custom-hint {
    background: linear-gradient(135deg, rgba(240, 245, 255, 0.9), rgba(225, 235, 250, 0.9)); /* Snowy, frosty white background */
    border-radius: 10px;
    padding: 14px 18px;
    box-shadow: 0 6px 16px rgba(180, 200, 225, 0.3), 0 2px 6px rgba(180, 200, 225, 0.2); /* Soft blue-tinted shadow */
    font-family: 'Inter', 'Roboto', -apple-system, sans-serif;
    color: #1a1a2e; /* Rich dark blue-black text */
    max-width: 280px;
    min-width: 180px;
    width: fit-content;
    text-align: left;
    white-space: normal;
    overflow-wrap: break-word;
    line-height: 1.5;
    font-size: 13px;
    letter-spacing: 0.2px;
    backdrop-filter: blur(6px);
    border: 1px solid rgba(255, 255, 255, 0.8); /* Bright white border */
    transform: translateY(0);
    transition: transform 0.2s ease, box-shadow 0.2s ease;
}

.custom-hint:hover {
    transform: translateY(-2px);
    box-shadow: 0 8px 20px rgba(180, 200, 225, 0.4), 0 3px 8px rgba(180, 200, 225, 0.3);
}

.custom-hint strong {
    font-weight: 600;
    color: #000814; /* Deeper black for emphasis */
}

/* Optional time/header styling */
.custom-hint::before {
    content: attr(data-time);
    display: block;
    font-size: 11px;
    margin-bottom: 8px;
    color: #4a5568; /* Subtle gray for secondary information */
    letter-spacing: 0.5px;
}

/* Enhanced styles for custom placemark */
.custom-placemark {
    position: absolute;
    font-size: 18px; /* Good readable size */
    font-weight: 700; /* Bolder text */
    color: #ffff00; /* Bright yellow - high contrast against most backgrounds */
    text-shadow: 
        -2px -2px 1px rgba(0,0,0,0.9),  
        2px -2px 1px rgba(0,0,0,0.9),
        -2px 2px 1px rgba(0,0,0,0.9),
        2px 2px 1px rgba(0,0,0,0.9),
        0 0 6px rgba(0,0,0,0.8); /* Multiple shadows for better outline */
    font-family: 'Arial', sans-serif;
    user-select: none;
    letter-spacing: 0.7px; /* Improved letter spacing */
    transform: scale(1.05); /* Slight scaling for emphasis */
}

/* Optional hover effect for interactive maps */
.custom-placemark:hover {
    transform: scale(1.15);
    transition: transform 0.2s ease;
}

/* --- Стили для боковой панели результатов --- */
.parcel-results-sidebar {
    position: fixed;
    top: 10px;
    right: 10px;
    width: 280px; /* Уменьшена ширина панели */
    height: calc(100vh - 20px);
    background: linear-gradient(135deg, #f8fafc, #eef2f7 80%);
    border-radius: 12px;
    box-shadow: -5px 0 15px rgba(0, 0, 0, 0.1);
    z-index: 1005;
    display: flex;
    flex-direction: column;
    overflow: hidden;
    transition: width 0.3s ease, transform 0.3s ease, opacity 0.3s ease;
    border: 1px solid #e2e8f0;
    opacity: 1;
    transform: translateX(0);
}

.parcel-results-sidebar.collapsed {
    width: 40px; /* Уменьшена ширина свернутой панели */
    background: #eef2f7;
}


.parcel-results-sidebar.hidden {
    opacity: 0;
    transform: translateX(100%);
    width: 0; /* Схлопываем при скрытии */
    pointer-events: none; /* Неактивна, когда скрыта */
}


.sidebar-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 10px 15px;
    border-bottom: 1px solid #e2e8f0;
    background-color: rgba(255, 255, 255, 0.5);
    flex-shrink: 0; /* Заголовок не сжимается */
}

.sidebar-header h3 {
    margin: 0;
    font-size: 1.1rem;
    color: #1e293b;
    font-weight: 600;
    white-space: nowrap; /* Заголовок не переносится */
    overflow: hidden;
    transition: opacity 0.2s ease;
}

.parcel-results-sidebar.collapsed .sidebar-header h3 {
    opacity: 0; /* Скрываем заголовок при сворачивании */
    width: 0;
}

.toggle-sidebar-btn {
    background: none;
    border: none;
    color: #4b5563;
    font-size: 1.2rem;
    cursor: pointer;
    padding: 5px;
    transition: color 0.2s ease, transform 0.3s ease;
}

.toggle-sidebar-btn:hover {
    color: #1e293b;
}



.parcel-results-sidebar.collapsed .toggle-sidebar-btn i {
    transform: rotate(180deg); /* Поворачиваем стрелку */
}

.toggle-sidebar-btn i {
    font-weight: 900; /* Критично для solid (fas) иконок Font Awesome */
    transition: transform 0.3s ease; /* Для плавного вращения */
    display: inline-block; /* Убедимся, что элемент отображается корректно */
}



.parcel-list-content {
    flex-grow: 1; /* Занимает все доступное место */
    overflow-y: auto; /* Вертикальная прокрутка */
    padding: 5px 0; /* Небольшие отступы сверху/снизу */
    transition: opacity 0.2s ease;
}

.parcel-results-sidebar.collapsed .parcel-list-content {
    opacity: 0; /* Скрываем контент при сворачивании */
    pointer-events: none;
}

.sidebar-item {
    padding: 12px 15px;
    margin: 8px 10px;
    border-radius: 8px;
    background-color: #ffffff;
    box-shadow: 0 1px 3px rgba(0,0,0,0.05);
    cursor: pointer;
    transition: background-color 0.2s ease, box-shadow 0.2s ease;
    border: 1px solid #f1f5f9;
}

.sidebar-item:hover {
    background-color: #f8fafc;
    box-shadow: 0 2px 5px rgba(0,0,0,0.08);
}

.sidebar-item p {
    margin: 0 0 6px 0;
    font-size: 0.9rem;
    color: #4b5563;
    line-height: 1.4;
}

.sidebar-item p:first-child { /* Кадастровый номер */
    font-weight: 600;
    font-size: 1rem;
    color: #1d4ed8; /* Синий */
}
.sidebar-item p:last-child {
    margin-bottom: 0;
}

.sidebar-footer {
    padding: 10px 15px;
    border-top: 1px solid #e2e8f0;
    background-color: rgba(255, 255, 255, 0.7); /* Немного прозрачнее */
    flex-shrink: 0;
    display: flex; /* Используем flexbox */
    align-items: center; /* Выравниваем по центру вертикально */
    gap: 10px; /* Отступ между элементами */
    transition: opacity 0.2s ease;
}
.parcel-results-sidebar.collapsed .sidebar-footer {
     opacity: 0;
     pointer-events: none;
}
#filter-cadnum-input {
    flex-grow: 1; /* Занимает доступное пространство */
    padding: 8px 12px;
    border: 1px solid #cbd5e1;
    border-radius: 6px;
    font-size: 0.9rem;
    background-color: #fff;
    box-shadow: inset 0 1px 2px rgba(0,0,0,0.05);
}
#filter-cadnum-input:focus {
    outline: none;
    border-color: #3b82f6;
    box-shadow: inset 0 1px 2px rgba(0,0,0,0.05), 0 0 0 2px rgba(59, 130, 246, 0.3);
}

.sidebar-btn {
    width: 100%;
    padding: 10px 15px;
    border-radius: 8px;
    border: none;
    font-size: 0.95rem;
    font-weight: 500;
    color: white;
    cursor: pointer;
    transition: all 0.2s ease;
    box-shadow: 0 2px 5px rgba(0,0,0,0.1);
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 8px;
}

.sidebar-icon-btn {
    flex-shrink: 0; /* Кнопка не сжимается */
    width: 36px;
    height: 36px;
    border-radius: 50%; /* Круглая кнопка */
    border: none;
    background-color: #3b82f6; /* Синий */
    color: white;
    font-size: 1rem; /* Размер иконки */
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    transition: background-color 0.2s ease, transform 0.1s ease;
    box-shadow: 0 1px 3px rgba(0,0,0,0.1);
}

.sidebar-icon-btn:hover {
    background-color: #2563eb;
    transform: translateY(-1px);
     box-shadow: 0 2px 5px rgba(0,0,0,0.15);
}
.sidebar-icon-btn:active {
     transform: translateY(0);
     background-color: #1d4ed8;
}

/* Добавляем стиль для скрытых элементов при фильтрации */
.sidebar-item.filtered-out {
    display: none;
}

#copy-all-sidebar-btn {
    background-color: #3b82f6; /* Синий */
}
#copy-all-sidebar-btn:hover {
    background-color: #2563eb;
    transform: translateY(-1px);
    box-shadow: 0 3px 6px rgba(0,0,0,0.15);
}

/* Адаптация под мобильные устройства - можно уменьшить ширину панели */
@media (max-width: 768px) {
    .parcel-results-sidebar {
        width: 240px; /* Уменьшена ширина панели на мобильных */
    }
     .parcel-results-sidebar.collapsed {
        width: 35px; /* Уменьшена ширина свернутой панели на мобильных */
    }
}


        /* --- Styles for Legends --- */
.map-legend {
    position: absolute;
    bottom: 10px;
    /* Изменено: уменьшаем отступ, чтобы легенда была ближе к панели */
    /* Ширина боковой панели 280px + ее отступ справа 10px + небольшой зазор 5px = 295px */
    right: 295px; 
    background-color: rgba(255, 255, 255, 0.85);
    backdrop-filter: blur(4px);
    padding: 10px 15px;
    border-radius: 8px;
    box-shadow: 0 2px 5px rgba(0,0,0,0.2);
    z-index: 900;
    max-width: 250px;
    max-height: 40vh;
    overflow-y: auto;
    font-size: 12px;
    color: #333;
    display: none; /* Hide by default */
}

    .map-legend h4,
    .map-legend .legend-title-multiline { /* Добавляем новый класс */
        margin-top: 0;
        margin-bottom: 8px;
        font-size: 13px; /* Или ваш размер */
        text-align: center;
        border-bottom: 1px solid #ddd;
        padding-bottom: 5px;
        color: #333; /* Цвет текста заголовка */
    }
    
   .camera-height-label {
        position: absolute;
        bottom: 45px;
        left: 10px;
        background-color: transparent;
        color: #ffffff;
        padding: 5px 8px;
        border-radius: 4px;
        font-size: 13px;
        font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
        font-weight: 500;
        z-index: 1000;
        pointer-events: none;
        text-shadow:
            -1px -1px 1px rgba(0,0,0,0.75),
             1px -1px 1px rgba(0,0,0,0.75),
            -1px  1px 1px rgba(0,0,0,0.75),
             1px  1px 1px rgba(0,0,0,0.75),
            0px 0px 5px rgba(0,0,0,0.5);
        transition: opacity 0.3s ease;
        display: none; /* СКРЫТЬ ПО УМОЛЧАНИЮ */
    }

    .camera-height-label.visible { /* НОВЫЙ КЛАСС ДЛЯ ОТОБРАЖЕНИЯ */
        display: block;
    }
    
        #cost-legend .legend-gradient {
            height: 15px;
            border-radius: 3px;
            margin-bottom: 5px;
            border: 1px solid #ccc;
        }
        #cost-legend .legend-labels {
            display: flex;
            justify-content: space-between;
            font-size: 11px;
        }
        #vri-legend-list {
            list-style: none;
            padding: 0;
            margin: 0;
        }
        #vri-legend-list li {
            display: flex;
            align-items: center;
            margin-bottom: 4px;
            line-height: 1.3;
        }
        #vri-legend-list .legend-color-box {
            width: 14px;
            height: 14px;
            border-radius: 3px;
            margin-right: 8px;
            flex-shrink: 0;
            border: 1px solid rgba(0,0,0,0.2);
        }
@media (max-width: 768px) {
      .map-legend {
         max-width: calc(100% - 40px);
         bottom: 60px; /* Adjust if needed based on other elements */
         /* На мобильных устройствах легенда позиционируется слева, поэтому 'right' сбрасывается */
         left: 10px;
         right: auto; 
      }
 }
 
 #vri-legend-list li.legend-item-selected {
    background-color: rgba(0, 0, 0, 0.1); /* Light gray background */
    font-weight: bold;
    border-radius: 4px; /* Optional: rounded corners for highlight */
    box-shadow: inset 0 0 3px rgba(0,0,0,0.1); /* Optional: inner shadow */
}

/* Ensure cursor indicates clickability */
#vri-legend-list li {
    cursor: pointer; /* Add this if not already present */
    /* ... other li styles ... */
}

/* --- Styles for Ownership Legend --- */
#ownership-legend {
    /* Inherits general .map-legend styles */
    /* Specific adjustments if needed */
}

#ownership-legend-list {
    list-style: none;
    padding: 0;
    margin: 0;
}

#ownership-legend-list li {
    display: flex;
    align-items: center;
    margin-bottom: 4px;
    line-height: 1.3;
    cursor: pointer; /* Indicate clickability */
    padding: 2px 4px; /* Add slight padding for better click target and highlight */
    border-radius: 3px; /* Rounded corners for potential highlight */
    transition: background-color 0.1s ease; /* Smooth background transition */
}

#ownership-legend-list .legend-color-box {
    width: 14px;
    height: 14px;
    border-radius: 3px;
    margin-right: 8px;
    flex-shrink: 0;
    border: 1px solid rgba(0,0,0,0.2);
}

 /* Style for selected ownership legend item */
 #ownership-legend-list li.legend-item-selected {
    background-color: rgba(0, 0, 0, 0.1); /* Light gray background */
    font-weight: bold;
    /* box-shadow: inset 0 0 3px rgba(0,0,0,0.1); Optional: inner shadow */
 }
 
 /* ... existing legend styles ... */

#vri-legend-list,
#ownership-legend-list,
#registration-date-legend-list { /* Added new legend list */
    list-style: none;
    padding: 0;
    margin: 0;
}
#vri-legend-list li,
#ownership-legend-list li,
#registration-date-legend-list li { /* Added new legend list */
    display: flex;
    align-items: center;
    margin-bottom: 4px;
    line-height: 1.3;
    cursor: pointer; /* Indicate clickability for all list-based legends */
    padding: 2px 4px;
    border-radius: 3px;
    transition: background-color 0.1s ease;
}
#vri-legend-list li:hover,
#ownership-legend-list li:hover,
#registration-date-legend-list li:hover { /* Added new legend list */
     background-color: rgba(0, 0, 0, 0.05);
}

#vri-legend-list .legend-color-box,
#ownership-legend-list .legend-color-box,
#registration-date-legend-list .legend-color-box { /* Added new legend list */
    width: 14px;
    height: 14px;
    border-radius: 3px;
    margin-right: 8px;
    flex-shrink: 0;
    border: 1px solid rgba(0,0,0,0.2);
}
 /* ... media query for legends ... */

#vri-legend-list li.legend-item-selected,
#ownership-legend-list li.legend-item-selected,
#registration-date-legend-list li.legend-item-selected { /* Added new legend list */
    background-color: rgba(0, 0, 0, 0.1); /* Light gray background */
    font-weight: bold;
    /* Optional: inner shadow */
    box-shadow: inset 0 0 3px rgba(0,0,0,0.1);
}


/* --- Styles for Ownership Legend --- */
#ownership-legend {
    /* Inherits general .map-legend styles */
    /* Specific adjustments if needed */
}
 /* Style for selected ownership legend item */


/* --- Styles for Registration Date Legend --- */
#registration-date-legend {
    /* Inherits general .map-legend styles */
}

#ulu-legend {
    /* ... any specific styles ... */
}

#ulu-legend-list {
    list-style: none;
    padding: 0;
    margin: 0;
}

#ulu-legend-list li {
    display: flex;
    align-items: center;
    margin-bottom: 4px;
    line-height: 1.3;
    /* cursor: pointer; Add if you make legend items clickable for filtering */
    padding: 2px 4px;
    border-radius: 3px;
     cursor: pointer; 
}

#ulu-legend-list .legend-color-box {
    width: 14px;
    height: 14px;
    border-radius: 3px;
    margin-right: 8px;
    flex-shrink: 0;
    border: 1px solid rgba(0,0,0,0.2);
}
#ulu-legend-list li.legend-item-selected {
    background-color: rgba(0, 0, 0, 0.1); /* Light gray background */
    font-weight: bold;
    /* box-shadow: inset 0 0 3px rgba(0,0,0,0.1); Optional: inner shadow */
}

/* Общий стиль для заголовка легенды, если еще нет */
.map-legend h4,
.map-legend .legend-title-multiline { /* Добавляем новый класс */
    margin-top: 0;
    margin-bottom: 8px;
    font-size: 13px; /* Или ваш размер */
    text-align: center;
    border-bottom: 1px solid #ddd;
    padding-bottom: 5px;
    color: #333; /* Цвет текста заголовка */
}

/* Стили для многострочного заголовка */
.legend-title-multiline span {
    display: block; /* Каждая часть заголовка будет на новой строке */
    line-height: 1.2; /* Межстрочный интервал, если нужно */
}

/* Можно сделать вторую строку чуть меньше или светлее, если хотите */
.legend-title-multiline span:last-child {
    font-size: 11px; /* Например, немного меньше */
    color: #555;    /* Например, немного светлее */
    margin-top: 2px; /* Небольшой отступ сверху для второй строки */
}



.numbered-point-label {
    color: #FF0000; /* Красный цвет текста */
    font-size: 16px; /* Размер шрифта */
    font-weight: bold; /* Жирный шрифт */
    font-family: Arial, sans-serif;
    /* Белый контур для лучшей читаемости на любом фоне */
    text-shadow: -1px -1px 0 #fff, 1px -1px 0 #fff, -1px 1px 0 #fff, 1px 1px 0 #fff;
    user-select: none; /* Запретить выделение текста */
    pointer-events: none; /* Метка не будет перехватывать клики мыши */
}



.custom-red-dot {
    width: 10px;
    height: 10px;
    background-color: #FF0000;
    border-radius: 50%;
    border: 1px solid #B20000; /* Темно-красная рамка для четкости */
}



/* ЗАМЕНИТЕ ВСЕ СТИЛИ ДЛЯ МОДАЛЬНОГО ОКНА ОКС НА ЭТИ */

/* Стилизация основного контейнера модального окна */
#oksModalContent {
    background: #ffffff !important;
    width: 90% !important;
    max-width: 480px !important; /* Немного шире для кнопок */
    border-radius: 12px !important;
    box-shadow: 0 5px 20px rgba(0,0,0,0.15) !important;
    padding: 15px !important;
    display: flex;
    flex-direction: column;
}

/* Контейнер списка с динамической высотой и скроллбаром */
#oksListContainer {
    max-height: 70vh;
    overflow-y: auto;
    padding: 5px;
    margin-bottom: 15px;
}

/* Стилизация красивого скроллбара */
#oksListContainer::-webkit-scrollbar { width: 8px; }
#oksListContainer::-webkit-scrollbar-track { background: #f1f1f1; border-radius: 10px; }
#oksListContainer::-webkit-scrollbar-thumb { background: #888; border-radius: 10px; }
#oksListContainer::-webkit-scrollbar-thumb:hover { background: #555; }

/* Стиль для каждого элемента списка (синяя "кнопка") */
#oksListContainer .oks-item {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 12px 18px;
    margin: 8px 0;
    border-radius: 8px;
    background-color: #3B82F6;
    color: white;
    font-size: 1rem;
    font-weight: 500;
    box-shadow: 0 2px 5px rgba(0,0,0,0.1);
    transition: all 0.2s ease-in-out;
}
#oksListContainer .oks-item:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 10px rgba(0,0,0,0.15);
    background-color: #2563EB;
}

/* Контейнер для двух кнопок в строке */
.oks-item-buttons {
    display: flex;
    align-items: center;
    gap: 8px; /* Расстояние между иконками */
    margin-left: 15px;
}

/* Общий стиль для иконок-кнопок в строке */
.oks-icon-btn {
    background: rgba(255, 255, 255, 0.2);
    border: none;
    border-radius: 50%;
    width: 32px;
    height: 32px;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    transition: all 0.2s ease;
    flex-shrink: 0;
    color: white; /* Цвет иконки FontAwesome */
    font-size: 14px; /* Размер иконки FontAwesome */
}

.oks-icon-btn:hover {
    background: rgba(255, 255, 255, 0.4);
    transform: scale(1.1);
}

.oks-icon-btn img {
    width: 20px;
    height: 20px;
}

/* Контейнер для нижних кнопок ("Копировать все" и "Закрыть") */
.oks-footer-buttons {
    display: flex;
    justify-content: center;
    gap: 15px; /* Расстояние между кнопками */
    margin-top: 10px;
    flex-wrap: wrap; /* Перенос кнопок на новую строку на маленьких экранах */
}

/* Общий стиль для нижних кнопок */
.oks-footer-btn {
    padding: 12px 20px;
    border: none;
    border-radius: 8px;
    color: white;
    font-size: 1rem;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.2s ease;
    box-shadow: 0 2px 5px rgba(0,0,0,0.15);
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 8px;
}
.oks-footer-btn:hover {
    box-shadow: 0 4px 10px rgba(0,0,0,0.2);
    transform: translateY(-1px);
}

/* Стиль для кнопки "Копировать все" */
#oksCopyAllBtn {
    background-color: #1E88E5; /* Другой оттенок синего */
}
#oksCopyAllBtn:hover {
    background-color: #1565C0;
}

/* Стиль для кнопки "Закрыть" (переименован из .oks-close-btn для единообразия) */
#closeOksModalBtn {
    background-color: #F44336; /* Красный */
}
#closeOksModalBtn:hover {
    background-color: #D32F2F;
}

/* Сообщение, если ОКС не найдены */
#oksListContainer .no-oks-found {
    padding: 20px;
    text-align: center;
    color: #6b7280;
    font-style: italic;
    background: #f8f9fa;
    border-radius: 8px;
}

/* --- Стили для модального окна конвертера (финальная версия) --- */
.converter-modal {
    position: fixed;
    z-index: 10001;
    left: 0;
    top: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0,0,0,0.5);
    backdrop-filter: blur(8px);
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 20px;
    box-sizing: border-box;
}

.converter-modal-content {
    /* Градиент будет применен через JS */
    padding: 20px 25px;
    border-radius: 24px;
    width: 100%;
    max-width: 450px;
    min-width: 320px;
    box-shadow: 0 15px 40px rgba(0,0,0,0.2);
    border: 1.5px solid rgba(255,255,255,0.2);
    display: flex;
    flex-direction: column;
    gap: 18px;
    position: relative;
    animation: fadeInScale 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
    box-sizing: border-box;
}

@keyframes fadeInScale {
    from { opacity: 0; transform: translateY(10px) scale(0.95); }
    to { opacity: 1; transform: translateY(0) scale(1); }
}

.converter-modal-content h3 {
    text-align: center;
    color: #333;
    margin: 0;
    font-weight: 600;
    font-size: 1.1rem;
    padding: 0 20px;
}

.converter-modal-content select,
.converter-modal-content textarea {
    width: 100%;
    padding: 12px 18px;
    border-radius: 16px;
    border: none;
    font-size: 0.95rem;
    background: rgba(255, 255, 255, 0.7);
    color: #444;
    box-shadow: inset 0 2px 4px rgba(0,0,0,0.05);
    transition: all 0.3s ease;
    box-sizing: border-box;
}

.converter-modal-content select::placeholder,
.converter-modal-content textarea::placeholder {
    color: #888;
}

.converter-modal-content select:focus,
.converter-modal-content textarea:focus {
    outline: none;
    background: rgba(255, 255, 255, 0.9);
    box-shadow: 0 0 0 3px rgba(120, 100, 255, 0.25), inset 0 2px 4px rgba(0,0,0,0.05);
}

.converter-modal-content textarea {
    min-height: 120px;
    resize: vertical;
    font-family: monospace;
}

.converter-modal-actions {
    display: flex;
    justify-content: space-between;
    align-items: center;
    gap: 15px;
}

.converter-modal-actions select {
    flex-grow: 1;
    text-align: center;
    text-align-last: center;
    appearance: none;
    background-image: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="%238a98b4" stroke-width="2" stroke-linecap="round"><polyline points="6,9 12,15 18,9"/></svg>');
    background-repeat: no-repeat;
    background-position: right 15px center;
    background-size: 18px;
    padding-right: 40px;
}

.converter-modal-actions .action-btn {
    width: 48px;
    height: 48px;
    flex-shrink: 0;
    border: none;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.3s cubic-bezier(0.25, 0.8, 0.25, 1);
    cursor: pointer;
    box-shadow: 0 6px 15px rgba(0,0,0,0.15);
}

.converter-modal-actions .action-btn:hover {
    transform: translateY(-2px) scale(1.05);
    box-shadow: 0 8px 20px rgba(0,0,0,0.2);
    filter: brightness(1.1);
}

.converter-modal-actions .action-btn img {
    width: 20px;
    height: 20px;
    filter: invert(1) drop-shadow(0 1px 2px rgba(0,0,0,0.2));
}

.converter-modal-content .close-btn {
    position: absolute;
    top: 18px;
    right: 20px;
    background: transparent;
    border: none;
    font-size: 1.6rem;
    color: rgba(0,0,0,0.3);
    cursor: pointer;
    transition: all 0.2s ease;
    padding: 0;
    line-height: 1;
}

.converter-modal-content .close-btn:hover {
    color: rgba(0,0,0,0.6);
    transform: scale(1.1);
}

/* Для мобильных устройств */
@media (max-width: 480px) {
    .converter-modal {
        padding: 15px;
    }
    
    .converter-modal-content {
        min-width: auto;
        width: 100%;
        padding: 18px 20px;
    }
}

.converter-mode-switch {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 15px;
    margin-bottom: 15px; /* Отступ снизу */
}
.converter-mode-switch label {
    margin: 0;
    color: #444;
    font-weight: 500;
}
.switch { position: relative; display: inline-block; width: 140px; height: 34px; }
.switch input { opacity: 0; width: 0; height: 0; }
.slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #ccc; transition: .4s; border-radius: 34px; }
.slider:before { position: absolute; content: ""; height: 26px; width: 70px; left: 4px; bottom: 4px; background-color: white; transition: .4s; border-radius: 34px; }
/* Текст на переключателе */
.slider:after { content: 'Запрос'; color: white; position: absolute; right: 15px; top: 50%; transform: translateY(-50%); font-size: 0.85rem; font-weight: bold; }
input:checked + .slider { background-color: #2196F3; }
input:checked + .slider:before { transform: translateX(62px); }
input:checked + .slider:after { content: 'Proj4'; left: 15px; right: auto; }

/* Стили для полей смещения */
.converter-offset-inputs {
    display: flex;
    gap: 15px;
    margin-top: -5px; /* Уменьшаем отступ сверху, т.к. у textarea свой отступ */
    margin-bottom: 18px;
}
.converter-offset-inputs div {
    flex: 1;
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 8px;
}
.converter-offset-inputs label {
    font-size: 0.9rem;
    color: #555;
    font-weight: 500;
}
.converter-offset-inputs input[type="number"] {
    width: 100%;
    padding: 10px;
    border-radius: 12px;
    border: none;
    text-align: center;
    font-size: 0.95rem;
    background: rgba(255, 255, 255, 0.7);
    color: #444;
    box-shadow: inset 0 2px 4px rgba(0,0,0,0.05);
}
.converter-offset-inputs input[type="number"]:focus {
     outline: none;
     background: rgba(255, 255, 255, 0.9);
     box-shadow: 0 0 0 3px rgba(120, 100, 255, 0.25), inset 0 2px 4px rgba(0,0,0,0.05);
}

.modal-option {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 10px;
    margin-bottom: 15px; /* Отступ снизу */
    user-select: none;
}
.modal-option input[type="checkbox"] {
    width: auto;
    height: auto;
    transform: scale(1.2);
    cursor: pointer;
    margin: 0;
}
.modal-option label {
    margin: 0;
    cursor: pointer;
    font-size: 0.9rem;
    color: #444;
}


.sidebar-stats {
    padding: 8px 15px;
    font-size: 0.85rem;
    color: #4b5563;
    background-color: rgba(255, 255, 255, 0.5);
    border-bottom: 1px solid #e2e8f0;
    line-height: 1.5;
    flex-shrink: 0; /* Запрещаем сжиматься */
    transition: opacity 0.2s ease;
    display: none; /* Скрыт по умолчанию, пока нет данных */
}
.parcel-results-sidebar.collapsed .sidebar-stats {
    opacity: 0;
    pointer-events: none;
}


</style>

</head>

<body>
    



     <div id="map"></div>

    <!-- LOADER (оставляем только один) -->
    <div class="loader-container" id="loaderContainer">
        <div class="loader">
            <div class="spinner-container">
                <div class="spinner-ring"></div>
            </div>
                <div class="loading-text">Загрузка...</div> 
        </div>
    </div>

    <!-- КОНТЕКСТНОЕ МЕНЮ (оставляем только одно, обычно здесь или перед </body>) -->
    <div class="custom-context-menu" style="display: none;">
       <!-- Содержимое контекстного меню (которое вы добавили ранее) будет здесь при инициализации карты -->
    </div>

    <!-- ЛЕГЕНДЫ КАРТЫ (их положение здесь нормальное) -->
    <div id="cost-legend" class="map-legend">
        <h4>Стоимость (руб./кв.м)</h4>
        <div class="legend-gradient"></div>
        <div class="legend-labels">
            <span id="legend-min-cost">0</span>
            <span id="legend-max-cost">0</span>
        </div>
    </div>
    <div id="vri-legend" class="map-legend">
        <h4>Вид разрешенного использования</h4>
        <ul id="vri-legend-list"></ul>
    </div>

    <div id="ownership-legend" class="map-legend">
        <h4>Форма собственности | Тип права</h4>
        <ul id="ownership-legend-list"></ul>
    </div>

    <!-- NEW LEGEND FOR REGISTRATION DATE - Corrected placement -->
    <div id="registration-date-legend" class="map-legend">
        <h4>Дата внесения в ЕГРН</h4>
        <ul id="registration-date-legend-list"></ul>
    </div>
    
    <div id="ulu-legend" class="map-legend">
       <div class="legend-title-multiline">
    <span>Единое землепользование</span>
    <span>(по состоянию на 2016 г.)</span>
</div>
    <ul id="ulu-legend-list"></ul>
</div>
    <!-- End NEW LEGEND -->
  <div id="camera-height-label" class="camera-height-label">Обзор: ...</div>
    <!-- Конец легенд -->

    <!-- ВИДЖЕТ (оставляем только одну копию) -->
    <div class="widget widget-desktop" id="widget">
        <a class="city-name" id="city-name-display" target="_blank"></a>
        <div class="date-time"></div>
        <textarea class="coords-input" id="coords-input" placeholder="Введите координаты (X Y или X[tab]Y)"></textarea>
        <textarea class="result-textarea" id="converted-textarea" placeholder="Конвертированные координаты" readonly></textarea>
        <textarea class="result-textarea" id="geo-textarea" placeholder="Географические координаты" readonly></textarea>
        
      
        
        <div class="map-mode-switcher">
            <button class="map-mode-button map-type" data-mode="map" title="Схема">
                <i class="fas fa-map"></i>
            </button>
            <button class="map-mode-button map-type" data-mode="satellite" title="Спутник">
                <i class="fas fa-satellite"></i>
            </button>
            <button class="map-mode-button map-type" data-mode="hybrid" title="Схема - Спутник">
                <i class="fas fa-layer-group"></i>
            </button>
            <button class="map-mode-button map-type" data-mode="blank" title="Пустая карта">
                <i class="fas fa-square"></i>
            </button>
        <button class="convert-button" onclick="findAndConvert()" title="Найти по координатам (F9)">
                <i class="fas fa-play"></i>
            </button>
        <button class="map-mode-button" id="open-converter-btn" title="МСК">
    <i class="fas fa-exchange-alt"></i>
</button>
            <button class="map-mode-button" data-mode="style" title="Настройки" onclick="openStyleSettings()">
                <i class="fas fa-cog"></i>
            </button>
            <button id="add-text-button" title="Добавить текст">
                <i class="fas fa-pencil-alt"></i>
            </button>
            <button class="map-mode-button" data-mode="yandex-google" title="Карты" onclick="openExternalMaps(event)">
                <i class="fas fa-map-marker-alt"></i>
            </button>
        </div>
        <div class="input-container">
            <img src="img/history.png" alt="History" class="history-icon" id="history-icon">
            <input type="text" id="city-input" placeholder="">
            <img src="img/find.png" alt="Search" class="search-icon" id="search-icon">
        </div>
        <div id="history-modal" class="history-modal"></div>
    </div>
    <!-- Конец виджета -->

    <!-- МОДАЛЬНЫЕ ОКНА (выносим за пределы виджета, обычно размещают перед </body>) -->
     <div id="styleModal" class="style-modal">
        <div class="style-modal-content">
            <h3>Настройки</h3>
            <div class="style-setting">
                <label>Линия:</label>
                <input type="color" id="lineColor" onchange="updatePolygonStyle()">
            </div>
            <div class="style-setting">
                <label>Уточненные ЗУ:</label>
                <input type="color" id="parcelsColor" onchange="updatePolygonStyle()">
            </div>
            <div class="style-setting">
                <label>Декларированные ЗУ:</label>
                <input type="color" id="declaredParcelsColor" onchange="updatePolygonStyle()">
            </div>
            
              <div class="style-setting">
                <label>Здания:</label>
                <input type="color" id="buildingsColor" onchange="updatePolygonStyle()">
            </div>
            
               <div class="style-setting">
                <label>Сооружения:</label>
                <input type="color" id="structuresColor" onchange="updatePolygonStyle()">
            </div>
            
       
            
            <div class="style-setting">
                <label>Толщина линии:</label>
                <input type="range" id="lineWidth" min="1" max="10" value="2" onchange="updatePolygonStyle()">
            </div>
            <div class="style-setting">
                <label>Смещение по широте (-4.5):</label>
                <input type="number" id="mapOffsetX" value="-4.5" step="0.1" onchange="updateMapOffset()">
            </div>
            <div class="style-setting">
                <label>Смещение по долготе (-1):</label>
                <input type="number" id="mapOffsetY" value="-1" step="0.1" onchange="updateMapOffset()">
            </div>
            
                 <div class="style-setting">
                <label>KML Смещение по широте (0):</label>
                <input type="number" id="kmlMapOffsetX" value="0" step="0.1" onchange="updateKmlMapOffset()">
            </div>
            <div class="style-setting">
                <label>KML Смещение по долготе (0):</label>
                <input type="number" id="kmlMapOffsetY" value="0" step="0.1" onchange="updateKmlMapOffset()">
            </div>
            
              <div class="style-setting">
                <label for="toggleOpenGoogleEarth">Web-версия Планета Земля:</label>
                <input type="checkbox" id="toggleOpenGoogleEarth" onchange="updateGoogleEarthSetting()">
            </div>
            
            <!-- НОВАЯ НАСТРОЙКА ДЛЯ МЕТКИ ВЫСОТЫ -->
            <div class="style-setting">
                <label for="toggleHeightLabel">Высота/Обзор:</label>
                <input type="checkbox" id="toggleHeightLabel" onchange="toggleCameraHeightLabelVisibility()">
            </div>
            <!-- КОНЕЦ НОВОЙ НАСТРОЙКИ -->
            <button class="gradient-button" onclick="openGradientModal()">
                <i class="fas fa-palette"></i>
            </button>
             <!-- СЮДА можно добавить input для thematicCostColor, если нужно -->
             <!-- <div class="style-setting">
                 <label>Цвет (Стоимость):</label>
                 <input type="color" id="thematicCostColorInputId" onchange="updatePolygonStyle()">
             </div> -->
        </div>
    </div>

    <div id="gradientModal" class="gradient-modal">
        <div class="gradient-modal-content">
            <h3>Градиент виджета</h3>
            <div class="color-pickers">
                <input type="color" id="color1" value="#3B82F6">
                <input type="color" id="color2" value="#60A5FA">
                <input type="color" id="color3" value="#1E3A8A">
                <input type="color" id="fontColor" value="#F9FAFB">
            </div>
            <button onclick="resetGradient()"><i class="fas fa-redo"></i></button>
            <button onclick="applyGradient()" aria-label="Применить градиент"><i class="fas fa-check"></i></button>
            <button onclick="closeGradientModal()" aria-label="Отменить"><i class="fas fa-times"></i></button>
        </div>
    </div>
    <!-- Конец модальных окон -->

    <!-- БОКОВАЯ ПАНЕЛЬ (положение в конце нормальное) -->
    <div id="parcel-results-sidebar" class="parcel-results-sidebar hidden">
        <div class="sidebar-header">
            <h3 id="sidebar-title">Найденные участки</h3>
            <button id="toggle-sidebar-btn" class="toggle-sidebar-btn" title="Свернуть/Развернуть">
                <i class="fas fa-chevron-right"></i>
            </button>
        </div>
        <!-- НОВЫЙ БЛОК ДЛЯ СТАТИСТИКИ -->
        <div id="sidebar-stats" class="sidebar-stats"></div>
        <!-- КОНЕЦ НОВОГО БЛОКА -->
        <div id="parcel-list-content" class="parcel-list-content">
            <div class="no-results-message" style="display: none; padding: 20px; text-align: center; color: #6b7280;">
                Нет пересекающихся участков.
            </div>
        </div>
        <div class="sidebar-footer">
            <input type="text" id="filter-cadnum-input" placeholder="Фильтр">
            <button id="copy-filtered-btn" class="sidebar-icon-btn" title="Копировать видимые">
                <i class="fas fa-copy"></i>
            </button>
        </div>
    </div>
    
    

<!-- Модальное окно для отображения списка ОКС на ЗУ -->
<div id="oksModal" class="style-modal">
    <div class="style-modal-content" id="oksModalContent">
        <div id="oksListContainer">
            <!-- Сюда будет динамически добавлен список ОКС -->
        </div>
      
    </div>
</div>
    
  <script src="msk.js"></script> 
      <script src="sk.js"></script>
    <script src="https://api-maps.yandex.ru/2.1/?apikey=dde71a0e-b612-44b7-b53b-82533420240f&lang=ru_RU"
        type="text/javascript"></script>
        <script src="webfonts/turf.min.js"></script>

    <script>

        const cityInput = document.getElementById('city-input');
        const cityNameElement = document.getElementById('city-name-display');
        const dateTimeElement = document.querySelector('.date-time');
        const mapElement = document.getElementById('map');
        const coordsInput = document.getElementById('coords-input');
        const convertedTextarea = document.getElementById('converted-textarea');
        const geoTextarea = document.getElementById('geo-textarea');
        const widget = document.getElementById('widget');

const sevenDigitsRegions = [
  '06', '07', '09', '10', '11', '12', '13', '14', '17', '23',
  '24', '27', '31', '32', '35', '36', '41', '42', '47', '48',
  '50', '52', '53', '56', '57', '58', '59', '60', '61', '62',
  '63', '64', '65', '66', '67', '69', '70', '71', '72', '74',
  '77', '78', '79'];

        let isMobile = window.innerWidth <= 768;
        let isSearching = false;

        let currentCity = '';
        let map;
        let polygons = [];
        let lastPolygonCenter = null;
        let distanceLine = null;
        let distanceLabel = null;
        let distancePoints = [];
        let distanceMeasurementActive = false;
        let debounceTimer = null;
        let numberedDotSize = 10;
            let numberedPointSize = 14;
        let loaderTextEl = null;
        let zuToEzMapGlobal = new Map();
          let isCameraHeightLabelVisible = false; 
             let openGoogleEarthAfterExport = true;

        
        let ownershipColorMap = new Map(); // Map<"Ownership|RightType", colorHex>
const ownershipLegendDiv = document.getElementById('ownership-legend'); // Legend div
let selectedOwnershipFromLegend = null; // Tracks the selected ownership combination, null means show all
let ownershipFilterPlacemarks = new Map(); // Stores temporary placemarks for ownership filter: Map<cadastralNumber, ymaps.Placemark>
 let selectedRegistrationDateFromLegend = null; 
        
         let parcelFeaturesData = []; 
      let buildingFeaturesData = [];
          let structureFeaturesData = []; // To store raw feature data for themes
          let zouitFeaturesData = []; 
        let currentTheme = 'none'; // 'none', 'cost', 'use'
        let vriColorMap = new Map(); // Map VRI names to colors
        const costLegendDiv = document.getElementById('cost-legend'); // Legend divs
        const vriLegendDiv = document.getElementById('vri-legend');
        
        let registrationDateColorMap = new Map(); // Map registration dates to colors
    const registrationDateLegendDiv = document.getElementById('registration-date-legend'); // New legend div
    
     let registrationDateFilterPlacemarks = new Map();
    
        let vriFilterPlacemarks = new Map(); // Stores temporary placemarks: Map<cadastralNumber, ymaps.Placemark>
        let currentQuarterNumber = null; 

let polygonStyle = {
    color: localStorage.getItem('polygonColor') || '#ffff00', // <-- Здесь теперь жёлтый цвет (#ffff00)
    width: parseInt(localStorage.getItem('polygonWidth')) || 4,
    parcelsColor: localStorage.getItem('parcelsColor') || '#2CFF05', 
    declaredParcelsColor: localStorage.getItem('declaredParcelsColor') || '#FF0000', 
    buildingsColor: localStorage.getItem('buildingsColor') || '#FFA500', 
       structuresColor: localStorage.getItem('structuresColor') || '#00BFFF', 
      
    thematicCostColor: localStorage.getItem('thematicCostColor') || '#0000FF', 
    thematicRegistrationDateColor1: localStorage.getItem('thematicRegistrationDateColor1') || '#FFFF00',
    thematicRegistrationDateColor2: localStorage.getItem('thematicRegistrationDateColor2') || '#00FF00'
};
        
   let areaMeasurementActive = false;
let areaPoints = [];
let areaPolygon = null;
let areaLabel = null;
let areaObjects = []; // Новый массив для объектов измерения площади
let allAreaMeasurements = [];
let selectedPlacemark = null;

const uluLegendDiv = document.getElementById('ulu-legend');
let uluColorMap = new Map(); // Map<EZ_CadastralNumber, colorHex>
let selectedUluFromLegend = null; // If you implement filtering by legend click later
let uluFilterPlacemarks = new Map(); 

let currentLineColor = '#ff2c2c'; // Default line color, can be changed
let currentLineWidth = 4;       // Default line width, can be changed

let selectedVriFromLegend = null; // Tracks the VRI selected in the legend, null means show all
        // Смещения по осям
        let mapOffsetX = parseFloat(localStorage.getItem('mapOffsetX')) || -4.5;
        let mapOffsetY = parseFloat(localStorage.getItem('mapOffsetY')) || -1;
        
         let kmlMapOffsetX = parseFloat(localStorage.getItem('kmlMapOffsetX')) || 0;
        let kmlMapOffsetY = parseFloat(localStorage.getItem('kmlMapOffsetY')) || 0;
        
        let isSidebarCollapsed = false; // Глобальная переменная для состояния панели
          let cameraHeightLabelElement = null;
        const ALTITUDE_CORRECTION_FACTOR = 3; // Новый коэффициент
        let selectedLine = null;
        
        
       let useVercelProxy = false;
       let isVercelProxyBlocked = false;
       let lastVercelBlockTime = 0;

const vercelProxyUrl = 'https://nsp-two.vercel.app/';


async function fetchNspd(url, options = {}) {
    if (isVercelProxyBlocked) {
        return new Response(JSON.stringify({ error: "Vercel proxy is blocked" }), {
            status: 403,
            statusText: "Forbidden (Proxy Blocked)",
            headers: { 'Content-Type': 'application/json' }
        });
    }

    const isPostRequest = options.method && options.method.toUpperCase() === 'POST';

    const fetchDirectly = async () => {
        try {
            const response = await fetch(url, options);
            return response;
        } catch (error) {
            useVercelProxy = true; 
            return await fetchViaVercel();
        }
    };

    const fetchViaVercel = async () => {
        const urlObject = new URL(url);
        const targetPath = `${urlObject.pathname}${urlObject.search}`;
        const proxyRequestUrl = `${vercelProxyUrl}?target=${encodeURIComponent(targetPath)}`;
        
        const newHeaders = new Headers(options.headers);
        newHeaders.append('Referer', 'https://nspd.gov.ru/');

        const proxyOptions = {
            ...options,
            headers: newHeaders
        };
       
        const response = await fetch(proxyRequestUrl, proxyOptions); 

        if (!response.ok && response.status === 403) {
            isVercelProxyBlocked = true;
            const currentTime = Date.now();
            if (currentTime - lastVercelBlockTime > 30000) {
                showNotification('Доступ через прокси-сервер заблокирован. Проверьте настройки ALLOWED_IPS на Vercel.', 'error', 'exclamation-triangle', 7000);
                lastVercelBlockTime = currentTime;
            }
        }

        if (response.ok) {
            const clonedResponse = response.clone(); 
            try {
                const data = await clonedResponse.json();
                if (data && data.error) {
                    throw new Error(data.error); 
                }
            } catch (e) {
                // Non-JSON responses are still valid in some cases
            }
        }
        return response; 
    };

    if (useVercelProxy) {
        return await fetchViaVercel();
    } else {
        return await fetchDirectly();
    }
}



function isZeroQuarterRequest(numberString) {
    if (!numberString || typeof numberString !== 'string') {
        return false;
    }

    const parts = numberString.trim().split(':');
    
  
    if (parts.length !== 3) {
        return false;
    }

    const regionPart = parts[0];
    const blockPart = parts[2]; 
    
   
    const isSevenDigitsRegion = sevenDigitsRegions.includes(regionPart);
    const expectedZerosLength = isSevenDigitsRegion ? 7 : 6;

    
    if (/^0+$/.test(blockPart) && blockPart.length === expectedZerosLength) {
        return true; 
    }

    return false;
}
        
        const sidebar = document.getElementById('parcel-results-sidebar');
const toggleBtn = document.getElementById('toggle-sidebar-btn');


const standardColors = [
    'blue',    // Синий
    'green',   // Зелёный
    'red',     // Красный
    'yellow',  // Жёлтый
    'black',   // Чёрный
    'gray',    // Серый
    'orange',  // Оранжевый
    'violet'   // Фиолетовый
];

// Объект для хранения счётчиков цвета для каждой метки
const placemarkColorIndices = new Map();

                // Определяем кастомный макет для метки

let ownershipFilterState = 0; // 0: все с заливкой, 1: отфильтрованные с заливкой, 2: отфильтрованные без заливки

// Функция для получения следующего цвета по порядку
function getNextStandardColor(placemark) {
    let colorIndex = placemarkColorIndices.get(placemark) || 0;
    colorIndex = (colorIndex + 1) % standardColors.length; // Циклический переход
    placemarkColorIndices.set(placemark, colorIndex);
    return standardColors[colorIndex];
}

let parcelPlacemarks = [];

function updatePlacemarksVisibility() {
    if (!map || !parcelPlacemarks.length) return;

    const zoom = map.getZoom();
    const projection = map.options.get('projection');
    const visiblePlacemarks = [];

    // Filter placemarks first based on theme/selection
     let filteredPlacemarks = parcelPlacemarks.filter(pm => {
         if (currentTheme === 'use' && selectedVriFromLegend !== null) {
             const vri = pm.polygon?.properties.get('vri') || '(Не указано)';
             return vri === selectedVriFromLegend;
         }
          // --- NEW --- Filter for Ownership
          if (currentTheme === 'ownership' && selectedOwnershipFromLegend !== null) {
               const options = pm.polygon?.properties.get('featureData')?.properties?.options || {};
               const ownership = options.ownership_type || 'Не указано';
               const rightType = options.right_type || 'Не указано';
               const key = `${ownership}|${rightType}`;
               return key === selectedOwnershipFromLegend;
          }
          // --- END NEW ---
           // --- NEW --- Filter for Registration Date
          if (currentTheme === 'registration_date' && selectedRegistrationDateFromLegend !== null) {
               const options = pm.polygon?.properties.get('featureData')?.properties?.options || {};
               const regDate = options.land_record_reg_date || 'Не указана';
               // Check if the date string starts with the selected filter string (allows filtering by year, year-month, or full date)
               return regDate.startsWith(selectedRegistrationDateFromLegend);
          }
          // --- END NEW ---

         return true; // Show all if no filter or theme
     });




    filteredPlacemarks.forEach(placemark => {
        const polygon = placemark.polygon;
        if (!polygon) {
             // console.warn("Placemark without linked polygon:", placemark);
             return; // Skip placemarks without linked polygons
        }

        const coords = placemark.geometry.getCoordinates();
        const pixelCoords = projection.toGlobalPixels(coords, zoom);

        const bounds = polygon.geometry.getBounds();
        if (!bounds || !bounds[0] || !bounds[1]) {
            // console.warn("Polygon without valid bounds:", polygon);
            placemark.options.set('visible', false); // Hide if bounds are invalid
            return;
        }
        const pixelBounds = [
            projection.toGlobalPixels(bounds[0], zoom),
            projection.toGlobalPixels(bounds[1], zoom)
        ];
        const width = Math.abs(pixelBounds[1][0] - pixelBounds[0][0]);
        const height = Math.abs(pixelBounds[1][1] - pixelBounds[0][1]);
        const areaInPixels = width * height;

        // Adjust visibility threshold based on zoom level and pixel area
        const isVisible = (areaInPixels > 500 || zoom > 16); // Labels visible for larger polygons or zoomed in

        if (isVisible) {
            // Check if the placemark is already on the map (prevent re-adding filter placemarks)
            if (map.geoObjects.indexOf(placemark) !== -1) {
                 placemark.options.set('visible', true);
                 const fontSize = Math.max(10, Math.min(16, 8 + zoom * 0.4));
                 const element = placemark.getOverlaySync()?.getLayoutSync()?.getElement()?.querySelector('.custom-placemark');
                 if (element) {
                     element.style.fontSize = `${fontSize}px`;
                 }

                 const textWidth = fontSize * (placemark.properties.get('iconContent')?.length || 0) * 0.6;
                 const textHeight = fontSize * 1.5;
                 visiblePlacemarks.push({
                     placemark,
                     bbox: {
                         left: pixelCoords[0] - textWidth / 2,
                         right: pixelCoords[0] + textWidth / 2,
                         top: pixelCoords[1] - textHeight / 2,
                         bottom: pixelCoords[1] + textHeight / 2
                     }
                 });
            } else {
                 // Should not happen if placemarks are managed correctly
                 // console.warn("Placemark is not on map but should be visible:", placemark);
                 placemark.options.set('visible', false);
            }
        } else {
            placemark.options.set('visible', false);
        }
    });

    // Basic overlap removal for visible labels
    for (let i = 0; i < visiblePlacemarks.length; i++) {
        const current = visiblePlacemarks[i];
        if (!current.placemark.options.get('visible')) continue; // Skip if already hidden by filter or size

        for (let j = 0; j < i; j++) {
            const other = visiblePlacemarks[j];
            if (!other.placemark.options.get('visible')) continue; // Skip if already hidden

            if (
                current.bbox.left < other.bbox.right &&
                current.bbox.right > other.bbox.left &&
                current.bbox.top < other.bbox.bottom &&
                current.bbox.bottom > other.bbox.top
            ) {
                // Overlap detected
                const currentArea = turf.area(turf.polygon([current.placemark.polygon.geometry.getCoordinates()[0].map(coord => [coord[1], coord[0]])]));
                const otherArea = turf.area(turf.polygon([other.placemark.polygon.geometry.getCoordinates()[0].map(coord => [coord[1], coord[0]])]));

                if (currentArea < otherArea) {
                    current.placemark.options.set('visible', false);
                } else {
                    other.placemark.options.set('visible', false);
                }
            }
        }
    }
}


     


      function closeStyleModal() {
    document.getElementById('styleModal').style.display = 'none';
}

        window.addEventListener('click', function (event) {
            const modal = document.getElementById('styleModal');
            if (event.target === modal) {
                modal.style.display = 'none';
            }
        });

function toEPSG3857(latitude, longitude) {
    const RADIUS = 6378137;
    const x = RADIUS * longitude * Math.PI / 180;
    const y = RADIUS * Math.log(Math.tan(Math.PI / 4 + latitude * Math.PI / 360));
    return { x: x, y: y };
}

        async function queryCadastralInfo(latitude, longitude) {
            const centerPoint = toEPSG3857(latitude, longitude);
            const centerX = centerPoint.x;
            const centerY = centerPoint.y;
            const polygonSizeMeters = 0.15;
            const halfSize = polygonSizeMeters / 2;
            const minX = centerX - halfSize;
            const minY = centerY - halfSize;
            const maxX = centerX + halfSize;
            const maxY = centerY + halfSize;
            const width = 512;
            const height = 512;
            const i = width / 2;
            const j = height / 2;
            const bbox = `${minX},${minY},${maxX},${maxY}`;
            const url = `https://nspd.gov.ru/api/aeggis/v4/36048/wms?REQUEST=GetFeatureInfo&QUERY_LAYERS=36048&SERVICE=WMS&VERSION=1.3.0&FORMAT=image%2Fpng%2F&STYLES=&TRANSPARENT=true&LAYERS=36048&RANDOM=${Math.random()}&INFO_FORMAT=application%2Fjson&FEATURE_COUNT=10&I=${i}&J=${j}&WIDTH=${width}&HEIGHT=${height}&CRS=EPSG%3A3857&BBOX=${bbox}`;

            try {
                const response = await fetchNspd(url);
                const data = await response.json();
                return data;
            } catch (error) {
                console.error('Error fetching cadastral data:', error);
                return null;
            }
        }


        function animateMapZoom() {
            const mapElement = document.getElementById('map');

            // Добавляем класс для анимации
            mapElement.classList.add('map-zoom-in');

            // Убираем класс после завершения анимации
            setTimeout(() => {
                mapElement.classList.remove('map-zoom-in');
            }, 500); // Длительность анимации в миллисекундах
        }


        let externalMapsContainer = null;
        
      

        function openExternalMaps(event) {
            if (!map) return;

            const button = event.target.closest('.map-mode-button');
            const widgetRect = widget.getBoundingClientRect(); // Get widget's position


            // Create the container if it doesn't exist
            if (!externalMapsContainer) {
                externalMapsContainer = document.createElement('div');
                externalMapsContainer.className = 'external-maps-container'; // Add class for styling
                document.body.appendChild(externalMapsContainer); // Append to body

                // Create buttons
                const nspdButton = createExternalMapButton('nspd', 'img/nspd.png');
                const yandexButton = createExternalMapButton('yandex', 'img/ymap.png');
                const googleButton = createExternalMapButton('google', 'img/gmap.png');
                 const exportAllKmlButton = createExternalMapButton('export_all_kml', 'img/emap.png');

                // Add animation class to each button
                [nspdButton, yandexButton, googleButton, exportAllKmlButton].forEach((btn, index) => {
                    btn.classList.add('external-map-button-animation');
                    btn.style.animationDelay = `${index * 0.1}s`; // Staggered animation
                    externalMapsContainer.appendChild(btn);
                });

                // Close the container if clicking outside
                document.addEventListener('click', closeExternalMapsContainerOnClickOutside);

            }

            // Calculate position - below the widget, aligned to the RIGHT
            const top = widgetRect.bottom + 10;  // 5px below the widget
            const left = widgetRect.right - externalMapsContainer.offsetWidth;     // Align with the RIGHT edge of the widget

            externalMapsContainer.style.top = `${top}px`;
            externalMapsContainer.style.left = `${left}px`;
            externalMapsContainer.style.display = 'flex'; // Show the container, and ensure it's a flex container

            // Force reflow to trigger animation
            void externalMapsContainer.offsetWidth;
            // Recalculate left position after display and reflow.  VERY IMPORTANT!
            externalMapsContainer.style.left = `${widgetRect.right - externalMapsContainer.offsetWidth}px`;
        }

        function closeExternalMapsContainerOnClickOutside(event) {
            if (externalMapsContainer && !externalMapsContainer.contains(event.target) && event.target.closest('[data-mode="yandex-google"]') === null) {
                externalMapsContainer.style.display = 'none';
            }
        }
        
        
        



function cleanAndFormatAICoordinates(aiText) {
    if (!aiText || aiText.trim() === "") {
        return "";
    }
    // Remove potential markdown backticks
    aiText = aiText.replace(/```plaintext|```csv|```/gi, '').trim();

    const lines = aiText.trim().split('\n');
    const formattedCoords = [];

    for (const line of lines) {
        const parts = line.trim().split(/\s+/); // Split by any whitespace (tab, space)
        if (parts.length === 2) {
            let xStr = parts[0].replace(',', '.');
            let yStr = parts[1].replace(',', '.');
            
            let x = parseFloat(xStr);
            let y = parseFloat(yStr);

            if (!isNaN(x) && !isNaN(y)) {
                // Ensure x < y
                if (x > y) {
                    [x, y] = [y, x];
                }
                // Format to 2 decimal places
                formattedCoords.push(`${x.toFixed(2)}\t${y.toFixed(2)}`);
            }
        }
    }
    return formattedCoords.join('\n');
}
// --- End AI Helper Functions ---
        

function createExternalMapButton(type, imgSrc) {
            const button = document.createElement('button');
            button.className = 'map-mode-button external-map-button'; // Используем существующий класс

            const img = document.createElement('img');
            img.src = imgSrc;
            img.style.width = '32px'; // Можно настроить, если нужно
            img.style.height = '32px';
            button.appendChild(img);

            button.addEventListener('click', (event) => {
                event.stopPropagation(); // Предотвращаем закрытие контейнера при клике на кнопку
                const mapCenter = map.getCenter();
                const lat = mapCenter[0];
                const lon = mapCenter[1];
                let url = '';

                if (type === 'yandex') {
                    url = `https://yandex.ru/maps/?pt=${lon},${lat}&z=15`;
                } else if (type === 'google') {
                    url = `https://www.google.com/maps?q=${lat},${lon}&z=15`;
                } else if (type === 'nspd') {
                    const epsg3857Coords = proj4("EPSG:4326", "EPSG:3857", [lon, lat]);
                    url = `https://nspd.gov.ru/map?zoom=20&coordinate_x=${epsg3857Coords[0]}&coordinate_y=${epsg3857Coords[1]}&theme_id=1&is_copy_url=true&active_layers=36329%2C36328%2C36049%2C36048`;
                // --- ОБРАБОТКА НОВОЙ КНОПКИ ---
                } else if (type === 'export_all_kml') {
                    exportAllMapObjectsToKml(); // Вызываем новую функцию экспорта
                    if (externalMapsContainer) {
                        externalMapsContainer.style.display = 'none'; // Закрываем контейнер после клика
                    }
                    return; // Выходим, так как это не открытие URL
                // --- КОНЕЦ ОБРАБОТКИ ---
                }


                if (url) {
                    window.open(url, '_blank');
                    if (externalMapsContainer) {
                        externalMapsContainer.style.display = 'none'; // Закрываем контейнер
                    }
                }
            });

            return button;
        }

  


function generateKmlForPlacemark(placemarkObject, placemarkName) {
    const yandexCoords = placemarkObject.geometry.getCoordinates(); // [lat, lon]

    // Корректируем координаты Yandex карты до "истинных" WGS84
    const trueLat = yandexCoords[0] + (mapOffsetY * 0.000008983);
    const trueLon = yandexCoords[1] + (mapOffsetX * 0.000008983);

    // Применяем KML смещения
    const kmlLat = trueLat + (kmlMapOffsetY * 0.000008983);
    const kmlLon = trueLon + (kmlMapOffsetX * 0.000008983);

    const kmlCoordsString = `${kmlLon},${kmlLat},0`; // lon,lat,alt

       let kmlStyleXml = `
      <Style>
        <IconStyle>
          <Icon>
            <href>http://maps.google.com/mapfiles/kml/pushpin/ylw-pushpin.png</href>
          </Icon>
          <hotSpot x="20" y="2" xunits="pixels" yunits="pixels"/>
        </IconStyle>
        <LabelStyle>
          <color>ffffffff</color> <!-- white text -->
          <scale>0.8</scale>
        </LabelStyle>
      </Style>`;

    const preset = placemarkObject.options.get('preset');
    if (preset && preset.includes('StretchyIcon')) {
        let kmlColor = "ffffffff"; // AABBGGRR for KML IconStyle color
        let labelColor = "ffffffff"; // Default label color to white

        if (preset.includes('blue')) { kmlColor = "ffff0000"; labelColor = "ffffffff"; } // Blue icon, white text
        else if (preset.includes('red')) { kmlColor = "ff0000ff"; labelColor = "ffffffff"; } // Red icon, white text
        else if (preset.includes('green')) { kmlColor = "ff00ff00"; labelColor = "ffffffff"; } // Green icon, white text
        else if (preset.includes('yellow')) { kmlColor = "ff00ffff"; labelColor = "ff000000"; } // Yellow icon, black text for contrast
        else if (preset.includes('orange')) { kmlColor = "ff00a5ff"; labelColor = "ffffffff"; } // Orange icon, white text
        else if (preset.includes('violet')) { kmlColor = "ffee82ee"; labelColor = "ffffffff"; } // Violet icon, white text
        
        kmlStyleXml = `
          <Style>
            <IconStyle>
              <color>${kmlColor}</color>
              <Icon><href>http://maps.google.com/mapfiles/kml/paddle/wht-blank.png</href></Icon>
            </IconStyle>
            <LabelStyle>
              <color>${labelColor}</color>
              <scale>0.9</scale>
            </LabelStyle>
          </Style>`;
    } else if (placemarkObject.options.get('iconLayout') === customPlacemarkLayout) {
        // For custom text placemarks, hide icon, style label
        kmlStyleXml = `
          <Style>
            <IconStyle><scale>0</scale></IconStyle> <!-- Hide icon -->
            <LabelStyle>
              <color>ffffffff</color> <!-- ИЗМЕНЕНО: Белый цвет текста для кастомных меток -->
              <scale>1.0</scale>
            </LabelStyle>
          </Style>`;
    }


    return `
    <Placemark>
      <name>${escapeXml(placemarkName)}</name>
      ${kmlStyleXml}
      <Point>
        <coordinates>${kmlCoordsString}</coordinates>
      </Point>
    </Placemark>`;
}

// Вспомогательная функция для генерации KML для draggableText
function generateKmlForDraggableText(draggableTextElement, mapInstance, defaultName) {
    const textContent = draggableTextElement.querySelector('span')?.textContent || defaultName;

    const rect = draggableTextElement.getBoundingClientRect();
    const pageX = rect.left + rect.width / 2 + window.scrollX;
    const pageY = rect.top + rect.height / 2 + window.scrollY;

    let geoCoords; // Это координаты, отображаемые на Yandex карте
    try {
        const globalPixelCoords = mapInstance.converter.pageToGlobal([pageX, pageY]);
        geoCoords = mapInstance.options.get('projection').fromGlobalPixels(globalPixelCoords, mapInstance.getZoom());
    } catch (e) {
        console.error("Error converting draggableText position:", e, draggableTextElement);
        return '';
    }

    if (!geoCoords) return '';

    // Корректируем до "истинных" WGS84
    const trueLatText = geoCoords[0] + (mapOffsetY * 0.000008983);
    const trueLonText = geoCoords[1] + (mapOffsetX * 0.000008983);

    // Применяем KML смещения
    const kmlLatText = trueLatText + (kmlMapOffsetY * 0.000008983);
    const kmlLonText = trueLonText + (kmlMapOffsetX * 0.000008983);

    const kmlCoordsString = `${kmlLonText},${kmlLatText},0`;

    const kmlStyle = `
      <Style>
        <IconStyle>
          <scale>0</scale>
        </IconStyle>
        <LabelStyle>
          <color>ffffffff</color> <!-- ИЗМЕНЕНО: Белый цвет текста для draggableText -->
          <scale>1.0</scale>
        </LabelStyle>
      </Style>`;
    // ... остальная часть функции ...
    return `
    <Placemark>
      <name>${escapeXml(textContent)}</name>
      ${kmlStyle}
      <Point>
        <coordinates>${kmlCoordsString}</coordinates>
      </Point>
    </Placemark>`;
}


     

    function openStyleSettings() {
    const styleModal = document.getElementById('styleModal');
    styleModal.style.display = 'block';
    document.getElementById('lineColor').value = polygonStyle.color;
    document.getElementById('parcelsColor').value = polygonStyle.parcelsColor;
    document.getElementById('declaredParcelsColor').value = polygonStyle.declaredParcelsColor;
    document.getElementById('buildingsColor').value = polygonStyle.buildingsColor;
      document.getElementById('structuresColor').value = polygonStyle.structuresColor; 
        
    document.getElementById('lineWidth').value = polygonStyle.width;
    document.getElementById('mapOffsetX').value = mapOffsetX;
    document.getElementById('mapOffsetY').value = mapOffsetY;
    
       document.getElementById('kmlMapOffsetX').value = kmlMapOffsetX;
    document.getElementById('kmlMapOffsetY').value = kmlMapOffsetY;

    const toggleHeightLabelCheckbox = document.getElementById('toggleHeightLabel');
    if (toggleHeightLabelCheckbox) {
        toggleHeightLabelCheckbox.checked = isCameraHeightLabelVisible;
    }

    // START: Load and set Google Earth setting
    const toggleOpenGoogleEarthCheckbox = document.getElementById('toggleOpenGoogleEarth');
    if (toggleOpenGoogleEarthCheckbox) {
        const savedGoogleEarthSetting = localStorage.getItem('openGoogleEarthAfterExport');
        openGoogleEarthAfterExport = savedGoogleEarthSetting === null ? true : (savedGoogleEarthSetting === 'true');
        toggleOpenGoogleEarthCheckbox.checked = openGoogleEarthAfterExport;
    }
    // END: Load and set Google Earth setting
}
        
 function updateKmlMapOffset() {
            // --- НАЧАЛО ИЗМЕНЕНИЙ ---
            // Принудительно заменяем запятую на точку перед парсингом
            const kmlOffsetXValue = document.getElementById('kmlMapOffsetX').value.replace(',', '.');
            const kmlOffsetYValue = document.getElementById('kmlMapOffsetY').value.replace(',', '.');

            kmlMapOffsetX = parseFloat(kmlOffsetXValue) || 0;
            kmlMapOffsetY = parseFloat(kmlOffsetYValue) || 0;
            // --- КОНЕЦ ИЗМЕНЕНИЙ ---
            
            localStorage.setItem('kmlMapOffsetX', kmlMapOffsetX);
            localStorage.setItem('kmlMapOffsetY', kmlMapOffsetY);
            // Не вызываем findAndConvert(), так как это только для KML экспорта
        }

        // START: New function to update Google Earth setting
        function updateGoogleEarthSetting() {
            const checkbox = document.getElementById('toggleOpenGoogleEarth');
            if (checkbox) {
                openGoogleEarthAfterExport = checkbox.checked;
                localStorage.setItem('openGoogleEarthAfterExport', openGoogleEarthAfterExport);
            }
        }
        
function showLoader(message = "Загрузка...") {
    const loaderContainer = document.getElementById('loaderContainer');
    const loadingText = document.querySelector('.loading-text'); // Make sure this element exists in your HTML
    if (loadingText) loadingText.textContent = message;
    if (loaderContainer) loaderContainer.style.display = 'flex';
}

function hideLoader() {
    const loaderContainer = document.getElementById('loaderContainer');
    if (loaderContainer) loaderContainer.style.display = 'none';
}



const STORAGE_API_URL = 'https://mapruapp.ru/storage';
const BUCKET_NAME = 'kpt';

const supabaseUrl = 'https://vznsatvyikahngdfvqho.supabase.co'; 
const supabaseAnonKey = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InZ6bnNhdHZ5aWthaG5nZGZ2cWhvIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDU0MjM3MDMsImV4cCI6MjA2MDk5OTcwM30.FJmk0lgIjqvcdV7p6C0riaxqS9QWKAuIHDZtkMYMJe4';

const { createClient } = supabase;
const supabaseClient = createClient(supabaseUrl, supabaseAnonKey);

// Helper function to generate the ZIP blob (extracted from export function)
async function generateParcelDataZipBlob(features, internalJsonFilename) {
    if (!features || features.length === 0) {
        throw new Error("Нет данных для создания ZIP.");
    }

    const jsonData = JSON.stringify(features, null, 2);

    const zip = new JSZip();
    zip.file(internalJsonFilename, jsonData);

    const zipBlob = await zip.generateAsync({
        type: "blob",
        compression: "DEFLATE",
        compressionOptions: {
            level: 9 // Max compression level
        }
    });

    return zipBlob;
}

async function uploadNspdDataToLocalServer(features, quarterNumber) {
    if (!features || features.length === 0) {
    //    console.log("Нет данных для выгрузки на сервер.");
        return;
    }
    if (!quarterNumber) {
        console.error("Не указан номер квартала для создания имени файла, выгрузка отменена.");
        return;
    }

  //  console.log(`Подготовка к выгрузке ${features.length} участков для квартала ${quarterNumber} на mapruapp.ru...`);

    try {
        const quarterName = quarterNumber.replace(/:/g, '_');
        const today = new Date();
        const dateString = today.getFullYear() + '-' +
                       String(today.getMonth() + 1).padStart(2, '0') + '-' +
                       String(today.getDate()).padStart(2, '0');
        
        const zipFilename = `${quarterName}.nspd`;
        const internalJsonFilename = `${quarterName} ${dateString}.json`;

        const jsonData = JSON.stringify(features, null, 2);
        const zip = new JSZip();
        zip.file(internalJsonFilename, jsonData);
        
        const zipBlob = await zip.generateAsync({
            type: "blob",
            compression: "DEFLATE",
            compressionOptions: {
                level: 9
            }
        });

        const formData = new FormData();
        formData.append('file', new File([zipBlob], zipFilename, { type: 'application/zip' }));

        const response = await fetch(`${STORAGE_API_URL}/nspd/upload`, {
            method: 'POST',
            body: formData,
        });

        if (!response.ok) {
            // Если сервер вернул ошибку, пытаемся прочитать ее и выбросить
            const errorData = await response.json().catch(() => null); // .catch на случай, если ответ не JSON
            throw new Error(errorData?.error || `Сервер ответил ошибкой: ${response.statusText}`);
        }
        
        const responseData = await response.json();
 //       console.log(`Архив ${zipFilename} успешно выгружен на сервер.`, responseData);
       

    } catch (error) {
       
        console.error(`ФОНОВАЯ ОШИБКА: Не удалось выгрузить данные NSPD на сервер. Причина:`, error.message);
    }
}


function updatePolygonStyle() {
    polygonStyle.color = document.getElementById('lineColor').value;
    polygonStyle.width = parseInt(document.getElementById('lineWidth').value);
    polygonStyle.parcelsColor = document.getElementById('parcelsColor').value;
    polygonStyle.declaredParcelsColor = document.getElementById('declaredParcelsColor').value;
   polygonStyle.buildingsColor = document.getElementById('buildingsColor').value;
     polygonStyle.structuresColor = document.getElementById('structuresColor').value;
     
    
    localStorage.setItem('polygonColor', polygonStyle.color);
    localStorage.setItem('polygonWidth', polygonStyle.width);
    localStorage.setItem('parcelsColor', polygonStyle.parcelsColor);
    localStorage.setItem('declaredParcelsColor', polygonStyle.declaredParcelsColor);
   localStorage.setItem('buildingsColor', polygonStyle.buildingsColor);
      localStorage.setItem('structuresColor', polygonStyle.structuresColor); 
 

    // Re-apply strokes based on new colors/width
    if (polygons && polygons.length > 0) {
        polygons.forEach(polygon => {
            if (polygon instanceof ymaps.Polygon) {
                if (polygon.properties.get('isParcelInQuarter') || polygon.properties.get('isFoundInArea')) { // Check both flags
                            const featureData = polygon.properties.get('featureData');
                     const parcelOptions = featureData?.properties?.options || {};
                     const isVerified = parcelOptions.specified_area || parcelOptions.land_record_area_verified;
                     const hasDeclaredField = parcelOptions.declared_area || parcelOptions.land_record_area_declaration || parcelOptions.land_record_area;
                     const isDeclared = !isVerified && hasDeclaredField;
                     const strokeColor = isDeclared ? polygonStyle.declaredParcelsColor : polygonStyle.parcelsColor;
                    
                    polygon.options.set({
                        strokeColor: strokeColor,
                        strokeWidth: polygonStyle.width - 1
                    });
                } 
                
            
           else if (polygon.properties.get('isBuilding')) { // Проверяем флаг для Зданий
    polygon.options.set({
        strokeColor: polygonStyle.buildingsColor, // Применяем цвет для Зданий
        strokeWidth: polygonStyle.width - 1
                    });
                } 
                
                    else if (polygon.properties.get('isStructure')) { // Проверяем флаг для Сооружений
                    polygon.options.set({
                        strokeColor: polygonStyle.structuresColor, // Применяем цвет для Сооружений
                        strokeWidth: polygonStyle.width - 1
                    });
                } 
                // <!-- КОНЕЦ НОВОГО БЛОКА -->
                else if (polygon.options.get('strokeStyle') !== 'dash') { // Don't change style of quarter outlines or specific drawings
                    polygon.options.set({
                        strokeColor: polygonStyle.color,
                        strokeWidth: polygonStyle.width
                    });
                }
            }
        });
    }
    applyCurrentTheme(); 
}

function updateMapOffset() {
            // --- НАЧАЛО ИЗМЕНЕНИЙ ---
            // Принудительно заменяем запятую на точку перед парсингом
            const offsetXValue = document.getElementById('mapOffsetX').value.replace(',', '.');
            const offsetYValue = document.getElementById('mapOffsetY').value.replace(',', '.');

            mapOffsetX = parseFloat(offsetXValue) || 0; // Используем || 0 для защиты от NaN
            mapOffsetY = parseFloat(offsetYValue) || 0;
            // --- КОНЕЦ ИЗМЕНЕНИЙ ---
            
            localStorage.setItem('mapOffsetX', mapOffsetX);
            localStorage.setItem('mapOffsetY', mapOffsetY);
            findAndConvert();
        }


        proj4.defs("EPSG:3857", "+proj=merc +a=6378137 +b=6378137 +lat_ts=0.0 +lon_0=0.0 +x_0=0.0 +y_0=0 +k=1.0 +units=m +nadgrids=@null +wktext +no_defs");
        proj4.defs("EPSG:4326", "+proj=longlat +datum=WGS84 +no_defs");
        proj4.defs("MSK16_ZONE2",
            "+proj=tmerc " +
            "+lat_0=0 " +
            "+lon_0=52.033333333333 " +
            "+k=1 " +
            "+x_0=2300000 " +
            "+y_0=-5709414.70 " +
            "+ellps=krass " +
            "+towgs84=23.57,-140.95,-79.8,0,-0.35,-0.79,-0.22 " +
            "+units=m " +
            "+no_defs " +
            "+axis=enu"
        );

        proj4.defs("MSK16_ZONE1",
            "+proj=tmerc " +
            "+lat_0=0 " +
            "+lon_0=49.033333333333 " +
            "+k=1 " +
            "+x_0=1300000 " +
            "+y_0=-5709414.70 " +
            "+ellps=krass " +
            "+towgs84=23.57,-140.95,-79.8,0,-0.35,-0.79,-0.22 " +
            "+units=m " +
            "+no_defs " +
            "+axis=enu"
        );


function parseCoordinates(text) {
    if (!text || typeof text !== 'string') {
        return [];
    }
    
    try {
        // Разделяем на группы по пустым строкам
        const groups = text.split(/\n\s*\n/)
            .map(group => group.trim())
            .filter(group => group !== '');
        
        return groups.map(group => {
            const lines = group.split('\n')
                .map(line => line.trim())
                .filter(line => line !== '');
            
            return lines.map(line => {
                const parts = line.split(/[\s\t]+/);
                
                if (parts.length < 2) {
                    console.warn(`Пропущена некорректная строка: "${line}"`);
                    return null;
                }
                
                const x = parseFloat(parts[0]);
                const y = parseFloat(parts[1]);
                
                if (!isFinite(x) || !isFinite(y)) {
                    console.warn(`Пропущены некорректные координаты: x=${parts[0]}, y=${parts[1]}`);
                    return null;
                }
                
                return [x, y];
            }).filter(coord => coord !== null);
        }).filter(group => group.length > 0);
    } catch (e) {
        console.error('Ошибка при разборе координат:', e);
        return [];
    }
}


function generateKmlForSinglePolygon(polygonObject, placemarkNameOverride = null) {
    const yandexCoordsSmeschennyeNaKarte = polygonObject.geometry.getCoordinates()[0];

    // --- ВОЗВРАЩАЕМ КООРДИНАТЫ К ИСТИННЫМ WGS84, "УБИРАЯ" ТВОЮ КОМПЕНСАЦИЮ ---
    const istinnyeWGS84Coords = yandexCoordsSmeschennyeNaKarte.map(coord => {
        return [
            coord[0] + (mapOffsetY * 0.000008983),
            coord[1] + (mapOffsetX * 0.000008983)
        ];
    });

    // --- ПРИМЕНЯЕМ KML СМЕЩЕНИЯ К "ИСТИННЫМ" WGS84 КООРДИНАТАМ ---
    const kmlAdjustedWGS84Coords = istinnyeWGS84Coords.map(coord => {
        return [
            coord[0] + (kmlMapOffsetY * 0.000008983), // KML широта (+/- в зависимости от знака kmlMapOffsetY)
            coord[1] + (kmlMapOffsetX * 0.000008983)  // KML долгота (+/- в зависимости от знака kmlMapOffsetX)
        ];
    });
    // --- КОНЕЦ ПРИМЕНЕНИЯ KML СМЕЩЕНИЙ ---

    // Используем kmlAdjustedWGS84Coords для генерации KML
    const kmlCoordsArray = kmlAdjustedWGS84Coords.map(coord => `${coord[1]},${coord[0]},0`);

    // --- Важно: Убедимся, что полигон замкнут с kmlAdjustedWGS84Coords ---
    if (kmlCoordsArray.length > 0 &&
        (kmlAdjustedWGS84Coords[0][0] !== kmlAdjustedWGS84Coords[kmlAdjustedWGS84Coords.length - 1][0] ||
         kmlAdjustedWGS84Coords[0][1] !== kmlAdjustedWGS84Coords[kmlAdjustedWGS84Coords.length - 1][1])) {
        kmlCoordsArray.push(`${kmlAdjustedWGS84Coords[0][1]},${kmlAdjustedWGS84Coords[0][0]},0`);
    }
    // --- КОНЕЦ ВАЖНОЙ ПРОВЕРКИ ---

    const kmlCoordsString = kmlCoordsArray.join(' ');

    const placemarkName = placemarkNameOverride ||
                          polygonObject.properties.get('cadastralNumber') ||
                          polygonObject.properties.get('hintContent')?.cadastralNumber ||
                          'Polygon';
    const safePlacemarkName = placemarkName.replace(/[^a-zA-Z0-9_.:-]/g, '_');

    let kmlStrokeColor = "ff0000ff";
    let kmlFillColor = "00000000";
    let kmlFillEnabled = 0;
    const kmlStrokeWidth = polygonObject.options.get('strokeWidth') || 2;

    const originalStrokeColor = polygonObject.options.get('strokeColor');
    if (originalStrokeColor) {
        if (originalStrokeColor.length === 7) {
            kmlStrokeColor = `ff${originalStrokeColor.substring(5, 7)}${originalStrokeColor.substring(3, 5)}${originalStrokeColor.substring(1, 3)}`;
        } else if (originalStrokeColor.length === 9) {
            kmlStrokeColor = `${originalStrokeColor.substring(7, 9)}${originalStrokeColor.substring(5, 7)}${originalStrokeColor.substring(3, 5)}${originalStrokeColor.substring(1, 3)}`;
        }
    }

    const originalFillColor = polygonObject.options.get('fillColor');
    if (originalFillColor && originalFillColor !== '#00000000') {
        kmlFillEnabled = 1;
        if (originalFillColor.length === 7) {
            kmlFillColor = `ff${originalFillColor.substring(5, 7)}${originalFillColor.substring(3, 5)}${originalFillColor.substring(1, 3)}`;
        } else if (originalFillColor.length === 9) {
            kmlFillColor = `${originalFillColor.substring(7, 9)}${originalFillColor.substring(5, 7)}${originalFillColor.substring(3, 5)}${originalFillColor.substring(1, 3)}`;
        } else if (originalFillColor.length === 4) {
            const r = originalFillColor[1]; const g = originalFillColor[2]; const b = originalFillColor[3];
            kmlFillColor = `ff${b}${b}${g}${g}${r}${r}`;
        } else if (originalFillColor.length === 5) {
            const r = originalFillColor[1]; const g = originalFillColor[2]; const b = originalFillColor[3]; const a = originalFillColor[4];
            kmlFillColor = `${a}${a}${b}${b}${g}${g}${r}${r}`;
        }
    }

    return `
    <Placemark>
      <name>${escapeXml(placemarkName)}</name>
      <Style>
        <LineStyle>
          <color>${kmlStrokeColor}</color>
          <width>${kmlStrokeWidth}</width>
        </LineStyle>
        <PolyStyle>
          <color>${kmlFillColor}</color>
          <fill>${kmlFillEnabled}</fill>
          <outline>1</outline>
        </PolyStyle>
      </Style>
      <Polygon>
        <outerBoundaryIs>
          <LinearRing>
            <coordinates>
              ${kmlCoordsString}
            </coordinates>
          </LinearRing>
        </outerBoundaryIs>
      </Polygon>
    </Placemark>`;
}


// Helper to escape XML special characters for KML content
function escapeXml(unsafe) {
    if (typeof unsafe !== 'string') return '';
    return unsafe.replace(/[<>&'"]/g, function (c) {
        switch (c) {
            case '<': return '&lt;';
            case '>': return '&gt;';
            case '&': return '&amp;';
            case '\'': return '&apos;';
            case '"': return '&quot;';
        }
        return c; // Должно быть здесь, на случай если символ не требует замены
    });
}

function autoUpdateMskSettings(cadastralNumber) {
    // 1. Проверяем, включена ли опция в настройках.
    // Читаем из localStorage, так как модальное окно может быть не открыто.
    const isAutoLoadEnabled = (localStorage.getItem('autoLoadMskOffset') !== 'false');
    if (!isAutoLoadEnabled) {
        console.log("Автообновление МСК отключено в настройках.");
        return; // Выходим, если опция выключена
    }

    // 2. Проверяем, что все нужные скрипты загружены
    if (typeof MskFinder === 'undefined' || typeof COORDINATE_SYSTEMS === 'undefined') {
        console.error("Необходимые для автоопределения МСК данные (MskFinder или COORDINATE_SYSTEMS) не загружены.");
        return;
    }

    // 3. Используем MskFinder для поиска кода (например, "16-2")
    const mskCode = MskFinder.findMskCode(cadastralNumber);
    if (!mskCode) {
        console.log(`Код МСК для '${cadastralNumber}' не найден в msk-data.js.`);
        return; // Ничего не делаем, если код не найден
    }

    // 4. Ищем соответствующую систему координат в sk.js
    const searchString = `МСК ${mskCode}`; // Формируем строку для поиска, например, "МСК 16-2"
    const foundSystem = COORDINATE_SYSTEMS.find(system => system.text.includes(searchString));

    if (foundSystem) {
        const currentDefaultMsk = localStorage.getItem('savedDefaultMskSystem');
        
        // 5. Обновляем настройки, только если найденная система отличается от текущей
        if (currentDefaultMsk !== foundSystem.value) {
            // Сохраняем новую МСК по умолчанию
            localStorage.setItem('savedDefaultMskSystem', foundSystem.value);

            // Сохраняем смещения, связанные с этой новой МСК
            const newOffsetX = String(foundSystem.offsetX || '0').replace(',', '.');
            const newOffsetY = String(foundSystem.offsetY || '0').replace(',', '.');
            localStorage.setItem('savedMskOffsetX', newOffsetX);
            localStorage.setItem('savedMskOffsetY', newOffsetY);
            
            // Уведомляем пользователя
            const systemName = foundSystem.text.split('(')[0].trim();
            showNotification(`МСК по умолчанию обновлена: ${systemName}`, 'success', 'info-circle');
            console.log(`Настройки МСК обновлены на ${foundSystem.value}. Смещения: X=${newOffsetX}, Y=${newOffsetY}`);
        }
    } else {
        console.warn(`Не удалось найти СК для кода '${mskCode}' в файле sk.js.`);
    }
}

       function showNotification(message, type = 'success', icon = 'info-circle', duration = 3000) {
            // Удаляем предыдущее уведомление, если оно есть
            const existingNotification = document.querySelector('.notification');
            if (existingNotification) {
                existingNotification.remove();
            }

            // Создаем новое уведомление
            const notification = document.createElement('div');
            notification.className = `notification ${type}`;
            notification.innerHTML = `
        <i class="fas fa-${icon}"></i>
        ${message}
    `;
            document.body.appendChild(notification);

            // Показываем уведомление
            setTimeout(() => notification.classList.add('show'), 10);

            // Скрываем и удаляем через заданное время (duration)
            setTimeout(() => {
                notification.classList.remove('show');
                setTimeout(() => notification.remove(), 500);
            }, duration);
        }
        
        function removeEmptyLinesFromCoordsInput() {
    const coordsText = coordsInput.value;
    const cleanedCoordsText = coordsText.split('\n')
                                       .filter(line => line.trim() !== '')
                                       .join('\n');
    coordsInput.value = cleanedCoordsText;
}

function findAndConvert() {
    if (!map) {
        console.error('Карта не инициализирована');
        return;
    }

    try {
        const coordsText = coordsInput.value.trim();
        if (!coordsText) return;

        animateMapZoom();
        const coordGroups = parseCoordinates(coordsText);
        if (coordGroups.length === 0) return;

        let geoGroups = [];
        const detectedMskSystem = findMskSystemByTemplate(coordsText);

        if (detectedMskSystem) {
            // Эта часть кода для автоопределения по шаблону, она уже работает с учетом смещений,
            // поэтому оставляем ее как есть.
            const sourceSc = detectedMskSystem;
            console.log(`Применяется СК, найденная по шаблону: ${sourceSc}`);
            const sourceDef = COORDINATE_SYSTEMS.find(s => s.value === sourceSc)?.def;
            if (!sourceDef) throw new Error(`Определение для ${sourceSc} не найдено в sk.js`);
            proj4.defs(sourceSc, sourceDef);
            const selectedSystem = COORDINATE_SYSTEMS.find(s => s.value === sourceSc);
            const offsetX = selectedSystem?.offsetX || 0;
            const offsetY = selectedSystem?.offsetY || 0;
            coordGroups.forEach(group => {
                const geoGroup = group.map(coord => {
                    const inputForProj4 = [coord[1], coord[0]];
                    const point3857 = proj4(sourceSc, "EPSG:3857", inputForProj4);
                    point3857[0] += offsetX;
                    point3857[1] += offsetY;
                    const finalWgs84 = proj4("EPSG:3857", "EPSG:4326", point3857);
                    return [finalWgs84[1], finalWgs84[0]];
                });
                geoGroups.push(geoGroup);
            });
        
        } else {
            // --- ОСНОВНАЯ ЛОГИКА И ИСПРАВЛЕНИЯ ЗДЕСЬ ---
            console.log("Шаблоны не сработали, используется стандартное определение СК.");
            const firstCoord = coordGroups[0][0];
            const x = firstCoord[0];
            const y = firstCoord[1];
            
            const hasLongDecimal = (num) => num.toString().includes('.') && num.toString().split('.')[1].length > 3;

            if (Math.abs(x) > 100 && Math.abs(y) > 100 && (hasLongDecimal(x) || hasLongDecimal(y))) {
                console.log("Определена система: EPSG:3857 (по формату)");
                coordGroups.forEach(group => {
                    const geoGroup = group.map(coord => {
                        const wgs84 = proj4("EPSG:3857", "EPSG:4326", [coord[0], coord[1]]);
                        return [wgs84[1], wgs84[0]];
                    });
                    geoGroups.push(geoGroup);
                });
            }
            else if ((Math.abs(x) <= 90 && Math.abs(y) <= 180) || (Math.abs(x) <= 180 && Math.abs(y) <= 90)) {
                console.log("Определена система: WGS84 (географические)");
                const needsSwap = Math.abs(x) > 90;
                coordGroups.forEach(group => {
                    const geoGroup = group.map(coord => {
                        const lon = needsSwap ? coord[0] : coord[1];
                        const lat = needsSwap ? coord[1] : coord[0];
                        return [lat, lon];
                    });
                    geoGroups.push(geoGroup);
                });
            }
            else {
                // --- БЛОК ОБРАБОТКИ МСК ---
                const sourceSc = localStorage.getItem('savedDefaultMskSystem') || 'EPSG:6331602';
                console.log(`Определена система: МСК (по умолчанию из localStorage), используется ${sourceSc}`);

                // Загружаем смещения.
                const mskOffsetX = parseFloat((localStorage.getItem('savedMskOffsetX') || '0').replace(',', '.')) || 0;
                const mskOffsetY = parseFloat((localStorage.getItem('savedMskOffsetY') || '0').replace(',', '.')) || 0;

                const sourceDef = COORDINATE_SYSTEMS.find(s => s.value === sourceSc)?.def;
                if (!sourceDef) throw new Error(`Определение для ${sourceSc} не найдено в sk.js`);
                proj4.defs(sourceSc, sourceDef);

                geoGroups = coordGroups.map(group => {
                    return group.map(coord => {
                        // В вашем коде первая колонка X (Northing), вторая Y (Easting).
                        const x_input_msk = coord[0]; 
                        const y_input_msk = coord[1];

                        console.log(`--- [findAndConvert] Начало конвертации точки ---`);
                        console.log(`Шаг 1: Исходные МСК: X=${x_input_msk.toFixed(4)}, Y=${y_input_msk.toFixed(4)}`);
                        console.log(`Шаг 2: Загруженное смещение: mskOffsetX = ${mskOffsetX}, mskOffsetY = ${mskOffsetY}`);

                        // --- ФИНАЛЬНОЕ ИСПРАВЛЕНИЕ: ВЫЧИТАЕМ ОБА СМЕЩЕНИЯ ---
                        const corrected_x_msk = x_input_msk - mskOffsetX;
                        const corrected_y_msk = y_input_msk - mskOffsetY;

                        console.log(`Шаг 3: Скорректированные МСК (X-mskOffsetX, Y-mskOffsetY): X=${corrected_x_msk.toFixed(4)}, Y=${corrected_y_msk.toFixed(4)}`);

                        // Proj4 с определением "+axis=enu" ожидает координаты в порядке [Y (Easting), X (Northing)]
                        const point3857 = proj4(sourceSc, "EPSG:3857", [corrected_y_msk, corrected_x_msk]);
                        
                        console.log(`Шаг 4: Промежуточный результат в EPSG:3857: X=${point3857[0].toFixed(4)}, Y=${point3857[1].toFixed(4)}`);

                        const finalWgs84 = proj4("EPSG:3857", "EPSG:4326", point3857);
                        console.log(`Шаг 5: Финальный результат в WGS84 (для карты): lat=${finalWgs84[1].toFixed(8)}, lon=${finalWgs84[0].toFixed(8)}`);
                        console.log(`--- [findAndConvert] Конец конвертации точки ---`);
                        
                        return [finalWgs84[1], finalWgs84[0]]; // [lat, lon]
                    });
                });
            }
        }
        
        fillAuxiliaryTextareas(coordGroups, geoGroups);
        drawFeatures(geoGroups);

    } catch (error) {
        console.error('Ошибка обработки координат:', error);
        convertedTextarea.value = "Ошибка: " + error.message;
        geoTextarea.value = "";
        showNotification('Ошибка обработки координат', 'error', 'exclamation-circle');
    }
}

// ДОБАВЬТЕ ЭТУ НОВУЮ ВСПОМОГАТЕЛЬНУЮ ФУНКЦИЮ
function fillAuxiliaryTextareas(originalCoordGroups, geoGroups) {
    let convertedText = '';
    let geoText = '';

    geoGroups.forEach((group, groupIndex) => {
        group.forEach(geoCoord => {
            const result3857 = proj4("EPSG:4326", "EPSG:3857", [geoCoord[1], geoCoord[0]]); // [lon, lat]
            convertedText += `${result3857[0].toFixed(4)}\t${result3857[1].toFixed(4)}\n`;
            geoText += `${geoCoord[0].toFixed(8)}\t${geoCoord[1].toFixed(8)}\n`;
        });
        if (groupIndex < geoGroups.length - 1) {
            convertedText += '\n';
            geoText += '\n';
        }
    });

    convertedTextarea.value = convertedText.trim();
    geoTextarea.value = geoText.trim();
}


   function isValidCadastralNumber(text) {
    const pattern = new RegExp(`^\\d{2}:\\d{2}:\\d{6,7}:\\d+$`);
    return pattern.test(text);
}


  // Глобальная переменная для кастомного макета метки
let customPlacemarkLayout;
let numberedPointLayout; 
let redDotLayout; 

document.addEventListener('DOMContentLoaded', async () => {
    
    
    try {
        await navigator.permissions.query({ name: 'clipboard-read' });
        ymaps.ready(function () {
            try {
                if (!ymaps || !ymaps.templateLayoutFactory) {
                    console.error('Yandex Maps API не загружен. Проверьте ключ API и подключение.');
                    return;
                }

                // Кастомный макет для метки
                customPlacemarkLayout = ymaps.templateLayoutFactory.createClass(
                    '<div class="custom-placemark" style="position: absolute; font-family: sans-serif; user-select: none; transform: scale(1); transform-origin: center; text-align: center;">$[properties.iconContent]</div>',
                    {
                        build: function () {
                            this.constructor.superclass.build.call(this);
                            const element = this.getParentElement().querySelector('.custom-placemark');
                            // Устанавливаем начальный размер текста по умолчанию, если карта еще не доступна
                            const defaultFontSize = 12; // Начальный размер текста
                            element.style.fontSize = `${defaultFontSize}px`;
                            element.style.color = '#000';
                            element.style.textShadow = '-1px -1px 0 #fff, 1px -1px 0 #fff, -1px 1px 0 #fff, 1px 1px 0 #fff, 0 0 2px #fff';
                            
                            // Проверяем, доступна ли карта, и обновляем размер текста
                            const map = this.getData().options.get('map');
                            if (map) {
                                const zoom = map.getZoom();
                                const fontSize = Math.max(10, Math.min(16, 8 + zoom * 0.4));
                                element.style.fontSize = `${fontSize}px`;
                            }
                        },
                        // Обновление при изменении карты
                        onMapChange: function () {
                            const element = this.getParentElement().querySelector('.custom-placemark');
                            const map = this.getData().options.get('map');
                            if (map) {
                                const zoom = map.getZoom();
                                const fontSize = Math.max(10, Math.min(16, 8 + zoom * 0.4));
                                element.style.fontSize = `${fontSize}px`;
                            }
                        },
                        // Убедимся, что форма применяется корректно
                        update: function () {
                            this.constructor.superclass.update.call(this);
                            const element = this.getParentElement().querySelector('.custom-placemark');
                            const map = this.getData().options.get('map');
                            if (map) {
                                const zoom = map.getZoom();
                                const fontSize = Math.max(10, Math.min(16, 8 + zoom * 0.4));
                                element.style.fontSize = `${fontSize}px`;
                            }
                        }
                    }
                );
                
            
                              // Кастомный макет для нумерованных точек (н1, н2...)
                numberedPointLayout = ymaps.templateLayoutFactory.createClass(
                    // Добавляем инлайновый стиль для размера шрифта, который берется из свойств метки
                    '<div class="numbered-point-label" style="font-size: $[properties.fontSize]px;">$[properties.iconContent]</div>'
                );

  redDotLayout = ymaps.templateLayoutFactory.createClass(
                    // <-- ИЗМЕНЕНО: Добавляем инлайновые стили для ширины и высоты
                    '<div class="custom-red-dot" style="width: $[properties.dotSize]px; height: $[properties.dotSize]px;"></div>'
                );
                
                // Кастомный макет для подсказки (без изменений)
                    customHintLayout = ymaps.templateLayoutFactory.createClass(
                    '<div class="custom-hint" style="min-width: 220px;">' +
                        '<strong>$[properties.hintContent.cadastralNumber]</strong>' +
                        '<div class="hint-address">$[properties.hintContent.address]</div>' +
                        '<div class="hint-area">$[properties.hintContent.area]</div>' +
                        // --- НАЧАЛО ИЗМЕНЕНИЙ: Добавляем новые поля для ОКС и ЗУ ---
                        '{% if properties.hintContent.cost %} <div class="hint-cost">Стоимость: $[properties.hintContent.cost] руб./м²</div> {% endif %}' +
                        '{% if properties.hintContent.vri %} <div class="hint-vri" style="color: #1e88e5;">ВРИ: $[properties.hintContent.vri]</div> {% endif %}' +
                        '{% if properties.hintContent.purpose %} <div class="hint-purpose" style="color: #1e88e5;">Назначение: $[properties.hintContent.purpose]</div> {% endif %}' +
                        '{% if properties.hintContent.ownershipType %} <div class="hint-ownership" style="color: #4a5568;">Форма собственности: $[properties.hintContent.ownershipType]</div> {% endif %}' +
                        '{% if properties.hintContent.rightType %} <div class="hint-right" style="color: #4a5568;">Тип права: $[properties.hintContent.rightType]</div> {% endif %}' +
                        '{% if properties.hintContent.yearBuilt %} <div class="hint-year" style="color: #4a5568;">Год постройки: $[properties.hintContent.yearBuilt]</div> {% endif %}' +
                        '{% if properties.hintContent.materials %} <div class="hint-materials" style="color: #4a5568;">Материал стен: $[properties.hintContent.materials]</div> {% endif %}' +
                        '{% if properties.hintContent.floors %} <div class="hint-floors" style="color: #4a5568;">Этажность: $[properties.hintContent.floors]</div> {% endif %}' +
                        // --- КОНЕЦ ИЗМЕНЕНИЙ ---
                    '</div>',
                    {
                        build: function () {
                            this.constructor.superclass.build.call(this);
                        },
                        clear: function () {
                            this.constructor.superclass.clear.call(this);
                        }
                    }
                );
                
            

                initMap();
                readFromClipboard().then(() => {
                    if (isValidCadastralNumber(cityInput.value.trim())) {
                        const event = new KeyboardEvent('keydown', {
                            key: 'Enter',
                            code: 'Enter',
                            which: 13,
                            keyCode: 13,
                            bubbles: true
                        });
                        cityInput.dispatchEvent(event);
                    } else {
                        findAndConvert();
                    }
                });
            } catch (error) {
                console.error('Error initializing map:', error);
            }
        });
    } catch (error) {
        console.error('Clipboard permission error:', error);
    }
});


async function fetchCadastralData(cadastralNumber) {
    const url = `https://nspd.gov.ru/api/geoportal/v2/search/geoportal?thematicSearchId=1&query=${cadastralNumber}`;

    try {
        const response = await fetchNspd(url);
        const data = await response.json();

   //     console.log('NSPD Data:', data);

        if (!data.data.features || data.data.features.length === 0) {
            console.error('Данные не найдены');
            return null;
        }

        return data.data.features[0];
    } catch (error) {
        console.error('Ошибка при получении данных:', error);
        return null;
    }
}



        function getAddressByCoords(coords) {
            return ymaps.geocode(coords).then(function (res) {
                const firstGeoObject = res.geoObjects.get(0);
                if (firstGeoObject) {
                    return firstGeoObject.getAddressLine();
                }
                return 'Адрес не найден';
            });
        }

        async function getCadastralNumber(lat, lon) {
            const cadastralData = await queryCadastralInfo(lat, lon);
            if (cadastralData && cadastralData.features && cadastralData.features.length > 0) {
                return cadastralData.features[0].properties.descr;
            }
            return null;
        }




    



async function drawFeatures(geoCoordinates) {
    try {
        if (!geoCoordinates || !Array.isArray(geoCoordinates) || geoCoordinates.length === 0) {
            console.warn('Нет координат для отрисовки');
            return;
        }

        let allBounds = [];
        
        for (const coordGroup of geoCoordinates) {
            if (!Array.isArray(coordGroup) || coordGroup.length === 0) continue;

            const validCoords = coordGroup
                .map(coord => {
                    if (Array.isArray(coord) && coord.length === 2 && isFinite(coord[0]) && isFinite(coord[1])) {
                        return [coord[0] - mapOffsetY * 0.000008983, coord[1] - mapOffsetX * 0.000008983];
                    }
                    return null;
                })
                .filter(Boolean);

            if (validCoords.length === 0) continue;

            const isPolygon = validCoords.length > 2 &&
                Math.abs(validCoords[0][0] - validCoords[validCoords.length - 1][0]) < 1e-9 &&
                Math.abs(validCoords[0][1] - validCoords[validCoords.length - 1][1]) < 1e-9;

            if (isPolygon) {
                const polygonObj = new ymaps.Polygon([validCoords], {
                    isManuallyDrawn: true // Новый флаг для идентификации
                }, {
                    strokeColor: polygonStyle.color,
                    strokeWidth: polygonStyle.width,
                    strokeOpacity: 0.8,
                    fillColor: '#00000000'
                });

                map.geoObjects.add(polygonObj);
                polygons.push(polygonObj);
                const bounds = polygonObj.geometry.getBounds();
                if (bounds) allBounds.push(bounds);

            } else if (validCoords.length > 1) {
                const polyline = new ymaps.Polyline(validCoords, {}, {
                    strokeColor: polygonStyle.color,
                    strokeWidth: polygonStyle.width,
                    strokeOpacity: 0.8
                });
                map.geoObjects.add(polyline);
                polygons.push(polyline);
                const bounds = polyline.geometry.getBounds();
                if (bounds) allBounds.push(bounds);
            } else if (validCoords.length === 1) {
                const placemark = new ymaps.Placemark(validCoords[0], {}, {
                    preset: 'islands#blueDotIcon'
                });
                map.geoObjects.add(placemark);
                polygons.push(placemark);
                allBounds.push([validCoords[0], validCoords[0]]);
            }
        }

        if (allBounds.length > 0) {
            let minLat = Infinity, minLng = Infinity, maxLat = -Infinity, maxLng = -Infinity;
            allBounds.forEach(bounds => {
                minLat = Math.min(minLat, bounds[0][0]);
                minLng = Math.min(minLng, bounds[0][1]);
                maxLat = Math.max(maxLat, bounds[1][0]);
                maxLng = Math.max(maxLng, bounds[1][1]);
            });

            if (isFinite(minLat)) {
                const latMargin = (maxLat - minLat) * 0.1 || 0.001;
                const lonMargin = (maxLng - minLng) * 0.1 || 0.001;
                const viewBounds = [
                    [minLat - latMargin, minLng - lonMargin],
                    [maxLat + latMargin, maxLng + lonMargin]
                ];
                map.setBounds(viewBounds, { checkZoomRange: true, duration: 200 });
            }
        }
    } catch (error) {
        console.error('Ошибка отрисовки объекта:', error);
        showNotification('Ошибка отрисовки объекта', 'error', 'exclamation-circle');
    }
}


        function formatDistance(distance) {
            if (distance < 1000) {
                return `${distance.toFixed(2)} м`;
            } else {
                return `${(distance / 1000).toFixed(2)} км`;
            }
        }

        let totalDistance = 0;
        let segments = [];

function measureDistance() {
    if (distanceMeasurementActive) {
        stopDistanceMeasurement();
        return;
    }
    distanceMeasurementActive = true;
    distancePoints = [];
    totalDistance = 0;
    segments = [];
    // Не вызываем clearDistanceMeasurement(), чтобы не удалять все объекты
    mapElement.classList.add('measuring-distance');
    map.events.add('click', onMapClickForDistance);
    map.events.add('dblclick', onMapDoubleClickForDistance);
}

// НОВАЯ ФУНКЦИЯ для генерации KML для полилинии
function generateKmlForPolyline(polylineObject, placemarkName) {
    const yandexCoordsSmeschennyeNaKarte = polylineObject.geometry.getCoordinates(); // Это массив точек [lat, lon]

    // --- ВОЗВРАЩАЕМ КООРДИНАТЫ К ИСТИННЫМ WGS84 ---
    const istinnyeWGS84Coords = yandexCoordsSmeschennyeNaKarte.map(coord => {
        return [
            coord[0] + (mapOffsetY * 0.000008983),
            coord[1] + (mapOffsetX * 0.000008983)
        ];
    });

    // --- ПРИМЕНЯЕМ KML СМЕЩЕНИЯ К "ИСТИННЫМ" WGS84 КООРДИНАТАМ ---
    const kmlAdjustedWGS84Coords = istinnyeWGS84Coords.map(coord => {
        return [
            coord[0] + (kmlMapOffsetY * 0.000008983), // KML широта
            coord[1] + (kmlMapOffsetX * 0.000008983)  // KML долгота
        ];
    });

    const kmlCoordsArray = kmlAdjustedWGS84Coords.map(coord => `${coord[1]},${coord[0]},0`); // lon,lat,alt
    const kmlCoordsString = kmlCoordsArray.join(' ');

    const safePlacemarkName = placemarkName.replace(/[^a-zA-Z0-9_.:-]/g, '_');

    let kmlStrokeColor = "ff0000ff"; // AABBGGRR - Красный по умолчанию
    const kmlStrokeWidth = polylineObject.options.get('strokeWidth') || 2;

    const originalStrokeColor = polylineObject.options.get('strokeColor');
    if (originalStrokeColor) {
        if (originalStrokeColor.length === 7) { // #RRGGBB
            kmlStrokeColor = `ff${originalStrokeColor.substring(5, 7)}${originalStrokeColor.substring(3, 5)}${originalStrokeColor.substring(1, 3)}`;
        } else if (originalStrokeColor.length === 9) { // #AARRGGBB
            kmlStrokeColor = `${originalStrokeColor.substring(7, 9)}${originalStrokeColor.substring(5, 7)}${originalStrokeColor.substring(3, 5)}${originalStrokeColor.substring(1, 3)}`;
        }
    }
    
    // Для LineString LabelStyle не используется для отображения имени вдоль линии в Google Earth,
    // имя отображается в списке объектов.
    // Если нужен текст прямо на карте рядом с линией, это делается отдельным Placemark с Point.
    const kmlStyleXml = `
      <Style>
        <LineStyle>
          <color>${kmlStrokeColor}</color>
          <width>${kmlStrokeWidth}</width>
        </LineStyle>
        <IconStyle><scale>0</scale></IconStyle> <!-- Скрываем иконку по умолчанию для линий -->
         <LabelStyle><scale>0.8</scale></LabelStyle> <!-- Масштаб имени в списке -->
      </Style>`;

    return `
    <Placemark>
      <name>${escapeXml(safePlacemarkName)}</name>
      ${kmlStyleXml}
      <LineString>
        <tessellate>1</tessellate>
        <coordinates>
          ${kmlCoordsString}
        </coordinates>
      </LineString>
    </Placemark>`;
}


// ИЗМЕНЕННАЯ ФУНКЦИЯ exportAllMapObjectsToKml
function exportAllMapObjectsToKml() {
    if (!map) {
        showNotification('Карта не инициализирована', 'error');
        return;
    }

    const kmlPlacemarks = [];
    let polygonIndex = 1;
    let lineIndex = 1; // Индекс для линий
    let placemarkIndex = 1;
    let textIndex = 1;

    const uniqueYandexGeoObjects = new Set();

    // Собираем все полигоны, полилинии и метки из polygons
    polygons.forEach(obj => {
        if (obj instanceof ymaps.GeoObject) { // Убеждаемся, что это геообъект Яндекса
            uniqueYandexGeoObjects.add(obj);
        }
    });

    // Собираем все полигоны из areaObjects (если там могут быть полилинии, их тоже)
    areaObjects.forEach(obj => {
        if (obj instanceof ymaps.GeoObject) {
            uniqueYandexGeoObjects.add(obj);
        }
    });

    // Собираем все метки из parcelPlacemarks
    parcelPlacemarks.forEach(obj => {
        if (obj instanceof ymaps.GeoObject) {
            uniqueYandexGeoObjects.add(obj);
        }
    });


    uniqueYandexGeoObjects.forEach(obj => {
        if (obj instanceof ymaps.Polygon) {
            const placemarkName = obj.properties.get('cadastralNumber') ||
                                  obj.properties.get('hintContent')?.cadastralNumber ||
                                  obj.properties.get('hintContent')?.iconContent ||
                                  `Полигон_${polygonIndex++}`;
            kmlPlacemarks.push(generateKmlForSinglePolygon(obj, placemarkName));
        } else if (obj instanceof ymaps.Polyline) { // <--- ДОБАВЛЕНА ОБРАБОТКА ПОЛИЛИНИЙ
            const placemarkName = obj.properties.get('hintContent') || // Попытка получить имя из подсказки
                                  (obj.properties.get('iconContent') && typeof obj.properties.get('iconContent') === 'string' ? obj.properties.get('iconContent') : null) || // Если имя в iconContent (для меток расстояния)
                                  `Линия_${lineIndex++}`;
            kmlPlacemarks.push(generateKmlForPolyline(obj, placemarkName));
        } else if (obj instanceof ymaps.Placemark) {
            // Пропускаем метки, которые являются частью измерения расстояния или площади,
            // так как сама линия/полигон уже будет экспортирована.
            // Это условие можно настроить, если нужно экспортировать и метки измерений.
            if (obj === distanceLabel || obj === areaLabel || (obj.properties && (obj.properties.get('isVertexPoint') || obj.properties.get('isDistanceSegmentLabel')))) {
                 // Пропускаем метки вершин и сегментов расстояний, если они специально помечены
            } else {
                const name = obj.properties.get('iconContent') ||
                             obj.properties.get('hintContent')?.cadastralNumber ||
                             (typeof obj.properties.get('hintContent') === 'string' ? obj.properties.get('hintContent') : null) ||
                             (typeof obj.properties.get('balloonContent') === 'string' ? obj.properties.get('balloonContent') : null) ||
                             `Метка_${placemarkIndex++}`;
                kmlPlacemarks.push(generateKmlForPlacemark(obj, name));
            }
        }
    });

    draggableTexts.forEach(textEl => {
        kmlPlacemarks.push(generateKmlForDraggableText(textEl, map, `Текст_${textIndex++}`));
    });


    if (kmlPlacemarks.length === 0) {
        showNotification('Нет объектов для экспорта в KML', 'warning', 'exclamation-triangle');
        return;
    }

    const kmlDocumentName = 'Все_объекты_карты';
    const kmlContent = `<?xml version="1.0" encoding="UTF-8"?>
<kml xmlns="http://www.opengis.net/kml/2.2">
  <Document>
    <name>${escapeXml(kmlDocumentName)}</name>
    ${kmlPlacemarks.join('\n')}
  </Document>
</kml>`;

    const blob = new Blob([kmlContent], { type: 'application/vnd.google-earth.kml+xml;charset=utf-8' });
    saveAs(blob, `${kmlDocumentName}.kml`);
    // Подсчитываем общее количество уникальных геообъектов Яндекса (не KML Placemarks) + текстовые метки
    showNotification(`Экспортировано ${uniqueYandexGeoObjects.size + draggableTexts.length} объектов в KML Google Earth`, 'success', 'check-circle');
    
    if (openGoogleEarthAfterExport) {
        window.open('https://earth.google.com/web/@0,-0.67350016,0a,22251752.77375655d,35y,0h,0t,0r/data=CgRCAggBOgMKATBCAggASg0I____________ARAA', '_blank');
    }
}

// ИЗМЕНЕННАЯ ФУНКЦИЯ onMapClickForDistance (добавляем свойство для метки сегмента)
function onMapClickForDistance(e) {
    const coords = e.get('coords');
    distancePoints.push(coords);

    const placemark = new ymaps.Placemark(coords, {}, {
        preset: 'islands#smallGreenDotIcon'
    });
    map.geoObjects.add(placemark);
    polygons.push(placemark);

    if (distancePoints.length > 1) {
        const lastIndex = distancePoints.length - 1;
        const p1 = distancePoints[lastIndex - 1];
        const p2 = distancePoints[lastIndex];
        const segmentDistance = ymaps.coordSystem.geo.getDistance(p1, p2);
        totalDistance += segmentDistance;
        segments.push(segmentDistance);

        const segmentLine = new ymaps.Polyline([p1, p2], {}, {
            strokeColor: '#4cbb17',
            strokeWidth: 3,
            opacity: 0.8
        });
        map.geoObjects.add(segmentLine);
        polygons.push(segmentLine);

        const midPoint = [(p1[0] + p2[0]) / 2, (p1[1] + p2[1]) / 2];
        const formattedDistance = formatDistance(segmentDistance);

        const segmentLabel = new ymaps.Placemark(midPoint, {
            iconContent: formattedDistance,
            balloonContent: formattedDistance,
            isDistanceSegmentLabel: true // <--- ДОБАВЛЕНО СВОЙСТВО
        }, {
            preset: 'islands#greenStretchyIcon',
            iconColor: '#4cbb17',
            iconSize: [20, 20]
        });
        map.geoObjects.add(segmentLabel);
        polygons.push(segmentLabel);

        updateTotalDistanceLabel();
    }
}

function onMapDoubleClickForDistance(e) {
    e.preventDefault();
    stopDistanceMeasurement();
    
    // Ensure only the total distance label (red) remains, and no duplicates are left
    updateTotalDistanceLabel();
    
    // Optionally, you can clear or re-evaluate distancePoints if needed, but this should suffice
    distancePoints = [...distancePoints]; // Keep the points for reference but don’t duplicate labels
}


function updateTotalDistanceLabel() {
    if (distanceLabel) {
        map.geoObjects.remove(distanceLabel);
        polygons = polygons.filter(p => p !== distanceLabel);
    }

    if (distancePoints.length > 0) {
        const lastPoint = distancePoints[distancePoints.length - 1];
        const formattedTotal = formatDistance(totalDistance);

        // Use only the red StretchyIcon preset for the total distance label
        distanceLabel = new ymaps.Placemark(lastPoint, {
            iconContent: formattedTotal,
            balloonContent: formattedTotal
        }, {
            preset: 'islands#redStretchyIcon' // Ensure only the red label is used
        });
        map.geoObjects.add(distanceLabel);
        polygons.push(distanceLabel);
    }
}

async function terrZoneMenuItemHandler(contextMenu, map, polygons, polygonStyle, mapOffsetY, mapOffsetX, getAddressByCoords, proj4, ymaps, showNotification) {
    const lat = parseFloat(contextMenu.dataset.lat);
    const lon = parseFloat(contextMenu.dataset.lon);

    try {
        const terrZoneData = await queryTerrZoneInfo(lat, lon);

        if (!terrZoneData || !terrZoneData.features || terrZoneData.features.length === 0) {
            showNotification('Территориальная зона не найдена', 'error', 'exclamation-circle');
            contextMenu.style.display = 'none';
            return;
        }

        const feature = terrZoneData.features[0];

        if (!feature.geometry || !feature.geometry.coordinates) {
            throw new Error('Геометрия или координаты отсутствуют в данных');
        }

        let combinedBounds = null;
        const turfPolygons = [];
        let clickedContourCentroid = null;

        const isMultiPolygon = feature.geometry.type === 'MultiPolygon';
        const polygonsCoords = isMultiPolygon ? feature.geometry.coordinates : [feature.geometry.coordinates];

        const cadastralNumber = feature.properties.options && feature.properties.options.reg_numb_border
            ? feature.properties.options.reg_numb_border
            : 'Не указан';
        const name = feature.properties.options && feature.properties.options.name_by_doc
            ? feature.properties.options.name_by_doc
            : 'Не указано';
        const registrationDate = feature.properties.options && feature.properties.options.registration_date
            ? feature.properties.options.registration_date
            : 'Не указана';
        const labelContent = `${cadastralNumber} - ${name} (${registrationDate})`;

        for (let polygonIndex = 0; polygonIndex < polygonsCoords.length; polygonIndex++) {
            const polygonCoords = polygonsCoords[polygonIndex];

            for (let contourIndex = 0; contourIndex < polygonCoords.length; contourIndex++) {
                const contour = polygonCoords[contourIndex];
                if (!Array.isArray(contour)) {
                    console.error(`Некорректный формат контура в полигоне:`, contour);
                    continue;
                }

                const coords = [];
                for (const coord of contour) {
                    if (!Array.isArray(coord) || coord.length !== 2 || typeof coord[0] !== 'number' || typeof coord[1] !== 'number' || !Number.isFinite(coord[0]) || !Number.isFinite(coord[1])) {
                        console.error(`Некорректная координата перед преобразованием:`, coord);
                        continue;
                    }

                    try {
                        const point = proj4('EPSG:3857', 'EPSG:4326', coord);
                        if (!Number.isFinite(point[0]) || !Number.isFinite(point[1])) {
                            console.error(`Преобразование дало некорректные значения:`, coord, '->', point);
                            continue;
                        }
                        coords.push([point[1], point[0]]);
                    } catch (e) {
                        console.error(`Ошибка преобразования координаты:`, coord, e);
                        continue;
                    }
                }

                if (coords.length > 0) {
                    const offsetCoords = coords.map(coord => [
                        coord[0] - mapOffsetY * 0.000008983,
                        coord[1] - mapOffsetX * 0.000008983
                    ]);

                    const polygonObj = new ymaps.Polygon([offsetCoords], {}, {
                        strokeColor: '#0000FF',
                        strokeWidth: polygonStyle.width,
                        strokeOpacity: 0.8,
                        fillColor: '#00000000',
                        hintEnabled: false,
                        hasBalloon: false,
                        interactivityModel: 'default#transparent'
                    });

                    map.geoObjects.add(polygonObj);
                    polygons.push(polygonObj);

                    const bounds = polygonObj.geometry.getBounds();
                    if (!combinedBounds) {
                        combinedBounds = bounds;
                    } else {
                        combinedBounds[0][0] = Math.min(combinedBounds[0][0], bounds[0][0]);
                        combinedBounds[0][1] = Math.min(combinedBounds[0][1], bounds[0][1]);
                        combinedBounds[1][0] = Math.max(combinedBounds[1][0], bounds[1][0]);
                        combinedBounds[1][1] = Math.max(combinedBounds[1][1], bounds[1][1]);
                    }

                    const turfContour = turf.polygon([coords.map(coord => [coord[1], coord[0]])]);
                    turfPolygons.push(turfContour);

                    const clickPoint = turf.point([lon, lat]);
                    const isPointInContour = turf.booleanPointInPolygon(clickPoint, turfContour);

                    if (isPointInContour) {
                        const centroidFeature = turf.centroid(turfContour);
                        const centroidCoordsGeo = centroidFeature.geometry.coordinates;
                        clickedContourCentroid = [
                            centroidCoordsGeo[1] - mapOffsetY * 0.000008983,
                            centroidCoordsGeo[0] - mapOffsetX * 0.000008983
                        ];
                    }
                }
            }
        }

        if (!combinedBounds) {
            throw new Error('Не удалось определить границы полигона');
        }

        map.setBounds(combinedBounds, {
            checkZoomRange: true,
            duration: 200
        });

        const centerGeo = [
            (combinedBounds[0][0] + combinedBounds[1][0]) / 2,
            (combinedBounds[0][1] + combinedBounds[1][1]) / 2
        ];

        getAddressByCoords(centerGeo).then(address => {
            document.getElementById('city-name-display').innerHTML = address;
        });

        const center3857 = proj4("EPSG:4326", "EPSG:3857", [centerGeo[1], centerGeo[0]]);

        lastPolygonCenter = {
            geo: {
                lat: centerGeo[0],
                lon: centerGeo[1]
            },
            epsg3857: {
                x: center3857[0],
                y: center3857[1]
            },
            native: {
                x: feature.geometry.coordinates[0]?.[0]?.[0]?.[0] || 0,
                y: feature.geometry.coordinates[0]?.[0]?.[0]?.[1] || 0
            }
        };

        if (clickedContourCentroid) {
            const terrZoneText = new ymaps.Placemark(clickedContourCentroid, {
                iconContent: labelContent,
                hintContent: labelContent
            }, {
                preset: 'islands#blueStretchyIcon',
                draggable: true // Добавлено: метка перетаскиваемая
            });

            map.geoObjects.add(terrZoneText);
            polygons.push(terrZoneText);
        } else {
            console.warn('Выбранная точка не попала ни в один из контуров');
        }
    } catch (error) {
        console.error('Ошибка при получении тер. зоны:', error);
        showNotification('Ошибка обработки данных территориальной зоны', 'error', 'exclamation-circle');
    }
    contextMenu.style.display = 'none';
}




async function getAllParcelsInQuarter(lat, lon, isSearchMode = false, directQuarterNumber = null, quarterAlreadyDrawn = false) {
    if (!isSearchMode) {
        if (directQuarterNumber) {
            showLoader(`Загрузка ${directQuarterNumber}...`);
        } else {
            showLoader("Поиск квартала ...");
        }
    }

    try {
        let quarterFeature = null;
        let quarterNumberToQuery = null;

        async function fetchNSPDQuarterGeometry(qn) {
            const url = `https://nspd.gov.ru/api/geoportal/v2/search/geoportal?thematicSearchId=2&query=${encodeURIComponent(qn)}`;
            try {
                const response = await fetchNspd(url); // Используем fetchNspd
                if (!response.ok) {
                    console.warn(`NSPD: HTTP error ${response.status} при запросе геометрии для квартала ${qn}`);
                    return null;
                }
                const data = await response.json();
                if (data && data.data && data.data.features && data.data.features.length > 0) {
                    return data.data.features[0];
                }
            } catch (error) {
                console.error(`NSPD: Ошибка при запросе геометрии для квартала ${qn}:`, error);
            }
            return null;
        }

        if (directQuarterNumber) {
            quarterNumberToQuery = directQuarterNumber;
        } else if (lat !== null && lon !== null) {
            async function tryGetQuarterDataByPoint(latitude, longitude) {
                const cadastralData = await queryCadastralInfo(latitude, longitude);
                if (!cadastralData?.features?.length) return null;
                const feature = cadastralData.features[0];
                const cadastralNumberOfPoint = feature.properties?.descr;
                if (!cadastralNumberOfPoint || cadastralNumberOfPoint.split(':').length < 3) return null;
                const qnForPoint = cadastralNumberOfPoint.split(':').slice(0, 3).join(':');
                return await fetchNSPDQuarterGeometry(qnForPoint);
            }

            quarterFeature = await tryGetQuarterDataByPoint(lat, lon);
            let foundByPoint = !!quarterFeature;
            let attempts = 0;
            const maxAttempts = 10;
            const squareWidthMeters = 50;
            const timeoutMs = 100;

            if (!foundByPoint) {
                const earthRadius = 6378137;
                const latRadians = lat * Math.PI / 180;
                const squareWidthLat = squareWidthMeters / earthRadius * (180 / Math.PI);
                const squareWidthLon = squareWidthMeters / (earthRadius * Math.cos(latRadians)) * (180 / Math.PI);

                while (!foundByPoint && attempts < maxAttempts) {
                    attempts++;
                    const offsetLat = (Math.random() - 0.5) * squareWidthLat;
                    const offsetLon = (Math.random() - 0.5) * squareWidthLon;
                    const newLat = lat + offsetLat;
                    const newLon = lon + offsetLon;
                    quarterFeature = await tryGetQuarterDataByPoint(newLat, newLon);
                    foundByPoint = !!quarterFeature;
                    if (!foundByPoint && attempts < maxAttempts) {
                        await new Promise(resolve => setTimeout(resolve, timeoutMs));
                    }
                }
            }
            if (quarterFeature && quarterFeature.properties && quarterFeature.properties.descr) {
                quarterNumberToQuery = quarterFeature.properties.descr.split(':').slice(0, 3).join(':');
            }
        }

        if (!quarterNumberToQuery) {
            if (!isSearchMode) showNotification('Не удалось определить кадастровый квартал.', 'error');
            hideLoader();
            return { quarterFeature: null, parcelFeatures: [] };
        }


        if (isZeroQuarterRequest(quarterNumberToQuery)) {
            showNotification('Поиск в нулевом квартале не выполняется', 'warning');
            hideLoader();
            return { quarterFeature: null, parcelFeatures: [] }; // Прерываем выполнение
        }
    

  autoUpdateMskSettings(quarterNumberToQuery); 
        currentQuarterNumber = quarterNumberToQuery;

        if (!quarterFeature && directQuarterNumber) {
            quarterFeature = await fetchNSPDQuarterGeometry(directQuarterNumber);
        }

        let combinedBounds = null;
        if (!quarterAlreadyDrawn && quarterFeature && quarterFeature.geometry && quarterFeature.geometry.coordinates) {
            try {
                const geometryType = quarterFeature.geometry.type;
                const nspdQuarterCoords = quarterFeature.geometry.coordinates;
                const yandexPolygons = [];
                const processNspdPolygon = (rings) => {
                    const wgsCoords = rings[0].map(coord => {
                        const p = proj4('EPSG:3857', 'EPSG:4326', coord);
                        return [p[1], p[0]];
                    });
                    return wgsCoords.map(c => [c[0] - mapOffsetY * 0.000008983, c[1] - mapOffsetX * 0.000008983]);
                };
                if (geometryType === "Polygon") {
                    yandexPolygons.push(processNspdPolygon(nspdQuarterCoords));
                } else if (geometryType === "MultiPolygon") {
                    nspdQuarterCoords.forEach(polygonRings => yandexPolygons.push(processNspdPolygon(polygonRings)));
                }
                if (yandexPolygons.length > 0) {
                    const quarterPolygonNSPD = new ymaps.Polygon(yandexPolygons, {}, {
                        strokeColor: '#AAAAAA', strokeWidth: polygonStyle.width > 1 ? polygonStyle.width - 1 : 1,
                        strokeStyle: 'dash', strokeOpacity: 0.7, fillColor: '#00000000', zIndex: 100
                    });
                    map.geoObjects.add(quarterPolygonNSPD);
                    polygons.push(quarterPolygonNSPD);
                    combinedBounds = quarterPolygonNSPD.geometry.getBounds();
                    const centerGeo = [(combinedBounds[0][0] + combinedBounds[1][0]) / 2, (combinedBounds[0][1] + combinedBounds[1][1]) / 2];
                    getAddressByCoords(centerGeo).then(address => { document.getElementById('city-name-display').innerHTML = address || `Квартал: ${quarterNumberToQuery} (с НСПД)`; });
                }
            } catch (e) { console.error("Ошибка отрисовки контура квартала:", e); }
        } else if (quarterAlreadyDrawn) {
            const existingQuarterPoly = polygons.find(p => p.properties && p.properties.get('hintContent')?.includes(currentQuarterNumber) && p.options.get('strokeColor') === '#00DD00');
            if (existingQuarterPoly) combinedBounds = existingQuarterPoly.geometry.getBounds();
        }

        if (!quarterFeature || !quarterFeature.geometry) {
            if (!isSearchMode) showNotification(`Нет геометрии для квартала ${quarterNumberToQuery}, чтобы запросить участки.`, 'error');
            hideLoader();
            return { quarterFeature: null, parcelFeatures: [] };
        }
        
        const requestBody = {
            "geom": { "type": "FeatureCollection", "features": [{ "type": "Feature", "geometry": { "crs": { "type": "name", "properties": { "name": "EPSG:3857" } }, "type": quarterFeature.geometry.type, "coordinates": quarterFeature.geometry.coordinates }, "properties": {} }] },
            "categories": [{ "id": 36368 }]
        };
        const response = await fetchNspd('https://nspd.gov.ru/api/geoportal/v1/intersects?typeIntersect=fullObject', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(requestBody) });
        if (!response.ok) throw new Error(`HTTP error ${response.status} при запросе участков для ${quarterNumberToQuery}`);
        const nspdParcelsData = await response.json();

        if (!nspdParcelsData?.features?.length) {
            if (!isSearchMode) showNotification(`Земельные участки в квартале ${quarterNumberToQuery} не найдены`, 'warning');
            if (combinedBounds) map.setBounds(combinedBounds, { checkZoomRange: true, duration: 300 });
            hideLoader();
            return { quarterFeature: quarterFeature, parcelFeatures: [] };
        }
        
        parcelFeaturesData = nspdParcelsData.features;
        await processAndDrawParcels(nspdParcelsData.features, 'quarter');
        await populateSidebarWithParcels(nspdParcelsData.features);
        
        updatePlacemarksVisibility();
        applyCurrentTheme();
        showNotification(`Загружено участков: ${parcelFeaturesData.length} для ${quarterNumberToQuery}`, 'success');
        hideLoader();

        // Фоновое сохранение данных
        saveQuarterGeometryToSupabase(quarterNumberToQuery, quarterFeature.geometry)
            .catch(err => console.error(`Фоновая ошибка сохранения геометрии в Supabase:`, err));

        uploadNspdDataToLocalServer(parcelFeaturesData, currentQuarterNumber)
            .catch(err => console.error(`Фоновая ошибка выгрузки данных на локальный сервер:`, err));
        
        return { quarterFeature: quarterFeature, parcelFeatures: parcelFeaturesData };

    } catch (error) {
        console.error('Ошибка в getAllParcelsInQuarter:', error);
        if (!isSearchMode) {
            showNotification(`НСПД: ${error.message || 'Ошибка сети или обработки данных'}`, 'error');
        }
        hideLoader();
        return { quarterFeature: null, parcelFeatures: [] };
    }
}

 

   async function saveQuarterGeometryToSupabase(quarterNumber, geometryGeoJSON) {
    if (!supabaseClient) {
        console.error("Клиент Supabase не инициализирован для сохранения геометрии.");
        return false;
    }
    if (!quarterNumber || !geometryGeoJSON) {
        console.error("Отсутствует номер квартала или геометрия для сохранения.");
        return false;
    }

    // Проверка на "нулевой" квартал, чтобы не сохранять его геометрию
    const quarterParts = quarterNumber.split(':');
    if (quarterParts.length === 3) {
        const regionPart = quarterParts[0];
        const blockPart = quarterParts[2];
        const isSevenDigitsRegion = sevenDigitsRegions.includes(regionPart);
        const expectedZerosLength = isSevenDigitsRegion ? 7 : 6;

        if (/^0+$/.test(blockPart) && blockPart.length === expectedZerosLength) {
             console.warn(`Нулевой квартал ${quarterNumber} - геометрия не будет сохранена в БД.`);
             return false;
        }
    }

    try {
        const { data, error } = await supabaseClient
            .from('cadastral_quarters')
            .upsert(
                {
                    quarter_number: quarterNumber,
                    geometry: geometryGeoJSON,
                },
                {
                    onConflict: 'quarter_number' // Обновляем, если квартал уже существует
                }
            )
            .select();

        if (error) {
        //    console.error(`Ошибка Supabase при сохранении геометрии квартала ${quarterNumber}:`, error);
            showNotification(`Ошибка сохранения геометрии квартала ${quarterNumber} в БД`, 'error');
            return false;
        }
     //   console.log(`Геометрия квартала ${quarterNumber} успешно сохранена/обновлена в Supabase.`);
        return true;
    } catch (dbError) {
    //    console.error(`Исключение при сохранении геометрии квартала ${quarterNumber}:`, dbError);
        showNotification(`Исключение при сохранении геометрии квартала ${quarterNumber} в БД`, 'error');
        return false;
    }
}


async function municipalMenuItemHandler(contextMenu, map, polygons, polygonStyle, mapOffsetY, mapOffsetX, getAddressByCoords, proj4, ymaps, showNotification) {
    const lat = parseFloat(contextMenu.dataset.lat);
    const lon = parseFloat(contextMenu.dataset.lon);

    try {
        const municipalData = await queryMunicipalInfo(lat, lon);

        if (!municipalData || !municipalData.features || municipalData.features.length === 0) {
            showNotification('Муниципальное образование не найдено', 'error', 'exclamation-circle');
            contextMenu.style.display = 'none';
            return;
        }

        let combinedBounds = null;
        const turfPolygons = [];

        for (const feature of municipalData.features) {
            if (!feature.geometry || !feature.geometry.coordinates) {
                console.error('Геометрия или координаты отсутствуют в данных:', feature);
                continue;
            }

            const isMultiPolygon = feature.geometry.type === 'MultiPolygon';
            const polygonsCoords = isMultiPolygon ? feature.geometry.coordinates : [feature.geometry.coordinates];

            const label = feature.properties.label || "Без названия";
            const descr = feature.properties.descr || "Без описания";
            const labelContent = `${label} - ${descr}`;

            for (let polygonIndex = 0; polygonIndex < polygonsCoords.length; polygonIndex++) {
                const polygonCoords = polygonsCoords[polygonIndex];

                for (let contourIndex = 0; contourIndex < polygonCoords.length; contourIndex++) {
                    const contour = polygonCoords[contourIndex];
                    if (!Array.isArray(contour)) {
                        console.error(`Некорректный формат контура в полигоне:`, contour);
                        continue;
                    }

                    const coords = [];
                    for (const coord of contour) {
                        if (!Array.isArray(coord) || coord.length !== 2 || typeof coord[0] !== 'number' || typeof coord[1] !== 'number' || !Number.isFinite(coord[0]) || !Number.isFinite(coord[1])) {
                            console.error(`Некорректная координата перед преобразованием:`, coord);
                            continue;
                        }

                        try {
                            const point = proj4('EPSG:3857', 'EPSG:4326', coord);
                            if (!Number.isFinite(point[0]) || !Number.isFinite(point[1])) {
                                console.error(`Преобразование дало некорректные значения:`, coord, '->', point);
                                continue;
                            }
                            coords.push([point[1], point[0]]);
                        } catch (e) {
                            console.error(`Ошибка преобразования координаты:`, coord, e);
                            continue;
                        }
                    }

                    if (coords.length > 0) {
                        const offsetCoords = coords.map(coord => [
                            coord[0] - mapOffsetY * 0.000008983,
                            coord[1] - mapOffsetX * 0.000008983
                        ]);

                        const polygonObj = new ymaps.Polygon([offsetCoords], {}, {
                            strokeColor: '#FFA500',
                            strokeWidth: polygonStyle.width,
                            strokeOpacity: 0.8,
                            fillColor: '#00000000',
                            hintEnabled: false,
                            hasBalloon: false,
                            interactivityModel: 'default#transparent'
                        });

                        map.geoObjects.add(polygonObj);
                        polygons.push(polygonObj);

                        const bounds = polygonObj.geometry.getBounds();
                        if (!combinedBounds) {
                            combinedBounds = bounds;
                        } else {
                            combinedBounds[0][0] = Math.min(combinedBounds[0][0], bounds[0][0]);
                            combinedBounds[0][1] = Math.min(combinedBounds[0][1], bounds[0][1]);
                            combinedBounds[1][0] = Math.max(combinedBounds[1][0], bounds[1][0]);
                            combinedBounds[1][1] = Math.max(combinedBounds[1][1], bounds[1][1]);
                        }

                        const turfContour = turf.polygon([coords.map(coord => [coord[1], coord[0]])]);
                        turfPolygons.push(turfContour);

                        const centroidFeature = turf.centroid(turfContour);
                        const centroidCoordsGeo = centroidFeature.geometry.coordinates;
                        const contourCentroid = [
                            centroidCoordsGeo[1] - mapOffsetY * 0.000008983,
                            centroidCoordsGeo[0] - mapOffsetX * 0.000008983
                        ];

                        const municipalText = new ymaps.Placemark(contourCentroid, {
                            iconContent: labelContent,
                            hintContent: labelContent
                        }, {
                            preset: 'islands#orangeStretchyIcon',
                            draggable: true // Добавлено: метка перетаскиваемая
                        });

                        map.geoObjects.add(municipalText);
                        polygons.push(municipalText);
                    }
                }
            }
        }

        if (!combinedBounds) {
            throw new Error('Не удалось определить границы полигонов');
        }

        map.setBounds(combinedBounds, {
            checkZoomRange: true,
            duration: 200
        });

        const centerGeo = [
            (combinedBounds[0][0] + combinedBounds[1][0]) / 2,
            (combinedBounds[0][1] + combinedBounds[1][1]) / 2
        ];

        getAddressByCoords(centerGeo).then(address => {
            document.getElementById('city-name-display').innerHTML = address;
        });

        const center3857 = proj4("EPSG:4326", "EPSG:3857", [centerGeo[1], centerGeo[0]]);

        lastPolygonCenter = {
            geo: { lat: centerGeo[0], lon: centerGeo[1] },
            epsg3857: { x: center3857[0], y: center3857[1] },
            native: {
                x: municipalData.features[0].geometry.coordinates[0]?.[0]?.[0]?.[0] || 0,
                y: municipalData.features[0].geometry.coordinates[0]?.[0]?.[0]?.[1] || 0
            }
        };
    } catch (error) {
        console.error('Ошибка при получении муниципального образования:', error);
        showNotification('Ошибка обработки данных муниципального образования', 'error', 'exclamation-circle');
    }
    contextMenu.style.display = 'none';
}

async function settlementsMenuItemHandler(contextMenu, map, polygons, polygonStyle, mapOffsetY, mapOffsetX, getAddressByCoords, proj4, ymaps, showNotification) {
    const lat = parseFloat(contextMenu.dataset.lat);
    const lon = parseFloat(contextMenu.dataset.lon);

    try {
        const settlementsData = await querySettlementsInfo(lat, lon);

        if (!settlementsData || !settlementsData.features || settlementsData.features.length === 0) {
            showNotification('Населённый пункт не найден', 'error', 'exclamation-circle');
            contextMenu.style.display = 'none';
            return;
        }

        let combinedBounds = null;
        const turfPolygons = [];

        for (const feature of settlementsData.features) {
            if (!feature.geometry || !feature.geometry.coordinates) {
                console.error('Геометрия или координаты отсутствуют в данных:', feature);
                continue;
            }

            const isMultiPolygon = feature.geometry.type === 'MultiPolygon';
            const polygonsCoords = isMultiPolygon ? feature.geometry.coordinates : [feature.geometry.coordinates];

            const label = feature.properties.label || "Без названия";
            const name = feature.properties.options && feature.properties.options.name 
                ? feature.properties.options.name 
                : 'Не указано';
            const labelContent = `${label} - ${name}`;

          //  console.log('Сформированная метка:', labelContent);

            for (let polygonIndex = 0; polygonIndex < polygonsCoords.length; polygonIndex++) {
                const polygonCoords = polygonsCoords[polygonIndex];

                for (let contourIndex = 0; contourIndex < polygonCoords.length; contourIndex++) {
                    const contour = polygonCoords[contourIndex];
                    if (!Array.isArray(contour)) {
                        console.error(`Некорректный формат контура в полигоне:`, contour);
                        continue;
                    }

                    const coords = [];
                    for (const coord of contour) {
                        if (!Array.isArray(coord) || coord.length !== 2 || typeof coord[0] !== 'number' || typeof coord[1] !== 'number' || !Number.isFinite(coord[0]) || !Number.isFinite(coord[1])) {
                            console.error(`Некорректная координата перед преобразованием:`, coord);
                            continue;
                        }

                        try {
                            const point = proj4('EPSG:3857', 'EPSG:4326', coord);
                            if (!Number.isFinite(point[0]) || !Number.isFinite(point[1])) {
                                console.error(`Преобразование дало некорректные значения:`, coord, '->', point);
                                continue;
                            }
                            coords.push([point[1], point[0]]);
                        } catch (e) {
                            console.error(`Ошибка преобразования координаты:`, coord, e);
                            continue;
                        }
                    }

                    if (coords.length > 0) {
                        const offsetCoords = coords.map(coord => [
                            coord[0] - mapOffsetY * 0.000008983,
                            coord[1] - mapOffsetX * 0.000008983
                        ]);

                        const polygonObj = new ymaps.Polygon([offsetCoords], {}, {
                            strokeColor: '#FFED29',
                            strokeWidth: polygonStyle.width,
                            strokeOpacity: 0.8,
                            fillColor: '#00000000',
                            hintEnabled: false,
                            hasBalloon: false,
                            interactivityModel: 'default#transparent'
                        });

                        map.geoObjects.add(polygonObj);
                        polygons.push(polygonObj);

                        const bounds = polygonObj.geometry.getBounds();
                        if (!combinedBounds) {
                            combinedBounds = bounds;
                        } else {
                            combinedBounds[0][0] = Math.min(combinedBounds[0][0], bounds[0][0]);
                            combinedBounds[0][1] = Math.min(combinedBounds[0][1], bounds[0][1]);
                            combinedBounds[1][0] = Math.max(combinedBounds[1][0], bounds[1][0]);
                            combinedBounds[1][1] = Math.max(combinedBounds[1][1], bounds[1][1]);
                        }

                        const turfContour = turf.polygon([coords.map(coord => [coord[1], coord[0]])]);
                        turfPolygons.push(turfContour);

                        const centroidFeature = turf.centroid(turfContour);
                        const centroidCoordsGeo = centroidFeature.geometry.coordinates;
                        const contourCentroid = [
                            centroidCoordsGeo[1] - mapOffsetY * 0.000008983,
                            centroidCoordsGeo[0] - mapOffsetX * 0.000008983
                        ];

                        const settlementText = new ymaps.Placemark(contourCentroid, {
                            iconContent: labelContent,
                            hintContent: labelContent
                        }, {
                            preset: 'islands#yellowStretchyIcon',
                            draggable: true // Добавлено: метка перетаскиваемая
                        });

                        map.geoObjects.add(settlementText);
                        polygons.push(settlementText);
                    }
                }
            }
        }

        if (!combinedBounds) {
            throw new Error('Не удалось определить границы полигонов');
        }

        map.setBounds(combinedBounds, {
            checkZoomRange: true,
            duration: 200
        });

        const centerGeo = [
            (combinedBounds[0][0] + combinedBounds[1][0]) / 2,
            (combinedBounds[0][1] + combinedBounds[1][1]) / 2
        ];

        getAddressByCoords(centerGeo).then(address => {
            document.getElementById('city-name-display').innerHTML = address;
        });

        const center3857 = proj4("EPSG:4326", "EPSG:3857", [centerGeo[1], centerGeo[0]]);

        lastPolygonCenter = {
            geo: { lat: centerGeo[0], lon: centerGeo[1] },
            epsg3857: { x: center3857[0], y: center3857[1] },
            native: {
                x: settlementsData.features[0].geometry.coordinates[0]?.[0]?.[0]?.[0] || 0,
                y: settlementsData.features[0].geometry.coordinates[0]?.[0]?.[0]?.[1] || 0
            }
        };
    } catch (error) {
        console.error('Ошибка при получении населённого пункта:', error);
        showNotification('Ошибка обработки данных населённого пункта', 'error', 'exclamation-circle');
    }
    contextMenu.style.display = 'none';
}


function copyPolygonCoordinatesAndOpenSite(targetPolygon) {
    const coordinates = targetPolygon.geometry.getCoordinates()[0];
    const coordsText = coordinates.map(coord => `${coord[0].toFixed(8)}\t${coord[1].toFixed(8)}`).join('\n');

    navigator.clipboard.writeText(coordsText).then(() => {
        showNotification('Координаты скопированы', 'success', 'check-circle');
        window.open('https://polygon.top/ws/csc/', '_blank');
    }).catch(err => {
        console.error('Ошибка при копировании координат:', err);
        showNotification('Ошибка при копировании координат', 'error', 'exclamation-circle');
    });
}


function getApproximateAltitude(zoom) {
    const altitudes = { // zoom: altitude_in_meters
        0: 40000000, 1: 20000000, 2: 10000000, 3: 5000000,
        4: 2500000,  5: 1200000,  6: 600000,   7: 300000,
        8: 150000,   9: 75000,    10: 35000,   11: 15000,
        12: 7000,    13: 3500,    14: 1700,    15: 850,
        16: 400,     17: 200,     18: 100,     19: 50,
        20: 25,      21: 12,
    };
    let baseAlt = altitudes[zoom] || (zoom < 0 ? altitudes[0] : altitudes[21]);
    const correctedAlt = baseAlt * ALTITUDE_CORRECTION_FACTOR;

    let formattedAlt;
    if (correctedAlt >= 1000) {
        // Используем toFixed для контроля над разделителем и затем заменяем, если нужно
        formattedAlt = (correctedAlt / 1000).toFixed(1).replace(',', '.') + ' км'; // Используем replace(',', '.') на всякий случай, если toFixed вернет запятую в какой-то локали
    } else {
        formattedAlt = Math.round(correctedAlt).toString() + ' м';
    }
    // Возвращаем только значение, префикс "Высота: ~" НЕ добавляем здесь
    return formattedAlt;
}


        // NEW FUNCTION: Update the camera height label
  function toggleCameraHeightLabelVisibility() {
            const checkbox = document.getElementById('toggleHeightLabel');
            isCameraHeightLabelVisible = checkbox.checked;
            localStorage.setItem('isCameraHeightLabelVisible', isCameraHeightLabelVisible);
            applyCameraHeightLabelVisibility();
        }

        // НОВАЯ ФУНКЦИЯ для применения сохраненной видимости
        function applyCameraHeightLabelVisibility() {
            if (cameraHeightLabelElement) {
                if (isCameraHeightLabelVisible) {
                    cameraHeightLabelElement.classList.add('visible');
                    updateCameraHeightLabel(); // Обновить текст, если метка становится видимой
                } else {
                    cameraHeightLabelElement.classList.remove('visible');
                }
            }
        }

        // МОДИФИКАЦИЯ: Update the camera height and map overview label
function updateCameraHeightLabel() {
    if (!map || !cameraHeightLabelElement || !isCameraHeightLabelVisible) {
        if (cameraHeightLabelElement) cameraHeightLabelElement.classList.remove('visible');
        return;
    }
    cameraHeightLabelElement.classList.add('visible'); // Убедимся, что класс есть

    const zoom = map.getZoom();
    const altitudeValue = getApproximateAltitude(zoom); // Получаем ТОЛЬКО значение высоты

    let overviewText = "н/д"; // Значение по умолчанию для обзора
    try {
        const bounds = map.getBounds();
        if (bounds && bounds[0] && bounds[1]) {
            const southWest = bounds[0];
            const northEast = bounds[1];

            const widthPoint1 = [southWest[0], southWest[1]];
            const widthPoint2 = [southWest[0], northEast[1]];
            const visibleWidthMeters = ymaps.coordSystem.geo.getDistance(widthPoint1, widthPoint2);

            const heightPoint1 = [southWest[0], southWest[1]];
            const heightPoint2 = [northEast[0], southWest[1]];
            const visibleHeightMeters = ymaps.coordSystem.geo.getDistance(heightPoint1, heightPoint2);

            const formatDimension = (meters) => {
                if (meters >= 1000) {
                    return (meters / 1000).toFixed(1).replace(',', '.') + ' км';
                } else {
                    return Math.round(meters).toString() + ' м';
                }
            };
            overviewText = `${formatDimension(visibleWidthMeters)} × ${formatDimension(visibleHeightMeters)}`;
        }
    } catch (error) {
        console.error("Ошибка при расчете обзора карты:", error);
        // overviewText останется "н/д"
    }

    // Формируем HTML для метки с иконками и значениями
    cameraHeightLabelElement.innerHTML = `
        <i class="fas fa-mountain" title="Высота камеры"></i> ${altitudeValue}
        <span style="margin: 0 5px;">|</span>
        <i class="fas fa-expand-arrows-alt" title="Обзор карты"></i> ${overviewText}
    `;
}


function stopDistanceMeasurement() {
    distanceMeasurementActive = false;
    mapElement.classList.remove('measuring-distance');
    map.events.remove('click', onMapClickForDistance);
    map.events.remove('dblclick', onMapDoubleClickForDistance);
    // Don’t clear polygons here to preserve the distance objects, but ensure labels are handled correctly in updateTotalDistanceLabel
}
    

function initMap() {
    // Загружаем сохраненный центр и масштаб из localStorage
    const savedCenterStr = localStorage.getItem('mapCenter');
    const savedZoomStr = localStorage.getItem('mapZoom');

    // Если данные есть - используем их, иначе - значения по умолчанию
    const initialCenter = savedCenterStr ? JSON.parse(savedCenterStr) : [54.8492, 50.7910];
    const initialZoom = savedZoomStr ? parseInt(savedZoomStr, 10) : 9;

    map = new ymaps.Map('map', {
        center: initialCenter,
        zoom: initialZoom,
        controls: [],
        behaviors: ['default']
    });

    // Получаем ссылку на метку высоты
    cameraHeightLabelElement = document.getElementById('camera-height-label');

    const savedVisibility = localStorage.getItem('isCameraHeightLabelVisible');
    isCameraHeightLabelVisible = savedVisibility === 'true';
    applyCameraHeightLabelVisibility();

    map.behaviors.enable(['scrollZoom', 'drag', 'multiTouch']);

    // ЕДИНЫЙ обработчик события boundschange
    map.events.add('boundschange', function (e) {
        // Debounce для сохранения состояния карты, чтобы не делать это слишком часто
        clearTimeout(debounceTimer);
        debounceTimer = setTimeout(() => {
            if (map) { // Убедимся, что карта все еще существует
                localStorage.setItem('mapCenter', JSON.stringify(map.getCenter()));
                localStorage.setItem('mapZoom', map.getZoom());
            }
        }, 500); // Сохраняем через 500ms после последнего изменения

        // Существующая логика из старых обработчиков
        if (e.get('newZoom') !== e.get('oldZoom')) {
            updatePlacemarksVisibility();
        }
        if (isCameraHeightLabelVisible) {
            updateCameraHeightLabel();
        }
    });
    

numberedPointSize = parseInt(localStorage.getItem('numberedPointSize'), 10) || 14;
  numberedDotSize = parseInt(localStorage.getItem('numberedDotSize'), 10) || 10;

    // Обновляем метки при добавлении на карту
    map.geoObjects.events.add('add', function (e) {
        const target = e.get('child');
        if (target instanceof ymaps.Placemark && target.options.get('iconLayout') === customPlacemarkLayout) {
            target.events.add('mapchange', function () {
                const layout = target.getOverlaySync()?.getLayoutSync();
                if (layout) {
                    layout.onMapChange();
                }
            });
        }
    });

    map.events.add('click', function (e) {
        if (selectedPlacemark) {
            selectedPlacemark = null;
        }
    });

    map.geoObjects.events.add('dragstart', function (e) {
        const target = e.get('target');
        if (target instanceof ymaps.Placemark) {
            // console.log('Начало перетаскивания метки:', target.properties.get('iconContent'));
        }
    });

    map.geoObjects.events.add('dragend', function (e) {
        const target = e.get('target');
        if (target instanceof ymaps.Placemark) {
            const newCoords = target.geometry.getCoordinates();
            const content = target.properties.get('iconContent') || 'Метка';
            //     console.log('Метка перемещена в:', newCoords);
            //   showNotification(`Метка ${content} перемещена`, 'success', 'check-circle');
        }
    });

    // Обработчик клика по объектам на карте
    map.geoObjects.events.add('click', function (e) {
        const target = e.get('target');

        // --- ЛОГИКА ВЫДЕЛЕНИЯ ЛИНИИ ---
        if (target && target.isDrawableLine === true && target instanceof ymaps.Polyline) {
            if (selectedLine && selectedLine !== target) {
                if (selectedLine.originalStyle) {
                    selectedLine.options.set({
                        strokeColor: selectedLine.originalStyle.strokeColor,
                        strokeWidth: selectedLine.originalStyle.strokeWidth
                    });
                } else {
                     selectedLine.options.set({
                         strokeColor: currentLineColor,
                         strokeWidth: currentLineWidth
                     });
                }
            }
            selectedLine = target;
            if (!selectedLine.originalStyle) {
                 selectedLine.originalStyle = {
                     strokeColor: selectedLine.options.get('strokeColor', currentLineColor),
                     strokeWidth: selectedLine.options.get('strokeWidth', currentLineWidth)
                 };
            }
            selectedLine.options.set({
                strokeColor: '#FFFF00',
                strokeWidth: selectedLine.originalStyle.strokeWidth + 2
            });
            if (selectedPlacemark) {
                 selectedPlacemark = null;
            }
            e.stopPropagation();
            return;
        }
        // --- КОНЕЦ ЛОГИКИ ВЫДЕЛЕНИЯ ЛИНИИ ---

        if (target instanceof ymaps.Placemark) {
            if (selectedLine) {
                if (selectedLine.originalStyle) {
                    selectedLine.options.set({
                        strokeColor: selectedLine.originalStyle.strokeColor,
                        strokeWidth: selectedLine.originalStyle.strokeWidth
                    });
                } else {
                    selectedLine.options.set({
                        strokeColor: currentLineColor,
                        strokeWidth: currentLineWidth
                    });
                }
                 selectedLine = null;
            }

            if (selectedPlacemark && selectedPlacemark !== target) {
                 selectedPlacemark = null;
            }
            selectedPlacemark = target;
            const nextColor = getNextStandardColor(target);
            const currentContent = target.properties.get('iconContent') || '';
            target.options.set({ preset: `islands#${nextColor}StretchyIcon` });
            if (currentContent) { target.properties.set('iconContent', currentContent); }
            e.stopPropagation();
            return;
        }

        if (selectedLine) {
            if (selectedLine.originalStyle) {
                selectedLine.options.set({
                    strokeColor: selectedLine.originalStyle.strokeColor,
                    strokeWidth: selectedLine.originalStyle.strokeWidth
                });
            } else {
                 selectedLine.options.set({
                     strokeColor: currentLineColor,
                     strokeWidth: currentLineWidth
                 });
            }
            selectedLine = null;
        }
    });

    const vriLegendList = document.getElementById('vri-legend-list');
    if (vriLegendList) {
        vriLegendList.addEventListener('click', handleVriLegendClick);
    } else {
        console.error("VRI Legend list element not found!");
    }

    map.events.add('click', function(e) {
        if (selectedLine) {
            if (selectedLine.originalStyle) {
                selectedLine.options.set({
                    strokeColor: selectedLine.originalStyle.strokeColor,
                    strokeWidth: selectedLine.originalStyle.strokeWidth
                });
            } else {
                 selectedLine.options.set({
                     strokeColor: currentLineColor,
                     strokeWidth: currentLineWidth
                 });
            }
            selectedLine = null;
        }
         if (selectedPlacemark) {
              selectedPlacemark = null;
         }
    });

    map.events.add('dblclick', function (e) {
        const coords = e.get('coords');
        ymaps.geocode(coords).then(function (res) {
            const firstGeoObject = res.geoObjects.get(0);
            if (firstGeoObject) {
                const address = firstGeoObject.getAddressLine();
                document.getElementById('city-name-display').innerHTML = address;
            } else {
                document.getElementById('city-name-display').innerHTML = 'Адрес не найден';
            }
        });
    });

    // Создание контекстного меню
    const contextMenu = document.createElement('div');
    contextMenu.className = 'custom-context-menu';
    contextMenu.style.display = 'none';
    document.body.appendChild(contextMenu);

     contextMenu.innerHTML = `
     
     
        <!-- START: Theme Submenu -->
        <div class="custom-context-menu-item" id="theme-main-menu-item">
            <i class="fas fa-city"></i>Квартал
            <div class="custom-context-submenu">
            
               
            
               <div class="custom-context-menu-item" id="all-parcels-in-quarter-menu-item">
                    <i class="fas fa-layer-group"></i>Земельные участки в квартале
                </div>
                
               <div class="custom-context-menu-item" id="all-buildings-in-quarter-menu-item">
                    <i class="fas fa-building"></i>Здания в квартале
                </div>
                
                     <div class="custom-context-menu-item" id="all-structures-in-quarter-menu-item">
                    <i class="fas fa-project-diagram"></i>Сооружения в квартале
                </div>
                
                  <div class="custom-context-menu-item" id="all-zouits-in-quarter-menu-item">
                    <i class="fas fa-exclamation-triangle"></i>ЗОУИТ в квартале
                </div>
                
                   
                <div class="custom-context-menu-item" id="quarter-menu-item">
                    <i class="fas fa-th"></i>Границы квартала
                </div>
                
                   <div class="custom-context-menu-item" id="theme-ownership-item">
    <i class="fas fa-home"></i>Собственность
</div>
             <div class="custom-context-menu-item" id="theme-use-item">
                    <i class="fas fa-map-marked-alt"></i>Разрешенное использование
                </div>
                
                <div class="custom-context-menu-item" id="theme-cost-item">
                    <i class="fas fa-dollar-sign"></i>Стоимость
                </div>
                
                   <div class="custom-context-menu-item" id="theme-registration-date-item">
                <i class="far fa-calendar-alt"></i>Дата внесения
           </div>
           
           <div class="custom-context-menu-item" id="theme-ulu-item">
    <i class="fas fa-network-wired"></i>Единое землепользование
</div>
              
               <div class="custom-context-menu-item" id="theme-none-item">
                    <i class="fas fa-ban"></i>Сбросить
                 </div>
                 
                   <div class="custom-context-menu-item" id="theme-import-item">
                    <i class="fas fa-file-upload"></i>Архив КПТ
                </div>
                
                
                 <div class="custom-context-menu-item" id="theme-export-item">
                    <i class="fas fa-file-excel"></i>Экспорт
                 </div>
                 
                 
                
            </div>
        </div>
        <!-- END: Theme Submenu -->
     
        <div class="custom-context-menu-item" id="object-menu-item"> <!-- ID и текст изменены -->
            <i class="fas fa-file-alt"></i>Объект
            <div class="custom-context-submenu">
                
                <div class="custom-context-menu-item" id="egrn-html-menu-item">
                    <i class="fas fa-file-alt"></i>ЕГРН
                </div>
                
          <div class="custom-context-menu-item" id="consolidated-report-menu-item">
                    <i class="fas fa-file-invoice"></i>Отчет
                </div>
                
                <div class="custom-context-menu-item" id="egrn-xml-menu-item">
                    <i class="fas fa-file-code"></i>Открыть КН в XML
                </div>
                
                   <div class="custom-context-menu-item" id="coords-msk-menu-item">
                <i class="fas fa-ruler-combined"></i>Конвертировать объект в МСК
            </div>
            
               <div class="custom-context-menu-item" id="convert-all-msk-menu-item">
                <i class="fas fa-layer-group"></i>Конвертировать все объекты в МСК
            </div>
            
                <div class="custom-context-menu-item" id="quarter-msk-xml-menu-item">
                <i class="fas fa-file-archive"></i>Конвертировать ЗУ в XML КПТ
            </div>
            
                     <div class="custom-context-menu-item" id="all-oks-on-object-menu-item">
                    <i class="fas fa-building"></i>ОКС на объекте
                </div>
                <div class="custom-context-menu-item" id="all-structures-on-object-menu-item">
                    <i class="fas fa-project-diagram"></i>Сооружения на объекте
                </div>
                <div class="custom-context-menu-item" id="all-zouits-on-object-menu-item">
                    <i class="fas fa-search-plus"></i>ЗОУИТ на объекте
                </div>
            
            </div>
        </div>
 
     
           <div class="custom-context-menu-item" id="boundaries-menu-item">
            <i class="fas fa-border-style"></i>Границы
            <div class="custom-context-submenu">
                <div class="custom-context-menu-item" id="cadastre-menu-item">
                    <i class="fas fa-draw-polygon"></i>Открыть ЗУ
                </div>
                <div class="custom-context-menu-item" id="oks-menu-item">
                    <i class="fas fa-building"></i>Открыть ОКС
                </div>
                
         
                <div class="custom-context-menu-item" id="terr-zone-menu-item">
                    <i class="fas fa-globe"></i>Территориальные зоны
                </div>
                <div class="custom-context-menu-item" id="zouit-menu-item">
                    <i class="fas fa-exclamation-triangle"></i>ЗОУИТ
                </div>
                <div class="custom-context-menu-item" id="settlements-menu-item">
                    <i class="fas fa-home"></i>Населенные пункты
                </div>
                <div class="custom-context-menu-item" id="municipal-menu-item">
                    <i class="fas fa-city"></i>Муниципальные образования
                </div>
           
             <div class="custom-context-menu-item" id="forestry-menu-item">
                    <i class="fas fa-tree"></i>Лесничество
                </div>
     
                 <div class="custom-context-menu-item" id="export-current-polygon-to-kml-menu-item">
            <i class="fas fa-file-export"></i> Планета Земля KML
        </div>
               
            </div>
        </div>
    
    
            <div class="custom-context-menu-item" id="oks-on-zu-menu-item">
                    <i class="fas fa-list-ol"></i>ОКС на ЗУ
                </div>
             

        <div class="custom-context-menu-item" id="distance-menu-item">
            <i class="fas fa-ruler"></i>Расстояние
        </div>
        <div class="custom-context-menu-item" id="area-menu-item">
            <i class="fas fa-vector-square"></i>Площадь
         </div>
        <div class="custom-context-menu-item" id="location-menu-item">
            <i class="fas fa-map-pin"></i>Местоположение
        </div>
        <div class="custom-context-menu-item" id="find-on-map-menu-item">
            <i class="fas fa-search-location"></i>Наложения
        </div>
        <div class="custom-context-menu-item" id="copy-cadastre-number-menu-item">
            <i class="fas fa-copy"></i>Копировать
        </div>
        <div class="custom-context-menu-item" id="copy-coords-menu-item">
              <i class="far fa-copy"></i>Координаты
            <div class="custom-context-submenu">
                <div class="custom-context-menu-item" id="copy-coords-menu-item">
                    <i class="fas fa-map-marker-alt"></i>Точка в WGS84
                </div>
                <div class="custom-context-menu-item" id="copy-all-epsg3857-menu-item"> <!-- НОВЫЙ ПУНКТ МЕНЮ -->
                    <i class="fas fa-ruler-combined"></i>Все в EPSG:3857
                </div>
            </div>
        </div>
          <div class="custom-context-menu-item" id="screenshot-menu-item">
            <i class="fas fa-camera"></i>Экран
        </div>
        <div class="custom-context-menu-item" id="change-color-menu-item">
            <i class="fas fa-edit"></i>Изменить
        </div>
         
        
    `;

    // Показ контекстного меню при правом клике
    map.events.add('contextmenu', function (e) {
        e.preventDefault();
        const coords = e.get('coords');
        const position = e.get('position');
        contextMenu.style.left = position[0] + 'px';
        contextMenu.style.top = position[1] + 'px';
        contextMenu.style.display = 'block';

        contextMenu.dataset.lat = coords[0].toFixed(8);
        contextMenu.dataset.lon = coords[1].toFixed(8);
    });

    // Закрытие контекстного меню при клике вне его
    document.addEventListener('click', function (e) {
        if (!contextMenu.contains(e.target)) {
            contextMenu.style.display = 'none';
        }
    });

    document.addEventListener('touchstart', function (e) {
        if (!contextMenu.contains(e.target)) {
            contextMenu.style.display = 'none';
        }
    });

    // Обработка кликов по элементам контекстного меню
        // Обработка кликов по элементам контекстного меню
contextMenu.addEventListener('click', async function (event) {
        if (event.target.id === 'area-menu-item') {
            contextMenu.style.display = 'none';
            measureArea();
        }
        
        if (event.target.id === 'consolidated-report-menu-item') {
            const lat = parseFloat(contextMenu.dataset.lat);
            const lon = parseFloat(contextMenu.dataset.lon);
            await generateConsolidatedReport(lat, lon);
            contextMenu.style.display = 'none';
        }
        
             if (event.target.id === 'screenshot-menu-item') {
            contextMenu.style.display = 'none';
            takeScreenshot(); // Просто вызываем новую функцию
        }
        
           if (event.target.id === 'theme-export-item') {
             contextMenu.style.display = 'none'; // Закрываем меню
            handleExportAction(); // <--- ИЗМЕНЕНО ЗДЕСЬ
        }
        
        
             // Обновляем ID для существующего обработчика ЗОУИТ
        if (event.target.id === 'all-zouits-on-object-menu-item') { // <-- ID ИЗМЕНЕН
            const lat = parseFloat(contextMenu.dataset.lat);
            const lon = parseFloat(contextMenu.dataset.lon);
            await getAllZouitsInObject(lat, lon); 
            contextMenu.style.display = 'none';
        }

        // НОВЫЙ ОБРАБОТЧИК ДЛЯ ОКС
        if (event.target.id === 'all-oks-on-object-menu-item') {
            const lat = parseFloat(contextMenu.dataset.lat);
            const lon = parseFloat(contextMenu.dataset.lon);
            await getAllOksInObject(lat, lon); // Вызываем новую функцию для ОКС
            contextMenu.style.display = 'none';
        }

        // НОВЫЙ ОБРАБОТЧИК ДЛЯ СООРУЖЕНИЙ
        if (event.target.id === 'all-structures-on-object-menu-item') {
            const lat = parseFloat(contextMenu.dataset.lat);
            const lon = parseFloat(contextMenu.dataset.lon);
            await getAllStructuresInObject(lat, lon); // Вызываем новую функцию для Сооружений
            contextMenu.style.display = 'none';
        }
        
            if (event.target.id === 'oks-on-zu-menu-item') {
            const lat = parseFloat(contextMenu.dataset.lat);
            const lon = parseFloat(contextMenu.dataset.lon);
            // Вызываем новую основную функцию для этого действия
            fetchOksOnZuHandler(lat, lon);
            contextMenu.style.display = 'none';
        }
        
        
        
          if (event.target.id === 'theme-import-item') {
            contextMenu.style.display = 'none';
            const clickedLat = parseFloat(contextMenu.dataset.lat);
            const clickedLon = parseFloat(contextMenu.dataset.lon);

            showLoader("Определение квартала...");
            const { x: pointX, y: pointY } = toEPSG3857(clickedLat, clickedLon); // Ensure you have toEPSG3857
            const quarterInfoFromSupabase = await findQuarterByPointSupabase(pointX, pointY);

            if (quarterInfoFromSupabase && quarterInfoFromSupabase.found_quarter_number) {
                // Quarter found in Supabase by point.
                // Set cityInput which will be picked up by triggerSupabaseImport
                cityInput.value = quarterInfoFromSupabase.found_quarter_number;
                
               //  console.log("cityInput.value SET TO (from Supabase point search):", cityInput.value); 
                // Store geometry to be drawn after map clear in triggerSupabaseImport
                window.pendingQuarterGeometryToDraw = quarterInfoFromSupabase.quarter_geometry_geojson;
                window.pendingQuarterNumber = quarterInfoFromSupabase.found_quarter_number; // Also store the number
              //  console.log(`Контекстное меню: Квартал ${quarterInfoFromSupabase.found_quarter_number} найден по точке.`);
            } else {
                // Point not in any Supabase quarter based on RPC.
                // Clear cityInput; triggerSupabaseImport will then rely on currentQuarterNumber
                // or, if archive for that fails, NSPD will try to find quarter by the clicked point.
                cityInput.value = '';
                window.pendingQuarterGeometryToDraw = null;
                window.pendingQuarterNumber = null;
                showNotification("Квартал по точке не найден в Архиве КПТ. Будет использован текущий квартал из поля ввода или поиск...", "info");
            }
            await triggerSupabaseImport(); // This will use the (potentially updated) cityInput value
        }
        
        if (event.target.id === 'theme-ulu-item') {
    setActiveTheme('ulu'); // Set the new theme
    contextMenu.style.display = 'none'; // Close the menu
}
        
            if (event.target.id === 'theme-registration-date-item') {
             setActiveTheme('registration_date'); // Set the new theme
             contextMenu.style.display = 'none'; // Close the menu
         }
         
         
         if (event.target.id === 'export-current-polygon-to-kml-menu-item') { // <--- THIS IS THE CORRECT ID
            contextMenu.style.display = 'none';
            const lat = parseFloat(contextMenu.dataset.lat);
            const lon = parseFloat(contextMenu.dataset.lon);

            // --- Логика поиска targetPolygon (остается такой же, как была для 'export-kml-zu-menu-item') ---
            // ... (existing code for finding targetPolygon) ...
            const candidatePolygons = [];
            for (const polygon of polygons) {
                if (polygon instanceof ymaps.Polygon) {
                    try {
                        const coords = polygon.geometry.getCoordinates()[0];
                        const turfPolygon = turf.polygon([coords.map(coord => [coord[1], coord[0]])]);
                        const point = turf.point([lon, lat]);
                        if (turf.booleanPointInPolygon(point, turfPolygon)) {
                            candidatePolygons.push(polygon);
                        }
                    } catch (turfError) {
                        if (polygon.geometry.contains([lat, lon])) { candidatePolygons.push(polygon); }
                    }
                }
            }
            for (const obj of areaObjects) {
                 if (obj instanceof ymaps.Polygon) {
                     try {
                        const coords = obj.geometry.getCoordinates()[0];
                        const turfPolygon = turf.polygon([coords.map(coord => [coord[1], coord[0]])]);
                        const point = turf.point([lon, lat]);
                        if (turf.booleanPointInPolygon(point, turfPolygon)) {
                            candidatePolygons.push(obj);
                        }
                    } catch(turfError) {
                         if (obj.geometry.contains([lat, lon])) { candidatePolygons.push(obj); }
                    }
                 }
            }

            if (candidatePolygons.length === 0) {
                showNotification('Контур для экспорта в KML не найден', 'warning', 'exclamation-triangle');
                return;
            }

            let targetPolygon = candidatePolygons[0];
            if (candidatePolygons.length > 1) {
                let minArea = Infinity;
                candidatePolygons.forEach(polygon => {
                    try {
                        const coords = polygon.geometry.getCoordinates()[0];
                        if (coords.length < 3) return;
                        const turfPolygon = turf.polygon([coords.map(coord => [coord[1], coord[0]])]);
                        const area = turf.area(turfPolygon);
                        if (isFinite(area) && area < minArea) {
                            minArea = area;
                            targetPolygon = polygon;
                        }
                    } catch (e) { console.error("Error calculating area for KML target polygon:", polygon, e); }
                });
            }

            if (targetPolygon) {
                const kmlContent = generateKmlForSinglePolygon(targetPolygon);
                const placemarkName = targetPolygon.properties.get('cadastralNumber') ||
                                      targetPolygon.properties.get('hintContent')?.cadastralNumber ||
                                      'Exported_Polygon';
                const safePlacemarkName = placemarkName.replace(/[^a-zA-Z0-9_.:-]/g, '_');
                const blob = new Blob([kmlContent], { type: 'application/vnd.google-earth.kml+xml;charset=utf-8' });
                saveAs(blob, `${safePlacemarkName}.kml`);
                showNotification(`KML файл для '${safePlacemarkName}' успешно создан`, 'success', 'check-circle');
                
                // START: Check setting before opening Google Earth
                if (openGoogleEarthAfterExport) {
                    window.open('https://earth.google.com/web/@0,-0.67350016,0a,22251752.77375655d,35y,0h,0t,0r/data=CgRCAggBOgMKATBCAggASg0I____________ARAA', '_blank');
                }
                // END: Check setting
            } else {
                showNotification('Не удалось определить полигон для экспорта в KML', 'error', 'exclamation-circle');
            }
        }
         
             if (event.target.id === 'theme-cost-item') {
            setActiveTheme('cost');
            contextMenu.style.display = 'none';
        }
        if (event.target.id === 'theme-use-item') {
            setActiveTheme('use');
            contextMenu.style.display = 'none';
        }
        
          if (event.target.id === 'theme-ownership-item') {
        setActiveTheme('ownership');
        contextMenu.style.display = 'none';
    }
    
        if (event.target.id === 'theme-none-item') {
            setActiveTheme('none');
            contextMenu.style.display = 'none';
        }

        if (event.target.id === 'distance-menu-item') {
            contextMenu.style.display = 'none';
            measureDistance();
        }
        
     if (event.target.id === 'theme-ulu-item') {
    setActiveTheme('ulu'); // Set the new theme
    contextMenu.style.display = 'none'; // Close the menu
}
        
if (event.target.id === 'find-on-map-menu-item') {
    showFindOnMapDialog();
    contextMenu.style.display = 'none';
}

           if (event.target.id === 'cadastre-menu-item') {
            const lat = parseFloat(contextMenu.dataset.lat);
            const lon = parseFloat(contextMenu.dataset.lon);

            try {
                // Вспомогательная функция для поиска объекта
                async function tryGetCadastralData(latitude, longitude) {
                    const cadastralData = await queryCadastralInfo(latitude, longitude);
                    if (!cadastralData || !cadastralData.features || cadastralData.features.length === 0) {
                        return null;
                    }
                    return cadastralData.features[0];
                }

                // Поиск объекта с несколькими попытками
                let feature = await tryGetCadastralData(lat, lon);
                let found = !!feature;
                let attempts = 0;
                const maxAttempts = 10;
                const squareWidthMeters = 50;
                const timeoutMs = 100;

                if (!found) {
                    const earthRadius = 6378137;
                    const latRadians = lat * Math.PI / 180;
                    const squareWidthLat = squareWidthMeters / earthRadius * (180 / Math.PI);
                    const squareWidthLon = squareWidthMeters / (earthRadius * Math.cos(latRadians)) * (180 / Math.PI);

                    while (!found && attempts < maxAttempts) {
                        attempts++;
                        const offsetLat = (Math.random() - 0.5) * squareWidthLat;
                        const offsetLon = (Math.random() - 0.5) * squareWidthLon;
                        const newLat = lat + offsetLat;
                        const newLon = lon + offsetLon;
                        feature = await tryGetCadastralData(newLat, newLon);
                        found = !!feature;
                        if (!found && attempts < maxAttempts) {
                            await new Promise(resolve => setTimeout(resolve, timeoutMs));
                        }
                    }
                }

                if (!found) {
                    showNotification('Кадастровый номер не найден', 'error', 'exclamation-circle');
                    contextMenu.style.display = 'none';
                    return;
                }
                
                // Вместо дублирования кода отрисовки, вызываем уже исправленную функцию
                await drawFeatureFromNspd(feature);

            } catch (error) {
                console.error('Ошибка при получении участка:', error);
                showNotification('Ошибка подключения, попробуйте позже', 'error', 'exclamation-circle');
            }
            contextMenu.style.display = 'none';
        }

        if (event.target.id === 'oks-menu-item') {
            const lat = parseFloat(contextMenu.dataset.lat);
            const lon = parseFloat(contextMenu.dataset.lon);

            try {
                const oksData = await queryOKSInfo(lat, lon);

                if (!oksData || !oksData.features || oksData.features.length === 0) {
                    showNotification('Объект капитального строительства не найден', 'error', 'exclamation-circle');
                    contextMenu.style.display = 'none';
                    return;
                }

                const feature = oksData.features[0];

                if (feature.geometry && feature.geometry.coordinates) {
                    const coordinates = feature.geometry.coordinates[0].map(coord => {
                        const point = proj4('EPSG:3857', 'EPSG:4326', coord);
                        return [point[1], point[0]];
                    });

                    const offsetCoordinates = coordinates.map(coord => [
                        coord[0] - mapOffsetY * 0.000008983,
                        coord[1] - mapOffsetX * 0.000008983
                    ]);

                    const polygon = new ymaps.Polygon([offsetCoordinates], {}, {
                        strokeColor: '#00FF00',
                        strokeWidth: polygonStyle.width,
                        strokeOpacity: 0.8,
                        fillColor: '#00000000',
                        hintEnabled: false,
                        hasBalloon: false,
                        interactivityModel: 'default#transparent'
                    });

                    map.geoObjects.add(polygon);
                    polygons.push(polygon);

                    const bounds = polygon.geometry.getBounds();
                    const centerGeo = [
                        (bounds[0][0] + bounds[1][0]) / 2,
                        (bounds[0][1] + bounds[1][1]) / 2
                    ];

                    getAddressByCoords(centerGeo).then(address => {
                        document.getElementById('city-name-display').innerHTML = address;
                    });

                    const center3857 = proj4("EPSG:4326", "EPSG:3857", [centerGeo[1], centerGeo[0]]);

                    lastPolygonCenter = {
                        geo: {
                            lat: centerGeo[0],
                            lon: centerGeo[1]
                        },
                        epsg3857: {
                            x: center3857[0],
                            y: center3857[1]
                        },
                        native: {
                            x: feature.geometry.coordinates[0][0][0],
                            y: feature.geometry.coordinates[0][0][1]
                        }
                    };

                    const cadastralNumber = feature.properties.options && feature.properties.options.cad_num
                        ? feature.properties.options.cad_num
                        : 'Не указан';
                    const name = feature.properties.descr || 'Не указано';
                    const labelContent = `${cadastralNumber} - ${name}`;

                    const oksText = new ymaps.Placemark([
                        centerGeo[0] - mapOffsetY * 0.000008983,
                        centerGeo[1] - mapOffsetX * 0.000008983
                    ], {
                        iconContent: labelContent
                    }, {
                        preset: 'islands#greenStretchyIcon',
                        draggable: true
                    });

                    map.geoObjects.add(oksText);
                    polygons.push(oksText);

                    map.setBounds(bounds, {
                        checkZoomRange: true,
                        duration: 200
                    });
                }
            } catch (error) {
                console.error('Ошибка при получении ОКС:', error);
                showNotification('Ошибка подключения, попробуйте позже', 'error', 'exclamation-circle');
            }
            contextMenu.style.display = 'none';
        }

        if (event.target.id === 'terr-zone-menu-item') {
            terrZoneMenuItemHandler(contextMenu, map, polygons, polygonStyle, mapOffsetY, mapOffsetX, getAddressByCoords, proj4, ymaps, showNotification);
        }

        //ЗОУИТ
        if (event.target.id === 'zouit-menu-item') {
            zouitMenuItemHandler(contextMenu, map, polygons, polygonStyle, mapOffsetY, mapOffsetX, getAddressByCoords, proj4, ymaps, showNotification);
        }

        if (event.target.id === 'municipal-menu-item') {
            municipalMenuItemHandler(contextMenu, map, polygons, polygonStyle, mapOffsetY, mapOffsetX, getAddressByCoords, proj4, ymaps, showNotification);
        }

        if (event.target.id === 'settlements-menu-item') {
            settlementsMenuItemHandler(contextMenu, map, polygons, polygonStyle, mapOffsetY, mapOffsetX, getAddressByCoords, proj4, ymaps, showNotification);
        }
        
        if (event.target.id === 'forestry-menu-item') {
            forestryMenuItemHandler(contextMenu, map, polygons, polygonStyle, mapOffsetY, mapOffsetX, getAddressByCoords, proj4, ymaps, showNotification);
        }

    if (event.target.id === 'egrn-html-menu-item') {
            const lat = parseFloat(contextMenu.dataset.lat);
            const lon = parseFloat(contextMenu.dataset.lon);
            await handleEgrnRelatedAction(lat, lon, 'egrn.html');
            contextMenu.style.display = 'none';
        }
        // END: НОВЫЙ ОБРАБОТЧИК

        if (event.target.id === 'egrn-xml-menu-item') { // Обработчик для пункта "XML схема"
            const lat = parseFloat(contextMenu.dataset.lat);
            const lon = parseFloat(contextMenu.dataset.lon);
            await handleEgrnRelatedAction(lat, lon, 'схема_xml.html');
            contextMenu.style.display = 'none';
        }

        if (event.target.id === 'egrn-xml-menu-item') { // Обработчик для пункта "XML схема"
            const lat = parseFloat(contextMenu.dataset.lat);
            const lon = parseFloat(contextMenu.dataset.lon);
            await handleEgrnRelatedAction(lat, lon, 'схема_xml.html');
            contextMenu.style.display = 'none';
        }
        
           if (event.target.id === 'convert-all-msk-menu-item') {
            // Вызываем новую функцию для конвертации всех объектов
            await convertAllObjectsToMskAndCopy();
            contextMenu.style.display = 'none';
        }
        
        
        if (event.target.id === 'coords-msk-menu-item') {
    const lat = parseFloat(contextMenu.dataset.lat);
    const lon = parseFloat(contextMenu.dataset.lon);
    
    // 1. Находим полигон под точкой клика
    const targetPolygon = findPolygonAtPoint(lat, lon);

    if (!targetPolygon) {
        showNotification('Объект для конвертации не найден', 'warning', 'exclamation-triangle');
        contextMenu.style.display = 'none';
        return;
    }
    
    

    // 2. Вызываем новую функцию для конвертации и копирования
    await convertAndCopyMskCoords(targetPolygon);
    contextMenu.style.display = 'none';
}

if (event.target.id === 'quarter-msk-xml-menu-item') {
    // Вызываем новую основную функцию-обработчик
    handleGenerateQuarterMskXml();
    contextMenu.style.display = 'none';
}

        if (event.target.id === 'quarter-menu-item') {
            const lat = parseFloat(contextMenu.dataset.lat);
            const lon = parseFloat(contextMenu.dataset.lon);
            getQuarterCadastre(lat, lon);
            contextMenu.style.display = 'none';
        }

        if (event.target.id === 'all-parcels-in-quarter-menu-item') {
            const lat = parseFloat(contextMenu.dataset.lat);
            const lon = parseFloat(contextMenu.dataset.lon);
         
            const quarterData = await getAllParcelsInQuarter(lat, lon); 
    /*        if (quarterData && quarterData.quarterFeature && quarterData.quarterFeature.geometry) {
                 await saveQuarterGeometryToSupabase(quarterData.quarterFeature.properties.descr, quarterData.quarterFeature.geometry);
            }
            */
         
            contextMenu.style.display = 'none';
        }
        
        
    if (event.target.id === 'all-buildings-in-quarter-menu-item') { // ID изменен
    const lat = parseFloat(contextMenu.dataset.lat);
    const lon = parseFloat(contextMenu.dataset.lon);
    await getAllBuildingsInQuarter(lat, lon); // Функция переименована
    contextMenu.style.display = 'none';
}

          if (event.target.id === 'all-structures-in-quarter-menu-item') {
            const lat = parseFloat(contextMenu.dataset.lat);
            const lon = parseFloat(contextMenu.dataset.lon);
            await getAllStructuresInQuarter(lat, lon); // Вызываем новую функцию для Сооружений
            contextMenu.style.display = 'none';
        }
        
        if (event.target.id === 'all-zouits-in-quarter-menu-item') {
            const lat = parseFloat(contextMenu.dataset.lat);
            const lon = parseFloat(contextMenu.dataset.lon);
            await getAllZouitsInQuarter(lat, lon);
            contextMenu.style.display = 'none';
        }

 
const ownershipLegendList = document.getElementById('ownership-legend-list');
if (ownershipLegendList) {
    ownershipLegendList.addEventListener('click', handleOwnershipLegendClick);
} else {
    console.error("Ownership Legend list element not found!");
}

        if (event.target.id === 'location-menu-item') {
            if (navigator.geolocation) {
                navigator.geolocation.getCurrentPosition(
                    function (position) {
                        const latitude = position.coords.latitude;
                        const longitude = position.coords.longitude;

                        map.setCenter([latitude, longitude], 15);

                        const placemark = new ymaps.Placemark([latitude, longitude], {
                            hintContent: 'Ваше местоположение'
                        }, {
                            preset: 'islands#redDotIcon',
                            draggable: true
                        });
                        map.geoObjects.add(placemark);
                        polygons.push(placemark);

                        getAddressByCoords([latitude, longitude]).then(address => {
                            document.getElementById('city-name-display').innerHTML = address;
                        });



                        showNotification('Ваше местоположение найдено', 'success', 'check-circle');
                    },
                    function (error) {
                        console.error('Ошибка при получении местоположения:', error);
                        showNotification('Не удалось определить местоположение', 'error', 'exclamation-circle');
                    }
                );
            } else {
                showNotification('Браузер не поддерживает Geolocation API', 'error', 'exclamation-circle');
            }
            contextMenu.style.display = 'none';
        }

       if (event.target.id === 'copy-cadastre-number-menu-item') {
    try {
        let candidateNumbers = [];
        map.geoObjects.each(function (geoObject) {
            if (geoObject instanceof ymaps.Placemark && geoObject.properties.get('iconContent')) {
                const content = geoObject.properties.get('iconContent');
                // Исключаем номера, начинающиеся с двоеточия и следующих за ним цифр
                if (!/^\s*:\d+/.test(content) && !candidateNumbers.includes(content)) {
                    candidateNumbers.push(content);
                }
            }
        });

        // Получаем текст из city-name-display
        const cityNameDisplayElement = document.getElementById('city-name-display');
        const cityName = cityNameDisplayElement.textContent.trim();

        // Добавляем текст city-name-display в список кандидатов, если он не пустой и еще не включен
        if (cityName && !candidateNumbers.includes(cityName)) {
            candidateNumbers = [cityName, ...candidateNumbers]; // Добавляем в начало списка
        }

        if (candidateNumbers.length === 1) {
            await navigator.clipboard.writeText(candidateNumbers[0]);
            showNotification(`Скопировано: ${candidateNumbers[0]}`, 'success', 'check-circle');
        } else if (candidateNumbers.length > 1) {
            showSelectionModal(candidateNumbers);
        } else {
            showNotification('Текст для копирования не найден', 'error', 'exclamation-circle');
        }
    } catch (error) {
        console.error('Ошибка при копировании:', error);
        showNotification('Ошибка при копировании', 'error', 'exclamation-circle');
    }
    contextMenu.style.display = 'none';
}


if (event.target.id === 'copy-all-epsg3857-menu-item') {
        await copyAllObjectsToEPSG3857();
        contextMenu.style.display = 'none';
    }
    
    
        if (event.target.id === 'copy-coords-menu-item') {
            const lat = parseFloat(contextMenu.dataset.lat);
            const lon = parseFloat(contextMenu.dataset.lon);
            navigator.clipboard.writeText(`${lat} ${lon}`);
            showNotification('Координаты скопированы', 'success', 'check-circle');

            const placemark = new ymaps.Placemark([lat, lon], {
                iconContent: `Широта: ${lat}\nДолгота: ${lon}`
            }, {
                preset: 'islands#orangeStretchyIcon',
                draggable: true
            });
            map.geoObjects.add(placemark);
            polygons.push(placemark);

            contextMenu.style.display = 'none';
        }

   // НАЙДИТЕ ЭТОТ БЛОК В ВАШЕМ КОДЕ И ЗАМЕНИТЕ ЕГО ПОЛНОСТЬЮ
// НАЙДИТЕ ЭТОТ БЛОК В ВАШЕМ КОДЕ И ЗАМЕНИТЕ ЕГО ПОЛНОСТЬЮ
if (event.target.id === 'change-color-menu-item') {
    const lat = parseFloat(contextMenu.dataset.lat);
    const lon = parseFloat(contextMenu.dataset.lon);

    const candidatePolygons = [];
    for (const polygon of polygons) {
        if (polygon instanceof ymaps.Polygon) {
            try {
                const coords = polygon.geometry.getCoordinates()[0];
                const turfPolygon = turf.polygon([coords.map(coord => [coord[1], coord[0]])]);
                const point = turf.point([lon, lat]);
                if (turf.booleanPointInPolygon(point, turfPolygon)) {
                    candidatePolygons.push(polygon);
                }
            } catch (turfError) {
                if (polygon.geometry.contains([lat, lon])) {
                    candidatePolygons.push(polygon);
                }
            }
        }
    }
    for (const obj of areaObjects) {
        if (obj instanceof ymaps.Polygon) {
             try {
                const coords = obj.geometry.getCoordinates()[0];
                const turfPolygon = turf.polygon([coords.map(coord => [coord[1], coord[0]])]);
                const point = turf.point([lon, lat]);
                if (turf.booleanPointInPolygon(point, turfPolygon)) {
                    candidatePolygons.push(obj);
                }
            } catch(turfError) {
                 if (obj.geometry.contains([lat, lon])) { candidatePolygons.push(obj); }
            }
        }
    }

    if (candidatePolygons.length === 0) {
        showNotification('Контур не найден в выбранной точке', 'warning', 'exclamation-triangle');
        contextMenu.style.display = 'none';
        return;
    }

    let targetPolygon = candidatePolygons[0];
    let minArea = Infinity;
    candidatePolygons.forEach(polygon => {
        try {
            const coords = polygon.geometry.getCoordinates()[0];
            if (coords.length < 3) return;
            const turfPolygon = turf.polygon([coords.map(coord => [coord[1], coord[0]])]);
            const area = turf.area(turfPolygon);
            if (isFinite(area) && area < minArea) {
                minArea = area;
                targetPolygon = polygon;
            }
        } catch (e) {
            console.error("Error calculating area for polygon:", polygon, e);
        }
    });

    const modal = document.createElement('div');
    modal.className = 'color-modal';
    // <-- ИЗМЕНЕНО: HTML для модального окна теперь содержит ДВА слайдера -->
    modal.innerHTML = `
        <div class="color-modal-content">
            <h3></h3>
            <input type="color" id="color-picker" value="${targetPolygon.options.get('strokeColor') || '#ff2c2c'}">
            <div class="toggle-fill">
                <label>Заливка:</label>
                <input type="checkbox" id="fill-toggle" ${targetPolygon.options.get('fillColor') && targetPolygon.options.get('fillColor') !== '#00000000' ? 'checked' : ''}>
            </div>
            <div class="opacity-slider">
                <label>Прозрачность: <span id="opacity-value">0.2</span></label>
                <input type="range" id="opacity-slider" min="0" max="1" step="0.1" value="0.2">
            </div>
             <div class="opacity-slider"> 
                <label>Размер точки (н1): <span id="dot-size-value">${numberedDotSize}</span>px</label>
                <input type="range" id="numbered-dot-size-slider" min="6" max="24" value="${numberedDotSize}">
            </div>
            <div class="opacity-slider"> 
                <label>Размер подписи (н1): <span id="point-size-value">${numberedPointSize}</span>px</label>
                <input type="range" id="numbered-point-size-slider" min="10" max="30" value="${numberedPointSize}">
            </div>
            <div class="area-info" style="margin-top: 15px; text-align: left; width: 100%;">
                <div id="area-details" style="font-size: 0.9rem; color: #555;"></div>
            </div>
            <div class="buttons" style="display: flex; flex-wrap: wrap; justify-content: space-around; gap: 10px;">
                <button class="apply-btn" style="width: auto; min-width: 80px;"><i class="fas fa-check"></i> Применить</button>
                <button class="cancel-btn" style="width: auto; min-width: 80px;"><i class="fas fa-times"></i> Отмена</button>
                <button class="delete-btn" style="width: auto; min-width: 80px;"><i class="fas fa-trash"></i> Удалить</button>
                <button class="copy-btn" title="Копировать" style="width: auto; min-width: 80px;"><i class="fas fa-copy"></i> Скопировать</button>
                <button class="draw-line-btn" title="Нарисовать линию" style="width: auto; min-width: 80px; background-color: cornflowerblue; color: white;"><i class="fas fa-ruler-horizontal"></i> Линия</button>
                <button class="clear-all-placemarks-btn" title="Удалить метки" style="width: auto; min-width: 80px; font-size: 0.7rem; padding: 8px 12px;"><i class="fas fa-eraser"></i> Метки</button>
                <button class="copy-coords-btn" title="Копировать координаты и конвертировать из WGS84" style="width: auto; min-width: 80px; background-color: #2980b9; color: white; padding: 8px 12px; border-radius: 8px; display: flex; align-items: center; justify-content: center; gap: 5px;">
                    <i class="fas fa-map-marker-alt"></i> WGS84
                </button>
                <button id="show-points-btn" title="Отобразить точки" style="width: auto; min-width: 80px; background-color: #17a2b8; color: white;">
                     <i class="fas fa-map-pin"></i> Точки
                </button>
                <button id="show-numbered-points-btn" title="Отобразить точки c нумерацией" style="width: auto; min-width: 80px; background-color: #dc3545; color: white;">
                    <i class="fas fa-map-pin"></i> Точки н1
                </button>
            </div>
        </div>
    `;
    document.body.appendChild(modal);
    modal.style.display = 'block';
    modal.style.width = '400px';

    const colorPicker = modal.querySelector('#color-picker');
    const fillToggle = modal.querySelector('#fill-toggle');
    const opacitySlider = modal.querySelector('#opacity-slider');
    const opacityValue = modal.querySelector('#opacity-value');
    const areaDetails = modal.querySelector('#area-details');
    const applyBtn = modal.querySelector('.apply-btn');
    const cancelBtn = modal.querySelector('.cancel-btn');
    const deleteBtn = modal.querySelector('.delete-btn');
    const copyBtn = modal.querySelector('.copy-btn');
    const clearAllPlacemarksBtn = modal.querySelector('.clear-all-placemarks-btn');
    const copyCoordsBtn = modal.querySelector('.copy-coords-btn');
    const drawLineBtn = modal.querySelector('.draw-line-btn');
    const showPointsBtn = modal.querySelector('#show-points-btn');
    const showNumberedPointsBtn = modal.querySelector('#show-numbered-points-btn');
    
    // <-- НАЧАЛО ЛОГИКИ ДЛЯ ДВУХ СЛАЙДЕРОВ -->
    const dotSizeSlider = modal.querySelector('#numbered-dot-size-slider');
    const dotSizeValueSpan = modal.querySelector('#dot-size-value');
    const pointSizeSlider = modal.querySelector('#numbered-point-size-slider');
    const pointSizeValueSpan = modal.querySelector('#point-size-value');
    
    // Обработчик для слайдера размера ТОЧКИ
    dotSizeSlider.addEventListener('input', () => {
        const newSize = dotSizeSlider.value;
        dotSizeValueSpan.textContent = newSize;
        numberedDotSize = parseInt(newSize, 10);
        localStorage.setItem('numberedDotSize', numberedDotSize);
    });

    // Обработчик для слайдера размера ПОДПИСИ
    pointSizeSlider.addEventListener('input', () => {
        const newSize = pointSizeSlider.value;
        pointSizeValueSpan.textContent = newSize;
        numberedPointSize = parseInt(newSize, 10);
        localStorage.setItem('numberedPointSize', numberedPointSize);
    });
    // <-- КОНЕЦ ЛОГИКИ ДЛЯ ДВУХ СЛАЙДЕРОВ -->

    // ... (весь остальной код обработчика остается здесь без изменений)
    const currentFillColor = targetPolygon.options.get('fillColor') || '#00000000';
    let opacity = 0.2;
    if (currentFillColor && currentFillColor !== '#00000000') {
        try {
            const opacityHex = currentFillColor.slice(-2);
            const opacityValueParsed = parseInt(opacityHex, 16) / 255;
            if (!isNaN(opacityValueParsed)) {
                opacity = opacityValueParsed;
            }
        } catch (error) {
            console.warn('Ошибка парсинга прозрачности, устанавливаем значение по умолчанию (0.2)');
        }
    }
    opacitySlider.value = opacity;
    opacityValue.textContent = isNaN(opacity) ? '0' : opacity.toFixed(1);
    opacitySlider.addEventListener('input', () => {
        const newOpacity = parseFloat(opacitySlider.value);
        opacityValue.textContent = isNaN(newOpacity) ? '0' : newOpacity.toFixed(1);
    });

    try {
        const coords = targetPolygon.geometry.getCoordinates()[0];
        if (coords.length >= 3) {
            const turfPolygon = turf.polygon([coords.map(coord => [coord[1], coord[0]])]);
            const areaInSquareMeters = turf.area(turfPolygon);
            const areaInSquareMetersFormatted = Math.round(areaInSquareMeters).toLocaleString('ru-RU');
            const areaInSotkas = (areaInSquareMeters / 100).toFixed(2).replace('.', ',');
            const areaInHectares = (areaInSquareMeters / 10000).toFixed(2).replace('.', ',');
            const areaInSquareKilometers = areaInSquareMeters > 1000000 ? (areaInSquareMeters / 1000000).toFixed(2).replace('.', ',') : null;
            const perimeterInMeters = turf.length(turfPolygon, { units: 'meters' });
            const roundedPerimeter = Math.round(perimeterInMeters);
            const formattedPerimeter = roundedPerimeter.toLocaleString('ru-RU') + ' м';
            let areaText = `Площадь: ~ ${areaInSquareMetersFormatted} м² | ${areaInSotkas} соток | ${areaInHectares} га`;
            if (areaInSquareKilometers) { areaText += ` | ${areaInSquareKilometers} км²`; }
            areaText += ` | Периметр: ${formattedPerimeter}`;
            areaDetails.innerHTML = areaText;
        } else {
            areaDetails.innerHTML = "Площадь/Периметр: недостаточно точек";
        }
    } catch (e) {
        console.error("Error calculating/displaying area/perimeter info:", e);
        areaDetails.innerHTML = "Площадь/Периметр: не удалось рассчитать";
    }

    applyBtn.addEventListener('click', () => {
        const newColor = colorPicker.value;
        const fillEnabled = fillToggle.checked;
        const opacity = parseFloat(opacitySlider.value) || 0;
        const opacityHex = Math.round(opacity * 255).toString(16).padStart(2, '0');
        targetPolygon.options.set({
            strokeColor: newColor,
            fillColor: fillEnabled ? `${newColor}${opacityHex}` : '#00000000'
        });
        document.body.removeChild(modal);
    });
    cancelBtn.addEventListener('click', () => { document.body.removeChild(modal); });
    deleteBtn.addEventListener('click', () => {
        if (map.geoObjects.indexOf(targetPolygon) !== -1) { map.geoObjects.remove(targetPolygon); }
        polygons = polygons.filter(p => p !== targetPolygon);
        areaObjects = areaObjects.filter(obj => obj !== targetPolygon);
        const pointsToRemove = [];
        polygons.forEach(p => {
            if (p instanceof ymaps.Placemark && p.properties.get('isVertexPoint') === true && p.properties.get('relatedPolygon') === targetPolygon) {
                pointsToRemove.push(p);
            }
        });
        pointsToRemove.forEach(p => {
            if (map.geoObjects.indexOf(p) !== -1) { map.geoObjects.remove(p); }
            polygons = polygons.filter(poly => poly !== p);
        });
        document.body.removeChild(modal);
    });
    copyBtn.addEventListener('click', () => {
        const newColor = colorPicker.value;
        const opacity = parseFloat(opacitySlider.value) || 0;
        const opacityHex = Math.round(opacity * 255).toString(16).padStart(2, '0');
        copyPolygonWithMap(targetPolygon, newColor, opacityHex);
        document.body.removeChild(modal);
        showNotification('Объект скопирован для перемещения', 'success', 'check-circle');
    });
    clearAllPlacemarksBtn.addEventListener('click', () => {
        const placemarksToRemove = [];
        map.geoObjects.each(function (geoObject) {
            if (geoObject instanceof ymaps.Placemark) { placemarksToRemove.push(geoObject); }
        });
        placemarksToRemove.forEach(pm => {
            if (map.geoObjects.indexOf(pm) !== -1) { map.geoObjects.remove(pm); }
        });
        polygons = polygons.filter(p => !(p instanceof ymaps.Placemark));
        areaObjects = areaObjects.filter(obj => !(obj instanceof ymaps.Placemark));
        parcelPlacemarks = parcelPlacemarks.filter(pm => placemarksToRemove.indexOf(pm) === -1);
        selectedPlacemark = null;
        document.body.removeChild(modal);
        showNotification('Все метки удалены', 'success', 'check-circle');
    });
    copyCoordsBtn.addEventListener('click', () => {
        copyPolygonCoordinatesAndOpenSite(targetPolygon);
        document.body.removeChild(modal);
    });
    drawLineBtn.addEventListener('click', () => {
        const currentLineWidth = parseInt(document.getElementById('lineWidth').value) || 3;
        startLineDrawing(colorPicker.value, currentLineWidth);
        document.body.removeChild(modal);
    });
    showPointsBtn.addEventListener('click', () => {
        const pointsToRemove = [];
        polygons.forEach(p => {
            if (p instanceof ymaps.Placemark && p.properties.get('isVertexPoint') === true && p.properties.get('relatedPolygon') === targetPolygon) {
                pointsToRemove.push(p);
            }
        });
        pointsToRemove.forEach(p => {
            if (map.geoObjects.indexOf(p) !== -1) { map.geoObjects.remove(p); }
            polygons = polygons.filter(poly => poly !== p);
        });
        let coordinates = [];
        if (targetPolygon instanceof ymaps.Polygon && targetPolygon.geometry.getCoordinates().length > 0) {
            coordinates = targetPolygon.geometry.getCoordinates()[0];
        } else {
            showNotification('Не удалось получить координаты полигона', 'error');
            document.body.removeChild(modal);
            return;
        }
        let addedPointsCount = 0;
        const actualParcelPolygons = polygons.filter(p =>
            p instanceof ymaps.Polygon &&
            (p.properties.get('isParcelInQuarter') || p.properties.get('isFoundInArea') || p.properties.get('featureData')) &&
            p !== targetPolygon
        );
        function getPointColor(vertexCoords, currentTargetPolygon, otherParcelPolygons) {
            const epsilon = 1e-7;
            let color = '#000000';
            let isSharedVertex = false;
            const targetTurfPoint = turf.point([vertexCoords[1], vertexCoords[0]]);
            for (const otherPoly of otherParcelPolygons) {
                const otherPolyCoords = otherPoly.geometry.getCoordinates()[0];
                for (const otherVertex of otherPolyCoords) {
                    if (Math.abs(vertexCoords[0] - otherVertex[0]) < epsilon &&
                        Math.abs(vertexCoords[1] - otherVertex[1]) < epsilon) {
                        isSharedVertex = true;
                        break;
                    }
                }
                if (isSharedVertex) break;
            }
            if (isSharedVertex) { return '#305CDE'; }
            for (const otherPoly of otherParcelPolygons) {
                const otherPolyCoords = otherPoly.geometry.getCoordinates()[0];
                try {
                    if (otherPolyCoords.length < 3) continue;
                    const firstPt = otherPolyCoords[0];
                    const lastPt = otherPolyCoords[otherPolyCoords.length - 1];
                    let turfReadyCoords = otherPolyCoords.map(c => [c[1], c[0]]);
                    if (Math.abs(firstPt[0] - lastPt[0]) > epsilon || Math.abs(firstPt[1] - lastPt[1]) > epsilon) {
                        turfReadyCoords.push([firstPt[1], firstPt[0]]);
                    }
                    const otherTurfPoly = turf.polygon([turfReadyCoords]);
                    if (turf.booleanPointInPolygon(targetTurfPoint, otherTurfPoly)) {
                        color = '#FF0000';
                        break;
                    }
                } catch (e) { console.warn("Error in turf.booleanPointInPolygon during color check:", e, otherPoly); }
            }
            return color;
        }
        coordinates.forEach(coord => {
            if (!Array.isArray(coord) || coord.length !== 2) return;
            const pointColor = getPointColor(coord, targetPolygon, actualParcelPolygons);
            const pointMarker = new ymaps.Placemark(coord, {}, {
                iconLayout: 'default#image',
                iconImageHref: 'data:image/svg+xml;base64,' + btoa(`<svg xmlns="http://www.w3.org/2000/svg" width="8" height="8"><circle cx="4" cy="4" r="4" fill="${pointColor}"/></svg>`),
                iconImageSize: [8, 8],
                iconImageOffset: [-4, -4],
                zIndex: 1100
            });
            pointMarker.properties.set('isVertexPoint', true);
            pointMarker.properties.set('relatedPolygon', targetPolygon);
            map.geoObjects.add(pointMarker);
            polygons.push(pointMarker);
            addedPointsCount++;
        });
        document.body.removeChild(modal);
        let displayCount = addedPointsCount;
        if (addedPointsCount > 0 && coordinates.length > 1 &&
            Math.abs(coordinates[0][0] - coordinates[coordinates.length - 1][0]) < 1e-7 &&
            Math.abs(coordinates[0][1] - coordinates[coordinates.length - 1][1]) < 1e-7) {
            displayCount = addedPointsCount > 1 ? addedPointsCount - 1 : addedPointsCount;
        } else if (addedPointsCount > 0 && coordinates.length <= 2) {
            displayCount = addedPointsCount;
        } else if (addedPointsCount === 0 && coordinates.length > 0) {
            displayCount = 0;
        }
        showNotification(`Отображено ${displayCount} точек полигона`, 'success', 'check-circle');
    });

    showNumberedPointsBtn.addEventListener('click', () => {
        // ... (код очистки предыдущих точек и получения координат остается)
        const pointsToRemove = [];
        polygons.forEach(p => {
            if (p instanceof ymaps.Placemark && p.properties.get('isVertexPoint') === true && p.properties.get('relatedPolygon') === targetPolygon) {
                pointsToRemove.push(p);
            }
        });
        pointsToRemove.forEach(p => {
            if (map.geoObjects.indexOf(p) !== -1) { map.geoObjects.remove(p); }
            polygons = polygons.filter(poly => poly !== p);
        });

        let coordinates = [];
        if (targetPolygon instanceof ymaps.Polygon && targetPolygon.geometry.getCoordinates().length > 0) {
            coordinates = targetPolygon.geometry.getCoordinates()[0];
        } else {
            showNotification('Не удалось получить координаты полигона', 'error');
            document.body.removeChild(modal);
            return;
        }
        const isClosed = coordinates.length > 1 &&
            Math.abs(coordinates[0][0] - coordinates[coordinates.length - 1][0]) < 1e-7 &&
            Math.abs(coordinates[0][1] - coordinates[coordinates.length - 1][1]) < 1e-7;
        
        // ... (код расчета смещения finalOffset остается)
        
        const pointsToAdd = [];
        const numPoints = isClosed ? coordinates.length - 1 : coordinates.length;
        if (numPoints < 1) return;
        for (let i = 0; i < numPoints; i++) {
            const currentCoord = coordinates[i];
            const prevIndex = (i - 1 + numPoints) % numPoints;
            const nextIndex = (i + 1) % numPoints;
            const prevCoord = coordinates[prevIndex];
            const nextCoord = coordinates[nextIndex];
            const projection = map.options.get('projection');
            const zoom = map.getZoom();
            const currentPx = projection.toGlobalPixels(currentCoord, zoom);
            const prevPx = projection.toGlobalPixels(prevCoord, zoom);
            const nextPx = projection.toGlobalPixels(nextCoord, zoom);
            const v1 = [prevPx[0] - currentPx[0], prevPx[1] - currentPx[1]];
            const v2 = [nextPx[0] - currentPx[0], nextPx[1] - currentPx[1]];
            const mag1 = Math.sqrt(v1[0] * v1[0] + v1[1] * v1[1]);
            const u1 = mag1 > 0 ? [v1[0] / mag1, v1[1] / mag1] : [0, 0];
            const mag2 = Math.sqrt(v2[0] * v2[0] + v2[1] * v2[1]);
            const u2 = mag2 > 0 ? [v2[0] / mag2, v2[1] / mag2] : [0, 0];
            const bisector = [u1[0] + u2[0], u1[1] + u2[1]];
            const outwardBisector = [-bisector[0], -bisector[1]];
            const magOut = Math.sqrt(outwardBisector[0] * outwardBisector[0] + outwardBisector[1] * outwardBisector[1]);
            const finalDirection = magOut > 0 ? [outwardBisector[0] / magOut, outwardBisector[1] / magOut] : [1, 0];
            const offsetDistance = 30; 
            const finalOffset = [
                Math.round(finalDirection[0] * offsetDistance),
                Math.round(finalDirection[1] * offsetDistance)
            ];

            const placemarkLabel = `н${i + 1}`;
            
            const halfSize = numberedDotSize / 2;
            const redDotMarker = new ymaps.Placemark(currentCoord, {
                dotSize: numberedDotSize
            }, {
                iconLayout: redDotLayout,
                iconOffset: [-halfSize, -halfSize],
                iconShape: { type: 'Rectangle', coordinates: [[-halfSize, -halfSize], [halfSize, halfSize]] },
                zIndex: 1140
            });
            redDotMarker.properties.set({ 'isVertexPoint': true, 'relatedPolygon': targetPolygon });
            pointsToAdd.push(redDotMarker);
            
            // <-- ИЗМЕНЕНО: Используем переменную для размера подписи -->
            const textLabelMarker = new ymaps.Placemark(currentCoord, {
                iconContent: placemarkLabel,
                hintContent: `Точка ${placemarkLabel}`,
                fontSize: numberedPointSize // Используем переменную для размера подписи
            }, {
                iconLayout: numberedPointLayout,
                iconOffset: finalOffset,
                zIndex: 1150
            });
            textLabelMarker.properties.set({ 'isVertexPoint': true, 'relatedPolygon': targetPolygon });
            pointsToAdd.push(textLabelMarker);
        }
        pointsToAdd.forEach(pm => {
            map.geoObjects.add(pm);
            polygons.push(pm);
        });
        document.body.removeChild(modal);
        showNotification(`Отображено ${numPoints} нумерованных точек`, 'success', 'check-circle');
    });

    modal.addEventListener('click', (e) => {
        if (e.target === modal) {
            document.body.removeChild(modal);
        }
    });

    contextMenu.style.display = 'none';
}

    });

    // Установка сохраненного режима карты
 const savedMode = localStorage.getItem('mapMode') || 'map';
    setMapMode(savedMode);

    document.querySelectorAll('.map-mode-button').forEach(button => {
        if (button.getAttribute('data-mode') === savedMode) {
            button.classList.add('active');
        }
    });

    mapOffsetX = parseFloat(localStorage.getItem('mapOffsetX')) || -4.5;
    mapOffsetY = parseFloat(localStorage.getItem('mapOffsetY')) || -1;
    document.getElementById('mapOffsetX').value = mapOffsetX;
    document.getElementById('mapOffsetY').value = mapOffsetY;

    // Инициализация метки высоты
    if (isCameraHeightLabelVisible) {
        updateCameraHeightLabel();
    }
}






let lineDrawingActive = false;
let linePoints = [];
let currentLine = null;

function startLineDrawing(lineColor, lineWidth) {
    if (distanceMeasurementActive) {
        stopDistanceMeasurement();
    }
    if (areaMeasurementActive) {
        stopAreaMeasurement();
    }

    lineDrawingActive = true;
    linePoints = [];
    currentLine = null;
    mapElement.classList.add('drawing-line');

    currentLineColor = lineColor || '#ff0000';
    currentLineWidth = parseInt(lineWidth) || 3;

    // Используем map.geoObjects.each для итерации
    map.geoObjects.each(function (obj) {
        if (obj instanceof ymaps.Polygon && obj.options) {
            // obj.originalInteractivity = obj.options.get('interactivityModel', 'default#geoObject'); // Если нужно сохранять разную интерактивность
            obj.options.set('interactivityModel', 'default#transparent');
        }
         // else if (obj instanceof ymaps.Polyline && obj.options) { // Можно добавить для линий
         //    obj.options.set('interactivityModel', 'default#transparent');
         // }
    });

    map.events.add('click', onMapClickForLineDrawing);
    map.events.add('dblclick', onMapDoubleClickForLineDrawing);
}






function updateCurrentLine() {
    if (currentLine) {
        map.geoObjects.remove(currentLine);
        polygons = polygons.filter(p => p !== currentLine);
    }

    // Используем сохраненные/установленные стили
    currentLine = new ymaps.Polyline(linePoints, {}, {
        strokeColor: currentLineColor,
        strokeWidth: currentLineWidth,
        strokeOpacity: 0.8
    });

    map.geoObjects.add(currentLine);
    polygons.push(currentLine);
}


function onMapClickForLineDrawing(e) {
    if (!lineDrawingActive) return;

    const coords = e.get('coords');
    linePoints.push(coords);

    /* --- НАЧАЛО ИЗМЕНЕНИЙ: Удаление маркера точки ---
    // Добавляем маркер точки (не обязательно, но полезно для визуализации)
    // const pointMarker = new ymaps.Placemark(coords, {}, {
    //     preset: 'islands#redDotIcon', // Маленькая красная точка
    //     // Убедимся, что маркеры не мешают кликам для рисования
    //     interactivityModel: 'default#transparent'
    // });
    // map.geoObjects.add(pointMarker);
    // polygons.push(pointMarker); // Добавляем маркер в общий список для возможной очистки
    --- КОНЕЦ ИЗМЕНЕНИЙ --- */

    // Обновляем полилинию, если есть хотя бы 2 точки
    if (linePoints.length >= 2) {
        updateCurrentLine();
    }
}

function onMapDoubleClickForLineDrawing(e) {
    if (!lineDrawingActive) return;

    e.preventDefault();
    if (linePoints.length >= 2) {
        updateCurrentLine();
    }
    stopLineDrawing();
}

function stopLineDrawing() {
    if (!lineDrawingActive) return;

    lineDrawingActive = false;
    mapElement.classList.remove('drawing-line');
    map.events.remove('click', onMapClickForLineDrawing);
    map.events.remove('dblclick', onMapDoubleClickForLineDrawing);

    // Сохраняем оригинальный стиль на *финальной* линии, если она была создана
    if (currentLine && currentLine instanceof ymaps.Polyline) {
        // Сохраняем оригинальные стили как свойства объекта
        currentLine.originalStyle = {
            strokeColor: currentLine.options.get('strokeColor', currentLineColor), // Используем текущий цвет линии
            strokeWidth: currentLine.options.get('strokeWidth', currentLineWidth)  // Используем текущую ширину линии
        };
        // Добавляем флаг, чтобы отличить эти линии от других полилиний
        currentLine.isDrawableLine = true;
    }

    // Восстанавливаем интерактивность полигонов
    map.geoObjects.each(function (obj) {
         if (obj instanceof ymaps.Polygon && obj.options) {
            obj.options.set('interactivityModel', 'default#geoObject');
         }
    });

    currentLine = null; // Сбрасываем временную линию
}





        function setMapMode(mode) {
            switch (mode) {
                case 'map':
                    map.setType('yandex#map');
                    break;
                case 'satellite':
                    map.setType('yandex#satellite');
                    break;
                case 'hybrid':
                    map.setType('yandex#hybrid');
                    break;
                    
                    case 'blank': 
                    map.setType(null); 
                    break;
            }
            localStorage.setItem('mapMode', mode);
        }

        function updateCity(address) {
            ymaps.geocode(address, {
                results: 1
            }).then(function (result) {
                const firstGeoObject = result.geoObjects.get(0);
                if (firstGeoObject) {
                    const coords = firstGeoObject.geometry.getCoordinates();

                    // Запускаем анимацию
                    animateMapZoom();

                    // Устанавливаем новый центр карты
                    map.setCenter(coords, 19);

                    // Обновляем адрес
                    const addressComponents = firstGeoObject.getAddressLine().split(', ');
                    let formattedAddress = '';
                    for (let i = 0; i < addressComponents.length; i++) {
                        formattedAddress += addressComponents[i] + '<br>';
                    }
                    document.getElementById('city-name-display').innerHTML = formattedAddress;
                    localStorage.setItem('city', formattedAddress);

                    // Очищаем старые объекты и добавляем новый маркер
                    map.geoObjects.removeAll();
                    const placemark = new ymaps.Placemark(coords, {
                        hintContent: firstGeoObject.getAddressLine()
                    });
                    map.geoObjects.add(placemark);
                } else {
                    document.getElementById('city-name-display').textContent = 'Адрес не найден';
                }
            });
        }

        // Открытие модального окна
        function openGradientModal() {
            const gradientModal = document.getElementById('gradientModal');
            gradientModal.style.display = 'block';

            // Восстановление сохраненных цветов, если они есть
            const savedColors = JSON.parse(localStorage.getItem('widgetGradientColors'));
            if (savedColors && savedColors.length === 3) {
                document.getElementById('color1').value = savedColors[0];
                document.getElementById('color2').value = savedColors[1];
                document.getElementById('color3').value = savedColors[2];
            }
        }

        // Закрытие модального окна
        function closeGradientModal() {
            const gradientModal = document.getElementById('gradientModal');
            gradientModal.style.display = 'none';
        }

        // Восстановление цветов при загрузке страницы
     function loadGradientColors() {
    const savedColors = JSON.parse(localStorage.getItem('widgetGradientColors'));
    const savedFontColor = localStorage.getItem('widgetFontColor');
    const widget = document.querySelector('.widget');
    const styleModalContent = document.querySelector('.style-modal-content');
    const cityNameDisplay = document.getElementById('city-name-display');
    const fontColorInput = document.getElementById('fontColor');
    const map = document.getElementById('map');
    // Add this line where you load other styles from localStorage
polygonStyle.thematicCostColor = localStorage.getItem('thematicCostColor') || polygonStyle.thematicCostColor;

    if (savedColors && savedColors.length === 3) {
        widget.style.background = `linear-gradient(135deg, ${savedColors[0]}, ${savedColors[1]}, ${savedColors[2]})`;
        styleModalContent.style.background = `linear-gradient(135deg, ${savedColors[0]}, ${savedColors[1]}, ${savedColors[2]})`;
        map.style.borderColor = savedColors[1];
    } else {
        const defaultColors = ["#3B82F6", "#60A5FA", "#1E3A8A"]; // Новая палитра
        widget.style.background = `linear-gradient(135deg, ${defaultColors[0]}, ${defaultColors[1]}, ${defaultColors[2]})`;
        styleModalContent.style.background = `linear-gradient(135deg, ${defaultColors[0]}, ${defaultColors[1]}, ${defaultColors[2]})`;
        map.style.borderColor = defaultColors[1];
    }

    if (savedFontColor) {
        widget.style.color = savedFontColor;
        styleModalContent.style.color = savedFontColor;
        cityNameDisplay.style.color = savedFontColor;
        fontColorInput.value = savedFontColor;
        widget.querySelectorAll('i').forEach(icon => {
            icon.style.color = savedFontColor;
        });
        widget.style.setProperty('--widget-border-color', savedFontColor);
    } else {
        const defaultFontColor = "#F9FAFB";
        widget.style.color = defaultFontColor;
        styleModalContent.style.color = defaultFontColor;
        cityNameDisplay.style.color = defaultFontColor;
        fontColorInput.value = defaultFontColor;
        widget.querySelectorAll('i').forEach(icon => {
            icon.style.color = defaultFontColor;
        });
        widget.style.setProperty('--widget-border-color', defaultFontColor);
    }
}


function copyPolygonWithMap(originalPolygon, strokeColor, opacityHex) {
    // Получаем координаты исходного полигона
    const originalCoords = originalPolygon.geometry.getCoordinates()[0];
    const bounds = originalPolygon.geometry.getBounds();

    // Получаем текущие стили оригинального полигона
    const originalFillColor = originalPolygon.options.get('fillColor') || '#00000000';
    const originalStrokeWidth = originalPolygon.options.get('strokeWidth') || 2;
    const originalStrokeOpacity = originalPolygon.options.get('strokeOpacity') || 0.8;

    // Создаем копию полигона с текущими стилями или новыми из модального окна
    const copiedPolygon = new ymaps.Polygon([originalCoords], {}, {
        strokeColor: strokeColor, // Новый цвет линии из модального окна
        strokeWidth: originalStrokeWidth, // Сохраняем толщину линии
        strokeOpacity: originalStrokeOpacity, // Сохраняем прозрачность линии
        fillColor: originalFillColor, // Сохраняем заливку (если была)
        hintEnabled: false,
        hasBalloon: false,
        interactivityModel: 'default#transparent',
        draggable: true // Делаем полигон перетаскиваемым
    });

    // Добавляем копию полигона на карту
    map.geoObjects.add(copiedPolygon);

    // Сохраняем копию в polygons для дальнейшего управления
    polygons.push(copiedPolygon);

    // Переменные для перетаскивания
    let isDragging = false;
    let startPixelCoords = null; // Пиксельные координаты начала перетаскивания
    let originalGeoCoords = null; // Географические координаты полигона при начале перетаскивания

    copiedPolygon.events.add('dragstart', function (e) {
        isDragging = true;
        // Получаем пиксельные координаты начала перетаскивания
        startPixelCoords = e.get('pixelCoordinates');
        // Сохраняем исходные географические координаты полигона
        originalGeoCoords = copiedPolygon.geometry.getCoordinates()[0].slice();
    });

    copiedPolygon.events.add('drag', function (e) {
        if (!isDragging || !startPixelCoords || !originalGeoCoords) return;

        // Получаем текущие пиксельные координаты курсора
        const currentPixelCoords = e.get('pixelCoordinates');

        // Вычисляем смещение в пикселях
        const deltaPixelX = currentPixelCoords[0] - startPixelCoords[0];
        const deltaPixelY = currentPixelCoords[1] - startPixelCoords[1];

        // Преобразуем пиксельное смещение в географические координаты
        const projection = map.options.get('projection');
        const zoomLevel = map.getZoom();

        // Получаем центр полигона как базовую точку
        const centerGeo = [
            (bounds[0][0] + bounds[1][0]) / 2,
            (bounds[0][1] + bounds[1][1]) / 2
        ];
        const centerPixel = projection.toGlobalPixels(centerGeo, zoomLevel);

        // Вычисляем новые пиксельные координаты центра
        const newCenterPixel = [
            centerPixel[0] + deltaPixelX,
            centerPixel[1] + deltaPixelY
        ];

        // Преобразуем новые пиксельные координаты обратно в географические
        const newCenterGeo = projection.fromGlobalPixels(newCenterPixel, zoomLevel);

        // Вычисляем смещение в географических координатах
        const deltaLat = newCenterGeo[0] - centerGeo[0];
        const deltaLon = newCenterGeo[1] - centerGeo[1];

        // Применяем смещение ко всем координатам полигона
        const newCoords = originalGeoCoords.map(coord => [
            coord[0] + deltaLat,
            coord[1] + deltaLon
        ]);

        copiedPolygon.geometry.setCoordinates([newCoords]);
    });

    copiedPolygon.events.add('dragend', function () {
        isDragging = false;
        startPixelCoords = null;
        originalGeoCoords = null;
    });

    // Уведомление о копировании
    showNotification('Объект скопирован для перемещения', 'success', 'check-circle');
}

        // Применение выбранных цветов
     function applyGradient() {
    const color1 = document.getElementById('color1').value;
    const color2 = document.getElementById('color2').value;
    const color3 = document.getElementById('color3').value;
    const fontColor = document.getElementById('fontColor').value;

    const widget = document.querySelector('.widget');
    const styleModalContent = document.querySelector('.style-modal-content');
    const cityNameDisplay = document.getElementById('city-name-display');
    const map = document.getElementById('map');

    // Применяем градиент
    widget.style.background = `linear-gradient(135deg, ${color1}, ${color2}, ${color3})`;
    styleModalContent.style.background = `linear-gradient(135deg, ${color1}, ${color2}, ${color3})`;
    map.style.borderColor = color2;

    // Применяем цвет шрифта и иконок
    widget.style.color = fontColor;
    styleModalContent.style.color = fontColor;
    widget.querySelectorAll('i').forEach(icon => {
        icon.style.color = fontColor;
    });
    cityNameDisplay.style.color = fontColor;

    // Устанавливаем цвет рамки
    widget.style.setProperty('--widget-border-color', fontColor);

    // Сохранение цветов в localStorage
    localStorage.setItem('widgetGradientColors', JSON.stringify([color1, color2, color3]));
    localStorage.setItem('widgetFontColor', fontColor);

    closeGradientModal();
    showHistoryModal(); // Добавлено: обновляем вид истории
}

        // Сброс цветов (обновленная)
    function resetGradient() {
    const defaultColors = ["#3B82F6", "#60A5FA", "#1E3A8A"]; // Новая палитра
    const defaultFontColor = "#F9FAFB"; // Новый цвет шрифта
    const fontColorInput = document.getElementById('fontColor');
    const map = document.getElementById('map');

    document.getElementById('color1').value = defaultColors[0];
    document.getElementById('color2').value = defaultColors[1];
    document.getElementById('color3').value = defaultColors[2];
    document.getElementById('fontColor').value = defaultFontColor;
    fontColorInput.value = defaultFontColor;

    const cityNameDisplay = document.getElementById('city-name-display');

    const widget = document.querySelector('.widget');
    const styleModalContent = document.querySelector('.style-modal-content');
    widget.style.background = `linear-gradient(135deg, ${defaultColors[0]}, ${defaultColors[1]}, ${defaultColors[2]})`;
    styleModalContent.style.background = `linear-gradient(135deg, ${defaultColors[0]}, ${defaultColors[1]}, ${defaultColors[2]})`;
    widget.style.color = defaultFontColor;
    styleModalContent.style.color = defaultFontColor;
    cityNameDisplay.style.color = defaultFontColor;
    map.style.borderColor = defaultColors[1]; // Средний цвет для границы карты

    widget.querySelectorAll('i').forEach(icon => {
        icon.style.color = defaultFontColor;
    });

    widget.style.setProperty('--widget-border-color', defaultFontColor);

    localStorage.removeItem('widgetGradientColors');
    localStorage.removeItem('widgetFontColor');
    showHistoryModal(); // Обновляем вид истории
}


        document.addEventListener('DOMContentLoaded', () => {
    
    const savedGoogleEarthSetting = localStorage.getItem('openGoogleEarthAfterExport');
    openGoogleEarthAfterExport = savedGoogleEarthSetting === null ? true : (savedGoogleEarthSetting === 'true');
    const toggleOpenGoogleEarthCheckbox = document.getElementById('toggleOpenGoogleEarth');
    if (toggleOpenGoogleEarthCheckbox) {
        toggleOpenGoogleEarthCheckbox.checked = openGoogleEarthAfterExport;
        if (!toggleOpenGoogleEarthCheckbox.onchange) {
             toggleOpenGoogleEarthCheckbox.addEventListener('change', updateGoogleEarthSetting);
        }
    }

    loadGradientColors();
    
    const importInput = document.getElementById('importFileInput');
    if (importInput) {
        importInput.addEventListener('change', handleImportFile);
    }

    // --- ИСПРАВЛЕНИЕ: Назначаем обработчик здесь ---
    const converterBtn = document.getElementById('open-converter-btn');
    if (converterBtn) {
        converterBtn.addEventListener('click', openMskConverterModal);
    } else {
        // Это сообщение больше не должно появляться после исправления HTML
        console.error('Кнопка конвертера #open-converter-btn не найдена!');
    }
    // --- КОНЕЦ ИСПРАВЛЕНИЯ ---

    const cityInput = document.getElementById('city-input');
    loaderTextEl = document.querySelector('.loading-text');

   
});

 document.querySelectorAll('.map-mode-button').forEach(button => {
    button.addEventListener('click', () => {
        const mode = button.getAttribute('data-mode');

        // Если это кнопка переключения типа карты
        if (['map', 'satellite', 'hybrid', 'blank'].includes(mode)) { // Добавили 'blank'
            setMapMode(mode);

            // Удаляем класс active у всех кнопок
            document.querySelectorAll('.map-mode-button').forEach(btn => {
                btn.classList.remove('active');
            });

            // Добавляем active только к текущей кнопке
            button.classList.add('active');
        }
    });
});

        function containsLetters(text) {
            return /[a-zA-Zа-яА-Я]/.test(text);
        }



        document.addEventListener('paste', function (event) {
            const text = event.clipboardData.getData('text');
            if (text) {
                coordsInput.value = text;
                findAndConvert();
            }
        });


      
    
         // Обработчик события paste для city-input
      cityInput.addEventListener('paste', async (event) => {
          event.preventDefault(); // Предотвращаем стандартное поведение вставки

          const text = (event.clipboardData || window.clipboardData).getData('text');
          if (!text) return;
          
          const trimmedText = text.trim();
          
          // Проверка на географические координаты (2 числа через пробел/запятую/табуляцию)
          const coordRegex = /^(-?\d+\.?\d*)\s*[,\s]\s*(-?\d+\.?\d*)$/;
          const coordMatch = trimmedText.match(coordRegex);
          
          if (coordMatch) {
              // Это координаты - извлекаем числа
              const firstNum = parseFloat(coordMatch[1]);
              const secondNum = parseFloat(coordMatch[2]);
              
              // Проверяем, может ли это быть "широта долгота"
              if (Math.abs(firstNum) <= 90 && Math.abs(secondNum) <= 180) {
              //    console.log(`Вставка координат (широта, долгота): ${firstNum}, ${secondNum}`);
                  
                  // Используем координаты в правильном порядке "широта долгота"
                  cityInput.value = trimmedText;
                  
                  // Имитируем нажатие Enter для обработки координат нашим основным обработчиком
                  const enterEvent = new KeyboardEvent('keydown', {
                      key: 'Enter',
                      code: 'Enter',
                      which: 13,
                      keyCode: 13,
                      bubbles: true
                  });
                  cityInput.dispatchEvent(enterEvent);
                  return;
              }
          }
          
          // Проверка на разделенные координаты другими способами
          const spaceSeparated = trimmedText.split(/\s+/);
          if (spaceSeparated.length === 2) {
              const lat = parseFloat(spaceSeparated[0]);
              const lon = parseFloat(spaceSeparated[1]);
              
              if (!isNaN(lat) && !isNaN(lon) && 
                  Math.abs(lat) <= 90 && Math.abs(lon) <= 180) {
                  // Это вероятно координаты в формате "широта долгота"
             //     console.log(`Вставка координат (форма 2): ${lat}, ${lon}`);
                  
                  cityInput.value = trimmedText;
                  
                  // Имитируем нажатие Enter
                  const enterEvent = new KeyboardEvent('keydown', {
                      key: 'Enter',
                      code: 'Enter',
                      which: 13,
                      keyCode: 13,
                      bubbles: true
                  });
                  cityInput.dispatchEvent(enterEvent);
                  return;
              }
          }

          // Если это не координаты, проверяем кадастровый номер
          if (isValidCadastralNumber(trimmedText)) {
              const formattedText = formatPotentialCadastralNumber(trimmedText);
              cityInput.value = formattedText;
              
              // Имитируем нажатие Enter
              const enterEvent = new KeyboardEvent('keydown', {
                  key: 'Enter',
                  code: 'Enter',
                  which: 13,
                  keyCode: 13,
                  bubbles: true
              });
              cityInput.dispatchEvent(enterEvent);
          } else {
              // Обычный текст - просто устанавливаем значение
              cityInput.value = text;
          }
      });
      


async function handleGenerateQuarterMskXml() {
    // 1. Проверяем, загружены ли данные квартала
    if (!currentQuarterNumber || !parcelFeaturesData || parcelFeaturesData.length === 0) {
        showNotification('Пожалуйста, загрузите земельные участки для кадастрового квартала', 'warning', 'exclamation-triangle');
        return;
    }

    const converterMode = localStorage.getItem('mskConverterMode');
    if (converterMode === 'api') {
        showNotification('XML КПТ генерируется только в режиме Proj4. Пожалуйста, переключите режим в окне конвертера (кнопка "МСК").', 'warning', 'exclamation-triangle', 5000);
        return;
    }

    showLoader('Подготовка XML...');

    try {
        // --- НАЧАЛО ИЗМЕНЕНИЙ: Логика получения смещения, аналогичная предыдущим функциям ---
        const destSc = localStorage.getItem('savedDefaultMskSystem') || 'EPSG:6331602';
        const destSystem = COORDINATE_SYSTEMS.find(s => s.value === destSc);
        if (!destSystem) {
            throw new Error(`Определение для ${destSc} не найдено в sk.js`);
        }

        let offsetX = 0;
        let offsetY = 0;
        const isAutoLoadEnabled = (localStorage.getItem('autoLoadMskOffset') !== 'false');

        if (isAutoLoadEnabled) {
            offsetX = destSystem.offsetX || 0;
            offsetY = destSystem.offsetY || 0;
            console.log(`[handleGenerateQuarterMskXml] Смещения загружены из sk.js для ${destSc}: X=${offsetX}, Y=${offsetY}`);
        } else {
            const offsetXRaw = localStorage.getItem('savedMskOffsetX') || '0';
            const offsetYRaw = localStorage.getItem('savedMskOffsetY') || '0';
            offsetX = parseFloat(offsetXRaw.replace(',', '.')) || 0;
            offsetY = parseFloat(offsetYRaw.replace(',', '.')) || 0;
            console.log(`[handleGenerateQuarterMskXml] Используются сохраненные вручную смещения: X=${offsetX}, Y=${offsetY}`);
        }
        // --- КОНЕЦ ИЗМЕНЕНИЙ ---

        const nspdData = { features: parcelFeaturesData };
        // Используем значения по умолчанию, как в xml_kpt.html
        const swapCoords = true;
        const reverseDirection = true;

        // 3. Конвертируем данные в XML-строку (offsetX и offsetY уже определены выше)
        const { xmlContent, filenameBase } = convertJsonToXml(
            nspdData, 
            currentQuarterNumber,
            destSc,
            offsetX, // Передаем правильное смещение
            offsetY, // Передаем правильное смещение
            swapCoords,
            reverseDirection
        );

        // 4. Создаем и скачиваем ZIP-архив
        await createAndDownloadZip(xmlContent, filenameBase);

        // 5. Копируем XML в буфер обмена
        await navigator.clipboard.writeText(xmlContent);
        showNotification('XML скопирован в буфер обмена', 'success', 'check-circle');

        // 6. Открываем схема_xml.html
        window.open('схема_xml.html', '_blank');
        
    } catch (error) {
        console.error("Ошибка при генерации XML квартала:", error);
        showNotification(`Ошибка: ${error.message}`, 'error', 'exclamation-circle');
    } finally {
        hideLoader();
    }
}

function convertJsonToXml(nspdData, quarterNumber, targetCS_value, offsetX, offsetY, swapXmlCoords, reverseDirection) {
    if (typeof COORDINATE_SYSTEMS === 'undefined') { 
        throw new Error("Список систем координат (sk.js) не загружен."); 
    }

    const targetSystem = COORDINATE_SYSTEMS.find(s => s.value === targetCS_value);
    const sourceSystem = COORDINATE_SYSTEMS.find(s => s.value === 'EPSG:3857');

    if (!targetSystem || !sourceSystem) {
        throw new Error(`Определение для ${targetCS_value} или EPSG:3857 не найдено.`);
    }
    
    proj4.defs(targetSystem.value, targetSystem.def); 
    proj4.defs(sourceSystem.value, sourceSystem.def);
    
    const today = new Date();
    const dateString = `${today.getFullYear()}-${String(today.getMonth() + 1).padStart(2, '0')}-${String(today.getDate()).padStart(2, '0')}`;
    const quarterSafe = quarterNumber.replace(/:/g, '_');
    const filenameBase = `${quarterSafe} ${dateString} NSPD`;

    const escapeXml = (unsafe) => unsafe ? String(unsafe).replace(/[<>&'"]/g, c => ({'<':'&lt;','>':'&gt;','&':'&amp;','\'':'&apos;','"':'&quot;'}[c])) : '-';

    const landRecordsXml = nspdData.features.map(feature => {
        const props = feature.properties.options || {};
        const geometry = feature.geometry;
        const finalSkId = targetSystem.text.split('(')[0].trim();

        // --- НАЧАЛО ИЗМЕНЕНИЙ ---
        const contoursXml = (geometry && geometry.coordinates) ? (() => {
            const polygonsData = geometry.type === 'MultiPolygon' ? geometry.coordinates : [geometry.coordinates];
            let contourCounter = 0; // Нумератор для тега <contour><number_pp>
            
            return polygonsData.map(polygonRings => {
                contourCounter++; // Увеличиваем счетчик для каждого полигона (внешнего контура)
                
                // polygonRings - это массив контуров [[внешний], [внутренний1], ...]
                const spatialsXml = polygonRings.map(ring => {
                    let points = ring; // ring - это массив точек [ [x1, y1], [x2, y2], ... ]
                    if (reverseDirection) { 
                        // Для внешнего контура оставляем как есть, внутренние - в обратном порядке
                        // (Согласно некоторым требованиям XML)
                        // Но API НСПД, скорее всего, уже дает правильное направление, так что пока не будем менять
                        // points = [...points].reverse(); 
                    }
                    
                    const ordinatesXml = points.map((point, i) => {
                        const convertedPoint = proj4(sourceSystem.value, targetSystem.value, point);
                        const decimalPlaces = targetCS_value === 'EPSG:4326' ? 8 : 2;
                        
                        const y_from_proj = convertedPoint[0];
                        const x_from_proj = convertedPoint[1];

                        const final_Y_with_offset = y_from_proj + offsetY;
                        const final_X_with_offset = x_from_proj + offsetX;

                        let xml_tag_x_value, xml_tag_y_value;
                        if (swapXmlCoords) {
                            xml_tag_x_value = final_X_with_offset.toFixed(decimalPlaces);
                            xml_tag_y_value = final_Y_with_offset.toFixed(decimalPlaces);
                        } else {
                            xml_tag_x_value = final_Y_with_offset.toFixed(decimalPlaces);
                            xml_tag_y_value = final_X_with_offset.toFixed(decimalPlaces);
                        }

                        return `<ordinate><x>${xml_tag_x_value}</x><y>${xml_tag_y_value}</y><ord_nmb>${i + 1}</ord_nmb><num_geopoint>${i + 1}</num_geopoint><delta_geopoint>0.0</delta_geopoint></ordinate>`;
                    }).join('');

                    return `<spatial_element><ordinates>${ordinatesXml}</ordinates></spatial_element>`;
                }).join('');

                return `<contour><number_pp>${contourCounter}</number_pp><entity_spatial><sk_id>${escapeXml(finalSkId)}</sk_id><spatials_elements>${spatialsXml}</spatials_elements></entity_spatial></contour>`;
            }).join('');
        })() : '';
        // --- КОНЕЦ ИЗМЕНЕНИЙ ---
        
        const isAreaSpecified = props.specified_area || props.land_record_area_verified;
        const areaValue = isAreaSpecified || props.declared_area || props.land_record_area_declaration || props.land_record_area;
        const areaXmlBlock = isAreaSpecified ?
            `<area><value>${escapeXml(areaValue)}</value><inaccuracy>0</inaccuracy></area>` :
            `<area><value>${escapeXml(areaValue)}</value></area>`;

        return `<land_record><object><common_data><type><code>002001001000</code><value>${escapeXml(props.land_record_type||'Земельный участок')}</value></type><cad_number>${escapeXml(props.cad_num)}</cad_number></common_data></object><params><category><type><code>003002000000</code><value>${escapeXml(props.land_record_category_type)}</value></type></category><permitted_use><permitted_use_established><by_document>${escapeXml(props.permitted_use_established_by_document)}</by_document></permitted_use_established></permitted_use>${areaXmlBlock}</params><address_location><address><readable_address>${escapeXml(props.readable_address)}</readable_address></address></address_location><cost><value>${escapeXml(props.cost_value)}</value></cost><contours_location><contours>${contoursXml}</contours></contours_location></land_record>`;
    }).join('');
    
    const fullXml = `<?xml version="1.0" encoding="UTF-8"?><extract_cadastral_plan_territory><details_statement><group_top_requisites><organ_registr_rights>Филиал ППК "Роскадастр" (данные из НСПД)</organ_registr_rights><date_formation>${dateString}</date_formation><registration_number>НСПД-КОНВЕРТЕР</registration_number></group_top_requisites></details_statement><cadastral_blocks><cadastral_block><cadastral_number>${escapeXml(quarterNumber)}</cadastral_number><record_data><base_data><land_records>${landRecordsXml}</land_records></base_data></record_data></cadastral_block></cadastral_blocks></extract_cadastral_plan_territory>`;
    
    return { xmlContent: fullXml, filenameBase };
}





async function convertAllObjectsToMskAndCopy() {
    try {
        // 1. Собираем все объекты для конвертации
        const allDrawableObjects = new Set([...polygons, ...areaObjects]);
        const objectsToConvert = Array.from(allDrawableObjects).filter(obj => 
            obj instanceof ymaps.Polygon || obj instanceof ymaps.Polyline
        );

        if (objectsToConvert.length === 0) {
            showNotification('На карте нет объектов для конвертации', 'warning', 'exclamation-triangle');
            return;
        }
        
        showLoader(`Конвертация ${objectsToConvert.length} объектов...`);

        // --- НАЧАЛО ИЗМЕНЕНИЙ: Логика получения смещения, аналогичная convertAndCopyMskCoords ---
        const destSc = localStorage.getItem('savedDefaultMskSystem') || 'EPSG:6331602';
        const destSystem = COORDINATE_SYSTEMS.find(s => s.value === destSc);
        if (!destSystem || !destSystem.def) {
            throw new Error(`Определение для ${destSc} не найдено в sk.js`);
        }

        let offsetX = 0;
        let offsetY = 0;
        const isAutoLoadEnabled = (localStorage.getItem('autoLoadMskOffset') !== 'false');

        if (isAutoLoadEnabled) {
            offsetX = destSystem.offsetX || 0;
            offsetY = destSystem.offsetY || 0;
            console.log(`[convertAllObjects] Смещения загружены из sk.js для ${destSc}: X=${offsetX}, Y=${offsetY}`);
        } else {
            const offsetXRaw = localStorage.getItem('savedMskOffsetX') || '0';
            const offsetYRaw = localStorage.getItem('savedMskOffsetY') || '0';
            offsetX = parseFloat(offsetXRaw.replace(',', '.')) || 0;
            offsetY = parseFloat(offsetYRaw.replace(',', '.')) || 0;
            console.log(`[convertAllObjects] Используются сохраненные вручную смещения: X=${offsetX}, Y=${offsetY}`);
        }
        // --- КОНЕЦ ИЗМЕНЕНИЙ ---
        
        const allMskBlocks = [];

        // 3. Проходим по каждому объекту
        for (const targetObject of objectsToConvert) {
            if (targetObject instanceof ymaps.Polygon) {
                const yandexCoordRings = targetObject.geometry.getCoordinates();
                const currentObjectMskBlocks = [];

                for (const ring of yandexCoordRings) {
                    const reversedYandexCoords = [...ring].reverse();
                    const wgs84Coords = reversedYandexCoords.map(coord => {
                        const trueLat = coord[0] + (mapOffsetY * 0.000008983);
                        const trueLon = coord[1] + (mapOffsetX * 0.000008983);
                        return [trueLon, trueLat];
                    });
                    const mskCoordsText = convertWgs84ToMskWithOffset(wgs84Coords, destSc, destSystem.def, offsetX, offsetY);
                    currentObjectMskBlocks.push(mskCoordsText);
                }
                allMskBlocks.push(currentObjectMskBlocks.join('\n\n'));

            } else { // Polyline
                const yandexCoords = targetObject.geometry.getCoordinates();
                const reversedYandexCoords = [...yandexCoords].reverse();
                const wgs84Coords = reversedYandexCoords.map(coord => {
                    const trueLat = coord[0] + (mapOffsetY * 0.000008983);
                    const trueLon = coord[1] + (mapOffsetX * 0.000008983);
                    return [trueLon, trueLat];
                });
                const mskCoordsText = convertWgs84ToMskWithOffset(wgs84Coords, destSc, destSystem.def, offsetX, offsetY);
                allMskBlocks.push(mskCoordsText);
            }
        }

        // 4. Объединяем результаты, копируем и открываем новую вкладку
        const finalStringToCopy = allMskBlocks.join('\n\n');
        await navigator.clipboard.writeText(finalStringToCopy);
        
        let notificationMessage = `Координаты ${objectsToConvert.length} объектов скопированы в ${destSystem.text}`;
        if (offsetX !== 0 || offsetY !== 0) {
            notificationMessage += ` (со смещением)`;
        }
        showNotification(notificationMessage, 'success', 'check-circle');
        window.open('схема.html', '_blank');

    } catch (error) {
        console.error("Ошибка при конвертации всех объектов в МСК:", error);
        showNotification(`Ошибка конвертации: ${error.message}`, 'error', 'exclamation-circle');
    } finally {
        hideLoader();
    }
}

async function createAndDownloadZip(xmlContent, filenameBase) {
    const zip = new JSZip();
    zip.file(`${filenameBase}.xml`, xmlContent);
    const blob = await zip.generateAsync({
        type: "blob",
        compression: "DEFLATE",
        compressionOptions: { level: 9 }
    });
    const link = document.createElement('a');
    link.href = URL.createObjectURL(blob);
    link.download = `${filenameBase}.zip`;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    URL.revokeObjectURL(link.href);
}



function isCoordinates(text) {
    if (!text || text.trim() === "") {
        return false;
    }
    const allowedChars = /^[0-9\s\t\n.,-]+$/; // Digits, spaces, tabs, newlines, dot, comma, minus
    const hasColon = text.includes(':');
    return allowedChars.test(text) && !hasColon;
}

async function processAndDrawParcels(features, source) {
    if (!map) {
        console.error('Карта не инициализирована');
        return [];
    }

    const newlyDrawnObjects = [];
    let combinedBounds = null;
    const isQuarterSource = source === 'quarter';
    const isAreaSearchSource = source === 'areaSearch'; // Flag for search results

    for (const feature of features) {
        try {
            if (!feature?.properties?.descr || !feature?.geometry?.coordinates) {
                 console.warn("Skipping feature due to missing properties or geometry:", feature);
                 continue;
            }

            const geometryType = feature.geometry.type;
            
            // --- ИЗМЕНЕНИЕ ЗДЕСЬ ---
            const polygonsData = [];
            if (geometryType === 'Polygon' && feature.geometry.coordinates) {
                polygonsData.push(feature.geometry.coordinates);
            } else if (geometryType === 'MultiPolygon' && Array.isArray(feature.geometry.coordinates)) {
                feature.geometry.coordinates.forEach(polyCoords => polygonsData.push(polyCoords));
            } else {
                continue;
            }

            for (const polygonRings of polygonsData) {
                const allProcessedRings = polygonRings.map(ring => {
                    if (!Array.isArray(ring) || ring.length < 3) return null;

                    const coordinates = ring.map(coord => {
                        if (!Array.isArray(coord) || coord.length !== 2 || typeof coord[0] !== 'number' || typeof coord[1] !== 'number') return null;
                        try {
                            const p = proj4('EPSG:3857', 'EPSG:4326', coord);
                            return (!p || !isFinite(p[0]) || !isFinite(p[1])) ? null : [p[1], p[0]];
                        } catch { return null; }
                    }).filter(p => p !== null);
                    
                    if (coordinates.length < 3) return null;

                    return coordinates.map(coord => [coord[0] - mapOffsetY * 0.000008983, coord[1] - mapOffsetX * 0.000008983]);
                }).filter(r => r !== null);
                
                if (allProcessedRings.length === 0) continue;

                const cadastralNumber = feature.properties.descr;
                const parcelOptions = feature.properties.options || {};
                const address = parcelOptions.readable_address || 'Адрес не указан';
                const areaText = getAreaText(parcelOptions);
                const costIndex = parcelOptions.cost_index !== undefined && parcelOptions.cost_index !== null && isFinite(parseFloat(parcelOptions.cost_index)) ? parseFloat(parcelOptions.cost_index) : null;
                const vri = parcelOptions.permitted_use_established_by_document || null;
                const ownershipType = parcelOptions.ownership_type || '-';
                const rightType = parcelOptions.right_type || '-';
                const isVerified = parcelOptions.specified_area || parcelOptions.land_record_area_verified;
                const hasDeclaredField = parcelOptions.declared_area || parcelOptions.land_record_area_declaration || parcelOptions.land_record_area;
                const isDeclared = !isVerified && hasDeclaredField;
                const finalStrokeColor = isAreaSearchSource ? '#FF4500' : (isDeclared ? polygonStyle.declaredParcelsColor : polygonStyle.parcelsColor);

                const hintContent = {
                     cadastralNumber: `${cadastralNumber}`,
                     address: `${address}`,
                     area: `Площадь: ${areaText}`,
                     cost: costIndex !== null ? costIndex.toLocaleString('ru-RU', { maximumFractionDigits: 2 }) : null,
                     vri: vri,
                     ownershipType: ownershipType,
                     rightType: rightType
                 };

                 const polygonProperties = {
                     hintContent: hintContent,
                     cadastralNumber: cadastralNumber,
                     address: address,
                     areaText: areaText,
                     costIndex: costIndex,
                     vri: vri,
                     featureData: feature,
                     isParcelInQuarter: isQuarterSource,
                     isFoundInArea: isAreaSearchSource
                 };

                 const parcelPolygon = new ymaps.Polygon(allProcessedRings, polygonProperties, {
                     strokeColor: finalStrokeColor,
                     strokeWidth: polygonStyle.width - 1,
                     strokeOpacity: 0.8,
                     fillColor: '#00000000',
                     hintLayout: customHintLayout,
                     hintOpenTimeout: 100, hintCloseTimeout: 50,
                     cursor: 'pointer',
                     zIndex: isAreaSearchSource ? 800 : 500
                 });
                
                 parcelPolygon.events.add('click', function (e) {
                      if (e.get('altKey')) {
                           const options = parcelPolygon.properties.get('featureData')?.properties?.options || {};
                           const isDeclared = !options.specified_area && !options.land_record_area_verified && !options.land_record_area && (options.land_record_area_declaration || options.declared_area);
                           const baseColor = isDeclared ? polygonStyle.declaredParcelsColor : polygonStyle.parcelsColor;
                          parcelPolygon.options.set('fillColor', `${baseColor}33`);
                      }
                      else {
                         const hintData = parcelPolygon.properties.get('hintContent');
                         let balloonContent = `<strong>${hintData.cadastralNumber}</strong><br>${hintData.address}<br>${hintData.area}`;
                         if (hintData.cost) balloonContent += `<br>Стоимость: ${hintData.cost} руб./м²`;
                         if (hintData.vri) balloonContent += `<br>Разрешенное использование: ${hintData.vri}`;
                         if (hintData.ownershipInfo) balloonContent += `<br>Собственность: ${hintData.ownershipInfo}`;
                         map.balloon.open(e.get('coords'), balloonContent);
                     }
                 });
                 parcelPolygon.events.add('dblclick', async function (e) {
                     try { await navigator.clipboard.writeText(cadastralNumber); showNotification(`Скопировано: ${cadastralNumber}`, 'success', 'check-circle'); }
                     catch (err) { console.error('Ошибка копирования КН:', err); showNotification('Ошибка копирования КН', 'error', 'exclamation-circle'); }
                 });

                 map.geoObjects.add(parcelPolygon);
                 polygons.push(parcelPolygon);
                 newlyDrawnObjects.push(parcelPolygon);

                 const parcelBounds = parcelPolygon.geometry.getBounds();
                 if (parcelBounds?.[0]?.[0] !== undefined && isFinite(parcelBounds[0][0])) {
                     if (!combinedBounds) { combinedBounds = [[parcelBounds[0][0], parcelBounds[0][1]], [parcelBounds[1][0], parcelBounds[1][1]]]; }
                     else { combinedBounds[0][0] = Math.min(combinedBounds[0][0], parcelBounds[0][0]); combinedBounds[0][1] = Math.min(combinedBounds[0][1], parcelBounds[0][1]); combinedBounds[1][0] = Math.max(combinedBounds[1][0], parcelBounds[1][0]); combinedBounds[1][1] = Math.max(combinedBounds[1][1], parcelBounds[1][1]); }
                 }

                  if (parcelBounds?.[0]?.[0] !== undefined && isFinite(parcelBounds[0][0])) {
                     const parcelCenterGeo = [(parcelBounds[0][0] + parcelBounds[1][0]) / 2, (parcelBounds[0][1] + parcelBounds[1][1]) / 2];
                     const parts = cadastralNumber.split(':');
                     const hasSixOrSevenZeros = parts.length >= 3 && /^0{6,7}$/.test(parts[2]);
                     const displayNumber = hasSixOrSevenZeros ? cadastralNumber : (parts.length > 3 ? ':' + parts.pop() : cadastralNumber);

                     const labelProperties = {
                         iconContent: displayNumber,
                         hintContent: hintContent,
                         cadastralNumber: cadastralNumber
                     };
                      if (isQuarterSource) labelProperties.isParcelInQuarter = true;
                      if (isAreaSearchSource) labelProperties.isFoundInArea = true;

                     const parcelText = new ymaps.Placemark(parcelCenterGeo, labelProperties, {
                         iconLayout: customPlacemarkLayout,
                         hintLayout: customHintLayout,
                         hasBalloon: false,
                         draggable: false,
                         visible: map.getZoom() > 14,
                         zIndex: isAreaSearchSource ? 850 : 550
                     });
                     parcelText.polygon = parcelPolygon;
                     map.geoObjects.add(parcelText);
                     parcelPlacemarks.push(parcelText);
                     polygons.push(parcelText);
                     newlyDrawnObjects.push(parcelText);
                  }
            }
        } catch (error) {
            console.error('Ошибка при отрисовке земельного участка:', error, feature);
        }
    }

    if (combinedBounds && combinedBounds[0] && combinedBounds[1] && combinedBounds[0].length === 2 && combinedBounds[1].length === 2 && isFinite(combinedBounds[0][0])) {
        const currentBounds = map.getBounds();
        let shouldSetBounds = true;
        if (currentBounds && currentBounds[0] && currentBounds[1]) {
             const margin = 0.0001;
             if (combinedBounds[0][0] >= currentBounds[0][0] - margin &&
                 combinedBounds[0][1] >= currentBounds[0][1] - margin &&
                 combinedBounds[1][0] <= currentBounds[1][0] + margin &&
                 combinedBounds[1][1] <= currentBounds[1][1] + margin) {
                    shouldSetBounds = false;
             }
        }

        if (shouldSetBounds) {
            const latMargin = (combinedBounds[1][0] - combinedBounds[0][0]) * 0.15 || 0.0005;
            const lonMargin = (combinedBounds[1][1] - combinedBounds[0][1]) * 0.15 || 0.0005;
            const viewBounds = [[combinedBounds[0][0] - latMargin, combinedBounds[0][1] - lonMargin], [combinedBounds[1][0] + latMargin, combinedBounds[1][1] + lonMargin]];
            try { map.setBounds(viewBounds, { checkZoomRange: true, duration: 300 }); }
            catch (setBoundsError) { console.error("Ошибка установки границ:", setBoundsError, viewBounds); }
        }
    } else if (newlyDrawnObjects.length === 1 && newlyDrawnObjects[0] instanceof ymaps.Placemark) {
         map.setCenter(newlyDrawnObjects[0].geometry.getCoordinates(), map.getZoom() > 16 ? map.getZoom() : 17);
    }

    return newlyDrawnObjects;
}

// Add this function to populate the sidebar with all currently loaded parcel features
function populateSidebarWithParcels(features, loadDate = null) {
     const sidebar = document.getElementById('parcel-results-sidebar');
     const contentDiv = document.getElementById('parcel-list-content');
     const statsDiv = document.getElementById('sidebar-stats');
     const sidebarTitle = document.getElementById('sidebar-title');
     const toggleBtn = document.getElementById('toggle-sidebar-btn');
     const filterInput = document.getElementById('filter-cadnum-input');
     const copyFilteredBtn = document.getElementById('copy-filtered-btn');

     if (!sidebar || !contentDiv || !sidebarTitle || !toggleBtn || !filterInput || !copyFilteredBtn || !statsDiv) {
         console.error("Sidebar elements not found!");
         return;
     }

     contentDiv.querySelectorAll('.sidebar-item').forEach(item => item.remove());
     statsDiv.innerHTML = '';
     if(filterInput) filterInput.value = '';

     const totalParcels = features.length;
     if(sidebar) sidebar.dataset.totalCount = totalParcels;

     if (loadDate) {
         if(sidebar) sidebar.dataset.titlePrefix = 'Архив: ' +loadDate;
     } else {
         if(sidebar) sidebar.dataset.titlePrefix = 'ЗУ в квартале';
     }

     if(sidebarTitle && sidebar.dataset.titlePrefix) {
        sidebarTitle.textContent = `${sidebar.dataset.titlePrefix} (${totalParcels}/${sidebar.dataset.totalCount})`;
     }
     
     let noResultsMsg = contentDiv.querySelector('.no-results-message');
     if (!noResultsMsg) {
         noResultsMsg = document.createElement('div');
         noResultsMsg.className = 'no-results-message';
         noResultsMsg.style.display = 'none';
         noResultsMsg.style.padding = '20px';
         noResultsMsg.style.textAlign = 'center';
         noResultsMsg.style.color = '#6b7280';
         contentDiv.prepend(noResultsMsg);
     }


     if (features.length > 0) {
         if (noResultsMsg) noResultsMsg.style.display = 'none';

         let declaredCount = 0;
         let specifiedCount = 0;

         features.forEach((feature, index) => {
            const properties = feature.properties || {};
            const options = properties.options || {};
            const cadNumber = properties.descr || 'Не указан';
            const address = options.readable_address || 'Адрес не указан';
            const areaText = getAreaText(options);

             // --- Логика подсчета статистики ---
             const isVerified = options.specified_area || options.land_record_area_verified;
             const hasDeclaredField = options.declared_area || options.land_record_area_declaration || options.land_record_area;
             const isDeclared = !isVerified && hasDeclaredField;

             if (isDeclared) {
                 declaredCount++;
             } else {
                 specifiedCount++;
             }
             // --- Конец логики подсчета ---

             const itemDiv = document.createElement('div');
             itemDiv.className = 'sidebar-item';
             itemDiv.dataset.cadnum = cadNumber.toLowerCase();
             itemDiv.innerHTML = `
                 <p>${index + 1}. ${cadNumber}</p>
                 <p>${address}</p>
                 <p>${areaText}</p>
             `;

             const correspondingPolygon = polygons.find(p =>
                 p instanceof ymaps.Polygon &&
                 p.properties?.get('cadastralNumber') === cadNumber &&
                 (p.properties?.get('isParcelInQuarter') === true || p.properties?.get('isFoundInArea') === true)
             );

             if (correspondingPolygon) {
                 itemDiv.addEventListener('dblclick', () => {
                      if (map) {
                         try {
                             const bounds = correspondingPolygon.geometry.getBounds();
                             if (bounds && bounds[0] && bounds[1]) {
                                 const latPadding = (bounds[1][0] - bounds[0][0]) * 0.15 || 0.0005;
                                 const lonPadding = (bounds[1][1] - bounds[0][1]) * 0.15 || 0.0005;
                                 const paddedBounds = [
                                      [bounds[0][0] - latPadding, bounds[0][1] - lonPadding],
                                      [bounds[1][0] + latPadding, bounds[1][1] + lonPadding]
                                 ];
                                 map.setBounds(paddedBounds, { checkZoomRange: true, duration: 500 });

                                  const originalFill = correspondingPolygon.options.get('fillColor') || '#00000000';
                                   const originalStroke = correspondingPolygon.options.get('strokeColor');
                                   const originalStrokeWidth = correspondingPolygon.options.get('strokeWidth');
                                   const originalStrokeOpacity = correspondingPolygon.options.get('strokeOpacity');

                                  correspondingPolygon.options.set({
                                      fillColor: '#FFFF0080',
                                      strokeColor: '#FFA500',
                                      strokeWidth: (correspondingPolygon.options.get('strokeWidth') || 2) + 2
                                  });
                                  setTimeout(() => {
                                      correspondingPolygon.options.set({
                                           fillColor: originalFill,
                                           strokeColor: originalStroke,
                                           strokeWidth: originalStrokeWidth,
                                           strokeOpacity: originalStrokeOpacity
                                      });
                                  }, 1500);

                             } else {
                                  console.warn("Не удалось получить границы для полигона:", correspondingPolygon);
                                  const coords = correspondingPolygon.geometry.getCoordinates()?.[0]?.[0];
                                  if (coords) map.setCenter(coords, 18, { duration: 500 });
                             }
                         } catch (e) {
                             console.error("Ошибка при позиционировании карты:", e);
                             const coords = correspondingPolygon.geometry.getCoordinates()?.[0]?.[0];
                             if (coords) map.setCenter(coords, 18, { duration: 500 });
                         }
                     }
                 });
             }
             contentDiv.appendChild(itemDiv);
         });

         // --- Отображение статистики ---
         const declaredPercent = totalParcels > 0 ? ((declaredCount / totalParcels) * 100).toFixed(0) : 0;
         const specifiedPercent = totalParcels > 0 ? ((specifiedCount / totalParcels) * 100).toFixed(0) : 0;
         
         statsDiv.innerHTML = `
             Декларированных ЗУ: <b>${declaredCount}</b> (${declaredPercent}%)<br>
             Уточненных ЗУ: <b>${specifiedCount}</b> (${specifiedPercent}%)
         `;
         statsDiv.style.display = 'block';
         // --- Конец отображения ---

         const footer = sidebar.querySelector('.sidebar-footer');
         if(footer) footer.style.display = 'flex';

     } else {
         if (noResultsMsg) {
            noResultsMsg.style.display = 'block';
            noResultsMsg.textContent = 'Нет загруженных участков в квартале.';
         }
         statsDiv.style.display = 'none'; // Скрываем статистику, если нет данных
         const footer = sidebar.querySelector('.sidebar-footer');
         if(footer) footer.style.display = 'none';
     }

     if(sidebar) sidebar.classList.remove('hidden', 'collapsed');
     if(toggleBtn) toggleBtn.innerHTML = '<i class="fas fa-chevron-right"></i>';
     isSidebarCollapsed = false;


     if(filterInput) filterInput.removeEventListener('input', filterParcelList);
     if(filterInput) filterInput.addEventListener('input', filterParcelList);

     if(copyFilteredBtn) copyFilteredBtn.removeEventListener('click', copyFilteredCadnums);
     if(copyFilteredBtn) copyFilteredBtn.addEventListener('click', copyFilteredCadnums);
}


       function getAreaInfo(options) {
            if (!options) return { value: null, type: 'Не указан' };

            // 1. Уточненная площадь (высший приоритет)
            if (options.specified_area) {
                return { value: parseFloat(options.specified_area), type: 'Уточненная' };
            }
            if (options.land_record_area_verified) {
                return { value: parseFloat(options.land_record_area_verified), type: 'Уточненная' };
            }

            // 2. Декларированная площадь (низший приоритет)
            if (options.declared_area) {
                return { value: parseFloat(options.declared_area), type: 'Декларированная' };
            }
            if (options.land_record_area_declaration) {
                return { value: parseFloat(options.land_record_area_declaration), type: 'Декларированная' };
            }
            if (options.land_record_area) {
                return { value: parseFloat(options.land_record_area), type: 'Декларированная' };
            }

            // 3. Площадь не найдена
            return { value: null, type: 'Не указан' };
        }



async function copyAllObjectsToEPSG3857() {
    if (!map) {
        showNotification('Карта не инициализирована', 'error');
        return;
    }

    const allCoordsBlocks = [];
    // Собираем уникальные объекты из обоих массивов (polygons и areaObjects)
    const allDrawableObjects = new Set([...polygons, ...areaObjects]);

    allDrawableObjects.forEach(obj => {
        // Проверяем, является ли объект полигоном или полилинией
        if (obj instanceof ymaps.Polygon || obj instanceof ymaps.Polyline) {
            let yandexCoords;

            // Получаем координаты в зависимости от типа объекта
            if (obj instanceof ymaps.Polygon) {
                // Для полигона берем внешний контур
                yandexCoords = obj.geometry.getCoordinates()[0];
            } else { // Polyline
                yandexCoords = obj.geometry.getCoordinates();
            }
            
            if (!yandexCoords || yandexCoords.length === 0) {
                return; // Пропускаем пустые объекты
            }

            // Конвертируем координаты и форматируем их
            const epsg3857Coords = yandexCoords.map(coord => {
                // 1. Возвращаем координату к "истинному" WGS84, убирая смещение карты
                const trueLat = coord[0] + (mapOffsetY * 0.000008983);
                const trueLon = coord[1] + (mapOffsetX * 0.000008983);
                
                // 2. Конвертируем WGS84 в EPSG:3857
                // proj4 ожидает на вход [долгота, широта] и возвращает [X, Y]
                const point3857 = proj4("EPSG:4326", "EPSG:3857", [trueLon, trueLat]);
                
                // --- ИЗМЕНЕНИЕ ЗДЕСЬ: Меняем местами X и Y для формата "Y [tab] X" ---
                // 3. Форматируем результат в "Y    X" с 4 знаками после запятой
                return `${point3857[1].toFixed(4)}\t${point3857[0].toFixed(4)}`;
            }).join('\n');
            
            allCoordsBlocks.push(epsg3857Coords);
        }
    });

    if (allCoordsBlocks.length === 0) {
        showNotification('На карте нет площадных или линейных объектов для копирования', 'warning', 'exclamation-triangle');
        return;
    }

    // Объединяем блоки координат пустой строкой
    const finalString = allCoordsBlocks.join('\n\n');

    try {
        await navigator.clipboard.writeText(finalString);
        showNotification(`Скопированы координаты ${allCoordsBlocks.length} объектов в EPSG:3857 (Y X)`, 'success', 'check-circle');
    } catch (err) {
        console.error('Ошибка копирования в буфер обмена:', err);
        showNotification('Не удалось скопировать координаты', 'error', 'exclamation-circle');
    }
}


      function getAreaText(options) {
            const areaInfo = getAreaInfo(options);
            if (areaInfo.value === null || isNaN(areaInfo.value)) {
                return 'не указана';
            }
            // Форматируем число с разделителями тысяч
            const formattedValue = areaInfo.value.toLocaleString('ru-RU');
            return `${formattedValue} м² (${areaInfo.type.toLowerCase()})`;
        }
        
        function findPolygonAtPoint(lat, lon) {
    const candidatePolygons = [];
    const allDrawableObjects = [...polygons, ...areaObjects]; // Ищем во всех полигонах

    for (const obj of allDrawableObjects) {
        if (obj instanceof ymaps.Polygon) {
            try {
                // Используем Turf.js для надежной проверки вхождения точки
                const coords = obj.geometry.getCoordinates()[0];
                const turfPolygon = turf.polygon([coords.map(coord => [coord[1], coord[0]])]);
                const point = turf.point([lon, lat]);
                if (turf.booleanPointInPolygon(point, turfPolygon)) {
                    candidatePolygons.push(obj);
                }
            } catch (turfError) {
                // Fallback на метод Яндекса, если Turf.js выдал ошибку
                if (obj.geometry.contains([lat, lon])) {
                    candidatePolygons.push(obj);
                }
            }
        }
    }

    if (candidatePolygons.length === 0) {
        return null;
    }

    // Если найдено несколько полигонов, выбираем тот, у которого наименьшая площадь
    let targetPolygon = candidatePolygons[0];
    if (candidatePolygons.length > 1) {
        let minArea = Infinity;
        candidatePolygons.forEach(polygon => {
            try {
                const coords = polygon.geometry.getCoordinates()[0];
                if (coords.length < 3) return;
                const turfPolygon = turf.polygon([coords.map(coord => [coord[1], coord[0]])]);
                const area = turf.area(turfPolygon);
                if (isFinite(area) && area < minArea) {
                    minArea = area;
                    targetPolygon = polygon;
                }
            } catch (e) {
                console.error("Ошибка при расчете площади для выбора полигона:", e);
            }
        });
    }
    
    return targetPolygon;
}


function convertWgs84ToMskWithOffset(wgs84Coords, destSc, destSystemDef, offsetX, offsetY) {
    proj4.defs(destSc, destSystemDef);
    
    return wgs84Coords.map(coord => {
        // coord должен быть в формате [lon, lat] для Proj4
        const mskPoint = proj4("EPSG:4326", destSc, coord); // Proj4 для МСК возвращает [Y, X]
        
        const y_from_proj = mskPoint[0];
        const x_from_proj = mskPoint[1];
        
        // Применяем загруженные смещения
        const final_Y_for_output = y_from_proj + offsetY;
        const final_X_for_output = x_from_proj + offsetX;

        // Форматируем результат как "X [tab] Y"
        return `${final_X_for_output.toFixed(2)}\t${final_Y_for_output.toFixed(2)}`;
    }).join('\n');
}



async function convertAndCopyMskCoords(targetPolygon) {
    try {
        console.log(`--- [convertAndCopyMskCoords] Начало конвертации объекта ---`);

        // 1. Получаем систему координат (с запасным вариантом)
        const destSc = localStorage.getItem('savedDefaultMskSystem') || 'EPSG:6331602';
        const destSystem = COORDINATE_SYSTEMS.find(s => s.value === destSc);
        if (!destSystem || !destSystem.def) {
            throw new Error(`Определение для ${destSc} не найдено в sk.js`);
        }
        
        // --- НАЧАЛО ИЗМЕНЕНИЙ: Полностью новая логика определения смещения ---
        let offsetX = 0;
        let offsetY = 0;
        
        // Проверяем настройку автозагрузки. Если ее нет в localStorage (инкогнито), считаем, что она включена.
        const isAutoLoadEnabled = (localStorage.getItem('autoLoadMskOffset') !== 'false');
        console.log(`[convertAndCopyMskCoords] Автозагрузка смещения: ${isAutoLoadEnabled}`);

        if (isAutoLoadEnabled) {
            // Если автозагрузка включена, берем смещения из объекта системы координат (sk.js)
            offsetX = destSystem.offsetX || 0;
            offsetY = destSystem.offsetY || 0;
            console.log(`[convertAndCopyMskCoords] Смещения загружены из sk.js для ${destSc}: X=${offsetX}, Y=${offsetY}`);
        } else {
            // Если выключена, берем из localStorage
            const offsetXRaw = localStorage.getItem('savedMskOffsetX') || '0';
            const offsetYRaw = localStorage.getItem('savedMskOffsetY') || '0';
            offsetX = parseFloat(offsetXRaw.replace(',', '.')) || 0;
            offsetY = parseFloat(offsetYRaw.replace(',', '.')) || 0;
            console.log(`[convertAndCopyMskCoords] Используются сохраненные вручную смещения: X=${offsetX}, Y=${offsetY}`);
        }
        // --- КОНЕЦ ИЗМЕНЕНИЙ ---

        // 2. Получаем ВСЕ контуры (внешний и внутренние)
        const yandexCoordRings = targetPolygon.geometry.getCoordinates();
        const allMskBlocks = [];

        // 3. Проходим по каждому контуру (кольцу) полигона
        for (const ring of yandexCoordRings) {
            const reversedYandexCoords = [...ring].reverse();
            const wgs84Coords = reversedYandexCoords.map(coord => {
                const trueLat = coord[0] + (mapOffsetY * 0.000008983);
                const trueLon = coord[1] + (mapOffsetX * 0.000008983);
                return [trueLon, trueLat];
            });
            const mskCoordsText = convertWgs84ToMskWithOffset(wgs84Coords, destSc, destSystem.def, offsetX, offsetY);
            allMskBlocks.push(mskCoordsText);
        }

        const finalMskText = allMskBlocks.join('\n\n');
        await navigator.clipboard.writeText(finalMskText);
        
        let notificationMessage = `Координаты в ${destSystem.text} скопированы`;
        if (offsetX !== 0 || offsetY !== 0) {
            notificationMessage += ` (со смещением X: ${offsetX.toFixed(2)}, Y: ${offsetY.toFixed(2)})`;
        }
        showNotification(notificationMessage, 'success', 'check-circle');
        window.open('схема.html', '_blank');

    } catch (error) {
        console.error("Ошибка при конвертации в МСК:", error);
        showNotification(`Ошибка конвертации: ${error.message}`, 'error', 'exclamation-circle');
    }
}



async function handleEgrnRelatedAction(lat, lon, targetUrl) {
    try {
        const cadastralData = await queryCadastralInfo(lat, lon);

        if (!cadastralData || !cadastralData.features || !cadastralData.features.length === 0) {
            showNotification('Кадастровый номер не найден', 'error', 'exclamation-circle');
            return; // No further action if CN not found
        }

        const feature = cadastralData.features[0];
        const cadastralNumber = feature.properties.descr;

        if (feature.geometry && feature.geometry.coordinates) {
            // The drawing logic is optional here if you only want to copy and open
            // If you want to draw the polygon as well, uncomment and adapt this part:
           
            const coordinates = feature.geometry.coordinates[0].map(coord => {
                const point = proj4('EPSG:3857', 'EPSG:4326', coord);
                return [point[1], point[0]];
            });
            const offsetCoordinates = coordinates.map(coord => [
                coord[0] - mapOffsetY * 0.000008983,
                coord[1] - mapOffsetX * 0.000008983
            ]);
            const polygon = new ymaps.Polygon([offsetCoordinates], {}, {
                strokeColor: polygonStyle.color,
                strokeWidth: polygonStyle.width,
                strokeOpacity: 0.8,
                fillColor: '#00000000',
                hintEnabled: false, hasBalloon: false, interactivityModel: 'default#transparent'
            });
            map.geoObjects.add(polygon);
            polygons.push(polygon);
            const bounds = polygon.geometry.getBounds();
            const centerGeo = [(bounds[0][0] + bounds[1][0]) / 2, (bounds[0][1] + bounds[1][1]) / 2];
            getAddressByCoords(centerGeo).then(address => {
                document.getElementById('city-name-display').innerHTML = address;
            });
            const center3857 = proj4("EPSG:4326", "EPSG:3857", [centerGeo[1], centerGeo[0]]);
            lastPolygonCenter = {
                geo: { lat: centerGeo[0], lon: centerGeo[1] },
                epsg3857: { x: center3857[0], y: center3857[1] },
                native: { x: feature.geometry.coordinates[0][0][0], y: feature.geometry.coordinates[0][0][1] }
            };
            const cadastralText = new ymaps.Placemark([
                centerGeo[0] - mapOffsetY * 0.000008983,
                centerGeo[1] - mapOffsetX * 0.000008983
            ], { iconContent: cadastralNumber }, { preset: 'islands#blueStretchyIcon', draggable: true });
            map.geoObjects.add(cadastralText);
            polygons.push(cadastralText);
           

            await navigator.clipboard.writeText(cadastralNumber);
            window.open(targetUrl, '_blank');
        }
    } catch (error) {
        showNotification('Ошибка подключения или обработки данных, попробуйте позже', 'error', 'exclamation-circle');
        console.error("Error in handleEgrnRelatedAction:", error);
    }
}


// Modify clearMapAndResetTheme to clear specific object types
function clearMapAndResetTheme() {
    if (!map) return;
    map.geoObjects.removeAll();
    polygons = [];
    parcelPlacemarks = [];
    areaObjects = [];
    allAreaMeasurements = [];
    draggableTexts.forEach(textEl => {
        if (textEl.parentNode) {
            textEl.parentNode.removeChild(textEl);
        }
    });
    draggableTexts = [];
    vriFilterPlacemarks.clear();
    ownershipFilterPlacemarks.clear();
    registrationDateFilterPlacemarks.clear();
    uluFilterPlacemarks.clear();

    parcelFeaturesData = [];
    buildingFeaturesData = [];
       structureFeaturesData = [];
       zouitFeaturesData = [];
       
    selectedVriFromLegend = null;
    selectedOwnershipFromLegend = null;
    selectedRegistrationDateFromLegend = null;
    selectedUluFromLegend = null;
    currentTheme = 'none';

    hideLegends();
    updateLegendSelectionVisuals();

    selectedPlacemark = null;
    selectedLine = null;
    distanceLabel = null;
    areaLabel = null;
    distancePoints = [];
    totalDistance = 0;
    segments = [];
    areaPoints = [];
    areaPolygon = null;
    distanceMeasurementActive = false;
    areaMeasurementActive = false;
    lineDrawingActive = false;
    linePoints = [];
    currentLine = null;
    activeDraggableText = null;
    mapElement.classList.remove('measuring-distance', 'measuring-area', 'drawing-line');

    coordsInput.value = '';
    convertedTextarea.value = '';
    geoTextarea.value = '';
    cityInput.value = '';
    document.getElementById('city-name-display').innerHTML = '';

    zuToEzMapGlobal.clear();
    resetSidebarUluInfo();
    populateSidebarWithParcels([]);
    currentQuarterNumber = null;

    showNotification("Карта очищена", "success");
}



function hexToRgb(hex) {
    const r = parseInt(hex.slice(1, 3), 16);
    const g = parseInt(hex.slice(3, 5), 16);
    const b = parseInt(hex.slice(5, 7), 16);
    return `rgb(${r}, ${g}, ${b})`;
}


function readFromClipboard() {
    return navigator.clipboard.readText().then(text => {
        if (text) {
            const trimmedText = text.trim();

            if (!trimmedText) return;

            const letterMatch = trimmedText.match(/[a-zA-Zа-яА-Я]/g);
            const letterCount = letterMatch ? letterMatch.length : 0;

            const hasLatinLetters = /[a-zA-Z]/.test(trimmedText);

            const skipAutoCityInputPaste = (hasLatinLetters || letterCount > 50);

       //     console.log(`Clipboard text: "${trimmedText}"`);
         //   console.log(`Letters: ${letterCount}, Has Latin: ${hasLatinLetters}, Skip CityInput Auto: ${skipAutoCityInputPaste}`);


            if (isCoordinates(trimmedText)) {
                coordsInput.value = trimmedText;
                cityInput.value = '';
           //     console.log("Text looks like multi-line coordinates. Pasting to coordsInput and processing.");
                findAndConvert();
                return;
            }

            if (isValidCadastralNumber(trimmedText)) {
                if (skipAutoCityInputPaste) {
                  //  console.log("Text looks like cadastral number, but skipped auto-paste/process due to Latin letters or excessive letter count.");
                    cityInput.value = trimmedText;
                    coordsInput.value = '';
                } else {
                    const formattedText = formatPotentialCadastralNumber(trimmedText);
                    cityInput.value = formattedText;
                    coordsInput.value = '';
                  //  console.log("Text looks like cadastral number. Pasting to cityInput and processing.");
                    const enterEvent = new KeyboardEvent('keydown', { key: 'Enter', code: 'Enter', which: 13, keyCode: 13, bubbles: true });
                    cityInput.dispatchEvent(enterEvent);
                }
                return;
            }

            const coordRegex = /^(-?\d+\.?\d*)\s*[,\s]\s*(-?\d+\.?\d*)$/;
            const coordMatch = trimmedText.match(coordRegex);
            const spaceSeparated = trimmedText.split(/\s+/);
            const isPotentialTwoNumbers = spaceSeparated.length === 2 && !isNaN(parseFloat(spaceSeparated[0])) && !isNaN(parseFloat(spaceSeparated[1]));
             const looksLikeLatLon = isPotentialTwoNumbers && Math.abs(parseFloat(spaceSeparated[0])) <= 90 && Math.abs(parseFloat(spaceSeparated[1])) <= 180;
             const looksLikeLonLat = isPotentialTwoNumbers && Math.abs(parseFloat(spaceSeparated[0])) <= 180 && Math.abs(parseFloat(spaceSeparated[1])) <= 90;


            if (coordMatch || looksLikeLatLon || looksLikeLonLat) {
                 if (skipAutoCityInputPaste) {
                   //  console.log("Text looks like a coordinate pair, but skipped auto-paste/process due to Latin letters or excessive letter count.");
                     cityInput.value = trimmedText;
                     coordsInput.value = '';
                 } else {
                     cityInput.value = trimmedText;
                     coordsInput.value = '';
                  //   console.log("Text looks like a coordinate pair. Pasting to cityInput and processing.");
                     const enterEvent = new KeyboardEvent('keydown', { key: 'Enter', code: 'Enter', which: 13, keyCode: 13, bubbles: true });
                     cityInput.dispatchEvent(enterEvent);
                 }
                 return;
            }

            if (!skipAutoCityInputPaste) {
                cityInput.value = trimmedText;
                coordsInput.value = '';
              //  console.log("Text looks like general text/address. Pasting to cityInput and processing.");
                const enterEvent = new KeyboardEvent('keydown', { key: 'Enter', code: 'Enter', which: 13, keyCode: 13, bubbles: true });
                cityInput.dispatchEvent(enterEvent);
            } else {
              //   console.log("Clipboard text skipped completely due to Latin letters or excessive letter count (general text). Not pasting automatically.");
            }

        }
    }).catch(error => {
      //  console.log('Ошибка чтения буфера обмена', error);
    });
}


async function queryOKSInfo(latitude, longitude) {
    const centerPoint = toEPSG3857(latitude, longitude);
    const centerX = centerPoint.x;
    const centerY = centerPoint.y;
    const polygonSizeMeters = 0.15;
    const halfSize = polygonSizeMeters / 2;
    const minX = centerX - halfSize;
    const minY = centerY - halfSize;
    const maxX = centerX + halfSize;
    const maxY = centerY + halfSize;
    const width = 512;
    const height = 512;
    const i = width / 2;
    const j = height / 2;
    const bbox = `${minX},${minY},${maxX},${maxY}`;
    const url = `https://nspd.gov.ru/api/aeggis/v4/36049/wms?REQUEST=GetFeatureInfo&QUERY_LAYERS=36049&SERVICE=WMS&VERSION=1.3.0&FORMAT=image%2Fpng%2F&STYLES=&TRANSPARENT=true&LAYERS=36049&RANDOM=${Math.random()}&INFO_FORMAT=application%2Fjson&FEATURE_COUNT=10&I=${i}&J=${j}&WIDTH=${width}&HEIGHT=${height}&CRS=EPSG%3A3857&BBOX=${bbox}`;

    try {
        const response = await fetchNspd(url);
        const data = await response.json();
        return data;
    } catch (error) {
        console.error('Error fetching OKS data:', error);
        return null;
    }
}

        function formatPotentialCadastralNumber(value) {

            let cleanedValue = value.replace(/\D/g, ''); // Remove all non-digit characters
            const firstTwoDigits = cleanedValue.slice(0, 2);
            const isSevenDigitsRegion = sevenDigitsRegions.includes(firstTwoDigits);
            const thirdBlockLength = isSevenDigitsRegion ? 7 : 6;


                let formatted = '';
                if (cleanedValue.length > 0) formatted += cleanedValue.slice(0, 2); // First 2 digits
                if (cleanedValue.length > 2) formatted += ':' + cleanedValue.slice(2, 4); // Next 2 digits
                if (cleanedValue.length > 4) {
                    const remainingDigits = cleanedValue.slice(4);
                    if (remainingDigits.length <= thirdBlockLength) {
                        formatted += ':' + remainingDigits; // Next 6 or 7 digits
                    } else {
                        formatted += ':' + remainingDigits.slice(0, thirdBlockLength) + ':' + remainingDigits.slice(thirdBlockLength); // Next 6 or 7 digits and remaining
                    }
                }
                return formatted;


            return value; // If it doesn't start with a known prefix, return the original. (This line might be redundant now, but kept for safety)

        }


   
        window.addEventListener('resize', function () {
            isMobile = window.innerWidth <= 768;
        });

        let isDragging = false;
        let dragStartX = 0;
        let dragStartY = 0;
        let initialX = 10;
        let initialY = 10;

    widget.addEventListener('mousedown', function (e) {
    isDragging = true;
    dragStartX = e.clientX - widget.offsetLeft;
    dragStartY = e.clientY - widget.offsetTop;
    widget.style.cursor = 'grabbing'; // Курсор "хватания" при нажатии
    initialX = widget.offsetLeft;
    initialY = widget.offsetTop;
});

document.addEventListener('mousemove', function (e) {
    if (!isDragging) return;
    const x = e.clientX - dragStartX;
    const y = e.clientY - dragStartY;
    widget.style.left = x + 'px';
    widget.style.top = y + 'px';
});

document.addEventListener('mouseup', function () {
    isDragging = false;
    widget.style.cursor = 'grab'; // Курсор "рука" после отпускания, готов к перемещению
});

document.addEventListener('mouseleave', function () {
    if (isDragging) {
        isDragging = false;
        widget.style.cursor = 'grab'; // Курсор "рука" при уходе мыши с виджета
    }
});

            function preventWidgetInteraction(event) {
                event.stopPropagation();
            }

            ['input', 'textarea', 'button', 'a'].forEach(elType => {
                const elements = widget.querySelectorAll(elType);
                elements.forEach(el => {
                    el.addEventListener('mousedown', preventWidgetInteraction);
                    el.addEventListener('click', preventWidgetInteraction);
                    el.addEventListener('mouseup', preventWidgetInteraction);
                });
            });

         
         
         function handleVriLegendClick(event) {
    const listItem = event.target.closest('li'); // Find the clicked list item
    if (!listItem) return; // Exit if click wasn't on an item

    // Extract the VRI text from the second span (assuming first is color box)
    const vriSpans = listItem.querySelectorAll('span');
    if (vriSpans.length < 2) return; // Malformed item
    const clickedVri = vriSpans[1].textContent.trim();

    // Toggle selection state
    if (selectedVriFromLegend === clickedVri) {
        // If clicking the already selected item, reset the filter
        selectedVriFromLegend = null;
    } else {
        // Otherwise, select the clicked VRI
        selectedVriFromLegend = clickedVri;
    }

    updateLegendSelectionVisuals(); // Update visual highlight in the legend
    applyVriFilter(); // Apply the filtering logic to map polygons
}


function updateLegendSelectionVisuals() {
    const vriListItems = document.querySelectorAll('#vri-legend-list li');
    vriListItems.forEach(li => {
        const vriSpans = li.querySelectorAll('span');
        if (vriSpans.length < 2) return;
        const itemVri = vriSpans[1].textContent.trim();
        li.classList.toggle('legend-item-selected', itemVri === selectedVriFromLegend);
    });

    const ownershipListItems = document.querySelectorAll('#ownership-legend-list li');
    ownershipListItems.forEach(li => {
        const itemKey = li.dataset.ownershipKey;
        li.classList.toggle('legend-item-selected', itemKey === selectedOwnershipFromLegend);
    });

    const regDateListItems = document.querySelectorAll('#registration-date-legend-list li');
    regDateListItems.forEach(li => {
        const itemValue = li.dataset.filterValue;
        if (itemValue === '') { // "Показать все"
            li.classList.toggle('legend-item-selected', selectedRegistrationDateFromLegend === null);
        } else {
            li.classList.toggle('legend-item-selected', itemValue === selectedRegistrationDateFromLegend);
        }
    });

    const uluListItems = document.querySelectorAll('#ulu-legend-list li');
    uluListItems.forEach(li => {
        const itemKey = li.dataset.uluKey;
        if (itemKey === '') { // "Показать все"
             li.classList.toggle('legend-item-selected', selectedUluFromLegend === null);
        } else {
            li.classList.toggle('legend-item-selected', itemKey === selectedUluFromLegend);
        }
    });
}

function applyVriFilter() {
    if (currentTheme !== 'use') {
        // Clear any existing filter placemarks if theme is not 'use'
        if (vriFilterPlacemarks.size > 0) {
            vriFilterPlacemarks.forEach(placemark => {
                if (map?.geoObjects.indexOf(placemark) !== -1) {
                    map.geoObjects.remove(placemark);
                }
            });
            vriFilterPlacemarks.clear();
        }
        // Reset selection state if necessary
        if (selectedVriFromLegend !== null) {
            selectedVriFromLegend = null;
            updateLegendSelectionVisuals();
        }
        return;
    }

   // console.log(`Applying VRI filter. Selected: ${selectedVriFromLegend === null ? 'None (Show All)' : selectedVriFromLegend}`);
    const placemarkPreset = 'islands#blueIcon'; // Standard blue placemark preset
    const placemarkZIndex = 600; // Z-index for temporary placemarks

    // Keep track of CNs that *should* have a placemark in this run
    const cnsToShowPlacemark = new Set();

    polygons.forEach(obj => {
        if (obj instanceof ymaps.Polygon && (obj.properties?.get('isParcelInQuarter') || obj.properties?.get('isFoundInArea'))) {
            const parcelVri = obj.properties.get('vri');
            const cadastralNumber = obj.properties.get('cadastralNumber');
            let fillColor = '#00000000'; // Default transparent fill

            if (!cadastralNumber) return; // Skip if no CN

            const shouldMatch = selectedVriFromLegend !== null && parcelVri === selectedVriFromLegend;
            const showAll = selectedVriFromLegend === null;

            // --- Fill Color Logic ---
            if (showAll) {
                if (parcelVri && vriColorMap.has(parcelVri)) {
                    fillColor = `${vriColorMap.get(parcelVri)}E6`;
                }
            } else if (shouldMatch) {
                if (parcelVri && vriColorMap.has(parcelVri)) {
                    fillColor = `${vriColorMap.get(parcelVri)}E6`;
                }
            } // Else: fillColor remains transparent

            obj.options.set('fillColor', fillColor);

            // --- Temporary Placemark Logic ---
            const existingPlacemark = vriFilterPlacemarks.get(cadastralNumber);

            if (shouldMatch) {
                cnsToShowPlacemark.add(cadastralNumber); // Mark this CN for placemark display
                if (!existingPlacemark) {
                    // Create and add placemark if it doesn't exist
                    const bounds = obj.geometry.getBounds();
                    if (bounds?.[0]?.[0] !== undefined && isFinite(bounds[0][0])) {
                        const centerGeo = [
                            (bounds[0][0] + bounds[1][0]) / 2,
                            (bounds[0][1] + bounds[1][1]) / 2
                        ];
                        const tempPlacemark = new ymaps.Placemark(centerGeo, {
                            // iconContent: cadastralNumber, // Optional: display CN on placemark
                            hintContent: cadastralNumber // Show CN on hover
                        }, {
                            preset: placemarkPreset,
                            zIndex: placemarkZIndex
                        });
                        map.geoObjects.add(tempPlacemark);
                        vriFilterPlacemarks.set(cadastralNumber, tempPlacemark);
                        // console.log(`Added filter placemark for ${cadastralNumber}`);
                    }
                }
            }
            // Note: We remove placemarks *after* the loop now
        }
    }); // End polygons loop

    // --- Remove Placemarks that are no longer needed ---
    vriFilterPlacemarks.forEach((placemark, cn) => {
        if (!cnsToShowPlacemark.has(cn)) {
            // This placemark should be hidden
            if (map?.geoObjects.indexOf(placemark) !== -1) {
                map.geoObjects.remove(placemark);
            }
            vriFilterPlacemarks.delete(cn); // Remove from tracking map
            // console.log(`Removed filter placemark for ${cn}`);
        }
    });
}



let draggableTexts = [];
let activeDraggableText = null;

let isRotating = false; // Флаг, указывающий, что идет процесс вращения
let rotatingElement = null; // Ссылка на вращаемый элемент

// ЗАМЕНИТЕ ВСЮ ФУНКЦИЮ ЦЕЛИКОМ
function createDraggableText(text, position) {
    const draggableText = document.createElement('div');
    draggableText.className = 'draggable-text';
    draggableText.dataset.rotation = '0';

    const innerContainer = document.createElement('div');
    innerContainer.style.position = 'relative';

    const span = document.createElement('span');
    span.textContent = text;
    span.dataset.backgroundVisible = 'true';
    span.style.fontSize = '16px';
    span.style.fontWeight = 'bold';
    span.style.color = '#333';
    span.style.padding = '5px 10px';
    span.style.borderRadius = '5px';
    span.style.background = 'rgba(255, 255, 255, 0.9)';
    span.style.whiteSpace = 'nowrap';
    span.style.display = 'inline-block';
    span.style.boxShadow = '0 2px 6px rgba(0, 0, 0, 0.2)';
    span.style.border = '1px solid #ccc'; // <-- ПЕРЕНЕСЛИ РАМКУ СЮДА
    span.style.transition = 'box-shadow 0.2s ease';
    innerContainer.appendChild(span);

    const rotateHandle = document.createElement('div');
    rotateHandle.className = 'rotation-handle';
    Object.assign(rotateHandle.style, {
        display: 'none', position: 'absolute', top: '-25px', left: '50%', transform: 'translateX(-50%)',
        width: '14px', height: '14px', backgroundColor: '#2196F3', border: '2px solid white',
        borderRadius: '50%', cursor: 'alias', boxShadow: '0 1px 4px rgba(0,0,0,0.3)', zIndex: '10'
    });
    rotateHandle.addEventListener('mousedown', (e) => {
        e.stopPropagation();
        isRotating = true;
        rotatingElement = draggableText;
    });
    innerContainer.appendChild(rotateHandle);

    const buttonContainer = document.createElement('div');
    buttonContainer.className = 'button-container';
    Object.assign(buttonContainer.style, {
        display: 'flex', flexDirection: 'column', gap: '4px', position: 'absolute',
        left: '100%', top: '0', marginLeft: '8px', transition: 'opacity 0.3s ease, transform 0.2s ease'
    });

    const increaseButton = createButton('+', '#4CAF50', '#66BB6A');
    const decreaseButton = createButton('-', '#F44336', '#E57373');
    
    const colorPicker = document.createElement('input');
    colorPicker.type = 'color';
    colorPicker.value = '#333333';
    Object.assign(colorPicker.style, {
        width: '24px', height: '24px', border: 'none', borderRadius: '50%', cursor: 'pointer', padding: '0',
        outline: 'none', backgroundColor: 'transparent', boxShadow: '0 2px 4px rgba(0,0,0,0.2)'
    });
    colorPicker.addEventListener('input', function(e) { e.stopPropagation(); span.style.color = this.value; });
    colorPicker.addEventListener('mousedown', (e) => e.stopPropagation());

    const rotateButton = createButton('<i class="fas fa-sync-alt"></i>', '#2196F3', '#1976D2');
    rotateButton.title = 'Повернуть на 30°';
    rotateButton.addEventListener('click', function(e) {
        e.stopPropagation();
        let currentRotation = parseInt(draggableText.dataset.rotation || '0', 10);
        const rotationStep = 30;
        let newRotation = (currentRotation + rotationStep) % 360;
        draggableText.dataset.rotation = newRotation;
        draggableText.style.transform = `rotate(${newRotation}deg)`;
    });

    const toggleBgButton = createButton('<i class="fas fa-eye-slash"></i>', '#607D8B', '#455A64');
    toggleBgButton.title = 'Вкл/Выкл фон';
    toggleBgButton.addEventListener('click', function(e) {
        e.stopPropagation();
        const isVisible = span.dataset.backgroundVisible === 'true';

        if (isVisible) {
            // Если фон видим -> скрываем его, padding, тень и рамку
            span.style.background = 'transparent';
            span.style.boxShadow = 'none';
            span.style.padding = '0px';
            span.style.border = 'none'; // <-- УБИРАЕМ РАМКУ
            span.dataset.backgroundVisible = 'false';
            this.innerHTML = '<i class="fas fa-eye"></i>';
        } else {
            // Если фон скрыт -> показываем всё обратно
            span.style.background = 'rgba(255, 255, 255, 0.9)';
            span.style.boxShadow = '0 2px 6px rgba(0, 0, 0, 0.2)';
            span.style.padding = '5px 10px';
            span.style.border = '1px solid #ccc'; // <-- ВОЗВРАЩАЕМ РАМКУ
            span.dataset.backgroundVisible = 'true';
            this.innerHTML = '<i class="fas fa-eye-slash"></i>';
        }
    });

    buttonContainer.appendChild(increaseButton);
    buttonContainer.appendChild(decreaseButton);
    buttonContainer.appendChild(colorPicker);
    buttonContainer.appendChild(rotateButton);
    buttonContainer.appendChild(toggleBgButton);

    innerContainer.appendChild(buttonContainer);
    draggableText.appendChild(innerContainer);
    document.body.appendChild(draggableText);

    if (position) {
        draggableText.style.left = `${position.x}px`;
        draggableText.style.top = `${position.y}px`;
    } else {
        const mapRect = document.getElementById('map').getBoundingClientRect();
        draggableText.style.left = `${mapRect.left + mapRect.width / 2}px`;
        draggableText.style.top = `${mapRect.top + mapRect.height / 2}px`;
    }

    draggableText.addEventListener('mousedown', function(e) {
        e.stopPropagation();
        setActiveDraggableText(draggableText);
        startDragging(e, draggableText);
    });

    increaseButton.addEventListener('click', function(e) { e.stopPropagation(); changeTextSize(draggableText, 2); });
    decreaseButton.addEventListener('click', function(e) { e.stopPropagation(); changeTextSize(draggableText, -2); });
    
    draggableText.addEventListener('mouseenter', () => {
        buttonContainer.style.opacity = '1';
        buttonContainer.style.transform = 'translateX(0)';
        if (span.dataset.backgroundVisible === 'true') {
            span.style.boxShadow = '0 4px 10px rgba(0,0,0,0.3)';
        }
    });
    draggableText.addEventListener('mouseleave', () => {
        buttonContainer.style.opacity = '0';
        buttonContainer.style.transform = 'translateX(100%)';
        if (span.dataset.backgroundVisible === 'true') {
            span.style.boxShadow = '0 2px 6px rgba(0,0,0,0.2)';
        }

        if (activeDraggableText != draggableText) {
            if (span.dataset.backgroundVisible === 'true') {
                 span.style.backgroundColor = 'rgba(255, 255, 255, 0.9)';
            }
        }
    });

    buttonContainer.style.opacity = '0';
    buttonContainer.style.transform = 'translateX(100%)';
    draggableTexts.push(draggableText);

    // У родительского контейнера УБИРАЕМ ВСЕ СТИЛИ, включая рамку
    Object.assign(draggableText.style, {
        position: 'absolute', zIndex: '1000', padding: '0px', background: 'transparent', boxShadow: 'none', border: 'none', // <-- УБИРАЕМ РАМКУ ЗДЕСЬ
        cursor: 'move', userSelect: 'none', display: 'inline-block', transition: 'transform 0.2s ease'
    });
}

function createButton(text, bgColor, hoverColor) {
    const button = document.createElement('button');
    button.innerHTML = text === '+' ? '<i class="fas fa-plus"></i>' : '<i class="fas fa-minus"></i>';
    button.style.backgroundColor = bgColor;
    button.style.color = 'white';
    button.style.border = 'none';
    button.style.borderRadius = '50%';
    button.style.width = '24px';
    button.style.height = '24px';
    button.style.display = 'flex';
    button.style.alignItems = 'center';
    button.style.justifyContent = 'center';
    button.style.cursor = 'pointer';
    button.style.boxShadow = '0 2px 4px rgba(0,0,0,0.2)';
    button.style.transition = 'transform 0.2s ease, background-color 0.2s ease';
    button.addEventListener('mouseenter', () => button.style.backgroundColor = hoverColor);
    button.addEventListener('mouseleave', () => button.style.backgroundColor = bgColor);
    button.addEventListener('mousedown', () => button.style.transform = 'scale(0.9)');
    button.addEventListener('mouseup', () => button.style.transform = 'scale(1)');
    return button;
}



document.addEventListener('mousemove', (e) => {
    // Если режим вращения не активен или нет элемента для вращения, выходим
    if (!isRotating || !rotatingElement) return;

    // Находим центр элемента, который мы вращаем
    const span = rotatingElement.querySelector('span');
    if (!span) return;
    
    const rect = span.getBoundingClientRect();
    const centerX = rect.left + rect.width / 2;
    const centerY = rect.top + rect.height / 2;

    // Вычисляем угол между центром элемента и текущим положением курсора
    const deltaX = e.clientX - centerX;
    const deltaY = e.clientY - centerY;
    const angleRad = Math.atan2(deltaY, deltaX);
    
    // Конвертируем радианы в градусы и добавляем 90, чтобы 0 градусов был "сверху"
    let angleDeg = (angleRad * 180 / Math.PI) + 90;

    // Применяем трансформацию и сохраняем значение
    rotatingElement.style.transform = `rotate(${angleDeg}deg)`;
    rotatingElement.dataset.rotation = angleDeg;
});

document.addEventListener('mouseup', () => {
    // При отпускании кнопки мыши сбрасываем флаги
    isRotating = false;
    rotatingElement = null;
});

function changeTextSize(draggableText, delta) {
    const span = draggableText.querySelector('span');
    const currentSize = parseInt(window.getComputedStyle(span).fontSize);
    span.style.fontSize = `${currentSize + delta}px`;
}

// ЗАМЕНИТЕ ВАШУ ФУНКЦИЮ setActiveDraggableText НА ЭТУ
function setActiveDraggableText(draggableText) {
    if (activeDraggableText && activeDraggableText !== draggableText) {
        activeDraggableText.classList.remove('active');
        // Скрываем ручку у старого активного элемента
        const oldHandle = activeDraggableText.querySelector('.rotation-handle');
        if (oldHandle) oldHandle.style.display = 'none';

        const span = activeDraggableText.querySelector('span');
        if (span) {
            span.style.backgroundColor = 'rgba(255, 255, 255, 0.9)';
            span.style.width = 'fit-content';
        }

        if (!activeDraggableText.matches(':hover')) {
            const buttonContainer = activeDraggableText.querySelector('.button-container');
            if (buttonContainer) {
                buttonContainer.style.opacity = '0';
                buttonContainer.style.transform = 'translateX(100%)';
            }
        }
    }
    
    activeDraggableText = draggableText;
    draggableText.classList.add('active');

    // Показываем ручку у нового активного элемента
    const newHandle = draggableText.querySelector('.rotation-handle');
    if (newHandle) newHandle.style.display = 'block';

    const span = activeDraggableText.querySelector('span');
    if (span) {
        span.style.backgroundColor = 'rgba(200, 230, 255, 0.9)';
        span.style.width = 'auto';
    }
    const buttonContainer = activeDraggableText.querySelector('.button-container');
    if (buttonContainer) {
        buttonContainer.style.opacity = '1';
        buttonContainer.style.transform = 'translateX(0)';
    }
}

function startDragging(e, draggableText) {
    const startX = e.clientX - draggableText.offsetLeft;
    const startY = e.clientY - draggableText.offsetTop;

    function onMouseMove(e) {
        draggableText.style.left = `${e.clientX - startX}px`;
        draggableText.style.top = `${e.clientY - startY}px`;
    }

    function onMouseUp() {
        document.removeEventListener('mousemove', onMouseMove);
        document.removeEventListener('mouseup', onMouseUp);
    }

    document.addEventListener('mousemove', onMouseMove);
    document.addEventListener('mouseup', onMouseUp);
}


if (toggleBtn && sidebar) {
    toggleBtn.addEventListener('click', () => {
        isSidebarCollapsed = !isSidebarCollapsed;
        sidebar.classList.toggle('collapsed', isSidebarCollapsed);

        // Меняем иконку кнопки
        if (isSidebarCollapsed) {
            toggleBtn.innerHTML = '<i class="fas fa-chevron-left"></i>'; // Стрелка влево, когда свернуто
            toggleBtn.title = "Развернуть";
        } else {
            toggleBtn.innerHTML = '<i class="fas fa-chevron-right"></i>'; // Стрелка вправо, когда развернуто
            toggleBtn.title = "Свернуть";
        }
    });
} else {
    console.error("Не найдены элементы sidebar или toggleBtn");
}


// ЗАМЕНИТЕ ЭТОТ ОБРАБОТЧИК ЦЕЛИКОМ
document.addEventListener('mousedown', function (e) {
    // Если клик был не по перетаскиваемому тексту
    if (!e.target.closest('.draggable-text')) {
        // И при этом есть активный текстовый элемент
        if (activeDraggableText) {
            activeDraggableText.classList.remove('active');
            const span = activeDraggableText.querySelector('span');
            
            // --- НАЧАЛО ИЗМЕНЕНИЙ ---
            // Проверяем, должен ли фон быть видимым, перед тем как его менять
            if (span && span.dataset.backgroundVisible === 'true') {
                span.style.backgroundColor = 'rgba(255, 255, 255, 0.9)';
            }
            // --- КОНЕЦ ИЗМЕНЕНИЙ ---
            
            // Скрываем и ручку вращения, и контейнер с кнопками
            const handle = activeDraggableText.querySelector('.rotation-handle');
            if (handle) {
                handle.style.display = 'none';
            }

            const buttonContainer = activeDraggableText.querySelector('.button-container');
            if (buttonContainer) {
                buttonContainer.style.opacity = '0';
                buttonContainer.style.transform = 'translateX(100%)';
            }
            
            activeDraggableText = null; // Снимаем выделение
        }
    }
});

document.getElementById('add-text-button').addEventListener('click', function () {
    const modal = document.createElement('div');
    modal.className = 'color-modal';
    modal.innerHTML = `
    <div class="color-modal-content">
        <h3>Добавить текст</h3>
        <input type="text" id="text-input" style="width: 80%; padding: 10px; border-radius: 2px; border: 1px solid #ccc; margin-bottom: 15px;">
        <div class="buttons">
            <button class="apply-btn"><i class="fas fa-check"></i> </button>
            <button class="cancel-btn"><i class="fas fa-times"></i> </button>
        </div>
    </div>
`;
    document.body.appendChild(modal);
    modal.style.display = 'block';

    const textInput = document.getElementById('text-input');
    const applyBtn = modal.querySelector('.apply-btn');
    const cancelBtn = modal.querySelector('.cancel-btn');

    applyBtn.addEventListener('click', () => {
        const inputText = textInput.value.trim();
        if (inputText) {
            const mapRect = document.getElementById('map').getBoundingClientRect();
            const centerX = mapRect.left + mapRect.width / 2;
            const centerY = mapRect.top + mapRect.height / 2;
            createDraggableText(inputText, { x: centerX, y: centerY });
        }
        document.body.removeChild(modal);
    });

    cancelBtn.addEventListener('click', () => {
        document.body.removeChild(modal);
    });

    modal.addEventListener('click', (e) => {
        if (e.target === modal) {
            document.body.removeChild(modal);
        }
    });

    textInput.focus();

    textInput.addEventListener('keydown', function(event) {
        if (event.key === 'Enter') {
            applyBtn.click();
        }
    });
});
         
         
            function replaceEnglishWithRussian(text) {
    const map = {
        'q': 'й',
        'w': 'ц',
        'e': 'у',
        'r': 'к',
        't': 'е',
        'y': 'н',
        'u': 'г',
        'i': 'ш',
        'o': 'щ',
        'p': 'з',
        '[': 'х',
        ']': 'ъ',
        'a': 'ф',
        's': 'ы',
        'd': 'в',
        'f': 'а',
        'g': 'п',
        'h': 'р',
        'j': 'о',
        'k': 'л',
        'l': 'д',
        ';': 'ж',
        '\'': 'э',
        'z': 'я',
        'x': 'ч',
        'c': 'с',
        'v': 'м',
        'b': 'и',
        'n': 'т',
        'm': 'ь',
        ',': 'б',
        '.': 'ю',
        '/': '.',
        'Q': 'Й',
        'W': 'Ц',
        'E': 'У',
        'R': 'К',
        'T': 'Е',
        'Y': 'Н',
        'U': 'Г',
        'I': 'Ш',
        'O': 'Щ',
        'P': 'З',
        '{': 'Х',
        '}': 'Ъ',
        'A': 'Ф',
        'S': 'Ы',
        'D': 'В',
        'F': 'А',
        'G': 'П',
        'H': 'Р',
        'J': 'О',
        'K': 'Л',
        'L': 'Д',
        ':': 'Ж',
        '"': 'Э',
        'Z': 'Я',
        'X': 'Ч',
        'C': 'С',
        'V': 'М',
        'B': 'И',
        'N': 'Т',
        'M': 'Ь',
        '<': 'Б',
        '>': 'Ю',
        '?': ','
    };
    return text.split('').map(char => map[char] || char).join('');
}


function formatCadastralNumber(input) {
    let value = input.value;
    if (/^\d/.test(value)) { // Check if the first character is a digit
        value = value.replace(/\D/g, ''); // Убираем все нецифровые символы
        const firstTwoDigits = value.slice(0, 2);
        const isSevenDigitsRegion = sevenDigitsRegions.includes(firstTwoDigits);
        const thirdBlockLength = isSevenDigitsRegion ? 7 : 6;

        let formatted = '';
        if (value.length > 0) formatted += value.slice(0, 2); // Первые 2 цифры
        if (value.length > 2) formatted += ':' + value.slice(2, 4); // Следующие 2 цифры
        if (value.length > 4) {
            const remainingDigits = value.slice(4);
            if (remainingDigits.length <= thirdBlockLength) {
                formatted += ':' + remainingDigits; // Следующие 6 или 7 цифр
            } else {
                formatted += ':' + remainingDigits.slice(0, thirdBlockLength) + ':' + remainingDigits.slice(thirdBlockLength); // Следующие 6 или 7 цифр и остаток
            }
        }
        input.value = formatted;
    } else {
        // Apply the English to Russian replacement for text input
        input.value = replaceEnglishWithRussian(value);
    }
}

async function drawFeatureFromNspd(feature) {
    if (!map || !feature || !feature.geometry) return;

    const inputText = feature.properties.descr;
    autoUpdateMskSettings(inputText);
    let centerCoords = null;
    let allFeatureBounds = [];
    let labelContentText = inputText;
    const isEgrnPointWithNoGeometry = feature.geometry.type === "Point" && feature.properties && feature.properties.categoryName === "Земельные участки ЕГРН";

    const processContour = (contour) => {
        return contour.map(coord => {
            const point = proj4('EPSG:3857', 'EPSG:4326', coord);
            return [point[1], point[0]];
        });
    };

    if (isEgrnPointWithNoGeometry) {
        labelContentText += " - объект без определенных границ, указан центр квартала";
        const geoCoordinates = proj4('EPSG:3857', 'EPSG:4326', feature.geometry.coordinates);
        centerCoords = feature.geometry.coordinates;
        allFeatureBounds.push([[geoCoordinates[1], geoCoordinates[0]], [geoCoordinates[1], geoCoordinates[0]]]);
        showNotification('Объект ЕГРН без координат границ найден', 'warning', 'exclamation-triangle');
    } else if (feature.geometry.type === "Polygon") {
        const bbox = calculateBBox(feature.geometry.coordinates);
        centerCoords = [(bbox[0] + bbox[2]) / 2, (bbox[1] + bbox[3]) / 2];
        
        const allProcessedRings = feature.geometry.coordinates.map(ring => {
            const geoCoords = processContour(ring);
            return geoCoords.map(coord => [
                coord[0] - mapOffsetY * 0.000008983,
                coord[1] - mapOffsetX * 0.000008983
            ]);
        });

        const polygon = new ymaps.Polygon(allProcessedRings, {
            featureData: feature,
            isParcelFromSingleSearch: true,
            cadastralNumber: inputText
        }, {
            strokeColor: polygonStyle.color,
            strokeWidth: polygonStyle.width,
            strokeOpacity: 0.8,
            fillColor: '#00000000'
        });
        
        map.geoObjects.add(polygon);
        polygons.push(polygon);
        
        const outerGeoCoords = processContour(feature.geometry.coordinates[0]);
        const lats = outerGeoCoords.map(c => c[0]);
        const lons = outerGeoCoords.map(c => c[1]);
        allFeatureBounds.push([[Math.min(...lats), Math.min(...lons)], [Math.max(...lats), Math.max(...lons)]]);

    } else if (feature.geometry.type === "MultiPolygon") {
        let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
        feature.geometry.coordinates.forEach(polygonCoordinates => {
            const bbox = calculateBBox(polygonCoordinates);
            minX = Math.min(minX, bbox[0]); minY = Math.min(minY, bbox[1]);
            maxX = Math.max(maxX, bbox[2]); maxY = Math.max(maxY, bbox[3]);
            
            const allProcessedRings = polygonCoordinates.map(ring => {
                const geoCoords = processContour(ring);
                return geoCoords.map(coord => [
                    coord[0] - mapOffsetY * 0.000008983,
                    coord[1] - mapOffsetX * 0.000008983
                ]);
            });

            const polygon = new ymaps.Polygon(allProcessedRings, {
                featureData: feature,
                isParcelFromSingleSearch: true,
                cadastralNumber: inputText
            }, {
                strokeColor: polygonStyle.color,
                strokeWidth: polygonStyle.width,
                strokeOpacity: 0.8,
                fillColor: '#00000000'
            });

            map.geoObjects.add(polygon);
            polygons.push(polygon);
            
            const outerGeoCoords = processContour(polygonCoordinates[0]);
            const lats = outerGeoCoords.map(c => c[0]);
            const lons = outerGeoCoords.map(c => c[1]);
            allFeatureBounds.push([[Math.min(...lats), Math.min(...lons)], [Math.max(...lats), Math.max(...lons)]]);
        });
        if (minX !== Infinity) {
            centerCoords = [(minX + maxX) / 2, (minY + maxY) / 2];
        }
    } else if (feature.geometry.type === "Point") {
        const geoCoordinates = proj4('EPSG:3857', 'EPSG:4326', feature.geometry.coordinates);
        centerCoords = feature.geometry.coordinates;
        allFeatureBounds.push([[geoCoordinates[1], geoCoordinates[0]], [geoCoordinates[1], geoCoordinates[0]]]);
        labelContentText = `${inputText} (Точка)`;
    }

    let labelPlacemark = null;
    if (centerCoords) {
        const geoCenter = proj4('EPSG:3857', 'EPSG:4326', centerCoords);
        getAddressByCoords([geoCenter[1], geoCenter[0]]).then(address => {
            document.getElementById('city-name-display').innerHTML = address;
        });
        const offsetCenter = [
            geoCenter[1] - mapOffsetY * 0.000008983,
            geoCenter[0] - mapOffsetX * 0.000008983
        ];
        const placemarkPreset = isEgrnPointWithNoGeometry ? 'islands#redStretchyIcon' : 'islands#blueStretchyIcon';

        labelPlacemark = new ymaps.Placemark(offsetCenter, {
            iconContent: labelContentText,
            hintContent: inputText,
            featureData: feature,
            isParcelFromSingleSearch: true,
            cadastralNumber: inputText
        }, {
            preset: placemarkPreset,
            draggable: true
        });
        map.geoObjects.add(labelPlacemark);
        polygons.push(labelPlacemark);
    }

    if (allFeatureBounds.length > 0) {
        let minLat = Infinity, minLng = Infinity, maxLat = -Infinity, maxLng = -Infinity;
        allFeatureBounds.forEach(bounds => {
            minLat = Math.min(minLat, bounds[0][0]); minLng = Math.min(minLng, bounds[0][1]);
            maxLat = Math.max(maxLat, bounds[1][0]); maxLng = Math.max(maxLng, bounds[1][1]);
        });
        if (isFinite(minLat)) {
            const latMargin = (maxLat - minLat) * 0.1 || 0.001;
            const lonMargin = (maxLng - minLng) * 0.1 || 0.001;
            map.setBounds([
                [minLat - latMargin, minLng - lonMargin],
                [maxLat + latMargin, maxLng + lonMargin]
            ], { checkZoomRange: true, duration: 200 });
        }
    } else if (labelPlacemark) {
        map.setCenter(labelPlacemark.geometry.getCoordinates(), 17);
    }

    addToHistory(inputText);
}


// Добавляем обработчик события input для поля city-input
document.getElementById('city-input').addEventListener('input', function (e) {
    formatCadastralNumber(this);
});


// ЗАМЕНИТЬ СТАРЫЙ ОБРАБОТЧИК KEYDOWN НА ЭТОТ
document.getElementById('city-input').addEventListener('keydown', async function (event) {
    if (event.key === 'Enter') {
        // 1. Проверяем флаг, чтобы остановить повторные вызовы
        if (isSearching) {
            console.log("Поиск уже выполняется. Новый запрос проигнорирован.");
            return;
        }

        const inputText = this.value.trim();
        if (!inputText) return;
        
           if (isZeroQuarterRequest(inputText)) {
            showNotification('Поиск в нулевом квартале не выполняется', 'warning');
            return; // Просто выходим, не начиная поиск
        }

        // 2. Устанавливаем флаг и начинаем поиск
        isSearching = true;
        console.log(`Начат поиск для: "${inputText}"`);

        try {
            // Проверка на географические координаты (2 числа)
            const coordRegex = /^(-?\d+\.?\d*)\s*[,\s]\s*(-?\d+\.?\d*)$/;
            const coordMatch = inputText.match(coordRegex);

            if (coordMatch) {
                const firstNum = parseFloat(coordMatch[1]);
                const secondNum = parseFloat(coordMatch[2]);
                if (Math.abs(firstNum) <= 90 && Math.abs(secondNum) <= 180) {
                    const coords = [firstNum, secondNum];
                    map.setCenter(coords, 17);
                    const placemark = new ymaps.Placemark(coords, { hintContent: `${firstNum}, ${secondNum}` }, { preset: 'islands#redDotIcon' });
                    map.geoObjects.add(placemark);
                    polygons.push(placemark);
                    await getAddressByCoords(coords).then(address => { document.getElementById('city-name-display').innerHTML = address; });
                    addToHistory(inputText);
                    return; // Завершаем, так как это не кадастровый номер
                }
            }

            // =========================================================
            // НОВАЯ ЛОГИКА: Сначала проверяем, является ли это кварталом
            // =========================================================
            if (isCadastralQuarter(inputText)) {
                console.log(`Обнаружен кадастровый квартал: ${inputText}. Запуск поиска границ...`);
                showLoader(`Поиск границ квартала ${inputText}...`);
                await drawCadastralQuarter(inputText); // Используем существующую функцию для отрисовки квартала
                addToHistory(inputText);
                return; // Завершаем после отрисовки квартала
            }
            
            // Основная логика для кадастровых номеров УЧАСТКОВ
            if (isValidCadastralNumber(inputText)) {
                showLoader(`Запрос данных для ${inputText}...`);
                const feature = await fetchCadastralData(inputText);

                if (!feature || !feature.geometry) {
                    console.log(`Объект ${inputText} не найден в НСПД. Поиск в архиве...`);
                    showNotification('Объект не найден в ЕГРН. Поиск в архиве КПТ...', 'warning');
                    await findParcelInArchive(inputText);
                    return; // Завершаем
                }

                // Логика для ЕЗП (остается без изменений, она корректна)
                const cnParts = inputText.split(':');
                const isSixOrSevenZerosCN = cnParts.length >= 3 && cnParts.length <= 4 && /^0{6,7}$/.test(cnParts[2]);
                const isNspdPointResult = feature.geometry.type === "Point" && feature.properties?.categoryName === "Земельные участки ЕГРН";

                if (isSixOrSevenZerosCN && isNspdPointResult) {
                    console.log(`Обнаружено ЕЗП: ${inputText}. Запуск специальной логики...`);
                    // ... (здесь остается ВАША существующая большая логика для обработки ЕЗП, она самодостаточна)
                    // Копируем её из предыдущей версии кода. Я для краткости опущу её здесь, но ВЫ ДОЛЖНЫ ЕЁ СЮДА ВСТАВИТЬ
                    // ... НАЧАЛО БЛОКА ЕЗП (скопировать из старого кода)
                    document.querySelector('.loading-text').textContent = `Загрузка данных ЕЗП ${inputText}...`;
                    let ezDataLoadedSuccessfully = false;
                    try {
                        clearMapAndResetTheme();
                        const baseEzFilename = inputText.replace(/:/g, '_');
                        const primaryEzFilename = baseEzFilename + '.nspd';
                        const alternateEzFilename = baseEzFilename + '@.nspd';
                        let zipBlob = await fetchZipFromLocalServer('ez', primaryEzFilename);
                        let loadedFromAlternate = false;
                        if (!zipBlob) {
                            zipBlob = await fetchZipFromLocalServer('ez', alternateEzFilename);
                            if (zipBlob) loadedFromAlternate = true;
                        }
                        if (zipBlob) {
                            const { features: ezFeatures, date: ezLoadDate, quarter: ezInferredCn } = await loadAndParseZipBlob(zipBlob);
                            if (ezFeatures && ezFeatures.length > 0) {
                                parcelFeaturesData = ezFeatures;
                                currentQuarterNumber = ezInferredCn || inputText;
                                cityInput.value = currentQuarterNumber;
                                const drawnEzObjects = await processAndDrawParcels(ezFeatures, 'quarter');
                                populateSidebarWithParcels(ezFeatures, ezLoadDate);
                                applyCurrentTheme();
                                updatePlacemarksVisibility();
                                document.getElementById('city-name-display').innerHTML = `ЕЗП (на 2016г.): ${currentQuarterNumber}`;
                                if (loadedFromAlternate) {
                                    showNotification(`Данные для данного единого землепользования ${currentQuarterNumber} загружены частично`, 'warning');
                                } else {
                                    showNotification(`Данные ЕЗП ${currentQuarterNumber} (${ezLoadDate || 'дата не указана'}) загружены: ${ezFeatures.length} ЗУ (с границами)`, 'success');
                                }
                                ezDataLoadedSuccessfully = true;
                                if (drawnEzObjects.length > 0) {
                                    let combinedEzpBounds = null;
                                    drawnEzObjects.forEach(obj => {
                                        if (obj instanceof ymaps.Polygon) {
                                            const bounds = obj.geometry.getBounds();
                                            if (bounds && bounds[0] && isFinite(bounds[0][0])) {
                                                if (!combinedEzpBounds) { combinedEzpBounds = [[bounds[0][0], bounds[0][1]],[bounds[1][0], bounds[1][1]]]; } 
                                                else {
                                                    combinedEzpBounds[0][0] = Math.min(combinedEzpBounds[0][0], bounds[0][0]);
                                                    combinedEzpBounds[0][1] = Math.min(combinedEzpBounds[0][1], bounds[0][1]);
                                                    combinedEzpBounds[1][0] = Math.max(combinedEzpBounds[1][0], bounds[1][0]);
                                                    combinedEzpBounds[1][1] = Math.max(combinedEzpBounds[1][1], bounds[1][1]);
                                                }
                                            }
                                        }
                                    });
                                    if (combinedEzpBounds) {
                                        const latMargin = (combinedEzpBounds[1][0] - combinedEzpBounds[0][0]) * 0.15 || 0.0005;
                                        const lonMargin = (combinedEzpBounds[1][1] - combinedEzpBounds[0][1]) * 0.15 || 0.0005;
                                        map.setBounds([[combinedEzpBounds[0][0] - latMargin, combinedEzpBounds[0][1] - lonMargin],[combinedEzpBounds[1][0] + latMargin, combinedEzpBounds[1][1] + lonMargin]], { checkZoomRange: true, duration: 300 });
                                    }
                                }
                            }
                        } else { showNotification(`Архив для ЕЗП ${inputText} (включая вариант с '@') не найден.`, 'info'); }
                    } catch (error) { showNotification(`Ошибка загрузки данных ЕЗП: ${error.message}`, 'error'); }
                    if (!ezDataLoadedSuccessfully) { await drawFeatureFromNspd(feature); }
                    // ... КОНЕЦ БЛОКА ЕЗП
                    addToHistory(inputText);
                    return; // Важно завершить здесь, чтобы не перейти к стандартной отрисовке
                }

                // Стандартная отрисовка для всех остальных кадастровых номеров
                console.log(`Найден стандартный объект ${inputText}. Отрисовка...`);
                await drawFeatureFromNspd(feature);

            } else {
                // Логика для поиска по адресу
                console.log(`"${inputText}" не является КН или кварталом. Поиск по адресу...`);
                ymaps.geocode(inputText, { results: 1 }).then(function (result) {
                    if (!result.geoObjects.get(0)) {
                        showNotification('Адрес не найден', 'error', 'exclamation-circle');
                        return;
                    }
                    addToHistory(inputText);
                    updateCity(inputText);
                });
            }
        } catch (error) {
            console.error("Критическая ошибка в обработчике поиска:", error);
            showNotification('Произошла ошибка при поиске', 'error');
        } finally {
            // 3. Сбрасываем флаг в любом случае, когда поиск завершен
            isSearching = false;
            hideLoader();
            console.log("Поиск завершен. Флаг isSearching сброшен.");
        }
    }
});


// Вспомогательная функция для расчета ограничивающего прямоугольника полигона
function calculateBBox(coordinates) {
    let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
    
    // Для MultiPolygon
    if (Array.isArray(coordinates[0][0][0])) {
        coordinates.forEach(polygon => {
            polygon.forEach(ring => {
                ring.forEach(coord => {
                    minX = Math.min(minX, coord[0]);
                    minY = Math.min(minY, coord[1]);
                    maxX = Math.max(maxX, coord[0]);
                    maxY = Math.max(maxY, coord[1]);
                });
            });
        });
    }
    // Для Polygon
    else if (Array.isArray(coordinates[0][0])) {
        coordinates.forEach(ring => {
            ring.forEach(coord => {
                minX = Math.min(minX, coord[0]);
                minY = Math.min(minY, coord[1]);
                maxX = Math.max(maxX, coord[0]);
                maxY = Math.max(maxY, coord[1]);
            });
        });
    }
    // Для кольца координат
    else if (Array.isArray(coordinates[0])) {
        coordinates.forEach(coord => {
            minX = Math.min(minX, coord[0]);
            minY = Math.min(minY, coord[1]);
            maxX = Math.max(maxX, coord[0]);
            maxY = Math.max(maxY, coord[1]);
        });
    }
    
    return [minX, minY, maxX, maxY];
}

async function queryTerrZoneInfo(latitude, longitude) {
    const centerPoint = toEPSG3857(latitude, longitude);
    const centerX = centerPoint.x;
    const centerY = centerPoint.y;
    const polygonSizeMeters = 0.15;
    const halfSize = polygonSizeMeters / 2;
    const minX = centerX - halfSize;
    const minY = centerY - halfSize;
    const maxX = centerX + halfSize;
    const maxY = centerY + halfSize;
    const width = 512;
    const height = 512;
    const i = width / 2;
    const j = height / 2;
    const bbox = `${minX},${minY},${maxX},${maxY}`;
    const url = `https://nspd.gov.ru/api/aeggis/v4/36315/wms?REQUEST=GetFeatureInfo&QUERY_LAYERS=36315&SERVICE=WMS&VERSION=1.3.0&FORMAT=image%2Fpng%2F&STYLES=&TRANSPARENT=true&LAYERS=36315&RANDOM=${Math.random()}&INFO_FORMAT=application%2Fjson&FEATURE_COUNT=10&I=${i}&J=${j}&WIDTH=${width}&HEIGHT=${height}&CRS=EPSG%3A3857&BBOX=${bbox}`;

    try {
       const response = await fetchNspd(url);
        const data = await response.json();
        return data;
    } catch (error) {
        console.error('Error fetching territorial zone data:', error);
        return null;
    }
}

async function queryZouitByArea(latitude, longitude, areaSizeMeters = 40) {
    const halfSize = areaSizeMeters / 2;
    console.log(`queryZouitByArea: Поиск в области ${areaSizeMeters}x${areaSizeMeters}м вокруг ${latitude}, ${longitude}`);

    try {
        // 1. Преобразуем центр в EPSG:3857
        const centerPoint = toEPSG3857(latitude, longitude);
        const centerX = centerPoint.x;
        const centerY = centerPoint.y;

        // 2. Создаем координаты углов квадрата в EPSG:3857
        const squareCoordsEPSG3857 = [
            [centerX - halfSize, centerY - halfSize], // Нижний левый
            [centerX + halfSize, centerY - halfSize], // Нижний правый
            [centerX + halfSize, centerY + halfSize], // Верхний правый
            [centerX - halfSize, centerY + halfSize], // Верхний левый
            [centerX - halfSize, centerY - halfSize]  // Замыкаем полигон
        ];
        console.log(`queryZouitByArea: Полигон поиска (EPSG:3857):`, squareCoordsEPSG3857);


        // 3. Формируем тело POST-запроса для /intersects
        const requestBody = {
            "geom": {
                "type": "FeatureCollection",
                "features": [{
                    "type": "Feature",
                    "geometry": {
                        "crs": {
                            "type": "name",
                            "properties": { "name": "EPSG:3857" }
                        },
                        "type": "Polygon",
                        "coordinates": [squareCoordsEPSG3857] // Важно: двойные скобки для Polygon
                    },
                    "properties": {}
                }]
            },
            "categories": [{"id": 37579}] // ID категории для ЗОУИТ
        };

        // 4. Выполняем POST-запрос
        const url = 'https://nspd.gov.ru/api/geoportal/v1/intersects?typeIntersect=fullObject';
        console.log(`queryZouitByArea: Запрос на ${url} с телом:`, JSON.stringify(requestBody));

        const response = await fetch(url, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(requestBody)
        });

        if (!response.ok) {
            console.error(`queryZouitByArea: HTTP error! status: ${response.status}`);
            const errorText = await response.text();
            console.error(`queryZouitByArea: Ошибка сервера: ${errorText}`);
            return null;
        }

        // Добавляем проверку на пустой ответ перед парсингом JSON
        const responseText = await response.text();
        if (!responseText) {
             console.warn("queryZouitByArea: Получен пустой ответ от сервера.");
             return { features: [] }; // Возвращаем структуру с пустым массивом features
        }

        const data = JSON.parse(responseText); // Парсим сохраненный текст
        console.log(`queryZouitByArea: Получен ответ с ${data?.features?.length ?? 0} features.`);
        return data; // Возвращаем весь объект ответа

    } catch (error) {
        console.error('queryZouitByArea: Ошибка выполнения запроса:', error);
        return null;
    }
}


function formatQuarterPath(cadastralNumber) {
    if (!cadastralNumber) return null;
    const parts = cadastralNumber.split(':');
    if (parts.length < 3) return null; // Needs at least quarter parts
    const quarterName = parts.slice(0, 3).join('_'); // Use underscores for path
    return `${quarterName}.nspd`; // Append the .nspd extension
}



async function fetchZipFromLocalServer(bucketName, filePathInBucket) {
    console.log(`Local Fetch: Попытка загрузить файл "${filePathInBucket}" из папки "${bucketName}"...`);
    try {
        const response = await fetch(`${STORAGE_API_URL}/${bucketName}/${filePathInBucket}`);
        if (!response.ok) {
            if (response.status === 404) {
                console.log(`Local Fetch: Файл "${filePathInBucket}" не найден в папке "${bucketName}".`);
            } else {
                console.error(`Local Fetch Error: Ошибка сервера ${response.status} для файла "${filePathInBucket}".`);
            }
            return null;
        }
        const blob = await response.blob();
        console.log(`Local Fetch: Файл "${filePathInBucket}" из папки "${bucketName}" успешно загружен.`);
        return blob;
    } catch (error) {
        console.error(`Local Fetch: Ошибка сети при запросе файла "${filePathInBucket}":`, error);
        return null;
    }
}


async function fetchOksOnZuHandler(lat, lon) {
    showLoader("Поиск земельного участка...");
    // Переменная для хранения кадастрового номера ЗУ, на случай если второй запрос не удастся
    let zuCadastralNumberForDisplay = "Не удалось определить ЗУ";

    try {
        // Шаг 1: Находим ЗУ по координатам клика
        const cadastralInfo = await queryCadastralInfo(lat, lon);
        if (!cadastralInfo || !cadastralInfo.features || cadastralInfo.features.length === 0) {
            throw new Error('Не удалось определить земельный участок в точке клика.');
        }

        const zuFeature = cadastralInfo.features[0]; // The feature for the Land Parcel (ZU)
        const zuCadastralNumber = zuFeature.properties.descr;
        if (!zuCadastralNumber) {
            throw new Error('Не удалось получить кадастровый номер земельного участка.');
        }
        // Сохраняем КН для отображения в модальном окне даже в случае ошибки
        zuCadastralNumberForDisplay = zuCadastralNumber;

        // Отрисовка контура и метки найденного ЗУ (этот блок без изменений)
        if (zuFeature.geometry && zuFeature.geometry.coordinates) {
            const coordinates = zuFeature.geometry.coordinates[0].map(coord => {
                const point = proj4('EPSG:3857', 'EPSG:4326', coord);
                return [point[1], point[0]];
            });

            const offsetCoordinates = coordinates.map(coord => [
                coord[0] - mapOffsetY * 0.000008983,
                coord[1] - mapOffsetX * 0.000008983
            ]);

            const polygon = new ymaps.Polygon([offsetCoordinates], {}, {
                strokeColor: polygonStyle.color,
                strokeWidth: polygonStyle.width,
                strokeOpacity: 0.8,
                fillColor: '#00000000',
                hintEnabled: false,
                hasBalloon: false,
                interactivityModel: 'default#transparent'
            });

            map.geoObjects.add(polygon);
            polygons.push(polygon);

            const bounds = polygon.geometry.getBounds();
            const centerGeo = [
                (bounds[0][0] + bounds[1][0]) / 2,
                (bounds[0][1] + bounds[1][1]) / 2
            ];

            getAddressByCoords(centerGeo).then(address => {
                document.getElementById('city-name-display').innerHTML = address;
            });

            const center3857 = proj4("EPSG:4326", "EPSG:3857", [centerGeo[1], centerGeo[0]]);
            lastPolygonCenter = {
                geo: { lat: centerGeo[0], lon: centerGeo[1] },
                epsg3857: { x: center3857[0], y: center3857[1] },
                native: { x: zuFeature.geometry.coordinates[0][0][0], y: zuFeature.geometry.coordinates[0][0][1] }
            };

            const cadastralText = new ymaps.Placemark([
                centerGeo[0] - mapOffsetY * 0.000008983,
                centerGeo[1] - mapOffsetX * 0.000008983
            ], {
                iconContent: zuCadastralNumber
            }, {
                preset: 'islands#blueStretchyIcon',
                draggable: true
            });

            map.geoObjects.add(cadastralText);
            polygons.push(cadastralText);
        }

        showLoader(`Запрос ОКС для ${zuCadastralNumber}...`);

        // Шаг 2: Получаем ПОЛНУЮ информацию о ЗУ по его кадастровому номеру, чтобы получить нужные ID
        const firstApiUrl = `https://nspd.gov.ru/api/geoportal/v2/search/geoportal?query=${encodeURIComponent(zuCadastralNumber)}&thematicSearchId=1`;
        const response1 = await fetchNspd(firstApiUrl);
        if (!response1.ok) throw new Error(`Ошибка запроса к НСПД (1): ${response1.status}`);
        const data1 = await response1.json();
        
        const feature = data1?.data?.features?.[0];
        if (!feature) {
             console.warn(`Объект с КН ${zuCadastralNumber} не найден в НСПД по КН, хотя был найден по координатам.`);
             displayOksInModal(null, zuCadastralNumber);
             return;
        }

        // *** НАЧАЛО ИЗМЕНЕНИЙ: НОВАЯ ЛОГИКА ОПРЕДЕЛЕНИЯ URL ***
        
        const geomId = feature.id; // Это ID объекта, который используется и как geomId, и как objdocId
        const categoryId = feature.properties?.category;
        const registersId = feature.properties?.options?.registersId; // Пытаемся получить registersId
        
        let secondApiUrl = ''; // Инициализируем URL для второго запроса

        // Проверяем, какой метод запроса использовать
        if (registersId) {
            // ПРИОРИТЕТНЫЙ МЕТОД: используем objdocId и registersId
            console.log(`Используется новый метод для поиска ОКС (с registersId: ${registersId})`);
            secondApiUrl = `https://nspd.gov.ru/api/geoportal/v1/tab-group-data?tabClass=objectsList&objdocId=${geomId}&registersId=${registersId}`;
        } else if (geomId && categoryId) {
            // ЗАПАСНОЙ МЕТОД: используем старый подход с geomId и categoryId
            console.log("registersId не найден. Используется старый метод для поиска ОКС.");
            secondApiUrl = `https://nspd.gov.ru/api/geoportal/v1/tab-group-data?tabClass=objectsList&categoryId=${categoryId}&geomId=${geomId}`;
        } else {
            // Если нет необходимых ID, поиск невозможен
            console.warn(`Не удалось извлечь необходимые ID для ${zuCadastralNumber}. Поиск ОКС невозможен.`);
            displayOksInModal(null, zuCadastralNumber);
            return;
        }

        // *** КОНЕЦ ИЗМЕНЕНИЙ ***

        // Шаг 3: Получаем список связанных объектов по СФОРМИРОВАННОМУ URL
        const response2 = await fetchNspd(secondApiUrl);
        if (!response2.ok) throw new Error(`Ошибка запроса к НСПД (2): ${response2.status}`);
        const data2 = await response2.json();

        // Шаг 4: Отображаем результаты в модальном окне
        displayOksInModal(data2, zuCadastralNumber);

    } catch (error) {
        // В случае любой ошибки на любом из шагов
        console.error("Ошибка в fetchOksOnZuHandler:", error);
        showNotification('ОКС не найдены или произошла ошибка при запросе', 'error', 'exclamation-circle');
        // Вызываем модальное окно с сообщением об ошибке
        displayOksInModal(null, zuCadastralNumberForDisplay);
    } finally {
        // Гарантированно скрываем загрузчик в конце
        hideLoader();
    }
}

function displayOksInModal(data, zuCadNum) {
    const modal = document.getElementById('oksModal');
    const modalContent = document.getElementById('oksModalContent');
    const container = document.getElementById('oksListContainer');

    modalContent.querySelector('.oks-footer-buttons')?.remove();
    modalContent.querySelector('h3')?.remove();
    container.innerHTML = '';

    const titleElement = document.createElement('h3');
    titleElement.textContent = `ОКС на ЗУ: ${zuCadNum}`;
    Object.assign(titleElement.style, {
        textAlign: 'center',
        marginTop: '0',
        marginBottom: '15px',
        paddingBottom: '10px',
        color: '#1e293b',
        fontSize: '1.2rem',
        fontWeight: '600',
        borderBottom: '1px solid #e2e8f0'
    });
    container.before(titleElement);

    let oksFound = false;
    let oksCadastralNumbers = [];

    // Используем более безопасную проверку с опциональной цепочкой (?.)
    if (data?.object?.[0]?.value && Array.isArray(data.object[0].value)) {
        oksCadastralNumbers = data.object[0].value;

        if (oksCadastralNumbers.length > 0) {
            oksFound = true;
            oksCadastralNumbers.forEach(cn => {
                if (cn) {
                    const itemDiv = document.createElement('div');
                    itemDiv.className = 'oks-item';

                    const textSpan = document.createElement('span');
                    textSpan.textContent = cn;
                    
                    const buttonsContainer = document.createElement('div');
                    buttonsContainer.className = 'oks-item-buttons';

                    const copyBtn = document.createElement('button');
                    copyBtn.className = 'oks-icon-btn';
                    copyBtn.title = `Копировать ${cn}`;
                    copyBtn.innerHTML = '<i class="fas fa-copy"></i>';
                    copyBtn.onclick = (e) => {
                        e.stopPropagation();
                        copyTextWithFeedback(cn, copyBtn);
                    };

                    const egrnBtn = document.createElement('button');
                    egrnBtn.className = 'oks-icon-btn';
                    egrnBtn.title = `Копировать ${cn} и открыть egrn.html`;
                    const egrnIcon = document.createElement('img');
                    egrnIcon.src = 'img/savannah.png';
                    egrnBtn.appendChild(egrnIcon);
                    egrnBtn.onclick = (e) => {
                        e.stopPropagation();
                        copyAndOpenEgrn(cn);
                    };

                    buttonsContainer.appendChild(copyBtn);
                    buttonsContainer.appendChild(egrnBtn);
                    
                    itemDiv.appendChild(textSpan);
                    itemDiv.appendChild(buttonsContainer);
                    container.appendChild(itemDiv);
                }
            });
        }
    }

    if (!oksFound) {
        container.innerHTML = `<div class="no-oks-found">На земельном участке ${zuCadNum} не найдено связанных объектов капитального строительства.</div>`;
    }

    const footerButtons = document.createElement('div');
    footerButtons.className = 'oks-footer-buttons';

    if (oksFound) {
        const copyAllBtn = document.createElement('button');
        copyAllBtn.id = 'oksCopyAllBtn';
        copyAllBtn.className = 'oks-footer-btn';
        copyAllBtn.innerHTML = '<i class="fas fa-clipboard-list"></i> Копировать все';
        
        const buttonColor = '#4CBB17';
        const buttonHoverColor = '#45a515';
        
        copyAllBtn.style.backgroundColor = buttonColor;

        copyAllBtn.addEventListener('mouseenter', () => {
            copyAllBtn.style.backgroundColor = buttonHoverColor;
        });
        copyAllBtn.addEventListener('mouseleave', () => {
            copyAllBtn.style.backgroundColor = buttonColor;
        });

        copyAllBtn.onclick = () => copyAllOks(oksCadastralNumbers);
        footerButtons.appendChild(copyAllBtn);
    }

    const closeBtn = document.createElement('button');
    closeBtn.id = 'closeOksModalBtn';
    closeBtn.className = 'oks-footer-btn';
    closeBtn.textContent = 'Закрыть';
    footerButtons.appendChild(closeBtn);

    modalContent.appendChild(footerButtons);

    modal.style.display = 'flex';

    const closeHandler = () => {
        modal.style.display = 'none';
    };
    closeBtn.addEventListener('click', closeHandler, { once: true });
    
    const backgroundClickHandler = (event) => {
        if (event.target === modal) {
            closeHandler();
            modal.removeEventListener('click', backgroundClickHandler);
        }
    };
    modal.addEventListener('click', backgroundClickHandler);
}

async function copyTextWithFeedback(text, element) {
    try {
        await navigator.clipboard.writeText(text);
        const originalContent = element.innerHTML;
        element.innerHTML = '<i class="fas fa-check"></i>'; // Показываем галочку
        element.style.backgroundColor = 'rgba(76, 175, 80, 0.5)'; // Зеленоватый фон

        setTimeout(() => {
            element.innerHTML = originalContent;
            element.style.backgroundColor = ''; // Возвращаем исходный фон
        }, 1500);
    } catch (err) {
        console.error('Ошибка копирования:', err);
        showNotification('Не удалось скопировать', 'error');
    }
}

async function copyAllOks(oksArray) {
    if (!oksArray || oksArray.length === 0) {
        showNotification('Нет номеров для копирования', 'warning');
        return;
    }
    const textToCopy = oksArray.join('\n');
    try {
        await navigator.clipboard.writeText(textToCopy);
        showNotification(`Скопировано ${oksArray.length} кадастровых номеров`, 'success', 'check-circle');
    } catch (err) {
        console.error('Ошибка при копировании списка:', err);
        showNotification('Не удалось скопировать список', 'error');
    }
}

async function copyAndOpenEgrn(cadastralNumber) {
    try {
        await navigator.clipboard.writeText(cadastralNumber);
        showNotification(`Скопировано: ${cadastralNumber}`, 'success', 'check-circle');
        
        // Открываем новую вкладку
        window.open('egrn.html', '_blank');

    } catch (err) {
        console.error('Ошибка при копировании или открытии окна:', err);
        showNotification('Не удалось скопировать номер', 'error');
    }
}

// Function to load and parse the ZIP blob, finding the internal JSON
// Modify loadAndParseZipBlob for more flexible JSON filename matching
async function loadAndParseZipBlob(zipBlob) {
    if (!zipBlob) throw new Error("Нет ZIP файла для загрузки.");

    document.querySelector('.loading-text').textContent = 'Обработка архива...';
    const zip = await JSZip.loadAsync(zipBlob);

    let jsonFile = null;
    let loadedDate = null;
    let inferredQuarter = null;
    // Updated pattern to match XX_YY_ZZZZZZ(Z)_PPPP YYYY-MM-DD.json
    // It now allows the third part (quarter/block) to be 6 or 7 digits,
    // and optionally a fourth part (parcel within EZ).
    const jsonFilenamePattern = /^(\d{2}_\d{2}_\d{6,7}(?:_\d+)?)\s(\d{4}-\d{2}-\d{2})\.json$/;


    console.log("Поиск JSON файла в архиве...");
    for (const filename in zip.files) {
        const match = filename.match(jsonFilenamePattern);
        if (match) {
            jsonFile = zip.files[filename];
            inferredQuarter = match[1].replace(/_/g, ':'); // Infer CN (can be quarter or full EZ CN), restore colons
            loadedDate = match[2]; // Extract the date part (YYYY-MM-DD)
            console.log(`Найден JSON файл: "${filename}", inferred CN: ${inferredQuarter}, date: ${loadedDate}`);
            break; // Found the first matching file
        }
    }

    if (!jsonFile) {
        throw new Error("Файл данных (XX_YY_ZZZZZZ(Z)[_PPPP] YYYY-MM-DD.json) не найден в архиве.");
    }

    document.querySelector('.loading-text').textContent = 'Чтение данных...';
    const jsonText = await jsonFile.async("text");

    document.querySelector('.loading-text').textContent = 'Парсинг данных...';
    const loadedFeatures = JSON.parse(jsonText);

    if (!Array.isArray(loadedFeatures) || loadedFeatures.length === 0) {
        throw new Error("Файл содержит некорректные или пустые данные.");
    }

    return { features: loadedFeatures, date: loadedDate, quarter: inferredQuarter };
}




// --- MODIFIED loadAndProcessSupabaseData ---
// Эта функция теперь правильно обрабатывает уже загруженные данные: рисует, заполняет сайдбар, применяет тему и центрирует карту.
async function loadAndProcessSupabaseData(loadedFeatures, loadedDate) {
    if (!map) {
         console.error('Карта не инициализирована в loadAndProcessSupabaseData');
         return;
    }
    if (!loadedFeatures || !Array.isArray(loadedFeatures)) {
         console.error('Нет загруженных данных из архива для обработки');
         return;
    }

    document.querySelector('.loading-text').textContent = 'Отрисовка участков из архива...';
    const drawnObjects = await processAndDrawParcels(loadedFeatures, 'quarter'); // 'quarter' source

    document.querySelector('.loading-text').textContent = 'Обновление боковой панели (архив)...';
    populateSidebarWithParcels(loadedFeatures, loadedDate); // Pass date

    document.querySelector('.loading-text').textContent = 'Применение темы (архив)...';
    applyCurrentTheme();

    // Set map bounds based on drawn objects from archive
     if (drawnObjects.length > 0) {
         let allBounds = null;
         drawnObjects.forEach(obj => {
             // Make sure the object has a geometry and bounds before trying to get them
             if (obj && typeof obj.geometry?.getBounds === 'function') {
                  const bounds = obj.geometry.getBounds();
                  // Ensure bounds are valid (not null/undefined and contain coordinates)
                  if (bounds && bounds[0] && bounds[1] && bounds[0].length === 2 && bounds[1].length === 2 && isFinite(bounds[0][0]) && isFinite(bounds[0][1]) && isFinite(bounds[1][0]) && isFinite(bounds[1][1])) {
                      if (!allBounds) {
                           allBounds = [
                               [bounds[0][0], bounds[0][1]],
                               [bounds[1][0], bounds[1][1]]
                           ];
                      } else {
                           allBounds = [
                               [Math.min(allBounds[0][0], bounds[0][0]), Math.min(allBounds[0][1], bounds[0][1])],
                               [Math.max(allBounds[1][0], bounds[1][0]), Math.max(allBounds[1][1], bounds[1][1])]
                           ];
                      }
                  }
             }
         });

         // Only set bounds if we collected valid bounds from drawn objects
         if (allBounds && allBounds[0] && allBounds[1]) {
             // Add a small margin for better viewing
             const latDiff = (allBounds[1][0] - allBounds[0][0]) * 0.15 || 0.0005;
             const lonDiff = (allBounds[1][1] - allBounds[0][1]) * 0.15 || 0.0005;
             const viewBounds = [
                  [allBounds[0][0] - latDiff, allBounds[0][1] - lonDiff],
                  [allBounds[1][0] + latDiff, allBounds[1][1] + lonDiff]
             ];
             try {
                 map.setBounds(viewBounds, {
                     checkZoomRange: true,
                     duration: 300 // Smooth transition
                 });
             } catch (setBoundsError) {
                  console.error("Ошибка установки границ карты:", setBoundsError, viewBounds);
             }
         } else if (drawnObjects.length > 0) {
              // Fallback: if bounds couldn't be calculated but objects exist,
              // try centering on the first object's coordinates if available
              const firstObjCoords = drawnObjects[0]?.geometry?.getCoordinates();
              if (firstObjCoords && Array.isArray(firstObjCoords[0])) {
                   const centerCoords = firstObjCoords[0].length === 2 ? firstObjCoords[0] : firstObjCoords[0][0]; // Handle Point vs Polygon coords
                   if (centerCoords && centerCoords.length === 2) {
                        map.setCenter(centerCoords, map.getZoom() > 16 ? map.getZoom() : 17, { duration: 300 });
                   }
              }
         }
    }
    // Loader hiding and final notification are handled by the calling function (triggerSupabaseImport)
}
// --- END MODIFIED loadAndProcessSupabaseData ---


// Global variable to hold geometry if found by point before map clear
window.pendingQuarterGeometryToDraw = null;
window.pendingQuarterNumber = null; // To store the number associated with the pending geometry


async function triggerSupabaseImport() {
    if (!map) {
        console.error('Карта не инициализирована для импорта');
        hideLoader(); // Скрыть загрузчик, если карта не готова
        return;
    }

    const inputText = cityInput.value.trim();
    console.log("triggerSupabaseImport CALLED. inputText:", inputText, "currentQuarterNumber:", currentQuarterNumber, "pendingQuarterNumber:", window.pendingQuarterNumber);

    let baseCadastralNumber = null;

    // ПРИОРИТЕТ 1: Текст из cityInput, если он валидный квартал или КН
    if (inputText) {
        if (isCadastralQuarter(inputText)) {
            baseCadastralNumber = inputText;
            console.log("Определен baseCadastralNumber из inputText (квартал):", baseCadastralNumber);
        } else if (isValidCadastralNumber(inputText)) {
            const parts = inputText.split(':');
            if (parts.length >= 3) {
                baseCadastralNumber = parts.slice(0, 3).join(':');
                console.log("Определен baseCadastralNumber из inputText (КН -> квартал):", baseCadastralNumber);
            }
        }
    }

    // ПРИОРИТЕТ 2: pendingQuarterNumber (если cityInput не дал результата или был пуст)
    if (!baseCadastralNumber && window.pendingQuarterNumber) {
        baseCadastralNumber = window.pendingQuarterNumber;
        console.log("Определен baseCadastralNumber из window.pendingQuarterNumber:", baseCadastralNumber);
    }

    // ПРИОРИТЕТ 3: currentQuarterNumber (если предыдущие не дали результата)
    if (!baseCadastralNumber && currentQuarterNumber) {
        baseCadastralNumber = currentQuarterNumber;
        console.log("Определен baseCadastralNumber из currentQuarterNumber:", baseCadastralNumber);
    }


    if (!baseCadastralNumber) {
        showNotification('Не указан квартал для импорта. Введите номер в поле или определите квартал.', 'warning', 'exclamation-triangle');
        hideLoader();
        return;
    }

    // --- ОБНОВЛЕНО: Устанавливаем currentQuarterNumber здесь, чтобы он был доступен для drawCadastralQuarterFromDB ---
    currentQuarterNumber = baseCadastralNumber;
    cityInput.value = baseCadastralNumber; // Синхронизация инпута
    console.log("ИТОГОВЫЙ baseCadastralNumber для импорта:", baseCadastralNumber);


    showLoader(`Загрузка данных для ${baseCadastralNumber}...`);
    if (loaderTextEl) loaderTextEl.textContent = `Загрузка данных для ${baseCadastralNumber}...`;

    // Очищаем карту ПОСЛЕ того, как определили baseCadastralNumber
    clearMapAndResetTheme();

    let quarterDrawnFromDB = false;
    let quarterGeometrySource = null;

    // 1. Попытка получить геометрию квартала
    if (window.pendingQuarterGeometryToDraw && window.pendingQuarterNumber === baseCadastralNumber) {
        quarterGeometrySource = window.pendingQuarterGeometryToDraw;
        console.log(`Используется pending quarter geometry для ${baseCadastralNumber}`);
        window.pendingQuarterGeometryToDraw = null;
        window.pendingQuarterNumber = null;
    } else {
        console.log(`Запрос геометрии квартала ${baseCadastralNumber} из таблицы Supabase...`);
        if (loaderTextEl) loaderTextEl.textContent = `Запрос геометрии квартала ${baseCadastralNumber} из БД...`;
        try {
            const { data: geomData, error: geomError } = await supabaseClient
                .from('cadastral_quarters')
                .select('geometry')
                .eq('quarter_number', baseCadastralNumber)
                .single();

            if (geomError && geomError.code !== 'PGRST116') {
                throw geomError;
            }
            if (geomData && geomData.geometry) {
                quarterGeometrySource = geomData.geometry;
                console.log(`Геометрия для квартала ${baseCadastralNumber} получена из таблицы Supabase.`);
            } else {
                console.warn(`Геометрия для квартала ${baseCadastralNumber} не найдена в таблице Supabase.`);
            }
        } catch (dbError) {
            console.error(`Ошибка запроса геометрии квартала ${baseCadastralNumber} из таблицы Supabase:`, dbError);
        }
    }

    if (quarterGeometrySource) {
        if (loaderTextEl) loaderTextEl.textContent = `Отрисовка квартала ${baseCadastralNumber} из БД...`;
        try {
            const geometryType = quarterGeometrySource.type;
            const nspdCoordsForDrawing = quarterGeometrySource.coordinates;
            const yandexPolygonsToDraw = [];

            const processNspdRingsForYandex = (rings) => {
                const outerRingEPSG3857 = rings[0];
                const wgs84Coords = outerRingEPSG3857.map(coord => {
                    const p = proj4('EPSG:3857', 'EPSG:4326', coord);
                    return [p[1], p[0]];
                });
                return wgs84Coords.map(c => [c[0] - mapOffsetY * 0.000008983, c[1] - mapOffsetX * 0.000008983]);
            };

            if (geometryType === "Polygon") {
                yandexPolygonsToDraw.push(processNspdRingsForYandex(nspdCoordsForDrawing));
            } else if (geometryType === "MultiPolygon") {
                nspdCoordsForDrawing.forEach(polygonRingsArray => {
                    yandexPolygonsToDraw.push(processNspdRingsForYandex(polygonRingsArray));
                });
            }

            if (yandexPolygonsToDraw.length > 0) {
                const qPoly = new ymaps.Polygon(yandexPolygonsToDraw, {
                    // --- ОБНОВЛЕНО: Используем currentQuarterNumber ---
                  //  hintContent: `Квартал: ${currentQuarterNumber} (из БД)`
                }, {
                    strokeColor: '#00DD00',
                    strokeWidth: polygonStyle.width,
                    strokeStyle: 'dash',
                    fillOpacity: 0,
                    zIndex: 150
                });
                map.geoObjects.add(qPoly);
                polygons.push(qPoly);
                map.setBounds(qPoly.geometry.getBounds(), { checkZoomRange: true, duration: 300 });
                quarterDrawnFromDB = true;
                // --- ОБНОВЛЕНО: Используем currentQuarterNumber ---
             //   document.getElementById('city-name-display').innerHTML = `Квартал: ${currentQuarterNumber} (из БД)`;
            }
        } catch (e) {
            console.error("Ошибка отрисовки квартала из геометрии Supabase (в triggerSupabaseImport):", e);
            showNotification("Ошибка отрисовки геометрии квартала из БД", "error");
        }
    }

    const bucketFilePath = formatQuarterPath(baseCadastralNumber);
    let loadedFeaturesFromArchive = null;
    let loadedDateFromArchive = null;

    if (bucketFilePath) {
     //   console.log(`Попытка загрузки архива: ${bucketFilePath}`);
        if (loaderTextEl) loaderTextEl.textContent = `Загрузка из архива КПТ ${baseCadastralNumber}...`;
        
  const zipBlob = await fetchZipFromLocalServer('nspd', bucketFilePath);
        if (zipBlob) {
            try {
                const parseResult = await loadAndParseZipBlob(zipBlob);
                loadedFeaturesFromArchive = parseResult.features;
                loadedDateFromArchive = parseResult.date;
                // --- ОБНОВЛЕНО: currentQuarterNumber уже установлен выше, не нужно переопределять ---
                // if (parseResult.quarter && parseResult.quarter !== currentQuarterNumber) {
                //     console.log(`Квартал из ZIP (${parseResult.quarter}) отличается от текущего (${currentQuarterNumber}). Обновление.`);
                //     currentQuarterNumber = parseResult.quarter;
                //     cityInput.value = currentQuarterNumber;
                // }
                console.log(`Архив ${bucketFilePath} успешно загружен и распарсен. Найдено участков: ${loadedFeaturesFromArchive.length}`);
            } catch (zipError) {
                console.error(`Ошибка обработки ZIP ${bucketFilePath}:`, zipError);
                showNotification(`Ошибка обработки архива КПТ: ${zipError.message}`, 'warning');
            }
        } else {
            console.log(`Архив ${bucketFilePath} не найден в Supabase Storage (bucket: 'nspd').`); // Added bucket info for clarity
        }
    }

    if (loadedFeaturesFromArchive && loadedFeaturesFromArchive.length > 0) {
        if (loaderTextEl) loaderTextEl.textContent = 'Обработка данных из архива...';
        parcelFeaturesData = loadedFeaturesFromArchive;
        await loadAndProcessSupabaseData(loadedFeaturesFromArchive, loadedDateFromArchive);
        showNotification(`Данные из архива КПТ (${loadedDateFromArchive || 'дата не указана'}) успешно загружены: ${loadedFeaturesFromArchive.length} ЗУ`, 'success');
    } else {
        showNotification(`Архив КПТ для квартала ${baseCadastralNumber} не найден или пуст. Обычная загрузка ...`, "info");
        if (loaderTextEl) loaderTextEl.textContent = `Загрузка  ${baseCadastralNumber}...`;
        await getAllParcelsInQuarter(null, null, false, baseCadastralNumber, quarterDrawnFromDB);
    }

    hideLoader();
}

// Inside the exportParcelDataToExcelZip function
async function exportParcelDataToExcelZip() {
     if (!parcelFeaturesData || parcelFeaturesData.length === 0) {
         showNotification('Нет данных участков для экспорта. Пожалуйста, сначала загрузите земельные участки в квартале', 'warning', 'exclamation-triangle');
         return;
     }
     if (!currentQuarterNumber) {
         showNotification('Не определен квартал для имени файла экспорта. Загрузите данные квартала.', 'warning', 'exclamation-triangle');
         return;
     }


     showLoader('Подготовка данных для экспорта...');

     try {
         // Determine filename
         let quarterName = currentQuarterNumber.replace(/:/g, '_'); // Remove colons for path safety

         const today = new Date();
         const dateString = today.getFullYear() + '-' +
                            String(today.getMonth() + 1).padStart(2, '0') + '-' +
                            String(today.getDate()).padStart(2, '0');

         // Outer ZIP filename
         const filename = `${quarterName}.nspd`;

         // Internal JSON filename
         const internalJsonFilename = `${quarterName} ${dateString}.json`;

         // --- MODIFIED: Use the helper function to generate the blob ---
         console.log(`Export: Генерация ZIP файла "${filename}" с внутренним файлом "${internalJsonFilename}"...`);
         const zipBlob = await generateParcelDataZipBlob(parcelFeaturesData, internalJsonFilename);
         // --- END MODIFIED ---


         // Save the blob using FileSaver.js
         saveAs(zipBlob, filename);

         hideLoader();
         showNotification('Данные успешно экспортированы в ZIP', 'success', 'check-circle');

     } catch (error) {
         console.error('Ошибка при экспорте данных в ZIP:', error);
         hideLoader();
         showNotification('Ошибка при экспорте данных в ZIP', 'error', 'exclamation-circle');
     }
}



function showZouitSelectionModal(features, onSelectCallback) {
    const modal = document.createElement('div');
    modal.className = 'color-modal';
    modal.style.width = '500px';
    modal.style.maxWidth = '90vw';

    let modalContent = `
        <div class="color-modal-content">
            <h3 style="margin-top: 5px; margin-bottom: 15px; font-size: 1.3rem; color: #333;">Найденные ЗОУИТ (${features.length} шт.)</h3>
            <p style="font-size: 0.9rem; color: #555; margin-bottom: 20px;">Выберите зону для отображения или отобразите все.</p>
            <div style="max-height: 40vh; overflow-y: auto; margin-bottom: 20px; width: 100%; border: 1px solid #eee; border-radius: 8px; padding: 5px;">`;

    modalContent += `
        <button class="zouit-select-button" data-index="-1" style="background-color: #4CAF50;">
            <i class="fas fa-layer-group" style="margin-right: 8px;"></i>Отобразить все (${features.length})
        </button>`;

    features.forEach((feature, index) => {
        const regNumbBorder = feature.properties.options?.reg_numb_border || 'Без номера';
        const nameByDoc = feature.properties.options?.name_by_doc || 'Без названия';
        modalContent += `
            <button class="zouit-select-button" data-index="${index}">
                <strong style="color: #1d4ed8;">${regNumbBorder}:</strong> ${nameByDoc}
            </button>`;
    });

    modalContent += `
            </div>
            <div class="buttons" style="margin-top: 10px;">
                <button class="cancel-btn" style="min-width: 120px;">
                    <i class="fas fa-times" style="margin-right: 5px;"></i>Отмена
                </button>
            </div>
        </div>`;

    modal.innerHTML = modalContent;

    const styleSheet = document.createElement("style");
    styleSheet.textContent = `
        .zouit-select-button { display: block; width: calc(100% - 20px); padding: 12px 15px; margin: 10px; border: none; border-radius: 6px; background-color: #f0f0f0; color: #333; text-align: left; cursor: pointer; transition: background-color 0.2s ease, box-shadow 0.2s ease; font-size: 0.9rem; box-shadow: 0 1px 3px rgba(0,0,0,0.1); }
        .zouit-select-button:hover { background-color: #e0e0e0; box-shadow: 0 2px 5px rgba(0,0,0,0.15); }
        .zouit-select-button[data-index="-1"] { color: white; font-weight: bold; }
        .zouit-select-button[data-index="-1"]:hover { background-color: #45a049; }
    `;
    modal.appendChild(styleSheet);

    document.body.appendChild(modal);
    modal.style.display = 'block';

    const escHandler = (e) => {
        if (e.key === 'Escape') {
            modal.querySelector('.cancel-btn')?.click();
        }
    };

    modal.querySelectorAll('.zouit-select-button').forEach(button => {
        button.addEventListener('click', () => {
            const selectedIndex = parseInt(button.getAttribute('data-index'));
            document.body.removeChild(modal);
            document.removeEventListener('keydown', escHandler);
            onSelectCallback(selectedIndex);
        });
    });

    modal.querySelector('.cancel-btn').addEventListener('click', () => {
        document.body.removeChild(modal);
        document.removeEventListener('keydown', escHandler);
        onSelectCallback(null);
    });

    modal.addEventListener('click', (e) => {
        if (e.target === modal) {
             modal.querySelector('.cancel-btn')?.click();
        }
    });
    document.addEventListener('keydown', escHandler);
}

async function drawSelectedZouits(features, selectedIndex, map, polygons, polygonStyle, mapOffsetY, mapOffsetX, getAddressByCoords, proj4, ymaps, showNotification) {
    if (selectedIndex === null || !features || features.length === 0) {
        return;
    }

    const featuresToDraw = selectedIndex === -1 ? features : [features[selectedIndex]];

    let combinedBounds = null;
    let firstFeatureCenterGeo = null;

    for (const feature of featuresToDraw) {
        if (!feature.geometry || !feature.geometry.coordinates) {
            continue;
        }
        
        const nameByDocRaw = feature.properties.options?.name_by_doc || '';
        const currentStrokeColor = getZouitColor(nameByDocRaw);
        let currentLabelPreset;
        if (currentStrokeColor === '#FF0000') {
            currentLabelPreset = 'islands#redStretchyIcon';
        } else if (currentStrokeColor === '#FFA500') {
            currentLabelPreset = 'islands#yellowStretchyIcon';
        } else {
            currentLabelPreset = 'islands#violetStretchyIcon';
        }

        const regNumbBorder = feature.properties.options?.reg_numb_border || 'Не указан';
        const registrationDate = feature.properties.options?.registration_date || 'Не указана';
        const fullLabelText = `${regNumbBorder} - ${nameByDocRaw || 'Без названия'} (${registrationDate})`;

        const isMultiPolygon = feature.geometry.type === 'MultiPolygon';
        const polygonsCoords = isMultiPolygon ? feature.geometry.coordinates : [feature.geometry.coordinates];

        for (const polygonCoords of polygonsCoords) {
            // --- ИЗМЕНЕНИЕ ЗДЕСЬ ---
            const allProcessedRings = polygonCoords.map(contour => {
                if (!Array.isArray(contour) || contour.length < 3) return null;

                const coords = [];
                let conversionOk = true;
                for (const coord of contour) {
                   if (!Array.isArray(coord) || coord.length !== 2 || typeof coord[0] !== 'number' || typeof coord[1] !== 'number') { conversionOk = false; break; }
                   try {
                       const point = proj4('EPSG:3857', 'EPSG:4326', coord);
                       coords.push([point[1], point[0]]);
                   } catch (e) { conversionOk = false; break; }
                }
                if (!conversionOk || coords.length < 3) return null;

                return coords.map(c => [c[0] - mapOffsetY * 0.000008983, c[1] - mapOffsetX * 0.000008983]);
            }).filter(r => r !== null);

            if (allProcessedRings.length === 0) continue;

            try {
               const polygonObj = new ymaps.Polygon(allProcessedRings, { /*...*/ }, {
                   strokeColor: currentStrokeColor,
                   fillColor: '#00000000',
                   strokeWidth: polygonStyle.width,
                   strokeOpacity: 0.9,
                   hintContent: fullLabelText,
               });
            // --- КОНЕЦ ИЗМЕНЕНИЯ ---

               map.geoObjects.add(polygonObj);
               polygons.push(polygonObj);

               const bounds = polygonObj.geometry.getBounds();
               if (bounds) {
                   if (!combinedBounds) combinedBounds = bounds;
                   else combinedBounds = [ [Math.min(combinedBounds[0][0], bounds[0][0]), Math.min(combinedBounds[0][1], bounds[0][1])], [Math.max(combinedBounds[1][0], bounds[1][0]), Math.max(combinedBounds[1][1], bounds[1][1])] ];
                   if (!firstFeatureCenterGeo) firstFeatureCenterGeo = [(bounds[0][0] + bounds[1][0]) / 2, (bounds[0][1] + bounds[1][1]) / 2];
               }
               
               const outerRingWGS84 = polygonCoords[0].map(c => proj4('EPSG:3857', 'EPSG:4326', c));
               const turfContour = turf.polygon([outerRingWGS84.map(p => [p[0], p[1]])]);
               const centroidFeature = turf.centroid(turfContour);
               const labelPosition = [centroidFeature.geometry.coordinates[1] - mapOffsetY * 0.000008983, centroidFeature.geometry.coordinates[0] - mapOffsetX * 0.000008983];

               const zouitText = new ymaps.Placemark(labelPosition, {
                    iconContent: fullLabelText,
                    hintContent: fullLabelText
               }, {
                    preset: currentLabelPreset,
                    draggable: true
               });
               map.geoObjects.add(zouitText);
               polygons.push(zouitText);
            } catch (ymapsError) {
                 console.error(`Ошибка Yandex Maps Polygon:`, ymapsError);
            }
        }
    }

    if (combinedBounds) {
         const latMargin = (combinedBounds[1][0] - combinedBounds[0][0]) * 0.1 || 0.001;
         const lonMargin = (combinedBounds[1][1] - combinedBounds[0][1]) * 0.1 || 0.001;
         const viewBounds = [[combinedBounds[0][0] - latMargin, combinedBounds[0][1] - lonMargin], [combinedBounds[1][0] + latMargin, combinedBounds[1][1] + lonMargin]];
         try {
            map.setBounds(viewBounds, { checkZoomRange: true, duration: 300 });
         } catch (boundsError) {
              console.error("Ошибка установки границ:", boundsError, viewBounds);
              if(firstFeatureCenterGeo) map.setCenter(firstFeatureCenterGeo, 16);
         }
    } else if (featuresToDraw.length > 0) {
         console.warn("Ни одна ЗОУИТ не была отрисована после выбора.");
    }

    if (firstFeatureCenterGeo) {
        getAddressByCoords(firstFeatureCenterGeo).then(address => {
            document.getElementById('city-name-display').innerHTML = address || 'Адрес не определен';
        });
        try {
            const center3857 = proj4("EPSG:4326", "EPSG:3857", [firstFeatureCenterGeo[1], firstFeatureCenterGeo[0]]);
            lastPolygonCenter = { geo: { lat: firstFeatureCenterGeo[0], lon: firstFeatureCenterGeo[1] }, epsg3857: { x: center3857[0], y: center3857[1] }, native: {} };
        } catch (projError) { console.error("Ошибка proj4 lastPolygonCenter:", projError); }
    }
}




async function takeScreenshot() {
    const mapElement = document.getElementById('map');
    const widgetElement = document.getElementById('widget');

    // 1. Временно скрываем виджет и показываем лоадер
    widgetElement.style.visibility = 'hidden';
    showLoader('Создание скриншота (F10)...');

    try {
        // 2. Используем html2canvas для создания снимка карты
        const canvas = await html2canvas(mapElement, {
            useCORS: true,
            allowTaint: true,
            logging: false
        });

        // 3. Конвертируем canvas в Blob
        canvas.toBlob(async (blob) => {
            if (!blob) {
                throw new Error('Не удалось создать Blob из canvas');
            }
            // 4. Используем Clipboard API для копирования изображения
            await navigator.clipboard.write([
                new ClipboardItem({
                    [blob.type]: blob
                })
            ]);
            
            showNotification('Скриншот скопирован в буфер обмена!', 'success', 'check-circle');
            
            // 5. Открываем новую страницу
            window.open('image.html', '_blank');

        }, 'image/png');

    } catch (error) {
        console.error('Ошибка при создании скриншота:', error);
        showNotification('Ошибка при создании скриншота', 'error', 'exclamation-triangle');
    } finally {
        // 6. Гарантированно возвращаем виджет и скрываем лоадер
        hideLoader();
        widgetElement.style.visibility = 'visible';
    }
}


async function queryZouitInfo(latitude, longitude) {
    const searchAreaSizeMeters = 40;
    const halfSize = searchAreaSizeMeters / 2;
    const featureLimit = 50;

    try {
        const centerPoint = toEPSG3857(latitude, longitude);
        const centerX = centerPoint.x;
        const centerY = centerPoint.y;

        const minX = centerX - halfSize;
        const minY = centerY - halfSize;
        const maxX = centerX + halfSize;
        const maxY = centerY + halfSize;

        const width = 512;
        const height = 512;
        const i = width / 2;
        const j = height / 2;
        const bbox = `${minX},${minY},${maxX},${maxY}`;

        const url = `https://nspd.gov.ru/api/aeggis/v4/37579/wms?REQUEST=GetFeatureInfo&QUERY_LAYERS=37579&SERVICE=WMS&VERSION=1.3.0&FORMAT=image%2Fpng%2F&STYLES=&TRANSPARENT=true&LAYERS=37579&RANDOM=${Math.random()}&INFO_FORMAT=application%2Fjson&FEATURE_COUNT=${featureLimit}&I=${i}&J=${j}&WIDTH=${width}&HEIGHT=${height}&CRS=EPSG%3A3857&BBOX=${bbox}`;

       const response = await fetchNspd(url);
        if (!response.ok) {
            const errorText = await response.text().catch(() => `HTTP error ${response.status}`);
            console.error(`queryZouitInfo (WMS): HTTP error! status: ${response.status}, Ошибка сервера: ${errorText}`);
            return null;
        }
        const responseText = await response.text();
        if (!responseText) {
             return { features: [] };
        }

        const data = JSON.parse(responseText);
        return data;

    } catch (error) {
        console.error('queryZouitInfo (WMS): Ошибка fetch или JSON parse:', error);
        return null;
    }
}


async function zouitMenuItemHandler(contextMenu, map, polygons, polygonStyle, mapOffsetY, mapOffsetX, getAddressByCoords, proj4, ymaps, showNotification) {
    const lat = parseFloat(contextMenu.dataset.lat);
    const lon = parseFloat(contextMenu.dataset.lon);

    contextMenu.style.display = 'none';

    try {
        const queryPointsWGS84 = [];
        queryPointsWGS84.push([lat, lon]);
        const squareHalfSizeMeters = 7.5;
        const centerEPSG3857 = proj4("EPSG:4326", "EPSG:3857", [lon, lat]);
        const centerX = centerEPSG3857[0];
        const centerY = centerEPSG3857[1];
        const cornersEPSG3857 = [
            [centerX - squareHalfSizeMeters, centerY + squareHalfSizeMeters],
            [centerX + squareHalfSizeMeters, centerY + squareHalfSizeMeters],
            [centerX - squareHalfSizeMeters, centerY - squareHalfSizeMeters],
            [centerX + squareHalfSizeMeters, centerY - squareHalfSizeMeters]
        ];
        for (const corner of cornersEPSG3857) {
            try {
                const cornerWGS84 = proj4("EPSG:3857", "EPSG:4326", corner);
                queryPointsWGS84.push([cornerWGS84[1], cornerWGS84[0]]);
            } catch (projError) { console.error("Ошибка конвертации координат угла:", corner, projError); }
        }

        const promises = queryPointsWGS84.map(point => queryZouitInfo(point[0], point[1]));
        const results = await Promise.all(promises);

        const allFoundFeatures = [];
        const uniqueFeatureIds = new Set();

        results.forEach((result) => {
            if (result && result.features && result.features.length > 0) {
                result.features.forEach(feature => {
                    const featureId = feature.id;
                    if (featureId && !uniqueFeatureIds.has(featureId)) {
                        uniqueFeatureIds.add(featureId);
                        allFoundFeatures.push(feature);
                    } else if (!featureId) {
                         const featureDescr = feature.properties?.descr;
                          if (featureDescr && !uniqueFeatureIds.has(featureDescr)) {
                              uniqueFeatureIds.add(featureDescr);
                              allFoundFeatures.push(feature);
                          }
                    }
                });
            }
        });

        if (allFoundFeatures.length === 0) {
            showNotification('ЗОУИТ не найдены', 'warning', 'exclamation-triangle');
            return;
        }

        showZouitSelectionModal(allFoundFeatures, (selectedIndex) => {
            if (selectedIndex !== null) {
                drawSelectedZouits(allFoundFeatures, selectedIndex, map, polygons, polygonStyle, mapOffsetY, mapOffsetX, getAddressByCoords, proj4, ymaps, showNotification);
            }
        });

    } catch (error) {
        console.error('Критическая ошибка в zouitMenuItemHandler:', error);
        showNotification('Ошибка при обработке запроса ЗОУИТ', 'error', 'exclamation-circle');
    }
}



async function queryForestryInfo(latitude, longitude) {
    const centerPoint = toEPSG3857(latitude, longitude);
    const centerX = centerPoint.x;
    const centerY = centerPoint.y;
    const polygonSizeMeters = 0.15;
    const halfSize = polygonSizeMeters / 2;
    const minX = centerX - halfSize;
    const minY = centerY - halfSize;
    const maxX = centerX + halfSize;
    const maxY = centerY + halfSize;
    const width = 512;
    const height = 512;
    const i = width / 2;
    const j = height / 2;
    const bbox = `${minX},${minY},${maxX},${maxY}`;
    const url = `https://nspd.gov.ru/api/aeggis/v4/36314/wms?REQUEST=GetFeatureInfo&QUERY_LAYERS=36314&SERVICE=WMS&VERSION=1.3.0&FORMAT=image%2Fpng%2F&STYLES=&TRANSPARENT=true&LAYERS=36314&RANDOM=${Math.random()}&INFO_FORMAT=application%2Fjson&FEATURE_COUNT=10&I=${i}&J=${j}&WIDTH=${width}&HEIGHT=${height}&CRS=EPSG%3A3857&BBOX=${bbox}`;

    try {
        const response = await fetchNspd(url);
        const data = await response.json();
        return data;
    } catch (error) {
        console.error('Error fetching forestry data:', error);
        return null;
    }
}

async function forestryMenuItemHandler(contextMenu, map, polygons, polygonStyle, mapOffsetY, mapOffsetX, getAddressByCoords, proj4, ymaps, showNotification) {
    const lat = parseFloat(contextMenu.dataset.lat);
    const lon = parseFloat(contextMenu.dataset.lon);

    try {
        const forestryData = await queryForestryInfo(lat, lon);

        if (!forestryData || !forestryData.features || forestryData.features.length === 0) {
            showNotification('Лесничество не найдено', 'error', 'exclamation-circle');
            contextMenu.style.display = 'none';
            return;
        }

        const feature = forestryData.features[0];

        if (!feature.geometry || !feature.geometry.coordinates) {
            throw new Error('Геометрия или координаты отсутствуют в данных');
        }

        let combinedBounds = null;
        const turfPolygons = [];
        let clickedContourCentroid = null;

        const isMultiPolygon = feature.geometry.type === 'MultiPolygon';
        const polygonsCoords = isMultiPolygon ? feature.geometry.coordinates : [feature.geometry.coordinates];
        
        const regNumbBorder = feature.properties.options?.reg_numb_border || 'Не указан';
        const nameByDoc = feature.properties.options?.name_by_doc || 'Не указано';
        const registrationDate = feature.properties.options?.registration_date || 'Не указана';
        const labelContent = `${regNumbBorder} - ${nameByDoc} (${registrationDate})`;


        for (let polygonIndex = 0; polygonIndex < polygonsCoords.length; polygonIndex++) {
            const polygonCoords = polygonsCoords[polygonIndex];

            for (let contourIndex = 0; contourIndex < polygonCoords.length; contourIndex++) {
                const contour = polygonCoords[contourIndex];
                if (!Array.isArray(contour)) {
                    console.error(`Некорректный формат контура в полигоне:`, contour);
                    continue;
                }

                const coords = [];
                for (const coord of contour) {
                    if (!Array.isArray(coord) || coord.length !== 2 || typeof coord[0] !== 'number' || typeof coord[1] !== 'number' || !Number.isFinite(coord[0]) || !Number.isFinite(coord[1])) {
                        console.error(`Некорректная координата перед преобразованием:`, coord);
                        continue;
                    }

                    try {
                        const point = proj4('EPSG:3857', 'EPSG:4326', coord);
                        if (!Number.isFinite(point[0]) || !Number.isFinite(point[1])) {
                            console.error(`Преобразование дало некорректные значения:`, coord, '->', point);
                            continue;
                        }
                        coords.push([point[1], point[0]]);
                    } catch (e) {
                        console.error(`Ошибка преобразования координаты:`, coord, e);
                        continue;
                    }
                }

                if (coords.length > 0) {
                    const offsetCoords = coords.map(coord => [
                        coord[0] - mapOffsetY * 0.000008983,
                        coord[1] - mapOffsetX * 0.000008983
                    ]);

                    const polygonObj = new ymaps.Polygon([offsetCoords], {}, {
                        strokeColor: '#228B22', // Forest Green
                        strokeWidth: polygonStyle.width,
                        strokeOpacity: 0.8,
                        fillColor: '#00000000',
                        hintEnabled: false,
                        hasBalloon: false,
                        interactivityModel: 'default#transparent'
                    });

                    map.geoObjects.add(polygonObj);
                    polygons.push(polygonObj);

                    const bounds = polygonObj.geometry.getBounds();
                    if (!combinedBounds) {
                        combinedBounds = bounds;
                    } else {
                        combinedBounds[0][0] = Math.min(combinedBounds[0][0], bounds[0][0]);
                        combinedBounds[0][1] = Math.min(combinedBounds[0][1], bounds[0][1]);
                        combinedBounds[1][0] = Math.max(combinedBounds[1][0], bounds[1][0]);
                        combinedBounds[1][1] = Math.max(combinedBounds[1][1], bounds[1][1]);
                    }

                    const turfContour = turf.polygon([coords.map(coord => [coord[1], coord[0]])]);
                    turfPolygons.push(turfContour);

                    const clickPoint = turf.point([lon, lat]);
                    const isPointInContour = turf.booleanPointInPolygon(clickPoint, turfContour);

                    if (isPointInContour) {
                        const centroidFeature = turf.centroid(turfContour);
                        const centroidCoordsGeo = centroidFeature.geometry.coordinates;
                        clickedContourCentroid = [
                            centroidCoordsGeo[1] - mapOffsetY * 0.000008983,
                            centroidCoordsGeo[0] - mapOffsetX * 0.000008983
                        ];
                    }
                }
            }
        }

        if (!combinedBounds) {
            throw new Error('Не удалось определить границы полигона');
        }

        map.setBounds(combinedBounds, {
            checkZoomRange: true,
            duration: 200
        });

        const centerGeo = [
            (combinedBounds[0][0] + combinedBounds[1][0]) / 2,
            (combinedBounds[0][1] + combinedBounds[1][1]) / 2
        ];

        getAddressByCoords(centerGeo).then(address => {
            document.getElementById('city-name-display').innerHTML = address;
        });

        const center3857 = proj4("EPSG:4326", "EPSG:3857", [centerGeo[1], centerGeo[0]]);

        lastPolygonCenter = {
            geo: {
                lat: centerGeo[0],
                lon: centerGeo[1]
            },
            epsg3857: {
                x: center3857[0],
                y: center3857[1]
            },
            native: {
                x: feature.geometry.coordinates[0]?.[0]?.[0]?.[0] || 0,
                y: feature.geometry.coordinates[0]?.[0]?.[0]?.[1] || 0
            }
        };

        if (clickedContourCentroid) {
            const forestryText = new ymaps.Placemark(clickedContourCentroid, {
                iconContent: labelContent,
                hintContent: labelContent
            }, {
                preset: 'islands#greenStretchyIcon',
                draggable: true 
            });

            map.geoObjects.add(forestryText);
            polygons.push(forestryText);
        } else {
            console.warn('Выбранная точка не попала ни в один из контуров');
        }
    } catch (error) {
        console.error('Ошибка при получении лесничества:', error);
        showNotification('Ошибка обработки данных лесничества', 'error', 'exclamation-circle');
    }
    contextMenu.style.display = 'none';
}


async function queryMunicipalInfo(latitude, longitude) {
    const centerPoint = toEPSG3857(latitude, longitude);
    const centerX = centerPoint.x;
    const centerY = centerPoint.y;
    const polygonSizeMeters = 0.15;
    const halfSize = polygonSizeMeters / 2;
    const minX = centerX - halfSize;
    const minY = centerY - halfSize;
    const maxX = centerX + halfSize;
    const maxY = centerY + halfSize;
    const width = 512;
    const height = 512;
    const i = width / 2;
    const j = height / 2;
    const bbox = `${minX},${minY},${maxX},${maxY}`;
    const url = `https://nspd.gov.ru/api/aeggis/v4/36278/wms?REQUEST=GetFeatureInfo&QUERY_LAYERS=36278&SERVICE=WMS&VERSION=1.3.0&FORMAT=image%2Fpng%2F&STYLES=&TRANSPARENT=true&LAYERS=36278&RANDOM=${Math.random()}&INFO_FORMAT=application%2Fjson&FEATURE_COUNT=10&I=${i}&J=${j}&WIDTH=${width}&HEIGHT=${height}&CRS=EPSG%3A3857&BBOX=${bbox}`;

    try {
      const response = await fetchNspd(url);
        const data = await response.json();
        return data;
    } catch (error) {
        console.error('Error fetching municipal data:', error);
        return null;
    }
}

async function querySettlementsInfo(latitude, longitude) {
    const centerPoint = toEPSG3857(latitude, longitude);
    const centerX = centerPoint.x;
    const centerY = centerPoint.y;
    const polygonSizeMeters = 0.15;
    const halfSize = polygonSizeMeters / 2;
    const minX = centerX - halfSize;
    const minY = centerY - halfSize;
    const maxX = centerX + halfSize;
    const maxY = centerY + halfSize;
    const width = 512;
    const height = 512;
    const i = width / 2;
    const j = height / 2;
    const bbox = `${minX},${minY},${maxX},${maxY}`;
    const url = `https://nspd.gov.ru/api/aeggis/v4/36281/wms?REQUEST=GetFeatureInfo&QUERY_LAYERS=36281&SERVICE=WMS&VERSION=1.3.0&FORMAT=image%2Fpng%2F&STYLES=&TRANSPARENT=true&LAYERS=36281&RANDOM=${Math.random()}&INFO_FORMAT=application%2Fjson&FEATURE_COUNT=10&I=${i}&J=${j}&WIDTH=${width}&HEIGHT=${height}&CRS=EPSG%3A3857&BBOX=${bbox}`;

    try {
        const response = await fetchNspd(url);
        const data = await response.json();
        return data;
    } catch (error) {
        console.error('Error fetching settlements data:', error);
        return null;
    }
}


function isCadastralQuarter(text) {
    if (!text) return false;
    // Паттерн: 2 цифры, двоеточие, 2 цифры, двоеточие, 6 или 7 цифр. И больше ничего.
    const pattern = /^\d{2}:\d{2}:\d{6,7}$/;
    return pattern.test(text.trim());
}

// Новая функция для отрисовки кадастрового квартала
async function drawCadastralQuarter(quarterNumber) {
    try {
        const url = `https://nspd.gov.ru/api/geoportal/v2/search/geoportal?thematicSearchId=2&query=${quarterNumber}`;
       const response = await fetchNspd(url);
        const quarterData = await response.json();

        if (!quarterData || !quarterData.data || !quarterData.data.features || quarterData.data.features.length === 0) {
            showNotification('Данные о квартале не найдены', 'error', 'exclamation-circle');
            return;
        }

        const quarterFeature = quarterData.data.features[0];

        if (quarterFeature.geometry && quarterFeature.geometry.coordinates) {
            const coordinates = quarterFeature.geometry.coordinates[0].map(coord => {
                const point = proj4('EPSG:3857', 'EPSG:4326', coord);
                return [point[1], point[0]]; // [lat, lon]
            });

            const offsetCoordinates = coordinates.map(coord => [
                coord[0] - mapOffsetY * 0.000008983,
                coord[1] - mapOffsetX * 0.000008983
            ]);

            const polygon = new ymaps.Polygon([offsetCoordinates], {}, {
                strokeColor: '#FF0000', // Красный цвет линии
                strokeWidth: polygonStyle.width,
                strokeOpacity: 0.8,
                fillColor: '#00000000',
                hintEnabled: false,
                hasBalloon: false,
                interactivityModel: 'default#transparent'
            });

            map.geoObjects.add(polygon);
            polygons.push(polygon);

            const bounds = polygon.geometry.getBounds();
            const centerGeo = [
                (bounds[0][0] + bounds[1][0]) / 2,
                (bounds[0][1] + bounds[1][1]) / 2
            ];

            getAddressByCoords(centerGeo).then(address => {
                document.getElementById('city-name-display').innerHTML = address;
            });

            const center3857 = proj4("EPSG:4326", "EPSG:3857", [centerGeo[1], centerGeo[0]]);

            lastPolygonCenter = {
                geo: {
                    lat: centerGeo[0],
                    lon: centerGeo[1]
                },
                epsg3857: {
                    x: center3857[0],
                    y: center3857[1]
                },
                native: {
                    x: quarterFeature.geometry.coordinates[0][0][0],
                    y: quarterFeature.geometry.coordinates[0][0][1]
                }
            };

            const quarterText = new ymaps.Placemark([
                centerGeo[0] - mapOffsetY * 0.000008983,
                centerGeo[1] - mapOffsetX * 0.000008983
            ], {
                iconContent: quarterFeature.properties.descr
            }, {
                preset: 'islands#redStretchyIcon' // Красная надпись
            });

            map.geoObjects.add(quarterText);
            polygons.push(quarterText);

            let combinedBounds = null;
            polygons.forEach(obj => {
                const objBounds = obj.geometry.getBounds();
                if (!combinedBounds) {
                    combinedBounds = objBounds;
                } else {
                    combinedBounds[0][0] = Math.min(combinedBounds[0][0], objBounds[0][0]);
                    combinedBounds[0][1] = Math.min(combinedBounds[0][1], objBounds[0][1]);
                    combinedBounds[1][0] = Math.max(combinedBounds[1][0], objBounds[1][0]);
                    combinedBounds[1][1] = Math.max(combinedBounds[1][1], objBounds[1][1]);
                }
            });

            if (combinedBounds) {
                map.setBounds(combinedBounds, {
                    checkZoomRange: true,
                    duration: 200
                });
            }

            showNotification(`Квартал ${quarterFeature.properties.descr}`, 'success', 'check-circle');
        }
    } catch (error) {
        console.error('Ошибка при отрисовке квартала:', error);
        showNotification('Ошибка подключения, попробуйте позже', 'error', 'exclamation-circle');
    }
}

                     const searchIcon = document.getElementById('search-icon');

            // Обработчик события input
            cityInput.addEventListener('input', function () {
                // Условие удалено, иконка всегда видна
                searchIcon.style.display = 'block'; // Всегда показываем иконку
            });

            // Обработчик клика по иконке поиска
            searchIcon.addEventListener('click', function () {
                const inputText = cityInput.value.trim();

                if (inputText) {
                    // Имитируем нажатие Enter
                    const event = new KeyboardEvent('keydown', {
                        key: 'Enter',
                        code: 'Enter',
                        which: 13,
                        keyCode: 13,
                        bubbles: true
                    });
                    cityInput.dispatchEvent(event);
                }
            });


    

            // --- История поиска ---

            const historyIcon = document.getElementById('history-icon');
            const historyModal = document.getElementById('history-modal');
            let history = JSON.parse(localStorage.getItem('searchHistory')) || [];

    
    
function showHistoryModal() {
    historyModal.innerHTML = ''; // Очищаем предыдущее содержимое

    // --- Создаем пункт "Очистить карту" ---
    const clearMapItem = document.createElement('div');
    clearMapItem.className = 'history-item';
    clearMapItem.style.borderBottom = '1px solid rgba(255, 255, 255, 0.4)'; // Визуальный разделитель
    clearMapItem.style.cursor = 'pointer'; // Указываем, что элемент кликабелен

    const clearMapContent = document.createElement('div');
    clearMapContent.style.display = 'flex';
    clearMapContent.style.alignItems = 'center';
    clearMapContent.style.width = '100%';

    const clearMapIcon = document.createElement('i');
    clearMapIcon.className = 'fas fa-eraser'; // Иконка ластика
    clearMapIcon.style.marginRight = '8px';
    clearMapIcon.style.color = 'inherit'; // Наследуем цвет

    const clearMapText = document.createElement('span');
    clearMapText.textContent = '';
    clearMapText.style.flexGrow = '1';
    clearMapText.style.color = 'inherit'; // Наследуем цвет

    clearMapContent.appendChild(clearMapIcon);
    clearMapContent.appendChild(clearMapText);
    clearMapItem.appendChild(clearMapContent);

    // --- Добавляем обработчик клика для "Очистить карту" ---
    clearMapItem.addEventListener('click', (event) => {
        event.stopPropagation();
          clearMapAndResetTheme();// Предотвращаем закрытие модального окна по клику на документ

        // Очищаем карту
        if (map) {
            map.geoObjects.removeAll();
        }

        // Очищаем внутренние массивы отслеживания объектов
           polygons = [];
        parcelPlacemarks = [];
        parcelFeaturesData = []; // Clear theme data source
        vriColorMap.clear(); // Clear VRI colors
        currentTheme = 'none'; // Reset theme state
        hideLegends(); // Hide legends
        areaObjects = []; // Объекты измерения площади
        allAreaMeasurements = []; // Все сохраненные измерения площади
        // Удаляем перетаскиваемые тексты из DOM и очищаем массив
        draggableTexts.forEach(textEl => {
            if (textEl.parentNode) {
                textEl.parentNode.removeChild(textEl);
            }
        });
        draggableTexts = [];

        // Сбрасываем состояния
        selectedPlacemark = null;
        distanceLabel = null; // Метки удаляются через map.geoObjects.removeAll()
        areaLabel = null;     // Метки удаляются через map.geoObjects.removeAll()
        distancePoints = [];
        totalDistance = 0;
        segments = [];
        areaPoints = [];
        areaPolygon = null; // Ссылка на удаленный объект
        distanceMeasurementActive = false; // Сбрасываем режим измерения расстояния
        areaMeasurementActive = false;     // Сбрасываем режим измерения площади
        mapElement.classList.remove('measuring-distance', 'measuring-area', 'drawing-line'); // Убираем классы режимов

        // Опционально: очистить текстовые поля, связанные с координатами/поиском
        coordsInput.value = '';
        convertedTextarea.value = '';
        geoTextarea.value = '';
        cityInput.value = ''; // Очищаем поле основного ввода
        document.getElementById('city-name-display').innerHTML = ''; // Очищаем отображение адреса/КН

        // Закрываем модальное окно и показываем уведомление
        historyModal.style.display = 'none';
        showNotification('Все объекты на карте удалены', 'success', 'check-circle');

        // Обновляем виджет времени/даты, если он есть и зависит от состояния
  
    });

    // Добавляем пункт "Очистить карту" в модальное окно
    historyModal.appendChild(clearMapItem);

    // --- Добавляем остальные элементы истории поиска ---
    if (history.length === 0) {
        // Можно добавить сообщение, если история пуста (после пункта "Очистить карту")
        // const emptyItem = document.createElement('div');
        // emptyItem.className = 'history-item';
        // emptyItem.textContent = 'История поиска пуста';
        // emptyItem.style.color = 'rgba(255, 255, 255, 0.7)';
        // emptyItem.style.fontStyle = 'italic';
        // historyModal.appendChild(emptyItem);
    } else {
        history.forEach(item => {
            const historyItem = document.createElement('div');
            historyItem.className = 'history-item';

            const itemContent = document.createElement('div');
            itemContent.style.display = 'flex';
            itemContent.style.justifyContent = 'space-between';
            itemContent.style.alignItems = 'center';
            itemContent.style.width = '100%';

            const itemText = document.createElement('span');
            itemText.textContent = item;
            itemText.style.flexGrow = '1';
            itemText.style.marginRight = '8px';
            itemText.style.overflow = 'hidden';
            itemText.style.textOverflow = 'ellipsis';
            itemText.style.whiteSpace = 'nowrap';
            itemText.style.color = 'inherit';
            itemText.style.cursor = 'pointer'; // Делаем текст кликабельным
            itemText.addEventListener('click', () => {
                cityInput.value = item;
                historyModal.style.display = 'none';
                // Имитируем нажатие Enter для запуска поиска/обработки
                const event = new KeyboardEvent('keydown', {
                    key: 'Enter',
                    code: 'Enter',
                    which: 13,
                    keyCode: 13,
                    bubbles: true
                });
                cityInput.dispatchEvent(event);
            });

            const deleteButton = document.createElement('button');
            deleteButton.innerHTML = '<i class="fas fa-times"></i>';
            deleteButton.style.backgroundColor = 'transparent';
            deleteButton.style.border = 'none';
            deleteButton.style.color = 'inherit';
            deleteButton.style.cursor = 'pointer';
            deleteButton.style.fontSize = '0.8rem';
            deleteButton.style.padding = '2px 5px';
            deleteButton.style.borderRadius = "4px";
            deleteButton.addEventListener('click', (event) => {
                event.stopPropagation(); // Предотвращаем клик по родительскому элементу
                // Удаляем элемент из истории
                history = history.filter(existingItem => existingItem !== item);
                localStorage.setItem('searchHistory', JSON.stringify(history));
                showHistoryModal(); // Перерисовываем модальное окно
            });

            itemContent.appendChild(itemText);
            itemContent.appendChild(deleteButton);
            historyItem.appendChild(itemContent);
            historyModal.appendChild(historyItem);
        });
    }

    // --- Применяем стили и позиционируем модальное окно ---
    const widgetStyles = window.getComputedStyle(widget);
    // Применяем фон и цвет текста от виджета
    historyModal.style.backgroundImage = widgetStyles.backgroundImage;
    historyModal.style.backgroundSize = widgetStyles.backgroundSize;
    historyModal.style.backgroundPosition = widgetStyles.backgroundPosition;
    historyModal.style.backgroundColor = widgetStyles.backgroundColor;
    historyModal.style.color = widgetStyles.color;
    // Устанавливаем наследование цвета для всех дочерних элементов
    Array.from(historyModal.querySelectorAll('*')).forEach(el => {
        el.style.color = 'inherit';
    });

    // Позиционируем под виджетом
    const widgetRect = widget.getBoundingClientRect();
    // Учитываем прокрутку страницы при позиционировании
    const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
    const scrollLeft = window.pageXOffset || document.documentElement.scrollLeft;

    historyModal.style.position = 'absolute'; // Используем absolute для позиционирования относительно body
    historyModal.style.left = `${widgetRect.left + scrollLeft}px`;
    historyModal.style.top = `${widgetRect.bottom + scrollTop + 5}px`; // 5px отступ снизу
    historyModal.style.width = `${widgetRect.width - 20}px`; // Ширина чуть меньше виджета
    historyModal.style.display = 'block'; // Показываем модальное окно
}


            // Добавить элемент в историю
            function addToHistory(item) {
                if (history.includes(item)) {
                    // Remove the item from its current position (to move to the top)
                    history = history.filter(existingItem => existingItem !== item);
                }
                history.unshift(item); // Add to the beginning
                history = history.slice(0, 30); // Keep only the last 30 items
                localStorage.setItem('searchHistory', JSON.stringify(history));
            }



            // Обработчик клика по иконке истории
            historyIcon.addEventListener('click', (event) => {
                event.stopPropagation(); // Предотвращаем всплытие, чтобы не закрыть модальное окно сразу
                showHistoryModal();
            });

            // Закрываем модальное окно при клике вне его
            document.addEventListener('click', (event) => {
                if (!historyModal.contains(event.target) && event.target !== historyIcon) {
                    historyModal.style.display = 'none';
                }
            });


        function updateCity(address) {
    ymaps.geocode(address, {
        results: 1
    }).then(function (result) {
        const firstGeoObject = result.geoObjects.get(0);
        if (firstGeoObject) {
            const coords = firstGeoObject.geometry.getCoordinates();

            // Запускаем анимацию
            animateMapZoom();

            // Устанавливаем новый центр карты
            map.setCenter(coords, 19);

            // Обновляем адрес в виджете
            const addressComponents = firstGeoObject.getAddressLine().split(', ');
            let formattedAddress = '';
            for (let i = 0; i < addressComponents.length; i++) {
                formattedAddress += addressComponents[i] + '<br>';
            }
            document.getElementById('city-name-display').innerHTML = formattedAddress;
            localStorage.setItem('city', formattedAddress); // Сохраняем для истории? (возможно, не нужно)

            // --- УДАЛЕНО очищение карты ---
            // map.geoObjects.removeAll();
            // --- КОНЕЦ УДАЛЕНИЯ ---

            // Добавляем новый маркер для найденного адреса
            const placemark = new ymaps.Placemark(coords, {
                hintContent: firstGeoObject.getAddressLine()
            }, {
                 preset: 'islands#violetDotIcon' // Используем другой цвет, чтобы отличить от поиска по КН/координатам
            });
            map.geoObjects.add(placemark);
            polygons.push(placemark); // Добавляем в массив отслеживания

            // Добавляем в историю поиска (если это не было сделано ранее)
            // addToHistory(address); // Эта строка уже есть в обработчике Enter

        } else {
            // Если адрес не найден, просто обновляем текст
            document.getElementById('city-name-display').textContent = 'Адрес не найден';
           // showNotification('Адрес не найден', 'error', 'exclamation-circle');
        }
    });
}


async function getAllZouitsInObject(lat, lon) {
    showLoader("Поиск объекта на карте...");
    try {
        const targetPolygon = findPolygonAtPoint(lat, lon);
        if (!targetPolygon) {
            throw new Error('Объект (полигон) в точке клика не найден.');
        }
        
        const cadNumber = targetPolygon.properties.get('cadastralNumber') || 'выбранный объект';
        showLoader(`Подготовка геометрии для запроса по ${cadNumber}...`);

        const geometryType = targetPolygon.geometry.getType();
        const allCoordRings = targetPolygon.geometry.getCoordinates();
        let outerRing;

        if (geometryType === 'Polygon') {
            outerRing = allCoordRings[0];
        } else if (geometryType === 'MultiPolygon') {
            outerRing = allCoordRings[0][0];
        } else {
            throw new Error(`Неподдерживаемый тип геометрии для поиска: ${geometryType}`);
        }

        if (!outerRing || outerRing.length < 3) {
            throw new Error('Не удалось получить корректный контур объекта для поиска.');
        }

        const transformedOuterRing = outerRing.map(coord => {
            const trueLat = coord[0] + (mapOffsetY * 0.000008983);
            const trueLon = coord[1] + (mapOffsetX * 0.000008983);
            return proj4("EPSG:4326", "EPSG:3857", [trueLon, trueLat]);
        });
        
        const geometryForApi = {
            "crs": { "type": "name", "properties": { "name": "EPSG:3857" } },
            "type": "Polygon",
            "coordinates": [transformedOuterRing]
        };

        showLoader(`Поиск ЗОУИТ на объекте ${cadNumber}...`); // <-- Текст изменен

        const requestBody = {
            "geom": { "type": "FeatureCollection", "features": [{ "type": "Feature", "geometry": geometryForApi, "properties": {} }] },
            "categories": [{ "id": 36940 }]
        };

        const response = await fetchNspd('https://nspd.gov.ru/api/geoportal/v1/intersects?typeIntersect=fullObject', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(requestBody)
        });

        if (!response.ok) {
            const errorData = await response.json().catch(() => null);
            const errorMessage = errorData?.message || `Ошибка запроса к НСПД: ${response.status}`;
            throw new Error(errorMessage);
        }
        
        const zouitsData = await response.json();
        const foundZouits = zouitsData.features || [];

        if (foundZouits.length === 0) {
            showNotification('Пересекающихся ЗОУИТ с выбранным объектом не найдено.', 'info');
            return;
        }

        await processAndDrawZouits(foundZouits);
        await populateSidebarWithFoundObjects(foundZouits, 'ЗОУИТ (на объекте)'); // <-- Текст изменен

        showNotification(`Найдено пересекающихся ЗОУИТ: ${foundZouits.length}`, 'success');

    } catch (error) {
        console.error('Ошибка в функции getAllZouitsInObject:', error);
        showNotification(`Ошибка: ${error.message}`, 'error', 'exclamation-circle');
    } finally {
        hideLoader();
    }
}


async function getAllOksInObject(lat, lon) {
    showLoader("Поиск объекта на карте...");
    try {
        const targetPolygon = findPolygonAtPoint(lat, lon);
        if (!targetPolygon) {
            throw new Error('Объект (полигон) в точке клика не найден.');
        }
        
        const cadNumber = targetPolygon.properties.get('cadastralNumber') || 'выбранный объект';
        showLoader(`Поиск ОКС на объекте ${cadNumber}...`);

        const geometryType = targetPolygon.geometry.getType();
        const allCoordRings = targetPolygon.geometry.getCoordinates();
        let outerRing;

        if (geometryType === 'Polygon') outerRing = allCoordRings[0];
        else if (geometryType === 'MultiPolygon') outerRing = allCoordRings[0][0];
        else throw new Error(`Неподдерживаемый тип геометрии: ${geometryType}`);

        if (!outerRing || outerRing.length < 3) {
            throw new Error('Не удалось получить корректный контур объекта.');
        }

        const transformedOuterRing = outerRing.map(coord => {
            const trueLat = coord[0] + (mapOffsetY * 0.000008983);
            const trueLon = coord[1] + (mapOffsetX * 0.000008983);
            return proj4("EPSG:4326", "EPSG:3857", [trueLon, trueLat]);
        });
        
        const geometryForApi = {
            "crs": { "type": "name", "properties": { "name": "EPSG:3857" } },
            "type": "Polygon",
            "coordinates": [transformedOuterRing]
        };

        const requestBody = {
            "geom": { "type": "FeatureCollection", "features": [{ "type": "Feature", "geometry": geometryForApi, "properties": {} }] },
            "categories": [{ "id": 36369 }] // <-- ID ДЛЯ ЗДАНИЙ (ОКС)
        };

        const response = await fetchNspd('https://nspd.gov.ru/api/geoportal/v1/intersects?typeIntersect=fullObject', {
            method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(requestBody)
        });

        if (!response.ok) {
            const errorData = await response.json().catch(() => null);
            throw new Error(errorData?.message || `Ошибка запроса к НСПД: ${response.status}`);
        }
        
        const buildingsData = await response.json();
        const foundBuildings = buildingsData.features || [];

        if (foundBuildings.length === 0) {
            showNotification('ОКС, пересекающихся с выбранным объектом, не найдено.', 'info');
            return;
        }

        await processAndDrawBuildings(foundBuildings); // <-- Вызываем функцию для отрисовки ЗДАНИЙ
        await populateSidebarWithFoundObjects(foundBuildings, 'Здания (на объекте)'); // <-- Вызываем сайдбар для ЗДАНИЙ

        showNotification(`Найдено пересекающихся ОКС: ${foundBuildings.length}`, 'success');

    } catch (error) {
        console.error('Ошибка в функции getAllOksInObject:', error);
        showNotification(`Ошибка: ${error.message}`, 'error', 'exclamation-circle');
    } finally {
        hideLoader();
    }
}

async function getAllStructuresInObject(lat, lon) {
    showLoader("Поиск объекта на карте...");
    try {
        const targetPolygon = findPolygonAtPoint(lat, lon);
        if (!targetPolygon) {
            throw new Error('Объект (полигон) в точке клика не найден.');
        }
        
        const cadNumber = targetPolygon.properties.get('cadastralNumber') || 'выбранный объект';
        showLoader(`Поиск Сооружений на объекте ${cadNumber}...`);

        const geometryType = targetPolygon.geometry.getType();
        const allCoordRings = targetPolygon.geometry.getCoordinates();
        let outerRing;

        if (geometryType === 'Polygon') outerRing = allCoordRings[0];
        else if (geometryType === 'MultiPolygon') outerRing = allCoordRings[0][0];
        else throw new Error(`Неподдерживаемый тип геометрии: ${geometryType}`);

        if (!outerRing || outerRing.length < 3) {
            throw new Error('Не удалось получить корректный контур объекта.');
        }

        const transformedOuterRing = outerRing.map(coord => {
            const trueLat = coord[0] + (mapOffsetY * 0.000008983);
            const trueLon = coord[1] + (mapOffsetX * 0.000008983);
            return proj4("EPSG:4326", "EPSG:3857", [trueLon, trueLat]);
        });
        
        const geometryForApi = {
            "crs": { "type": "name", "properties": { "name": "EPSG:3857" } },
            "type": "Polygon",
            "coordinates": [transformedOuterRing]
        };

        const requestBody = {
            "geom": { "type": "FeatureCollection", "features": [{ "type": "Feature", "geometry": geometryForApi, "properties": {} }] },
            "categories": [{ "id": 36383 }] // <-- ID ДЛЯ СООРУЖЕНИЙ
        };

        const response = await fetchNspd('https://nspd.gov.ru/api/geoportal/v1/intersects?typeIntersect=fullObject', {
            method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(requestBody)
        });

        if (!response.ok) {
            const errorData = await response.json().catch(() => null);
            throw new Error(errorData?.message || `Ошибка запроса к НСПД: ${response.status}`);
        }
        
        const structuresData = await response.json();
        const foundStructures = structuresData.features || [];

        if (foundStructures.length === 0) {
            showNotification('Сооружений, пересекающихся с выбранным объектом, не найдено.', 'info');
            return;
        }

        await processAndDrawStructures(foundStructures); // <-- Вызываем функцию для отрисовки СООРУЖЕНИЙ
        await populateSidebarWithFoundObjects(foundStructures, 'Сооружения (на объекте)'); // <-- Вызываем сайдбар для СООРУЖЕНИЙ

        showNotification(`Найдено пересекающихся Сооружений: ${foundStructures.length}`, 'success');

    } catch (error) {
        console.error('Ошибка в функции getAllStructuresInObject:', error);
        showNotification(`Ошибка: ${error.message}`, 'error', 'exclamation-circle');
    } finally {
        hideLoader();
    }
}

async function getAllZouitsInQuarter(lat, lon) {
    showLoader("Поиск квартала для ЗОУИТ...");

    try {
        let quarterFeature = null;
        let quarterNumberToQuery = null;

        async function fetchNSPDQuarterGeometry(qn) {
            const url = `https://nspd.gov.ru/api/geoportal/v2/search/geoportal?thematicSearchId=2&query=${encodeURIComponent(qn)}`;
            try {
                const response = await fetchNspd(url); // Используем fetchNspd
                const data = await response.json();
                if (data?.data?.features?.length > 0) return data.data.features[0];
            } catch (error) { console.error(`Ошибка при запросе геометрии квартала ${qn}:`, error); }
            return null;
        }

        const cadastralData = await queryCadastralInfo(lat, lon);
        if (cadastralData?.features?.length) {
            const feature = cadastralData.features[0];
            const cadastralNumberOfPoint = feature.properties?.descr;
            if (cadastralNumberOfPoint && cadastralNumberOfPoint.split(':').length >= 3) {
                quarterNumberToQuery = cadastralNumberOfPoint.split(':').slice(0, 3).join(':');
                
                // --- ИЗМЕНЕНИЕ: Добавлена проверка на нулевой квартал ---
                if (isZeroQuarterRequest(quarterNumberToQuery)) {
                    showNotification('Поиск в нулевом квартале не выполняется', 'warning');
                    hideLoader();
                    return;
                }
                // --- КОНЕЦ ИЗМЕНЕНИЯ ---
                
                quarterFeature = await fetchNSPDQuarterGeometry(quarterNumberToQuery);
            }
        }
        
        if (!quarterFeature) {
            showNotification('Не удалось определить кадастровый квартал.', 'error');
            hideLoader();
            return;
        }

        showLoader(`Загрузка ЗОУИТ в квартале ${quarterNumberToQuery}...`);

        const requestBody = {
            "geom": { "type": "FeatureCollection", "features": [{ "type": "Feature", "geometry": quarterFeature.geometry, "properties": {} }] },
            "categories": [{ "id": 36940 }]
        };

        const response = await fetchNspd('https://nspd.gov.ru/api/geoportal/v1/intersects?typeIntersect=fullObject', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(requestBody)
        });

        if (!response.ok) throw new Error(`HTTP ошибка ${response.status} при запросе ЗОУИТ`);
        
        const zouitsData = await response.json();
        zouitFeaturesData = zouitsData.features || [];

        if (zouitFeaturesData.length === 0) {
            showNotification(`ЗОУИТ в квартале ${quarterNumberToQuery} не найдены`, 'warning');
            hideLoader();
            return;
        }

        await processAndDrawZouits(zouitFeaturesData);
        await populateSidebarWithFoundObjects(zouitFeaturesData, 'ЗОУИТ');

        showNotification(`Загружено ЗОУИТ: ${zouitFeaturesData.length} для ${quarterNumberToQuery}`, 'success');

    } catch (error) {
        console.error('Ошибка в getAllZouitsInQuarter:', error);
        showNotification(`Ошибка сети или обработки данных: ${error.message}`, 'error');
    } finally {
        hideLoader();
    }
}


function getZouitColor(zouitName) {
    // Если имя отсутствует, возвращаем фиолетовый по умолчанию
    if (!zouitName) {
        return '#9400D3'; 
    }
    
    const nameLowerCase = zouitName.toLowerCase();
    
    // 1. Приоритет: Энергетика (красный)
    if (nameLowerCase.includes('вл') || nameLowerCase.includes('вкл') || nameLowerCase.includes('электро')) {
        return '#FF0000'; // Красный
    }
    
    // 2. Газопроводы (оранжево-желтый)
    if (nameLowerCase.includes('газ')) {
        return '#FFA500'; // Оранжевый
    }

    // 3. Цвет по умолчанию для всех остальных ЗОУИТ
    return '#9400D3'; // Темно-фиолетовый
}

/**
 * 2. ПОЛНАЯ ФУНКЦИЯ ДЛЯ ОТРИСОВКИ ЗОУИТ
 */
async function processAndDrawZouits(features) {
    if (!map) return;

    for (const feature of features) {
        try {
            const properties = feature.properties || {};
            const options = properties.options || {};
            const regNumber = options.reg_numb_border || properties.descr || 'Без номера';
            const nameRaw = options.name_by_doc || 'Без названия';
            const restrictions = options.content_restrict_encumbrances || 'Ограничения не указаны';

            // --- ИЗМЕНЕНИЕ: Используем единую функцию для получения цвета ---
            const strokeColor = getZouitColor(nameRaw);

            const hintContent = {
                cadastralNumber: regNumber,
                address: nameRaw,
                area: restrictions,
            };
            
            if (!feature?.geometry?.coordinates) continue;

            const geometryType = feature.geometry.type;
            let allContours = [];
            if (geometryType === 'Polygon') allContours = [feature.geometry.coordinates[0]];
            else if (geometryType === 'MultiPolygon') feature.geometry.coordinates.forEach(poly => allContours.push(poly[0]));
            else continue;

            for (const contour of allContours) {
                 if (!Array.isArray(contour) || contour.length < 3) continue;

                 const coordinates = contour.map(coord => {
                     const p = proj4('EPSG:3857', 'EPSG:4326', coord);
                     return [p[1], p[0]];
                 });
                 const offsetCoordinates = coordinates.map(c => [c[0] - mapOffsetY * 0.000008983, c[1] - mapOffsetX * 0.000008983]);

                 const zouitPolygon = new ymaps.Polygon([offsetCoordinates], 
                    {
                        cadastralNumber: regNumber,
                        name: nameRaw,
                        hintContent: hintContent,
                        isZouit: true
                    }, 
                    {
                        strokeColor: strokeColor, // <-- Применяем полученный цвет
                        strokeWidth: polygonStyle.width - 1,
                        strokeOpacity: 0.8,
                        fillColor: '#00000000',
                        cursor: 'pointer',
                        hintLayout: customHintLayout
                    }
                 );

                zouitPolygon.events.add('dblclick', async () => {
                    try { await navigator.clipboard.writeText(regNumber); showNotification(`Скопировано: ${regNumber}`, 'success'); }
                    catch (err) { showNotification('Ошибка копирования', 'error'); }
                });

                map.geoObjects.add(zouitPolygon);
                polygons.push(zouitPolygon);

                const bounds = zouitPolygon.geometry.getBounds();
                if (bounds && bounds[0] && bounds[1]) {
                    const centerGeo = [(bounds[0][0] + bounds[1][0]) / 2, (bounds[0][1] + bounds[1][1]) / 2];
                    
                    const zouitText = new ymaps.Placemark(centerGeo, { iconContent: regNumber, hintContent: hintContent }, {
                        iconLayout: customPlacemarkLayout,
                        visible: map.getZoom() > 14
                    });
                    
                    zouitText.polygon = zouitPolygon;
                    map.geoObjects.add(zouitText);
                    polygons.push(zouitText);
                    parcelPlacemarks.push(zouitText);
                }
            }
        } catch (error) {
            console.error('Ошибка при отрисовке ЗОУИТ:', error, feature);
        }
    }
}

/**
 * 3. ПОЛНАЯ ФУНКЦИЯ ДЛЯ ЭКСПОРТА ДАННЫХ ЗОУИТ В EXCEL
 */
function exportZouitsToExcel() {
    showLoader('Подготовка данных ЗОУИТ для экспорта...');

    try {
        const dataForSheet = [];
        const headers = [
            "Регистрационный номер", "Наименование", "Ограничения", "Дата регистрации", 
            "Документ-основание", "Номер документа", "Дата документа", "Орган власти"
        ];
        dataForSheet.push(headers);

        zouitFeaturesData.forEach(feature => {
            const properties = feature.properties || {};
            const options = properties.options || {};
            
            const regNumber = options.reg_numb_border || properties.descr || 'Не указан';
            const name = options.name_by_doc || 'Не указано';
            const restrictions = options.content_restrict_encumbrances || 'Не указаны';
            const registrationDate = options.registration_date || 'Не указана';
            const docName = options.legal_act_document_name || 'Не указан';
            const docNumber = options.legal_act_document_number || 'Не указан';
            const docDate = options.legal_act_document_date || 'Не указана';
            const docIssuer = options.legal_act_document_issuer || 'Не указан';

            const row = [
                regNumber, name, restrictions, registrationDate,
                docName, docNumber, docDate, docIssuer
            ];
            dataForSheet.push(row);
        });

        const wb = XLSX.utils.book_new();
        const ws = XLSX.utils.aoa_to_sheet(dataForSheet);

        ws['!cols'] = [ {wch:20}, {wch:50}, {wch:60}, {wch:20}, {wch:50}, {wch:20}, {wch:20}, {wch:40} ];

        XLSX.utils.book_append_sheet(wb, ws, "ЗОУИТ");
        XLSX.writeFile(wb, "Найденные_ЗОУИТ.xlsx");

        showNotification('Данные ЗОУИТ успешно экспортированы в Excel', 'success', 'check-circle');

    } catch (error) {
        console.error('Ошибка при экспорте данных ЗОУИТ:', error);
        showNotification('Ошибка при экспорте данных ЗОУИТ в Excel', 'error', 'exclamation-circle');
    } finally {
        hideLoader();
    }
}




function handleOwnershipLegendClick(event) {
    const listItem = event.target.closest('li');
    if (!listItem) return;

    const clickedKey = listItem.dataset.ownershipKey;
    if (clickedKey === undefined) return;

    // Проверяем, изменилась ли категория или это повторный клик по той же
    if (selectedOwnershipFromLegend !== clickedKey) {
        // Клик по новой категории - начинаем цикл с первого шага
        selectedOwnershipFromLegend = clickedKey;
        ownershipFilterState = 1; // 1: отфильтрованные с заливкой
    } else {
        // Повторный клик по той же категории - переключаем состояние
        ownershipFilterState = (ownershipFilterState + 1) % 3;
        // Если вернулись в состояние "показать все", сбрасываем ключ выбора
        if (ownershipFilterState === 0) {
            selectedOwnershipFromLegend = null;
        }
    }

    updateOwnershipLegendSelectionVisuals();
    applyOwnershipFilter();
    updatePlacemarksVisibility(); // Обновляем видимость меток после смены фильтра
}

function updateOwnershipLegendSelectionVisuals() {
    const listItems = document.querySelectorAll('#ownership-legend-list li');
    listItems.forEach(li => {
        const itemKey = li.dataset.ownershipKey;
        li.classList.toggle('legend-item-selected', itemKey === selectedOwnershipFromLegend);
    });
}


async function searchIntersectingObjects(targetPolygon, categoryId) {
    try {
        const geometryType = targetPolygon.geometry.getType();
        const allCoordRings = targetPolygon.geometry.getCoordinates();
        let outerRing;

        if (geometryType === 'Polygon') outerRing = allCoordRings[0];
        else if (geometryType === 'MultiPolygon') outerRing = allCoordRings[0][0];
        else return [];

        if (!outerRing || outerRing.length < 3) return [];

        const transformedOuterRing = outerRing.map(coord => {
            const trueLat = coord[0] + (mapOffsetY * 0.000008983);
            const trueLon = coord[1] + (mapOffsetX * 0.000008983);
            return proj4("EPSG:4326", "EPSG:3857", [trueLon, trueLat]);
        });

        const geometryForApi = {
            "crs": { "type": "name", "properties": { "name": "EPSG:3857" } },
            "type": "Polygon",
            "coordinates": [transformedOuterRing]
        };

        const requestBody = {
            "geom": { "type": "FeatureCollection", "features": [{ "type": "Feature", "geometry": geometryForApi, "properties": {} }] },
            "categories": [{ "id": categoryId }]
        };

        const response = await fetchNspd('https://nspd.gov.ru/api/geoportal/v1/intersects?typeIntersect=fullObject', {
            method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(requestBody)
        });

        if (!response.ok) {
            console.error(`Ошибка запроса для категории ${categoryId}: ${response.status}`);
            return [];
        }
        
        const data = await response.json();
        return data.features || [];
    } catch (error) {
        console.error(`Ошибка при поиске пересечений для категории ${categoryId}:`, error);
        return [];
    }
}

// ЗАМЕНИТЕ ЭТУ ФУНКЦИЮ ПОЛНОСТЬЮ
function buildReportHtml(mainObjectData, linkedOksResults, oksResults, structuresResults, zouitResults, underlyingParcelsResults, terrZoneResults, settlementsResults, municipalResults, forestryResults, schemeImageWithPoints, schemeImageWithoutPoints, parcelsSchemeWithPoints, parcelsSchemeWithoutPoints, coordsTableHtml) {
    const reportDate = new Date().toLocaleDateString('ru-RU');

    const generateMainInfoRows = () => {
        let rows = '';
        const dataMap = {
            'Кадастровый номер': mainObjectData.cadastralNumber, 'Адрес': mainObjectData.address,
            'Площадь': mainObjectData.areaText, 'Категория земель': mainObjectData.category,
            'Разрешенное использование': mainObjectData.vri,
            'Кадастровая стоимость': mainObjectData.cost ? `${mainObjectData.cost.toLocaleString('ru-RU')} руб.` : null,
            'Форма собственности': mainObjectData.ownershipType, 'Тип права': mainObjectData.rightType
        };
        for (const [key, value] of Object.entries(dataMap)) {
            if (value) rows += `<tr><td>${key}</td><td>${value}</td></tr>`;
        }
        return rows;
    };

    const generateResultTable = (title, resultObject, headers, rowGenerator, tableClass = '') => {
        const items = resultObject && resultObject.items ? resultObject.items : (Array.isArray(resultObject) ? resultObject : []);
        const isFullyContained = (resultObject && typeof resultObject.isFullyContained === 'boolean') ? resultObject.isFullyContained : true;
        let tableHtml = `<div class="section-title">${title}</div>`;
        if (items.length > 0 && !isFullyContained) {
            tableHtml += '<p style="text-align: center; font-style: italic; font-size: 9pt; margin: -5px 0 10px 0;">Примечание: объект может находиться на территории нескольких зон. Отображена только зона в центре объекта.</p>';
        }
        if (!items || items.length === 0) {
            return tableHtml + '<p style="text-align: center; margin: 10px 0;">Объекты не найдены.</p>';
        }
        tableHtml += `<table class="${tableClass}"><thead><tr>`;
        headers.forEach(h => tableHtml += `<th>${h}</th>`);
        tableHtml += '</tr></thead><tbody>';
        items.forEach(item => tableHtml += rowGenerator(item));
        tableHtml += '</tbody></table>';
        return tableHtml;
    };

    const underlyingParcelRowGenerator = (f) => `<tr><td>${f.properties.descr || '-'}</td><td>${f.properties.options.readable_address || '-'}</td><td>${getAreaText(f.properties.options) || '-'}</td></tr>`;
    const linkedOksRowGenerator = (cn) => `<tr><td>${cn}</td></tr>`;
    const oksRowGenerator = (f) => { const o = f.properties.options; return `<tr><td>${o.cad_num || '-'}</td><td>${o.purpose || o.building_name || '-'}</td><td>${o.year_built || '-'}</td><td>${o.floors || '-'}</td></tr>`; };
    const structuresRowGenerator = (f) => { const o = f.properties.options; const l = (o.params_extension && isFinite(parseFloat(o.params_extension))) ? `${parseFloat(o.params_extension).toLocaleString('ru-RU')} м.` : '-'; return `<tr><td>${o.cad_number || '-'}</td><td>${o.params_name || '-'}</td><td>${l}</td><td>${o.params_purpose || '-'}</td></tr>`; };
    const zouitRowGenerator = (f) => { const o = f.properties.options; return `<tr><td>${o.reg_numb_border || '-'}</td><td>${o.name_by_doc || '-'}</td><td>${o.content_restrict_encumbrances || '-'}</td></tr>`; };
    const terrZoneRowGenerator = (f) => { const o = f.properties.options; return `<tr><td>${o.reg_numb_border || '-'}</td><td>${o.name_by_doc || '-'}</td><td>${o.registration_date || '-'}</td></tr>`; };
    const settlementsRowGenerator = (f) => { const p = f.properties; const o = p.options || {}; return `<tr><td>${p.label || '-'}</td><td>${o.name || '-'}</td></tr>`; };
    const municipalRowGenerator = (f) => { const p = f.properties; return `<tr><td>${p.label || '-'}</td><td>${p.descr || '-'}</td></tr>`; };
    const forestryRowGenerator = (f) => { const o = f.properties.options; return `<tr><td>${o.reg_numb_border || '-'}</td><td>${o.name_by_doc || '-'}</td><td>${o.registration_date || '-'}</td></tr>`; };

    return `<!DOCTYPE html><html lang="ru"><head><meta charset="UTF-8"><title>Отчет: ${mainObjectData.cadastralNumber}</title><link rel="icon" href="img/vyp.png"><style>body{font-family: "Times New Roman", Times, serif; margin: 0; background: #e9ecef; color: #212224; font-size: 10pt;}.page{background: white; box-shadow: 0 4px 16px rgba(0,0,0,0.1); margin: 20px auto; padding: 20mm; box-sizing: border-box; width: 210mm; max-width: 100%;}.coords-table-container table { margin-bottom: 20px; } table{width: 100%; border-collapse: collapse; margin: 8px 0 12px 0; table-layout: fixed;}th, td{border: 1px solid #333; padding: 6px 8px; text-align: center; vertical-align: middle; word-break: break-word;}th{background-color: #f8f9fa; font-weight: 600;}.main-info-table{table-layout: auto;}.main-info-table td{text-align: left;}.main-info-table td:first-child{width: 35%; font-weight: bold; background-color: #f8f9fa;}.parcels-table td{text-align: left;}.parcels-table th:nth-child(1), .parcels-table td:nth-child(1){width: 25%;}.parcels-table th:nth-child(3), .parcels-table td:nth-child(3){width: 20%;}.zouit-table td{text-align: left;}.zouit-table th:nth-child(1),.zouit-table td:nth-child(1){width: 25%;}.zouit-table th:nth-child(2),.zouit-table td:nth-child(2){width: 30%;}.header{text-align: center; margin-bottom: 20px;}.section-title{text-align: center; font-weight: bold; margin: 25px 0 10px 0; font-size: 1.1em; page-break-after: avoid;}.scheme-container{text-align: center; margin-top: 25px; page-break-inside: avoid;}.scheme-container img{max-width: 100%; border: 1px solid #ccc;}#togglePointsBtn{display:block; margin: 20px auto 0; padding: 8px 16px; font-size: 10pt; cursor: pointer;}.points-hidden .scheme-with-points, .points-visible .scheme-without-points { display: none; }.points-hidden .point-col { display: none; }@media print{body{background: none;}.page{box-shadow: none; border: none; margin: 0; padding: 15mm;} #togglePointsBtn {display: none;}}</style></head><body class="points-hidden"><div class="page"><div class="header"><h3>Сводный отчет по объекту недвижимости</h3><h4>сформирован ${reportDate}</h4></div><div class="section-title">Сведения об исходном объекте</div><table class="main-info-table">${generateMainInfoRows()}</table>${generateResultTable('Пересекаемые земельные участки', underlyingParcelsResults, ['Кадастровый номер', 'Адрес', 'Площадь'], underlyingParcelRowGenerator, 'parcels-table')}${parcelsSchemeWithoutPoints ? `<div class="scheme-container"><div class="section-title">Схема пересекаемых ЗУ</div><img src="${parcelsSchemeWithoutPoints}" class="scheme-without-points" alt="Схема пересечений"><img src="${parcelsSchemeWithPoints}" class="scheme-with-points" alt="Схема пересечений с точками"></div>` : ''}${generateResultTable('1. Связанные ОКС по сведениям ЕГРН', linkedOksResults, ['Кадастровый номер'], linkedOksRowGenerator)}${generateResultTable('2. Объекты капитального строительства на объекте', oksResults, ['Кадастровый номер', 'Назначение', 'Год ввода', 'Этажность'], oksRowGenerator)}${generateResultTable('3. Сооружения на объекте', structuresResults, ['Кадастровый номер', 'Наименование', 'Протяженность', 'Назначение'], structuresRowGenerator)}${generateResultTable('4. Зоны с особыми условиями использования территории (ЗОУИТ)', zouitResults, ['Рег. номер', 'Наименование', 'Ограничения'], zouitRowGenerator, 'zouit-table')}${generateResultTable('5. Территориальные зоны', terrZoneResults, ['Рег. номер', 'Наименование', 'Дата рег.'], terrZoneRowGenerator)}${generateResultTable('6. Населенные пункты', settlementsResults, ['Тип', 'Наименование'], settlementsRowGenerator)}${generateResultTable('7. Муниципальные образования', municipalResults, ['Наименование', 'Описание'], municipalRowGenerator)}${generateResultTable('8. Лесничества', forestryResults, ['Рег. номер', 'Наименование', 'Дата рег.'], forestryRowGenerator)}<div class="scheme-container"><div class="section-title">Схема расположения объектов</div><img src="${schemeImageWithoutPoints}" class="scheme-without-points" alt="Схема расположения"><img src="${schemeImageWithPoints}" class="scheme-with-points" alt="Схема расположения с точками"></div><button onclick="togglePoints()" id="togglePointsBtn">Показать точки</button><div class="coords-table-container">${coordsTableHtml}</div></div><script>function togglePoints(){const body = document.body; const btn = document.getElementById('togglePointsBtn'); if (body.classList.contains('points-hidden')) { body.classList.remove('points-hidden'); body.classList.add('points-visible'); btn.textContent = 'Скрыть точки'; } else { body.classList.remove('points-visible'); body.classList.add('points-hidden'); btn.textContent = 'Показать точки'; }}<\/script></body></html>`;
}

// ДОБАВЬТЕ ЭТУ ФУНКЦИЮ В ВАШ КОД
async function searchFeaturesByGeometry(targetPolygon, categoryId) {
    try {
        const geometryType = targetPolygon.geometry.getType();
        const allCoordRings = targetPolygon.geometry.getCoordinates();
        let outerRing;
        
        if (geometryType === 'Polygon') outerRing = allCoordRings[0];
        else if (geometryType === 'MultiPolygon') outerRing = allCoordRings[0][0];
        else return [];

        if (!outerRing || outerRing.length < 3) return [];

        const transformedOuterRing = outerRing.map(coord => {
            const trueLat = coord[0] + (mapOffsetY * 0.000008983);
            const trueLon = coord[1] + (mapOffsetX * 0.000008983);
            return proj4("EPSG:4326", "EPSG:3857", [trueLon, trueLat]);
        });
        
        const geometryForApi = {
            "crs": { "type": "name", "properties": { "name": "EPSG:3857" } },
            "type": "Polygon", "coordinates": [transformedOuterRing]
        };

        const requestBody = {
            "geom": { "type": "FeatureCollection", "features": [{ "type": "Feature", "geometry": geometryForApi, "properties": {} }] },
            "categories": [{ "id": categoryId }]
        };

        const response = await fetchNspd('https://nspd.gov.ru/api/geoportal/v1/intersects?typeIntersect=fullObject', {
            method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(requestBody)
        });

        if (!response.ok) { 
            console.error(`Ошибка запроса для категории ${categoryId}: ${response.status}`); 
            return []; 
        }
        
        const data = await response.json();
        return data.features || [];
    } catch (error) {
        console.error(`Ошибка при поиске пересечений для категории ${categoryId}:`, error);
        return [];
    }
}

async function searchContainingObjectByPoint(latitude, longitude, layerId, targetPolygon = null) {
    try {
        const centerPoint = toEPSG3857(latitude, longitude);
        const centerX = centerPoint.x;
        const centerY = centerPoint.y;
        
        const halfSize = 10;
        const width = 512;
        const height = 512;
        const i = 256;
        const j = 256;

        const bbox = `${centerX - halfSize},${centerY - halfSize},${centerX + halfSize},${centerY + halfSize}`;
        const url = `https://nspd.gov.ru/api/aeggis/v4/${layerId}/wms?REQUEST=GetFeatureInfo&QUERY_LAYERS=${layerId}&SERVICE=WMS&VERSION=1.3.0&FORMAT=image%2Fpng%2F&STYLES=&TRANSPARENT=true&LAYERS=${layerId}&INFO_FORMAT=application%2Fjson&FEATURE_COUNT=10&I=${i}&J=${j}&WIDTH=${width}&HEIGHT=${height}&CRS=EPSG%3A3857&BBOX=${bbox}`;

        const response = await fetchNspd(url);
        if (!response.ok) {
            console.error(`Ошибка точечного запроса для слоя ${layerId}: ${response.status}`);
            return { features: [], isContained: false };
        }
        const data = await response.json();
        const features = data.features || [];
        
        let isContained = false;

        if (targetPolygon && features.length > 0) {
            const targetBbox = targetPolygon.geometry.getBounds();
            
            for (const feature of features) {
                const serverFeatureWGS84 = { ...feature };
                
                if (serverFeatureWGS84.geometry && serverFeatureWGS84.geometry.coordinates) {
                    try {
                        const convertedCoords = serverFeatureWGS84.geometry.coordinates.map(polygon =>
                            polygon.map(ring =>
                                ring.map(coord => {
                                    if (Array.isArray(coord) && coord.length === 2 && isFinite(coord[0]) && isFinite(coord[1])) {
                                        return proj4('EPSG:3857', 'EPSG:4326', coord);
                                    }
                                    return null;
                                }).filter(Boolean)
                            ).filter(ring => ring.length > 0)
                        ).filter(polygon => polygon.length > 0);

                        serverFeatureWGS84.geometry.coordinates = convertedCoords;

                        if (isBboxInsidePolygon(targetBbox, serverFeatureWGS84)) {
                            isContained = true;
                            break; 
                        }
                    } catch (conversionError) {
                        console.error(`Ошибка при конвертации геометрии для слоя ${layerId} (ID: ${feature.id}):`, conversionError);
                    }
                }
            }
        }
        
        return { features: features, isContained: isContained };
    } catch (error) {
        console.error(`Критическая ошибка при точечном запросе для слоя ${layerId}:`, error);
        return { features: [], isContained: false };
    }
}


async function fetchLinkedOks(cadastralNumber) {
    if (!cadastralNumber) return [];
    try {
        const url1 = `https://nspd.gov.ru/api/geoportal/v2/search/geoportal?query=${encodeURIComponent(cadastralNumber)}&thematicSearchId=1`;
        const response1 = await fetchNspd(url1);
        if (!response1.ok) {
            console.error(`Ошибка запроса связанных ОКС (шаг 1): ${response1.status}`);
            return [];
        }
        const data1 = await response1.json();
        const feature = data1?.data?.features?.[0];
        if (!feature) {
             console.warn(`Объект ${cadastralNumber} не найден в НСПД для поиска связанных ОКС.`);
             return [];
        }

        const geomId = feature.id;
        const categoryId = feature.properties?.category;
        const registersId = feature.properties?.options?.registersId;
        
        let url2 = '';
        if (registersId) {
            url2 = `https://nspd.gov.ru/api/geoportal/v1/tab-group-data?tabClass=objectsList&objdocId=${geomId}&registersId=${registersId}`;
        } else if (geomId && categoryId) {
            url2 = `https://nspd.gov.ru/api/geoportal/v1/tab-group-data?tabClass=objectsList&categoryId=${categoryId}&geomId=${geomId}`;
        } else {
            console.warn(`Недостаточно ID для поиска связанных ОКС для ${cadastralNumber}.`);
            return [];
        }

        const response2 = await fetchNspd(url2);
        if (!response2.ok) {
             console.error(`Ошибка запроса связанных ОКС (шаг 2): ${response2.status}`);
            return [];
        }
        const data2 = await response2.json();
        
        return data2?.object?.[0]?.value || [];
    } catch (error) {
        console.error("Критическая ошибка при запросе связанных ОКС:", error);
        return [];
    }
}



function isBboxInsidePolygon(bbox, polygonFeature) {
    try {
        if (!bbox || !polygonFeature || !polygonFeature.geometry || !polygonFeature.geometry.coordinates) {
            return false;
        }
        
        const bboxPolygon = turf.bboxPolygon([bbox[0][1], bbox[0][0], bbox[1][1], bbox[1][0]]);

        let containerPolygon;
        if (polygonFeature.geometry.type === 'Polygon') {
            // Проверяем, что в координатах есть данные, чтобы избежать ошибки turf
            if (!polygonFeature.geometry.coordinates || polygonFeature.geometry.coordinates.length === 0) {
                return false;
            }
            containerPolygon = turf.polygon(polygonFeature.geometry.coordinates);
        } else if (polygonFeature.geometry.type === 'MultiPolygon') {
            for (const coords of polygonFeature.geometry.coordinates) {
                // Проверяем каждый полигон в мультиполигоне
                if (coords && coords.length > 0) {
                    const singlePolygon = turf.polygon(coords);
                    if (turf.booleanWithin(bboxPolygon, singlePolygon)) {
                        return true;
                    }
                }
            }
            return false;
        } else {
            return false;
        }
        
        return turf.booleanWithin(bboxPolygon, containerPolygon);
    } catch (error) {
        console.error("Критическая ошибка в функции isBboxInsidePolygon:", error);
        return false;
    }
}

// ЗАМЕНИТЕ ЭТУ ФУНКЦИЮ ПОЛНОСТЬЮ
async function generateConsolidatedReport(lat, lon) {
    showLoader("Формирование отчета...");
    const delay = ms => new Promise(res => setTimeout(res, ms));

    try {
        const targetPolygon = findPolygonAtPoint(lat, lon);
        
        const isRealObject = targetPolygon && (targetPolygon.properties.get('isParcelInQuarter') || targetPolygon.properties.get('isFoundInArea') || targetPolygon.properties.get('isParcelFromSingleSearch'));
        const isManualObject = targetPolygon && targetPolygon.properties.get('isManuallyDrawn');

        if (!isRealObject && !isManualObject) {
            throw new Error('Для формирования отчета необходимо выбрать существующий или образованный земельный участок');
        }

        let mainObjectData;
        let underlyingParcelsResults = [];
        let linkedOksResults = [];

        if (isRealObject) {
            const featureData = targetPolygon.properties.get('featureData');
            if (!featureData) throw new Error('Не удалось получить исходные данные из выбранного объекта.');
            
            const opts = featureData.properties.options || {};
            mainObjectData = {
                cadastralNumber: featureData.properties.descr,
                address: opts.readable_address,
                areaText: getAreaText(opts),
                category: opts.land_record_category_type,
                vri: opts.permitted_use_established_by_document,
                cost: parseFloat(opts.cost_value),
                ownershipType: opts.ownership_type,
                rightType: opts.right_type
            };
            linkedOksResults = await fetchLinkedOks(mainObjectData.cadastralNumber);
        } else { // isManualObject
            const coords = targetPolygon.geometry.getCoordinates()[0];
            const turfPoly = turf.polygon([coords.map(c => [c[1], c[0]])]);
            const areaInMeters = turf.area(turfPoly);
            mainObjectData = {
                cadastralNumber: 'Образованный (нарисованный) объект',
                address: 'Координаты указаны вручную',
                areaText: `${Math.round(areaInMeters).toLocaleString('ru-RU')} м²`,
            };
            underlyingParcelsResults = await searchFeaturesByGeometry(targetPolygon, 36368);
            await delay(100);
        }

        const bounds = targetPolygon.geometry.getBounds();
        if (!bounds) throw new Error('Не удалось определить границы объекта для поиска.');
        
        const centerLat = (bounds[0][0] + bounds[1][0]) / 2;
        const centerLon = (bounds[0][1] + bounds[1][1]) / 2;

        const oksResults = await searchFeaturesByGeometry(targetPolygon, 36369);
        await delay(100);
        const structuresResults = await searchFeaturesByGeometry(targetPolygon, 36383);
        await delay(100);
        const zouitResults = await searchFeaturesByGeometry(targetPolygon, 36940);
        await delay(100);
        
        const terrZoneResults = await searchContainingObjectByPoint(centerLat, centerLon, 36315, targetPolygon);
        await delay(100);
        const settlementsResults = await searchContainingObjectByPoint(centerLat, centerLon, 36281, targetPolygon);
        await delay(100);
        const municipalResults = await searchContainingObjectByPoint(centerLat, centerLon, 36278, targetPolygon);
        await delay(100);
        const forestryResults = await searchContainingObjectByPoint(centerLat, centerLon, 36314, targetPolygon);
        
        // --- ЛОГИКА ДЛЯ ДВУХ ВЕРСИЙ СХЕМ ---

        // Собираем объекты для схем
        const mainSchemeOtherObjects = [];
        oksResults.forEach(f => { const p = createTemporaryYmapsPolygon(f); if(p) mainSchemeOtherObjects.push(p); });
        structuresResults.forEach(f => { const p = createTemporaryYmapsPolygon(f); if(p) mainSchemeOtherObjects.push(p); });

        // Генерируем ОСНОВНУЮ схему С ТОЧКАМИ (она же сгенерирует полную таблицу координат)
        const { image: mainSchemeWithPoints, coordsTable } = await drawAllObjectsToCanvas(targetPolygon, mainSchemeOtherObjects, true);
        // Генерируем ОСНОВНУЮ схему БЕЗ ТОЧЕК
        const { image: mainSchemeWithoutPoints } = await drawAllObjectsToCanvas(targetPolygon, mainSchemeOtherObjects, false);

        let parcelsSchemeWithPoints = null;
        let parcelsSchemeWithoutPoints = null;
        if (underlyingParcelsResults.length > 0) {
            const intersectingParcelPolygons = underlyingParcelsResults.map(f => createTemporaryYmapsPolygon(f)).filter(Boolean);
            // Генерируем схему пересечений С ТОЧКАМИ
            const { image: imageParcelsWithPoints } = await drawAllObjectsToCanvas(targetPolygon, intersectingParcelPolygons, true, underlyingParcelsResults);
            parcelsSchemeWithPoints = imageParcelsWithPoints;
            // Генерируем схему пересечений БЕЗ ТОЧЕК
            const { image: imageParcelsWithoutPoints } = await drawAllObjectsToCanvas(targetPolygon, intersectingParcelPolygons, false, underlyingParcelsResults);
            parcelsSchemeWithoutPoints = imageParcelsWithoutPoints;
        }
        
        const reportHtml = buildReportHtml(
            mainObjectData, linkedOksResults, oksResults, structuresResults, zouitResults, 
            underlyingParcelsResults, terrZoneResults, settlementsResults, municipalResults, forestryResults,
            mainSchemeWithPoints, mainSchemeWithoutPoints, 
            parcelsSchemeWithPoints, parcelsSchemeWithoutPoints, 
            coordsTable
        );
        
        const reportWindow = window.open('', '_blank');
        if (reportWindow) {
            reportWindow.document.write(reportHtml);
            reportWindow.document.close();
        } else {
            throw new Error('Не удалось открыть новое окно. Возможно, оно заблокировано браузером.');
        }

    } catch (error) {
        console.error("Ошибка при формировании сводного отчета:", error);
        showNotification(error.message, 'error', 'exclamation-circle', 5000);
    } finally {
        hideLoader();
    }
}


async function searchContainingObjectByPoint(latitude, longitude, layerId, targetPolygon = null) {
    try {
        const centerPoint = toEPSG3857(latitude, longitude);
        const centerX = centerPoint.x;
        const centerY = centerPoint.y;
        
        const halfSize = 10;
        const width = 512;
        const height = 512;
        const i = 256;
        const j = 256;

        const bbox = `${centerX - halfSize},${centerY - halfSize},${centerX + halfSize},${centerY + halfSize}`;
        const url = `https://nspd.gov.ru/api/aeggis/v4/${layerId}/wms?REQUEST=GetFeatureInfo&QUERY_LAYERS=${layerId}&SERVICE=WMS&VERSION=1.3.0&FORMAT=image%2Fpng%2F&STYLES=&TRANSPARENT=true&LAYERS=${layerId}&INFO_FORMAT=application%2Fjson&FEATURE_COUNT=10&I=${i}&J=${j}&WIDTH=${width}&HEIGHT=${height}&CRS=EPSG%3A3857&BBOX=${bbox}`;

        const response = await fetchNspd(url);
        if (!response.ok) {
            console.error(`Ошибка точечного запроса для слоя ${layerId}: ${response.status}`);
            return { features: [], isContained: false };
        }
        const data = await response.json();
        const features = data.features || [];
        
        let isContained = false;

        if (targetPolygon && features.length > 0) {
            const targetBbox = targetPolygon.geometry.getBounds();
            
            for (const feature of features) {
                const serverFeatureWGS84 = { ...feature };
                
                if (serverFeatureWGS84.geometry && serverFeatureWGS84.geometry.coordinates) {
                    try {
                        const convertedCoords = serverFeatureWGS84.geometry.coordinates.map(polygon =>
                            polygon.map(ring =>
                                ring.map(coord => {
                                    if (Array.isArray(coord) && coord.length === 2 && isFinite(coord[0]) && isFinite(coord[1])) {
                                        return proj4('EPSG:3857', 'EPSG:4326', coord);
                                    }
                                    return null;
                                }).filter(Boolean)
                            ).filter(ring => ring.length > 0)
                        ).filter(polygon => polygon.length > 0);

                        serverFeatureWGS84.geometry.coordinates = convertedCoords;

                        if (isBboxInsidePolygon(targetBbox, serverFeatureWGS84)) {
                            isContained = true;
                            break; 
                        }
                    } catch (conversionError) {
                        console.error(`Ошибка при конвертации геометрии для слоя ${layerId} (ID: ${feature.id}):`, conversionError);
                    }
                }
            }
        }
        
        return { features: features, isContained: isContained };
    } catch (error) {
        console.error(`Критическая ошибка при точечном запросе для слоя ${layerId}:`, error);
        return { features: [], isContained: false };
    }
}

function applyOwnershipFilter() {
    // Эта проверка важна, чтобы фильтр не работал, когда тема "Собственность" неактивна
    if (currentTheme !== 'ownership') {
        // Очищаем временные метки, если они остались от предыдущего использования темы
        if (ownershipFilterPlacemarks.size > 0) {
            ownershipFilterPlacemarks.forEach(placemark => {
                if (map?.geoObjects.indexOf(placemark) !== -1) map.geoObjects.remove(placemark);
            });
            ownershipFilterPlacemarks.clear();
        }
        // Убедимся, что все полигоны видимы, когда тема отключается
        polygons.forEach(obj => {
             if (obj instanceof ymaps.Polygon) obj.options.set('visible', true);
        });
        return;
    }

    console.log(`Применение фильтра Собственности. Состояние: ${ownershipFilterState}, Выбрано: ${selectedOwnershipFromLegend}`);

    // Проходим по всем полигонам на карте
    polygons.forEach(obj => {
        if (obj instanceof ymaps.Polygon && (obj.properties?.get('isParcelInQuarter') || obj.properties?.get('isFoundInArea'))) {
            // Получаем ключ собственности для текущего полигона
            const options = obj.properties.get('featureData')?.properties?.options || {};
            const ownership = options.ownership_type || 'Не указано';
            const rightType = options.right_type || 'Не указано';
            const parcelKey = `${ownership}|${rightType}`;

            // Задаем значения по умолчанию
            let fillColor = '#00000000'; // Прозрачная заливка
            let isVisible = true;        // Видимость

            // Применяем логику в зависимости от состояния клика
            switch (ownershipFilterState) {
                // Состояние 0: Показать все участки с их тематической заливкой
                case 0:
                    isVisible = true;
                    if (ownershipColorMap.has(parcelKey)) {
                        fillColor = `${ownershipColorMap.get(parcelKey)}E6`; // 90% непрозрачности
                    }
                    break;

                // Состояние 1: Отфильтрованные с заливкой, остальные - только контур (НОВАЯ ЛОГИКА)
                case 1:
                    isVisible = true; // Все участки видимы
                    if (parcelKey === selectedOwnershipFromLegend) {
                        // Если участок соответствует фильтру, заливаем его
                        if (ownershipColorMap.has(parcelKey)) {
                            fillColor = `${ownershipColorMap.get(parcelKey)}E6`;
                        }
                    } else {
                        // Если не соответствует - оставляем прозрачным (только контур)
                        fillColor = '#00000000';
                    }
                    break;

                // Состояние 2: Отфильтрованные без заливки, остальные - скрыты
                case 2:
                    if (parcelKey === selectedOwnershipFromLegend) {
                        isVisible = true;
                        fillColor = '#00000000'; // Прозрачная заливка
                    } else {
                        isVisible = false; // Скрываем остальные участки
                    }
                    break;
            }

            // Применяем рассчитанные стили к полигону
            obj.options.set('fillColor', fillColor);
            obj.options.set('visible', isVisible);
        }
    });

    // После применения стилей обновляем видимость меток, так как некоторые полигоны могли быть скрыты
    updatePlacemarksVisibility();
}
  
 
        
function showSelectionModal(candidateNumbers) {
    // Создаем модальное окно
    const modal = document.createElement('div');
    modal.style.position = 'fixed';
    modal.style.top = '50%';
    modal.style.left = '50%';
    modal.style.transform = 'translate(-50%, -50%)';
    modal.style.backgroundColor = 'rgba(255, 255, 255, 0.9)';
    modal.style.padding = '20px';
    modal.style.borderRadius = '10px';
    modal.style.boxShadow = '0 4px 8px rgba(0, 0, 0, 0.2)';
    modal.style.zIndex = '10000';
    modal.style.display = 'flex';
    modal.style.flexDirection = 'column';
    modal.style.alignItems = 'center';
    modal.style.maxHeight = '80vh';
    modal.style.overflowY = 'auto';




    // Контейнер для кнопок
    const buttonContainer = document.createElement('div');
    buttonContainer.style.display = 'flex';
    buttonContainer.style.flexDirection = 'column';
    buttonContainer.style.gap = '10px';

    // Создаем кнопки для каждого кандидата
    candidateNumbers.forEach((number, index) => {
        const button = document.createElement('button');
        button.textContent = number;
        button.style.padding = '10px 20px';
        button.style.border = 'none';
        button.style.borderRadius = '5px';
        button.style.backgroundColor = '#4a90e2';
        button.style.color = 'white';
        button.style.cursor = 'pointer';
        button.style.transition = 'background-color 0.3s';
        button.style.textAlign = 'left';
        button.style.width = '300px';
        button.style.whiteSpace = 'normal';
        button.style.wordBreak = 'break-word';

        button.addEventListener('click', () => {
            navigator.clipboard.writeText(number).then(() => {
     //          showNotification(`Скопирован: ${number}`, 'success', 'check-circle');
            }).catch(err => {
                showNotification('Ошибка при копировании', 'error', 'exclamation-circle');
            });
            document.body.removeChild(modal); // Закрываем модальное окно
        });

        button.addEventListener('mouseenter', () => {
            button.style.backgroundColor = '#357abd';
        });

        button.addEventListener('mouseleave', () => {
            button.style.backgroundColor = '#4a90e2';
        });

        buttonContainer.appendChild(button);
    });

    // Кнопка закрытия
    const closeButton = document.createElement('button');
    closeButton.textContent = 'Закрыть';
    closeButton.style.padding = '10px 20px';
    closeButton.style.marginTop = '15px';
    closeButton.style.border = 'none';
    closeButton.style.borderRadius = '5px';
    closeButton.style.backgroundColor = '#e74c3c';
    closeButton.style.color = 'white';
    closeButton.style.cursor = 'pointer';
    closeButton.style.transition = 'background-color 0.3s';

    closeButton.addEventListener('click', () => {
        document.body.removeChild(modal);
    });

    closeButton.addEventListener('mouseenter', () => {
        closeButton.style.backgroundColor = '#c0392b';
    });

    closeButton.addEventListener('mouseleave', () => {
        closeButton.style.backgroundColor = '#e74c3c';
    });

    modal.appendChild(buttonContainer);
    modal.appendChild(closeButton);
    document.body.appendChild(modal);

    // Закрытие модального окна при клике вне его
    modal.addEventListener('click', (e) => {
        if (e.target === modal) {
            document.body.removeChild(modal);
        }
    });
}



async function findParcelInArchive(targetCadastralNumber) {
    const loaderText = document.querySelector('.loading-text');
    
    try {
        const quarterNumber = targetCadastralNumber.split(':').slice(0, 3).join(':');
        const filename = quarterNumber.replace(/:/g, '_') + '.nspd';

        if (loaderText) loaderText.textContent = `Загрузка архива ${quarterNumber}...`;

        const zipBlob = await fetchZipFromLocalServer('nspd', filename);
        if (!zipBlob) {
            showNotification(`Архив для квартала ${quarterNumber} не найден.`, 'error');
            return;
        }

        if (loaderText) loaderText.textContent = `Распаковка данных...`;
        
        const { features, date: archiveDate } = await loadAndParseZipBlob(zipBlob);
        const targetFeature = features.find(f => f.properties && f.properties.descr === targetCadastralNumber);

        if (!targetFeature) {
            showNotification(`Участок ${targetCadastralNumber} не найден в архиве.`, 'error');
            return;
        }

        clearMapAndResetTheme();
        
        // --- НАЧАЛО БЛОКА ИЗМЕНЕНИЙ ---
        // 1. Отрисовываем участок и получаем ссылку на созданные объекты Я.Карт
        const drawnObjects = await processAndDrawParcels([targetFeature], 'quarter');
        
        // 2. Ищем среди отрисованных объектов именно полигон
        const targetPolygon = drawnObjects.find(obj => obj instanceof ymaps.Polygon);
        
        // 3. Если полигон найден, устанавливаем границы карты по нему
        if (targetPolygon) {
            const bounds = targetPolygon.geometry.getBounds();
            
            // Проверяем, что границы корректны
            if (bounds && bounds[0] && bounds[1]) {
                // Добавляем небольшой отступ (padding) для лучшего вида
                const latPadding = (bounds[1][0] - bounds[0][0]) * 0.15 || 0.0005;
                const lonPadding = (bounds[1][1] - bounds[0][1]) * 0.15 || 0.0005;

                const paddedBounds = [
                    [bounds[0][0] - latPadding, bounds[0][1] - lonPadding],
                    [bounds[1][0] + latPadding, bounds[1][1] + lonPadding]
                ];
                
                map.setBounds(paddedBounds, {
                    checkZoomRange: true, // Убедимся, что зум не выходит за пределы min/max
                    duration: 500 // Плавная анимация приближения
                });
            }
        }
        // --- КОНЕЦ БЛОКА ИЗМЕНЕНИЙ ---
        
        let formattedDate = '';
        if (archiveDate) {
            const [year, month, day] = archiveDate.split('-');
            formattedDate = `${day}.${month}.${year}`;
        }
        
        document.getElementById('city-name-display').innerHTML = `Архив (${formattedDate}):<br>${targetCadastralNumber}`;
        
        showNotification(`Основной сервис недоступен. Участок ${targetCadastralNumber} загружен из архива от ${formattedDate}`, 'success');
        
        addToHistory(targetCadastralNumber);

    } catch (error) {
        console.error("Ошибка при поиске в архиве:", error);
        showNotification(`Ошибка при работе с архивом: ${error.message}`, 'error');
    }
}


// Функция для получения и отрисовки кадастрового квартала
async function getQuarterCadastre(lat, lon) {
    try {
        // Функция для попытки получения данных о квартале по координатам
        async function tryGetQuarterData(latitude, longitude) {
            const cadastralData = await queryCadastralInfo(latitude, longitude);
            if (!cadastralData || !cadastralData.features || cadastralData.features.length === 0) {
                return null;
            }
            
            const feature = cadastralData.features[0];
            const cadastralNumber = feature.properties.descr;
            if (!cadastralNumber || cadastralNumber.split(':').length < 3) { // Added check for valid CN
                 return null;
            }
            const quarterNumber = cadastralNumber.split(':').slice(0, 3).join(':');
            
            const url = `https://nspd.gov.ru/api/geoportal/v2/search/geoportal?thematicSearchId=2&query=${quarterNumber}`;
           const response = await fetchNspd(url);
            if (!response.ok) return null; // Added check for response.ok
            const quarterData = await response.json();
            
            if (!quarterData || !quarterData.data || !quarterData.data.features || quarterData.data.features.length === 0) {
                return null;
            }
            
            return quarterData.data.features[0];
        }

        // Первая попытка с исходными координатами
        let quarterFeature = await tryGetQuarterData(lat, lon);
        let found = !!quarterFeature;
        let attempts = 0;
        const maxAttempts = 10;
        const stepMeters = 10; // Шаг в метрах
        const squareWidthMeters = 50; // Ширина квадрата в метрах
        const timeoutMs = 100; // Таймаут 0.1 секунды

        // Если данные не найдены, начинаем рандомный поиск
        if (!found) {
            const earthRadius = 6378137; // Радиус Земли в метрах
            const latRadians = lat * Math.PI / 180;
            // const metersToLat = stepMeters / earthRadius * (180 / Math.PI); // Not used directly in random offset
            // const metersToLon = stepMeters / (earthRadius * Math.cos(latRadians)) * (180 / Math.PI); // Not used
            const squareWidthLat = squareWidthMeters / earthRadius * (180 / Math.PI);
            const squareWidthLon = squareWidthMeters / (earthRadius * Math.cos(latRadians)) * (180 / Math.PI);

            while (!found && attempts < maxAttempts) {
                attempts++;
                // Генерируем случайное смещение в пределах квадрата 50x50 м
                const offsetLat = (Math.random() - 0.5) * squareWidthLat;
                const offsetLon = (Math.random() - 0.5) * squareWidthLon;
                const newLat = lat + offsetLat;
                const newLon = lon + offsetLon;

                console.log(`Поиск квартала ${attempts}: lat=${newLat.toFixed(6)}, lon=${newLon.toFixed(6)}`);
                
                quarterFeature = await tryGetQuarterData(newLat, newLon);
                found = !!quarterFeature;

                if (!found && attempts < maxAttempts) {
                    await new Promise(resolve => setTimeout(resolve, timeoutMs));
                }
            }
        }

        // Если данные так и не найдены
        if (!found) {
            showNotification('Кадастровый квартал не найден', 'error', 'exclamation-circle');
            return;
        }

        // Отрисовка квартала
        if (quarterFeature.geometry && quarterFeature.geometry.coordinates) {
            const coordinates = quarterFeature.geometry.coordinates[0].map(coord => {
                const point = proj4('EPSG:3857', 'EPSG:4326', coord);
                return [point[1], point[0]]; // [lat, lon]
            });

            const offsetCoordinates = coordinates.map(coord => [
                coord[0] - mapOffsetY * 0.000008983,
                coord[1] - mapOffsetX * 0.000008983
            ]);

            const polygon = new ymaps.Polygon([offsetCoordinates], {}, {
                strokeColor: '#FF0000',
                strokeWidth: polygonStyle.width,
                strokeOpacity: 0.8,
                fillColor: '#00000000',
                hintEnabled: false,
                hasBalloon: false,
                interactivityModel: 'default#transparent'
            });

            map.geoObjects.add(polygon);
            polygons.push(polygon);

            const bounds = polygon.geometry.getBounds();
            const centerGeo = [
                (bounds[0][0] + bounds[1][0]) / 2,
                (bounds[0][1] + bounds[1][1]) / 2
            ];

            getAddressByCoords(centerGeo).then(address => {
                document.getElementById('city-name-display').innerHTML = address;
            });

            const center3857 = proj4("EPSG:4326", "EPSG:3857", [centerGeo[1], centerGeo[0]]);

            lastPolygonCenter = {
                geo: {
                    lat: centerGeo[0],
                    lon: centerGeo[1]
                },
                epsg3857: {
                    x: center3857[0],
                    y: center3857[1]
                },
                native: {
                    x: quarterFeature.geometry.coordinates[0][0][0],
                    y: quarterFeature.geometry.coordinates[0][0][1]
                }
            };

            // << MODIFICATION: Update currentQuarterNumber >>
            if (quarterFeature.properties && quarterFeature.properties.descr) {
                currentQuarterNumber = quarterFeature.properties.descr;
                console.log(`Current quarter updated by getQuarterCadastre: ${currentQuarterNumber}`);
            }
            // << END MODIFICATION >>

            const quarterText = new ymaps.Placemark([
                centerGeo[0] - mapOffsetY * 0.000008983,
                centerGeo[1] - mapOffsetX * 0.000008983
            ], {
                iconContent: quarterFeature.properties.descr
            }, {
                preset: 'islands#redStretchyIcon'
            });

            map.geoObjects.add(quarterText);
            polygons.push(quarterText);

            let combinedBoundsInternal = null; // Use a different name to avoid conflict with outer scope
            polygons.forEach(obj => {
                const objBounds = obj.geometry.getBounds();
                if (!combinedBoundsInternal) {
                    combinedBoundsInternal = objBounds;
                } else {
                    combinedBoundsInternal[0][0] = Math.min(combinedBoundsInternal[0][0], objBounds[0][0]);
                    combinedBoundsInternal[0][1] = Math.min(combinedBoundsInternal[0][1], objBounds[0][1]);
                    combinedBoundsInternal[1][0] = Math.max(combinedBoundsInternal[1][0], objBounds[1][0]);
                    combinedBoundsInternal[1][1] = Math.max(combinedBoundsInternal[1][1], objBounds[1][1]);
                }
            });

            if (combinedBoundsInternal) {
                map.setBounds(combinedBoundsInternal, {
                    checkZoomRange: true,
                    duration: 200
                });
            }

            showNotification(`Квартал ${quarterFeature.properties.descr}`, 'success', 'check-circle');
        }
    } catch (error) {
        console.error('Ошибка при получении квартала:', error);
        showNotification('Ошибка подключения, попробуйте позже', 'error', 'exclamation-circle');
    }
}

function measureArea() {
    // Если измерение активно, завершаем и очищаем только объекты измерения
    if (areaMeasurementActive) {
        stopAreaMeasurement();
        clearAreaMeasurement();
        return;
    }

    // Очищаем только объекты измерения перед началом нового
    clearAreaMeasurement();

    // --- ИЗМЕНЕНИЕ: Делаем полигоны полностью "глухими" к событиям ---
    map.geoObjects.each(function(geoObject) {
        if (geoObject instanceof ymaps.Polygon) {
            // Сохраняем текущую модель интерактивности
            geoObject.originalInteractivity = geoObject.options.get('interactivityModel', 'default#geoObject');
            // Устанавливаем модель 'silent', чтобы все клики проходили сквозь полигон на карту
            geoObject.options.set('interactivityModel', 'default#silent');
        }
    });
    // --- КОНЕЦ ИЗМЕНЕНИЯ ---

    // Активируем режим измерения
    areaMeasurementActive = true;
    areaPoints = [];
    mapElement.classList.add('measuring-area');
    map.events.add('click', onMapClickForArea);
    map.events.add('dblclick', onMapDoubleClickForArea);
}

function stopAreaMeasurement() {
    areaMeasurementActive = false;
    mapElement.classList.remove('measuring-area');
    map.events.remove('click', onMapClickForArea);
    map.events.remove('dblclick', onMapDoubleClickForArea);

    // --- ИЗМЕНЕНИЕ: Восстанавливаем интерактивность ---
    map.geoObjects.each(function(geoObject) {
        // Проверяем, что это полигон и что мы сохраняли его предыдущее состояние
        if (geoObject instanceof ymaps.Polygon && geoObject.originalInteractivity) {
            // Восстанавливаем сохраненную модель интерактивности
            geoObject.options.set('interactivityModel', geoObject.originalInteractivity);
            // Удаляем временное свойство
            delete geoObject.originalInteractivity;
        }
    });
    // --- КОНЕЦ ИЗМЕНЕНИЯ ---
}
function onMapClickForArea(e) {
    const coords = e.get('coords');
    areaPoints.push(coords);

    const placemark = new ymaps.Placemark(coords, {}, {
        preset: 'islands#smallBlueDotIcon' // Маленькая синяя точка
    });
    map.geoObjects.add(placemark);
    areaObjects.push(placemark); // Добавляем в areaObjects вместо polygons

    if (areaPoints.length >= 3) {
        updateAreaPolygon();
        calculateAndDisplayArea(); // Вызываем расчет и отображение метки
    } else {
        updateAreaPolygon(); // Обновляем полигон, если точек меньше 3
    }
}

function onMapDoubleClickForArea(e) {
    e.preventDefault();
    stopAreaMeasurement();
    calculateAndDisplayArea();
}

function updateAreaPolygon() {
    if (areaPolygon) {
        map.geoObjects.remove(areaPolygon);
        areaObjects = areaObjects.filter(obj => obj !== areaPolygon);
    }

    if (areaPoints.length > 2) {
        areaPolygon = new ymaps.Polygon([areaPoints], {}, {
            strokeColor: '#0000FF',
            strokeWidth: 3,
            strokeOpacity: 0.8,
            fillColor: '#00000000', // Заливка отключена по умолчанию
            hintEnabled: false,
            hasBalloon: false,
            interactivityModel: 'default#transparent'
        });
        map.geoObjects.add(areaPolygon);
        areaObjects.push(areaPolygon);
    }
}

function calculateAndDisplayArea() {
    if (areaPoints.length < 3) {
        return; // Ничего не делаем, если меньше 3 точек
    }

    // Ensure the polygon is closed temporarily for calculation
    let closedAreaPoints = areaPoints.slice();
    if (closedAreaPoints[0][0] !== closedAreaPoints[closedAreaPoints.length - 1][0] ||
        closedAreaPoints[0][1] !== closedAreaPoints[closedAreaPoints.length - 1][1]) {
        closedAreaPoints.push(closedAreaPoints[0]);
    }

    // Calculate area with Turf.js
    const turfPolygon = turf.polygon([closedAreaPoints.map(point => [point[1], point[0]])]);
    const areaInMeters = turf.area(turfPolygon);
    const roundedArea = Math.round(areaInMeters);
    const formattedArea = roundedArea.toLocaleString('ru-RU') + ' м²';

    // Calculate perimeter with Turf.js
    const perimeterInMeters = turf.length(turfPolygon, { units: 'meters' });
    const roundedPerimeter = Math.round(perimeterInMeters);
    const formattedPerimeter = roundedPerimeter.toLocaleString('ru-RU') + ' м';

    // Remove previous area label if it exists
    if (areaLabel) {
        map.geoObjects.remove(areaLabel);
        areaObjects = areaObjects.filter(obj => obj !== areaLabel);
    }

    // Calculate centroid with Turf.js
    const centroidFeature = turf.centroid(turfPolygon);
    const centroid = [centroidFeature.geometry.coordinates[1], centroidFeature.geometry.coordinates[0]];

    // Add new label with area and perimeter
    const labelContent = `Площадь: ${formattedArea}     Периметр: ${formattedPerimeter}`;
    areaLabel = new ymaps.Placemark(centroid, {
        iconContent: labelContent,
        balloonContent: labelContent
    }, {
        preset: 'islands#blueStretchyIcon'
    });
    map.geoObjects.add(areaLabel);
    areaObjects.push(areaLabel); // Добавляем в areaObjects

    // Уведомление показываем только при завершении (двойной клик), поэтому убираем его отсюда
}

function stopAreaMeasurement() {
    areaMeasurementActive = false;
    mapElement.classList.remove('measuring-area');
    map.events.remove('click', onMapClickForArea);
    map.events.remove('dblclick', onMapDoubleClickForArea);
}


function clearAreaMeasurement() {
    if (areaObjects.length > 0) {
        allAreaMeasurements.push([...areaObjects]); // Сохраняем текущее измерение
    }
    areaObjects.forEach(obj => map.geoObjects.remove(obj));
    areaObjects = [];
    areaPoints = [];
    areaPolygon = null;
    areaLabel = null;
}


document.addEventListener('keydown', async function (e) {
    // --- Обработка Delete ---
    if (e.key === 'Delete') {
        let deleted = false;

        // 1. Приоритет: Удаление активного перетаскиваемого текста
        if (activeDraggableText) {
            activeDraggableText.remove();
            draggableTexts = draggableTexts.filter(text => text !== activeDraggableText);
            activeDraggableText = null;
            deleted = true;
            // console.log("Deleted activeDraggableText"); // Для отладки
        }
        // 2. Если текст не выбран, удаляем выделенную линию
        else if (selectedLine) {
            map.geoObjects.remove(selectedLine);
            polygons = polygons.filter(p => p !== selectedLine); // Удаляем из основного массива
            selectedLine = null; // Сбрасываем выбор
            deleted = true;
            // console.log("Deleted selectedLine"); // Для отладки
        }
        // 3. Если линия не выбрана, удаляем выделенную метку (Placemark)
        else if (selectedPlacemark) {
            map.geoObjects.remove(selectedPlacemark);
            // Удаляем объект из массива polygons, если он там есть
            polygons = polygons.filter(p => p !== selectedPlacemark);
            // Удаляем из areaObjects, если объект был частью измерения площади
            areaObjects = areaObjects.filter(obj => obj !== selectedPlacemark);
            selectedPlacemark = null;
            deleted = true;
            // console.log("Deleted selectedPlacemark"); // Для отладки
        }

        // Показываем уведомление, если что-то удалили (опционально)
        // if (deleted) {
        //     showNotification('Объект удален', 'success', 'check-circle');
        // }
    }


   // F7: Export Data
    if (e.key === 'F7') {
        e.preventDefault();
        exportParcelDataToExcelZip(); // Use a new function for export
    }

    // F8: Import Data
  if (e.key === 'F8') {
        e.preventDefault();
        await triggerSupabaseImport(); // Call the new function
    }
    
       if (e.key === 'F10') {
        e.preventDefault(); // Предотвращаем стандартное действие F10 (фокус на меню браузера)
        takeScreenshot();
    }
    
    // --- Обработка F9 (показ/скрытие полей координат) ---
    if (e.key === 'F9') { // Используем e.key вместо event.key
        e.preventDefault();
        coordsInput.style.display = coordsInput.style.display === 'block' ? 'none' : 'block';
        convertedTextarea.style.display = convertedTextarea.style.display === 'block' ? 'none' : 'block';
        geoTextarea.style.display = geoTextarea.style.display === 'block' ? 'none' : 'block';
    }

    // --- Обработка Escape ---
    if (e.key === 'Escape') {
        // Остановка измерения площади
        if (areaMeasurementActive) {
            stopAreaMeasurement();
            clearAreaMeasurement(); // Очищаем текущее измерение при Escape
        }
        // Остановка рисования линии
        if (lineDrawingActive) {
             stopLineDrawing();
             // Решаем, нужно ли удалять нарисованное по Escape
             if (currentLine) { // Если линия была частично нарисована
                 map.geoObjects.remove(currentLine);
                 polygons = polygons.filter(p => p !== currentLine);
                 currentLine = null; // Сбрасываем
             }
             // Также удаляем точки, добавленные для линии
              linePoints.forEach(coord => {
                 // Найдем и удалим маркеры точек, если они добавлялись
                 // (в текущей версии они не добавляются, но оставим логику на будущее)
                 // const markerToRemove = polygons.find(p => p instanceof ymaps.Placemark && p.geometry.getCoordinates()[0] === coord[0] && p.geometry.getCoordinates()[1] === coord[1]);
                 // if (markerToRemove) {
                 //     map.geoObjects.remove(markerToRemove);
                 //     polygons = polygons.filter(p => p !== markerToRemove);
                 // }
              });
             linePoints = []; // Очищаем точки
        }
        // Остановка измерения расстояния (если нужно добавить)
        // if (distanceMeasurementActive) {
        //     stopDistanceMeasurement();
        //     clearDistanceMeasurement(); // Или просто остановить без очистки
        // }
        // Скрытие лоадера
        document.getElementById('loaderContainer').style.display = 'none';
        // Скрытие модального окна истории (если оно открыто)
        if (historyModal.style.display === 'block') {
            historyModal.style.display = 'none';
        }
        // Снятие выделения с линии
         if (selectedLine) {
             if (selectedLine.originalStyle) {
                 selectedLine.options.set({
                     strokeColor: selectedLine.originalStyle.strokeColor,
                     strokeWidth: selectedLine.originalStyle.strokeWidth
                 });
             }
             selectedLine = null;
         }
         // Снятие выделения с метки
         if (selectedPlacemark) {
             // Добавить логику сброса стиля метки, если она есть
             selectedPlacemark = null;
         }
    }

    // --- НАЧАЛО ИЗМЕНЕНИЙ: ПРОВЕРКА АКТИВНОГО ЭЛЕМЕНТА ---
    const activeElement = document.activeElement;
    const isInputActive = activeElement && (activeElement.tagName === 'INPUT' || activeElement.tagName === 'TEXTAREA');
    // --- КОНЕЦ ИЗМЕНЕНИЙ ---

    // --- Зумирование карты (+/-) ---
    if (!isInputActive && (e.key === '+' || e.key === '=')) {
        e.preventDefault();
        if (map) map.setZoom(map.getZoom() + 1);
    }
    if (!isInputActive && (e.key === '-' || e.key === '_')) {
        e.preventDefault();
        if (map) map.setZoom(map.getZoom() - 1);
    }

    // --- Перемещение карты (стрелки) ---
    if (!isInputActive && ['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.key)) {
        e.preventDefault();
        if (!map) return; // Проверка, что карта инициализирована

        const bounds = map.getBounds();
        const center = map.getCenter();

        // Проверка, что bounds и center корректны
        if (!bounds || !center || !bounds[0] || !bounds[1]) return;

        const latDiff = (bounds[1][0] - bounds[0][0]) * 0.05;
        const lonDiff = (bounds[1][1] - bounds[0][1]) * 0.05;

        let newLat = center[0];
        let newLon = center[1];

        switch (e.key) {
            case 'ArrowUp':    newLat += latDiff; break;
            case 'ArrowDown':  newLat -= latDiff; break;
            case 'ArrowLeft':  newLon -= lonDiff; break;
            case 'ArrowRight': newLon += lonDiff; break;
        }

        map.setCenter([newLat, newLon]);
    }
});



// Modify showFindOnMapDialog
// Modify showFindOnMapDialog
function showFindOnMapDialog() {
    const modal = document.createElement('div');
    modal.className = 'color-modal'; // Re-use existing class for base styling
    // Override or add styles for this specific dialog
    modal.style.width = '450px'; // Adjusted width
    modal.style.maxWidth = '95vw';
    modal.style.background = 'linear-gradient(135deg, #f8fafc, #eef2f7)'; // Softer background
    modal.style.border = '1px solid #e2e8f0';
    modal.style.boxShadow = '0 10px 25px -5px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05)'; // Softer shadow


    // Define colors
    const findButtonColor = '#4169E1'; // Royal Blue
    const findButtonHoverColor = '#3658c1'; // Darker Royal Blue
    const cancelButtonColor = '#FF69B4'; // Hot Pink
    const cancelButtonHoverColor = '#db4c98'; // Darker Pink

    modal.innerHTML = `
        <div class="color-modal-content" style="padding: 25px 30px; display: flex; flex-direction: column; align-items: center; gap: 20px;">
            <h3 style="margin-top: 0; margin-bottom: 5px; font-size: 1.5rem; color: #1e293b; text-align: center; font-weight: 600;">
                Найти наложения
            </h3>
         <textarea id="coords-search-input"
                 style="width: 100%; height: 140px; padding: 12px; border-radius: 8px; border: 1px solid #cbd5e1; font-family: monospace; resize: vertical; font-size: 0.9rem; box-shadow: inset 0 1px 2px rgba(0,0,0,0.05); background-color: #ffffff; text-align: center;"
                 placeholder="Координаты X Y

(погрешность ~ 1 см)
"
         ></textarea>
            <div style="display: flex; justify-content: center; gap: 15px; width: 100%; margin-top: 10px;">
                <button id="find-coords-btn" style="flex-grow: 1; max-width: 180px; display: flex; align-items: center; justify-content: center; gap: 8px; background-color: ${findButtonColor}; padding: 10px 15px; border-radius: 8px; border: none; color: white; font-weight: 500; cursor: pointer; transition: all 0.2s ease; box-shadow: 0 1px 3px rgba(0,0,0,0.1);">
                    <i class="fas fa-search" style="font-size: 0.9em;"></i>
                    <span>Найти</span>
                </button>
                <button id="cancel-coords-btn" style="flex-grow: 1; max-width: 180px; display: flex; align-items: center; justify-content: center; gap: 8px; background-color: ${cancelButtonColor}; padding: 10px 15px; border-radius: 8px; border: none; color: white; font-weight: 500; cursor: pointer; transition: all 0.2s ease; box-shadow: 0 1px 3px rgba(0,0,0,0.1);">
                    <i class="fas fa-times" style="font-size: 0.9em;"></i>
                    <span>Отмена</span>
                </button>
            </div>
        </div>
    `;

    document.body.appendChild(modal);
    modal.style.display = 'block';

    const coordsInput = document.getElementById('coords-search-input');
    const findBtn = document.getElementById('find-coords-btn');
    const cancelBtn = document.getElementById('cancel-coords-btn');

    // Add hover effects for the buttons
    [findBtn, cancelBtn].forEach(button => {
        // Common button styles on setup
        button.style.fontSize = '0.95rem'; // Ensure consistent font size

        button.addEventListener('mouseenter', () => {
            button.style.transform = 'translateY(-2px)';
            button.style.boxShadow = '0 4px 8px rgba(0,0,0,0.15)';
            if (button.id === 'find-coords-btn') {
                 button.style.backgroundColor = findButtonHoverColor;
            } else {
                button.style.backgroundColor = cancelButtonHoverColor;
            }
        });

        button.addEventListener('mouseleave', () => {
            button.style.transform = 'translateY(0)';
            button.style.boxShadow = '0 1px 3px rgba(0,0,0,0.1)';
             if (button.id === 'find-coords-btn') {
                 button.style.backgroundColor = findButtonColor;
            } else {
                button.style.backgroundColor = cancelButtonColor;
            }
        });
         button.addEventListener('mousedown', () => {
             button.style.transform = 'translateY(0px)'; // Press effect
             button.style.boxShadow = '0 1px 2px rgba(0,0,0,0.1)';
         });
         button.addEventListener('mouseup', () => {
              // Restore hover effect if mouse is still over
              if (button.matches(':hover')) {
                    button.style.transform = 'translateY(-2px)';
                    button.style.boxShadow = '0 4px 8px rgba(0,0,0,0.15)';
              } else {
                    button.style.transform = 'translateY(0)';
                    button.style.boxShadow = '0 1px 3px rgba(0,0,0,0.1)';
              }
         });
    });


    navigator.clipboard.readText().then(text => {
        if (text && text.trim() && /^[\d\s.,\-\t]+$/.test(text.trim())) {
            coordsInput.value = text.trim();
        }
    }).catch(err => {
        console.log('Не удалось прочитать буфер обмена:', err);
    });

    findBtn.addEventListener('click', () => {
        const inputText = coordsInput.value.trim();
        if (inputText) {
            findOnMap(inputText);
        } else {
            showNotification('Пожалуйста, введите координаты', 'warning', 'exclamation-triangle');
            return;
        }
        document.body.removeChild(modal);
    });

    cancelBtn.addEventListener('click', () => {
        document.body.removeChild(modal);
    });

    modal.addEventListener('click', (e) => {
        // Close only if clicking the modal background itself
        if (e.target === modal) {
            document.body.removeChild(modal);
        }
    });

    coordsInput.addEventListener('keydown', (e) => {
        if (e.key === 'Enter' && e.ctrlKey) {
            findBtn.click();
        }
    });

    coordsInput.focus();

    const escHandler = (e) => {
        if (e.key === 'Escape') {
            document.body.removeChild(modal);
            document.removeEventListener('keydown', escHandler);
        }
    };
    document.addEventListener('keydown', escHandler);
}



async function findOnMap(coordinatesText) {
    try {
        document.getElementById('loaderContainer').style.display = 'flex';
        document.querySelector('.loading-text').textContent = 'Анализ координат...';

        const coordGroups = parseCoordinates(coordinatesText);
        if (coordGroups.length === 0) {
            showNotification('Некорректный формат координат', 'error', 'exclamation-circle');
            document.getElementById('loaderContainer').style.display = 'none';
            return;
        }

        document.querySelector('.loading-text').textContent = 'Преобразование координат...';
        
        let geoCoordGroups;
        const firstCoord = coordGroups[0][0];
        const looksLikeMsk = Math.abs(firstCoord[0]) > 100000 || Math.abs(firstCoord[1]) > 100000;

        if (looksLikeMsk) {
            console.log("[Наложения] Обнаружены координаты, похожие на МСК. Применяется калибровка...");
            
            // --- НАЧАЛО ИЗМЕНЕНИЙ: Та же самая логика, что и выше ---
            const sourceSc = localStorage.getItem('savedDefaultMskSystem') || 'EPSG:6331602';
            const sourceSystem = COORDINATE_SYSTEMS.find(s => s.value === sourceSc);
            if (!sourceSystem) throw new Error(`Определение для ${sourceSc} не найдено в sk.js`);

            let mskOffsetX = 0;
            let mskOffsetY = 0;
            const isAutoLoadEnabled = (localStorage.getItem('autoLoadMskOffset') !== 'false');
            
            if (isAutoLoadEnabled) {
                mskOffsetX = sourceSystem.offsetX || 0;
                mskOffsetY = sourceSystem.offsetY || 0;
            } else {
                mskOffsetX = parseFloat((localStorage.getItem('savedMskOffsetX') || '0').replace(',', '.')) || 0;
                mskOffsetY = parseFloat((localStorage.getItem('savedMskOffsetY') || '0').replace(',', '.')) || 0;
            }
            console.log(`[Наложения] Используются смещения: X=${mskOffsetX}, Y=${mskOffsetY}`);
            // --- КОНЕЦ ИЗМЕНЕНИЙ ---
            
            const sourceDef = sourceSystem.def;
            proj4.defs(sourceSc, sourceDef);

            geoCoordGroups = coordGroups.map(group => {
                return group.map(coord => {
                    const x_input_msk = coord[0]; 
                    const y_input_msk = coord[1];
                    const corrected_x_msk = x_input_msk - mskOffsetX;
                    const corrected_y_msk = y_input_msk - mskOffsetY;
                    const point3857 = proj4(sourceSc, 'EPSG:3857', [corrected_y_msk, corrected_x_msk]);
                    const finalWgs84 = proj4('EPSG:3857', 'EPSG:4326', point3857);
                    return [finalWgs84[1], finalWgs84[0]]; 
                });
            });

        } else {
            console.log("[Наложения] Координаты не похожи на МСК. Используется стандартное определение.");
            geoCoordGroups = determineCoordinateSystemAndConvert(coordGroups);
        }

        if (geoCoordGroups.length === 0) {
            showNotification('Ошибка преобразования координат', 'error', 'exclamation-circle');
            document.getElementById('loaderContainer').style.display = 'none';
            return;
        }

        const searchShapes = drawSearchObject(geoCoordGroups);
        if (searchShapes.length === 0) {
             showNotification('Не удалось отрисовать объект поиска', 'error', 'exclamation-circle');
             document.getElementById('loaderContainer').style.display = 'none';
             return;
        }

        document.querySelector('.loading-text').textContent = 'Подготовка области поиска...';
        let minLat = Infinity, maxLat = -Infinity, minLon = Infinity, maxLon = -Infinity;
        geoCoordGroups.forEach(group => {
            group.forEach(coord => {
                minLat = Math.min(minLat, coord[0]);
                maxLat = Math.max(maxLat, coord[0]);
                minLon = Math.min(minLon, coord[1]);
                maxLon = Math.max(maxLon, coord[1]);
            });
        });

        const bufferDegrees = 0.00005; 
        minLat -= bufferDegrees;
        maxLat += bufferDegrees;
        minLon -= bufferDegrees;
        maxLon += bufferDegrees;

        const searchPolygonCoordsEPSG3857 = [
            [minLon, minLat], [maxLon, minLat], [maxLon, maxLat], [minLon, maxLat], [minLon, minLat]
        ].map(coord => proj4("EPSG:4326", "EPSG:3857", coord));

        document.querySelector('.loading-text').textContent = 'Поиск участков ...';
        const foundFeatures = await searchParcelsByArea(searchPolygonCoordsEPSG3857);

        document.querySelector('.loading-text').textContent = 'Отрисовка найденных участков...';
        await drawFoundParcels(foundFeatures, true);

        document.querySelector('.loading-text').textContent = 'Анализ пересечений...';
        const intersectingParcels = findIntersectingParcelsFrontend(searchShapes);

        if (intersectingParcels.length > 0) {
            highlightIntersectingParcels(intersectingParcels);
            showParcelResults(intersectingParcels);
            showNotification(`Найдено пересечений: ${intersectingParcels.length}`, 'success', 'check-circle');
        } else {
            showNotification('Объект не пересекается с найденными участками', 'warning', 'exclamation-triangle');
            let allBounds = null;
            searchShapes.forEach(shape => {
                const bounds = shape.geometry.getBounds();
                if (!allBounds) { allBounds = bounds; }
                else {
                     allBounds = [
                        [Math.min(allBounds[0][0], bounds[0][0]), Math.min(allBounds[0][1], bounds[0][1])],
                        [Math.max(allBounds[1][0], bounds[1][0]), Math.max(allBounds[1][1], bounds[1][1])]
                     ];
                }
            });
             if (allBounds && allBounds[0] && allBounds[1]) {
                 map.setBounds(allBounds, { checkZoomRange: true, duration: 300 });
             }
        }

        document.getElementById('loaderContainer').style.display = 'none';

    } catch (error) {
        console.error('Ошибка при поиске на карте:', error);
        showNotification('Ошибка при обработке запроса "Найти"', 'error', 'exclamation-circle');
        document.getElementById('loaderContainer').style.display = 'none';
    }
}



// 4. Implement searchParcelsByArea
async function searchParcelsByArea(searchPolygonCoordsEPSG3857) {
    const requestBody = {
        "geom": {
            "type": "FeatureCollection",
            "features": [{
                "type": "Feature",
                "geometry": {
                    "crs": { "type": "name", "properties": { "name": "EPSG:3857" } },
                    "type": "Polygon",
                    "coordinates": [searchPolygonCoordsEPSG3857]
                },
                "properties": {}
            }]
        },
        "categories": [{"id": 36368}] // Land parcels
    };

    try {
       const response = await fetchNspd('https://nspd.gov.ru/api/geoportal/v1/intersects?typeIntersect=fullObject', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(requestBody)
        });

        const text = await response.text();
        if (!text) {
            console.warn('Пустой ответ от API при поиске по области');
            return [];
        }

        const data = JSON.parse(text);
        const responseSizeKB = new TextEncoder().encode(text).length / 1024;
        console.log(`Размер ответа от NSPD (поиск по области): ${responseSizeKB.toFixed(2)} КБ`);

        if (!data || !data.features || data.features.length === 0) {
            console.log('Участки в указанной области не найдены.');
            return [];
        }
        return data.features; // Return the raw features found

    } catch (error) {
        console.error('Ошибка при запросе участков по области:', error);
        showNotification('Ошибка сети при поиске участков', 'error', 'exclamation-circle');
        return [];
    }
}




function determineCoordinateSystemAndConvert(coordGroups) {
    const { system, swap } = determineCoordinateSystem(coordGroups);
    if (system === 'unknown') {
        console.error("Не удалось определить систему координат для конвертации.");
        return [];
    }
    return convertCoordinatesToGeo(coordGroups, system, swap);
}






function findIntersectingParcelsFrontend(searchShapes) {
    const intersectingParcels = [];
    const processedCadastralNumbers = new Set();

    for (const searchShape of searchShapes) {
        for (const obj of polygons) { // Check against ALL polygons on map
            // Check if it's a parcel polygon from either search type
             if (!(obj instanceof ymaps.Polygon) || (!obj.properties.get('isParcelInQuarter') && !obj.properties.get('isFoundInArea'))) {
                continue;
             }

            const cadastralNumber = obj.properties.get('cadastralNumber');
            // Ensure CN exists and hasn't been processed
            if (!cadastralNumber || processedCadastralNumbers.has(cadastralNumber)) {
                continue;
            }

            let isIntersecting = false;
            const targetPolygonCoords = obj.geometry.getCoordinates()[0]; // Assume single outer ring

            try { // Add try-catch for robustness
                if (searchShape instanceof ymaps.Placemark) {
                    const pointCoords = searchShape.geometry.getCoordinates();
                    isIntersecting = obj.geometry.contains(pointCoords);
                } else if (searchShape instanceof ymaps.Polyline) {
                    const lineCoords = searchShape.geometry.getCoordinates();
                    for (let i = 0; i < lineCoords.length - 1; i++) {
                        const segment = [lineCoords[i], lineCoords[i + 1]];
                        if (obj.geometry.contains(segment[0]) || obj.geometry.contains(segment[1])) {
                            isIntersecting = true; break;
                        }
                        for (let j = 0; j < targetPolygonCoords.length - 1; j++) {
                            if (doLinesIntersect(segment[0], segment[1], targetPolygonCoords[j], targetPolygonCoords[j + 1])) {
                                isIntersecting = true; break;
                            }
                        }
                        if (isIntersecting) break;
                    }
                } else if (searchShape instanceof ymaps.Polygon) {
                    const searchPolygonCoords = searchShape.geometry.getCoordinates()[0];
                    // Use Turf.js for robust polygon intersection check
                    let searchTurfPoly = turf.polygon([searchPolygonCoords.map(c => [c[1], c[0]])]); // lon, lat
// Создаем отрицательный буфер размером в 1 сантиметр (0.01 метра)
// Это немного "сожмет" поисковый полигон
const bufferedSearchPoly = turf.buffer(searchTurfPoly, -0.01, { units: 'meters' });
// Если буферизация прошла успешно, используем сжатый полигон для проверки
if (bufferedSearchPoly) {
    searchTurfPoly = bufferedSearchPoly;
}

                     const targetTurfPoly = turf.polygon([targetPolygonCoords.map(c => [c[1], c[0]])]); // lon, lat
                     isIntersecting = turf.booleanIntersects(searchTurfPoly, targetTurfPoly);

                     // Fallback/alternative checks (less robust than Turf)
                     /*
                    for (const point of searchPolygonCoords) { if (obj.geometry.contains(point)) { isIntersecting = true; break; } }
                    if (!isIntersecting) { for (const point of targetPolygonCoords) { if (searchShape.geometry.contains(point)) { isIntersecting = true; break; } } }
                    if (!isIntersecting) {
                        for (let i = 0; i < searchPolygonCoords.length - 1; i++) {
                            for (let j = 0; j < targetPolygonCoords.length - 1; j++) {
                                if (doLinesIntersect(searchPolygonCoords[i], searchPolygonCoords[i + 1], targetPolygonCoords[j], targetPolygonCoords[j + 1])) {
                                    isIntersecting = true; break;
                                }
                            }
                            if (isIntersecting) break;
                        }
                    } */
                }
            } catch(intersectionError) {
                console.error("Ошибка при проверке пересечения:", intersectionError, "Search Shape:", searchShape, "Target Object:", obj);
                isIntersecting = false; // Assume no intersection on error
            }

            if (isIntersecting) {
                processedCadastralNumbers.add(cadastralNumber);
                intersectingParcels.push({
                    cadastralNumber: cadastralNumber,
                    address: obj.properties.get('address') || 'Адрес не указан',
                    areaText: obj.properties.get('areaText') || 'Площадь не указана',
                    polygon: obj // Reference to the ymaps.Polygon object
                });
            }
        }
    }
    console.log("Intersecting Parcels Found:", intersectingParcels.length);
    return intersectingParcels;
}

function doLinesIntersect(p1, p2, p3, p4) {
    function ccw(a, b, c) {
        return (c[1] - a[1]) * (b[0] - a[0]) > (b[1] - a[1]) * (c[0] - a[0]);
    }
    
    return ccw(p1, p3, p4) !== ccw(p2, p3, p4) && ccw(p1, p2, p3) !== ccw(p1, p2, p4);
}

function highlightIntersectingParcels(parcels) {
    for (const parcel of parcels) {
        // Подсвечиваем полигон
        const polygon = parcel.polygon;
        const currStrokeColor = polygon.options.get('strokeColor');
        
        // Устанавливаем заливку
        polygon.options.set('fillColor', `${currStrokeColor}33`); // 33 - это 20% прозрачности в hex
        polygon.options.set('strokeWidth', polygonStyle.width); // Увеличиваем толщину линии
        
        // Создаем метку над центром полигона с кадастровым номером
        const bounds = polygon.geometry.getBounds();
        const centerGeo = [
            (bounds[0][0] + bounds[1][0]) / 2,
            (bounds[0][1] + bounds[1][1]) / 2
        ];
        
        const parts = parcel.cadastralNumber.split(':');
        const displayNumber = `:${parts[parts.length - 1]}`; // Последняя часть кадастрового номера
        
        const parcelText = new ymaps.Placemark(centerGeo, {
            iconContent: displayNumber,
            hintContent: `${parcel.cadastralNumber}\n${parcel.address}\n${parcel.areaText}`
        }, {
            preset: 'islands#darkOrangeStretchyIcon',
            draggable: true,
            zIndex: 900 // Поверх остальных меток
        });
        
        map.geoObjects.add(parcelText);
        polygons.push(parcelText);
    }
}





// Convert input coordinates to WGS84
function determineCoordinateSystem(coordGroups) {
    let system = 'unknown';
    let swap = false;

    if (!coordGroups || !coordGroups.length || !coordGroups[0] || !coordGroups[0].length) {
        console.error("Нет координат для определения системы.");
        return { system, swap };
    }

    const firstCoord = coordGroups[0][0];
    const x = firstCoord[0]; // Может быть X или широта
    const y = firstCoord[1]; // Может быть Y или долгота

    console.log(`Определение системы координат для точки: X=${x}, Y=${y}`);

    // 1. Проверка на EPSG:3857 (7+ цифр до точки) - приоритет
    const xIntDigits = Math.abs(x).toString().split('.')[0].length;
    const yIntDigits = Math.abs(y).toString().split('.')[0].length;
    if (xIntDigits >= 7 && yIntDigits >= 7) {
        system = 'EPSG:3857';
        swap = false; // Стандартный порядок X, Y для EPSG:3857
        console.log(`Обнаружен EPSG:3857 по длине цифр.`);
        return { system, swap };
    }

    // 2. Проверка на MSK (большие числа > 1M)
    if (Math.abs(x) > 1000000 || Math.abs(y) > 1000000) {
        if (Math.abs(x) > Math.abs(y)) { // Предполагаем X > Y
            if (x > 2000000 && x < 2999999) {
                system = 'MSK16_ZONE2';
                swap = false;
            } else if (x > 1000000 && x < 1999999) {
                system = 'MSK16_ZONE1';
                swap = false;
            }
        } else { // Предполагаем Y > X (возможно, перепутаны)
            if (y > 2000000 && y < 2999999) {
                system = 'MSK16_ZONE2';
                swap = true;
            } else if (y > 1000000 && y < 1999999) {
                system = 'MSK16_ZONE1';
                swap = true;
            }
        }
        if (system !== 'unknown') {
             console.log(`Обнаружен ${system}, swap=${swap}`);
             return { system, swap };
        }
    }

    // 3. Проверка на WGS84 (маленькие числа, широта/долгота)
    if (Math.abs(x) <= 90 && Math.abs(y) <= 180) { // Похоже на [lat, lon]
        system = 'EPSG:4326';
        swap = false; // Уже в правильном порядке [lat, lon]
        console.log(`Обнаружен EPSG:4326 (lat, lon), swap=${swap}`);
        return { system, swap };
    }
    if (Math.abs(x) <= 180 && Math.abs(y) <= 90) { // Похоже на [lon, lat]
        system = 'EPSG:4326';
        swap = true; // Нужно поменять на [lat, lon]
        console.log(`Обнаружен EPSG:4326 (lon, lat), swap=${swap}`);
        return { system, swap };
    }

    // Если ничего не подошло
    console.warn(`Не удалось определить систему координат для X=${x}, Y=${y}`);
    return { system, swap }; // system останется 'unknown'
}


        async function findQuarterByPointSupabase(pointX, pointY) {
            if (!supabaseClient) {
                console.error("Supabase client not initialized.");
                return null;
            }
            try {
                // В rpc передаем аргументы функции PostgreSQL
                const { data, error } = await supabaseClient.rpc('get_quarter_by_point', {
                    point_x: pointX, // Имя аргумента как в SQL функции
                    point_y: pointY  // Имя аргумента как в SQL функции
                });

                if (error) {
                    console.error("Supabase RPC error (get_quarter_by_point):", error);
                    return null;
                }

                console.log("Supabase RPC (get_quarter_by_point) result:", data);
                return (data && data.length > 0) ? data[0] : null;

            } catch (rpcError) {
                console.error("Exception during Supabase RPC call (get_quarter_by_point):", rpcError);
                return null;
            }
        }


// Функция для преобразования координат в WGS84 (с учетом swap)
function convertCoordinatesToGeo(coordGroups, coordSystem, needSwapXY) {
    const geoGroups = [];

    for (const group of coordGroups) {
        const geoGroup = [];

        for (const coord of group) {
            try {
                // Применяем swap *до* передачи в proj4, если нужно
                const [input1, input2] = needSwapXY ? [coord[1], coord[0]] : [coord[0], coord[1]];
                let wgs84Coords; // Ожидаем [lon, lat] от proj4

                switch (coordSystem) {
                    case 'MSK16_ZONE2':
                        const correctedX2 = input1 + 14.745; // input1 должен быть X
                        const correctedY2 = input2 - 14.038; // input2 должен быть Y
                        wgs84Coords = proj4("MSK16_ZONE2", "EPSG:4326", [correctedX2, correctedY2]);
                        wgs84Coords[0] -= 0.00000152; // Коррекция долготы
                        wgs84Coords[1] += 0.00000118; // Коррекция широты
                        break;

                    case 'MSK16_ZONE1':
                        const correctedX1 = input1 + 14.745; // input1 должен быть X
                        const correctedY1 = input2 - 14.038; // input2 должен быть Y
                        wgs84Coords = proj4("MSK16_ZONE1", "EPSG:4326", [correctedX1, correctedY1]);
                        wgs84Coords[0] -= 0.00000152; // Коррекция долготы
                        wgs84Coords[1] += 0.00000118; // Коррекция широты
                        break;

                    case 'EPSG:3857':
                        // proj4 ожидает [X, Y] для EPSG:3857
                        wgs84Coords = proj4("EPSG:3857", "EPSG:4326", [input1, input2]);
                        break;

                    case 'EPSG:4326':
                        // Уже в WGS84. Если swap=true, значит исходные были [lon, lat] -> input1=lon, input2=lat.
                        // Если swap=false, значит исходные были [lat, lon] -> input1=lat, input2=lon.
                        // Нам нужно вернуть [lat, lon].
                        wgs84Coords = needSwapXY ? [input1, input2] : [input2, input1]; // Результат [lon, lat]
                        break;

                    default:
                        console.error(`Неизвестная система координат: ${coordSystem}`);
                        continue; // Пропускаем эту координату
                }

                // proj4 возвращает [longitude, latitude], нам нужен [latitude, longitude]
                const geoCoord = [wgs84Coords[1], wgs84Coords[0]];
                geoGroup.push(geoCoord);
              //  console.log(`Преобразование: [${coord[0]}, ${coord[1]}] (${coordSystem}, swap=${needSwapXY}) -> [${geoCoord[0]}, ${geoCoord[1]}] (WGS84 lat, lon)`);

            } catch (e) {
                console.error('Ошибка преобразования координат:', e, coord, coordSystem);
            }
        }

        if (geoGroup.length > 0) {
            geoGroups.push(geoGroup);
        }
    }

    return geoGroups;
}


        // --- Core Theme Functions ---
function setActiveTheme(theme) {
    if (!map) return;
    const previousTheme = currentTheme;

    if ((previousTheme === 'use' && theme !== 'use') || theme === 'none') {
        selectedVriFromLegend = null;
        updateLegendSelectionVisuals();
        if (vriFilterPlacemarks.size > 0) {
            vriFilterPlacemarks.forEach(placemark => {
                if (map?.geoObjects.indexOf(placemark) !== -1) {
                    map.geoObjects.remove(placemark);
                }
            });
            vriFilterPlacemarks.clear();
        }
    }
   if ((previousTheme === 'ownership' && theme !== 'ownership') || theme === 'none') {
         selectedOwnershipFromLegend = null;
         ownershipFilterState = 0; // <-- ДОБАВИТЬ ЭТУ СТРОКУ
         updateLegendSelectionVisuals();
         if (ownershipFilterPlacemarks.size > 0) {
            ownershipFilterPlacemarks.forEach(placemark => {
                if (map?.geoObjects.indexOf(placemark) !== -1) {
                    map.geoObjects.remove(placemark);
                }
            });
            ownershipFilterPlacemarks.clear();
         }
    }
    if ((previousTheme === 'registration_date' && theme !== 'registration_date') || theme === 'none') {
         selectedRegistrationDateFromLegend = null;
         updateLegendSelectionVisuals();
    }
    if ((previousTheme === 'ulu' && theme !== 'ulu') || theme === 'none') {
        selectedUluFromLegend = null;
        updateLegendSelectionVisuals();
        if (uluFilterPlacemarks.size > 0) {
            uluFilterPlacemarks.forEach(placemark => {
                if (map?.geoObjects.indexOf(placemark) !== -1) {
                    map.geoObjects.remove(placemark);
                }
            });
            uluFilterPlacemarks.clear();
        }
        uluColorMap.clear();
        resetSidebarUluInfo();
    }

    if (theme !== 'none' && parcelFeaturesData.length === 0) {
         let existingFeatures = [];
         polygons.forEach(p => { if (p instanceof ymaps.Polygon && p.properties?.get('featureData')) { existingFeatures.push(p.properties.get('featureData')); }});
         if (existingFeatures.length === 0) { showNotification("Пожалуйста, сначала загрузите земельные участки в квартале", "warning"); return; }
         parcelFeaturesData = existingFeatures;
    }

    currentTheme = theme;
    applyCurrentTheme();

    let themeName = 'Тема сброшена';
    if (theme === 'cost') themeName = 'Тема: Кадастровая стоимость';
    else if (theme === 'use') themeName = 'Тема: Вид разрешенного использования';
    else if (theme === 'ownership') themeName = 'Тема: Собственность';
    else if (theme === 'registration_date') themeName = 'Тема: Дата внесения';
    else if (theme === 'ulu') themeName = 'Тема: Единое землепользование';

    if (theme !== 'none' || parcelFeaturesData.length > 0) {
        showNotification(themeName, 'success');
    }
}

function applyCurrentTheme() {
    hideLegends();
    if (currentTheme === 'cost') applyCostTheme();
    else if (currentTheme === 'use') applyUseTheme();
    else if (currentTheme === 'ownership') applyOwnershipTheme();
    else if (currentTheme === 'registration_date') applyRegistrationDateTheme();
    else if (currentTheme === 'ulu') applyUluTheme();
    else resetThemeVisuals();

    if (currentTheme === 'use' && selectedVriFromLegend !== null) applyVriFilter();
    if (currentTheme === 'ownership' && selectedOwnershipFromLegend !== null) applyOwnershipFilter();
    if (currentTheme === 'registration_date' && selectedRegistrationDateFromLegend !== null) applyRegistrationDateFilter();
    if (currentTheme === 'ulu' && selectedUluFromLegend !== null) applyUluFilter();
}

// --- NEW FUNCTION ---
// --- MODIFIED FUNCTION (Color Generation Part) ---
function applyRegistrationDateTheme() {
    const polygonsToStyle = [];
    const uniqueDates = new Set();
    registrationDateColorMap.clear(); // Clear previous colors

    console.log("Applying Registration Date Theme. Total objects to check:", polygons.length);

    // First pass: collect unique dates
    polygons.forEach(obj => {
        if (obj instanceof ymaps.Polygon && (obj.properties?.get('isParcelInQuarter') || obj.properties?.get('isFoundInArea'))) {
            polygonsToStyle.push(obj);
            const options = obj.properties.get('featureData')?.properties?.options || {};
            const regDate = options.land_record_reg_date; // Format "YYYY-MM-DD"
            if (regDate) {
                uniqueDates.add(regDate);
            } else {
                uniqueDates.add('Не указана'); // Consistent key for missing dates
            }
        }
         // Optional: Reset non-parcel polygons or handle labels if needed
        else if (obj instanceof ymaps.Placemark && obj.options?.get('iconLayout') === customPlacemarkLayout) {
             // Keep parcel labels visible based on zoom, visibility handled by updatePlacemarksVisibility
             obj.options.set('visible', map.getZoom() > 14);
        }
    });

    if (uniqueDates.size === 0) {
         console.warn("Нет данных о дате внесения.");
         polygonsToStyle.forEach(p => p.options.set('fillColor', '#00000000')); // Reset fill
         updateRegistrationDateLegend([]); // Hide legend
         return;
    }

    // Sort dates chronologically (ascending)
    const sortedDates = Array.from(uniqueDates).sort((a, b) => {
         if (a === 'Не указана') return 1; // 'Не указана' goes last
         if (b === 'Не указана') return -1;
         // Handle potential invalid date strings gracefully
         const dateA = new Date(a);
         const dateB = new Date(b);
         if (isNaN(dateA.getTime()) && isNaN(dateB.getTime())) return 0; // Both invalid, keep original order
         if (isNaN(dateA.getTime())) return 1; // A is invalid, B goes first
         if (isNaN(dateB.getTime())) return -1; // B is invalid, A goes first
         return dateA - dateB; // Sort actual dates
    });

     const totalUniqueDatesWithMissing = sortedDates.length;
     const datesOnly = sortedDates.filter(d => d !== 'Не указана');
     const totalUniqueDates = datesOnly.length;


    // Assign colors based on chronological order (distribute hues)
    sortedDates.forEach((date, index) => {
        if (date === 'Не указана') {
            registrationDateColorMap.set(date, '#cccccc'); // Grey for unspecified
        } else {
             // Find the index within the dates-only array
             const dateIndex = datesOnly.indexOf(date);
             const normalized = totalUniqueDates <= 1 ? 0.5 : (dateIndex / (totalUniqueDates - 1)); // Position in sorted date list (0 to 1)

             // Distribute hue across the spectrum (e.g., 0 to 300)
             const hue = Math.floor(normalized * 300);
             const saturation = 80; // High saturation
             const lightness = 50; // Medium lightness
             const hex = hslToHex(hue, saturation, lightness);
             registrationDateColorMap.set(date, hex);
        }
    });

    // Apply initial fill color to polygons when the theme is first activated
    // This coloring represents the date distribution visually.
    // Filtering will then make non-matching polygons transparent.
    polygonsToStyle.forEach(polygon => {
        const options = polygon.properties.get('featureData')?.properties?.options || {};
        const regDate = options.land_record_reg_date || 'Не указана';
        const colorKey = regDate; // Use the actual date string or 'Не указана'
        let initialFillColor = '#00000000'; // Default transparent

        if (registrationDateColorMap.has(colorKey)) {
             initialFillColor = `${registrationDateColorMap.get(colorKey)}CC`; // Use 80% opacity fill
        } else if (registrationDateColorMap.has('Не указана') && regDate === 'Не указана') {
             initialFillColor = `${registrationDateColorMap.get('Не указана')}CC`;
        }

        polygon.options.set('fillColor', initialFillColor);
    });

    updateRegistrationDateLegend(sortedDates); // Update the new legend with sorted dates
    if (registrationDateLegendDiv) registrationDateLegendDiv.style.display = 'block'; // Show the new legend
    // Hide other legends
    if (costLegendDiv) costLegendDiv.style.display = 'none';
    if (vriLegendDiv) vriLegendDiv.style.display = 'none';
    if (ownershipLegendDiv) ownershipLegendDiv.style.display = 'none';

    // Re-apply filter AFTER setting initial colors and showing legend
    // This is important if a date was already selected when the theme was switched
    applyRegistrationDateFilter();
}
// --- END MODIFIED FUNCTION (Color Generation Part) ---


async function fetchUluRelations(parcelCNs) {
    if (!parcelCNs || parcelCNs.length === 0) {
        return [];
    }

    const MAX_CNS_PER_REQUEST = 200; // Threshold for chunking
    let allFetchedRelations = [];
    let totalFetchedCount = 0;

    try {
        if (parcelCNs.length <= MAX_CNS_PER_REQUEST) {
            // If the number of CNs is within the limit, make a single request
            console.log(`Fetching ULU relations for ${parcelCNs.length} parcels (single request)...`);
            const { data, error } = await supabaseClient
                .from('EZ') // Your table name
                .select('EZ, ZU') // Column names in your Supabase table
                .in('ZU', parcelCNs);

            if (error) {
                console.error('Supabase error fetching ULU relations (single request):', error);
                throw error; // Propagate the error
            }
            allFetchedRelations = data || [];
            totalFetchedCount = allFetchedRelations.length;
            console.log(`Fetched ${totalFetchedCount} ULU relations (single request).`);

        } else {
            // If the number of CNs exceeds the limit, process in chunks
            console.log(`Fetching ULU relations for ${parcelCNs.length} parcels in chunks of ${MAX_CNS_PER_REQUEST}...`);
            for (let i = 0; i < parcelCNs.length; i += MAX_CNS_PER_REQUEST) {
                const chunk = parcelCNs.slice(i, i + MAX_CNS_PER_REQUEST);
                console.log(`Fetching ULU relations for chunk ${Math.floor(i / MAX_CNS_PER_REQUEST) + 1}/${Math.ceil(parcelCNs.length / MAX_CNS_PER_REQUEST)}, size: ${chunk.length}`);

                const { data, error } = await supabaseClient
                    .from('EZ')
                    .select('EZ, ZU')
                    .in('ZU', chunk);

                if (error) {
                    console.error(`Supabase error fetching ULU relations for chunk ${Math.floor(i / MAX_CNS_PER_REQUEST) + 1}:`, error);
                    // Decide how to handle chunk errors:
                    // Option 1: Continue and try to fetch other chunks (current implementation)
                    // Option 2: throw error; // Stop processing if any chunk fails
                    // For now, we'll log the error and continue, results for this chunk will be empty.
                } else if (data) {
                    allFetchedRelations.push(...data);
                    totalFetchedCount += data.length;
                }
                 // Optional: Add a small delay between chunk requests if needed, though Supabase usually handles concurrent requests well.
                 // await new Promise(resolve => setTimeout(resolve, 100)); // e.g., 100ms delay
            }
            console.log(`Fetched a total of ${totalFetchedCount} ULU relations from all chunks.`);
        }
        return allFetchedRelations;

    } catch (e) {
        // This catch block handles errors from single requests or re-thrown errors from chunk processing
        console.error('Exception during ULU relation fetching process:', e);
        showNotification('Ошибка получения данных о ЕЗП из БД', 'error');
        return []; // Return empty array on failure to allow the rest of the theme application to proceed gracefully
    }
}



async function applyUluTheme() {
    if (!parcelFeaturesData || parcelFeaturesData.length === 0) {
        let existingFeatures = [];
        polygons.forEach(p => {
            if (p instanceof ymaps.Polygon && p.properties?.get('featureData')) {
                existingFeatures.push(p.properties.get('featureData'));
            }
        });
        if (existingFeatures.length === 0) {
            showNotification("Сначала загрузите участки в квартале для темы ЕЗП", "warning");
            resetThemeVisuals();
            return;
        }
        parcelFeaturesData = existingFeatures; // Use features from existing polygons if parcelFeaturesData was empty
    }

    showLoader("Обработка ЕЗП...");
    const polygonsToStyle = [];
    const parcelCNsForUluQuery = []; // New array for filtered CNs
    uluColorMap.clear();
    zuToEzMapGlobal.clear();

    polygons.forEach(obj => {
        if (obj instanceof ymaps.Polygon && (obj.properties?.get('isParcelInQuarter') || obj.properties?.get('isFoundInArea'))) {
            const featureData = obj.properties.get('featureData');
            const cn = obj.properties.get('cadastralNumber');

            if (cn && featureData && featureData.properties && featureData.properties.options) {
                polygonsToStyle.push(obj); // Still style all polygons on the map

                // Check the subtype for ULU query
                const subtype = featureData.properties.options.subtype || featureData.properties.options.land_record_subtype;
                if (subtype === "Обособленный участок") {
                    parcelCNsForUluQuery.push(cn);
                }
            }
        }
    });

    if (parcelCNsForUluQuery.length === 0) {
        hideLoader();
        // Even if no "Обособленный участок" found for query, we might still want to show the legend if other themes are active
        // Or simply hide the ULU legend if this theme relies solely on these specific parcels.
        // For now, let's assume if no CNs to query, ULU theme effectively shows nothing specific for ULU.
        polygonsToStyle.forEach(polygon => { // Ensure all polygons are reset if no ULU data is applied
            polygon.options.set('fillColor', '#00000000');
            polygon.properties.set('uluParentCn', null);
        });
        updateUluLegend(new Map()); // Update with empty map to hide legend or show "no data"
        if (uluLegendDiv) uluLegendDiv.style.display = 'block'; // Keep legend visible to show "no data" or allow selection
        resetSidebarUluInfo(); // Ensure sidebar is cleared of ULU info
        applyUluFilter(); // Apply filter (which will likely show nothing if no data)
        showNotification("Не найдено обособленных участков для анализа ЕЗП.", "info");
        hideLoader();
        return;
    }

    // Now, fetch ULU relations ONLY for the filtered parcelCNsForUluQuery
    const uluRelations = await fetchUluRelations(parcelCNsForUluQuery);
    const uniqueEzNumbers = new Set();

    uluRelations.forEach(relation => {
        zuToEzMapGlobal.set(relation.ZU, relation.EZ);
        uniqueEzNumbers.add(relation.EZ);
    });

    const sortedEzNumbers = Array.from(uniqueEzNumbers).sort();
    sortedEzNumbers.forEach((ez, index) => {
        const hue = (index * (360 / (sortedEzNumbers.length || 1))) % 360;
        uluColorMap.set(ez, hslToHex(hue, 80, 55));
    });

    // Style all polygons based on the fetched ULU data (even those not queried, they won't have a color if not in an EZ)
    polygonsToStyle.forEach(polygon => {
        const cn = polygon.properties.get('cadastralNumber');
        let fillColor = '#00000000'; // Default: no fill
        let parentEzForPolygon = null;

        if (zuToEzMapGlobal.has(cn)) { // Check if this CN (which was queried or is part of an EZ found) has a parent
            const ezParent = zuToEzMapGlobal.get(cn);
            parentEzForPolygon = ezParent;
            if (uluColorMap.has(ezParent)) {
                fillColor = `${uluColorMap.get(ezParent)}CC`; // Apply color with opacity
            }
        }
        polygon.options.set('fillColor', fillColor);
        polygon.properties.set('uluParentCn', parentEzForPolygon); // Store parent EZ for sidebar/filtering
    });

    updateUluLegend(uluColorMap);
    if (uluLegendDiv) uluLegendDiv.style.display = 'block';
    updateSidebarForUluTheme(); // Update sidebar with EZ info
    applyUluFilter(); // Apply any legend-based filtering
    hideLoader();
}

function updateSidebarForUluTheme() {
    const contentDiv = document.getElementById('parcel-list-content');
    if (!contentDiv) return;

    const items = contentDiv.querySelectorAll('.sidebar-item');

    items.forEach(itemDiv => {
        const cadNumElement = itemDiv.querySelector('p:first-child');
        if (!cadNumElement) return;

        const fullText = cadNumElement.textContent;
        const cadNumberMatch = fullText.match(/\d+:\d+:\d{6,7}:\d+/);
        if (!cadNumberMatch) return;
        const parcelCn = cadNumberMatch[0];

        let uluInfoElement = itemDiv.querySelector('.ulu-info-sidebar');
        if (!uluInfoElement) {
            uluInfoElement = document.createElement('p');
            uluInfoElement.className = 'ulu-info-sidebar';
            uluInfoElement.style.color = '#007bff';
            uluInfoElement.style.fontSize = '0.85rem';
            uluInfoElement.style.marginTop = '4px';
            const addressElement = itemDiv.querySelectorAll('p')[1];
            if (addressElement) {
                addressElement.insertAdjacentElement('afterend', uluInfoElement);
            } else {
                itemDiv.appendChild(uluInfoElement);
            }
        }

        if (zuToEzMapGlobal.has(parcelCn)) {
            const ezParentCn = zuToEzMapGlobal.get(parcelCn);
            uluInfoElement.innerHTML = `Единое землепользование:<br>${ezParentCn}`;
        } else {
            uluInfoElement.innerHTML = '-';
        }
    });
}


function resetSidebarUluInfo() {
    const contentDiv = document.getElementById('parcel-list-content');
    if (!contentDiv) return;

    const items = contentDiv.querySelectorAll('.sidebar-item');
    items.forEach(itemDiv => {
        const uluInfoElement = itemDiv.querySelector('.ulu-info-sidebar');
        if (uluInfoElement) {
            uluInfoElement.innerHTML = '-';
        }
    });
}


function updateUluLegend(uluMapWithColors) {
    if (!uluLegendDiv) return;
    const list = document.getElementById('ulu-legend-list');
    if (!list) return;
    list.innerHTML = '';

    if (!uluMapWithColors || uluMapWithColors.size === 0) {
        uluLegendDiv.style.display = 'none';
        return;
    }

    const resetItem = document.createElement('li');
    resetItem.textContent = 'Показать все';
    resetItem.style.fontWeight = 'bold';
    resetItem.style.cursor = 'pointer';
    resetItem.style.color = '#333';
    resetItem.dataset.uluKey = '';
    if (selectedUluFromLegend === null || selectedUluFromLegend === '') {
        resetItem.classList.add('legend-item-selected');
    }
    resetItem.addEventListener('click', handleUluLegendClick);
    list.appendChild(resetItem);

    const sortedUluArray = Array.from(uluMapWithColors.entries()).sort((a, b) => {
        return a[0].localeCompare(b[0], 'ru', { sensitivity: 'base' });
    });

    sortedUluArray.forEach(([ezCn, colorHex]) => {
        const li = document.createElement('li');
        li.dataset.uluKey = ezCn;

        const colorBox = document.createElement('span');
        colorBox.className = 'legend-color-box';
        colorBox.style.backgroundColor = colorHex || '#cccccc';

        const text = document.createElement('span');
        text.textContent = ezCn;
        text.style.fontSize = '11px';

        li.appendChild(colorBox);
        li.appendChild(text);
        list.appendChild(li);

        li.addEventListener('click', handleUluLegendClick);
        if (selectedUluFromLegend === ezCn) {
            li.classList.add('legend-item-selected');
        }
    });
    uluLegendDiv.style.display = 'block';
}

function handleUluLegendClick(event) {
    const listItem = event.target.closest('li');
    if (!listItem) return;

    const clickedUluKey = listItem.dataset.uluKey;
    if (clickedUluKey === undefined) return;

    if (selectedUluFromLegend === clickedUluKey || clickedUluKey === '') {
        selectedUluFromLegend = null;
    } else {
        selectedUluFromLegend = clickedUluKey;
    }

    updateLegendSelectionVisuals();
    applyUluFilter();
}

function applyUluFilter() {
    if (currentTheme !== 'ulu') {
        if (uluFilterPlacemarks.size > 0) {
            uluFilterPlacemarks.forEach(placemark => {
                if (map?.geoObjects.indexOf(placemark) !== -1) {
                    map.geoObjects.remove(placemark);
                }
            });
            uluFilterPlacemarks.clear();
        }
        if (selectedUluFromLegend !== null) {
            selectedUluFromLegend = null;
            updateLegendSelectionVisuals();
        }
        return;
    }

    const placemarkPreset = 'islands#violetIcon';
    const placemarkZIndex = 700;
    const cnsToShowPlacemark = new Set();

    polygons.forEach(obj => {
        if (obj instanceof ymaps.Polygon && (obj.properties?.get('isParcelInQuarter') || obj.properties?.get('isFoundInArea'))) {
            const zuCn = obj.properties.get('cadastralNumber');
            if (!zuCn) return;

            const uluParentCn = obj.properties.get('uluParentCn');
            let fillColor = '#00000000';
            const showAll = selectedUluFromLegend === null;
            const matchesSelectedUlu = uluParentCn === selectedUluFromLegend;

            if (showAll) {
                if (uluParentCn && uluColorMap.has(uluParentCn)) {
                    fillColor = `${uluColorMap.get(uluParentCn)}CC`;
                }
            } else if (matchesSelectedUlu) {
                if (uluColorMap.has(selectedUluFromLegend)) {
                    fillColor = `${uluColorMap.get(selectedUluFromLegend)}CC`;
                }
            }
            obj.options.set('fillColor', fillColor);

            const existingPlacemark = uluFilterPlacemarks.get(zuCn);
            if (matchesSelectedUlu && selectedUluFromLegend !== null) {
                cnsToShowPlacemark.add(zuCn);
                if (!existingPlacemark) {
                    const bounds = obj.geometry.getBounds();
                    if (bounds?.[0]?.[0] !== undefined && isFinite(bounds[0][0])) {
                        const centerGeo = [(bounds[0][0] + bounds[1][0]) / 2, (bounds[0][1] + bounds[1][1]) / 2];
                        const tempPlacemark = new ymaps.Placemark(centerGeo, {
                            hintContent: `${zuCn}\n(входит в ЕЗП: ${selectedUluFromLegend})`
                        }, {
                            preset: placemarkPreset,
                            zIndex: placemarkZIndex
                        });
                        map.geoObjects.add(tempPlacemark);
                        uluFilterPlacemarks.set(zuCn, tempPlacemark);
                    }
                }
            }
        }
    });

    uluFilterPlacemarks.forEach((placemark, cn) => {
        if (!cnsToShowPlacemark.has(cn)) {
            if (map?.geoObjects.indexOf(placemark) !== -1) {
                map.geoObjects.remove(placemark);
            }
            uluFilterPlacemarks.delete(cn);
        }
    });
    updatePlacemarksVisibility();
}


async function getAllStructuresInQuarter(lat, lon) {
    showLoader("Поиск квартала для сооружений...");

    try {
        let quarterFeature = null;
        let quarterNumberToQuery = null;

        async function fetchNSPDQuarterGeometry(qn) {
            const url = `https://nspd.gov.ru/api/geoportal/v2/search/geoportal?thematicSearchId=2&query=${encodeURIComponent(qn)}`;
            try {
                const response = await fetchNspd(url); // Используем fetchNspd
                const data = await response.json();
                if (data?.data?.features?.length > 0) return data.data.features[0];
            } catch (error) { console.error(`Ошибка при запросе геометрии квартала ${qn}:`, error); }
            return null;
        }

        const cadastralData = await queryCadastralInfo(lat, lon);
        if (cadastralData?.features?.length) {
            const feature = cadastralData.features[0];
            const cadastralNumberOfPoint = feature.properties?.descr;
            if (cadastralNumberOfPoint && cadastralNumberOfPoint.split(':').length >= 3) {
                quarterNumberToQuery = cadastralNumberOfPoint.split(':').slice(0, 3).join(':');
                
                // --- ИЗМЕНЕНИЕ: Добавлена проверка на нулевой квартал ---
                if (isZeroQuarterRequest(quarterNumberToQuery)) {
                    showNotification('Поиск в нулевом квартале не выполняется', 'warning');
                    hideLoader();
                    return;
                }
                // --- КОНЕЦ ИЗМЕНЕНИЯ ---
                
                quarterFeature = await fetchNSPDQuarterGeometry(quarterNumberToQuery);
            }
        }
        
        if (!quarterFeature) {
            showNotification('Не удалось определить кадастровый квартал.', 'error');
            hideLoader();
            return;
        }

        showLoader(`Загрузка Сооружений в квартале ${quarterNumberToQuery}...`);

        const requestBody = {
            "geom": { "type": "FeatureCollection", "features": [{ "type": "Feature", "geometry": quarterFeature.geometry, "properties": {} }] },
            "categories": [{ "id": 36383 }]
        };

        const response = await fetchNspd('https://nspd.gov.ru/api/geoportal/v1/intersects?typeIntersect=fullObject', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(requestBody)
        });

        if (!response.ok) throw new Error(`HTTP ошибка ${response.status} при запросе Сооружений`);
        
        const structuresData = await response.json();
        structureFeaturesData = structuresData.features || [];

        if (structureFeaturesData.length === 0) {
            showNotification(`Сооружения в квартале ${quarterNumberToQuery} не найдены`, 'warning');
            hideLoader();
            return;
        }

        await processAndDrawStructures(structureFeaturesData);
        await populateSidebarWithFoundObjects(structureFeaturesData, 'Сооружения');

        showNotification(`Загружено Сооружений: ${structureFeaturesData.length} для ${quarterNumberToQuery}`, 'success');

    } catch (error) {
        console.error('Ошибка в getAllStructuresInQuarter:', error);
        showNotification(`Ошибка сети или обработки данных: ${error.message}`, 'error');
    } finally {
        hideLoader();
    }
}


async function processAndDrawStructures(features) {
    if (!map) return;

    for (const feature of features) {
        try {
            const properties = feature.properties || {};
            const options = properties.options || {};
            const cadNumber = options.cad_number || properties.descr || 'Без номера';
            const name = options.params_name || properties.descr || 'Без названия'; // params_name приоритетнее
            const address = options.address_readable_address || 'Адрес не указан';
            
            const lengthValue = options.params_extension;
            let lengthText = 'Протяженность не указана';
            if (lengthValue && isFinite(parseFloat(lengthValue))) {
                lengthText = `Протяженность: ${parseFloat(lengthValue).toLocaleString('ru-RU')} м`;
            }

            const purpose = options.params_purpose || null;
            const yearBuilt = options.params_year_built || null;
            
            const hintContent = {
                cadastralNumber: cadNumber,
                address: address,
                area: lengthText, // Используем area для универсальности в макете
                purpose: purpose,
                yearBuilt: yearBuilt,
                // Добавляем другие поля, если нужно
            };
            
            if (!feature?.geometry?.coordinates) continue;

            const geometryType = feature.geometry.type;
            let allContours = [];
            if (geometryType === 'Polygon') allContours = [feature.geometry.coordinates[0]];
            else if (geometryType === 'MultiPolygon') feature.geometry.coordinates.forEach(poly => allContours.push(poly[0]));
            else continue;

            for (const contour of allContours) {
                 if (!Array.isArray(contour) || contour.length < 3) continue;

                 const coordinates = contour.map(coord => {
                     const p = proj4('EPSG:3857', 'EPSG:4326', coord);
                     return [p[1], p[0]];
                 });
                 const offsetCoordinates = coordinates.map(c => [c[0] - mapOffsetY * 0.000008983, c[1] - mapOffsetX * 0.000008983]);

                 const structurePolygon = new ymaps.Polygon([offsetCoordinates], 
                    {
                        cadastralNumber: cadNumber, 
                        name: name,
                        hintContent: hintContent,
                        isStructure: true // <-- Новый флаг
                    }, 
                    {
                        strokeColor: polygonStyle.structuresColor, // <-- Новый цвет
                        strokeWidth: polygonStyle.width - 1,
                        strokeOpacity: 0.8,
                        fillColor: '#00000000',
                        cursor: 'pointer',
                        hintLayout: customHintLayout
                    }
                 );

                structurePolygon.events.add('dblclick', async () => {
                    try { await navigator.clipboard.writeText(cadNumber); showNotification(`Скопировано: ${cadNumber}`, 'success'); }
                    catch (err) { showNotification('Ошибка копирования', 'error'); }
                });

                map.geoObjects.add(structurePolygon);
                polygons.push(structurePolygon);

                const bounds = structurePolygon.geometry.getBounds();
                if (bounds && bounds[0] && bounds[1]) {
                    const centerGeo = [(bounds[0][0] + bounds[1][0]) / 2, (bounds[0][1] + bounds[1][1]) / 2];
                    const parts = cadNumber.split(':');
                    const displayNumber = parts.length > 3 ? ':' + parts[parts.length - 1] : cadNumber;
                    
                    const structureText = new ymaps.Placemark(centerGeo, { iconContent: displayNumber, hintContent: hintContent }, {
                        iconLayout: customPlacemarkLayout,
                        visible: map.getZoom() > 14
                    });
                    
                    structureText.polygon = structurePolygon;
                    map.geoObjects.add(structureText);
                    polygons.push(structureText);
                    parcelPlacemarks.push(structureText);
                }
            }
        } catch (error) {
            console.error('Ошибка при отрисовке Сооружения:', error, feature);
        }
    }
}

function exportStructuresToExcel() {
    showLoader('Подготовка данных Сооружений для экспорта...');

    try {
        const dataForSheet = [];
        const headers = [
            "Кадастровый номер", "Наименование", "Адрес", "Протяженность (м)", 
            "Назначение", "Год постройки", "Форма собственности", "Тип права", "Дата внесения"
        ];
        dataForSheet.push(headers);

        structureFeaturesData.forEach(feature => {
            const properties = feature.properties || {};
            const options = properties.options || {};
            
            const cadNumber = options.cad_number || properties.descr || 'Не указан';
            const name = options.params_name || properties.descr || 'Не указано';
            const address = options.address_readable_address || 'Не указан';
            const lengthValue = (options.params_extension && isFinite(parseFloat(options.params_extension))) ? parseFloat(options.params_extension) : 'Не указана';
            const purpose = options.params_purpose || 'Не указано';
            const yearBuilt = options.params_year_built || 'Не указан';
            const ownership = options.ownership_type || 'Не указана';
            const rightType = options.right_type || 'Не указана';
            const registrationDate = options.registration_date || 'Не указана';

            const row = [
                cadNumber, name, address, lengthValue, purpose, yearBuilt, 
                ownership, rightType, registrationDate
            ];
            dataForSheet.push(row);
        });

        const wb = XLSX.utils.book_new();
        const ws = XLSX.utils.aoa_to_sheet(dataForSheet);

        ws['!cols'] = [ {wch:20}, {wch:50}, {wch:50}, {wch:20}, {wch:20}, {wch:15}, {wch:20}, {wch:20}, {wch:20} ];

        XLSX.utils.book_append_sheet(wb, ws, "Сооружения");
        XLSX.writeFile(wb, "Найденные_Сооружения.xlsx");

        showNotification('Данные Сооружений успешно экспортированы в Excel', 'success', 'check-circle');

    } catch (error) {
        console.error('Ошибка при экспорте данных Сооружений:', error);
        showNotification('Ошибка при экспорте данных Сооружений в Excel', 'error', 'exclamation-circle');
    } finally {
        hideLoader();
    }
}



// --- MODIFIED FUNCTION ---
function updateRegistrationDateLegend(sortedDates) {
    if (!registrationDateLegendDiv) return;
    const list = document.getElementById('registration-date-legend-list');
    if (!list) return;
    list.innerHTML = ''; // Clear previous items

    if (!sortedDates || sortedDates.length === 0) {
        registrationDateLegendDiv.style.display = 'none';
        return;
    }

    // Add filter reset item at the top
     const resetItem = document.createElement('li');
     resetItem.textContent = 'Показать все';
     resetItem.style.fontWeight = 'bold';
     resetItem.style.cursor = 'pointer';
     resetItem.style.color = '#333'; // Ensure visibility
     resetItem.dataset.filterValue = ''; // Use empty string to signify "show all"
     // Check if this item is currently selected to apply the visual
     if (selectedRegistrationDateFromLegend === null || selectedRegistrationDateFromLegend === '') {
         resetItem.classList.add('legend-item-selected');
     }
     resetItem.addEventListener('click', handleRegistrationDateLegendClick); // Add listener
     list.appendChild(resetItem);


    // Iterate over the sorted dates to create legend items
    sortedDates.forEach(date => {
        const li = document.createElement('li');
        li.dataset.filterValue = date; // Store the date string for filtering

        const colorBox = document.createElement('span');
        colorBox.className = 'legend-color-box';
        colorBox.style.backgroundColor = registrationDateColorMap.get(date) || '#cccccc'; // Fallback color

        const text = document.createElement('span');
        text.textContent = date;
        li.appendChild(colorBox);
        li.appendChild(text);
        list.appendChild(li);

        // Add click listener to filter
        li.addEventListener('click', handleRegistrationDateLegendClick);

         // Apply visual highlight if this item is currently selected
        if (selectedRegistrationDateFromLegend === date) {
             li.classList.add('legend-item-selected');
        }
    });

    registrationDateLegendDiv.style.display = 'block'; // Ensure legend is visible
     // updateLegendSelectionVisuals(); // This is now called internally or after this function finishes

    // Hide other legends (ensure this is handled correctly by applyCurrentTheme)
    // if (costLegendDiv) costLegendDiv.style.display = 'none';
    // if (vriLegendDiv) vriLegendDiv.style.display = 'none';
    // if (ownershipLegendDiv) ownershipLegendDiv.style.display = 'none';
}
// --- END MODIFIED FUNCTION ---



// --- MODIFIED FUNCTION ---
function handleRegistrationDateLegendClick(event) {
    const listItem = event.target.closest('li');
    if (!listItem) return;

    const clickedValue = listItem.dataset.filterValue; // Get the value from the dataset

    // Toggle selection state
    if (selectedRegistrationDateFromLegend === clickedValue || clickedValue === '') {
        // If clicking the currently selected item OR clicking "Показать все", deselect
        selectedRegistrationDateFromLegend = null;
    } else {
        // Otherwise, select the clicked date/year
        selectedRegistrationDateFromLegend = clickedValue;
    }

    updateLegendSelectionVisuals(); // Update visual highlight in the legend
    applyRegistrationDateFilter(); // Apply the filtering logic to map polygons and placemarks
}
// --- END MODIFIED FUNCTION ---


// --- NEW FUNCTION ---
// --- MODIFIED FUNCTION ---
function applyRegistrationDateFilter() {
     // This filter only applies when the theme is 'registration_date'
     if (currentTheme !== 'registration_date') {
          // If we are not in this theme, clear any filter placemarks that might somehow exist
          if (registrationDateFilterPlacemarks.size > 0) {
              registrationDateFilterPlacemarks.forEach(placemark => {
                  if (map?.geoObjects.indexOf(placemark) !== -1) {
                      map.geoObjects.remove(placemark);
                  }
              });
              registrationDateFilterPlacemarks.clear();
          }
          // Ensure date filter value is null if theme changes away
          selectedRegistrationDateFromLegend = null;
          updateLegendSelectionVisuals(); // Update visuals
          return;
     }

     console.log(`Applying Registration Date filter. Selected: ${selectedRegistrationDateFromLegend === null ? 'None (Show All)' : selectedRegistrationDateFromLegend}`);

     const placemarkPreset = 'islands#blueDotIcon'; // Preset for filter placemarks
     const placemarkZIndex = 650; // Z-index above parcel labels

     // Keep track of CNs that *should* have a filter placemark in this run
     const cnsToShowPlacemark = new Set();


     polygons.forEach(obj => {
         // Process only relevant polygons (parcels)
         if (obj instanceof ymaps.Polygon && (obj.properties?.get('isParcelInQuarter') || obj.properties?.get('isFoundInArea'))) {
             const options = obj.properties.get('featureData')?.properties?.options || {};
             const regDate = options.land_record_reg_date || 'Не указана';
             const cadastralNumber = obj.properties.get('cadastralNumber');

             if (!cadastralNumber) return;

             // Determine if this polygon should be highlighted by the current filter
             const shouldMatch = selectedRegistrationDateFromLegend === null || regDate.startsWith(selectedRegistrationDateFromLegend);

             let fillColor = '#00000000'; // Default transparent

             // --- Fill Color Logic (only apply if it matches the filter OR if showing all) ---
             if (shouldMatch) {
                 const colorKey = regDate; // Use the date string or 'Не указана'
                 if (registrationDateColorMap.has(colorKey)) {
                     // Use consistent opacity (e.g., 80%)
                     fillColor = `${registrationDateColorMap.get(colorKey)}CC`;
                 } else if (registrationDateColorMap.has('Не указана') && regDate === 'Не указана') {
                      fillColor = `${registrationDateColorMap.get('Не указана')}CC`;
                 }

                 // --- Manage Temporary Filter Placemarks ---
                 if (selectedRegistrationDateFromLegend !== null) { // Only add placemarks when a specific date is selected
                     cnsToShowPlacemark.add(cadastralNumber); // Mark this CN for filter placemark display

                     const existingPlacemark = registrationDateFilterPlacemarks.get(cadastralNumber);
                     if (!existingPlacemark) {
                         // Create and add placemark if it doesn't exist
                         const bounds = obj.geometry.getBounds();
                         if (bounds?.[0]?.[0] !== undefined && isFinite(bounds[0][0])) {
                             const centerGeo = [
                                 (bounds[0][0] + bounds[1][0]) / 2,
                                 (bounds[0][1] + bounds[1][1]) / 2
                             ];
                             const tempPlacemark = new ymaps.Placemark(centerGeo, {
                                 // iconContent: cadastralNumber, // Optional: display CN on placemark
                                 hintContent: `${cadastralNumber}\nДата: ${regDate}` // Show CN and date on hover
                             }, {
                                 preset: placemarkPreset,
                                 zIndex: placemarkZIndex
                             });
                             map.geoObjects.add(tempPlacemark);
                             registrationDateFilterPlacemarks.set(cadastralNumber, tempPlacemark);
                             // console.log(`Added filter placemark for ${cadastralNumber} (Date Filter)`);
                         }
                     }
                 }
             }
             // Else (shouldMatch is false): fillColor remains transparent. The placemark will be removed in the cleanup step.

             obj.options.set('fillColor', fillColor);
         }
     });

     // --- Remove Placemarks that are no longer needed ---
     registrationDateFilterPlacemarks.forEach((placemark, cn) => {
         if (!cnsToShowPlacemark.has(cn)) {
             // This placemark should be hidden/removed
             if (map?.geoObjects.indexOf(placemark) !== -1) {
                 map.geoObjects.remove(placemark);
             }
             registrationDateFilterPlacemarks.delete(cn); // Remove from tracking map
             // console.log(`Removed filter placemark for ${cn} (Date Filter)`);
         }
     });

     // Update regular parcel label visibility based on the date filter selection
     // Labels linked to polygons that DO NOT match the date filter will be hidden here
     updatePlacemarksVisibility();
 }
// --- END MODIFIED FUNCTION ---


async function getAllBuildingsInQuarter(lat, lon) {
    showLoader("Поиск квартала...");

    try {
        let quarterFeature = null;
        let quarterNumberToQuery = null;

        async function fetchNSPDQuarterGeometry(qn) {
            const url = `https://nspd.gov.ru/api/geoportal/v2/search/geoportal?thematicSearchId=2&query=${encodeURIComponent(qn)}`;
            try {
                const response = await fetchNspd(url); // Используем fetchNspd
                const data = await response.json();
                if (data?.data?.features?.length > 0) return data.data.features[0];
            } catch (error) { console.error(`Ошибка при запросе геометрии квартала ${qn}:`, error); }
            return null;
        }

        const cadastralData = await queryCadastralInfo(lat, lon);
        if (cadastralData?.features?.length) {
            const feature = cadastralData.features[0];
            const cadastralNumberOfPoint = feature.properties?.descr;
            if (cadastralNumberOfPoint && cadastralNumberOfPoint.split(':').length >= 3) {
                quarterNumberToQuery = cadastralNumberOfPoint.split(':').slice(0, 3).join(':');

                // --- ИЗМЕНЕНИЕ: Добавлена проверка на нулевой квартал ---
                if (isZeroQuarterRequest(quarterNumberToQuery)) {
                    showNotification('Поиск в нулевом квартале не выполняется', 'warning');
                    hideLoader();
                    return;
                }
                // --- КОНЕЦ ИЗМЕНЕНИЯ ---

                quarterFeature = await fetchNSPDQuarterGeometry(quarterNumberToQuery);
            }
        }
        
        if (!quarterFeature) {
            showNotification('Не удалось определить кадастровый квартал.', 'error');
            hideLoader();
            return;
        }

        if (quarterFeature.geometry && quarterFeature.geometry.coordinates) {
             const yandexPolygons = [];
             const processNspdPolygon = (rings) => {
                 const wgsCoords = rings[0].map(coord => {
                     const p = proj4('EPSG:3857', 'EPSG:4326', coord);
                     return [p[1], p[0]];
                 });
                 return wgsCoords.map(c => [c[0] - mapOffsetY * 0.000008983, c[1] - mapOffsetX * 0.000008983]);
             };
             if (quarterFeature.geometry.type === "Polygon") {
                 yandexPolygons.push(processNspdPolygon(quarterFeature.geometry.coordinates));
             } else if (quarterFeature.geometry.type === "MultiPolygon") {
                 quarterFeature.geometry.coordinates.forEach(polygonRings => yandexPolygons.push(processNspdPolygon(polygonRings)));
             }
             if (yandexPolygons.length > 0) {
                 const quarterPolygonNSPD = new ymaps.Polygon(yandexPolygons, {}, {
                     strokeColor: '#AAAAAA', strokeWidth: polygonStyle.width > 1 ? polygonStyle.width - 1 : 1,
                     strokeStyle: 'dash', strokeOpacity: 0.7, fillColor: '#00000000', zIndex: 100
                 });
                 map.geoObjects.add(quarterPolygonNSPD);
                 polygons.push(quarterPolygonNSPD);
                 map.setBounds(quarterPolygonNSPD.geometry.getBounds(), { checkZoomRange: true, duration: 300 });
             }
        }

        showLoader(`Загрузка Зданий в квартале ${quarterNumberToQuery}...`);

        const requestBody = {
            "geom": { "type": "FeatureCollection", "features": [{ "type": "Feature", "geometry": quarterFeature.geometry, "properties": {} }] },
            "categories": [{ "id": 36369 }]
        };

        const response = await fetchNspd('https://nspd.gov.ru/api/geoportal/v1/intersects?typeIntersect=fullObject', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(requestBody)
        });

        if (!response.ok) throw new Error(`HTTP ошибка ${response.status} при запросе Зданий`);
        
        const buildingsData = await response.json();
        buildingFeaturesData = buildingsData.features || [];

        if (buildingFeaturesData.length === 0) {
            showNotification(`Здания в квартале ${quarterNumberToQuery} не найдены`, 'warning');
            hideLoader();
            return;
        }

        await processAndDrawBuildings(buildingFeaturesData);
        await populateSidebarWithFoundObjects(buildingFeaturesData, 'Здания');

        showNotification(`Загружено Зданий: ${buildingFeaturesData.length} для ${quarterNumberToQuery}`, 'success');

    } catch (error) {
        console.error('Ошибка в getAllBuildingsInQuarter:', error);
        showNotification(`Ошибка сети или обработки данных: ${error.message}`, 'error');
    } finally {
        hideLoader();
    }
}



async function processAndDrawBuildings(features) {
    if (!map) return;

    for (const feature of features) {
        try {
            const options = feature.properties.options || {};
            const cadNumber = options.cad_num || feature.properties.descr || 'Без номера';
            const name = feature.properties.descr || 'Без названия';
            const address = options.readable_address || 'Адрес не указан';
            
            const areaValue = options.build_record_area;
            let areaText = 'Площадь не указана';
            if (areaValue && isFinite(parseFloat(areaValue))) {
                areaText = `${parseFloat(areaValue).toLocaleString('ru-RU')} м²`;
            }

            let formattedCost = null;
            if (options.cost_index !== undefined && options.cost_index !== null && isFinite(parseFloat(options.cost_index))) {
                formattedCost = parseFloat(options.cost_index).toLocaleString('ru-RU', { maximumFractionDigits: 2 });
            }
            
            const purpose = options.purpose || options.building_name || null;
            const yearBuilt = options.year_built || null;
            const materials = options.materials || null;
            const floors = options.floors || null;
            const ownershipType = options.ownership_type || null;
            const rightType = options.right_type || null;
            
            const hintContent = {
                cadastralNumber: cadNumber,
                address: address,
                area: `Площадь: ${areaText}`,
                cost: formattedCost,
                purpose: purpose,
                yearBuilt: yearBuilt,
                materials: materials,
                floors: floors,
                ownershipType: ownershipType,
                rightType: rightType
            };
            
            if (!feature?.geometry?.coordinates) continue;

            const geometryType = feature.geometry.type;
            let allContours = [];
            if (geometryType === 'Polygon') allContours = [feature.geometry.coordinates[0]];
            else if (geometryType === 'MultiPolygon') feature.geometry.coordinates.forEach(poly => allContours.push(poly[0]));
            else continue;

            for (const contour of allContours) {
                 if (!Array.isArray(contour) || contour.length < 3) continue;

                 const coordinates = contour.map(coord => {
                     const p = proj4('EPSG:3857', 'EPSG:4326', coord);
                     return [p[1], p[0]];
                 });
                 const offsetCoordinates = coordinates.map(c => [c[0] - mapOffsetY * 0.000008983, c[1] - mapOffsetX * 0.000008983]);

                 const buildingPolygon = new ymaps.Polygon([offsetCoordinates], 
                    { // properties
                        cadastralNumber: cadNumber, 
                        name: name,
                        hintContent: hintContent,
                        isBuilding: true // <-- Флаг изменен
                    }, 
                    { // options
                        strokeColor: polygonStyle.buildingsColor, // <-- Используем цвет для зданий
                        strokeWidth: polygonStyle.width - 1,
                        strokeOpacity: 0.8,
                        fillColor: '#00000000',
                        cursor: 'pointer',
                        hintLayout: customHintLayout, 
                        hintOpenTimeout: 100,
                        hintCloseTimeout: 50
                    }
                 );

                buildingPolygon.events.add('dblclick', async () => {
                    try { await navigator.clipboard.writeText(cadNumber); showNotification(`Скопировано: ${cadNumber}`, 'success'); }
                    catch (err) { showNotification('Ошибка копирования', 'error'); }
                });

                map.geoObjects.add(buildingPolygon);
                polygons.push(buildingPolygon);

                const bounds = buildingPolygon.geometry.getBounds();
                if (bounds && bounds[0] && bounds[1]) {
                    const centerGeo = [(bounds[0][0] + bounds[1][0]) / 2, (bounds[0][1] + bounds[1][1]) / 2];
                    
                    const parts = cadNumber.split(':');
                    const displayNumber = parts.length > 3 ? ':' + parts[parts.length - 1] : cadNumber;
                    
                    const labelProperties = {
                        iconContent: displayNumber,
                        hintContent: hintContent,
                        cadastralNumber: cadNumber
                    };
                    
                    const buildingText = new ymaps.Placemark(centerGeo, labelProperties, {
                        iconLayout: customPlacemarkLayout,
                        hintLayout: customHintLayout,
                        hasBalloon: false,
                        draggable: false,
                        visible: map.getZoom() > 14,
                        zIndex: 550
                    });
                    
                    buildingText.polygon = buildingPolygon;
                    
                    map.geoObjects.add(buildingText);
                    polygons.push(buildingText);
                    parcelPlacemarks.push(buildingText);
                }
            }
        } catch (error) {
            console.error('Ошибка при отрисовке Здания:', error, feature);
        }
    }
}

async function populateSidebarWithFoundObjects(features, objectType) {
    const sidebar = document.getElementById('parcel-results-sidebar');
    const contentDiv = document.getElementById('parcel-list-content');
    const sidebarTitle = document.getElementById('sidebar-title');

    if (!sidebar || !contentDiv || !sidebarTitle) {
        console.error("Не найдены элементы боковой панели для populateSidebarWithFoundObjects");
        return;
    }
    
    contentDiv.innerHTML = ''; 
    sidebarTitle.textContent = `Найденные ${objectType} (${features.length})`;
    
    if (features && features.length > 0) {
        features.forEach((feature, index) => {
            const properties = feature.properties || {};
            const options = properties.options || {};
            
            let cadNumber, primaryDesc, secondaryDesc, thirdDesc;

            // --- ИЗМЕНЕНИЕ: Заменяем '===' на 'startsWith()' для гибкости ---
            if (objectType.startsWith('ЗУ')) {
                cadNumber = properties.descr || 'Без номера';
                primaryDesc = options.readable_address || 'Адрес не указан';
                secondaryDesc = getAreaText(options);
                thirdDesc = null;
            } 
            else if (objectType.startsWith('Здания')) {
                cadNumber = options.cad_num || properties.descr || 'Без номера';
                primaryDesc = properties.descr || 'Тип не указан';
                secondaryDesc = options.readable_address || 'Адрес не указан';
                const areaValue = options.build_record_area;
                thirdDesc = (areaValue && isFinite(parseFloat(areaValue))) 
                    ? `Площадь: ${parseFloat(areaValue).toLocaleString('ru-RU')} м²` 
                    : 'Площадь не указана';
            } 
            else if (objectType.startsWith('Сооружения')) {
                cadNumber = options.cad_number || properties.descr || 'Без номера';
                primaryDesc = options.params_name || properties.descr || 'Тип не указан';
                secondaryDesc = options.address_readable_address || 'Адрес не указан';
                const lengthValue = options.params_extension;
                thirdDesc = (lengthValue && isFinite(parseFloat(lengthValue))) 
                    ? `Протяженность: ${parseFloat(lengthValue).toLocaleString('ru-RU')} м` 
                    : 'Протяженность не указана';
            }
            else if (objectType.startsWith('ЗОУИТ')) {
                cadNumber = options.reg_numb_border || properties.descr || 'Без номера';
                primaryDesc = options.name_by_doc || 'Название не указано';
                secondaryDesc = options.content_restrict_encumbrances || 'Ограничения не указаны';
                thirdDesc = `Дата рег.: ${options.registration_date || 'не указана'}`;
            }
            // --- КОНЕЦ ИЗМЕНЕНИЯ ---
            
            const itemDiv = document.createElement('div');
            itemDiv.className = 'sidebar-item';
            // Проверяем, что cadNumber определен, перед вызовом toLowerCase()
            itemDiv.dataset.cadnum = cadNumber ? cadNumber.toLowerCase() : '';

            let html = `
                <p>${index + 1}. ${cadNumber || 'Неизвестный номер'}</p>
                <p style="font-style: italic; color: #1e88e5;">${primaryDesc}</p> 
                <p>${secondaryDesc}</p>`;
            if (thirdDesc) {
                html += `<p>${thirdDesc}</p>`;
            }
            itemDiv.innerHTML = html;

            const correspondingPolygon = polygons.find(p => p instanceof ymaps.Polygon && p.properties?.get('cadastralNumber') === cadNumber);
            if (correspondingPolygon) {
                itemDiv.addEventListener('dblclick', () => {
                    if (map) {
                        map.setBounds(correspondingPolygon.geometry.getBounds(), { 
                            checkZoomRange: true, 
                            duration: 500 
                        });
                    }
                });
            }
            contentDiv.appendChild(itemDiv);
        });
        
        sidebar.classList.remove('hidden', 'collapsed');

    } else {
        sidebar.classList.add('hidden');
    }
}


function applyOwnershipTheme() {
    const polygonsToStyle = [];
    const uniqueOwnershipCombinations = new Map(); // Map<"Ownership|RightType", colorHex>
    const allCombinationKeys = new Set(); // Collect all combination keys first

    // First pass: collect all combination keys
    polygons.forEach(obj => {
        if (obj instanceof ymaps.Polygon && (obj.properties?.get('isParcelInQuarter') || obj.properties?.get('isFoundInArea'))) {
            const options = obj.properties.get('featureData')?.properties?.options || {};
            const ownership = options.ownership_type || 'Не указано';
            const rightType = options.right_type || 'Не указано';
            const key = `${ownership}|${rightType}`;
            allCombinationKeys.add(key);
        }
    });

    // Create a sorted list of unique keys for consistent color assignment
    const sortedKeys = Array.from(allCombinationKeys).sort((a, b) => a.localeCompare(b));

    // Second pass: assign colors and collect data for legend
    polygons.forEach(obj => {
        if (obj instanceof ymaps.Polygon && (obj.properties?.get('isParcelInQuarter') || obj.properties?.get('isFoundInArea'))) {
            polygonsToStyle.push(obj);
            const options = obj.properties.get('featureData')?.properties?.options || {};
            const ownership = options.ownership_type || 'Не указано';
            const rightType = options.right_type || 'Не указано';
            const key = `${ownership}|${rightType}`;

            if (!ownershipColorMap.has(key)) {
                // Generate color based on the sorted position
                const index = sortedKeys.indexOf(key);
                const hue = (index * (360 / sortedKeys.length)) % 360; // Distribute hue
                const saturation = 65 + (index % 5) * 5; // Vary saturation slightly
                const lightness = 50 + (index % 3) * 5; // Vary lightness slightly
                ownershipColorMap.set(key, hslToHex(hue, saturation, lightness));
            }
            uniqueOwnershipCombinations.set(key, ownershipColorMap.get(key));

        } else if (obj instanceof ymaps.Placemark && obj.options?.get('iconLayout') === customPlacemarkLayout) {
             obj.options.set('visible', map.getZoom() > 14);
         }
    });

    // Third pass: Apply colors
    polygonsToStyle.forEach(polygon => {
        const options = polygon.properties.get('featureData')?.properties?.options || {};
        const ownership = options.ownership_type || 'Не указано';
        const rightType = options.right_type || 'Не указано';
        const key = `${ownership}|${rightType}`;
        let initialFillColor = '#CCCCCC'; // Default grey if key somehow not found

        if (ownershipColorMap.has(key)) {
            initialFillColor = `${ownershipColorMap.get(key)}E6`; // Use 90% opacity fill
        }
        polygon.options.set('fillColor', initialFillColor); // Set initial color
    });

    updateOwnershipLegend(uniqueOwnershipCombinations); // Update the new legend
    if (ownershipLegendDiv) ownershipLegendDiv.style.display = 'block'; // Show the new legend
    // Hide other legends
    if (costLegendDiv) costLegendDiv.style.display = 'none';
    if (vriLegendDiv) vriLegendDiv.style.display = 'none';

    // Re-apply filter AFTER setting initial colors and showing legend
    applyOwnershipFilter();
}

function updateOwnershipLegend(ownershipMapWithColors) { // Expects Map<"Ownership|RightType", colorHex>
    if (!ownershipLegendDiv) return;
    const list = document.getElementById('ownership-legend-list');
    if (!list) return;
    list.innerHTML = ''; // Clear previous items

    if (!ownershipMapWithColors || ownershipMapWithColors.size === 0) {
        ownershipLegendDiv.style.display = 'none';
        return;
    }

    // Convert Map entries to an array, sort by the key ("Ownership|RightType")
    const sortedOwnershipArray = Array.from(ownershipMapWithColors.entries()).sort((a, b) => {
        return a[0].localeCompare(b[0], 'ru', { sensitivity: 'base' });
    });

    // Iterate over the SORTED array
    sortedOwnershipArray.forEach(([key, colorHex]) => {
        const [ownership, rightType] = key.split('|'); // Split the key back
        const li = document.createElement('li');
        li.dataset.ownershipKey = key; // Store the key for filtering

        const colorBox = document.createElement('span');
        colorBox.className = 'legend-color-box';
        colorBox.style.backgroundColor = colorHex || '#cccccc';

        const text = document.createElement('span');
        // Display format: "Муниципальная | Собственность"
        text.textContent = `${ownership} | ${rightType}`;
        text.style.fontSize = '11px'; // Make text slightly smaller if needed

        li.appendChild(colorBox);
        li.appendChild(text);
        list.appendChild(li);
    });

    ownershipLegendDiv.style.display = 'block'; // Ensure legend is visible
    // Hide other legends
    if (costLegendDiv) costLegendDiv.style.display = 'none';
    if (vriLegendDiv) vriLegendDiv.style.display = 'none';
}


function applyCostTheme() {
    let minCost = Infinity, maxCost = -Infinity, hasCostData = false;
    const polygonsToStyle = []; // Collect relevant polygons first

    console.log("Applying Cost Theme. Total objects to check:", polygons.length);

    // --- First Pass: Collect data and find global min/max ---
    polygons.forEach(obj => {
        // Check if it's a polygon representing a land parcel (loaded via quarter or area search)
        if (obj instanceof ymaps.Polygon && (obj.properties?.get('isParcelInQuarter') || obj.properties?.get('isFoundInArea'))) {
            polygonsToStyle.push(obj);
            const cost = obj.properties.get('costIndex'); // Get stored cost
            // No need to re-fetch from featureData here if it was stored correctly
            if (cost !== null && isFinite(cost)) {
                minCost = Math.min(minCost, cost);
                maxCost = Math.max(maxCost, cost);
                hasCostData = true;
            }
        }
        // Optional: Reset non-parcel polygons or handle labels if needed
         else if (obj instanceof ymaps.Placemark && obj.options?.get('iconLayout') === customPlacemarkLayout) {
             // Ensure labels are visible based on zoom, regardless of theme
             obj.options.set('visible', map.getZoom() > 14);
         }
    });

    if (!hasCostData || !isFinite(minCost) || !isFinite(maxCost)) {
        console.warn("Нет данных о стоимости для градиента или диапазон некорректен.");
        polygonsToStyle.forEach(p => p.options.set('fillColor', '#00000000')); // Reset fill
        updateCostLegend(null, null); // Hide legend
        return;
    }

    const costRange = maxCost - minCost;

    console.log(`Global Cost Range: min=${minCost}, max=${maxCost}, range=${costRange}`);

    // --- Second Pass: Apply colors based on global range ---
    polygonsToStyle.forEach(polygon => {
        const cost = polygon.properties.get('costIndex');
        let fillColor = '#00000000'; // Default transparent

        if (cost !== null && isFinite(cost)) {
            let opacity = 0;
            if (costRange <= 0) { // Handle single value or invalid range
                opacity = 0.5; // Use a fixed medium opacity
            } else {
                const norm = (cost - minCost) / costRange;
                opacity = 0.1 + norm * 0.8; // Opacity from 10% to 90%
            }
            const opacityHex = Math.round(opacity * 255).toString(16).padStart(2, '0');
            fillColor = `${polygonStyle.thematicCostColor}${opacityHex}`;
        }
        polygon.options.set('fillColor', fillColor);
    });

    updateCostLegend(minCost, maxCost);
    if (costLegendDiv) costLegendDiv.style.display = 'block'; // Ensure legend is visible
    if (vriLegendDiv) vriLegendDiv.style.display = 'none';
}

// Function to calculate similarity between two strings based on common characters
function calculateStringSimilarity(str1, str2) {
    if (!str1 || !str2) return 0;
    
    str1 = str1.toLowerCase();
    str2 = str2.toLowerCase();
    
    // Count common characters with their positions
    let commonChars = 0;
    const minLength = Math.min(str1.length, str2.length);
    
    // Count exact character matches
    for (let i = 0; i < minLength; i++) {
        if (str1[i] === str2[i]) {
            commonChars += 2; // Give more weight to characters in same position
        }
    }
    
    // Count characters that appear in both strings
    const set1 = new Set(str1.split(''));
    const set2 = new Set(str2.split(''));
    
    let intersection = 0;
    for (const char of set1) {
        if (set2.has(char) && char.trim() !== '') {
            intersection++;
        }
    }
    
    const union = set1.size + set2.size - intersection;
    const jaccardSimilarity = intersection / union;
    
    // Combine both metrics for better similarity detection
    return (jaccardSimilarity + (commonChars / (str1.length + str2.length))) / 2;
}

// Function to group similar VRIs
function groupSimilarVRIs(allVris) {
    const groups = [];
    const processed = new Set();
    
    // Convert Set to Array for easier manipulation
    const vrisArray = Array.from(allVris);
    
    for (let i = 0; i < vrisArray.length; i++) {
        if (processed.has(vrisArray[i])) continue;
        
        const currentGroup = [vrisArray[i]];
        processed.add(vrisArray[i]);
        
        for (let j = 0; j < vrisArray.length; j++) {
            if (i === j || processed.has(vrisArray[j])) continue;
            
            const similarity = calculateStringSimilarity(vrisArray[i], vrisArray[j]);
            if (similarity > 0.4) { // Threshold for grouping
                currentGroup.push(vrisArray[j]);
                processed.add(vrisArray[j]);
            }
        }
        
        groups.push(currentGroup);
    }
    
    return groups;
}

// Function to generate a base color for a group
function generateBaseColorForGroup(group, groupIndex, totalGroups) {
    // Distribute base colors evenly across the hue spectrum
    const hue = Math.floor((groupIndex / totalGroups) * 360);
    return hue;
}

// Function to generate a color based on VRI similarity
function generateSimilarityBasedColor(vriString, allVris, vriGroups, groupColors) {
    if (!vriString) {
        return '#cccccc'; // Default color for null/empty VRI
    }
    
    // Find which group this VRI belongs to
    let groupIndex = -1;
    let positionInGroup = 0;
    
    for (let i = 0; i < vriGroups.length; i++) {
        const position = vriGroups[i].indexOf(vriString);
        if (position !== -1) {
            groupIndex = i;
            positionInGroup = position;
            break;
        }
    }
    
    if (groupIndex === -1) {
        // If not found in any group, use default color generation
        const hash = simpleStringHash(vriString);
        const hue = hash % 360;
        const saturation = 70 + (hash % 31);
        const lightness = 55 + (hash % 16);
        return hslToHex(hue, saturation, lightness);
    }
    
    // Use the group's base hue
    const baseHue = groupColors[groupIndex];
    
    // Adjust saturation and lightness based on position in group
    const groupSize = vriGroups[groupIndex].length;
    const saturation = 70 + (positionInGroup % 3) * 10;
    const lightness = 55 - (positionInGroup % 5) * 3;
    
    return hslToHex(baseHue, saturation, lightness);
}

// Function to convert HSL color values to Hex format
function hslToHex(h, s, l) {
    l /= 100;
    const a = s * Math.min(l, 1 - l) / 100;
    const f = n => {
        const k = (n + h / 30) % 12;
        const color = l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);
        return Math.round(255 * color).toString(16).padStart(2, '0');
    };
    return `#${f(0)}${f(8)}${f(4)}`;
}

// Function to generate a simple hash from a string
function simpleStringHash(str) {
    let hash = 0;
    if (str.length === 0) {
        return hash;
    }
    for (let i = 0; i < str.length; i++) {
        const char = str.charCodeAt(i);
        hash = ((hash << 5) - hash) + char;
        hash |= 0; // Convert to 32bit integer
    }
    return Math.abs(hash); // Use absolute value for positive numbers
}

// Function to map a VRI string to a deterministic, bright hex color
function stringToColor(vriString, allVris, vriGroups, groupColors) {
    return generateSimilarityBasedColor(vriString, allVris, vriGroups, groupColors);
}

function applyUseTheme() {
    const polygonsToStyle = [];
    const uniqueVRIs = new Map(); // Map to store unique VRIs and their assigned colors
    const allVriStrings = new Set(); // Collect all VRI strings first
    
    // First pass: collect all VRI strings
    polygons.forEach(obj => {
        if (obj instanceof ymaps.Polygon && (obj.properties?.get('isParcelInQuarter') || obj.properties?.get('isFoundInArea'))) {
            const vri = obj.properties.get('vri');
            if (vri) {
                allVriStrings.add(vri);
            }
        }
    });
    
    // Group similar VRIs
    const vriGroups = groupSimilarVRIs(allVriStrings);
    
    // Generate base colors for each group
    const groupColors = vriGroups.map((group, index) => 
        generateBaseColorForGroup(group, index, vriGroups.length)
    );
    
    // Second pass: assign colors based on similarity groups
    polygons.forEach(obj => {
        if (obj instanceof ymaps.Polygon && (obj.properties?.get('isParcelInQuarter') || obj.properties?.get('isFoundInArea'))) {
            polygonsToStyle.push(obj);
            const vri = obj.properties.get('vri');
            if (vri) {
                if (!vriColorMap.has(vri)) {
                    vriColorMap.set(vri, stringToColor(vri, allVriStrings, vriGroups, groupColors));
                }
                uniqueVRIs.set(vri, vriColorMap.get(vri));
            } else {
                if (!vriColorMap.has('(Не указано)')) {
                    vriColorMap.set('(Не указано)', '#cccccc'); // Gray for unspecified VRI
                }
                uniqueVRIs.set('(Не указано)', vriColorMap.get('(Не указано)'));
            }
        }
        else if (obj instanceof ymaps.Placemark && obj.options?.get('iconLayout') === customPlacemarkLayout) {
            obj.options.set('visible', map.getZoom() > 14);
        }
    });

    polygonsToStyle.forEach(polygon => {
        const vri = polygon.properties.get('vri');
        const colorKey = vri || '(Не указано)'; // Use the VRI or the 'unspecified' key
        let initialFillColor = '#00000000'; // Default transparent for initial setup before filter
        if (vriColorMap.has(colorKey)) {
            initialFillColor = `${vriColorMap.get(colorKey)}E6`; // Use 90% opacity fill
        }
        polygon.options.set('fillColor', initialFillColor); // Set initial color
    });

    updateVriLegend(uniqueVRIs); // Pass the map of unique VRIs and their colors
    if (vriLegendDiv) vriLegendDiv.style.display = 'block';
    if (costLegendDiv) costLegendDiv.style.display = 'none';

    // Re-apply filter AFTER setting initial colors and showing legend
    applyVriFilter();
}

function resetThemeVisuals() {
    polygons.forEach(obj => {
        if (obj instanceof ymaps.Polygon && (obj.properties?.get('isParcelInQuarter') || obj.properties?.get('isFoundInArea'))) {
            obj.options.set('fillColor', '#00000000');
        }
        else if (obj instanceof ymaps.Placemark && obj.options?.get('iconLayout') === customPlacemarkLayout) {
            obj.options.set('visible', map.getZoom() > 14);
        }
    });
    hideLegends();
    vriColorMap.clear();
    ownershipColorMap.clear();
    registrationDateColorMap.clear();
    uluColorMap.clear();
    resetSidebarUluInfo(); // Добавлено для сброса ЕЗП в сайдбаре
}




function hideLegends() {
    if (costLegendDiv) costLegendDiv.style.display = 'none';
    if (vriLegendDiv) vriLegendDiv.style.display = 'none';
    if (ownershipLegendDiv) ownershipLegendDiv.style.display = 'none';
    if (registrationDateLegendDiv) registrationDateLegendDiv.style.display = 'none';
    if (uluLegendDiv) uluLegendDiv.style.display = 'none';
}

        function updateCostLegend(min, max) {
             if (!costLegendDiv) return;
             if (min === null || max === null || !isFinite(min) || !isFinite(max)) {
                 costLegendDiv.style.display = 'none';
                 return;
             }
             const minSpan = document.getElementById('legend-min-cost');
             const maxSpan = document.getElementById('legend-max-cost');
             const gradientDiv = costLegendDiv.querySelector('.legend-gradient');

             if (minSpan) minSpan.textContent = Math.round(min).toLocaleString('ru-RU');
             if (maxSpan) maxSpan.textContent = Math.round(max).toLocaleString('ru-RU');
             if (gradientDiv) gradientDiv.style.background = `linear-gradient(to right, ${polygonStyle.thematicCostColor}1A, ${polygonStyle.thematicCostColor}E6)`; // 10% to 90%

             costLegendDiv.style.display = 'block';
             if (vriLegendDiv) vriLegendDiv.style.display = 'none';
        }

               function updateVriLegend(vriMapWithColors) { // Expects Map<vri, color>
             if (!vriLegendDiv) return;
             const list = document.getElementById('vri-legend-list');
             if (!list) return;
             list.innerHTML = ''; // Clear previous items

             if (!vriMapWithColors || vriMapWithColors.size === 0) {
                 vriLegendDiv.style.display = 'none';
                 return;
             }

             // --- START SORTING ---
             // Convert Map entries to an array, sort by VRI name (key)
             const sortedVriArray = Array.from(vriMapWithColors.entries()).sort((a, b) => {
                 const vriA = a[0] || ''; // Handle null/undefined VRI
                 const vriB = b[0] || '';
                 return vriA.localeCompare(vriB, 'ru', { sensitivity: 'base' }); // Case-insensitive Russian sorting
             });
             // --- END SORTING ---

             // --- Iterate over the SORTED array ---
             sortedVriArray.forEach(([vri, colorHex]) => { // Destructure the sorted array entry
                const li = document.createElement('li');
                const colorBox = document.createElement('span');
                colorBox.className = 'legend-color-box';
                colorBox.style.backgroundColor = colorHex || '#cccccc'; // Fallback color
                const text = document.createElement('span');
                text.textContent = vri || '(Не указано)';
                li.appendChild(colorBox);
                li.appendChild(text);
                list.appendChild(li);
             });
             // --- End iteration ---

             vriLegendDiv.style.display = 'block';
             if (costLegendDiv) costLegendDiv.style.display = 'none';
        }

        // Helper Functions (copy if not present)
         function hslToHex(h, s, l) {
             l /= 100;
             const a = s * Math.min(l, 1 - l) / 100;
             const f = n => {
                 const k = (n + h / 30) % 12;
                 const color = l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);
                 return Math.round(255 * color).toString(16).padStart(2, '0');
             };
             return `#${f(0)}${f(8)}${f(4)}`;
         }

         function getRandomBrightHexColor() {
             const h = Math.floor(Math.random() * 360);         // Hue (0-359)
             const s = 70 + Math.floor(Math.random() * 31);    // Saturation (70-100) - quite saturated
             const l = 55 + Math.floor(Math.random() * 16);    // Lightness (55-70) - not too light, not too dark
             return hslToHex(h, s, l);
         }
        // --- End Core Theme Functions ---

// Вспомогательная функция для проверки, является ли ЗУ декларированным
function isDeclared(polygon) {
    const featureData = polygon.properties.get('featureData');
    if (!featureData) return false;
    const opts = featureData.properties.options || {};
    return !opts.specified_area && !opts.land_record_area_verified && (opts.declared_area || opts.land_record_area_declaration || opts.land_record_area);
}


// ЗАМЕНИТЕ ЭТУ ФУНКЦИЮ ПОЛНОСТЬЮ
async function drawAllObjectsToCanvas(mainObject, otherObjects, showPoints = true, underlyingParcels = []) {
    const canvasWidth = 800;
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    const padding = 40;
    
    const destSc = localStorage.getItem('savedDefaultMskSystem') || 'EPSG:6331602';
    const destSystem = COORDINATE_SYSTEMS.find(s => s.value === destSc);
    if (!destSystem) throw new Error(`Определение для ${destSc} не найдено.`);
    const isAutoLoadEnabled = (localStorage.getItem('autoLoadMskOffset') !== 'false');
    const mskOffsetX = isAutoLoadEnabled ? (destSystem.offsetX || 0) : (parseFloat((localStorage.getItem('savedMskOffsetX') || '0').replace(',', '.')) || 0);
    const mskOffsetY = isAutoLoadEnabled ? (destSystem.offsetY || 0) : (parseFloat((localStorage.getItem('savedMskOffsetY') || '0').replace(',', '.')) || 0);

    const underlyingCadNumbers = new Set(underlyingParcels.map(f => f.properties.descr));

    const processObject = (obj) => {
        if (!obj || !(obj instanceof ymaps.Polygon)) return null;
        const cadNum = obj.properties.get('cadastralNumber') || 'Объект';
        const featureData = obj.properties.get('featureData');
        const isBuilding = obj.properties.get('isBuilding') || (featureData && featureData.properties.categoryName === 'Здания');
        const isStructure = obj.properties.get('isStructure') || (featureData && featureData.properties.categoryName === 'Сооружения');
        let type = 'ЗУ';
        let color = isDeclared(obj) ? polygonStyle.declaredParcelsColor : polygonStyle.parcelsColor;

        if (isBuilding) { type = 'Здание'; color = polygonStyle.buildingsColor; } 
        else if (isStructure) { type = 'Сооружение'; color = polygonStyle.structuresColor; }
        
        if (underlyingCadNumbers.has(cadNum)) { color = '#FFA500'; }

        const rings = obj.geometry.getCoordinates();
        const projectedRings = rings.map(ring => {
            return ring.map(coord => {
                const trueLat = coord[0] + (mapOffsetY * 0.000008983);
                const trueLon = coord[1] + (mapOffsetX * 0.000008983);
                const projected = proj4('EPSG:4326', 'EPSG:3857', [trueLon, trueLat]);
                return { projected, original: coord };
            });
        });
        return { name: cadNum, type, color, projectedRings };
    };
    
    const mainObjectClean = new ymaps.Polygon(mainObject.geometry.getCoordinates().map(ring => {
        return ring.map(coord => [ coord[0] + (mapOffsetY * 0.000008983), coord[1] + (mapOffsetX * 0.000008983) ]);
    }), { ...mainObject.properties.getAll() });

    const mainObjectInfo = processObject(mainObjectClean);
    const otherObjectsInfo = otherObjects.map(obj => processObject(obj)).filter(Boolean);
    const objectDrawInfo = [mainObjectInfo, ...otherObjectsInfo].filter(Boolean);

    let bboxCoords = [];
    if (mainObjectInfo && mainObjectInfo.projectedRings) {
        mainObjectInfo.projectedRings.forEach(ring => ring.forEach(p => bboxCoords.push(p.projected)));
    }
    
    if (bboxCoords.length === 0) { return { image: null, coordsTable: '' }; }

    const minX = Math.min(...bboxCoords.map(p => p[0]));
    const maxX = Math.max(...bboxCoords.map(p => p[0]));
    const minY = Math.min(...bboxCoords.map(p => p[1]));
    const maxY = Math.max(...bboxCoords.map(p => p[1]));
    
    const projectedWidth = maxX - minX;
    const projectedHeight = maxY - minY;
    
    const effectiveWidth = projectedWidth > 0 ? projectedWidth : 1;
    
    const scale = (canvasWidth - padding * 2) / effectiveWidth;
    canvas.width = canvasWidth;
    canvas.height = projectedHeight * scale + padding * 2;
    
    const cOffsetX = (canvas.width - projectedWidth * scale) / 2;
    const cOffsetY = (canvas.height - projectedHeight * scale) / 2;
    
    ctx.fillStyle = '#FFFFFF';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    let allTablesHtml = '';
    const drawnLabelBounds = [];

    objectDrawInfo.forEach(info => {
        const { projectedRings, color, name, type } = info;
        let pointCounterForObject = 1;
        let currentObjectTableBody = '';

        projectedRings.forEach(ring => {
            ctx.beginPath();
            let canvasPoints = [];

            ring.forEach((pointData, index) => {
                const { projected, original } = pointData;
                const x = cOffsetX + (projected[0] - minX) * scale;
                const y = canvas.height - (cOffsetY + (projected[1] - minY) * scale);
                
                canvasPoints.push({x, y});
                
                if (index === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);

                const mskCoords = convertWgs84ToMskWithOffset([[original[1], original[0]]], destSc, destSystem.def, mskOffsetX, mskOffsetY).split('\t');
                
                if (showPoints) {
                    ctx.fillStyle = '#000000';
                    ctx.fillRect(x - 2, y - 2, 4, 4);
                    ctx.font = '10px Arial';
                    ctx.fillText(`${pointCounterForObject}`, x + 5, y - 5);
                    currentObjectTableBody += `<tr><td>${pointCounterForObject}</td><td>${mskCoords[0]}</td><td>${mskCoords[1]}</td></tr>`;
                } else {
                    currentObjectTableBody += `<tr><td>${mskCoords[0]}</td><td>${mskCoords[1]}</td></tr>`;
                }
                pointCounterForObject++;
            });

            ctx.closePath();
            ctx.strokeStyle = color;
            ctx.lineWidth = 2;
            ctx.stroke();
            ctx.fillStyle = `${color}33`;
            ctx.fill();
            
            if (name && name !== 'Объект') {
                ctx.fillStyle = '#000000';
                ctx.font = 'bold 12px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                
                const textMetrics = ctx.measureText(name);
                const labelWidth = textMetrics.width + 10;
                const labelHeight = 12 + 10;

                const isOverlapping = (x, y) => {
                    const newLabelBox = { left: x - labelWidth / 2, right: x + labelWidth / 2, top: y - labelHeight / 2, bottom: y + labelHeight / 2 };
                    for (const box of drawnLabelBounds) {
                        if (newLabelBox.left < box.right && newLabelBox.right > box.left && newLabelBox.top < box.bottom && newLabelBox.bottom > box.top) return true;
                    }
                    return false;
                };

                const visiblePoints = canvasPoints.filter(p => p.x >= 0 && p.x <= canvas.width && p.y >= 0 && p.y <= canvas.height);
                if (visiblePoints.length === 0) return;

                const visMinX = Math.min(...visiblePoints.map(p => p.x));
                const visMaxX = Math.max(...visiblePoints.map(p => p.x));
                const visMinY = Math.min(...visiblePoints.map(p => p.y));
                const visMaxY = Math.max(...visiblePoints.map(p => p.y));
                const centerX = (visMinX + visMaxX) / 2;
                const centerY = (visMinY + visMaxY) / 2;

                let anchorPoint = { x: centerX, y: centerY };
                
                // --- НОВАЯ УЛУЧШЕННАЯ ЛОГИКА ---
                const isSkinny = (visMaxX - visMinX < labelWidth / 2) || (visMaxY - visMinY < labelHeight / 2);

                if (isSkinny && visiblePoints.length > 1) {
                    // Для тонких объектов ищем ближайшую ВИДИМУЮ точку на контуре к центру видимой части
                    let closestVisiblePoint = visiblePoints[0];
                    let minDistance = Infinity;
                    visiblePoints.forEach(p => {
                        const dist = Math.sqrt(Math.pow(p.x - centerX, 2) + Math.pow(p.y - centerY, 2));
                        if (dist < minDistance) {
                            minDistance = dist;
                            closestVisiblePoint = p;
                        }
                    });
                    anchorPoint = closestVisiblePoint; // Эта точка станет "якорем" для выноски
                }
                // --- КОНЕЦ НОВОЙ ЛОГИКИ ---

                const offsets = [ { x: 0, y: 0 }, { x: 0, y: -25 }, { x: 0, y: 25 }, { x: -60, y: 0 }, { x: 60, y: 0 }, { x: 60, y: -25 }, { x: -60, y: -25 }];
                let finalX, finalY;
                for (const offset of offsets) {
                    let testX = anchorPoint.x + offset.x;
                    let testY = anchorPoint.y + offset.y;
                    testX = Math.max(labelWidth / 2, Math.min(testX, canvas.width - labelWidth / 2));
                    testY = Math.max(labelHeight / 2, Math.min(testY, canvas.height - labelHeight / 2));

                    if (!isOverlapping(testX, testY)) {
                        finalX = testX;
                        finalY = testY;
                        break;
                    }
                }
                
                if (finalX !== undefined) {
                    // Рисуем выноску, если подпись была сдвинута от якорной точки
                    if (isSkinny || Math.hypot(finalX - anchorPoint.x, finalY - anchorPoint.y) > 5) {
                         ctx.beginPath();
                         ctx.moveTo(anchorPoint.x, anchorPoint.y);
                         ctx.lineTo(finalX, finalY);
                         ctx.strokeStyle = 'rgba(0,0,0,0.6)';
                         ctx.lineWidth = 1;
                         ctx.stroke();
                    }

                    ctx.strokeStyle = 'white';
                    ctx.lineWidth = 3;
                    ctx.strokeText(name, finalX, finalY);
                    ctx.fillText(name, finalX, finalY);
                    drawnLabelBounds.push({ left: finalX - labelWidth / 2, right: finalX + labelWidth / 2, top: finalY - labelHeight / 2, bottom: finalY + labelHeight / 2 });
                }
            }
        });
        
        if (currentObjectTableBody) {
            const tableHeaders = showPoints 
                ? '<thead><tr><th>Номер точки</th><th>X (МСК)</th><th>Y (МСК)</th></tr></thead>'
                : '<thead><tr><th>X (МСК)</th><th>Y (МСК)</th></tr></thead>';

            allTablesHtml += `
                <div class="section-title">Каталог координат: ${name} (${type})</div>
                <table>
                    ${tableHeaders}
                    <tbody>${currentObjectTableBody}</tbody>
                </table>`;
        }
    });

    return { image: canvas.toDataURL('image/png'), coordsTable: allTablesHtml };
}

// Вспомогательная функция для создания временных полигонов Я.Карт для схемы
// (нужна для объектов, которые не были добавлены на карту, например, ОКС из отчета)
function createTemporaryYmapsPolygon(feature) {
    if (!feature?.geometry?.coordinates) return null;

    const geometryType = feature.geometry.type;
    let yandexCoordsRings = [];

    const processRings = (rings) => rings.map(ring => {
        return ring.map(coord => {
            const point = proj4('EPSG:3857', 'EPSG:4326', coord);
            return [point[1], point[0]]; // [lat, lon]
        });
    });

    if (geometryType === 'Polygon') {
        yandexCoordsRings = processRings(feature.geometry.coordinates);
    } else if (geometryType === 'MultiPolygon') {
        // Для мультиполигона пока берем только первый полигон для простоты
        yandexCoordsRings = processRings(feature.geometry.coordinates[0]);
    } else {
        return null;
    }
    
    // Определяем, является ли объект зданием или сооружением
    const isBuilding = feature.properties?.categoryName === 'Здания';
    const isStructure = feature.properties?.categoryName === 'Сооружения';

    // Создаем временный полигон, чтобы передать его в функцию отрисовки
    return new ymaps.Polygon(yandexCoordsRings, {
        cadastralNumber: feature.properties?.options?.cad_num || feature.properties?.options?.cad_number || feature.properties?.descr,
        isBuilding: isBuilding,
        isStructure: isStructure
    });
}

// Draw the searched object on the map
function drawSearchObject(geoCoordGroups) {
    const shapes = [];
    
    for (const coordGroup of geoCoordGroups) {
        const offsetCoordinates = coordGroup.map(coord => [
            coord[0] - mapOffsetY * 0.000008983,
            coord[1] - mapOffsetX * 0.000008983
        ]);
        
        if (offsetCoordinates.length === 1) {
            // Точка
            const placemark = new ymaps.Placemark(offsetCoordinates[0], {
                hintContent: 'Поисковая точка'
            }, {
                preset: 'islands#redDotIcon',
                iconColor: '#FF0000',
                zIndex: 1000
            });
            
            map.geoObjects.add(placemark);
            polygons.push(placemark);
            shapes.push(placemark);
            
        } else if (offsetCoordinates.length > 1) {
            // Проверяем, замкнутый ли это полигон
            const isClosedPolygon = offsetCoordinates.length > 2 && 
                                   Math.abs(offsetCoordinates[0][0] - offsetCoordinates[offsetCoordinates.length-1][0]) < 0.000001 &&
                                   Math.abs(offsetCoordinates[0][1] - offsetCoordinates[offsetCoordinates.length-1][1]) < 0.000001;
            
            if (isClosedPolygon) {
                // Полигон (первая и последняя точки совпадают)
                const polygon = new ymaps.Polygon([offsetCoordinates], {
                    hintContent: 'Поисковый полигон'
                }, {
                    strokeColor: '#FF0000',
                    strokeWidth: 4,
                    strokeOpacity: 0.8,
                    fillColor: '#FF000033', // Полупрозрачная заливка
                    zIndex: 900
                });
                
                map.geoObjects.add(polygon);
                polygons.push(polygon);
                shapes.push(polygon);
                
            } else {
                // Линия
                const polyline = new ymaps.Polyline(offsetCoordinates, {
                    hintContent: 'Поисковая линия'
                }, {
                    strokeColor: '#FF0000',
                    strokeWidth: 4,
                    strokeOpacity: 0.8,
                    zIndex: 900
                });
                
                map.geoObjects.add(polyline);
                polygons.push(polyline);
                shapes.push(polyline);
            }
        }
    }
    
    // Устанавливаем границы карты, чтобы вместить все фигуры
    if (shapes.length > 0) {
        let allBounds = null;
        
        shapes.forEach(shape => {
            const bounds = shape.geometry.getBounds();
            if (!allBounds) {
                allBounds = bounds;
            } else {
                allBounds = [
                    [
                        Math.min(allBounds[0][0], bounds[0][0]),
                        Math.min(allBounds[0][1], bounds[0][1])
                    ],
                    [
                        Math.max(allBounds[1][0], bounds[1][0]),
                        Math.max(allBounds[1][1], bounds[1][1])
                    ]
                ];
            }
        });
        
        if (allBounds) {
            // Немного расширяем границы для лучшего просмотра
            const latDiff = (allBounds[1][0] - allBounds[0][0]) * 0.1;
            const lonDiff = (allBounds[1][1] - allBounds[0][1]) * 0.1;
            allBounds = [
                [allBounds[0][0] - latDiff, allBounds[0][1] - lonDiff],
                [allBounds[1][0] + latDiff, allBounds[1][1] + lonDiff]
            ];
            
            map.setBounds(allBounds, {
                checkZoomRange: true,
                duration: 300
            });
        }
    }
    
    return shapes;
}


// Find cadastral parcels that overlap with the provided coordinates
async function findOverlappingParcels(geoCoordGroups) {
    const foundParcels = [];
    const processedCadastralNumbers = new Set();
    
    // For each coordinate group (point, line, or polygon)
    for (const coordGroup of geoCoordGroups) {
        // Convert the coordinates to EPSG:3857 for the NSPD API
        const epsg3857Coordinates = coordGroup.map(coord => {
            return proj4("EPSG:4326", "EPSG:3857", [coord[1], coord[0]]);
        });
        
        // Create appropriate geometry for the request
        let geometry;
        if (epsg3857Coordinates.length === 1) {
            // For a single point, create a small buffer around it
            const point = epsg3857Coordinates[0];
            const bufferSize = 0.5; // meters
            geometry = {
                "type": "Polygon",
                "coordinates": [[
                    [point[0] - bufferSize, point[1] - bufferSize],
                    [point[0] - bufferSize, point[1] + bufferSize],
                    [point[0] + bufferSize, point[1] + bufferSize],
                    [point[0] + bufferSize, point[1] - bufferSize],
                    [point[0] - bufferSize, point[1] - bufferSize]
                ]]
            };
        } else if (epsg3857Coordinates.length === 2) {
            // For a line with two points, create a small buffer
            const lineString = turf.lineString(epsg3857Coordinates.map(coord => [coord[0], coord[1]]));
            const buffered = turf.buffer(lineString, 1, { units: 'meters' });
            geometry = {
                "type": "Polygon",
                "coordinates": buffered.geometry.coordinates
            };
        } else {
            // For lines with more points or polygons
            if (
                epsg3857Coordinates.length > 2 && 
                epsg3857Coordinates[0][0] === epsg3857Coordinates[epsg3857Coordinates.length-1][0] && 
                epsg3857Coordinates[0][1] === epsg3857Coordinates[epsg3857Coordinates.length-1][1]
            ) {
                // Polygon (first and last points match)
                geometry = {
                    "type": "Polygon",
                    "coordinates": [epsg3857Coordinates]
                };
            } else {
                // Line with multiple points
                const lineString = turf.lineString(epsg3857Coordinates.map(coord => [coord[0], coord[1]]));
                const buffered = turf.buffer(lineString, 1, { units: 'meters' });
                geometry = {
                    "type": "Polygon",
                    "coordinates": buffered.geometry.coordinates
                };
            }
        }
        
        // Make the request to NSPD API
        const requestBody = {
            "geom": {
                "type": "FeatureCollection",
                "features": [{
                    "type": "Feature",
                    "geometry": {
                        "crs": {
                            "type": "name",
                            "properties": {
                                "name": "EPSG:3857"
                            }
                        },
                        ...geometry
                    },
                    "properties": {}
                }]
            },
            "categories": [{"id": 36368}] // Land parcels category
        };
        
        try {
          const response = await fetchNspd('https://nspd.gov.ru/api/geoportal/v1/intersects?typeIntersect=fullObject', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(requestBody)
            });
            
            const data = await response.json();
            
            if (data && data.features && data.features.length > 0) {
                for (const feature of data.features) {
                    // Skip duplicates
                    if (processedCadastralNumbers.has(feature.properties.descr)) {
                        continue;
                    }
                    
                    processedCadastralNumbers.add(feature.properties.descr);
                    foundParcels.push(feature);
                }
            }
        } catch (error) {
            console.error('Error fetching parcels from NSPD:', error);
        }
    }
    
    return foundParcels;
}

function handleExportAction() {
    let somethingWasExported = false;

    if (parcelFeaturesData && parcelFeaturesData.length > 0) {
        exportParcelsToExcel(); // Вызываем экспорт ЗУ
        somethingWasExported = true;
    }

  if (buildingFeaturesData && buildingFeaturesData.length > 0) { // ИЗМЕНЕНО
        exportBuildingsToExcel(); // ИЗМЕНЕНО
        somethingWasExported = true;
    }
    
     if (structureFeaturesData && structureFeaturesData.length > 0) {
        exportStructuresToExcel(); // Вызываем экспорт Сооружений
        somethingWasExported = true;
    }
    
     if (zouitFeaturesData && zouitFeaturesData.length > 0) {
        exportZouitsToExcel();
        somethingWasExported = true;
    }

    if (!somethingWasExported) {
        showNotification('Нет данных для экспорта. Сначала загрузите участки или ОКС в квартале.', 'warning', 'exclamation-triangle');
    }
}

/**
 * Новая функция для экспорта данных ОКС в Excel.
 */
function exportBuildingsToExcel() {
    showLoader('Подготовка данных Зданий для экспорта...');

    try {
        const dataForSheet = [];
        const headers = [
            "Кадастровый номер", "Наименование", "Адрес", "Площадь (м²)", "Назначение", 
            "Год постройки", "Материал стен", "Этажность", "Стоимость (полная)", 
            "Форма собственности", "Тип права", "Дата внесения"
        ];
        dataForSheet.push(headers);

        buildingFeaturesData.forEach(feature => {
            const properties = feature.properties || {};
            const options = properties.options || {};
            
            const cadNumber = options.cad_num || properties.descr || 'Не указан';
            const name = properties.descr || 'Не указан';
            const address = options.readable_address || 'Не указан';
            const areaValue = (options.build_record_area && isFinite(parseFloat(options.build_record_area))) ? parseFloat(options.build_record_area) : 'Не указана';
            const purpose = options.purpose || options.building_name || 'Не указано';
            const yearBuilt = options.year_built || 'Не указан';
            const materials = options.materials || 'Не указан';
            const floors = options.floors || 'Не указан';
            const fullCost = (options.cost_value && isFinite(parseFloat(options.cost_value))) ? parseFloat(options.cost_value) : 'Не указана';
            const ownership = options.ownership_type || 'Не указана';
            const rightType = options.right_type || 'Не указана';
            const registrationDate = options.build_record_registration_date || 'Не указана';

            const row = [
                cadNumber, name, address, areaValue, purpose, yearBuilt, 
                materials, floors, fullCost, ownership, rightType, registrationDate
            ];
            dataForSheet.push(row);
        });

        const wb = XLSX.utils.book_new();
        const ws = XLSX.utils.aoa_to_sheet(dataForSheet);

        const wscols = [ {wch:20}, {wch:30}, {wch:50}, {wch:15}, {wch:20}, {wch:15}, {wch:20}, {wch:12}, {wch:18}, {wch:20}, {wch:20}, {wch:20} ];
        ws['!cols'] = wscols;

        XLSX.utils.book_append_sheet(wb, ws, "Здания");
        XLSX.writeFile(wb, "Найденные_Здания.xlsx");

        showNotification('Данные Зданий успешно экспортированы в Excel', 'success', 'check-circle');

    } catch (error) {
        console.error('Ошибка при экспорте данных Зданий:', error);
        showNotification('Ошибка при экспорте данных Зданий в Excel', 'error', 'exclamation-circle');
    } finally {
        hideLoader();
    }
}



async function exportParcelsToExcel() { // <-- Добавлено async
    // Начальная проверка на данные уже сделана в handleExportAction
    showLoader('Подготовка данных ЗУ для экспорта...');

    try {
        const dataForSheet = [];
        const headers = [
            "Кадастровый номер", "Адрес", "Площадь (м²)", "Тип площади",
            "Стоимость (руб./м²)", "Стоимость (полная)", "Вид разрешенного использования",
            "Категория земель", "Статус", "Дата внесения", "Форма собственности", "Тип права"
        ];
        dataForSheet.push(headers);

        parcelFeaturesData.forEach(feature => {
            const properties = feature.properties || {};
            const options = properties.options || {};
            const areaInfo = getAreaInfo(options);
            const areaValue = (areaInfo.value !== null && !isNaN(areaInfo.value)) ? areaInfo.value : 'Не указана';
            const areaType = areaInfo.type;
            const cadastralNumber = properties.descr || 'Не указан';
            const address = options.readable_address || 'Не указан';
            let costIndex = 'Не указана';
            if (options.cost_index !== undefined && options.cost_index !== null && isFinite(parseFloat(options.cost_index))) {
                costIndex = Math.round(parseFloat(options.cost_index));
            }
            const fullCost = options.cost_value !== undefined && options.cost_value !== null && isFinite(parseFloat(options.cost_value))
                ? parseFloat(options.cost_value)
                : 'Не указана';
            const vri = options.permitted_use_established_by_document || 'Не указан';
            const category = options.land_record_category_type || 'Не указана';
            const status = options.status || 'Не указан';
            const registrationDate = options.land_record_reg_date || 'Не указана';
            const ownership = options.ownership_type || 'Не указана';
            const rightType = options.right_type || 'Не указана';

            const row = [
                cadastralNumber, address, areaValue, areaType, costIndex, fullCost,
                vri, category, status, registrationDate, ownership, rightType
            ];
            dataForSheet.push(row);
        });

        // --- НАЧАЛО ИЗМЕНЕНИЙ ---

        // 1. Преобразуем массив данных в строку с разделителями-табуляцией
        const textToCopy = dataForSheet.map(row => row.join('\t')).join('\n');

        // 2. Копируем подготовленный текст в буфер обмена
        try {
            await navigator.clipboard.writeText(textToCopy);
            showNotification('Данные таблицы скопированы в буфер обмена', 'success', 'check-circle');
        } catch (err) {
            console.error('Ошибка копирования данных таблицы:', err);
            showNotification('Ошибка копирования данных', 'error', 'exclamation-triangle');
        }
        // --- КОНЕЦ ИЗМЕНЕНИЙ ---


        // Логика создания Excel файла остается без изменений
        const wb = XLSX.utils.book_new();
        const ws = XLSX.utils.aoa_to_sheet(dataForSheet);
        const wscols = [ { wch: 20 }, { wch: 50 }, { wch: 15 }, { wch: 18 }, { wch: 15 }, { wch: 18 }, { wch: 30 }, { wch: 30 }, { wch: 20 }, { wch: 20 }, { wch: 20 }, { wch: 20 } ];
        ws['!cols'] = wscols;

        XLSX.utils.book_append_sheet(wb, ws, "Участки");
        XLSX.writeFile(wb, "Найденные_участки.xlsx");

        showNotification('Данные ЗУ успешно экспортированы в Excel', 'success', 'check-circle');
        
        // --- ИЗМЕНЕНИЕ ФАЙЛА ДЛЯ ОТКРЫТИЯ ---
        window.open('format.html', '_blank');

    } catch (error) {
        console.error('Ошибка при экспорте данных ЗУ:', error);
        showNotification('Ошибка при экспорте данных ЗУ в Excel', 'error', 'exclamation-circle');
    } finally {
        hideLoader();
    }
}

// Draw found parcels on the map
async function drawFoundParcels(parcels, markAsFoundInArea = false) {
    let combinedBounds = null;
    const drawnParcelObjects = []; // Keep track of objects drawn in this call

    // --- Clear Previous Objects Marked as 'isFoundInArea' ---
    if (markAsFoundInArea) {
        const objectsToRemove = [];
        polygons.forEach((obj) => {
            // Check if the flag exists and is explicitly true
            if (obj?.properties?.get('isFoundInArea') === true) {
                objectsToRemove.push(obj);
            }
        });
        objectsToRemove.forEach(obj => {
            if (map?.geoObjects.indexOf(obj) !== -1) map.geoObjects.remove(obj);
            polygons = polygons.filter(p => p !== obj);
            if (obj instanceof ymaps.Placemark) {
                parcelPlacemarks = parcelPlacemarks.filter(pm => pm !== obj);
            }
        });
        console.log(`Removed ${objectsToRemove.length} previous 'isFoundInArea' objects.`);
    }

    // --- Process and Draw New Parcels ---
    for (const feature of parcels) {
        try {
            if (!feature?.properties?.descr || !feature?.geometry?.coordinates) {
                 console.warn("Skipping feature due to missing properties or geometry:", feature);
                 continue;
            }

            const geometryType = feature.geometry.type;
            let allContours = [];
            if (geometryType === 'Polygon' && feature.geometry.coordinates?.[0]) { allContours = [feature.geometry.coordinates[0]]; }
            else if (geometryType === 'MultiPolygon' && Array.isArray(feature.geometry.coordinates)) { feature.geometry.coordinates.forEach(poly => { if (Array.isArray(poly?.[0])) allContours.push(poly[0]) }); }
            else { continue; } // Skip unsupported or empty geometries

            for (const contour of allContours) {
                 if (!Array.isArray(contour) || contour.length < 3) { continue; } // Skip invalid contours

                 // --- Coordinate Conversion ---
                 const coordinates = contour.map(coord => {
                     if (!Array.isArray(coord) || coord.length !== 2 || typeof coord[0] !== 'number' || typeof coord[1] !== 'number') return null;
                     try { const p = proj4('EPSG:3857', 'EPSG:4326', coord); return (!p || !isFinite(p[0]) || !isFinite(p[1])) ? null : [p[1], p[0]]; } catch { return null; }
                 }).filter(p => p !== null);
                 if (coordinates.length < 3) { continue; } // Need at least 3 valid points
                 const offsetCoordinates = coordinates.map(coord => [coord[0] - mapOffsetY * 0.000008983, coord[1] - mapOffsetX * 0.000008983]);

                 // --- Extract Properties ---
                 const cadastralNumber = feature.properties.descr;
                 const parcelOptions = feature.properties.options || {};
                 const address = parcelOptions.readable_address || 'Адрес не указан';
                 const areaText = getAreaText(parcelOptions); // Assumes getAreaText helper exists
                 const costIndex = parcelOptions.cost_index !== undefined && parcelOptions.cost_index !== null && isFinite(parseFloat(parcelOptions.cost_index)) ? parseFloat(parcelOptions.cost_index) : null;
                 const vri = parcelOptions.permitted_use_established_by_document || null;
                 // Extract ownership info
                const ownershipType = parcelOptions.ownership_type || '-';
                 const rightType = parcelOptions.right_type || '-';

                 const isDeclared = !parcelOptions.specified_area && !parcelOptions.land_record_area_verified && !parcelOptions.land_record_area && (parcelOptions.land_record_area_declaration || parcelOptions.declared_area);
                 const strokeColor = isDeclared ? polygonStyle.declaredParcelsColor : polygonStyle.parcelsColor;

                 // Create hint content including ownership
             const hintContent = {
                     cadastralNumber: `${cadastralNumber}`,
                     address: `${address}`,
                     area: `Площадь: ${areaText}`,
                     cost: costIndex !== null ? costIndex.toLocaleString('ru-RU', { maximumFractionDigits: 2 }) : null,
                     vri: vri,
                     // --- НАЧАЛО ИЗМЕНЕНИЙ: Добавляем поля для макета ---
                     ownershipType: ownershipType,
                     rightType: rightType
                     // --- КОНЕЦ ИЗМЕНЕНИЙ ---
                 };
                 
                 // --- Create Polygon ---
                 const polygonProperties = {
                     hintContent: hintContent, // Use updated hintContent
                     cadastralNumber: cadastralNumber,
                     address: address,
                     areaText: areaText,
                     costIndex: costIndex,
                     vri: vri,
                     featureData: feature // Store raw feature
                 };
                 if (markAsFoundInArea) {
                     polygonProperties.isFoundInArea = true; // Mark as found by area search
                 }

                 const parcelPolygon = new ymaps.Polygon([offsetCoordinates], polygonProperties, {
                     strokeColor: strokeColor,
                     strokeWidth: polygonStyle.width - 1, // Slightly thinner
                     strokeOpacity: 0.8,
                     fillColor: '#00000000', // No fill initially
                     hintLayout: customHintLayout, // Use custom layout
                     hintOpenTimeout: 100, hintCloseTimeout: 50,
                     cursor: 'pointer',
                     zIndex: 800 // Below potential search object
                 });

                 // Add event listeners
                 parcelPolygon.events.add('click', function (e) {
                     if (e.get('altKey')) { parcelPolygon.options.set('fillColor', `${strokeColor}33`); }
                     else {
                         const hintData = parcelPolygon.properties.get('hintContent');
                         let balloonContent = `<strong>${hintData.cadastralNumber}</strong><br>${hintData.address}<br>${hintData.area}`;
                         if (hintData.cost) balloonContent += `<br>Стоимость: ${hintData.cost} руб./м²`;
                         if (hintData.vri) balloonContent += `<br>Разрешенное использование: ${hintData.vri}`;
                         // Add ownership info to balloon if desired
                         if (hintData.ownershipInfo) balloonContent += `<br>Собственность: ${hintData.ownershipInfo}`;
                         map.balloon.open(e.get('coords'), balloonContent);
                     }
                 });
                 parcelPolygon.events.add('dblclick', async function (e) {
                     try { await navigator.clipboard.writeText(cadastralNumber); showNotification(`Скопировано: ${cadastralNumber}`, 'success', 'check-circle'); }
                     catch (err) { console.error('Ошибка копирования КН:', err); showNotification('Ошибка копирования КН', 'error', 'exclamation-circle'); }
                 });

                 map.geoObjects.add(parcelPolygon);
                 polygons.push(parcelPolygon); // Add to global tracking
                 drawnParcelObjects.push(parcelPolygon); // Add to tracking for *this call*

                 // --- Update Combined Bounds for *this call* ---
                 const parcelBounds = parcelPolygon.geometry.getBounds();
                 if (parcelBounds?.[0]?.[0] !== undefined && isFinite(parcelBounds[0][0])) {
                     if (!combinedBounds) { combinedBounds = [[parcelBounds[0][0], parcelBounds[0][1]], [parcelBounds[1][0], parcelBounds[1][1]]]; }
                     else { combinedBounds[0][0] = Math.min(combinedBounds[0][0], parcelBounds[0][0]); combinedBounds[0][1] = Math.min(combinedBounds[0][1], parcelBounds[0][1]); combinedBounds[1][0] = Math.max(combinedBounds[1][0], parcelBounds[1][0]); combinedBounds[1][1] = Math.max(combinedBounds[1][1], parcelBounds[1][1]); }
                 }

                 // --- Create Label ---
                  if (parcelBounds?.[0]?.[0] !== undefined && isFinite(parcelBounds[0][0])) {
                     const parcelCenterGeo = [(parcelBounds[0][0] + parcelBounds[1][0]) / 2, (parcelBounds[0][1] + parcelBounds[1][1]) / 2];
                     const parts = cadastralNumber.split(':');
                     const hasSixOrSevenZeros = parts.length >= 3 && /^0{6,7}$/.test(parts[2]);
                     const displayNumber = hasSixOrSevenZeros ? cadastralNumber : (parts.length > 3 ? ':' + parts.pop() : cadastralNumber);

                     const labelProperties = {
                         iconContent: displayNumber,
                         hintContent: hintContent, // Pass updated hintContent to label
                         cadastralNumber: cadastralNumber
                     };
                     if (markAsFoundInArea) {
                         labelProperties.isFoundInArea = true; // Mark label too
                     }

                     const parcelText = new ymaps.Placemark(parcelCenterGeo, labelProperties, {
                         iconLayout: customPlacemarkLayout, // Use custom layout
                         hintLayout: customHintLayout, // Use custom layout for hint
                         hasBalloon: false,
                         draggable: false,
                         visible: map.getZoom() > 14,
                         zIndex: 850 // Below potential search object labels
                     });
                     parcelText.polygon = parcelPolygon; // Link label to polygon
                     map.geoObjects.add(parcelText);
                     parcelPlacemarks.push(parcelText); // Add to label tracking
                     polygons.push(parcelText); // Add to global tracking
                     drawnParcelObjects.push(parcelText);
                  }
            } // End contour loop
        } catch (error) {
            console.error('Ошибка при отрисовке найденного земельного участка:', error, feature);
        }
    } // End feature loop

    // --- Set Map Bounds based on objects drawn *in this call* ---
    if (combinedBounds && combinedBounds[0] && combinedBounds[1] && combinedBounds[0].length === 2 && combinedBounds[1].length === 2 && isFinite(combinedBounds[0][0])) {
        const currentBounds = map.getBounds();
        let shouldSetBounds = true;
        if (currentBounds && currentBounds[0] && currentBounds[1]) {
             const margin = 0.0001;
             if (combinedBounds[0][0] >= currentBounds[0][0] - margin &&
                 combinedBounds[0][1] >= currentBounds[0][1] - margin &&
                 combinedBounds[1][0] <= currentBounds[1][0] + margin &&
                 combinedBounds[1][1] <= currentBounds[1][1] + margin) {
                    shouldSetBounds = false;
             }
        }

        if (shouldSetBounds) {
            const latMargin = (combinedBounds[1][0] - combinedBounds[0][0]) * 0.15 || 0.0005; // Add padding
            const lonMargin = (combinedBounds[1][1] - combinedBounds[0][1]) * 0.15 || 0.0005;
            const viewBounds = [[combinedBounds[0][0] - latMargin, combinedBounds[0][1] - lonMargin], [combinedBounds[1][0] + latMargin, combinedBounds[1][1] + lonMargin]];
            try { map.setBounds(viewBounds, { checkZoomRange: true, duration: 300 }); }
            catch (setBoundsError) { console.error("Ошибка установки границ:", setBoundsError, viewBounds); }
        }
    } else if (drawnParcelObjects.length === 1 && drawnParcelObjects[0] instanceof ymaps.Placemark) {
         // Center on single placemark if that's all that was drawn
         map.setCenter(drawnParcelObjects[0].geometry.getCoordinates(), map.getZoom() > 16 ? map.getZoom() : 17);
    }

    // --- Update UI ---
    updatePlacemarksVisibility();
    applyCurrentTheme(); // Apply active theme styles

    return drawnParcelObjects; // Return objects added in this call
}



// Ensure highlightIntersectingParcels uses the correct stroke color
function highlightIntersectingParcels(parcels) {
    for (const parcel of parcels) {
        const polygon = parcel.polygon;
        // Determine the base color (declared vs verified)
         const options = polygon.properties.get('hintContent'); // Assuming hintContent holds the structure
         let isDeclared = false;
         if (options && typeof options.area === 'string') {
            isDeclared = options.area.includes('декларированная');
         }
        let baseStrokeColor = isDeclared ? polygonStyle.declaredParcelsColor : polygonStyle.parcelsColor;

        // Set thicker stroke and semi-transparent fill for highlighting
        polygon.options.set('fillColor', `${baseStrokeColor}66`); // Use ~40% opacity fill for highlight
        polygon.options.set('strokeWidth', polygonStyle.width + 1); // Make border slightly thicker
        polygon.options.set('strokeColor', '#FF8C00'); // Optional: Change stroke color to orange for highlight

        // Find and highlight the corresponding label (if it exists)
        const label = parcelPlacemarks.find(pm => pm.properties.get('cadastralNumber') === parcel.cadastralNumber || (pm.polygon === polygon));
        if (label) {
             // Change label appearance - e.g., using a different preset or style
            // Example: Change preset if using standard Yandex presets
            // label.options.set('preset', 'islands#redStretchyIcon'); // Or another distinct preset

             // Example: Directly style the custom layout element (if possible and reliable)
              const element = label.getOverlaySync()?.getLayoutSync()?.getElement()?.querySelector('.custom-placemark');
              if (element) {
                  element.style.color = '#FF0000'; // Red text
                  element.style.fontWeight = 'bold';
                  element.style.textShadow = '0 0 3px white, 0 0 5px yellow'; // Add glow
              }

              label.options.set('zIndex', 950); // Bring label to front
        }
    }
}

function openMskConverterModal() {
    const existingModal = document.getElementById('msk-converter-modal');
    if (existingModal) existingModal.remove();

    const modalGradients = [
        'linear-gradient(135deg, #e0c3fc 0%, #8ec5fc 100%)', 'linear-gradient(135deg, #a1c4fd 0%, #c2e9fb 100%)',
        'linear-gradient(135deg, #fbc2eb 0%, #a6c1ee 100%)', 'linear-gradient(135deg, #84fab0 0%, #8fd3f4 100%)',
        'linear-gradient(135deg, #f6d365 0%, #fda085 100%)', 'linear-gradient(135deg, #d4fc79 0%, #96e6a1 100%)'
    ];
    const buttonGradients = [
        'linear-gradient(135deg, #667eea 0%, #764ba2 100%)', 'linear-gradient(135deg, #2af598 0%, #009efd 100%)'
    ];

    const modal = document.createElement('div');
    modal.id = 'msk-converter-modal';
    modal.className = 'converter-modal';

    const modalContent = document.createElement('div');
    modalContent.className = 'converter-modal-content';
    // --- НАЧАЛО ИЗМЕНЕНИЙ В HTML ---
    modalContent.innerHTML = `
        <button class="close-btn" title="Закрыть">&times;</button>
        <h3>Настройка МСК</h3>
        <div class="converter-mode-switch" style="display: none;">
            <label>Режим:</label>
            <label class="switch"><input type="checkbox" id="mskConversionModeSwitch"><span class="slider"></span></label>
        </div>
        <textarea id="msk-coords-input" placeholder="Вставьте координаты X Y..."></textarea>
        <div class="converter-offset-inputs">
            <div><label for="mskOffsetX">Смещение X (м):</label><input type="number" id="mskOffsetX" value="0.00" step="0.01"></div>
            <div><label for="mskOffsetY">Смещение Y (м):</label><input type="number" id="mskOffsetY" value="0.00" step="0.01"></div>
        </div>
        <div class="modal-option">
            <input type="checkbox" id="autoLoadOffsetSwitch"><label for="autoLoadOffsetSwitch">Автозагрузка смещения из Proj4</label>
        </div>
        <div class="converter-modal-actions">
             <select id="msk-select"></select>
             <button id="execute-msk-conversion" class="action-btn" title="Отобразить на карте"><img src="img/play.png" alt=">"></button>
        </div>
        
        <!-- НОВЫЙ ЭЛЕМЕНТ TEXTAREA ДЛЯ ШАБЛОНОВ -->
        <textarea id="msk-templates-input" 
                  placeholder="текст_поиска_МСК;префикс_Y;префикс_X \nнапример: 16-2;22;3" 
                  title="Автоопределение по шаблону: текст для поиска в названии МСК;префикс Y;префикс X (каждый с новой строки)"
                  style="width: 100%; min-height: 100px; margin-top: 15px; padding: 10px; border-radius: 12px; border: 1px solid rgba(0,0,0,0.1); font-family: monospace; resize: vertical; box-sizing: border-box; background: rgba(255, 255, 255, 0.7);"
        ></textarea>
    `;
    // --- КОНЕЦ ИЗМЕНЕНИЙ В HTML ---

    modalContent.style.background = modalGradients[Math.floor(Math.random() * modalGradients.length)];
    modalContent.querySelector('.action-btn').style.background = buttonGradients[Math.floor(Math.random() * buttonGradients.length)];

    modal.appendChild(modalContent);
    document.body.appendChild(modal);
    
    // --- НАЧАЛО ИЗМЕНЕНИЙ В JAVASCRIPT ---
     const select = document.getElementById('msk-select');
    const modeSwitch = document.getElementById('mskConversionModeSwitch');
    const autoLoadSwitch = document.getElementById('autoLoadOffsetSwitch');
    const offsetXInput = document.getElementById('mskOffsetX');
    const offsetYInput = document.getElementById('mskOffsetY');
    const templatesInput = document.getElementById('msk-templates-input');
    const coordsInput = document.getElementById('msk-coords-input');

    // Главная хелпер-функция для принудительного форматирования значения в "X.XX"
    const formatAndCorrectOffset = (value) => {
        // 1. Преобразуем в строку и принудительно меняем запятую на точку.
        const stringValue = String(value || '0').replace(',', '.');
        // 2. Парсим в число, по умолчанию 0 в случае ошибки.
        const numberValue = parseFloat(stringValue) || 0;
        // 3. Форматируем до 2 знаков после запятой (может вернуть запятую).
        const fixedString = numberValue.toFixed(2);
        // 4. Еще раз принудительно меняем запятую на точку для 100% гарантии.
        return fixedString.replace(',', '.');
    };

    // Функция для обновления полей смещения на основе текущих настроек
    const updateOffsetFields = () => {
        let offsetX, offsetY;

        if (autoLoadSwitch.checked && typeof COORDINATE_SYSTEMS !== 'undefined') {
            const selectedSystem = COORDINATE_SYSTEMS.find(s => s.value === select.value);
            offsetX = selectedSystem?.offsetX || 0;
            offsetY = selectedSystem?.offsetY || 0;
        } else {
            offsetX = localStorage.getItem('savedMskOffsetX') || '0';
            offsetY = localStorage.getItem('savedMskOffsetY') || '0';
        }

        const formattedX = formatAndCorrectOffset(offsetX);
        const formattedY = formatAndCorrectOffset(offsetY);

        offsetXInput.value = formattedX;
        offsetYInput.value = formattedY;

        // Если значения берутся из localStorage, перезаписываем их в правильном формате
        if (!autoLoadSwitch.checked) {
            localStorage.setItem('savedMskOffsetX', formattedX);
            localStorage.setItem('savedMskOffsetY', formattedY);
        }
    };

    // Заполняем выпадающий список систем координат
    if (typeof COORDINATE_SYSTEMS !== 'undefined') {
        COORDINATE_SYSTEMS.forEach(sys => {
            const option = document.createElement('option');
            option.value = sys.value;
            option.textContent = sys.text;
            select.appendChild(option);
        });
        select.value = localStorage.getItem('savedDefaultMskSystem') || 'EPSG:6331602';
    }

    // Загружаем сохраненные шаблоны
    templatesInput.value = localStorage.getItem('mskCoordinateTemplates') || '';
    
    // Устанавливаем начальное состояние переключателей
    modeSwitch.checked = (localStorage.getItem('mskConverterMode') !== 'api');
    autoLoadSwitch.checked = (localStorage.getItem('autoLoadMskOffset') !== 'false');

    // Первоначальное заполнение полей смещения при открытии окна
    updateOffsetFields();

    // --- ОБРАБОТЧИКИ СОБЫТИЙ ---
    
    templatesInput.addEventListener('input', () => {
        localStorage.setItem('mskCoordinateTemplates', templatesInput.value);
    });
    
    coordsInput.addEventListener('input', autoSelectMskSystemByTemplate);

    modeSwitch.addEventListener('change', () => localStorage.setItem('mskConverterMode', modeSwitch.checked ? 'proj' : 'api'));

    autoLoadSwitch.addEventListener('change', () => {
        localStorage.setItem('autoLoadMskOffset', autoLoadSwitch.checked);
        updateOffsetFields();
    });

    select.addEventListener('change', () => {
        localStorage.setItem('savedDefaultMskSystem', select.value);
        updateOffsetFields();
    });

    // Обработчик 'change' для форматирования и сохранения после того, как пользователь закончил ввод
    offsetXInput.addEventListener('change', () => {
        const formattedValue = formatAndCorrectOffset(offsetXInput.value);
        offsetXInput.value = formattedValue;
        localStorage.setItem('savedMskOffsetX', formattedValue);
    });

    offsetYInput.addEventListener('change', () => {
        const formattedValue = formatAndCorrectOffset(offsetYInput.value);
        offsetYInput.value = formattedValue;
        localStorage.setItem('savedMskOffsetY', formattedValue);
    });

    document.getElementById('execute-msk-conversion').addEventListener('click', executeMskConversion);

    modal.style.display = 'flex';

    const closeModal = () => modal.remove();
    modal.querySelector('.close-btn').addEventListener('click', closeModal);
    
    navigator.clipboard.readText().then(text => {
        if (text && text.trim()) {
            document.getElementById('msk-coords-input').value = text;
            autoSelectMskSystemByTemplate();
        }
    }).catch(err => console.log('Не удалось прочитать буфер обмена для конвертера.'));
}

function autoSelectMskSystemByTemplate() {
    // Получаем ссылки на все необходимые элементы
    const coordsInput = document.getElementById('msk-coords-input');
    const templatesInput = document.getElementById('msk-templates-input');
    const mskSelect = document.getElementById('msk-select');

    // Проверяем, что все элементы существуют
    if (!coordsInput || !templatesInput || !mskSelect) return;

    // Получаем текст из полей
    const coordsText = coordsInput.value.trim();
    const templatesText = templatesInput.value.trim();

    // Если нет координат или шаблонов, выходим
    if (!coordsText || !templatesText) return;
    
    // Проверяем, что список систем координат загружен
    if (typeof COORDINATE_SYSTEMS === 'undefined') return;

    // Анализируем первую строку координат
    const firstLine = coordsText.split('\n')[0].trim();
    const parts = firstLine.split(/\s+/);

    if (parts.length < 2) return; // Строка должна содержать минимум 2 числа

    // В России принято Y X, поэтому первая часть - Y, вторая - X
    const yCoord = parts[0].replace(',', '.');
    const xCoord = parts[1].replace(',', '.');

    // Разбираем шаблоны
    const templates = templatesText.split('\n');
    for (const template of templates) {
        // Разделяем шаблон по ';' и убираем пробелы
        const [searchText, prefixX, prefixY] = template.split(';').map(s => s.trim());

        // Пропускаем некорректно заполненные шаблоны
        if (!searchText || !prefixX || !prefixY) continue;

        // Сравниваем начала строк координат с префиксами из шаблона
        if (xCoord.startsWith(prefixX) && yCoord.startsWith(prefixY)) {
            
            // Если префиксы совпали, ищем систему координат по тексту
            const systemToFind = COORDINATE_SYSTEMS.find(sys => sys.text.toLowerCase().includes(searchText.toLowerCase()));

            if (systemToFind) {
                // Если система найдена, устанавливаем ее в выпадающем списке
                mskSelect.value = systemToFind.value;
                console.log(`Шаблон '${template}' сработал. Найдена СК: ${systemToFind.text}`);

                // ВАЖНО: Имитируем событие 'change', чтобы сработала остальная логика (например, автозагрузка смещения)
                mskSelect.dispatchEvent(new Event('change'));

                return; // Прекращаем поиск, так как нашли подходящий шаблон
            }
        }
    }
}

function findMskSystemByTemplate(coordsText) {
    // Получаем шаблоны из localStorage. Модального окна может не быть на странице.
    const templatesText = localStorage.getItem('mskCoordinateTemplates');

    // Проверяем, есть ли все необходимое для работы
    if (!coordsText || !templatesText || typeof COORDINATE_SYSTEMS === 'undefined') {
        return null;
    }

    // Анализируем первую строку координат
    const firstLine = coordsText.split('\n')[0].trim();
    const parts = firstLine.split(/\s+/);

    if (parts.length < 2) return null; // Нужно минимум 2 числа

    // В России принято Y X, поэтому первая часть - Y, вторая - X
    const yCoord = parts[0].replace(',', '.');
    const xCoord = parts[1].replace(',', '.');

    // Разбираем шаблоны
    const templates = templatesText.trim().split('\n');
    for (const template of templates) {
        const [searchText, prefixX, prefixY] = template.split(';').map(s => s.trim());

        if (!searchText || !prefixX || !prefixY) continue;

        // Сравниваем начала строк координат с префиксами
        if (xCoord.startsWith(prefixX) && yCoord.startsWith(prefixY)) {
            // Ищем систему координат по тексту
            const systemToFind = COORDINATE_SYSTEMS.find(sys => sys.text.toLowerCase().includes(searchText.toLowerCase()));

            if (systemToFind) {
                console.log(`Автоопределение по шаблону '${template}': Найдена СК - ${systemToFind.text}`);
                return systemToFind.value; // Возвращаем ID системы, например "EPSG:6331602"
            }
        }
    }

    return null; // Ни один шаблон не подошел
}

async function executeMskConversion() {
    const sourceText = document.getElementById('msk-coords-input').value.trim();
    const sourceSc = document.getElementById('msk-select').value;
    // const mode = document.getElementById('mskConversionModeSwitch').checked ? 'proj' : 'api'; // Старая строка, считывающая значение
    const mode = 'proj'; // Принудительно используем локальный режим Proj4
   const offsetXRaw = document.getElementById('mskOffsetX').value.replace(',', '.');
    const offsetYRaw = document.getElementById('mskOffsetY').value.replace(',', '.');
    const offsetX = parseFloat(offsetXRaw) || 0;
    const offsetY = parseFloat(offsetYRaw) || 0;

    console.log(`[executeMskConversion] Смещения для конвертации: X=${offsetX}, Y=${offsetY} (исходные: "${document.getElementById('mskOffsetX').value}", "${document.getElementById('offsetYInput').value}")`);
    
    if (!sourceText) {
        showNotification('Введите координаты для конвертации', 'warning');
        return;
    }

    showLoader('Конвертация...');
    
    try {
        let finalResultText = '';

        if (mode === 'proj') {
            const sourceDef = COORDINATE_SYSTEMS.find(s => s.value === sourceSc)?.def;
            if (!sourceDef) throw new Error(`Определение для ${sourceSc} не найдено в sk.js`);
            proj4.defs(sourceSc, sourceDef);

            const lines = sourceText.split('\n');
            const results = lines.map(line => {
                if (line.trim() === '') return '';
                const parts = line.trim().split(/\s+/).map(p => p.replace(',', '.')); // Замена запятых на точки
                if (parts.length !== 2) return "Ошибка: 2 координаты в строке";
                
                const y_input = parseFloat(parts[0]); // Первая колонка - Y
                const x_input = parseFloat(parts[1]); // Вторая колонка - X
                if (isNaN(x_input) || isNaN(y_input)) return "Ошибка: некорректные числа";

                // Proj4 ожидает [X, Y]. В России принято Y, X. Меняем местами.
                const convertedPoint = proj4(sourceSc, 'EPSG:3857', [x_input, y_input]);
                const finalX = convertedPoint[0] + offsetX;
                const finalY = convertedPoint[1] + offsetY;
                return `${finalX.toFixed(4)}\t${finalY.toFixed(4)}`;
            });
            finalResultText = results.join('\n');

        } else { // Режим API
            const response = await fetch('https://cc-psi-livid.vercel.app/api/convert', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                // API ожидает, что X и Y могут быть перепутаны, он сам их определит.
                // Но мы можем помочь ему, поменяв их местами, если уверены.
                // Для простоты оставим как есть, API разберется.
                body: JSON.stringify({ sourceText, sourceSc, destSc: 'EPSG:3857' })
            });
            const result = await response.json();
            if (!response.ok || (result.error && result.error.length > 0)) {
                throw new Error(result.error || `Сервер вернул ошибку ${response.status}`);
            }
            if (!result.destText) throw new Error('Ответ сервера не содержит координат.');

            // Применяем смещение к результату от API
            if (offsetX !== 0 || offsetY !== 0) {
                const lines = result.destText.replace(/\r/g, '').split('\n');
                const shiftedLines = lines.map(line => {
                    if (line.trim() === '') return '';
                    const parts = line.trim().split(/\s+/).map(p => p.replace(',', '.'));
                    if (parts.length === 2 && !isNaN(parseFloat(parts[0])) && !isNaN(parseFloat(parts[1]))) {
                        const x_api = parseFloat(parts[0]) + offsetX;
                        const y_api = parseFloat(parts[1]) + offsetY;
                        return `${x_api.toFixed(4)}\t${y_api.toFixed(4)}`;
                    }
                    return line;
                });
                finalResultText = shiftedLines.join('\n');
            } else {
                finalResultText = result.destText.replace(/\r/g, '');
            }
        }
        
        // Помещаем результат в ГЛАВНОЕ поле `coordsInput` и вызываем `findAndConvert`,
        // который уже умеет обрабатывать EPSG:3857. Это самый надежный способ.
        coordsInput.value = finalResultText;
        findAndConvert();
        
        const modal = document.getElementById('msk-converter-modal');
        if (modal) modal.remove();

    } catch (error) {
        showNotification(`Ошибка: ${error.message}`, 'error');
    } finally {
        hideLoader();
    }
}


// Show results in the sidebar
function showParcelResults(parcels) {
    const sidebar = document.getElementById('parcel-results-sidebar');
    const contentDiv = document.getElementById('parcel-list-content');
    const noResultsMsg = contentDiv.querySelector('.no-results-message');
    const sidebarTitle = document.getElementById('sidebar-title');
    const toggleBtn = document.getElementById('toggle-sidebar-btn');
    const filterInput = document.getElementById('filter-cadnum-input');
    const copyFilteredBtn = document.getElementById('copy-filtered-btn');

    // --- Добавлено: Сохраняем общее количество ---
    const totalParcels = parcels.length;
    if (sidebar) {
        sidebar.dataset.totalCount = totalParcels; // Сохраняем в data-атрибут
    }
    // --- Конец добавления ---

    // Очищаем предыдущие результаты и сбрасываем фильтр
    contentDiv.querySelectorAll('.sidebar-item').forEach(item => item.remove());
    if (filterInput) filterInput.value = '';

    // --- Изменено: Отображаем видимое/общее количество сразу ---
    sidebarTitle.textContent = `Найденные участки (${totalParcels}/${totalParcels})`;
    // --- Конец изменения ---

    if (parcels.length > 0) {
        noResultsMsg.style.display = 'none';
        parcels.forEach((parcel, index) => {
            const cadNumber = parcel.cadastralNumber || 'Не указан';
            const address = parcel.address || 'Адрес не указан';
            const areaText = parcel.areaText || 'Площадь не указана';

            const itemDiv = document.createElement('div');
            itemDiv.className = 'sidebar-item';
            itemDiv.dataset.cadnum = cadNumber.toLowerCase();
            itemDiv.innerHTML = `
                <p>${index + 1}. ${cadNumber}</p>
                <p>${address}</p>
                <p>${areaText}</p>
            `;

            // Обработчик двойного клика (без изменений)
            itemDiv.addEventListener('dblclick', () => {
                const targetPolygon = parcel.polygon;
                if (targetPolygon && map) {
                    try {
                        const bounds = targetPolygon.geometry.getBounds();
                        if (bounds && bounds[0] && bounds[1]) {
                            const latPadding = (bounds[1][0] - bounds[0][0]) * 0.15 || 0.0005;
                            const lonPadding = (bounds[1][1] - bounds[0][1]) * 0.15 || 0.0005;
                            const paddedBounds = [
                                 [bounds[0][0] - latPadding, bounds[0][1] - lonPadding],
                                 [bounds[1][0] + latPadding, bounds[1][1] + lonPadding]
                            ];
                            map.setBounds(paddedBounds, { checkZoomRange: true, duration: 500 });

                            const originalFill = targetPolygon.options.get('fillColor') || '#00000000';
                            const options = parcel.polygon.properties.get('hintContent');
                            let isDeclared = false;
                            if (options && typeof options.area === 'string') {
                                isDeclared = options.area.includes('декларированная');
                            }
                            let baseStrokeColor = isDeclared ? polygonStyle.declaredParcelsColor : polygonStyle.parcelsColor;
                            const originalStroke = targetPolygon.options.get('strokeColor');

                            targetPolygon.options.set('fillColor', '#FFFF0080');
                            targetPolygon.options.set('strokeColor', '#FFA500');
                            setTimeout(() => {
                                targetPolygon.options.set('fillColor', `${baseStrokeColor}66`);
                                targetPolygon.options.set('strokeColor', '#FF8C00');
                            }, 1500);

                        } else {
                             console.warn("Не удалось получить границы для полигона:", targetPolygon);
                             const coords = targetPolygon.geometry.getCoordinates()[0][0];
                             if (coords) map.setCenter(coords, 18, { duration: 500 });
                        }
                    } catch (e) {
                        console.error("Ошибка при позиционировании карты:", e);
                         const coords = targetPolygon.geometry.getCoordinates()[0][0];
                         if (coords) map.setCenter(coords, 18, { duration: 500 });
                    }
                }
            });

            contentDiv.appendChild(itemDiv);
        });
        if (sidebar.querySelector('.sidebar-footer')) {
            sidebar.querySelector('.sidebar-footer').style.display = 'flex';
        }
    } else {
        noResultsMsg.style.display = 'block';
        if (sidebar.querySelector('.sidebar-footer')) {
             sidebar.querySelector('.sidebar-footer').style.display = 'none';
        }
    }

    sidebar.classList.remove('hidden', 'collapsed');
    toggleBtn.innerHTML = '<i class="fas fa-chevron-right"></i>';
    isSidebarCollapsed = false;

    filterInput?.removeEventListener('input', filterParcelList);
    copyFilteredBtn?.removeEventListener('click', copyFilteredCadnums);

    if (filterInput) {
        filterInput.addEventListener('input', filterParcelList);
    }
    if (copyFilteredBtn) {
        copyFilteredBtn.addEventListener('click', copyFilteredCadnums);
    }
}

/**
 * Фильтрует список участков в боковой панели на основе введенного текста.
 */
/**
 * Фильтрует список участков в боковой панели на основе введенного текста.
 */
function filterParcelList() {
    const filterInput = document.getElementById('filter-cadnum-input');
    const contentDiv = document.getElementById('parcel-list-content');
    const sidebar = document.getElementById('parcel-results-sidebar'); // Get sidebar here
    if (!filterInput || !contentDiv || !sidebar) return;

    // Получаем текст фильтра, приводим к нижнему регистру и обрезаем пробелы
    const filterText = filterInput.value.toLowerCase().trim();

    // Разбиваем текст фильтра на отдельные слова (термины поиска)
    // Исключаем пустые строки, если пользователь ввел несколько пробелов
    const searchTerms = filterText.split(/\s+/).filter(term => term.length > 0);

    const items = contentDiv.querySelectorAll('.sidebar-item');
    let visibleCount = 0;

    items.forEach(item => {
        // Получаем текст из data-атрибута (КН) и из p-тегов (адрес)
        // Используем Optional Chaining (?.) для безопасности
        const cadNum = item.dataset.cadnum?.toLowerCase() || '';
        const addressText = item.querySelectorAll('p')[1]?.textContent?.toLowerCase() || '';
        // const areaText = item.querySelectorAll('p')[2]?.textContent?.toLowerCase() || ''; // Площадь больше не используется для фильтрации

        let isVisible = false;

        if (filterText === '') {
            // Если поле фильтра пустое, показываем все элементы
            isVisible = true;
        } else {
            // Условие 1: Кадастровый номер включает ВЕСЬ введенный текст фильтра
            const cadnumMatch = cadNum.includes(filterText);

            // Условие 2: ВСЕ слова из searchTerms присутствуют ГДЕ-ТО в тексте Адреса
            // Используем .every() для проверки наличия всех терминов
            const addressMatch = searchTerms.every(term => addressText.includes(term));

            // Элемент видим, если совпал КН ИЛИ совпал Адрес
            isVisible = cadnumMatch || addressMatch;
        }

        // Применяем или убираем класс filtered-out
        item.classList.toggle('filtered-out', !isVisible);

        // Подсчитываем видимые элементы
        if (isVisible) {
            visibleCount++;
        }
    });

    // Обновляем заголовок боковой панели с учетом видимого количества
    const sidebarTitle = document.getElementById('sidebar-title');
    // Используем сохраненное общее количество из data-атрибута или считаем все элементы, если его нет
    const totalCount = sidebar.dataset.totalCount || items.length;
    // Получаем префикс из data-атрибута (Квартал: дата или Найденные участки)
     const prefix = sidebar.dataset.titlePrefix || 'Найденные участки';

    sidebarTitle.textContent = `${prefix} (${visibleCount}/${totalCount})`;

    // Обновляем сообщение "нет результатов"
    const noResultsMsg = contentDiv.querySelector('.no-results-message');
    if (noResultsMsg) {
        const totalItems = parseInt(sidebar.dataset.totalCount || '0'); // Общее количество элементов (до фильтрации)

        if (visibleCount === 0 && totalItems > 0) {
            // Если после фильтрации нет видимых элементов, но изначально они были
            noResultsMsg.style.display = 'block';
            noResultsMsg.textContent = 'Нет участков, соответствующих фильтру.';
        } else if (totalItems === 0) {
            // Если изначально не было загруженных участков
            noResultsMsg.style.display = 'block'; // Показываем сообщение "Нет загруженных участков"
            noResultsMsg.textContent = 'Нет загруженных участков в квартале.';
        }
        else {
             // Если есть видимые элементы или изначально не было элементов
             noResultsMsg.style.display = 'none';
        }
    }
}


function copyFilteredCadnums() {
    const contentDiv = document.getElementById('parcel-list-content');
    if (!contentDiv) return;

    const visibleItems = contentDiv.querySelectorAll('.sidebar-item:not(.filtered-out)');
    if (visibleItems.length === 0) {
        showNotification('Нет видимых участков для копирования', 'warning', 'exclamation-triangle');
        return;
    }

    const textToCopy = Array.from(visibleItems)
        .map(item => {
            const pTags = item.querySelectorAll('p');

            // 1. Кадастровый номер (без порядкового номера)
            const fullCadNumberText = pTags[0]?.textContent.trim() || '';
            const cadNumberText = fullCadNumberText.replace(/^\d+\.\s*/, '');

            // 2. Адрес
            const addressText = pTags[1]?.textContent.trim() || '';

            // --- НАЧАЛО ИЗМЕНЕНИЙ ДЛЯ ПЛОЩАДИ ---
            const areaRawText = pTags[2]?.textContent.trim() || '';
            let areaValue = '';
            let areaType = '';

            // Регулярное выражение для разбора строки типа "22 838 м² (уточненная)"
            // Оно захватывает (1) числовую часть и (2) текст в скобках.
            const areaRegex = /^([\d\s ]+)\s*м²\s*\((.*?)\)$/;
            const match = areaRawText.match(areaRegex);

            if (match) {
                // match[1] - это числовая часть, например "22 838". Убираем из нее пробелы.
                areaValue = match[1].replace(/[\s ]/g, '');
                // match[2] - это тип, например "уточненная".
                areaType = match[2];
            } else {
                // Если формат не совпал (например, "площадь не указана"),
                // оставляем значение площади пустым, чтобы не ломать колонки.
                areaValue = areaRawText.includes('не указана') ? '' : areaRawText;
            }
            // --- КОНЕЦ ИЗМЕНЕНИЙ ДЛЯ ПЛОЩАДИ ---

            // 4. Единое землепользование
            const uluElement = item.querySelector('.ulu-info-sidebar');
            const uluText = uluElement 
                ? uluElement.textContent.replace('Единое землепользование:', '').replace(/\s+/g, ' ').trim() 
                : '';

            // Собираем итоговую строку с 5 колонками
            return [cadNumberText, addressText, areaValue, areaType, uluText].join('\t');
        })
        .join('\n');

    navigator.clipboard.writeText(textToCopy)
        .then(() => {
            showNotification(`Скопировано ${visibleItems.length} записей`, 'success', 'check-circle');
        })
        .catch(err => {
            console.error('Ошибка при копировании отфильтрованных данных:', err);
            showNotification('Ошибка при копировании', 'error', 'exclamation-circle');
        });
}




        </script>
</body>

</html>