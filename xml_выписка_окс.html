

<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Просмотр XML-выписки</title>
    <link rel="stylesheet" href="webfonts/all.min.css">
    <script src="webfonts/jszip.min.js"></script>
<link rel="icon" href="https://img.icons8.com/?size=100&id=12053&format=png&color=000000" type="image/png">
    <style>
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            margin: 20px;
            background-color: #f0f0f0;
        }
        .file-input-wrapper {
            position: relative;
            display: inline-block;
            margin: 20px auto;
            text-align: center;
            width: 100%;
        }
        .file-input-wrapper input[type="file"] {
            position: absolute;
            left: -9999px;
        }
        .file-input-wrapper label {
            display: inline-block;
            padding: 10px 20px;
            background-color: #4CAF50;
            color: white;
            cursor: pointer;
            border-radius: 5px;
            font-size: 16px;
            transition: all 0.3s ease;
            transform: translateY(-50px);
            opacity: 0;
            animation: dropIn 0.5s forwards;
        }
        @keyframes dropIn {
            0% {
                transform: translateY(-50px);
                opacity: 0;
            }
            100% {
                transform: translateY(0);
                opacity: 1;
            }
        }
        .file-input-wrapper label:hover {
            background-color: #45a049;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.1);
        }
        td, th {
            border: 1px solid #ddd;
            padding: 12px;
            text-align: left;
            transition: background-color 0.3s;
        }
        tr:nth-child(even) {
            background-color: #f8f8f8;
        }
        tr:nth-child(odd) {
            background-color: #ffffff;
        }
        tr:hover {
            background-color: #f8f8f8;
            box-shadow: 0 0 10px rgba(0, 0, 255, 0.2);
        }
        .copyable {
            cursor: pointer;
            transition: color 0.3s;
        }
        .copyable:hover {
            color: black;
        }
        .flash {
            animation: flash 1s;
        }
        @keyframes flash {
            0%, 100% { background-color: inherit; }
            50% { background-color:  #00FF7F; }
        }
        .clickable {
            cursor: pointer;
            color: black;
         
            transition: color 0.3s;
        }
        .clickable:hover {
         
        }
        .coordinates-table {
            width: 100%;
            border-collapse: collapse;
            display: none;
            margin-top: 10px;
        }
        .coordinates-table th, .coordinates-table td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: center;
        }
        .coordinates-table th {
            background-color: #f2f2f2;
        }
        .button-group {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 10px;
        }
        .button {
            padding: 14px 21px;
            color: white;
            border: none;
            border-radius: 12px;
            cursor: pointer;
            font-size: 16px;
            transition: all 0.6s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: rgba(76, 175, 80, 0.9);
            position: relative;
            overflow: hidden;
        }
        .button:hover {
            background-color: rgba(76, 175, 80, 0.9);
        }
        .button:active {
            transform: translateY(1px);
        }
        .button i {
            margin-right: 5px;
        }
        .button::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: #0FF7F;
            transform: rotate(45deg);
            transition: all 0.3s ease;
            opacity: 0;
        }
        .button:hover::before {
            animation: flashButton 0.6s;
        }
        .button.export {
            background-color: rgba(65, 105, 225, 0.7);
        }
        .button.export:hover {
            background-color: rgba(65, 105, 225, 0.9);
        }
        @keyframes flashButton {
            0% {
                opacity: 0;
                transform: translate(-50%, -50%) rotate(45deg);
            }
            50% {
                opacity: 1;
            }
            100% {
                opacity: 0;
                transform: translate(50%, 50%) rotate(45deg);
            }
        }
        .rights-header {
            cursor: pointer;
            color: black;
        }
        .rights-header:hover {
   
        }
        .rights-info {
            cursor: default;
        }
        .right-info {
            cursor: pointer;
        }
        .right-info:hover {
            background-color: #f0f0f0;
        }
    </style>
</head>
<body>
    <div class="file-input-wrapper">
            <input type="file" id="fileInput" accept=".xml,.zip">
        <label for="fileInput" id="fileInputLabel">Открыть XML выписку ОКС</label>
    </div>
    <div id="output"></div>

     <script>
    function getElementValue(element, tagName) {
        if (!element) return '';
        const parts = tagName.split('>');
        let currentElement = element;
        for (let part of parts) {
            currentElement = currentElement.querySelector(part);
            if (!currentElement) return '';
        }
        return currentElement.textContent.trim();
    }

function extractCoordinatesFromXML(xmlContent) {
    const parser = new DOMParser();
    const xmlDoc = parser.parseFromString(xmlContent, "text/xml");
    const contours = [];

    const spatialElements = xmlDoc.querySelectorAll("spatial_element");
    
    spatialElements.forEach((spatialElement) => {
        const contour = [];
        const ordinates = spatialElement.querySelectorAll("ordinates > ordinate");
        ordinates.forEach((ordinate, index) => {
            const x = parseFloat(ordinate.querySelector("x")?.textContent || "");
            const y = parseFloat(ordinate.querySelector("y")?.textContent || "");
            const ordNmb = parseInt(ordinate.querySelector("ord_nmb")?.textContent || "");
            const delta = parseFloat(ordinate.querySelector("delta_geopoint")?.textContent || "0");
            
            if (!isNaN(x) && !isNaN(y)) {
                // Если это последняя точка и она совпадает с первой, используем номер 1
                const pointOrdNmb = (index === ordinates.length - 1 && 
                                     x === parseFloat(ordinates[0].querySelector("x")?.textContent || "") &&
                                     y === parseFloat(ordinates[0].querySelector("y")?.textContent || ""))
                                    ? 1 : ordNmb;
                
                contour.push({x, y, ordNmb: isNaN(pointOrdNmb) ? null : pointOrdNmb, delta});
            }
        });
        if (contour.length > 0) {
            contours.push(contour);
        }
    });

    return contours;
}

    function extractShortAddress(fullAddress) {
        let settlement = fullAddress.match(/\s(с|г|город|д|д\.)\s([А-Яа-я\-]+)/);
        settlement = settlement ? settlement[2] : '';

        let street = fullAddress.match(/\s(ул|ул\.|улица)\s*\.?\s*([А-Яа-я\-]+)/);
        street = street ? street[2] : '';

        let houseNumber = fullAddress.match(/(\d+)(?!.*\d)/);
        houseNumber = houseNumber ? houseNumber[1] : '';

        let shortAddress = [settlement, street, houseNumber].filter(Boolean).join(' ');

        return shortAddress;
    }

    function generateSearchUrl(surname, name) {
        return `https://www.np-okirt.ru/o-partnerstve/reestr-chlenov-partnerstva/index.php?search-type=SECOND_NAME&search-type-value=${encodeURIComponent(surname)}&search-type-2=NAME&search-type-value-2=${encodeURIComponent(name)}&region=&city=`;
    }

    function extractData(xmlContent) {
        const parser = new DOMParser();
        const xmlDoc = parser.parseFromString(xmlContent, "text/xml");
        
        const objectType = getElementValue(xmlDoc, 'build_record > object > common_data > type > value') ||
                           getElementValue(xmlDoc, 'construction_record > object > common_data > type > value') ||
                           getElementValue(xmlDoc, 'land_record > object > common_data > type > value');

        const recordElement = xmlDoc.querySelector('build_record') || 
                              xmlDoc.querySelector('construction_record') || 
                              xmlDoc.querySelector('land_record');

        const surname = getElementValue(recordElement, 'cad_works > cad_work > fio_cad_ingineer > surname');
        const name = getElementValue(recordElement, 'cad_works > cad_work > fio_cad_ingineer > name');
        const patronymic = getElementValue(recordElement, 'cad_works > cad_work > fio_cad_ingineer > patronymic');
        const cadastralEngineerNumber = getElementValue(recordElement, 'cad_works > cad_work > cadastral_engineer_registry_number');
        const cadastralEngineer = `${surname} ${name} ${patronymic} (№ ${cadastralEngineerNumber})`.trim();

        const cadNumber = getElementValue(recordElement, 'object > common_data > cad_number');
        const formattedCadNumber = cadNumber.replace(/:/g, '_');
        const date = getElementValue(xmlDoc, 'details_statement > group_top_requisites > date_formation');
        const address = getElementValue(recordElement, 'address_location > address > readable_address');
        const shortAddress = extractShortAddress(address);

        const landCadNumbers = Array.from(recordElement.querySelectorAll('cad_links > land_cad_numbers > land_cad_number > cad_number'))
            .map(el => el.textContent);
        const landCadNumbersString = landCadNumbers.join(', ');

        let areaOrExtension = '';
        let areaOrExtensionLabel = '';
        if (objectType === 'build_record') {
            areaOrExtension = getElementValue(recordElement, 'params > area');
            areaOrExtensionLabel = 'Площадь';
        } else if (objectType === 'construction_record') {
            areaOrExtension = getElementValue(recordElement, 'params > extension');
            areaOrExtensionLabel = 'Протяженность';
        } else {
            const areaElement = recordElement.querySelector('params > area');
            areaOrExtensionLabel = getElementValue(areaElement, 'type > value') || 'Площадь';
            const areaValues = areaElement.querySelectorAll('value');
            for (let valueElement of areaValues) {
                const value = valueElement.textContent.trim();
                if (/^\d+(\.\d+)?$/.test(value)) {
                    areaOrExtension = value;
                    break;
                }
            }
        }
        
        const searchUrl = generateSearchUrl(surname, name);
        
        const areaInaccuracy = getElementValue(recordElement, 'params > area > inaccuracy');
        
        let areaOrExtensionString = '';
        if (areaOrExtension) {
            if (areaInaccuracy && areaInaccuracy !== '') {
                areaOrExtensionString = `${areaOrExtension} +/- ${areaInaccuracy} ${objectType === 'construction_record' ? 'м' : 'кв.м.'}`;
            } else {
                areaOrExtensionString = `${areaOrExtension} ${objectType === 'construction_record' ? 'м' : 'кв.м.'}`;
            }
        }

        const objectName = getElementValue(recordElement, 'params > name');
        const permittedUse = getElementValue(recordElement, 'params > permitted_use > permitted_use_established > by_document');

        const registrationDate = getElementValue(recordElement, 'record_info > registration_date');
        const formattedRegistrationDate = registrationDate ? new Date(registrationDate).toLocaleDateString('ru-RU') : '';

        const regNumber = getElementValue(xmlDoc, 'details_statement > group_top_requisites > registration_number');
        const organ = getElementValue(xmlDoc, 'details_statement > group_top_requisites > organ_registr_rights');

        const cadastralValue = getElementValue(recordElement, 'cost > value');
        const formattedCadastralValue = cadastralValue ? parseFloat(cadastralValue).toLocaleString('ru-RU', { minimumFractionDigits: 2, maximumFractionDigits: 2 }) + ' руб.' : 'Нет данных';

        const rightRecords = recordElement.querySelectorAll('right_records > right_record');
        let rightsInfo = [];

        rightRecords.forEach((record, index) => {
            const rightType = getElementValue(record, 'right_data > right_type > value');
            const rightNumber = getElementValue(record, 'right_data > right_number');
            const registrationDate = getElementValue(record, 'record_info > registration_date');
            const formattedRegistrationDate = new Date(registrationDate).toLocaleDateString('ru-RU');

            const shares = record.querySelector('right_data > shares > share');
            let shareInfo = '';
            if (shares) {
                const numerator = getElementValue(shares, 'numerator');
                const denominator = getElementValue(shares, 'denominator');
                shareInfo = `${numerator}/${denominator}`;
            }

            const shareDescription = getElementValue(record, 'right_data > share_description');

            const rightHolders = record.querySelectorAll('right_holders > right_holder');
            rightHolders.forEach((holder) => {
                const individual = holder.querySelector('individual');
                const legalEntity = holder.querySelector('legal_entity');
                const publicFormation = holder.querySelector('public_formation');

                let ownerInfo = '';
                if (individual) {
                    const surname = getElementValue(individual, 'surname');
                    const name = getElementValue(individual, 'name');
                    const patronymic = getElementValue(individual, 'patronymic');
                    const birthDate = getElementValue(individual, 'birth_date');
                    const formattedBirthDate = birthDate ? new Date(birthDate).toLocaleDateString('ru-RU') : '-';
                    ownerInfo = `${surname} ${name} ${patronymic} ${formattedBirthDate}`;
                } else if (legalEntity) {
                    ownerInfo = getElementValue(legalEntity, 'entity > government_entity > full_name') ||
                                getElementValue(legalEntity, 'entity > resident > name') ||
                                getElementValue(legalEntity, 'name');
                } else if (publicFormation) {
                    ownerInfo = getElementValue(publicFormation, 'public_formation_type > municipality > name') ||
                                getElementValue(publicFormation, 'name');
                }

                rightsInfo.push(`<span class="right-info" data-index="${index}">${ownerInfo}   ${rightType}   ${shareInfo} ${shareDescription}   ${rightNumber} от ${formattedRegistrationDate}</span>`);
            });
        });

        const rightsInfoString = rightsInfo.join('<br>');

        const restrictRecords = recordElement.querySelectorAll('restrictions_encumbrances > restriction_encumbrance');
        let restrictionsInfo = [];

        restrictRecords.forEach((record) => {
            const restrictionType = getElementValue(record, 'encumbrance_type > value');
            const restrictionNumber = getElementValue(record, 'cad_link > reg_number_border > number');
            const registrationDate = getElementValue(record, 'starting_date');
            const formattedRegistrationDate = new Date(registrationDate).toLocaleDateString('ru-RU');

            const rightHolders = record.querySelectorAll('right_holders > right_holder');
            if (rightHolders.length > 0) {
                rightHolders.forEach((holder) => {
                    const legalEntity = holder.querySelector('legal_entity');
                    if (legalEntity) {
                        const name = getElementValue(legalEntity, 'entity > resident > name');
                        const inn = getElementValue(legalEntity, 'entity > resident > inn');
                        const ogrn = getElementValue(legalEntity, 'entity > resident > ogrn');
                        restrictionsInfo.push(`${restrictionType} ${restrictionNumber} от ${formattedRegistrationDate} (${name}, ИНН: ${inn}, ОГРН: ${ogrn})`);
                    }
                });
            } else {
                const underlyingDocument = record.querySelector('underlying_docs > underlying_document');
                let documentInfo = '';
                if (underlyingDocument) {
                    const documentName = getElementValue(underlyingDocument, 'document_name');
                    const documentNumber = getElementValue(underlyingDocument, 'document_number');
                    const documentDate = getElementValue(underlyingDocument, 'document_date');
                    documentInfo = ` (${documentName} №${documentNumber} от ${documentDate})`;
                }
                restrictionsInfo.push(`${restrictionType} ${restrictionNumber} от ${formattedRegistrationDate}${documentInfo}`);
            }
        });

        const restrictionsInfoString = restrictionsInfo.join('<br>');

        const coordinates = extractCoordinatesFromXML(xmlContent);
        let coordinatesString = '';
        if (coordinates.length > 0) {
            coordinatesString = `
                <div class="button-group">
                   <button class="button" id="toggleCoordinates"></button>
                   <button class="button" id="copyCoordinates"></button>
                   <button class="button secondary" id="exportDXF">DXF</button>
                   <button class="button secondary" id="exportMIF">MIF</button>
                   <button class="button secondary" id="exportCSV">CSV</button>
                </div>
                <table class="coordinates-table">
                    <tr>
                        <th>Контур</th>
                        <th>№ точки</th>
                        <th>Координата X</th>
                        <th>Координата Y</th>
                        <th>Погрешность</th>
                    </tr>
                    ${coordinates.map((contour, contourIndex) => 
                        contour.map((coord, pointIndex) => `
                            <tr>
                                <td>${contourIndex + 1}</td>
                                <td>${coord.ordNmb || pointIndex + 1}</td>
                                <td>${typeof coord.x === 'number' ? coord.x.toFixed(2) : ''}</td>
                                <td>${typeof coord.y === 'number' ? coord.y.toFixed(2) : ''}</td>
                                <td>${coord.delta.toFixed(2)}</td>
                            </tr>
                        `).join('')
                    ).join('')}
                </table>
            `;
        } else {
            coordinatesString = '<p>Координаты не найдены</p>';
        }

        return `
            <table>
            <tr><td class="clickable" onclick="window.open('https://pkk.rosreestr.ru/#/search/?text=${cadNumber}', '_blank')">Кадастровый номер</td><td><span class="copyable">${cadNumber}</span></td></tr>
            <tr><td>Тип объекта</td><td><span class="copyable">${objectType}</span></td></tr>
            <tr><td class="clickable" onclick="window.open('https://yandex.ru/maps/?text=${encodeURIComponent(shortAddress)}', '_blank')">Адрес</td><td><span class="copyable">${address}</span></td></tr>
            <tr><td class="clickable" onclick="window.open('https://pkk.rosreestr.ru/#/search/?text=${landCadNumbersString}&type=1', '_blank')">Кадастровые номера земельных участков</td><td><span class="copyable">${landCadNumbersString}</span></td></tr>
            <tr><td>${areaOrExtensionLabel}</td><td><span class="copyable">${areaOrExtensionString}</span></td></tr>
            ${objectName ? `<tr><td>Наименование</td><td><span class="copyable">${objectName}</span></td></tr>` : ''}
            ${permittedUse ? `<tr><td>Вид разрешенного использования</td><td><span class="copyable">${permittedUse}</span></td></tr>` : ''}
            <tr><td>Дата постановки на учет</td><td><span class="copyable">${formattedRegistrationDate}</span></td></tr>
            <tr><td class="clickable" onclick="window.open('${searchUrl}', '_blank')">Кадастровый инженер</td><td><span class="copyable">${cadastralEngineer}</span></td></tr>
            <tr><td>Кадастровая стоимость</td><td><span class="copyable">${formattedCadastralValue}</span></td></tr>
            <tr><td>Номер выписки</td><td><span class="copyable">${regNumber}</span></td></tr>
            <tr><td>Дата выписки</td><td><span class="copyable">${date}</span></td></tr>
            <tr><td class="rights-header">Сведения о правах</td><td class="rights-info">${rightsInfoString}</td></tr>
            <tr><td>Ограничения</td><td><span class="copyable">${restrictionsInfoString}</span></td></tr>
            <tr><td>Координаты</td><td>${coordinatesString}</td></tr>
        </table>`;
    }

    function copyHandler(event) {
        const element = event.target;
        let textToCopy = '';

        if (element.classList.contains('rights-header')) {
            textToCopy = element.nextElementSibling.textContent;
        } else if (element.classList.contains('right-info') || element.closest('.right-info')) {
            const rightInfo = element.classList.contains('right-info') ? element.textContent : element.closest('.right-info').textContent;
            const parts = rightInfo.split(/\s{3,}/);
            textToCopy = parts[0].trim();
        } else if (element.classList.contains('copyable')) {
            textToCopy = element.textContent;
        } else {
            return;
        }

        if (textToCopy) {
            copyToClipboard(textToCopy, element.closest('tr'));
        }
    }

    function copyToClipboard(text, element) {
        navigator.clipboard.writeText(text).then(() => {
            element.classList.add('flash');
            setTimeout(() => {
                element.classList.remove('flash');
            }, 1000);
        }).catch(err => {
            console.error('Ошибка при копировании: ', err);
        });
    }

    function copyCoordinates() {
        const contours = extractCoordinatesFromXML(window.xmlContent);
        const textToCopy = contours.map(contour => 
            contour.map(coord => `${coord.x.toFixed(2)}\t${coord.y.toFixed(2)}`).join('\n')
        ).join('\n\n');

        navigator.clipboard.writeText(textToCopy).then(() => {
            const copyButton = document.getElementById('copyCoordinates');
            copyButton.classList.add('flash');
            setTimeout(() => {
                copyButton.classList.remove('flash');
            }, 1000);
        }).catch(err => {
            console.error('Ошибка при копировании: ', err);
        });
    }

    function toggleCoordinates() {
        const table = document.querySelector('.coordinates-table');
        if (table.style.display === "none" || table.style.display === "") {
            table.style.display = "table";
        } else {
            table.style.display = "none";
        }
    }

    function isContourInside(innerContour, outerContour) {
        return innerContour.some(point => isPointInside(point, outerContour));
    }

    function isPointInside(point, polygon) {
        let inside = false;
        for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
            const xi = polygon[i].x, yi = polygon[i].y;
            const xj = polygon[j].x, yj = polygon[j].y;
            
            const intersect = ((yi > point.y) !== (yj > point.y))
                && (point.x < (xj - xi) * (point.y - yi) / (yj - yi) + xi);
            if (intersect) inside = !inside;
        }
        return inside;
    }

    function generateDXF(contours) {
        if (!Array.isArray(contours) || contours.length === 0) {
            console.error('Неверный формат данных контуров');
            return '';
        }

        let dxfContent = `0\nSECTION\n2\nHEADER\n0\nENDSEC\n`;
        dxfContent += `0\nSECTION\n2\nTABLES\n0\nENDSEC\n`;
        dxfContent += `0\nSECTION\n2\nBLOCKS\n0\nENDSEC\n`;
        dxfContent += `0\nSECTION\n2\nENTITIES\n`;

        contours.forEach((contour, contourIndex) => {
            if (!Array.isArray(contour) || contour.length === 0) {
                console.warn(`Пропущен недопустимый контур с индексом ${contourIndex}`);
                return;
            }

            const isClosed = isClosedContour(contour);
            const pointsToProcess = isClosed ? contour.length - 1 : contour.length;

            dxfContent += `0\nLWPOLYLINE\n8\n${contourIndex}\n70\n${isClosed ? 1 : 0}\n`;
            dxfContent += `90\n${pointsToProcess}\n`;

            for (let i = 0; i < pointsToProcess; i++) {
                const point = contour[i];
                if (typeof point !== 'object' || !('x' in point) || !('y' in point)) {
                    console.warn(`Пропущена недопустимая точка в контуре ${contourIndex}, индекс ${i}`);
                    continue;
                }
                dxfContent += `10\n${point.y.toFixed(2)}\n20\n${point.x.toFixed(2)}\n`;
            }
        });

        dxfContent += `0\nENDSEC\n0\nSECTION\n2\nOBJECTS\n0\nENDSEC\n0\nEOF\n`;
        return dxfContent;
    }

    function isClosedContour(contour) {
        if (contour.length < 3) return false;
        const firstPoint = contour[0];
        const lastPoint = contour[contour.length - 1];
        return Math.abs(firstPoint.x - lastPoint.x) < 0.001 && 
               Math.abs(firstPoint.y - lastPoint.y) < 0.001;
    }

    function generateMIF(contours) {
        if (!Array.isArray(contours) || contours.length === 0) {
            console.error('Неверный формат данных контуров');
            return '';
        }

        const allPoints = contours.reduce((acc, contour) => acc.concat(contour), []);
        const minX = Math.min(...allPoints.map(p => p.x));
        const minY = Math.min(...allPoints.map(p => p.y));
        const maxX = Math.max(...allPoints.map(p => p.x));
        const maxY = Math.max(...allPoints.map(p => p.y));

        let mifContent = `Version 300
Charset "WindowsCyrillic"
Delimiter ";"
CoordSys Nonearth Units "m" Bounds 
(${minY.toFixed(2)}, ${minX.toFixed(2)}) (${maxY.toFixed(2)}, ${maxX.toFixed(2)})
Columns 7
LayerName Char(32)
LayerNumber Integer
ObjectName Char(32)
ObjectCode Integer
ObjectNumber Integer
ObjectLocal Integer
ObjectKey Char(32)
Data
`;

        contours.forEach((contour, index) => {
            if (!Array.isArray(contour) || contour.length === 0) {
                console.warn(`Пропущен недопустимый контур с индексом ${index}`);
                return;
            }

            mifContent += `Pline ${contour.length}\n`;
            contour.forEach(point => {
                if (typeof point !== 'object' || !('x' in point) || !('y' in point)) {
                    console.warn(`Пропущена недопустимая точка в контуре ${index}`);
                    return;
                }
                mifContent += `${point.y.toFixed(3)} ${point.x.toFixed(3)}\n`;
            });
            mifContent += `Pen (1,2,16733695)\n`;
            if (index < contours.length - 1) {
                mifContent += '\n';
            }
        });

        return mifContent;
    }

    function generateAndDownloadMIF() {
        const contours = extractCoordinatesFromXML(window.xmlContent);
        if (!Array.isArray(contours) || contours.length === 0) {
            alert('Не удалось извлечь координаты из XML. Пожалуйста, проверьте формат файла.');
            return;
        }

        const mifContent = generateMIF(contours);
        if (mifContent === '') {
            alert('Не удалось сгенерировать MIF. Пожалуйста, проверьте данные координат.');
            return;
        }

        const blob = new Blob([mifContent], { type: 'text/plain' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'output.mif';
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
    }

    function generateAndDownloadDXF() {
        const contours = extractCoordinatesFromXML(window.xmlContent);
        if (!Array.isArray(contours) || contours.length === 0) {
            alert('Не удалось извлечь координаты из XML. Пожалуйста, проверьте формат файла.');
            return;
        }

        const dxfContent = generateDXF(contours);
        if (dxfContent === '') {
            alert('Не удалось сгенерировать DXF. Пожалуйста, проверьте данные координат.');
            return;
        }

        const blob = new Blob([dxfContent], { type: 'application/dxf' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'output.dxf';
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
    }

    function generateCSV(contours) {
        if (!Array.isArray(contours) || contours.length === 0) {
            console.error('Неверный формат данных контуров');
            return '';
        }

        let csvContent = "Контур;Префикс номера;Номер;Старый X;Старый Y;Новый X;Новый Y;Метод определения;Формула;Радиус;Погрешность;Описание закрепления\n";
        csvContent += ";;;;;;;;;;;\n";

        let mainContourIndex = 1;
        let innerContourIndex = 1;

        contours.forEach((contour, contourIndex) => {
            if (!Array.isArray(contour) || contour.length === 0) {
                console.warn(`Пропущен недопустимый контур с индексом ${contourIndex}`);
                return;
            }

            if (contourIndex > 0) {
                csvContent += ";;;;;;;;;;;\n";
            }

            let contourName;
            let isInner = false;
            if (contourIndex === 0) {
                contourName = `${mainContourIndex}`;
                mainContourIndex++;
            } else if (isContourInside(contour, contours[0])) {
                contourName = `${mainContourIndex - 1}.${innerContourIndex}`;
                innerContourIndex++;
                isInner = true;
            } else {
                contourName = `${mainContourIndex}`;
                mainContourIndex++;
                innerContourIndex = 1;
            }

            const isClosed = isClosedContour(contour);

            contour.forEach((point, index) => {
                if (typeof point !== 'object' || !('x' in point) || !('y' in point) || !('delta' in point)) {
                    console.warn(`Пропущена недопустимая точка в контуре ${contourName}, индекс ${index}`);
                    return;
                }

                let pointNumber = index + 1;
                let prefix = isInner ? '' : 'н';

                if (isClosed && index === contour.length - 1) {
                    pointNumber = 1;
                }

                csvContent += `[${contourName}];${prefix};${pointNumber};;;${point.x.toFixed(2)};${point.y.toFixed(2)};;;;${point.delta.toFixed(2)};Долговременный межевой знак\n`;
            });
        });

        return csvContent;
    }

  
    function generateAndDownloadCSV() {
        const contours = extractCoordinatesFromXML(window.xmlContent);
        if (!Array.isArray(contours) || contours.length === 0) {
            alert('Не удалось извлечь координаты из XML. Пожалуйста, проверьте формат файла.');
            return;
        }

        const csvContent = generateCSV(contours);
        if (csvContent === '') {
            alert('Не удалось сгенерировать CSV. Пожалуйста, проверьте данные координат.');
            return;
        }
        
        const bom = '\uFEFF';
        const csvWithBom = bom + csvContent;
        
        const blob = new Blob([csvWithBom], { type: 'text/csv;charset=utf-8;' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'output.csv';
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
    }

    document.getElementById('fileInput').addEventListener('change', function(event) {
        const file = event.target.files[0];
        if (file) {
            const reader = new FileReader();
            reader.onload = function(e) {
                const fileContent = e.target.result;
                if (file.name.endsWith('.xml')) {
                    window.xmlContent = fileContent;
                    processXMLContent(fileContent);
                    currentCoords = extractCoordinatesFromXML(fileContent);
                    showScheme();
                } else if (file.name.endsWith('.zip')) {
                    processZipFile(fileContent);
                } else {
                    alert('Пожалуйста, выберите файл XML или ZIP.');
                }

                const label = document.getElementById('fileInputLabel');
                label.textContent = file.name;
            };
            if (file.name.endsWith('.xml')) {
                reader.readAsText(file);
            } else if (file.name.endsWith('.zip')) {
                reader.readAsArrayBuffer(file);
            }
        }
    });

    function processXMLContent(xmlContent) {
        window.xmlContent = xmlContent;
        const extractedData = extractData(xmlContent);
        document.getElementById('output').innerHTML = extractedData;

        const copyables = document.querySelectorAll('.copyable, .rights-header, .right-info');
        copyables.forEach(el => {
            el.addEventListener('click', copyHandler);
        });

        const toggleCoordinatesButton = document.getElementById('toggleCoordinates');
        if (toggleCoordinatesButton) {
            toggleCoordinatesButton.innerHTML = '<i class="fas fa-eye"></i>';
            toggleCoordinatesButton.addEventListener('click', toggleCoordinates);
        }

        const copyCoordinatesButton = document.getElementById('copyCoordinates');
        if (copyCoordinatesButton) {
            copyCoordinatesButton.innerHTML = '<i class="fas fa-copy"></i>';
            copyCoordinatesButton.addEventListener('click', copyCoordinates);
        }

        const exportDXFButton = document.getElementById('exportDXF');
        if (exportDXFButton) {
            exportDXFButton.innerHTML = '<i class="fas fa-file-export"></i>DXF';
            exportDXFButton.classList.add('export');
            exportDXFButton.addEventListener('click', () => generateAndDownloadDXF(extractCoordinatesFromXML(xmlContent)));
        }

        const exportMIFButton = document.getElementById('exportMIF');
        if (exportMIFButton) {
            exportMIFButton.innerHTML = '<i class="fas fa-file-export"></i>MIF';
            exportMIFButton.classList.add('export');
            exportMIFButton.addEventListener('click', () => generateAndDownloadMIF(extractCoordinatesFromXML(xmlContent)));
        }

        const exportCSVButton = document.getElementById('exportCSV');
        if (exportCSVButton) {
            exportCSVButton.innerHTML = '<i class="fas fa-file-csv"></i>CSV';
            exportCSVButton.classList.add('export');
            exportCSVButton.addEventListener('click', () => generateAndDownloadCSV(extractCoordinatesFromXML(xmlContent)));
        }

        const label = document.getElementById('fileInputLabel');
        label.textContent = 'XML файл загружен';
    }
    
    function processZipFile(zipContent) {
        JSZip.loadAsync(zipContent).then(function(zip) {
            let xmlFile = null;
            let xmlFileName = '';
            zip.forEach(function(relativePath, zipEntry) {
                if (relativePath.endsWith('.xml')) {
                    xmlFile = zipEntry;
                    xmlFileName = relativePath.split('/').pop(); // Получаем имя файла из пути
                }
            });

            if (xmlFile) {
                xmlFile.async('string').then(function(xmlContent) {
                    window.xmlContent = xmlContent;
                    processXMLContent(xmlContent);
                    
                    // Обновляем название кнопки
                    const label = document.getElementById('fileInputLabel');
                    label.textContent = xmlFileName;

                    // Извлекаем координаты и отрисовываем схему
                    currentCoords = extractCoordinatesFromXML(xmlContent);
                    showScheme();
                });
            } else {
                alert('XML-файл не найден в архиве ZIP.');
            }
        }).catch(function(error) {
            console.error('Ошибка при обработке ZIP-файла:', error);
            alert('Ошибка при обработке ZIP-файла.');
        });
    }
          
    // Глобальная переменная для отслеживания, была ли уже создана схема
    let currentCoords = null;
    let schemeCreated = false;
    let showDistances = true;
    let showPointNumbers = true;

    function showScheme() {
        const coords = currentCoords || extractCoordinatesFromXML(window.xmlContent);
        const cadNumber = extractCadastralNumber(window.xmlContent);

        // Удаляем существующий контейнер схемы, если он есть
        const existingContainer = document.getElementById('schemeContainer');
        if (existingContainer) {
            existingContainer.remove();
        }

        // Создаем новый контейнер схемы
        const schemeContainer = document.createElement('div');
        schemeContainer.id = 'schemeContainer';
        schemeContainer.style.width = '100%';
        schemeContainer.style.height = '600px';
        schemeContainer.style.margin = '20px auto';
        schemeContainer.style.position = 'relative';

        const canvas = document.createElement('canvas');
        canvas.id = 'schemeCanvas';
        canvas.style.width = '100%';
        canvas.style.height = '100%';
        canvas.style.border = '1px solid #007bff';
        canvas.style.borderRadius = '10px';

        schemeContainer.appendChild(canvas);

        // Добавляем canvas в конец body
        document.body.appendChild(schemeContainer);

        // Добавляем кнопку "глаз"
        const eyeButton = document.createElement('button');
        eyeButton.innerHTML = '<i class="fas fa-eye"></i>';
        eyeButton.style.position = 'absolute';
        eyeButton.style.top = '10px';
        eyeButton.style.right = '10px';
        eyeButton.style.zIndex = '1000';
        eyeButton.style.background = 'white';
        eyeButton.style.border = '1px solid #007bff';
        eyeButton.style.borderRadius = '5px';
        eyeButton.style.padding = '5px 10px';
        schemeContainer.appendChild(eyeButton);

        eyeButton.addEventListener('click', () => {
            if (showDistances && showPointNumbers) {
                showDistances = false;
            } else if (!showDistances && showPointNumbers) {
                showPointNumbers = false;
            } else {
                showDistances = true;
                showPointNumbers = true;
            }
            drawScheme();
        });

        schemeCreated = true;
        currentCoords = coords;

        // Вызываем функцию отрисовки схемы
        drawScheme();

        // Добавляем обработчик события изменения размера окна
        window.addEventListener('resize', drawScheme);
    }

    function drawScheme() {
        const canvas = document.getElementById('schemeCanvas');
        if (!canvas) return;

        const ctx = canvas.getContext('2d');
        canvas.width = canvas.offsetWidth;
        canvas.height = canvas.offsetHeight;

        ctx.fillStyle = 'white';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        if (!currentCoords || currentCoords.length === 0) return;

        const allCoords = currentCoords.flat();
        const minX = Math.min(...allCoords.map(p => p.x));
        const minY = Math.min(...allCoords.map(p => p.y));
        const maxX = Math.max(...allCoords.map(p => p.x));
        const maxY = Math.max(...allCoords.map(p => p.y));

        const scaleX = (canvas.width - 60) / (maxY - minY);
        const scaleY = (canvas.height - 60) / (maxX - minX);
        const scale = Math.min(scaleX, scaleY) * 0.9;

        const offsetX = (canvas.width - (maxY - minY) * scale) / 2;
        const offsetY = (canvas.height - (maxX - minX) * scale) / 2;

        const transformCoord = (x, y) => [
            offsetX + (y - minY) * scale,
            canvas.height - (offsetY + (x - minX) * scale)
        ];

        currentCoords.forEach((contour, contourIndex) => {
            ctx.beginPath();
            contour.forEach(({x, y}, index) => {
                const [canvasX, canvasY] = transformCoord(x, y);
                if (index === 0) {
                    ctx.moveTo(canvasX, canvasY);
                } else {
                    ctx.lineTo(canvasX, canvasY);
                }
            });

            if (isClosedContour(contour)) {
                ctx.closePath();
            }

            ctx.strokeStyle = contourIndex === 0 ? 'black' : 'red';
            ctx.lineWidth = 2;
            ctx.stroke();

            if (showPointNumbers) {
                ctx.fillStyle = contourIndex === 0 ? 'red' : 'blue';
                ctx.font = '14px Arial';
                contour.forEach(({x, y, ordNmb}, index) => {
                    if (index === contour.length - 1 && isClosedContour(contour)) return;
                    const [canvasX, canvasY] = transformCoord(x, y);
                    ctx.beginPath();
                    ctx.arc(canvasX, canvasY, 4, 0, 2 * Math.PI);
                    ctx.fill();
                    ctx.fillText(ordNmb, canvasX + 7, canvasY - 7);
                });
            }

            if (showDistances) {
                ctx.font = '12px Arial';
                ctx.fillStyle = 'black';
                contour.forEach(({x: x1, y: y1}, index) => {
                    const {x: x2, y: y2} = contour[(index + 1) % contour.length];
                    if (index === contour.length - 1 && isClosedContour(contour)) return;
                    const [canvasX1, canvasY1] = transformCoord(x1, y1);
                    const [canvasX2, canvasY2] = transformCoord(x2, y2);
                    const distance = Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);
                    const midX = (canvasX1 + canvasX2) / 2;
                    const midY = (canvasY1 + canvasY2) / 2;

                    const angle = Math.atan2(canvasY2 - canvasY1, canvasX2 - canvasX1);
                    const offset = 15;
                    const textX = midX + offset * Math.sin(angle);
                    const textY = midY - offset * Math.cos(angle);

                    ctx.save();
                    ctx.translate(textX, textY);
                    ctx.rotate(angle);
                    ctx.fillText(`${distance.toFixed(2)} м`, 0, 0);
                    ctx.restore();
                });
            }
        });

        ctx.fillStyle = 'black';
        ctx.font = '16px Arial';
        ctx.fillText(`Кадастровый номер: ${extractCadastralNumber(window.xmlContent)}`, 10, 20);

        const totalPerimeter = currentCoords.reduce((sum, contour) => sum + calculatePerimeter(contour), 0);
        const totalArea = currentCoords.reduce((sum, contour) => sum + calculateArea(contour), 0);
        ctx.font = '16px Arial';
        ctx.fillText(`Периметр: ${totalPerimeter.toFixed(2)} м`, 10, 50);
        ctx.fillText(`Площадь: ${totalArea.toFixed(2)} кв.м`, 10, 80);

        drawRulers(ctx, minX, minY, maxX, maxY, offsetX, offsetY, scale, canvas.width, canvas.height);
    }

    function drawRulers(ctx, minX, minY, maxX, maxY, offsetX, offsetY, scale, canvasWidth, canvasHeight) {
        ctx.strokeStyle = 'royalblue';
        ctx.fillStyle = 'royalblue';
        ctx.font = '12px Arial';
        ctx.textAlign = 'center';

        function getOptimalStep(range) {
            const steps = [5, 10, 20, 50, 100, 200, 500, 1000];
            const targetDivisions = 5;
            return steps.find(step => range / step <= targetDivisions) || steps[steps.length - 1];
        }

        const bottomY = canvasHeight - 20;
        ctx.beginPath();
        ctx.moveTo(offsetX, bottomY);
        ctx.lineTo(canvasWidth - offsetX, bottomY);
        ctx.stroke();

        const horizontalRange = maxY - minY;
        const horizontalStep = getOptimalStep(horizontalRange);
        for (let y = Math.ceil(minY / horizontalStep) * horizontalStep; y <= maxY; y += horizontalStep) {
            const canvasX = offsetX + (y - minY) * scale;
            ctx.beginPath();
            ctx.moveTo(canvasX, bottomY);
            ctx.lineTo(canvasX, bottomY + 5);
            ctx.stroke();
            ctx.fillText(`${Math.round(y - minY)} м`, canvasX, bottomY + 15);
        }

        const rightX = canvasWidth - 20;
        ctx.beginPath();
        ctx.moveTo(rightX, offsetY);
        ctx.lineTo(rightX, canvasHeight - offsetY - 30);
        ctx.stroke();

        ctx.textAlign = 'right';
        const verticalRange = maxX - minX;
        const verticalStep = getOptimalStep(verticalRange);
            for (let x = Math.ceil(minX / verticalStep) * verticalStep; x <= maxX; x += verticalStep) {
            const canvasY = canvasHeight - (offsetY + (x - minX) * scale);
            ctx.beginPath();
            ctx.moveTo(rightX, canvasY);
            ctx.lineTo(rightX + 5, canvasY);
            ctx.stroke();
            ctx.fillText(`${Math.round(x - minX)} м`, rightX - 5, canvasY + 4);
        }
    }

    function calculatePerimeter(contour) {
        let perimeter = 0;
        for (let i = 0; i < contour.length; i++) {
            const {x: x1, y: y1} = contour[i];
            const {x: x2, y: y2} = contour[(i + 1) % contour.length];
            perimeter += Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);
        }
        return perimeter;
    }

    function calculateArea(contour) {
        let area = 0;
        for (let i = 0; i < contour.length; i++) {
            const {x: x1, y: y1} = contour[i];
            const {x: x2, y: y2} = contour[(i + 1) % contour.length];
            area += x1 * y2 - y1 * x2;
        }
        return Math.abs(area) / 2;
    }

    // Вызываем функцию отрисовки схемы
    drawScheme();

    // Добавляем обработчик события изменения размера окна
    window.addEventListener('resize', drawScheme);

    // Добавим функцию для извлечения кадастрового номера из XML
    function extractCadastralNumber(xmlContent) {
        const parser = new DOMParser();
        const xmlDoc = parser.parseFromString(xmlContent, "text/xml");
        const cadNumberElement = xmlDoc.querySelector('build_record > object > common_data > cad_number, construction_record > object > common_data > cad_number, land_record > object > common_data > cad_number');
        return cadNumberElement ? cadNumberElement.textContent : 'Не найден';
    }

    // Обновите обработчик событий для файлового ввода
    document.getElementById('fileInput').addEventListener('change', function(event) {
        const file = event.target.files[0];
        if (file) {
            const reader = new FileReader();
            reader.onload = function(e) {
                const fileContent = e.target.result;
                if (file.name.endsWith('.xml')) {
                    window.xmlContent = fileContent;
                    processXMLContent(fileContent);
                    currentCoords = extractCoordinatesFromXML(fileContent);
                    showScheme();
                } else if (file.name.endsWith('.zip')) {
                    processZipFile(fileContent);
                } else {
                    alert('Пожалуйста, выберите файл XML или ZIP.');
                }

                const label = document.getElementById('fileInputLabel');
                label.textContent = file.name;
            };
            if (file.name.endsWith('.xml')) {
                reader.readAsText(file);
            } else if (file.name.endsWith('.zip')) {
                reader.readAsArrayBuffer(file);
            }
        }
    });

    function getRandomColor() {
        return '#' + Math.floor(Math.random()*16777215).toString(16);
    }
    </script>
</body>
</html>





                 

