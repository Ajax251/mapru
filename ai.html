<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github.min.css" id="hljs-theme">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.11.338/pdf.min.js"></script>
    <link rel="icon" href="img/ai.svg" type="image/svg+xml" id="favicon">
  <style>
  * { margin: 0; padding: 0; box-sizing: border-box; transition: background-color 0.3s ease, color 0.3s ease, border-color 0.3s ease, box-shadow 0.3s ease; }
:root {
    --base-font-size: 14px;
    --bg-color: #f8f9fa;
    --container-bg: #ffffff;
    --message-user-bg: #e8f0fe;
    --message-user-border: #d2e3fc;
    --message-bot-bg: #f8f9fa;
    --message-bot-border: #e8eaed;
    --message-user-color: #202124;
    --message-bot-color: #202124;
    --input-bg: #ffffff;
    --input-border: #dadce0;
    --input-text: #202124;
    --button-bg: #1a73e8;
    --button-bg-hover: #1765cc;
    --button-color: white;
    --selector-bg: #ffffff;
    --option-hover: #f1f3f4;
    --option-selected: #e8f0fe;
    --option-selected-border: #1a73e8;
    --copy-button-bg: var(--message-bot-bg);
    --copy-button-hover-bg: var(--option-hover);
    --copy-button-border: var(--message-bot-border);
    --typing-indicator-bg: #f8f9fa;
    --typing-dot-color: #5f6368;
    --shadow-color: rgba(0, 0, 0, 0.1);
    --border-color: #dadce0;
    --accent-color: #1a73e8;
    --notification-color: #1a73e8;
    --header-color: #202124;
    --code-font-size: calc(var(--base-font-size) * 0.88);
    --code-bg: #f1f3f4;
    --code-header-bg: #e8eaed;
    --code-border: #dadce0;
    --code-copy-button-bg: #ffffff;
    --code-copy-button-border: #dadce0;
    --code-copy-button-color: #5f6368;
    --code-copy-button-hover-bg: #f1f3f4;
    --code-copy-button-hover-border: #1a73e8;
    --scrollbar-thumb: #bdc1c6;
    --scrollbar-track: #f1f3f4;
    --modal-bg: #ffffff;
    --modal-border: #dadce0;
    --modal-shadow: rgba(0, 0, 0, 0.2);
    --modal-textarea-bg: #f8f9fa;
    --modal-textarea-border: #dadce0;
    --modal-textarea-color: #202124;
    --selection-bg: #accef7;
    --selection-color: #1f1f1f;
    --settings-color-proxy-lite: #64B5F6;
    --settings-color-proxy-standard: #1976D2;
    --settings-color-direct-lite: #FFA726;
    --settings-color-direct-standard: #D32F2F;
    --settings-color-claude: #66BB6A;
}
body.dark-theme {
    --bg-color: #132036;
    --container-bg: #172a45;
    --message-user-bg: #2c3a5a;
    --message-user-border: #69a7df;
    --message-bot-bg: #1b253b;
    --message-bot-border: #314262;
    --message-user-color: #eaf6ff;
    --message-bot-color: #f3f9fb;
    --input-bg: #1c2842;
    --input-border: #3d5a8c;
    --input-text: #e4f0f4;
    --button-bg: #259af7;
    --button-bg-hover: #41c6e0;
    --button-color: #07111f;
    --selector-bg: #172a45;
    --option-hover: #223c5c;
    --option-selected: #223e60;
    --option-selected-border: #3edbea;
    --copy-button-bg: var(--message-bot-bg);
    --copy-button-hover-bg: var(--option-hover);
    --copy-button-border: var(--message-bot-border);
    --typing-indicator-bg: #203051;
    --typing-dot-color: #84d1fa;
    --shadow-color: rgba(10, 63, 102, 0.45);
    --border-color: #31517a;
    --accent-color: #56c8fa;
    --notification-color: #259af7;
    --header-color: #e0eafe;
    --code-bg: #20334d;
    --code-header-bg: #284066;
    --code-border: #31517a;
    --code-copy-button-bg: #1c2842;
    --code-copy-button-border: #3d5a8c;
    --code-copy-button-color: #e4f0f4;
    --code-copy-button-hover-bg: #223c5c;
    --code-copy-button-hover-border: #56c8fa;
    --scrollbar-thumb: #4a6d9f;
    --scrollbar-track: #20334d;
    --modal-bg: #172a45;
    --modal-border: #31517a;
    --modal-shadow: rgba(10, 63, 102, 0.6);
    --modal-textarea-bg: #1c2842;
    --modal-textarea-border: #3d5a8c;
    --modal-textarea-color: #e4f0f4;
    --selection-bg: #56c8fa;
    --selection-color: #07111f;
    filter: brightness(1) contrast(1.07) sepia(0.07);
    --settings-color-proxy-lite: #81D4FA;
    --settings-color-proxy-standard: #42A5F5;
    --settings-color-direct-lite: #FFB74D;
    --settings-color-direct-standard: #E53935;
    --settings-color-claude: #81C784;
}
.container { max-width: none; width: 100%; margin: 0; padding: 0; box-shadow: none !important; border: none !important; }
#chat-container { border: none !important; background-color: var(--bg-color); }
#input-container { border-top: none !important; box-shadow: none !important; border: none !important; padding-left: 20px; padding-right: 20px; }
:root .user-message .copy-button { --copy-button-bg: var(--message-user-bg); --copy-button-border: var(--message-user-border); }
body.dark-theme .user-message .copy-button { --copy-button-bg: var(--message-user-bg); --copy-button-border: var(--message-user-border); }
html, body { height: 100%; width: 100%; -webkit-font-smoothing: antialiased; }
body { font-family: 'Google Sans', 'Roboto', Arial, sans-serif; background-color: var(--bg-color); display: flex; flex-direction: column; color: var(--message-bot-color); }
.container { height: 100%; display: flex; flex-direction: column; position: relative; background-color: var(--container-bg); }
.header { display: flex; align-items: center; justify-content: space-between; padding: 12px 20px; z-index: 10; background-color: var(--bg-color); border-bottom: 1px solid var(--border-color); flex-shrink: 0; }
.header-title { font-size: 20px; font-weight: 500; color: var(--header-color); display: flex; align-items: center; cursor: pointer; padding: 5px 10px; border-radius: 8px; transition: all 0.3s ease; -webkit-tap-highlight-color: transparent; user-select: none; }
.header-title:hover { background-color: var(--option-hover); }
.header-logo { width: 24px; height: 24px; margin-right: 8px; }
@keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
.font-size-button { width: 36px; height: 36px; border-radius: 50%; background: var(--container-bg); border: 1px solid var(--border-color); cursor: pointer; display: flex; align-items: center; justify-content: center; font-weight: bold; color: var(--accent-color); transition: all 0.2s ease; -webkit-tap-highlight-color: transparent; }
.font-size-button:hover { background-color: var(--option-hover); }
.font-size-button-clicked { transform: scale(1.1); background-color: var(--option-selected); }
.theme-toggle { width: 36px; height: 36px; border-radius: 50%; background: transparent; border: none; cursor: pointer; display: flex; align-items: center; justify-content: center; position: relative; transition: background-color 0.2s ease; }
.theme-toggle:hover { background-color: var(--option-hover); }
.theme-toggle svg { width: 20px; height: 20px; fill: var(--accent-color); transition: transform 0.3s ease; }
:root .theme-toggle svg.sun-icon { display: block; } :root .theme-toggle svg.moon-icon { display: none; } body.dark-theme .theme-toggle svg.sun-icon { display: none; } body.dark-theme .theme-toggle svg.moon-icon { display: block; }
.theme-toggle:active svg { transform: scale(0.8); }

/* --- Start Selector Styles --- */
#model-selector-container, #api-mode-selector-container { position: relative; }
#model-selector-button, #api-mode-selector-button {
    padding: 8px 12px 8px 12px; border: 1px solid var(--border-color);
    border-radius: 24px; background: var(--container-bg);
    cursor: pointer; transition: all 0.2s ease; font-size: 13px; color: var(--message-bot-color);
    display: flex; align-items: center; gap: 8px;
    min-width: 180px; max-width: 280px;
    text-overflow: ellipsis; white-space: nowrap; overflow: hidden; justify-content: space-between;
}
#model-selector-button:hover, #api-mode-selector-button:hover { background: var(--option-hover); }
#model-selector-button::after, #api-mode-selector-button::after { content: ''; width: 6px; height: 6px; border-right: 1.5px solid var(--message-bot-color); border-bottom: 1.5px solid var(--message-bot-color); transform: rotate(45deg); flex-shrink: 0; margin-left: 5px; }
#api-mode-selector-button .icon { width: 16px; height: 16px; fill: var(--accent-color); flex-shrink: 0; }
#api-mode-selector-button .text { flex-grow: 1; text-align: left; overflow: hidden; text-overflow: ellipsis; }

#model-options, #api-mode-options {
    position: absolute; top: 45px; right: 0; background: var(--selector-bg);
    border-radius: 8px; box-shadow: 0 2px 10px var(--shadow-color);
    padding: 8px 0; list-style: none; opacity: 0; visibility: hidden;
    transform: translateY(-10px); transition: opacity 0.2s ease, transform 0.2s ease, visibility 0.2s;
    z-index: 100; border: 1px solid var(--border-color);
    width: 250px; max-height: 400px; overflow-y: auto;
}
#model-options.show, #api-mode-options.show { opacity: 1; visibility: visible; transform: translateY(0); }
.model-option, .api-mode-option {
    padding: 10px 16px; cursor: pointer; font-size: 13px;
    transition: background-color 0.2s ease; color: var(--message-bot-color);
    white-space: normal; word-break: break-word; display: flex; align-items: center; gap: 10px;
}
.model-option:hover, .api-mode-option:hover { background-color: var(--option-hover); }
.model-option.selected, .api-mode-option.selected {
    background-color: var(--option-selected); border-left: 3px solid var(--option-selected-border);
    font-weight: 500; padding-left: 13px;
}
.api-mode-option .icon { width: 16px; height: 16px; fill: var(--accent-color); flex-shrink: 0; }
/* --- End Selector Styles --- */

#chat-container { flex: 1; overflow-y: auto; scroll-behavior: smooth; padding: 16px 20px; background-color: var(--bg-color); }
#chat-container::-webkit-scrollbar { width: 8px; } #chat-container::-webkit-scrollbar-track { background-color: var(--bg-color); border-radius: 4px; } #chat-container::-webkit-scrollbar-thumb { background-color: var(--border-color); border-radius: 4px; border: 2px solid var(--bg-color); } #chat-container::-webkit-scrollbar-thumb:hover { background-color: var(--accent-color); }
.message { margin-bottom: 16px; animation: fadeIn 0.3s ease; position: relative; max-width: 90%; clear: both; }
@keyframes fadeIn { 0% { opacity: 0; transform: translateY(10px); } 100% { opacity: 1; transform: translateY(0); } }
.message-content { padding: 10px 14px 24px 14px; border-radius: 8px; white-space: pre-wrap; word-wrap: break-word; line-height: 1.5; font-size: var(--base-font-size); transition: box-shadow 0.2s ease; position: relative; user-select: text !important; }
.user-message { float: right; }
.user-message .message-content { background-color: var(--message-user-bg); color: var(--message-user-color); border: 1px solid var(--message-user-border); border-bottom-right-radius: 4px; }
.bot-message { float: left; }
.bot-message .message-content { background-color: var(--message-bot-bg); color: var(--message-bot-color); border: 1px solid var(--message-bot-border); border-bottom-left-radius: 4px; }
.message-content:hover { box-shadow: 0 2px 8px var(--shadow-color); }
.copy-button { width: 26px; height: 26px; border-radius: 50%; background: var(--copy-button-bg); border: 1px solid var(--copy-button-border); opacity: 0; transition: opacity 0.2s ease, transform 0.2s ease, background-color 0.2s ease; cursor: pointer; display: flex; align-items: center; justify-content: center; box-shadow: 0 1px 3px var(--shadow-color); z-index: 5; display: block; position: absolute; bottom: 4px; }
.user-message .copy-button { right: 4px; margin-left: auto; margin-right: 0; } .bot-message .copy-button { left: 4px; margin-left: 0; margin-right: auto; }
.message:hover .copy-button:not(.code-copy-button) { opacity: 0.8; } .copy-button:not(.code-copy-button):hover { opacity: 1; transform: scale(1.1); background-color: var(--copy-button-hover-bg); }
.copy-button svg { stroke: var(--message-bot-color); width: 14px; height: 14px; } body.dark-theme .user-message .copy-button svg { stroke: var(--message-user-color); } body.dark-theme .bot-message .copy-button svg { stroke: var(--message-bot-color); } :root .user-message .copy-button svg { stroke: var(--message-user-color); } :root .bot-message .copy-button svg { stroke: var(--message-bot-color); }
@keyframes copyFlash { 0% { transform: scale(1); } 50% { transform: scale(1.05); } 100% { transform: scale(1); } } .copy-button.copy-flash { animation: copyFlash 0.3s ease-out; }
#input-container { display: flex; padding: 12px 20px; background-color: var(--bg-color); align-items: flex-end; gap: 10px; }
#message-input { flex-grow: 1; padding: 10px 16px; border: 1px solid var(--input-border); border-radius: 20px; font-size: var(--base-font-size); background-color: var(--input-bg); color: var(--input-text); resize: none; min-height: 42px; max-height: 150px; overflow-y: auto; box-shadow: 0 1px 2px var(--shadow-color); font-family: 'Google Sans', 'Roboto', Arial, sans-serif; line-height: 1.4; }
#message-input::placeholder { color: var(--input-text); opacity: 0.6; } #message-input:focus { outline: none; border-color: var(--accent-color); box-shadow: 0 0 0 1px var(--accent-color); } body.dark-theme #message-input:focus { box-shadow: 0 0 0 1px var(--accent-color); }
#file-input { display: none; }
#desktop-upload-button { padding: 0; width: 38px; height: 38px; border-radius: 50%; background-color: transparent; color: var(--accent-color); cursor: pointer; transition: background-color 0.2s ease; display: flex; align-items: center; justify-content: center; border: none; flex-shrink: 0; margin-bottom: 2px; }
#desktop-upload-button:hover { background-color: var(--option-hover); } #desktop-upload-button svg { width: 22px; height: 22px; fill: var(--accent-color); }
#send-button { width: 38px; height: 38px; border-radius: 50%; background-color: var(--button-bg); color: var(--button-color); cursor: pointer; transition: all 0.2s ease; display: flex; align-items: center; justify-content: center; border: none; flex-shrink: 0; margin-bottom: 2px; }
#send-button:hover { background-color: var(--button-bg-hover); } #send-button svg { width: 18px; height: 18px; fill: var(--button-color); }
#desktop-upload-button.file-selected { background-color: var(--option-selected); }
.typing-indicator { background-color: var(--typing-indicator-bg); padding: 10px 16px; border-radius: 18px; display: inline-flex; align-items: center; margin-bottom: 16px; box-shadow: 0 1px 3px var(--shadow-color); border: 1px solid var(--message-bot-border); float: left; clear: both; position: relative; overflow: hidden; }
.typing-indicator::after { content: ""; position: absolute; width: 50px; height: 50px; background: radial-gradient(circle, var(--accent-color) 0%, transparent 70%); opacity: 0.15; border-radius: 50%; top: 50%; left: 50%; transform: translate(-50%, -50%); animation: pulse-wave 2s infinite; }
@keyframes pulse-wave { 0%, 100% { transform: translate(-50%, -50%) scale(0.5); opacity: 0.1; } 50% { transform: translate(-50%, -50%) scale(1.2); opacity: 0.2; } }
.typing-dot { width: 7px; height: 7px; margin: 0 3px; background-color: var(--typing-dot-color); border-radius: 50%; display: inline-block; animation: wave 1.5s infinite ease-in-out; }
.typing-dot:nth-child(1) { animation-delay: 0s; } .typing-dot:nth-child(2) { animation-delay: 0.2s; } .typing-dot:nth-child(3) { animation-delay: 0.4s; }
@keyframes wave { 0%, 60%, 100% { transform: translateY(0); } 30% { transform: translateY(-8px); } }
.time-display { font-size: 11px; opacity: 0.7; margin-top: 6px; color: var(--accent-color); width: 100%; }
.user-message .time-display { text-align: right; } .bot-message .time-display { text-align: left; } body.dark-theme .time-display { color: #6ee2ee; opacity: 0.65; }
.message-image { max-width: 100%; border-radius: 8px; margin-top: 8px; border: 1px solid var(--border-color); display: block; cursor: pointer; transition: transform 0.2s ease; } .message-image:hover { transform: scale(1.02); }
.notification { position: fixed; top: 15px; left: 50%; transform: translateX(-50%) translateY(-100px); background-color: var(--notification-color); color: white; padding: 10px 15px; border-radius: 6px; font-size: 14px; box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15); z-index: 1000; opacity: 0; transition: transform 0.3s ease, opacity 0.3s ease; display: flex; align-items: center; gap: 8px; max-width: 90%; }
.notification.show { transform: translateX(-50%) translateY(0); opacity: 1; } .notification-icon { font-size: 16px; }
.clearfix::after { content: ""; clear: both; display: table; }
::selection { background: var(--selection-bg); color: var(--selection-color); }
body.dark-theme ::selection { background: var(--selection-bg); color: var(--selection-color); }
a { color: var(--accent-color); text-decoration: none; } a:hover { text-decoration: underline; }
.user-message a { color: var(--accent-color); } .bot-message a { color: var(--accent-color); } body.dark-theme a { color: var(--accent-color); }
pre { white-space: pre; margin: 0; padding: 0; }
code { font-family: 'Consolas', 'Monaco', 'Courier New', monospace; font-size: var(--code-font-size); }
code:not(pre code) { background-color: var(--option-hover); color: var(--message-bot-color); padding: 0.2em 0.4em; margin: 0 1px; border-radius: 4px; }
body.dark-theme code:not(pre code) { background-color: #263d5e; color: #f1f7fa; }
.hljs { background: none !important; color: inherit !important; }
.message-content .code-block { margin: 10px 0; border: 1px solid var(--code-border); border-radius: 6px; overflow: hidden; background: var(--code-bg); }
.message-content .code-header { background: var(--code-header-bg); padding: 4px 10px; display: flex; justify-content: space-between; align-items: center; font-size: 0.85em; color: var(--message-bot-color); border-bottom: 1px solid var(--code-border); min-height: 28px; gap: 8px; }
.message-content .code-language { font-style: italic; color: color-mix(in srgb, var(--accent-color) 60%, var(--message-bot-color) 40%); }
.message-content .code-copy-button { background: var(--code-copy-button-bg); border: 1px solid var(--code-copy-button-border); border-radius: 4px; padding: 3px 8px; color: var(--code-copy-button-color); font-size: 11px; cursor: pointer; transition: all 0.2s ease; font-family: inherit; display: flex; align-items: center; gap: 4px; }
.message-content .code-copy-button svg { width: 12px; height: 12px; fill: none; stroke: currentColor; stroke-width: 2; stroke-linecap: round; stroke-linejoin: round; }
.message-content .code-copy-button:hover { background: var(--code-copy-button-hover-bg); color: var(--code-copy-button-color); border-color: var(--code-copy-button-hover-border); }
.message-content .code-copy-button.copied { background-color: var(--accent-color); color: var(--button-color); }
.message-content .code-copy-button.error { background-color: #d93025; color: white; }
.message-content .code-copy-button span { white-space: nowrap; }
.message-content .code-block pre { margin: 0; padding: 10px 15px 15px 15px; overflow-x: auto; scrollbar-width: thin; scrollbar-color: var(--scrollbar-thumb) var(--scrollbar-track); max-width: 100%; }
.message-content .code-block pre::-webkit-scrollbar { height: 6px; }
.message-content .code-block pre::-webkit-scrollbar-track { background: var(--scrollbar-track); }
.message-content .code-block pre::-webkit-scrollbar-thumb { background-color: var(--scrollbar-thumb); border-radius: 3px; }
.message-content code { font-family: 'Consolas', 'Monaco', 'Courier New', monospace; font-size: var(--code-font-size); color: var(--message-bot-color); }
.message-content .code-block code { display: block; min-width: min-content; line-height: 1.45; white-space: pre; word-wrap: normal; word-break: normal; background: transparent; padding: 0; margin: 0; border-radius: 0;}
.message-content:has(.code-block) { padding-bottom: 10px; }
.message:has(.code-block) .copy-button:not(.code-copy-button) { display: none; }
.message-content .code-save-button { background: var(--code-copy-button-bg); border: 1px solid var(--code-copy-button-border); border-radius: 4px; padding: 3px 8px; color: var(--code-copy-button-color); font-size: 11px; cursor: pointer; transition: all 0.2s ease; font-family: inherit; display: flex; align-items: center; gap: 4px; }
.message-content .code-save-button:hover { background: var(--code-copy-button-hover-bg); color: var(--code-copy-button-color); border-color: var(--code-copy-button-hover-border); }
.message-content .code-save-button svg { width: 12px; height: 12px; fill: none; stroke: currentColor; stroke-width: 2; stroke-linecap: round; stroke-linejoin: round; }
.message-content .code-save-button span { white-space: nowrap; }
.message-content .code-block pre::-webkit-scrollbar-thumb { background-color: var(--scrollbar-thumb); border-radius: 3px; }
.modal-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.5); display: none; justify-content: center; align-items: center; z-index: 1001; }
.modal-content { background-color: var(--modal-bg); padding: 25px; border-radius: 10px; box-shadow: 0 5px 20px var(--modal-shadow); width: 80%; max-width: 900px; height: 70%; max-height: 80vh; display: flex; flex-direction: column; border: 1px solid var(--modal-border); }
#modal-textarea { flex-grow: 1; width: 100%; padding: 12px; border: 1px solid var(--modal-textarea-border); border-radius: 6px; font-size: calc(var(--base-font-size) * 0.95); background-color: var(--modal-textarea-bg); color: var(--modal-textarea-color); resize: none; font-family: 'Consolas', 'Monaco', 'Courier New', monospace; line-height: 1.5; margin-bottom: 15px; white-space: pre-wrap; word-wrap: break-word; }
#modal-textarea:focus { outline: none; border-color: var(--accent-color); box-shadow: 0 0 0 1px var(--accent-color); }
#modal-send-button { padding: 10px 20px; background-color: var(--button-bg); color: var(--button-color); border: none; border-radius: 6px; cursor: pointer; transition: background-color 0.2s ease; font-size: var(--base-font-size); align-self: flex-end; }
#modal-send-button:hover { background-color: var(--button-bg-hover); }
#api-key-modal-overlay .modal-content { background-color: var(--modal-bg); padding: 25px; border-radius: 10px; box-shadow: 0 5px 20px var(--modal-shadow); width: 90%; max-width: 450px; height: auto; max-height: none; display: flex; flex-direction: column; border: 1px solid var(--modal-border); text-align: center; }
#api-key-modal-title { margin-top: 0; margin-bottom: 10px; color: var(--header-color); font-size: 1.2em; }
#api-key-modal-text, #api-key-modal-overlay .modal-content p { margin-bottom: 15px; font-size: 0.9em; line-height: 1.5; color: var(--message-bot-color); }
#api-key-modal-overlay .modal-content a { color: var(--accent-color); font-weight: 500; }
#api-key-input { width: 100%; padding: 10px; margin-top: 10px; margin-bottom: 15px; border: 1px solid var(--modal-textarea-border); border-radius: 6px; font-size: var(--base-font-size); background-color: var(--modal-textarea-bg); color: var(--modal-textarea-color); font-family: 'Consolas', 'Monaco', 'Courier New', monospace; }
#api-key-input:focus { outline: none; border-color: var(--accent-color); box-shadow: 0 0 0 1px var(--accent-color); }
#save-api-key-btn { padding: 10px 20px; background-color: var(--button-bg); color: var(--button-color); border: none; border-radius: 6px; cursor: pointer; transition: background-color 0.2s ease; font-size: var(--base-font-size); align-self: center; width: 50%; }
#save-api-key-btn:hover { background-color: var(--button-bg-hover); }
#change-key-btn { width: 36px; height: 36px; border-radius: 50%; background: transparent; border: none; cursor: pointer; display: flex; align-items: center; justify-content: center; transition: background-color 0.2s ease; }
#change-key-btn:hover { background-color: var(--option-hover); }
#change-key-btn.hidden { display: none; }
#settings-btn-mobile { display: flex; width: 36px; height: 36px; border-radius: 50%; background: transparent; border: none; cursor: pointer; align-items: center; justify-content: center; transition: background-color 0.2s ease, color 0.3s ease; color: var(--accent-color); }
#settings-btn-mobile:hover { background-color: var(--option-hover); }
#settings-modal-overlay .modal-content { background-color: var(--modal-bg); padding: 25px; border-radius: 10px; box-shadow: 0 5px 20px var(--modal-shadow); width: 90%; max-width: 400px; height: auto; max-height: 80vh; display: flex; flex-direction: column; border: 1px solid var(--modal-border); gap: 20px; }
#settings-modal-title { margin: 0; color: var(--header-color); font-size: 1.2em; text-align: center; }
#settings-modal-controls-container { display: flex; flex-direction: column; gap: 16px; align-items: center; }
#settings-modal-controls-container .font-size-button, #settings-modal-controls-container .theme-toggle { width: 48px; height: 48px; }
#settings-modal-controls-container #model-selector-container,
#settings-modal-controls-container #api-mode-selector-container,
#settings-modal-controls-container #change-key-btn {
    width: 100%; max-width: 280px; justify-content: center;
}
#settings-modal-controls-container #model-selector-button,
#settings-modal-controls-container #api-mode-selector-button {
    width: 100%;
}
#settings-modal-controls-container #change-key-btn { width: auto; padding: 8px 12px; border-radius: 24px; border: 1px solid var(--border-color); }
#settings-modal-controls-container #model-options,
#settings-modal-controls-container #api-mode-options { z-index: 1002; }
#close-settings-modal-btn { padding: 10px 20px; background-color: var(--button-bg); color: var(--button-color); border: none; border-radius: 6px; cursor: pointer; transition: background-color 0.2s ease; font-size: var(--base-font-size); align-self: center; width: 60%; }
#close-settings-modal-btn:hover { background-color: var(--button-bg-hover); }
.header-controls { display: none !important; }
@media (max-width: 768px) { .container { max-width: 100%; box-shadow: none; } .header { padding: 10px 12px; } .header-title { font-size: 18px; } #chat-container { padding: 12px; } #input-container { padding: 10px 12px; } .message { max-width: 95%; } .modal-content { width: 90%; height: 80%; } #api-key-modal-overlay .modal-content {width: 90%; height: auto;} }
@media (max-width: 480px) { .font-size-button { width: 32px; height: 32px; } .theme-toggle { width: 32px; height: 32px; } .header-title { font-size: 16px; } #desktop-upload-button, #send-button { width: 36px; height: 36px; } #message-input { min-height: 40px; padding: 9px 14px; max-height: 120px; } .message { max-width: 98%; } .model-option, .api-mode-option { padding: 8px 12px; font-size: 12px; } .modal-content { width: 95%; height: 85%; padding: 15px; } #modal-textarea { font-size: calc(var(--base-font-size) * 0.9); } #api-key-modal-overlay .modal-content {width: 95%; height: auto; padding: 20px;} }
.header { border: none !important; box-shadow: none !important; }
body.dark-theme .container, body.dark-theme #chat-container, body.dark-theme #input-container, body.dark-theme .header { border: none !important; box-shadow: none !important; }

/* START: Added styles for Crop Modal */
#crop-image-modal {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.7);
    z-index: 10001;
    display: none;
    justify-content: center;
    align-items: center;
    flex-direction: column;
}

.crop-modal-content-wrapper {
    background-color: var(--modal-bg);
    color: var(--message-bot-color);
    padding: 20px;
    border-radius: 10px;
    box-shadow: 0 0 15px var(--modal-shadow);
    max-width: 95vw;
    max-height: 95vh;
    overflow: auto;
    text-align: center;
    border: 1px solid var(--modal-border);
}

.crop-modal-content-wrapper h3 {
    margin-top: 0;
    color: var(--header-color);
}
.crop-modal-content-wrapper p {
    font-size: 0.9em;
    color: var(--message-bot-color);
    opacity: 0.8;
}

#crop-image-container {
    position: relative;
    display: inline-block;
    border: 1px dashed var(--border-color);
    user-select: none;
    touch-action: none;
    max-width: 100%;
    max-height: calc(85vh - 120px);
    overflow: hidden;
    cursor: crosshair;
    margin: 15px 0;
}
#crop-image-preview {
    display: block;
    max-width: 100%;
    max-height: 100%;
    user-select: none;
    -webkit-user-drag: none;
}
#crop-selection-rectangle {
    position: absolute;
    border: 2px solid var(--accent-color);
    background-color: color-mix(in srgb, var(--accent-color) 15%, transparent);
    display: none;
    pointer-events: none;
}
.crop-modal-buttons {
    margin-top: 15px;
    display: flex;
    justify-content: center;
    gap: 15px;
}
.crop-modal-buttons button {
    padding: 10px 20px;
    color: var(--button-color);
    border: none;
    border-radius: 8px;
    cursor: pointer;
    font-size: 0.9rem;
    transition: transform 0.2s ease, background-color 0.2s ease;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 8px;
}
.crop-modal-buttons button:hover {
    transform: scale(1.05);
}
/* Apply button */
#crop-image-button-confirm {
    background-color: #4CBB17;
}
body.dark-theme #crop-image-button-confirm {
     background-color: #5cb85c;
}
#crop-image-button-confirm:hover {
    background-color: #449d44;
}

/* Cancel/Select All button */
#crop-image-button-cancel {
    background-color: #d9534f;
}
body.dark-theme #crop-image-button-cancel {
    background-color: #d9534f;
}
#crop-image-button-cancel:hover {
    background-color: #c9302c;
}
/* END: Added styles for Crop Modal */
  </style>
</head>
<body>
    <div class="container">
        <header class="header">
            <div class="header-title">
                <img src="img/ai.svg" alt="Logo" class="header-logo">
                <span>Gemini</span>
            </div>
            <div class="header-controls">
                <button class="font-size-button" title="Изменить размер шрифта">Aa</button>

                <!-- Model Selector -->
                <div id="model-selector-container">
                    <button id="model-selector-button">Loading Model...</button>
                    <ul id="model-options"></ul>
                </div>

                <!-- NEW: API Mode Selector -->
                <div id="api-mode-selector-container">
                    <button id="api-mode-selector-button">
                        <!-- Content will be generated by JS -->
                    </button>
                    <ul id="api-mode-options"></ul>
                </div>

                <button id="change-key-btn" title="Изменить API ключ Gemini">
                    <svg xmlns="http://www.w3.org/2000/svg" height="20" viewBox="0 0 24 24" width="20" fill="var(--accent-color)"><path d="M12.65 10C11.83 7.67 9.61 6 7 6c-3.31 0-6 2.69-6 6s2.69 6 6 6c2.61 0 4.83-1.67 5.65-4H17v4h4v-4h2v-4H12.65zM7 14c-1.1 0-2-.9-2-2s.9-2 2-2 2 .9 2 2-.9 2-2 2z"/></svg>
                </button>
                <button class="theme-toggle" title="Переключить тему">
                     <svg class="sun-icon" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3zm-9 4c0-.55-.45-1-1-1s-1 .45-1 1 .45 1 1 1 1-.45 1-1zm20 0c0-.55-.45-1-1-1s-1 .45-1 1 .45 1 1 1 1-.45 1-1zm-2.99-7c-.38-.44-1.03-.48-1.49-.1l-.05.05c-.42.42-.39 1.12.07 1.49.44.41 1.12.39 1.49-.07.36-.44.32-1.08-.02-1.37zM5.04 6.94c.44-.38.48-1.09-.01-1.47-.44-.38-1.07-.36-1.45.04-.37.47-.33 1.1.07 1.47.4.38 1.05.36 1.39.04zm-.5 11.11c.44.41 1.09.37 1.45-.04.37-.47-.33-1.1-.07-1.47-.44-.38-1.07-.36-1.45.04-.37.47-.33 1.1.07 1.47zm16.91-11.05c-.38-.44-1.03-.48-1.49-.1-.44.41-.45 1.05-.04 1.47.42.42 1.06.4 1.47-.02.42-.42.42-1.1.06-1.35zm-2.9 11.05c.44.41 1.09.37 1.45-.04.37-.47.33-1.1-.07-1.47-.44-.38-1.07-.36-1.45.04-.37.47-.33 1.1.07 1.47zM12 3c-.55 0-1 .45-1 1s.45 1 1 1 1-.45 1-1-.45-1-1-1zm0 16c-.55 0-1 .45-1 1s.45 1 1 1 1-.45 1-1-.45-1-1-1z"/></svg>
                     <svg class="moon-icon" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M12 3c-4.97 0-9 4.03-9 9s4.03 9 9 9 9-4.03 9-9c0-.46-.04-.92-.1-1.36-.98 1.37-2.58 2.26-4.4 2.26-2.98 0-5.4-2.42-5.4-5.4 0-1.81.89-3.42 2.26-4.4-.44-.06-.9-.1-1.36-.1z"/></svg>
                </button>
            </div>
            <button id="settings-btn-mobile" title="Настройки">
                <svg class="settings-icon-cog" xmlns="http://www.w3.org/2000/svg" height="20" viewBox="0 0 24 24" width="20" fill="currentColor"><path d="M19.43 12.98c.04-.32.07-.64.07-.98s-.03-.66-.07-.98l2.11-1.65c.19-.15.24-.42.12-.64l-2-3.46c-.12-.22-.39-.3-.61-.22l-2.49 1c-.52-.4-1.08-.73-1.69-.98l-.38-2.65C14.46 2.18 14.25 2 14 2h-4c-.25 0-.46.18-.49.42l-.38 2.65c-.61.25-1.17.59-1.69-.98l-2.49-1c-.23-.09-.49 0-.61.22l-2 3.46c-.13.22-.07.49.12.64l2.11 1.65c-.04.32-.07.65-.07.98s.03.66.07.98l-2.11 1.65c-.19.15-.24.42-.12.64l2 3.46c.12.22.39.3.61.22l2.49-1c.52.4 1.08.73 1.69.98l.38 2.65c.03.24.24.42.49.42h4c.25 0 .46-.18.49.42l.38-2.65c.61-.25 1.17-.59 1.69-.98l2.49 1c.23.09.49 0 .61.22l2-3.46c.12-.22.07-.49-.12.64l-2.11-1.65zM12 15.5c-1.93 0-3.5-1.57-3.5-3.5s1.57-3.5 3.5-3.5 3.5 1.57 3.5 3.5-1.57 3.5-3.5 3.5z"/></svg>
                <svg class="settings-icon-key" xmlns="http://www.w3.org/2000/svg" height="20" viewBox="0 0 24 24" width="20" fill="currentColor" style="display: none;"><path d="M12.65 10C11.83 7.67 9.61 6 7 6c-3.31 0-6 2.69-6 6s2.69 6 6 6c2.61 0 4.83-1.67 5.65-4H17v4h4v-4h2v-4H12.65zM7 14c-1.1 0-2-.9-2-2s.9-2 2-2 2 .9 2 2-.9 2-2 2z"/></svg>
            </button>
        </header>
        <div id="chat-container"></div>
        <div id="input-container">
            <input type="file" id="file-input" accept="image/*, application/pdf">
            <button id="desktop-upload-button" title="Прикрепить файл">
                <svg xmlns="http://www.w3.org/2000/svg" height="24" viewBox="0 -960 960 960" width="24"><path d="M440-280h80v-160h160v-80H520v-160h-80v160H280v80h160v160Zm40 200q-83 0-156-31.5T197-197q-54-54-85.5-127T80-480q0-83 31.5-156T197-763q54-54 127-85.5T480-880q83 0 156 31.5T763-763q54 54 85.5 127T880-480q0 83-31.5-156T763-197q-54 54-127 85.5T480-80Z"/></svg>
            </button>
            <textarea id="message-input" placeholder="Сообщение..." rows="1"></textarea>
            <button id="send-button" title="Отправить">
                <svg xmlns="http://www.w3.org/2000/svg" height="24" viewBox="0 -960 960 960" width="24"><path d="M120-160v-640l760 320-760 320Zm80-120 474-200-474-200v140l240 60-240 60v140Zm0 0v-400 400Z"/></svg>
            </button>
        </div>
    </div>
    <div class="notification" style="display: none;"></div>

    <div class="modal-overlay" id="f9-modal">
        <div class="modal-content">
            <textarea id="modal-textarea" placeholder="Введите или вставьте текст сюда..."></textarea>
            <button id="modal-send-button">Отправить выделенное</button>
        </div>
    </div>

    <div class="modal-overlay" id="api-key-modal-overlay">
        <div class="modal-content">
            <h2 id="api-key-modal-title">API ключ для Gemini</h2>
            <p id="api-key-modal-text">Для использования вставьте ваш API-ключ Google Gemini. Он будет сохранен локально в вашем браузере.</p>
            <p><a href="https://aistudio.google.com/app/apikey" target="_blank" rel="noopener noreferrer">Получить ключ в Google AI Studio</a></p>
            <input type="password" id="api-key-input" placeholder="Введите ваш API ключ...">
            <button id="save-api-key-btn">Сохранить</button>
        </div>
    </div>

    <div class="modal-overlay" id="settings-modal-overlay">
        <div class="modal-content" id="settings-modal-main-content">
            <h2 id="settings-modal-title">Настройки</h2>
            <div id="settings-modal-controls-container">
            </div>
            <button id="close-settings-modal-btn">Закрыть</button>
        </div>
    </div>
    
    <!-- START: Added Crop Modal HTML -->
    <div id="crop-image-modal">
        <div class="crop-modal-content-wrapper">
            <h3>Обрезать изображение</h3>
            <p>Нажмите и перетащите на изображении, чтобы выбрать область.</p>
            <div id="crop-image-container">
                <img id="crop-image-preview" src="#" alt="Preview" />
                <div id="crop-selection-rectangle"></div>
            </div>
            <div class="crop-modal-buttons">
                <button id="crop-image-button-confirm">
                    &#x2714; Применить
                </button>
                <button id="crop-image-button-cancel">
                    &#x2716; Выбрать все
                </button>
            </div>
        </div>
    </div>
    <!-- END: Added Crop Modal HTML -->


   <script>
    const chatContainer = document.getElementById('chat-container');
    const messageInput = document.getElementById('message-input');
    const sendButton = document.getElementById('send-button');
    const fileInput = document.getElementById('file-input');
    const desktopUploadButton = document.getElementById('desktop-upload-button');
    const modelSelectorButton = document.getElementById('model-selector-button');
    const modelOptionsList = document.getElementById('model-options');
    const themeToggle = document.querySelector('.theme-toggle');
    const headerTitleElement = document.querySelector('.header-title');
    const headerLogo = headerTitleElement.querySelector('.header-logo');
    const headerTitleTextSpan = headerTitleElement.querySelector('span');
    const notificationElement = document.querySelector('.notification');
    const hljsThemeLink = document.getElementById('hljs-theme');
    const fontSizeButton = document.querySelector('.font-size-button');
    const f9Modal = document.getElementById('f9-modal');
    const modalTextarea = document.getElementById('modal-textarea');
    const modalSendButton = document.getElementById('modal-send-button');
    const faviconElement = document.getElementById('favicon');
    const apiKeyModalOverlay = document.getElementById('api-key-modal-overlay');
    const apiKeyInput = document.getElementById('api-key-input');
    const saveApiKeyBtn = document.getElementById('save-api-key-btn');
    const changeKeyBtn = document.getElementById('change-key-btn');
    const headerControls = document.querySelector('.header-controls');
    const settingsBtnMobile = document.getElementById('settings-btn-mobile');
    const settingsModalOverlay = document.getElementById('settings-modal-overlay');
    const settingsModalControlsContainer = document.getElementById('settings-modal-controls-container');
    const closeSettingsModalBtn = document.getElementById('close-settings-modal-btn');

    // New API Mode elements
    const apiModeSelectorButton = document.getElementById('api-mode-selector-button');
    const apiModeOptionsList = document.getElementById('api-mode-options');

  const GEMINI_API_KEY_STORAGE = 'gemini_api_key';
    const MISTRAL_API_KEY_STORAGE = 'mistral_api_key'; // <<< НОВАЯ СТРОКА
    const API_MODE_STORAGE = 'chat_api_mode'; // Now stores 'vercel', 'mapruapp', 'direct'
    const MODELS_STORAGE = 'selectedModelId';
    const FONT_SIZE_STORAGE = 'fontSizeIndex';
    const THEME_STORAGE = 'darkTheme';
    const MODAL_STORAGE_KEY = 'f9ModalTextContent';


    // --- Configuration ---
    const VERCEL_PROXY_BASE_URL = "https://ver-olive-delta.vercel.app";
    const MAPRUAPP_PROXY_BASE_URL = "https://mapruapp.ru"; // Your site

const MODELS = [
        { id: "gemini-2.5-flash-lite-preview-06-17", uiName: "Gemini 2.5 Flash Lite (быстрая)", apiType: "gemini", tier: 'lite' },
        { id: "gemini-2.5-flash", uiName: "Gemini 2.5 Flash", apiType: "gemini", tier: 'standard' },
        { id: "gemini-2.5-flash-image-preview", uiName: "Gemini 2.5 Flash Image", apiType: "gemini", tier: 'standard' },
        { id: "mistral-medium-2508", uiName: "Mistral Medium (быстрая)", apiType: "mistral", tier: 'standard' },
        { id: "magistral-medium-2507", uiName: "Mistral Magistral ", apiType: "mistral", tier: 'standard' },
               { id: "glm-4.5-flash", uiName: "GLM-4.5 Flash", apiType: "zhipu", tier: 'standard' },
{ id: "gpt-oss-20b-free", uiName: "OpenAI GPT-OSS 20B", apiType: "openrouter", tier: 'standard' },
    ];


       const API_MODES = {
        'mapruapp': {
            uiName: 'Прокси (mapruapp)',
            geminiUrl: () => `${MAPRUAPP_PROXY_BASE_URL}/ai/api/v1/chat/completions`,
            claudeUrl: () => `${MAPRUAPP_PROXY_BASE_URL}/ai/api/v1/chat/completions`, // Добавлено для Claude
            icon: '<svg class="icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M17.6,15.2c-1-1.4-2.5-2.5-4.2-2.9c-0.3-0.1-0.6-0.1-0.8-0.1s-0.5,0-0.8,0.1c-1.7,0.5-3.2,1.5-4.2,2.9 c-1.2,1.6-1.8,3.5-1.8,5.5c0,0.4,0.3,0.8,0.8,0.8h11.2c0.4,0,0.8-0.3,0.8-0.8C19.5,18.7,18.8,16.8,17.6,15.2z M6.9,4.4 C8.1,3.2,9.9,2.5,12,2.5s3.9,0.7,5.1,1.9c1.2,1.2,1.9,2.9,1.9,4.7c0,1.8-0.7,3.6-1.9,4.7c-0.2,0.2-0.5,0.3-0.8,0.3s-0.6-0.1-0.8-0.3 c-0.4-0.4-0.4-1.1,0-1.5c0.8-0.8,1.2-1.8,1.2-2.9c0-1.1-0.4-2.2-1.2-2.9C15.8,5,15,5,14.1,5.4c-0.4,0.2-1,0.1-1.3-0.3 c-0.3-0.4-0.1-1,0.3-1.3C13.5,3.5,12.8,3.3,12,3.3s-1.5,0.2-2.1,0.5c0.4,0.3,0.5,0.9,0.3,1.3C10,5.4,9.4,5.6,9,5.4 C8,5,7.2,5,6.3,5.4C5.5,6.2,5.1,7.2,5.1,8.3c0,1.1,0.4,2.2,1.2,2.9c0.4,0.4,0.4,1.1,0,1.5c-0.4,0.4-1.1,0.4-1.5,0 c-1.2-1.2-1.9-2.9-1.9-4.7C3.1,7.3,3.8,5.6,4.9,4.4H6.9z" fill="var(--accent-color)"/></svg>'
        },
        'vercel': {
            uiName: 'Прокси (vercel)',
            geminiUrl: (modelId) => `${VERCEL_PROXY_BASE_URL}/v1beta/models/${modelId}:generateContent`,
            claudeUrl: () => `${VERCEL_PROXY_BASE_URL}/proxy/langdock/anthropic/eu/v1/messages`,
            icon: '<svg class="icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M17.6,15.2c-1-1.4-2.5-2.5-4.2-2.9c-0.3-0.1-0.6-0.1-0.8-0.1s-0.5,0-0.8,0.1c-1.7,0.5-3.2,1.5-4.2,2.9 c-1.2,1.6-1.8,3.5-1.8,5.5c0,0.4,0.3,0.8,0.8,0.8h11.2c0.4,0,0.8-0.3,0.8-0.8C19.5,18.7,18.8,16.8,17.6,15.2z M6.9,4.4 C8.1,3.2,9.9,2.5,12,2.5s3.9,0.7,5.1,1.9c1.2,1.2,1.9,2.9,1.9,4.7c0,1.8-0.7,3.6-1.9,4.7c-0.2,0.2-0.5,0.3-0.8,0.3s-0.6-0.1-0.8-0.3 c-0.4-0.4-0.4-1.1,0-1.5c0.8-0.8,1.2-1.8,1.2-2.9c0-1.1-0.4-2.2-1.2-2.9C15.8,5,15,5,14.1,5.4c-0.4,0.2-1,0.1-1.3-0.3 c-0.3-0.4-0.1-1,0.3-1.3C13.5,3.5,12.8,3.3,12,3.3s-1.5,0.2-2.1,0.5c0.4,0.3,0.5,0.9,0.3,1.3C10,5.4,9.4,5.6,9,5.4 C8,5,7.2,5,6.3,5.4C5.5,6.2,5.1,7.2,5.1,8.3c0,1.1,0.4,2.2,1.2,2.9c0.4,0.4,0.4,1.1,0,1.5c-0.4,0.4-1.1,0.4-1.5,0 c-1.2-1.2-1.9-2.9-1.9-4.7C3.1,7.3,3.8,5.6,4.9,4.4H6.9z" fill="var(--accent-color)"/></svg>'
        },
        'direct': {
            uiName: 'Прямой (gemini)',
            geminiUrl: (modelId, key) => `https://generativelanguage.googleapis.com/v1beta/models/${modelId}:generateContent?key=${key}`,
            claudeUrl: () => null,
            icon: '<svg class="icon" xmlns="http://www.w3.org/2000/svg" height="20" viewBox="0 0 24 24" width="20"><path d="M12.65 10C11.83 7.67 9.61 6 7 6c-3.31 0-6 2.69-6 6s2.69 6 6 6c2.61 0 4.83-1.67 5.65-4H17v4h4v-4h2v-4H12.65zM7 14c-1.1 0-2-.9-2-2s.9-2 2-2 2 .9 2 2-.9 2-2 2z" fill="var(--accent-color)"/></svg>'
        },
           'direct_mistral': {
            uiName: 'Прямой (mistral)',
            icon: '<svg class="icon" xmlns="http://www.w3.org/2000/svg" height="20" viewBox="0 0 24 24" width="20"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8zm-1-13h2v6h-2zm0 8h2v2h-2z" fill="var(--accent-color)"/></svg>'
        }
    };

    const defaultHeaderText = 'AI Chat';
    const fontSizes = [14, 15, 16, 17, 18];
    let defaultModelId = 'gemini-2.5-flash-lite-preview-06-17';

    if (!MODELS.find(m => m.id === defaultModelId)) { defaultModelId = MODELS[0]?.id || ''; }

    let currentFontSizeIndex = parseInt(localStorage.getItem(FONT_SIZE_STORAGE) || 0);
    let currentSelectedModelId = localStorage.getItem(MODELS_STORAGE) || defaultModelId;
    if (!MODELS.find(m => m.id === currentSelectedModelId)) {
        currentSelectedModelId = defaultModelId;
        localStorage.setItem(MODELS_STORAGE, currentSelectedModelId);
    }
    let isDarkTheme = localStorage.getItem(THEME_STORAGE) === 'true';
    let chatHistory = [];
    let uploadedFile = null;
    let lastUserMessageTimestamp = null;
    let currentBaseHeaderText = defaultHeaderText;
    let originalFaviconHref = faviconElement.href;
    let faviconIntervalId = null;
    let faviconIsOriginal = true;
    const alternateFaviconHref = "data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>💭</text></svg>";

    let apiKey = null;
       let mistralApiKey = null; 
    let currentApiMode = 'mapruapp'; // Default API mode

    // START: Added variables for Crop Modal
    let cropSelection = { startX: 0, startY: 0, endX: 0, endY: 0, isDrawing: false };
    let imageNaturalSize = { width: 0, height: 0 };
    let imageDisplaySize = { width: 0, height: 0 };
    let cropModalResolve = null;
    // END: Added variables for Crop Modal


    function calculateChatSize() { let totalChars = 0; let totalBytes = 0; chatHistory.forEach(msg => { if (msg.text) { totalChars += msg.text.length; totalBytes += new TextEncoder().encode(msg.text).length; } if (msg.file?.data) { totalBytes += msg.file.data.length; } }); const estimatedTokens = Math.round(totalChars / 4); const estimatedKB = totalBytes > 0 ? Math.round(totalBytes / 1024) : 0; return { tokens: estimatedTokens, kb: estimatedKB }; }
    function updateHeaderSizeDisplay() { if (!headerTitleTextSpan || !currentBaseHeaderText) return; const sizeInfo = calculateChatSize(); let sizeString = ''; if (sizeInfo.tokens > 0 || sizeInfo.kb > 0) { sizeString = ` - ${sizeInfo.tokens.toLocaleString('ru-RU')} токенов - ${sizeInfo.kb} КБ`; } headerTitleTextSpan.textContent = currentBaseHeaderText + sizeString; }
    
    function updateSettingsButtonColor() {
        const settingsBtn = document.getElementById('settings-btn-mobile');
        if (!settingsBtn) return;
        const selectedModel = MODELS.find(m => m.id === currentSelectedModelId);
        const modelTier = selectedModel?.tier || 'lite';
        let colorVar;
        if (selectedModel?.apiType === 'anthropic') { colorVar = '--settings-color-claude'; }
        else if (currentApiMode === 'direct') { colorVar = modelTier === 'standard' ? '--settings-color-direct-standard' : '--settings-color-direct-lite'; }
        else { colorVar = modelTier === 'standard' ? '--settings-color-proxy-standard' : '--settings-color-proxy-lite'; }
        settingsBtn.style.color = `var(${colorVar})`;
    }

    // ИЗМЕНЕНИЕ: Логика блокировки режимов
    function updateApiSelectorsAvailability() {
        const selectedModel = MODELS.find(m => m.id === currentSelectedModelId);
        const isGeminiModel = selectedModel?.apiType === 'gemini';

        // Разрешаем все опции, но будем отключать "Direct" для Claude
        apiModeSelectorButton.disabled = false;
        apiModeSelectorButton.style.opacity = '1';
        apiModeSelectorButton.style.pointerEvents = 'auto';
        apiModeSelectorButton.title = 'Выбрать режим API';

        // Отключить опцию 'direct' в списке, если модель не Gemini
        document.querySelectorAll('.api-mode-option').forEach(option => {
            if (option.dataset.apiMode === 'direct') {
                option.style.display = isGeminiModel ? 'flex' : 'none';
            }
        });

        // Если выбрана не-Gemini модель, а активный режим 'direct',
        // принудительно переключаемся на прокси по умолчанию.
        if (!isGeminiModel && currentApiMode === 'direct') {
            currentApiMode = 'mapruapp'; // Безопасный режим по умолчанию
            localStorage.setItem(API_MODE_STORAGE, currentApiMode);
            updateApiModeUI();
            showNotification("Режим 'Прямой' недоступен для Claude. Выбран 'Прокси (MapRuApp)'.", false, 4000);
        }
    }
    
    function initializeApp() {
        if (isDarkTheme) { document.body.classList.add('dark-theme'); updateHljsTheme(true); }

        fontSizeButton.addEventListener('click', handleFontSizeClick);
        themeToggle.addEventListener('click', handleThemeToggle);
        modelSelectorButton.addEventListener('click', handleModelSelectorToggle);
        apiModeSelectorButton.addEventListener('click', handleApiModeSelectorToggle); // New
        document.addEventListener('click', handleGlobalClick);
        document.addEventListener('keydown', handleKeyDown);
        desktopUploadButton.addEventListener('click', handleFileInputClick);
        sendButton.addEventListener('click', handleSendClick);loadApiMode
        messageInput.addEventListener('keydown', handleEnterKey);
        fileInput.addEventListener('change', handleFileSelection);
        messageInput.addEventListener('paste', handlePaste);
        messageInput.addEventListener('input', handleInputResize);
        headerTitleElement.addEventListener('click', handleLogoClick);
        modalSendButton.addEventListener('click', handleModalSendClick);
        modalTextarea.addEventListener('input', () => { localStorage.setItem(MODAL_STORAGE_KEY, modalTextarea.value); });
        f9Modal.addEventListener('click', (event) => { if (event.target === f9Modal) { hideF9Modal(); } });
        changeKeyBtn.addEventListener('click', showApiKeyModal);
        saveApiKeyBtn.addEventListener('click', saveApiKey);
        apiKeyModalOverlay.addEventListener('click', (e) => { if (e.target === apiKeyModalOverlay) hideApiKeyModal(); });
        apiKeyInput.addEventListener('keydown', e => { if (e.key === 'Enter') { e.preventDefault(); saveApiKey(); } });
        settingsBtnMobile.addEventListener('click', openSettingsModal);
        closeSettingsModalBtn.addEventListener('click', closeSettingsModal);
        settingsModalOverlay.addEventListener('click', (e) => { if (e.target === settingsModalOverlay) { closeSettingsModal(); } });

        loadApiKey();
        loadApiMode();
        
        populateModelOptions();
        populateApiModeOptions(); // New

        updateApiModeUI();
        updateApiSelectorsAvailability();
        updateFontSize(fontSizes[currentFontSizeIndex]);
        updateHeaderTitle(currentSelectedModelId);
        highlightSelectedModel();
        messageInput.value = '';
        handleInputResize.call(messageInput);
        updateSettingsButtonColor();
    }

    function openSettingsModal() { const controls = Array.from(headerControls.children); controls.forEach(control => settingsModalControlsContainer.appendChild(control)); settingsModalOverlay.style.display = 'flex'; }
    function closeSettingsModal() {
        const controls = Array.from(settingsModalControlsContainer.children);
        controls.forEach(control => { if (control.id !== 'close-settings-modal-btn' && control.id !== 'settings-modal-title') headerControls.appendChild(control); });
        settingsModalOverlay.style.display = 'none';
        if (modelOptionsList.classList.contains('show')) modelOptionsList.classList.remove('show');
        if (apiModeOptionsList.classList.contains('show')) apiModeOptionsList.classList.remove('show');
    }

       function showApiKeyModal() {
        hideAllModals();
        
        const modalTitle = document.getElementById('api-key-modal-title');
        const modalText = document.getElementById('api-key-modal-text');
        const modalLink = apiKeyModalOverlay.querySelector('a');

        const isMistral = currentApiMode === 'direct_mistral';

        modalTitle.textContent = isMistral ? 'API ключ для Mistral' : 'API ключ для Gemini';
        modalText.textContent = isMistral 
            ? 'Для использования вставьте ваш API-ключ Mistral. Он будет сохранен локально в вашем браузере.'
            : 'Для использования вставьте ваш API-ключ Google Gemini. Он будет сохранен локально в вашем браузере.';
        
        modalLink.href = isMistral ? 'https://console.mistral.ai/api-keys/' : 'https://aistudio.google.com/app/apikey';
        modalLink.textContent = isMistral ? 'Получить ключ на сайте Mistral AI' : 'Получить ключ в Google AI Studio';

        apiKeyInput.value = isMistral ? (mistralApiKey || '') : (apiKey || '');
        apiKeyModalOverlay.style.display = 'flex';
        apiKeyInput.focus();
    }
    function hideApiKeyModal() { apiKeyModalOverlay.style.display = 'none'; }
    function saveApiKey() {
        const key = apiKeyInput.value.trim();
        if (!key) {
            showNotification('Поле ключа не может быть пустым.', true);
            return;
        }

        const isMistral = currentApiMode === 'direct_mistral';
        if (isMistral) {
            mistralApiKey = key;
            localStorage.setItem(MISTRAL_API_KEY_STORAGE, key);
        } else {
            apiKey = key;
            localStorage.setItem(GEMINI_API_KEY_STORAGE, key);
        }
        showNotification('API ключ сохранен.');
        hideApiKeyModal();
    }
     function loadApiKey() {
        const savedGeminiKey = localStorage.getItem(GEMINI_API_KEY_STORAGE);
        if (savedGeminiKey) {
            apiKey = savedGeminiKey;
        }
        const savedMistralKey = localStorage.getItem(MISTRAL_API_KEY_STORAGE);
        if (savedMistralKey) {
            mistralApiKey = savedMistralKey;
        }
    }
          function loadApiMode() {
        const savedMode = localStorage.getItem(API_MODE_STORAGE);
          currentApiMode = API_MODES[savedMode] ? savedMode : 'mapruapp';
    }
    
    function updateApiModeUI() {
        const mode = API_MODES[currentApiMode];
        if (!mode) return;

        apiModeSelectorButton.innerHTML = `${mode.icon}<span class="text">${mode.uiName}</span>`;
        
             const isDirect = currentApiMode === 'direct' || currentApiMode === 'direct_mistral';
        const settingsIconCog = document.querySelector('#settings-btn-mobile .settings-icon-cog');
        const settingsIconKey = document.querySelector('#settings-btn-mobile .settings-icon-key');
    
        changeKeyBtn.classList.toggle('hidden', !isDirect);
    
        if (settingsIconCog && settingsIconKey) {
            settingsIconCog.style.display = isDirect ? 'none' : 'block';
            settingsIconKey.style.display = isDirect ? 'block' : 'none';
        }
        document.querySelectorAll('.api-mode-option').forEach(option => {
            option.classList.toggle('selected', option.dataset.apiMode === currentApiMode);
        });
        updateSettingsButtonColor();
    }

    // --- New API Mode Selector Functions ---
    function populateApiModeOptions() {
        apiModeOptionsList.innerHTML = '';
        for (const modeId in API_MODES) {
            const mode = API_MODES[modeId];
            const option = document.createElement('li');
            option.className = 'api-mode-option';
            option.dataset.apiMode = modeId;
            option.innerHTML = `${mode.icon} <span>${mode.uiName}</span>`;
            option.addEventListener('click', handleApiModeSelection);
            apiModeOptionsList.appendChild(option);
        }
    }
    function handleApiModeSelectorToggle(event) { apiModeOptionsList.classList.toggle('show'); event.stopPropagation(); }
    function handleApiModeSelection(event) {
        const selectedOption = event.currentTarget;
        currentApiMode = selectedOption.dataset.apiMode;
        localStorage.setItem(API_MODE_STORAGE, currentApiMode);
        updateApiModeUI();
        apiModeOptionsList.classList.remove('show');
        if (currentApiMode === 'direct' && !apiKey) {
            showApiKeyModal();
        }
    }

    function populateModelOptions() { modelOptionsList.innerHTML = ''; MODELS.forEach(model => { const option = document.createElement('li'); option.className = 'model-option'; option.dataset.modelId = model.id; option.dataset.apiType = model.apiType; option.textContent = model.uiName; option.addEventListener('click', handleModelSelection); modelOptionsList.appendChild(option); }); }
    function updateFontSize(size) { document.documentElement.style.setProperty('--base-font-size', size + 'px'); if (messageInput) messageInput.style.fontSize = size + 'px'; document.querySelectorAll('.message-content').forEach(message => { if (!message.closest('.code-block')) { message.style.fontSize = size + 'px'; } }); document.documentElement.style.setProperty('--code-font-size', `calc(${size}px * 0.88)`); if (modalTextarea) modalTextarea.style.fontSize = `calc(${size}px * 0.95)`; }
    function updateHeaderTitle(modelId) { let headerText = defaultHeaderText, browserTitle = defaultHeaderText, modelNameForButton = defaultHeaderText; const selectedModelInfo = MODELS.find(m => m.id === modelId); if (selectedModelInfo) { headerText = selectedModelInfo.uiName; browserTitle = selectedModelInfo.uiName; modelNameForButton = selectedModelInfo.uiName; } else { currentSelectedModelId = defaultModelId; localStorage.setItem(MODELS_STORAGE, currentSelectedModelId); const defaultModelInfo = MODELS.find(m => m.id === currentSelectedModelId); if (defaultModelInfo) { headerText = defaultModelInfo.uiName; browserTitle = defaultModelInfo.uiName; modelNameForButton = defaultModelInfo.uiName; } else { headerText = "Select Model"; browserTitle = "Chat"; modelNameForButton = "Select Model"; } highlightSelectedModel(); } currentBaseHeaderText = headerText; document.title = browserTitle; modelSelectorButton.textContent = modelNameForButton; updateHeaderSizeDisplay(); }
    function highlightSelectedModel() { document.querySelectorAll('.model-option').forEach(option => { option.classList.toggle('selected', option.dataset.modelId === currentSelectedModelId); }); }
    function updateHljsTheme(isDark) { const newHref = isDark ? 'https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css' : 'https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github.min.css'; if (hljsThemeLink.getAttribute('href') !== newHref) { hljsThemeLink.setAttribute('href', newHref); document.querySelectorAll('pre code.hljs').forEach(block => { try { block.classList.remove('hljs'); block.removeAttribute('data-highlighted'); hljs.highlightElement(block); } catch (e) {} }); } }
    function hideAllModals() { if (modelOptionsList.classList.contains('show')) { modelOptionsList.classList.remove('show'); } if (apiModeOptionsList.classList.contains('show')) { apiModeOptionsList.classList.remove('show'); } if (f9Modal.style.display === 'flex') { hideF9Modal(); } if (apiKeyModalOverlay.style.display === 'flex') { hideApiKeyModal(); } if (settingsModalOverlay.style.display === 'flex') { closeSettingsModal(); } }
    function handleFontSizeClick() { currentFontSizeIndex = (currentFontSizeIndex + 1) % fontSizes.length; updateFontSize(fontSizes[currentFontSizeIndex]); localStorage.setItem(FONT_SIZE_STORAGE, currentFontSizeIndex); this.classList.add('font-size-button-clicked'); setTimeout(() => this.classList.remove('font-size-button-clicked'), 300); }
    function handleThemeToggle() { document.body.classList.toggle('dark-theme'); isDarkTheme = document.body.classList.contains('dark-theme'); localStorage.setItem(THEME_STORAGE, isDarkTheme); updateHljsTheme(isDarkTheme); }
    function handleModelSelectorToggle(event) { modelOptionsList.classList.toggle('show'); event.stopPropagation(); }
    function handleModelSelection(event) { const selectedOption = event.currentTarget; currentSelectedModelId = selectedOption.dataset.modelId; localStorage.setItem(MODELS_STORAGE, currentSelectedModelId); highlightSelectedModel(); updateHeaderTitle(currentSelectedModelId); modelOptionsList.classList.remove('show'); updateSettingsButtonColor(); updateApiSelectorsAvailability(); }
    function handleGlobalClick(event) { if (modelOptionsList.classList.contains('show') && !modelOptionsList.contains(event.target) && !modelSelectorButton.contains(event.target)) { modelOptionsList.classList.remove('show'); } if (apiModeOptionsList.classList.contains('show') && !apiModeOptionsList.contains(event.target) && !apiModeSelectorButton.contains(event.target)) { apiModeOptionsList.classList.remove('show'); } }
    function handleKeyDown(event) { if (event.key === 'Escape') { hideAllModals(); } else if (event.key === 'F9') { event.preventDefault(); showF9Modal(); } }
    function handleFileInputClick() { fileInput.click(); }
    function handleSendClick() { sendMessage(); }
    function handleEnterKey(event) { if (event.key === 'Enter' && !event.shiftKey && !sendButton.disabled) { event.preventDefault(); sendMessage(); } }
    function handleInputResize() { this.style.height = 'auto'; const scrollHeight = this.scrollHeight; const maxHeight = parseInt(window.getComputedStyle(this).maxHeight) || 150; this.style.height = Math.min(scrollHeight, maxHeight) + (scrollHeight > this.clientHeight ? 2 : 0) + 'px'; this.style.overflowY = scrollHeight > maxHeight ? 'auto' : 'hidden'; }
    function handleLogoClick(e) { e.stopPropagation(); const logoImg = this.querySelector('.header-logo'); logoImg.style.animation = 'none'; void logoImg.offsetWidth; logoImg.style.animation = 'spin 0.5s ease-in-out'; logoImg.addEventListener('animationend', () => { logoImg.style.animation = ''; }, { once: true }); }
    function showF9Modal() { modalTextarea.value = localStorage.getItem(MODAL_STORAGE_KEY) || ''; f9Modal.style.display = 'flex'; modalTextarea.focus(); modalTextarea.scrollTop = modalTextarea.scrollHeight; }
    function hideF9Modal() { localStorage.setItem(MODAL_STORAGE_KEY, modalTextarea.value); f9Modal.style.display = 'none'; }
    function handleModalSendClick() { const selectedText = modalTextarea.value.substring(modalTextarea.selectionStart, modalTextarea.selectionEnd); if (selectedText) { const currentInputText = messageInput.value; messageInput.value = (currentInputText ? currentInputText + '\n\n' : '') + selectedText; handleInputResize.call(messageInput); hideF9Modal(); messageInput.focus(); setTimeout(() => { if (!sendButton.disabled) sendButton.click(); }, 100); } else { showNotification("Сначала выделите текст в окне (F9).", true); } }
    function getCurrentTime() { const now = new Date(); return now.toLocaleTimeString('ru-RU', { hour: '2-digit', minute: '2-digit', second: '2-digit' }); }
    function copyTextToClipboard(text) { if (navigator.clipboard && navigator.clipboard.writeText) { return navigator.clipboard.writeText(text).then(() => true, (err) => { return copyViaExecCommand(text); }); } else { return Promise.resolve(copyViaExecCommand(text)); } }
    function copyViaExecCommand(text) { const textArea = document.createElement('textarea'); textArea.value = text; textArea.style.position = 'fixed'; textArea.style.left = '-999999px'; textArea.style.top = '-999999px'; document.body.appendChild(textArea); textArea.select(); textArea.setSelectionRange(0, 99999); let success = false; try { success = document.execCommand('copy'); } catch (err) {} document.body.removeChild(textArea); return success; }
    async function handleCopyButtonClick(button, textToCopy, buttonTextSpan = null) { if (textToCopy) { try { const success = await copyTextToClipboard(textToCopy); if (success) { button.classList.add('copy-flash', 'copied'); if (buttonTextSpan) buttonTextSpan.textContent = 'Скопировано!'; showNotification('Скопировано'); setTimeout(() => { button.classList.remove('copy-flash', 'copied'); if (buttonTextSpan) buttonTextSpan.textContent = 'Копировать'; }, 1500); } else { if (buttonTextSpan) buttonTextSpan.textContent = 'Ошибка'; button.classList.add('error'); showNotification('Не удалось скопировать', true); setTimeout(() => { if (buttonTextSpan) buttonTextSpan.textContent = 'Копировать'; button.classList.remove('error'); }, 2000); } } catch (err) { if (buttonTextSpan) buttonTextSpan.textContent = 'Ошибка'; button.classList.add('error'); showNotification('Ошибка копирования', true); setTimeout(() => { if (buttonTextSpan) buttonTextSpan.textContent = 'Копировать'; button.classList.remove('error'); }, 2000); } } else { showNotification('Нет текста для копирования', true); } }
    function addCopyButtonToMessage(messageDiv) { const messageContent = messageDiv.querySelector('.message-content'); if (!messageContent || messageDiv.querySelector('.copy-button:not(.code-copy-button)')) return; const copyButton = document.createElement('button'); copyButton.className = 'copy-button'; copyButton.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path></svg>'; copyButton.title = 'Копировать'; messageDiv.appendChild(copyButton); copyButton.addEventListener('click', function(e) { e.stopPropagation(); const rawText = messageContent.dataset.rawText || messageContent.innerText?.trim() || ''; handleCopyButtonClick(this, rawText); }); }
    function escapeHtml(text) { if (typeof text !== 'string') return text; const map = { '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#039;' }; return text.replace(/[&<>"']/g, m => map[m]); }
    function linkify(text) { const urlRegex = /(?<!(?:\]\(|href=|src=|`|='|"))(https?:\/\/[^\s<`'">\])}]+[^\s<`'">.,;!?\])}])/g; return text.replace(urlRegex, (url) => { let displayUrl = url; if (displayUrl.length > 60) { try { const u = new URL(url); displayUrl = `${u.hostname}${u.pathname.length > 15 ? u.pathname.substring(0,12)+'...' : u.pathname}${u.search ? '?...' : ''}${u.hash ? '#...' : ''}`; } catch (e) {} } return `<a href="${escapeHtml(url)}" target="_blank" rel="noopener noreferrer">${escapeHtml(displayUrl)}</a>`; }); }
    function createCodeBlock(code, language = 'plaintext') { const wrapper = document.createElement('div'); wrapper.className = 'code-block'; const header = document.createElement('div'); header.className = 'code-header'; const langSpan = document.createElement('span'); langSpan.className = 'code-language'; let detectedLang = language?.toLowerCase() || 'plaintext'; let displayLang = 'plaintext'; let fileExtension = 'txt'; const langMap = { html: { display: 'html', ext: 'html', mime: 'text/html' }, css: { display: 'css', ext: 'css', mime: 'text/css' }, javascript: { display: 'javascript', ext: 'js', mime: 'text/javascript' }, js: { display: 'javascript', ext: 'js', mime: 'text/javascript' }, python: { display: 'python', ext: 'py', mime: 'text/x-python' }, py: { display: 'python', ext: 'py', mime: 'text/x-python' }, java: { display: 'java', ext: 'java', mime: 'text/x-java-source' }, csharp: { display: 'csharp', ext: 'cs', mime: 'text/plain' }, cs: { display: 'csharp', ext: 'cs', mime: 'text/plain' }, cpp: { display: 'cpp', ext: 'cpp', mime: 'text/x-c++src' }, 'c++': { display: 'cpp', ext: 'cpp', mime: 'text/x-c++src' }, ruby: { display: 'ruby', ext: 'rb', mime: 'text/x-ruby' }, rb: { display: 'ruby', ext: 'rb', mime: 'text/x-ruby' }, php: { display: 'php', ext: 'php', mime: 'application/x-httpd-php' }, go: { display: 'go', ext: 'go', mime: 'text/x-go' }, swift: { display: 'swift', ext: 'swift', mime: 'text/x-swift' }, kotlin: { display: 'kotlin', ext: 'kt', mime: 'text/x-kotlin' }, kt: { display: 'kotlin', ext: 'kt', mime: 'text/x-kotlin' }, sql: { display: 'sql', ext: 'sql', mime: 'application/sql' }, xml: { display: 'xml', ext: 'xml', mime: 'application/xml' }, json: { display: 'json', ext: 'json', mime: 'application/json' }, markdown: { display: 'markdown', ext: 'md', mime: 'text/markdown' }, md: { display: 'markdown', ext: 'md', mime: 'text/markdown' }, shell: { display: 'shell', ext: 'sh', mime: 'application/x-sh' }, bash: { display: 'bash', ext: 'sh', mime: 'application/x-sh' }, sh: { display: 'shell', ext: 'sh', mime: 'application/x-sh' }, typescript: { display: 'typescript', ext: 'ts', mime: 'application/typescript' }, ts: { display: 'typescript', ext: 'ts', mime: 'application/typescript' }, plaintext: { display: 'plaintext', ext: 'txt', mime: 'text/plain' }, text: { display: 'plaintext', ext: 'txt', mime: 'text/plain' }, "": { display: 'plaintext', ext: 'txt', mime: 'text/plain' }, }; if (typeof hljs !== 'undefined' && (!detectedLang || ['plaintext', 'text'].includes(detectedLang))) { try { const result = hljs.highlightAuto(code); detectedLang = result.language || 'plaintext'; } catch (e) { detectedLang = 'plaintext'; } } const langInfo = langMap[detectedLang] || langMap.plaintext; displayLang = langInfo.display; fileExtension = langInfo.ext; const mimeType = langInfo.mime; langSpan.textContent = displayLang; const buttonContainer = document.createElement('div'); buttonContainer.style.display = 'flex'; buttonContainer.style.gap = '8px'; const copyButton = document.createElement('button'); copyButton.className = 'code-copy-button'; const copyBtnSpan = document.createElement('span'); copyBtnSpan.textContent = 'Копировать'; copyButton.innerHTML = '<svg viewBox="0 0 24 24" width="12" height="12" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path></svg>'; copyButton.appendChild(copyBtnSpan); copyButton.title = 'Скопировать код'; copyButton.addEventListener('click', (e) => { e.stopPropagation(); handleCopyButtonClick(copyButton, code, copyBtnSpan); }); const saveButton = document.createElement('button'); saveButton.className = 'code-save-button'; const saveBtnSpan = document.createElement('span'); saveBtnSpan.textContent = 'Сохранить'; saveButton.innerHTML = '<svg viewBox="0 0 24 24" width="12" height="12" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M19 9h-4V3H9v6H5l7 7 7-7zM5 18v2h14v-2H5z"/></svg>'; saveButton.appendChild(saveBtnSpan); saveButton.title = `Сохранить как .${fileExtension}`; saveButton.addEventListener('click', (e) => { e.stopPropagation(); try { const blob = new Blob([code], { type: `${mimeType};charset=utf-8` }); const url = URL.createObjectURL(blob); const a = document.createElement('a'); a.href = url; a.download = `code_snippet_${Date.now()}.${fileExtension}`; document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(url); showNotification(`Файл '.${fileExtension}' начал скачиваться.`); } catch (error) { showNotification('Не удалось сохранить файл.', true); } }); buttonContainer.appendChild(copyButton); buttonContainer.appendChild(saveButton); header.appendChild(langSpan); header.appendChild(buttonContainer); const pre = document.createElement('pre'); const codeElement = document.createElement('code'); const validLang = (typeof hljs !== 'undefined' && hljs.getLanguage(displayLang)) ? displayLang : 'plaintext'; codeElement.className = `language-${validLang}`; codeElement.textContent = code; pre.appendChild(codeElement); wrapper.appendChild(header); wrapper.appendChild(pre); return wrapper; }
    function formatMessageContent(rawText) { const codeBlockRegex = /```(\w+)?\n?([\s\S]*?)```/gs; let parts = []; let lastIndex = 0; let match; while ((match = codeBlockRegex.exec(rawText)) !== null) { if (match.index > lastIndex) parts.push({ type: 'text', content: rawText.substring(lastIndex, match.index) }); parts.push({ type: 'code', content: match[2] || '', language: match[1] || '' }); lastIndex = match.index + match[0].length; } if (lastIndex < rawText.length) parts.push({ type: 'text', content: rawText.substring(lastIndex) }); if (parts.length === 0 && rawText.trim().length > 0) { parts.push({ type: 'text', content: rawText }); } else if (parts.length === 0 && rawText.length === 0) { return document.createDocumentFragment(); } const fragment = document.createDocumentFragment(); parts.forEach(part => { if (part.type === 'text') { let html = escapeHtml(part.content) .replace(/`([^`]+?)`/g, '<code>$1</code>') .replace(/\*\*(?=\S)(.+?[*\s]?)(?<=\S)\*\*/g, '<strong>$1</strong>') .replace(/__(?=\S)(.+?[_\s]?)(?<=\S)__/g, '<strong>$1</strong>') .replace(/(?<!\*)\*(?=\S)(.+?[*\s]?)(?<=\S)\*(?!\*)/g, '<em>$1</em>'); html = linkify(html).replace(/\n/g, '<br>'); const tempDiv = document.createElement('div'); tempDiv.innerHTML = html; while (tempDiv.firstChild) { fragment.appendChild(tempDiv.firstChild); } } else if (part.type === 'code') { fragment.appendChild(createCodeBlock(part.content, part.language)); } }); return fragment; }
    function startFaviconBlinking() { if (faviconIntervalId) return; faviconIntervalId = setInterval(() => { faviconElement.href = faviconIsOriginal ? alternateFaviconHref : originalFaviconHref; faviconIsOriginal = !faviconIsOriginal; }, 800); }
    function stopFaviconBlinking() { if (faviconIntervalId) { clearInterval(faviconIntervalId); faviconIntervalId = null; } faviconElement.href = originalFaviconHref; faviconIsOriginal = true; }
    function showTypingIndicator() { const existing = document.querySelector('.typing-indicator-container'); if (existing) return existing; const typingDiv = document.createElement('div'); typingDiv.className = 'typing-indicator'; typingDiv.innerHTML = '<div class="typing-dot"></div><div class="typing-dot"></div><div class="typing-dot"></div>'; const dotColors = ['var(--accent-color)', 'var(--typing-dot-color)']; const randomColor = dotColors[Math.floor(Math.random() * dotColors.length)]; const dots = typingDiv.querySelectorAll('.typing-dot'); dots.forEach(dot => { dot.style.backgroundColor = randomColor; }); const typingContainer = document.createElement('div'); typingContainer.className = 'message bot-message clearfix typing-indicator-container'; typingContainer.appendChild(typingDiv); chatContainer.appendChild(typingContainer); chatContainer.scrollTo({ top: chatContainer.scrollHeight, behavior: 'smooth' }); startFaviconBlinking(); return typingContainer; }
    function removeTypingIndicator() { const indicator = document.querySelector('.typing-indicator-container'); if (indicator) { indicator.remove(); } stopFaviconBlinking(); }
    async function extractTextFromPdf(file) { return new Promise(async (resolve, reject) => { if (typeof pdfjsLib === 'undefined') { return reject(new Error('pdf.js не загружена.')); } if (!pdfjsLib.GlobalWorkerOptions.workerSrc) { pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.11.338/pdf.worker.min.js'; } const reader = new FileReader(); reader.onload = async (event) => { if (!event.target?.result) { return reject(new Error("FileReader error reading PDF.")); } try { const typedArray = new Uint8Array(event.target.result); const pdf = await pdfjsLib.getDocument(typedArray).promise; let fullText = ''; const MAX_PAGES = 10; const numPagesToProcess = Math.min(pdf.numPages, MAX_PAGES); for (let i = 1; i <= numPagesToProcess; i++) { try { const page = await pdf.getPage(i); const tc = await page.getTextContent({ normalizeWhitespace: true }); const pageText = tc.items.map(it => it.str || '').join(' '); fullText += pageText.trim() + '\n\n'; page.cleanup(); } catch (pageError) { fullText += `\n\n[Ошибка извлечения текста со стр. ${i}]\n\n`; } } if (pdf.numPages > MAX_PAGES) { fullText += `\n... [Содержимое усечено после ${MAX_PAGES} стр.] ...`; } resolve(fullText.replace(/\n{3,}/g, '\n\n').trim()); } catch (error) { reject(new Error(`Ошибка извлечения PDF: ${error.message || error}`)); } }; reader.onerror = (error) => reject(new Error(`FileReader error: ${error}`)); reader.readAsArrayBuffer(file); }); }
    function getMimeTypeFromBase64(base64String) { if (!base64String) return null; const match = base64String.match(/^data:([a-zA-Z0-9]+\/[a-zA-Z0-9-.+]+);base64,/); return match ? match[1] : null; }
    function toBase64(file) { return new Promise((resolve, reject) => { const reader = new FileReader(); reader.readAsDataURL(file); reader.onload = () => resolve(reader.result); reader.onerror = error => reject(error); }); }
    function showNotification(message, isError = false, duration = null) { const existing = document.querySelector('.notification.show'); if (existing) { existing.classList.remove('show'); existing.addEventListener('transitionend', () => { if (existing.parentNode) existing.parentNode.removeChild(existing); displayNewNotification(message, isError, duration); }, { once: true }); } else { displayNewNotification(message, isError, duration); } }
    function displayNewNotification(message, isError, duration) { const newNotification = document.createElement('div'); newNotification.className = 'notification'; newNotification.innerHTML = `<span class="notification-icon">${isError ? '⚠️' : 'ℹ️'}</span><span class="notification-text">${message}</span>`; if (isError) { newNotification.style.backgroundColor = '#d93025'; newNotification.style.color = 'white'; } else { newNotification.style.backgroundColor = 'var(--notification-color)'; newNotification.style.color = 'var(--button-color)'; } document.body.appendChild(newNotification); newNotification.style.display = 'flex'; requestAnimationFrame(() => { requestAnimationFrame(() => { newNotification.classList.add('show'); }); }); const hideDuration = duration ?? (isError ? 4000 : 2500); setTimeout(() => { newNotification.classList.remove('show'); newNotification.addEventListener('transitionend', () => { if (newNotification.parentNode) newNotification.parentNode.removeChild(newNotification); }, { once: true }); }, hideDuration); }
    function handleFileSelection() { if (fileInput.files?.[0]) { const file = fileInput.files[0]; const allowedTypes = ['image/jpeg', 'image/png', 'image/gif', 'image/webp', 'application/pdf']; const maxMB = 10; if (allowedTypes.includes(file.type)) { if (file.size > maxMB * 1024 * 1024) { showNotification(`Файл "${file.name}" слишком большой (> ${maxMB} MB).`, true); uploadedFile = null; } else { uploadedFile = file; showNotification(`Файл "${file.name}" прикреплен (${(file.size / 1024 / 1024).toFixed(1)} MB).`); } } else { showNotification(`Тип файла "${file.type || '?'}" не поддерживается.`, true); uploadedFile = null; } desktopUploadButton.classList.toggle('file-selected', !!uploadedFile); desktopUploadButton.title = uploadedFile ? `Прикреплен: ${uploadedFile.name}` : 'Прикрепить файл'; fileInput.value = null; } }
    async function handlePaste(event) { const items = (event.clipboardData || window.clipboardData)?.items; if (!items) return; let imageFile = null; for (let i = 0; i < items.length; i++) { if (items[i].type.startsWith('image/')) { const blob = items[i].getAsFile(); if (blob) { const ext = blob.type.split('/')[1] || 'png'; const name = `pasted-image-${Date.now()}.${ext}`; imageFile = new File([blob], name, { type: blob.type }); break; } } } if (imageFile) { event.preventDefault(); const maxMB = 10; if (imageFile.size > maxMB * 1024 * 1024) { showNotification(`Вставленное изображение слишком большое (> ${maxMB} MB).`, true); uploadedFile = null; } else { uploadedFile = imageFile; messageInput.value = "Изображение из буфера обмена"; handleInputResize.call(messageInput); showNotification(`Изображение из буфера обмена прикреплено.`); sendMessage(); } desktopUploadButton.classList.toggle('file-selected', !!uploadedFile); desktopUploadButton.title = uploadedFile ? `Прикреплено: ${uploadedFile.name}` : 'Прикрепить файл'; } }
    function formatDuration(seconds) { if (seconds === null || seconds < 0) return ''; const totalSeconds = Math.round(seconds); if (totalSeconds === 0) return 'менее 1 сек'; const minutes = Math.floor(totalSeconds / 60); const remainingSeconds = totalSeconds % 60; let durationString = ''; if (minutes > 0) { durationString += `${minutes} мин`; } if (remainingSeconds > 0) { if (minutes > 0) durationString += ' '; durationString += `${remainingSeconds} сек`; } return durationString.trim(); }
    function displayMessage(sender, message, fileUrl = null, fileName = null, isBase64Image = false, responseDuration = null) { const messageDiv = document.createElement('div'); messageDiv.className = `message ${sender}-message clearfix`; const contentDiv = document.createElement('div'); contentDiv.className = 'message-content'; contentDiv.style.fontSize = fontSizes[currentFontSizeIndex] + 'px'; let messageTextContent = message; let containsCode = false; let imageElement = null; if (isBase64Image && message?.startsWith('data:image')) { imageElement = document.createElement('img'); imageElement.src = message; imageElement.alt = "Generated Image"; messageTextContent = '[Generated Image]'; } else if (sender === 'user' && fileUrl && (fileName?.match(/\.(jpg|jpeg|png|gif|webp)$/i) || fileUrl.startsWith('data:image'))) { imageElement = document.createElement('img'); imageElement.src = fileUrl; imageElement.alt = fileName || "Uploaded image"; messageTextContent = message || `(Файл: ${fileName})`; } if (imageElement) { imageElement.className = 'message-image'; imageElement.onclick = () => window.open(imageElement.src, '_blank'); contentDiv.appendChild(imageElement); if (message && !isBase64Image) { contentDiv.appendChild(document.createElement('br')); } } const textToFormat = message || (fileName && !imageElement ? `(Файл: ${fileName})` : '') || ''; if (!isBase64Image && textToFormat) { const formattedFragment = formatMessageContent(textToFormat); containsCode = !!formattedFragment.querySelector('.code-block'); contentDiv.appendChild(formattedFragment); } else if (isBase64Image && !imageElement && message) { const formattedFragment = formatMessageContent(message); containsCode = !!formattedFragment.querySelector('.code-block'); contentDiv.appendChild(formattedFragment); } contentDiv.dataset.rawText = messageTextContent; const timeDiv = document.createElement('div'); timeDiv.className = 'time-display'; let timeString = getCurrentTime(); if (sender === 'bot' && responseDuration !== null) { const durationSeconds = parseFloat(responseDuration); const formattedDuration = formatDuration(durationSeconds); if (formattedDuration) { timeString += `  (ответ за ${formattedDuration})`; } } timeDiv.textContent = timeString; contentDiv.appendChild(timeDiv); messageDiv.appendChild(contentDiv); if (messageTextContent && !isBase64Image && !containsCode) { setTimeout(() => addCopyButtonToMessage(messageDiv), 50); } chatContainer.appendChild(messageDiv); chatContainer.scrollTo({ top: chatContainer.scrollHeight, behavior: 'smooth' }); const codeBlocks = messageDiv.querySelectorAll('.code-block code'); if (codeBlocks.length > 0 && typeof hljs !== 'undefined') { codeBlocks.forEach((block) => { try { if (!block.dataset.highlighted) { hljs.highlightElement(block); block.dataset.highlighted = 'true'; } } catch (e) { } }); } }
    function transformGeminiToClaudeMessages(geminiContents) { const messages = []; let lastUserText = ""; let lastUserPartsForClaude = []; let foundLastUser = false; for (let i = geminiContents.length - 1; i >= 0; i--) { const item = geminiContents[i]; const role = item.role; const parts = item.parts || []; if (role === 'user' && !foundLastUser) { foundLastUser = true; const currentUserTextParts = []; for (const part of parts) { if (part.text) currentUserTextParts.push(part.text.trim()); if (part.inlineData || part.inline_data) { const inlineData = part.inlineData || part.inline_data || {}; const mimeType = inlineData.mimeType || 'image/unknown'; lastUserPartsForClaude.push({ "type": "text", "text": `[Image (${mimeType}) present]` }); } } lastUserText = currentUserTextParts.join(" ").trim(); if (lastUserText) lastUserPartsForClaude.unshift({ "type": "text", "text": lastUserText }); if (i > 0) { const prevItem = geminiContents[i-1]; if (prevItem.role === 'model') { const assistantText = (prevItem.parts || []) .filter(p => p.text) .map(p => p.text.trim()) .join(" ") .trim(); if (assistantText) messages.push({ "role": "assistant", "content": assistantText }); } } break; } } if (lastUserPartsForClaude.length > 0) { messages.push({ "role": "user", "content": lastUserPartsForClaude }); } else if (lastUserText) { messages.push({ "role": "user", "content": lastUserText }); } if (messages.length > 0 && messages[0].role === 'assistant') { messages.shift(); } else if (messages.length === 0 && lastUserText) { messages.push({ "role": "user", "content": lastUserText }); } messages.reverse(); return messages; }
    function transliterateFromEnToRu(text) { const enToRuMap = { 'q': 'й', 'w': 'ц', 'e': 'у', 'r': 'к', 't': 'е', 'y': 'н', 'u': 'г', 'i': 'ш', 'o': 'щ', 'p': 'з', '[': 'х', ']': 'ъ', 'a': 'ф', 's': 'ы', 'd': 'в', 'f': 'а', 'g': 'п', 'h': 'р', 'j': 'о', 'k': 'л', 'l': 'д', ';': 'ж', "'": 'э', 'z': 'я', 'x': 'ч', 'c': 'с', 'v': 'м', 'b': 'и', 'n': 'т', 'm': 'ь', ',': 'б', '.': 'ю', '`': 'ё', '<': 'б', '>': 'ю', '?': ',', '/': '.', 'Q': 'Й', 'W': 'Ц', 'E': 'У', 'R': 'К', 'T': 'Е', 'Y': 'Н', 'U': 'Г', 'I': 'Ш', 'O': 'Щ', 'P': 'З', '{': 'Х', '}': 'Ъ', 'A': 'Ф', 'S': 'Ы', 'D': 'В', 'F': 'А', 'G': 'П', 'H': 'Р', 'J': 'О', 'K': 'Л', 'L': 'Д', ':': 'Ж', '"': 'Э', 'Z': 'Я', 'X': 'Ч', 'C': 'С', 'V': 'М', 'B': 'И', 'N': 'Т', 'M': 'Ь', '~': 'Ё' }; let result = ''; for (let i = 0; i < text.length; i++) { const char = text[i]; result += enToRuMap[char] || char; } return result; }

    // START: Added function for Crop Modal
    function showCropModal(imageFile) {
        return new Promise((resolve) => {
            cropModalResolve = resolve;
            const modal = document.getElementById('crop-image-modal');
            const imgPreview = document.getElementById('crop-image-preview');
            const cropContainer = document.getElementById('crop-image-container');
            const selectionRectDiv = document.getElementById('crop-selection-rectangle');
            const confirmButton = document.getElementById('crop-image-button-confirm');
            const cancelButton = document.getElementById('crop-image-button-cancel');

            selectionRectDiv.style.display = 'none';
            cropSelection.isDrawing = false;

            const reader = new FileReader();
            reader.onload = function(e) {
                imgPreview.src = e.target.result;
                modal.style.display = 'flex';

                imgPreview.onload = () => {
                    imageNaturalSize.width = imgPreview.naturalWidth;
                    imageNaturalSize.height = imgPreview.naturalHeight;

                    const modalContentWrapper = modal.querySelector('.crop-modal-content-wrapper');
                    const containerPadding = 40;
                    const buttonsAndTextHeight = 120;

                    imgPreview.style.maxWidth = `calc(${modalContentWrapper.clientWidth - containerPadding}px - 2px)`;
                    imgPreview.style.maxHeight = `calc(${modalContentWrapper.clientHeight - containerPadding - buttonsAndTextHeight}px - 2px)`;

                    requestAnimationFrame(() => {
                        imageDisplaySize.width = imgPreview.offsetWidth;
                        imageDisplaySize.height = imgPreview.offsetHeight;
                    });
                };
            };
            reader.readAsDataURL(imageFile);

            function updateSelectionRect() {
                const x = Math.min(cropSelection.startX, cropSelection.endX);
                const y = Math.min(cropSelection.startY, cropSelection.endY);
                const width = Math.abs(cropSelection.endX - cropSelection.startX);
                const height = Math.abs(cropSelection.endY - cropSelection.startY);
                selectionRectDiv.style.left = `${x}px`;
                selectionRectDiv.style.top = `${y}px`;
                selectionRectDiv.style.width = `${width}px`;
                selectionRectDiv.style.height = `${height}px`;
            }

            function getMousePos(event) {
                const rect = cropContainer.getBoundingClientRect();
                let x = event.clientX - rect.left;
                let y = event.clientY - rect.top;
                x = Math.max(0, Math.min(x, imageDisplaySize.width));
                y = Math.max(0, Math.min(y, imageDisplaySize.height));
                return { x, y };
            }

            const onMouseDown = (e) => {
                e.preventDefault();
                if (e.button !== 0 && e.type === 'mousedown') return;
                cropSelection.isDrawing = true;
                const pos = getMousePos(e.touches ? e.touches[0] : e);
                cropSelection.startX = pos.x;
                cropSelection.startY = pos.y;
                cropSelection.endX = pos.x;
                cropSelection.endY = pos.y;
                selectionRectDiv.style.width = '0px';
                selectionRectDiv.style.height = '0px';
                selectionRectDiv.style.left = `${pos.x}px`;
                selectionRectDiv.style.top = `${pos.y}px`;
                selectionRectDiv.style.display = 'block';
                cropContainer.addEventListener('mousemove', onMouseMove);
                cropContainer.addEventListener('touchmove', onMouseMove, { passive: false });
                window.addEventListener('mouseup', onMouseUp);
                window.addEventListener('touchend', onMouseUp);
            };

            const onMouseMove = (e) => {
                if (!cropSelection.isDrawing) return;
                e.preventDefault();
                const pos = getMousePos(e.touches ? e.touches[0] : e);
                cropSelection.endX = pos.x;
                cropSelection.endY = pos.y;
                updateSelectionRect();
            };

            const onMouseUp = () => {
                if (!cropSelection.isDrawing) return;
                cropSelection.isDrawing = false;
                cropContainer.removeEventListener('mousemove', onMouseMove);
                cropContainer.removeEventListener('touchmove', onMouseMove);
                window.removeEventListener('mouseup', onMouseUp);
                window.removeEventListener('touchend', onMouseUp);
                const width = Math.abs(cropSelection.endX - cropSelection.startX);
                const height = Math.abs(cropSelection.endY - cropSelection.startY);
                if (width < 5 || height < 5) {
                    selectionRectDiv.style.display = 'none';
                }
            };

            cropContainer.addEventListener('mousedown', onMouseDown);
            cropContainer.addEventListener('touchstart', onMouseDown, { passive: false });

            const handleConfirm = () => {
                const selWidth = Math.abs(cropSelection.endX - cropSelection.startX);
                const selHeight = Math.abs(cropSelection.endY - cropSelection.startY);
                if (selWidth < 5 || selHeight < 5 || selectionRectDiv.style.display === 'none') {
                    toBase64(imageFile).then(base64 => cropModalResolve({
                        cropped: false, data: base64
                    }));
                    cleanupModal();
                    return;
                }
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                const scaleX = imageNaturalSize.width / imageDisplaySize.width;
                const scaleY = imageNaturalSize.height / imageDisplaySize.height;
                const sX = Math.min(cropSelection.startX, cropSelection.endX) * scaleX;
                const sY = Math.min(cropSelection.startY, cropSelection.endY) * scaleY;
                const sWidth = selWidth * scaleX;
                const sHeight = selHeight * scaleY;
                canvas.width = sWidth;
                canvas.height = sHeight;
                ctx.drawImage(imgPreview, sX, sY, sWidth, sHeight, 0, 0, sWidth, sHeight);
                const croppedImageDataUrl = canvas.toDataURL(imageFile.type);
                cropModalResolve({ cropped: true, data: croppedImageDataUrl });
                cleanupModal();
            };

            const handleCancel = () => {
                toBase64(imageFile).then(base64 => cropModalResolve({
                    cropped: false, data: base64
                }));
                cleanupModal();
            };

            confirmButton.onclick = handleConfirm;
            cancelButton.onclick = handleCancel;

            function cleanupModal() {
                modal.style.display = 'none';
                imgPreview.src = '#';
                imgPreview.onload = null;
                cropContainer.removeEventListener('mousedown', onMouseDown);
                cropContainer.removeEventListener('touchstart', onMouseDown);
                cropContainer.removeEventListener('mousemove', onMouseMove);
                cropContainer.removeEventListener('touchmove', onMouseMove);
                window.removeEventListener('mouseup', onMouseUp);
                window.removeEventListener('touchend', onMouseUp);
                confirmButton.onclick = null;
                cancelButton.onclick = null;
                cropModalResolve = null;
            }
        });
    }
    // END: Added function for Crop Modal

 function cleanBotResponse(rawText) {
        if (typeof rawText !== 'string' || !rawText) {
            return '';
        }
        // 1. Приоритет №1: Ищем блок \boxed{...} - это всегда финальный ответ.
        const boxedMatch = rawText.match(/\\boxed{([\s\S]*?)}/);
        if (boxedMatch && boxedMatch[1]) {
            return boxedMatch[1].trim();
        }
        // 2. Если \boxed{} не найден, удаляем блок <think>...</think>.
        let cleanedText = rawText.replace(/<think>[\s\S]*?<\/think>/g, '');
        // 3. Удаляем заголовки и резюме в стиле Markdown.
        cleanedText = cleanedText.replace(/###\s*(Итог|Резюме)[\s\S]*/i, '');
        cleanedText = cleanedText.replace(/\*\*(Ответ|Итог):\*\*/gi, '');
        cleanedText = cleanedText.replace(/Краткое резюме:[\s\S]*/i, '');
        // 4. Финальная очистка от лишних пробелов.
        return cleanedText.trim();
    }

    async function sendMessage() {
        let message = messageInput.value.trim();
        let fileData = null;
        let fileUrlForDisplay = null;
        let userFileName = null;
        let pdfTextContent = null;
        let originalMessage = message;
        let correctedMessage = message;
        let wasCorrected = false;

        const hasRussianChars = /[а-яА-ЯёЁ]/.test(message);
        if (message && !hasRussianChars) {
            const potentialCorrection = transliterateFromEnToRu(message);
            if (potentialCorrection !== message && /[а-яА-ЯёЁ]/.test(potentialCorrection)) {
                correctedMessage = potentialCorrection;
                wasCorrected = true;
            }
        }

        sendButton.disabled = true;
        desktopUploadButton.disabled = true;
        lastUserMessageTimestamp = performance.now();

        // --- БЛОК ПРОВЕРКИ МОДЕЛИ И КЛЮЧЕЙ (ИСПРАВЛЕННЫЙ ПОРЯДОК) ---
        const selectedModel = MODELS.find(m => m.id === currentSelectedModelId);
        if (!selectedModel) {
            showNotification("Модель не выбрана или не найдена.", true);
            sendButton.disabled = false;
            desktopUploadButton.disabled = false;
            return;
        }

        if (selectedModel.apiType === 'gemini' && currentApiMode === 'direct' && !apiKey) {
            showNotification("Пожалуйста, введите API ключ для Gemini.", true);
            showApiKeyModal();
            sendButton.disabled = false;
            desktopUploadButton.disabled = false;
            return;
        }

        if (selectedModel.apiType === 'mistral' && currentApiMode === 'direct_mistral' && !mistralApiKey) {
            showNotification("Пожалуйста, введите API ключ для Mistral.", true);
            showApiKeyModal();
            sendButton.disabled = false;
            desktopUploadButton.disabled = false;
            return;
        }
        // --- КОНЕЦ БЛОКА ПРОВЕРКИ ---

        if (uploadedFile) {
            userFileName = uploadedFile.name;
            desktopUploadButton.title = `Обработка: ${userFileName}`;
            const typingIndicator = showTypingIndicator();
            try {
                if (uploadedFile.type.startsWith('image/')) {
                    fileData = await new Promise((resolve, reject) => {
                        const tempImg = new Image();
                        const objectURL = URL.createObjectURL(uploadedFile);
                        tempImg.onload = async () => {
                            URL.revokeObjectURL(objectURL);
                            if (tempImg.width > 800 || tempImg.height > 800) {
                                try {
                                    const cropResult = await showCropModal(uploadedFile);
                                    resolve(cropResult.data);
                                } catch (cropError) {
                                    reject(cropError);
                                }
                            } else {
                                resolve(await toBase64(uploadedFile));
                            }
                        };
                        tempImg.onerror = () => {
                            URL.revokeObjectURL(objectURL);
                            reject(new Error('Не удалось загрузить изображение для проверки размеров.'));
                        };
                        tempImg.src = objectURL;
                    });
                    fileUrlForDisplay = fileData;
                } else if (uploadedFile.type === 'application/pdf') {
                    showNotification(`Извлечение текста из PDF: ${userFileName}...`, false, 8000);
                    pdfTextContent = await extractTextFromPdf(uploadedFile);
                    showNotification(`Текст из PDF "${userFileName}" извлечен.`);
                }
            } catch (error) {
                showNotification(`Ошибка обработки файла ${userFileName}: ${error.message}`, true);
                uploadedFile = null;
            } finally {
                removeTypingIndicator();
            }
        }

        let textForApi = wasCorrected ? correctedMessage : originalMessage;
        if (pdfTextContent) {
            textForApi = (textForApi ? textForApi + '\n\n' : '') + `--- Начало PDF (${userFileName || 'файл'}) ---\n${pdfTextContent}\n--- Конец PDF (${userFileName || 'файл'}) ---`;
        }

        if (!textForApi.trim() && !fileData) {
            showNotification("Введите сообщение или прикрепите файл.", true);
            sendButton.disabled = false;
            desktopUploadButton.disabled = false;
            lastUserMessageTimestamp = null;
            uploadedFile = null;
            fileInput.value = null;
            desktopUploadButton.classList.remove('file-selected');
            desktopUploadButton.title = 'Прикрепить файл';
            return;
        }

        let systemInstruction = "(Your primary response language is Russian. Always reply in Russian if the user's prompt is in Russian. You may switch to English only if the user writes entirely in English or explicitly asks you to. Use other languages only upon explicit request.)";
        if (wasCorrected) {
            systemInstruction = `(Дополнительная инструкция: запрос пользователя "${originalMessage}" был автоматически распознан как "${correctedMessage}" из-за неверной раскладки клавиатуры. Дай ответ на распознанный запрос и в конце вежливо упомяни, что исходный текст был скорректирован.)`;
        }

        displayMessage('user', originalMessage, fileUrlForDisplay, userFileName);
        const historyEntry = { sender: 'user', text: textForApi };
        if (fileData) {
            historyEntry.file = { data: fileData, mimeType: getMimeTypeFromBase64(fileData) };
        }
        chatHistory.push(historyEntry);

        updateHeaderSizeDisplay();
        messageInput.value = '';
        handleInputResize.call(messageInput);
        desktopUploadButton.classList.remove('file-selected');
        desktopUploadButton.title = 'Прикрепить файл';
        uploadedFile = null;
        fileInput.value = null;

        const typingIndicator = showTypingIndicator();
        let apiUrl;
        let requestBody;
        let fetchOptions = { method: 'POST', headers: { 'Content-Type': 'application/json' } };

        try {
            const apiModeConfig = API_MODES[currentApiMode];
            const isMapruappProxy = currentApiMode === 'mapruapp';

            if (isMapruappProxy) {
                const openRouterMessages = [];
                openRouterMessages.push({ role: 'system', content: systemInstruction });
                chatHistory.forEach(msg => {
                    let content = [];
                    if (msg.text) content.push({ type: 'text', text: msg.text });
                    if (msg.sender === 'user' && msg.file) { content.push({ type: 'image_url', image_url: { url: msg.file.data } }); }
                    const role = msg.sender === 'bot' ? 'assistant' : 'user';
                    openRouterMessages.push({ role: role, content: content.length === 1 && content[0].type === 'text' ? content[0].text : content });
                });
                apiUrl = apiModeConfig.geminiUrl();
                requestBody = { model: selectedModel.id, messages: openRouterMessages, max_tokens: 4096 };
            } else {
                if (currentApiMode === 'direct_mistral') {
                    apiUrl = 'https://api.mistral.ai/v1/chat/completions';
                    fetchOptions.headers['Authorization'] = `Bearer ${mistralApiKey}`;
                    const mistralMessages = [];
                    mistralMessages.push({ role: 'system', content: systemInstruction });
                    chatHistory.forEach(msg => {
                        let content = [];
                        if (msg.text) content.push({ type: 'text', text: msg.text });
                        if (msg.sender === 'user' && msg.file) { content.push({ type: 'image_url', image_url: { url: msg.file.data } }); }
                        const role = msg.sender === 'bot' ? 'assistant' : 'user';
                        mistralMessages.push({ role: role, content: content.length === 1 && content[0].type === 'text' ? content[0].text : content });
                    });
                    requestBody = { model: selectedModel.id, messages: mistralMessages, max_tokens: 4096 };
                } else if (selectedModel.apiType === 'gemini') {
                    apiUrl = apiModeConfig.geminiUrl(selectedModel.id, apiKey);
                    const geminiContents = chatHistory.map(msg => {
                        let parts = [];
                        if (msg.text) parts.push({ text: msg.text });
                        if (msg.sender === 'user' && msg.file) { parts.push({ inlineData: { mimeType: msg.file.mimeType, data: msg.file.data.split(',')[1] } }); }
                        return { role: msg.sender === 'user' ? 'user' : 'model', parts: parts };
                    });
                    if (geminiContents.length > 0 && systemInstruction) {
                        geminiContents[0].parts.unshift({ text: systemInstruction });
                    }
                    requestBody = { contents: geminiContents };
                } else if (selectedModel.apiType === 'anthropic') {
                    apiUrl = apiModeConfig.claudeUrl();
                    if (!apiUrl) throw new Error("Этот режим не поддерживает Claude.");
                    const claudeMessages = chatHistory.map(msg => {
                        let content = [];
                        if (msg.text) content.push({ type: 'text', text: msg.text });
                        if (msg.sender === 'user' && msg.file) { content.push({ type: 'image', source: { type: 'base64', media_type: msg.file.mimeType, data: msg.file.data.split(',')[1] } }); }
                        return { role: msg.sender === 'user' ? 'user' : 'assistant', content: content };
                    });
                    requestBody = { model: selectedModel.id, messages: claudeMessages, max_tokens: 4096, system: systemInstruction };
                } else if (selectedModel.apiType === 'mistral') {
                    apiUrl = `${VERCEL_PROXY_BASE_URL}/proxy/mistral/chat/completions`;
                    const mistralMessages = [];
                    mistralMessages.push({ role: 'system', content: systemInstruction });
                    chatHistory.forEach(msg => {
                        let content = [];
                        if (msg.text) content.push({ type: 'text', text: msg.text });
                        if (msg.sender === 'user' && msg.file) { content.push({ type: 'image_url', image_url: { url: msg.file.data } }); }
                        const role = msg.sender === 'bot' ? 'assistant' : 'user';
                        mistralMessages.push({ role: role, content: content.length === 1 && content[0].type === 'text' ? content[0].text : content });
                    });
                    requestBody = { model: selectedModel.id, messages: mistralMessages, max_tokens: 4096 };
                } else if (selectedModel.apiType === 'openrouter') {
                    apiUrl = `${VERCEL_PROXY_BASE_URL}/proxy/openrouter/chat/completions`;
                    const openRouterMessages = [];
                    openRouterMessages.push({ role: 'system', content: systemInstruction });
                    chatHistory.forEach(msg => {
                        let content = [];
                        if (msg.text) content.push({ type: 'text', text: msg.text });
                        if (msg.sender === 'user' && msg.file) { content.push({ type: 'image_url', image_url: { url: msg.file.data } }); }
                        const role = msg.sender === 'bot' ? 'assistant' : 'user';
                        openRouterMessages.push({ role: role, content: content.length === 1 && content[0].type === 'text' ? content[0].text : content });
                    });
                    requestBody = { model: selectedModel.apiId, messages: openRouterMessages, max_tokens: 4096 };
                }
            }
            fetchOptions.body = JSON.stringify(requestBody);
            const response = await fetch(apiUrl, fetchOptions);
            const botResponseTimestamp = performance.now();
            removeTypingIndicator();
            const duration = lastUserMessageTimestamp ? ((botResponseTimestamp - lastUserMessageTimestamp) / 1000).toFixed(2) : null;
            const data = await response.json();
            if (!response.ok) {
                let errorDetail = data?.error?.message || JSON.stringify(data) || `Статус ${response.status}`;
                if (response.status === 400 && errorDetail.includes("API_KEY_INVALID")) {
                    errorDetail = "API ключ недействителен.";
                    showApiKeyModal();
                }
                throw new Error(`Ошибка API: ${errorDetail}`);
            }
            let botReplyText = null;
            if (isMapruappProxy || currentApiMode === 'direct_mistral') {
                botReplyText = data.choices?.[0]?.message?.content;
            } else {
                if (selectedModel.apiType === 'gemini') {
                    if (data.candidates?.[0]?.content?.parts) {
                        botReplyText = data.candidates[0].content.parts.map(part => part.text || '').join('');
                    }
                } else if (selectedModel.apiType === 'anthropic') {
                    if (data.content?.[0]?.text) {
                        botReplyText = data.content.map(block => block.type === "text" ? block.text : "").join("");
                    }
                } else if (selectedModel.apiType === 'mistral' || selectedModel.apiType === 'openrouter') {
                    botReplyText = data.choices?.[0]?.message?.content;
                }
            }
            if (botReplyText) {
                const cleanedReply = cleanBotResponse(botReplyText);
                displayMessage('bot', cleanedReply, null, null, false, duration);
                chatHistory.push({ sender: 'bot', text: cleanedReply });
            } else {
                const fallbackMessage = data.promptFeedback?.blockReason ? `[Ответ заблокирован: ${data.promptFeedback.blockReason}]` : "[Пустой или некорректный ответ от API]";
                displayMessage('bot', fallbackMessage, null, null, false, duration);
            }
        } catch (error) {
            removeTypingIndicator();
            displayMessage('bot', `Ошибка: ${error.message}`);
        } finally {
            sendButton.disabled = false;
            desktopUploadButton.disabled = false;
            updateHeaderSizeDisplay();
        }
    }

    document.addEventListener('DOMContentLoaded', initializeApp);
</script>
</body>
</html>
