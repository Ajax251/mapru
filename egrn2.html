<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ЕГРН</title>
    <link rel="icon" href="img/savannah.png" type="image/png">
    <link rel="stylesheet" href="webfonts/all.min.css">
     <script src="webfonts/proj4.js"></script>
<script src="webfonts/jspdf.umd.min.js"></script>
<script src="webfonts/jszip.min.js"></script>
<script src="webfonts/html2canvas.min.js"></script>
<script src="webfonts/xlsx.full.min.js"></script>
<script src="webfonts/supabase-js@2.js"></script> 
  <script src="sk.js"></script>
<script src="msk.js"></script>


    <style>
   
   :root {
        --primary-color: #2196F3;
        --secondary-color: #f5f5f5;
        --border-color: #e0e0e0;
        --text-color: #333;
        --spacing: 20px;
    }

    /* Анимации */
    @keyframes fadeIn {
        from { opacity: 0; transform: translateY(-20px); }
        to { opacity: 1; transform: translateY(0); }
    }

    @keyframes slideIn {
        from { transform: translateX(-100%); opacity: 0; }
        to { transform: translateX(0); opacity: 1; }
    }

    body {
        font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        margin: 0;
        padding: var(--spacing);
        background-color: #fafafa;
        color: var(--text-color);
        animation: fadeIn 0.8s ease-out;
    }

    .search-container {
        background: linear-gradient(145deg, #ffffff, #f0f0f0);
        padding: var(--spacing);
        border-radius: 8px;
        box-shadow: 0 8px 15px rgba(0,0,0,0.1);
        margin-bottom: var(--spacing);
        animation: slideIn 0.8s ease-out;
    }

    .search-box {
        display: flex;
        gap: 15px;
        align-items: center;
        position: relative;
        padding: 5px;
    }

    input[type="text"] {
        flex: 1;
        font-size: 18px;
        padding: 15px 20px;
        border: 2px solid var(--border-color);
        border-radius: 25px;
        transition: all 0.3s ease;
        text-align: center;
        box-shadow: inset 0 1px 3px rgba(0,0,0,0.1);
        margin-right: 10px;
        min-width: 0;
    }

    input[type="text"]:focus {
        outline: none;
        border-color: var(--primary-color);
        box-shadow: 0 0 0 3px rgba(33, 150, 243, 0.2);
        transform: scale(1.02);
    }

  button {
    flex-shrink: 0;
    border-radius: 50%;
    width: 50px;
    height: 50px;
    color: white;
    border: none;
    cursor: pointer;
    transition: all 0.3s ease;
    display: flex;
    align-items: center;
    justify-content: center;
    box-shadow: 0 4px 6px rgba(0, 0, 0, 0.2);
    position: relative;
    overflow: hidden;
}

button i {
    font-size: 18px;
    transition: transform 0.3s ease;
}

button:hover {
    transform: translateY(-2px);
    box-shadow: 0 6px 10px rgba(0, 0, 0, 0.3);
}

button:hover i {
    transform: scale(1.2);
}

button:active {
    transform: translateY(0);
    box-shadow: 0 3px 6px rgba(0, 0, 0, 0.2);
}

/* Эффект "нажатия" (ripple) */
button:active::after {
    content: '';
    position: absolute;
    top: 50%;
    left: 50%;
    width: 300%;
    height: 300%;
    background: rgba(255, 255, 255, 0.4);
    transform: translate(-50%, -50%) scale(0);
    border-radius: 50%;
    animation: ripple 0.6s ease;
}

@keyframes ripple {
    to {
        transform: translate(-50%, -50%) scale(1);
        opacity: 0;
    }
}

/* Цвета кнопок из варианта 2 */
button.search-button {
    background: linear-gradient(145deg, #4CAF50, #45a049);
}

button.map-button {
  background: linear-gradient(145deg, #9C27B0, #7B1FA2);

}

button.coordinates-button {
     background: linear-gradient(145deg, #FF9800, #F57C00); 
}

button.keyboard-button {
    background: linear-gradient(145deg, #6395ee, #6395ee);
}

button.yandex-map-button {
    background: linear-gradient(145deg, #FF4444, #CC0000); /* Градиентный красный цвет */
}

button.yandex-map-button:hover {
    background: linear-gradient(145deg, #CC0000, #FF4444); /* Инвертированный градиент при наведении */
}

button.yandex-map-button:active {
    background: linear-gradient(145deg, #CC0000, #FF4444); /* Градиент при нажатии */
}


    .content-container {
        display: none;
        grid-template-columns: 1fr 1fr;
        gap: var(--spacing);
        height: calc(100vh - 150px);
    }

    .data-container {
        background: white;
        padding: var(--spacing);
        border-radius: 8px;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        overflow-y: auto;
    }

    .scheme-container {
        background: white;
        padding: var(--spacing);
        border-radius: 8px;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        position: relative; /* Добавляем для позиционирования "глаза" */
    }

    #schemeCanvas {
        width: 100%;
        height: 100%;
        border: 1px solid var(--border-color);
        border-radius: 4px;
    }
    
/* Стили для toggle */
.toggle-container {
    position: absolute;
    top: 20px;
    right: 20px;
    z-index: 10;
}

.toggle {
    display: none;
}

.toggle + label {
    display: inline-block;
    width: 55px;
    height: 28px;
    background-color: #fff;
    border-radius: 30px;
    position: relative;
    cursor: pointer;
    transition: background-color 0.3s ease;
}

.toggle + label:after {
    content: '';
    display: inline-block;
    position: absolute;
    width: 24px;
    height: 24px;
    background-color: #fff;
    top: 2px;
    left: 2px;
    border-radius: 50%;
    transition: all 0.3s ease;
}

.toggle:checked + label {
    background-color: #2196F3;
}

.toggle:checked + label:after {
    left: 29px;
}
    
    
    
    /* Toggle Specific styles */
input[type='checkbox'].toggle {
    display: inline-block;
    -webkit-appearance: none;
    -moz-appearance: none;
    appearance: none;
    width: 55px;
    height: 28px;
    background-color: #fafafa;
    position: relative;
    border-radius: 30px;
    box-shadow: none;
    transition: all 0.2s ease-in-out;
}

input[type='checkbox'].toggle:hover:after {
    background-color: #d1d1d1;
}

input[type='checkbox'].toggle:after {
    content: '';
    display: inline-block;
    position: absolute;
    width: 24px;
    height: 24px;
    background-color: #ccc;
    top: 2px;
    left: 2px;
    border-radius: 50%;
    transition: all 0.2s ease-in-out;
}

input[type='checkbox'].toggle:checked {
    box-shadow: inset 0 0 0 15px #158EC6;
}

input[type='checkbox'].toggle:checked:after {
    left: 29px;
    background-color: #fff;
}



    /* Стили для таблиц */
    table {
        width: 100%;
        border-collapse: collapse;
        margin-top: 10px;
        border-radius: 8px;
        overflow: hidden;
        box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        animation: fadeIn 0.8s ease-out;
    }

    th, td {
        padding: 15px;
        text-align: left;
        border-bottom: 1px solid var(--border-color);
        transition: background-color 0.3s ease;
    }

    th {
        background-color: var(--secondary-color);
        font-weight: 600;
    }

    tr:hover td {
        background-color: #f5f5f5;
    }

    /* Модальное окно */
    .modal {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0,0,0,0.5);
        z-index: 1000;
        animation: fadeIn 0.3s ease-out;
    }

    .modal-content {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: white;
        padding: 30px;
        border-radius: 15px;
        box-shadow: 0 10px 25px rgba(0,0,0,0.2);
        max-width: 600px;
        width: 90%;
        max-height: 80vh;
        overflow-y: auto;
        text-align: center;
    }

    #modalCoordinatesTable {
        width: 100%;
        border-collapse: collapse;
        margin-top: 20px;
    }

    #modalCoordinatesTable th,
    #modalCoordinatesTable td {
        text-align: center;
        padding: 12px;
        border: 1px solid var(--border-color);
    }

    #modalCoordinatesTable th {
        background-color: var(--secondary-color);
        font-weight: 600;
        text-align: center;
    }

    #modalCoordinatesTable tr:hover td {
        background-color: #f5f5f5;
    }

    .close-modal {
        position: absolute;
        top: 15px;
        right: 15px;
        font-size: 24px;
        cursor: pointer;
        color: #666;
        transition: color 0.3s ease;
    }

    .close-modal:hover {
        color: #333;
    }

    /* Уведомления */
    #notification-container {
        position: fixed;
        bottom: 20px;
        right: 20px;
        z-index: 1000;
        display: flex;
        flex-direction: column;
        gap: 10px;
    }

    .notification {
        background-color: #333;
        color: white;
        padding: 15px 20px;
        border-radius: 5px;
        box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        opacity: 0;
        transform: translateX(100%);
        transition: opacity 0.3s ease, transform 0.3s ease;
    }

    .notification.show {
        opacity: 1;
        transform: translateX(0);
    }

    .notification.success {
        background-color: #4CAF50;
    }

    .notification.error {
        background-color: #F44336;
    }

    .notification.info {
        background-color: #2196F3;
    }
    
     .notification.warning {
        background-color: #FF9800; /* Оранжевый цвет */
    }

    /* Стили для виртуальной клавиатуры */
    .virtual-keyboard {
        display: none;
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: #f5f5f5;
        padding: 20px;
        border-radius: 12px;
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        z-index: 1000;
    }

    .virtual-keyboard.active {
        display: block;
    }

    .keyboard-row {
        display: flex;
        justify-content: center;
        gap: 10px;
        margin-bottom: 10px;
    }

    .keyboard-key {
        width: 60px;
        height: 60px;
        display: flex;
        align-items: center;
        justify-content: center;
        background: #ffffff;
        border: 1px solid #ccc;
        border-radius: 8px;
        cursor: pointer;
        font-size: 20px;
        transition: background 0.3s ease, transform 0.1s ease;
    }

    .keyboard-key:hover {
        background: #e0e0e0;
    }

    .keyboard-key:active {
        background: #d0d0d0;
        transform: scale(0.95);
    }

    .keyboard-key.clear {
        background: #ff4444;
        color: white;
    }

    .keyboard-key.clear:hover {
        background: #cc0000;
    }

    .keyboard-key.enter {
        background: #4CAF50;
        color: white;
        flex-grow: 1;
    }

    .keyboard-key.enter:hover {
        background: #45a049;
    }

    .keyboard-key.enter:active {
        background: #3d8b40;
    }

    /* Стили для мобильной версии */
    @media (max-width: 768px) {
        .search-box {
            flex-direction: column;
            gap: 10px;
        }

        .search-box input[type="text"] {
            width: 100%;
            margin-right: 0;
        }

        .button-row {
            display: flex;
            gap: 10px;
            width: 100%;
        }

        .button-row button {
            flex: 1;
            border-radius: 8px;
        }

        .mobile-only {
            display: block;
        }

        .scheme-container {
            display: none;
        }

        .content-container {
            display: block !important;
            height: auto;
        }

        .data-container {
            width: 100%;
            margin-bottom: var(--spacing);
        }

        #resultTable {
            margin: 0;
        }
    }
    
@media (max-width: 768px) {
    .scheme-container {
        display: block; /* Показываем canvas по умолчанию */
        width: 100%; /* Занимает всю ширину */
        height: 300px; /* Фиксированная высота для мобильной версии */
        margin-bottom: var(--spacing); /* Добавляем отступ снизу */
    }

    .content-container {
        display: block !important;
        height: auto;
    }

    .data-container {
        width: 100%;
        margin-bottom: var(--spacing);
    }

    #resultTable {
        margin: 0;
    }
}
    /* Стили для десктопной версии */
    @media (min-width: 769px) {
        .search-box {
            flex-direction: row;
        }

        .button-row {
            display: flex;
            gap: 10px;
        }

        .mobile-only {
            display: none;
        }
    }
    
.convert-button {
    background: linear-gradient(145deg, #4CAF50, #45a049);
    color: white;
    border: none;
    padding: 15px 20px;
    border-radius: 5px;
    cursor: pointer;
    font-size: 16px;
    margin-bottom: 15px;
    transition: background 0.3s ease, transform 0.2s ease;
    width: 100%; /* Кнопка на всю ширину */
    box-sizing: border-box; /* Учитываем padding в ширине */
}

.convert-button:hover {
    background: linear-gradient(145deg, #45a049, #4CAF50);
    transform: translateY(-2px);
}

.convert-button:active {
    transform: translateY(0);
}

/* Стили для таблицы */
#resultTable {
    width: 100%;
    border-collapse: separate;
    border-spacing: 0;
    margin-top: 10px;
    border-radius: 12px;
    overflow: hidden;
    box-shadow: 0 6px 16px rgba(0,0,0,0.1);
    animation: tableAppear 0.6s ease-out;
    background: white;
}

@keyframes tableAppear {
    from {
        opacity: 0;
        transform: translateY(20px);
    }
    to {
        opacity: 1;
        transform: translateY(0);
    }
}

#resultTable tr {
    animation: rowFadeIn 0.5s ease-out;
    animation-fill-mode: both;
}

@keyframes rowFadeIn {
    from {
        opacity: 0;
        transform: translateX(-20px);
    }
    to {
        opacity: 1;
        transform: translateX(0);
    }
}

#resultTable tr:nth-child(even) {
    background-color: #f8f9fa;
}

#resultTable td {
    padding: 14px 18px;
    border-bottom: 1px solid rgba(0,0,0,0.05);
    transition: all 0.3s ease;
    line-height: 1.4;
}

#resultTable td:first-child {
    font-weight: 500;
    color: #2c3e50;
    width: 30%;
    position: relative;
}

#resultTable td:first-child::after {
    content: '';
    position: absolute;
    right: 0;
    top: 50%;
    transform: translateY(-50%);
    height: 70%;
    width: 1px;
    background: rgba(0,0,0,0.05);
}

#resultTable td:last-child {
    color: #34495e;
}

/* --- Стили для кнопки копирования в таблице --- */

#resultTable td:last-child {
    position: relative;
    /* Добавляем отступ справа, чтобы текст не заезжал под кнопку */
    padding-right: 40px; 
}

/* Стили самой кнопки-иконки */
.copy-icon-button {
    display: none; /* Скрыта по умолчанию */
    position: absolute;
    top: 50%;
    right: 8px; /* Немного ближе к краю */
    transform: translateY(-50%);
    /* --- ИЗМЕНЕНИЕ: Зеленый градиент --- */
    background: linear-gradient(145deg, #4CAF50, #45a049);
    color: white;
    border: none;
    /* --- ИЗМЕНЕНИЕ: Уменьшенный размер --- */
    width: 24px;
    height: 24px;
    border-radius: 50%;
    cursor: pointer;
    /* --- ИЗМЕНЕНИЕ: Уменьшенный размер иконки --- */
    font-size: 12px;
    transition: all 0.2s ease;
    align-items: center;
    justify-content: center;
    box-shadow: 0 1px 3px rgba(0,0,0,0.15);
    z-index: 5; /* Чтобы кнопка была поверх содержимого */
}

/* Показываем кнопку при наведении на любую строку таблицы */
#resultTable tr:hover .copy-icon-button {
    display: flex; 
}

.copy-icon-button:hover {
    /* --- ИЗМЕНЕНИЕ: Зеленый градиент при наведении --- */
    background: linear-gradient(145deg, #45a049, #4CAF50);
    transform: translateY(-50%) scale(1.1);
    box-shadow: 0 3px 6px rgba(0,0,0,0.2);
}

.copy-icon-button:active {
    transform: translateY(-50%) scale(1);
}

#resultTable tr:hover {
    background-color: #f1f4f6 !important;
    transform: translateX(5px);
    transition: all 0.3s ease;
}

/* Стили для значений в таблице */
#resultTable td strong {
    font-weight: 500;
    color: #2c3e50;
    display: inline-block;
    transition: all 0.3s ease;
}



/* Стили для мобильной версии */
@media (max-width: 768px) {
    #resultTable td {
        padding: 12px 15px;
    }

    #resultTable td:first-child {
        width: 40%;
    }

    #resultTable {
        font-size: 14px;
    }
}

/* Эффект появления для всей таблицы */
.data-container {
    perspective: 1000px;
}

#resultTable {
    transform-origin: top center;
    animation: tableReveal 0.6s ease-out;
}

@keyframes tableReveal {
    from {
        opacity: 0;
        transform: rotateX(-10deg);
    }
    to {
        opacity: 1;
        transform: rotateX(0);
    }
}

   .map-buttons {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }

        .map-buttons button {
            display: flex;
            align-items: center;
            gap: 5px;
            padding: 10px 15px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            transition: background 0.3s ease, transform 0.2s ease;
        }

        .map-buttons button:hover {
            transform: translateY(-2px);
        }

        .map-buttons button:active {
            transform: translateY(0);
        }

        .map-buttons .yandex-map-button {
            background: linear-gradient(145deg, #FF4444, #CC0000);
            color: white;
        }

        .map-buttons .google-map-button {
            background: linear-gradient(145deg, #4285F4, #357ABD);
            color: white;
        }
        
            /* Стили для контейнера кнопок */
        .button-container {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }

        .button-container button {
            flex: 1; /* Равная ширина для всех кнопок */
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 5px;
            padding: 10px 15px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            transition: background 0.3s ease, transform 0.2s ease;
        }

        .button-container button:hover {
            transform: translateY(-2px);
        }

        .button-container button:active {
            transform: translateY(0);
        }

        .button-container .convert-button {
            background: linear-gradient(145deg, #4CAF50, #45a049);
            color: white;
        }

        .button-container .yandex-map-button {
            background: linear-gradient(145deg, #FF4444, #CC0000);
            color: white;
        }

        .button-container .google-map-button {
            background: linear-gradient(145deg, #4285F4, #357ABD);
            color: white;
        }
        
          #modalCoordinatesTable th:first-child,
        #modalCoordinatesTable td:first-child {
            width: 50px; /* Ширина колонки с номером */
            text-align: center; /* Выравнивание по центру */
        }
        
        /* Стили для модального окна поиска */
/* Стили для модального окна поиска */
.search-modal-container {
    display: flex;
    flex-direction: column;
    gap: 20px;
    padding: 20px;
    width: 400px; /* Фиксированная ширина контейнера */
    margin: 0 auto; /* Центрирование */
}

#rightNumberInput {
    width: 100%; /* Поле ввода занимает всю ширину контейнера */
    font-size: 18px;
    padding: 15px 20px;
    border: 2px solid var(--border-color);
    border-radius: 25px;
    transition: all 0.3s ease;
    text-align: center;
    box-shadow: inset 0 1px 3px rgba(0,0,0,0.1);
    box-sizing: border-box; /* Учитываем padding в общей ширине */
}

.search-right-button {
    width: 100%; /* Кнопка занимает всю ширину контейнера */
    padding: 15px 20px;
    border-radius: 25px;
    background: linear-gradient(145deg, #4CAF50, #45a049);
    color: white;
    border: none;
    font-size: 16px;
    cursor: pointer;
    transition: all 0.3s ease;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 10px;
    box-sizing: border-box; /* Учитываем padding в общей ширине */
}

#rightNumberInput:focus {
    outline: none;
    border-color: var(--primary-color);
    box-shadow: 0 0 0 3px rgba(33, 150, 243, 0.2);
    transform: scale(1.02);
}


.search-right-button:hover {
    transform: translateY(-2px);
    box-shadow: 0 6px 10px rgba(0, 0, 0, 0.3);
}

.search-right-button:active {
    transform: translateY(0);
    box-shadow: 0 3px 6px rgba(0, 0, 0, 0.2);
}

#rightSearchTable {
    width: 100%;
    margin-top: 20px;
    border-collapse: collapse;
    background: white;
    border-radius: 8px;
    overflow: hidden;
    box-shadow: 0 4px 6px rgba(0,0,0,0.1);
}

#rightSearchTable td {
    padding: 12px 15px;
    border-bottom: 1px solid #e0e0e0;
}

#rightSearchTable td:first-child {
    font-weight: 500;
    width: 30%;
    color: #2c3e50;
}

#rightSearchTable td:last-child {
    color: #34495e;
}


/* Стили для кнопки "Единое землепользование" */
.ez-button {
    background: linear-gradient(145deg, #4CAF50, #45a049);
    color: white;
    border: none;
    padding: 10px 20px; /* Уменьшим отступы для компактности */
    border-radius: 8px; /* Закругленные углы */
    cursor: pointer;
    font-size: 16px;
    transition: background 0.3s ease, transform 0.2s ease;
    display: inline-flex; /* Используем inline-flex для компактного размера */
    align-items: center;
    justify-content: center;
    gap: 8px; /* Расстояние между иконкой и текстом */
    box-shadow: 0 4px 6px rgba(0, 0, 0, 0.2);
        width: 300px; /* Фиксированная ширина */
}

.ez-button:hover {
    background: linear-gradient(145deg, #45a049, #4CAF50);
    transform: translateY(-2px);
    box-shadow: 0 6px 10px rgba(0, 0, 0, 0.3);
}

.ez-button:active {
    transform: translateY(0);
    box-shadow: 0 3px 6px rgba(0, 0, 0, 0.2);
}

.ez-button i {
    font-size: 16px; /* Уменьшим размер иконки для пропорциональности */
}

.scheme-button {
    background: linear-gradient(145deg, #3F51B5, #303F9F);
    color: white;
    border: none;
    padding: 15px 20px;
    border-radius: 5px;
    cursor: pointer;
    font-size: 16px;
    transition: background 0.3s ease, transform 0.2s ease;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 8px;
}

.scheme-button:hover {
    background: linear-gradient(145deg, #303F9F, #3F51B5);
    transform: translateY(-2px);
}

.scheme-button:active {
    transform: translateY(0);
}

.copy-coordinates-button {
    background: linear-gradient(145deg, #2196F3, #1976D2);
    color: white;
    border: none;
    width: 36px;
    height: 36px;
    border-radius: 50%;
    cursor: pointer;
    font-size: 16px;
    transition: background 0.3s ease, transform 0.2s ease;
    display: flex;
    align-items: center;
    justify-content: center;
    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
    margin: 0   auto; /* Центрируем кнопку в ячейке */
}

.copy-coordinates-button:hover {
    background: linear-gradient(145deg, #1976D2, #2196F3);
    transform: translateY(-2px);
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
}

.copy-coordinates-button:active {
    transform: translateY(0);
    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
}

/* Стили для заголовка таблицы */
#modalCoordinatesTable th {
    padding: 12px 15px;
    text-align: center;
    background-color: var(--secondary-color);
    font-weight: 600;
}

/* Убираем стандартные отступы и рамки у кнопки в заголовке */
#modalCoordinatesTable th button {
    margin: 0;
    padding: 0;
    border: none;
    outline: none;
}


/* Контейнер для поля ввода и иконки */
.input-container {
    position: relative;
    flex: 1; /* Занимает всё доступное пространство */
    margin-right: 10px; /* Отступ от кнопок */
}

/* Поле ввода */
#cadastralNumber {
    width: 100%; 
    font-size: 18px;
   
  padding: 15px 150px 15px 20px; 
    border: 2px solid var(--border-color);
    border-radius: 25px;
    transition: all 0.3s ease;
    text-align: center;
    box-shadow: inset 0 1px 3px rgba(0,0,0,0.1);
    box-sizing: border-box; 
}

/* Контейнер для иконки */
.icon-container {
    position: absolute;
    top: 50%;
    right: 10px; /* Отступ от правого края */
    transform: translateY(-50%); /* Центрируем по вертикали */
    cursor: pointer;
    padding: 8px;
    border-radius: 50%;
    transition: background 0.3s ease;
}

.icon-container:hover {
    background: rgba(0, 0, 0, 0.1); /* Легкий эффект при наведении */
}

/* Стили для иконки */
.site-icon {
    width: 24px; /* Размер иконки */
    height: 24px;
    transition: filter 0.3s ease;
}

.icon-container:hover .site-icon {
    filter: grayscale(0%); /* Цветная иконка при наведении */
}

.keyboard-key.insert {
    background: linear-gradient(145deg, #BF00FF, #BF00FF);
    color: white;
}

.keyboard-key.insert:hover {
    background: linear-gradient(145deg, #BF00FF, #BF00FF);
}

.keyboard-key.insert:active {
    background: linear-gradient(145deg, #E64A19, #FF9800);
}

/* --- Styling for Batch Cadastral Modal --- */
#batchCadastralModal .modal-content {
    max-width: 500px; /* Slightly wider for the textarea */
    text-align: left; /* Align text left for better readability */
    padding: 25px; /* More padding */
}

#batchCadastralModal h4 {
    margin-top: 0;
    margin-bottom: 10px;
    color: var(--primary-color);
    text-align: center;
    font-size: 20px;
}

#batchCadastralModal p {
    text-align: center;
    color: #666;
    font-size: 14px;
    margin-bottom: 20px;
}

#cadastralListInput {
    width: 100%; /* Take full width */
    box-sizing: border-box; /* Include padding/border in width */
    min-height: 150px; /* Minimum height */
    font-size: 15px;
    padding: 12px;
    border: 1px solid var(--border-color);
    border-radius: 8px;
    margin-bottom: 20px;
    resize: vertical; /* Allow vertical resizing */
    line-height: 1.5;
    font-family: Consolas, monospace; /* Monospace font for better alignment */
    background-color: #fdfdfd;
    box-shadow: inset 0 1px 3px rgba(0,0,0,0.05);
}

#cadastralListInput:focus {
    outline: none;
    border-color: var(--primary-color);
    box-shadow: inset 0 1px 3px rgba(0,0,0,0.05), 0 0 0 2px rgba(33, 150, 243, 0.2);
}

#batchCadastralModal .button-container-modal {
     display: flex;
     justify-content: center; /* Center the button */
     width: 100%;
     gap: 15px; /* Add gap between buttons */
}

/* Style for both export buttons */
#exportCsvButton, #exportExcelButton {
    background: linear-gradient(145deg, #4CAF50, #45a049); /* Default green */
    color: white;
    border: none;
    padding: 12px 14px;
    border-radius: 8px;
    cursor: pointer;
    font-size: 18px;
    font-weight: 500;
    transition: background 0.3s ease, transform 0.2s ease, box-shadow 0.3s ease;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    gap: 8px;
    box-shadow: 0 4px 8px rgba(0,0,0,0.1);
    line-height: 1;
    flex-grow: 0; /* Prevent buttons from growing */
    flex-shrink: 0; /* Prevent buttons from shrinking */
}

/* Specific style for Excel button */
#exportExcelButton {
    background: linear-gradient(145deg, #2196F3, #1976D2); /* Blue for Excel */
}


#exportCsvButton:hover {
    background: linear-gradient(145deg, #45a049, #4CAF50);
    transform: translateY(-2px);
    box-shadow: 0 6px 12px rgba(0,0,0,0.15);
}

#exportExcelButton:hover {
    background: linear-gradient(145deg, #1976D2, #2196F3);
    transform: translateY(-2px);
    box-shadow: 0 6px 12px rgba(0,0,0,0.15);
}


#exportCsvButton:active, #exportExcelButton:active {
    transform: translateY(0);
    box-shadow: 0 3px 6px rgba(0,0,0,0.1);
}

#exportCsvButton:disabled, #exportExcelButton:disabled {
    background: #ccc;
    cursor: not-allowed;
    transform: none;
    box-shadow: none;
}

/* Explicitly style the icons if needed */
#exportCsvButton i, #exportExcelButton i {
    font-size: 20px; /* Control icon size directly */
    margin: 0; /* Remove any potential default margins */
    line-height: 1; /* Ensure consistent line height */
}


.progress-bar {
    width: 100%;
    height: 10px; /* Height of the progress bar line */
    background-color: #e0e0e0; /* Background track color */
    border-radius: 5px; /* Rounded corners for the track */
    overflow: hidden; /* Keep the fill inside */
    box-shadow: inset 0 1px 2px rgba(0,0,0,0.1);
}

.progress-bar-fill {
    height: 100%;
    width: 0%; /* Start with 0% width */
    background-color: #2196F3; /* Progress fill color (adjust as needed) */
    /* Optional: Nice gradient */
    background-image: linear-gradient(45deg, rgba(255,255,255,.15) 25%, transparent 25%, transparent 50%, rgba(255,255,255,.15) 50%, rgba(255,255,255,.15) 75%, transparent 75%, transparent);
    background-size: 40px 40px;
    border-radius: 5px; /* Match parent's rounding */
    transition: width 0.4s ease-in-out; /* Smooth width transition */
    animation: progress-bar-stripes 1s linear infinite; /* Animated stripes */
}

button.scheme-convert-button {
    background: linear-gradient(145deg, #673AB7, #512DA8);
    color: white;
}
button.scheme-convert-button:hover {
    background: linear-gradient(145deg, #512DA8, #673AB7);
}


.warning-modal-container {
    text-align: center;
    padding: 10px;
}

.warning-icon {
    font-size: 48px;
    color: #FF9800;
    margin-bottom: 15px;
    animation: pulse 2s infinite;
}

.warning-title {
    font-size: 20px;
    font-weight: 600;
    margin-bottom: 10px;
    color: #333;
}

.warning-text {
    font-size: 15px;
    color: #666;
    margin-bottom: 25px;
    line-height: 1.5;
}

.warning-buttons {
    display: flex;
    justify-content: center;
    gap: 15px;
}

.btn-confirm {
    background: linear-gradient(145deg, #4CAF50, #45a049);
    color: white;
    border: none;
    padding: 10px 25px;
    border-radius: 25px;
    cursor: pointer;
    font-size: 16px;
    transition: transform 0.2s;
}

.btn-cancel {
    background: linear-gradient(145deg, #f44336, #d32f2f);
    color: white;
    border: none;
    padding: 10px 25px;
    border-radius: 25px;
    cursor: pointer;
    font-size: 16px;
    transition: transform 0.2s;
}

.btn-confirm:hover, .btn-cancel:hover {
    transform: scale(1.05);
    box-shadow: 0 4px 8px rgba(0,0,0,0.2);
}

/* Стили для новой иконки списка (левее иконки архива) */
.icon-container-list {
    position: absolute;
    top: 50%;
    right: 105px; 
    transform: translateY(-50%);
    cursor: pointer;
    padding: 8px;
    border-radius: 50%;
    transition: background 0.3s ease;
    z-index: 5;
}

.icon-container-list:hover {
    background: rgba(0, 0, 0, 0.1);
}

/* Стили для таблицы результатов поиска */
#addressResultsTable {
    width: 100%;
    border-collapse: collapse;
    margin-top: 10px;
}

#addressResultsTable th {
    background-color: var(--primary-color);
    color: white;
    padding: 12px;
    position: sticky;
    top: 0;
}

#addressResultsTable td {
    padding: 10px;
    border-bottom: 1px solid #eee;
    cursor: pointer;
    font-size: 14px;
}

#addressResultsTable tr:hover td {
    background-color: #e3f2fd; /* Подсветка при наведении */
    color: #1565c0;
}



@keyframes pulse {
    0% { transform: scale(1); opacity: 1; }
    50% { transform: scale(1.1); opacity: 0.8; }
    100% { transform: scale(1); opacity: 1; }
}

/* Animation for the stripes */
@keyframes progress-bar-stripes {
  from { background-position: 40px 0; }
  to { background-position: 0 0; }
}

/* Optional: Style for the text above the bar */
#progressBarContainer span {
    font-weight: 500;
}

/* Анимация для иконки списка */
.icon-container-list.pulse-animation {
    display: block !important;
    animation: popInIcon 0.6s cubic-bezier(0.68, -0.55, 0.265, 1.55) forwards;
}

/* Псевдо-элемент для волны (ripple effect) */
.icon-container-list.pulse-animation::after {
    content: '';
    position: absolute;
    top: 50%;
    left: 50%;
    width: 100%;
    height: 100%;
    transform: translate(-50%, -50%);
    border-radius: 50%;
    border: 2px solid #2196F3;
    opacity: 0;
    animation: rippleWave 1.5s ease-out 2; /* Проиграть 2 раза */
    pointer-events: none;
}

@keyframes popInIcon {
    0% { transform: translateY(-50%) scale(0); opacity: 0; }
    60% { transform: translateY(-50%) scale(1.2); opacity: 1; }
    100% { transform: translateY(-50%) scale(1); opacity: 1; }
}


@keyframes rippleWave {
    0% { width: 100%; height: 100%; opacity: 0.8; border-width: 2px; }
    100% { width: 300%; height: 300%; opacity: 0; border-width: 0px; }
}


.filter-tabs {
    display: flex;
    justify-content: space-between;
    gap: 10px;
    margin-bottom: 15px;
    margin-top: 5px;
    border-bottom: 1px solid #eee;
    padding-bottom: 10px;
}

.filter-tab {
    flex: 1; /* Растягиваем кнопки на всю ширину */
    background: #f5f5f5;
    border: none;
    border-radius: 8px;
    padding: 12px 0;
    cursor: pointer;
    font-size: 18px;
    color: #757575;
    transition: all 0.3s ease;
    display: flex;
    align-items: center;
    justify-content: center;
}

.filter-tab:hover {
    background: #e0e0e0;
    color: #333;
    transform: translateY(-2px);
}

/* Активное состояние кнопки */
.filter-tab.active {
    background: linear-gradient(145deg, #2196F3, #1976D2);
    color: white;
    box-shadow: 0 4px 8px rgba(33, 150, 243, 0.3);
    transform: translateY(0);
}

.address-toolbar {
    display: flex;
    gap: 10px;
    margin-bottom: 10px;
    margin-top: 10px;
}

.search-input-wrapper {
    position: relative;
    flex-grow: 1;
}

.search-input-wrapper i {
    position: absolute;
    left: 12px;
    top: 50%;
    transform: translateY(-50%);
    color: #999;
}

#addressFilterInput {
    width: 100%;
    padding: 10px 10px 10px 35px; /* Отступ слева для иконки */
    border: 1px solid var(--border-color);
    border-radius: 8px;
    font-size: 14px;
    box-sizing: border-box;
    transition: border-color 0.3s;
}

#addressFilterInput:focus {
    outline: none;
    border-color: var(--primary-color);
}

.tool-btn {
    width: 42px;
    height: 42px;
    border: none;
    background: #f5f5f5;
    border-radius: 8px;
    cursor: pointer;
    color: #555;
    font-size: 16px;
    transition: all 0.2s;
    flex-shrink: 0;
    display: flex;
    align-items: center;
    justify-content: center;
}

.tool-btn:hover {
    background: #e0e0e0;
    color: #333;
}

.tool-btn.active {
    background-color: #2ecc71;
    color: white;
    box-shadow: inset 0 3px 5px rgba(0,0,0,0.2); 
    border: 1px solid #27ae60; 
    transform: translateY(1px); 
}


.tool-btn.active:hover {
    background-color: #27ae60;
}



/* --- ОТКЛЮЧЕНИЕ  АНИМАЦИЙ --- */
*, *::before, *::after {
    transition: none !important;
    animation: none !important;
}

/* Убираем эффекты наведения, которые меняют размер */
button:hover, input:hover, .keyboard-key:hover, .tool-btn:hover {
    transform: none !important;
    box-shadow: none !important;
}

/* Убираем эффект ripple (волны) */
button:active::after {
    display: none !important;
}

/* Исправляем скрытие элементов, которые зависели от прозрачности */
.notification {
    opacity: 1 !important;
    display: none; /* Скрываем по умолчанию */
}
.notification.show {
    display: block !important; /* Показываем моментально */
}

/* Убираем пульсацию иконок */
.warning-icon, .pulse-animation {
    animation: none !important;
}


/* Стили для лоадера */
    .loading-overlay {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(255, 255, 255, 0.8);
        z-index: 2000;
        justify-content: center;
        align-items: center;
        backdrop-filter: blur(2px);
        animation: fadeIn 0.3s ease-out;
    }

    .loader-content {
        background: white;
        padding: 30px;
        border-radius: 15px;
        box-shadow: 0 10px 25px rgba(0,0,0,0.15);
        text-align: center;
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 20px;
        min-width: 250px;
    }

    .spinner-circle {
        width: 50px;
        height: 50px;
        border: 4px solid #f3f3f3;
        border-top: 4px solid var(--primary-color);
        border-radius: 50%;
        animation: spin 1s linear infinite;
    }

    .loader-text {
        font-size: 18px;
        font-weight: 500;
        color: #333;
    }

   .btn-cancel-search {
      
        width: auto !important; 
        height: auto !important;
        border-radius: 8px !important; 
        
        /* Дизайн кнопки */
        background: linear-gradient(145deg, #FF5252, #F44336);
        color: white;
        border: none;
        padding: 10px 30px; 
        margin-top: 15px;
        cursor: pointer;
        font-size: 16px;
        font-weight: 500;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        gap: 8px;
        box-shadow: 0 4px 6px rgba(0,0,0,0.2);
        transition: all 0.2s ease;
    }

    .btn-cancel-search:hover {
        background: linear-gradient(145deg, #F44336, #D32F2F);
        transform: translateY(-2px);
        box-shadow: 0 6px 12px rgba(244, 67, 54, 0.3);
    }

    .btn-cancel-search:active {
        transform: translateY(0);
    }

    @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
    }

.deep-search-icon {
    position: absolute;
    right: 10px;
    top: 50%;
    transform: translateY(-50%);
    width: 20px;
    height: 20px;
    cursor: pointer;
    opacity: 0.6;
    transition: opacity 0.2s;
}

.deep-search-icon:hover {
    opacity: 1;
}

#addressFilterInput {
    padding-right: 40px; 
}

.status-bar {
    padding: 10px;
    text-align: right;
    font-size: 14px;
    color: #666;
    border-top: 1px solid #eee;
    margin-top: 5px;
    font-weight: 500;
}


#addressListModal .modal-content {
    max-width: 1200px !important; 
    width: 95% !important;       
}

.print-container {
    display: flex;
    flex-direction: row;
    width: 100%;
    height: 100%;
    font-family: 'Times New Roman', Times, serif;
    font-size: 10pt;
}

.print-left-column {
    flex: 0 0 45%;
    padding-right: 15px;
    box-sizing: border-box;
}

.print-right-column {
    flex: 0 0 55%;
    display: flex;
    align-items: center;
    justify-content: center;
}

.print-right-column img {
    max-width: 100%;
    max-height: 100%;
    object-fit: contain;
}

.print-container table {
    width: 100%;
    border-collapse: collapse;
    font-size: 9pt;
    box-shadow: none;
    border: 1px solid #333;
}

.print-container th,
.print-container td {
    border: 1px solid #333;
    padding: 4px 6px;
    text-align: left;
    vertical-align: top;
    word-break: break-word;
}

.print-container td:first-child {
    font-weight: bold;
    width: 35%;
}


.icon-container-print {
    position: absolute;
    top: 50%;
    right: 60px; 
    transform: translateY(-50%);
    cursor: pointer;
    padding: 8px;
    border-radius: 50%;
    transition: background 0.3s ease;
    z-index: 5;
}

.icon-container-print:hover {
    background: rgba(0, 0, 0, 0.1);
}

.icon-container-print:hover .site-icon {
    filter: grayscale(0%);
}

#mskSelectionModal .modal-content {
    max-width: 500px;
    text-align: left;
}

.msk-list {
    display: flex;
    flex-direction: column;
    gap: 10px;
    max-height: 400px;
    overflow-y: auto;
    padding-right: 5px;
    margin-top: 15px;
}

.msk-list-item {
    padding: 12px 16px;
    background: #f8fafc;
    border: 1px solid var(--border-color);
    border-radius: 8px;
    cursor: pointer;
    transition: all 0.2s ease;
    font-size: 15px;
    display: flex;
    align-items: center;
    gap: 10px;
    color: var(--text-color);
}

.msk-list-item:hover {
    background: #e0eaff;
    border-color: var(--primary-color);
    transform: translateX(2px);
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}

.msk-list-item i {
    color: var(--primary-color);
}

.msk-region-title {
    font-size: 14px;
    color: #666;
    margin-bottom: 10px;
    border-bottom: 1px solid var(--border-color);
    padding-bottom: 5px;
}


</style>

</head>
<body>
     <div class="search-container">

<div class="search-box">
    <div class="input-container">
        <input type="text" id="cadastralNumber" placeholder="Кадастровый номер или адрес">
           <div class="icon-container-print" onclick="copyAndOpenOt()">
            <img src="img/print.png" alt="Print" class="site-icon">
        </div>
         <div class="icon-container-list" id="addressListIcon" onclick="isAddressIconAnimationDisabled = true; openAddressModal()" style="display: none;">
    <img src="img/location.png" alt="List" class="site-icon">
</div>

        <!-- Иконка внутри поля ввода -->
        <div class="icon-container" onclick="fetchDataFromArchive()">
            <img src="img/his.png" alt="Open Site" class="site-icon">
        </div>
    </div>
    <div class="button-row">
        <button class="search-button" onclick="fetchData()">
            <i class="fas fa-search"></i>
        </button>
        <button class="coordinates-button" onclick="showCoordinates()">
            <i class="fas fa-compass"></i>
        </button>
        <button class="map-button" onclick="openMap()">
            <i class="fas fa-map"></i>
        </button>
       <button class="yandex-map-button" onclick="convertToMskAndOpenScheme()">
     <i class="fas fa-map-marked-alt"></i>
</button>
        <button id="mobileKeyboardButton" class="keyboard-button mobile-only">
            <i class="fas fa-keyboard"></i>
        </button>
    </div>
</div>

<div class="virtual-keyboard" id="virtualKeyboard">
    <div class="keyboard-row">
        <div class="keyboard-key" data-key="1">1</div>
        <div class="keyboard-key" data-key="2">2</div>
        <div class="keyboard-key" data-key="3">3</div>
    </div>
    <div class="keyboard-row">
        <div class="keyboard-key" data-key="4">4</div>
        <div class="keyboard-key" data-key="5">5</div>
        <div class="keyboard-key" data-key="6">6</div>
    </div>
    <div class="keyboard-row">
        <div class="keyboard-key" data-key="7">7</div>
        <div class="keyboard-key" data-key="8">8</div>
        <div class="keyboard-key" data-key="9">9</div>
    </div>
    <div class="keyboard-row">
        <div class="keyboard-key" data-key="0">0</div>
          <div class="keyboard-key insert">Ins</div> 
        <div class="keyboard-key clear">C</div>
        <div class="keyboard-key enter" onclick="handleEnter()">Enter</div>

    </div>
</div>
<div class="content-container">
    <div class="data-container">
        
    <div id="archiveInfo" style="display: none; text-align: center; margin-bottom: 15px; padding: 8px; border-radius: 5px; background-color: #ffebee;">
    <!-- Сюда будет вставляться иконка и текст с датой -->
</div>

    
        <table id="resultTable" style="display:none;">
            <tbody></tbody>
        </table>
        <div id="ezLinkContainer" style="display: none; margin-top: 20px;">
            <button id="ezLink" class="ez-button" type="button">
                <i class="fas fa-link"></i> Единое землепользование
            </button>
        </div>
    </div>
   <div class="scheme-container">
 <div class="toggle-container">
    <input type="checkbox" id="distanceToggle" class="toggle" onclick="toggleDistanceLabels()">

</div>

    <canvas id="schemeCanvas"></canvas>
</div>
</div>


<!-- Модальное окно для координат -->
<div id="coordinatesModal" class="modal">
    <div class="modal-content">
        <!-- ВСТАВЬТЕ ЭТУ СТРОКУ ПРЯМО СЮДА -->
        <span class="close-modal">×</span>

        <!-- Контейнер для кнопок -->
        <div class="button-container">
            <button class="yandex-map-button" onclick="openYandexMaps()">
                <i class="fas fa-map-marked-alt"></i> Yandex
            </button>
   <button class="scheme-convert-button" onclick="handleEditorButtonClick()">
    <i class="fas fa-layer-group"></i> ГеоРедактор
</button>
            <button class="convert-button" onclick="convertCoordinates()">
                <i class="fas fa-exchange-alt"></i> Конвертация в МСК
            </button>
            <button class="scheme-button" onclick="openSchemeMap()">
                <i class="fas fa-globe"></i> Карта
            </button>
        </div>

        <!-- Таблица с координатами -->
        <table id="modalCoordinatesTable">
            <thead>
                <tr>
                    <th>
                        <button class="copy-coordinates-button" onclick="copyCoordinates()">
                            <i class="fas fa-copy"></i>
                        </button>
                    </th>
                    <th>X</th>
                    <th>Y</th>
                </tr>
            </thead>
            <tbody></tbody>
        </table>
    </div>
</div>




<!-- Обновленное модальное окно для поиска по номеру права -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <span class="close-modal">×</span>
        <div class="search-modal-container">
            <input type="text" id="rightNumberInput" placeholder="Введите текст">
            <button class="search-right-button">
                <i class="fas fa-search"></i>
                Поиск по номеру права
            </button>
            <table id="rightSearchTable" style="display: none;">
                <tbody>
                    <tr><td>Номер регистрации права:</td><td id="rightNumber"></td></tr>
                    <tr><td>Кадастровый номер:</td><td id="cadastralNumberFound"></td></tr>
                    <tr><td>Адрес:</td><td id="addressFound"></td></tr>
                </tbody>
            </table>
        </div>
    </div>
</div>


<div id="batchCadastralModal" class="modal">
    <div class="modal-content">
        <span class="close-modal" onclick="closeSpecificModal('batchCadastralModal')">×</span>
        <h4>Запрос данных по списку</h4>
        
        <!-- НАЧАЛО ИЗМЕНЕНИЙ: Добавлен селектор типа объектов -->
        <div style="margin-bottom: 20px;">
            <label for="searchTypeSelector" style="display: block; margin-bottom: 5px; font-weight: 500; color: #333;">Тип объектов в списке:</label>
            <select id="searchTypeSelector" style="width: 100%; padding: 10px; border-radius: 8px; border: 1px solid var(--border-color); font-size: 15px; background-color: #fdfdfd;">
                <option value="1" selected>Кадастровый номер (объекты)</option>
                <option value="5">ЗОУИТ</option>
                <option value="7">Территориальные зоны</option>
            </select>
        </div>
        <p>Введите кадастровые номера (до 100), каждый с новой строки</p>
        <textarea id="cadastralListInput" rows="10" placeholder=""></textarea>
<div style="margin: 15px 0; text-align: center;">
    <input type="checkbox" id="linkOksCheckbox" style="vertical-align: middle;">
    <label for="linkOksCheckbox" style="vertical-align: middle; cursor: pointer; user-select: none;">Привязка ОКС к ЗУ</label>
</div>
        <!-- Progress Bar Container -->
        <div id="progressBarContainer" style="display: none; margin-bottom: 20px;">
            <div style="text-align: center; font-size: 14px; margin-bottom: 5px; color: #555;">
                Обработка: <span id="progressBarText">0%</span>
            </div>
            <div class="progress-bar">
                <div class="progress-bar-fill" id="progressBarFill"></div>
            </div>
        </div>

        <!-- Button Container (for centering) -->
        <div class="button-container-modal">
             <!-- Icon-only button with title for tooltip -->
            <button id="exportCsvButton" onclick="exportToCsv()" title="Экспорт в CSV">
                <i class="fas fa-spinner fa-spin" style="display: none;"></i> <!-- Spinner Icon -->
                <i class="fas fa-file-csv"></i> <!-- Main CSV Icon -->
            </button>
             <!-- New Excel Export Button -->
            <button id="exportExcelButton" onclick="exportToExcel()" title="Экспорт в XLSX">
                 <i class="fas fa-spinner fa-spin" style="display: none;"></i> <!-- Spinner Icon -->
                <i class="fas fa-file-excel"></i> <!-- Main Excel Icon -->
            </button>
        </div>
    </div> <!-- End modal-content -->
</div> <!-- End batchCadastralModal -->


<div id="offsetWarningModal" class="modal">
    <div class="modal-content" style="max-width: 450px;">
        <div class="warning-modal-container">
            <div class="warning-icon">
                <i class="fas fa-exclamation-triangle"></i>
            </div>
            <div class="warning-title">Внимание!</div>
            <div class="warning-text">
                Для данного региона не настроены параметры смещения (X/Y). 
                <br><br>
                Координаты будут сконвертированы, но объект может отобразиться со сдвигом или в неверном месте на схеме.
                <br><br>
                Продолжить?
            </div>
            <div class="warning-buttons">
                <button class="btn-cancel" onclick="closeSpecificModal('offsetWarningModal')">Отмена</button>
                <button class="btn-confirm" onclick="proceedWithSchemeConversion()">Продолжить</button>
            </div>
        </div>
    </div>
</div>


<!-- Модальное окно результатов поиска по адресу -->
<div id="addressListModal" class="modal">
    <div class="modal-content" style="max-width: 800px;">
        <span class="close-modal" onclick="closeSpecificModal('addressListModal'); triggerListIconAnimation();">×</span>
     
        <!-- ПАНЕЛЬ ИНСТРУМЕНТОВ -->
        <div class="address-toolbar">
           <div class="search-input-wrapper">
    <i class="fas fa-search"></i>
    <input type="text" id="addressFilterInput" placeholder="Быстрый фильтр" oninput="filterAddressListByInput(this.value)">
    <img src="img/det.png" class="deep-search-icon" onclick="performDeepSearch()" title="Поиск по содержимому">
</div>
        
            <button class="tool-btn" id="refineBtn" onclick="refineAddressList()" title="Уточнить (строгое совпадение)">
                <i class="fas fa-filter"></i>
            </button>
            
            <button class="tool-btn" onclick="copyRawJson()" title="Копировать JSON">
                <i class="fas fa-code"></i>
            </button>
            
            <!-- ИСПРАВЛЕНИЕ: Кнопка перенесена ВНУТРЬ address-toolbar -->
            <button class="tool-btn" onclick="copyTableData()" title="Копировать таблицу">
                <i class="fas fa-table"></i>
            </button>
        </div> 
        <!-- Закрываем toolbar здесь, а не раньше -->

      

        <div class="filter-tabs">
            <button class="filter-tab" onclick="filterAddressList(this, 'Земельные участки')" title="Земельные участки">
                <i class="fas fa-layer-group"></i>
            </button>
            <button class="filter-tab" onclick="filterAddressList(this, 'Здания')" title="Здания">
                <i class="far fa-building"></i>
            </button>
            <button class="filter-tab" onclick="filterAddressList(this, 'Сооружения')" title="Сооружения">
                <i class="fas fa-industry"></i>
            </button>
            <button class="filter-tab" onclick="filterAddressList(this, 'Помещения')" title="Помещения">
                <i class="fas fa-door-open"></i>
            </button>
        </div>

        <div style="height: 60vh; overflow-y: auto; border: 1px solid #eee; border-radius: 4px;">
    <table id="addressResultsTable">
        <thead>
            <tr>
                <th>Тип</th>
                <th>Кадастровый номер</th>
                <th>Адрес</th>
            </tr>
        </thead>
        <tbody></tbody>
    </table>
</div>
<div id="addressListCount" class="status-bar">Найдено записей: 0</div>
    </div>
</div>

<div id="loadingOverlay" class="loading-overlay">
    <div class="loader-content">
        <div class="spinner-circle"></div>
        <div id="loaderText" class="loader-text">Поиск данных...</div>
        <button class="btn-cancel-search" onclick="cancelCurrentSearch()">
            <i class="fas fa-times"></i> Отмена
        </button>
    </div>
</div>

    <div id="notification-container"></div>
    
<div id="mskSelectionModal" class="modal">
    <div class="modal-content">
        <span class="close-modal" onclick="closeSpecificModal('mskSelectionModal')">×</span>
        <h4 style="margin-top: 0; color: var(--primary-color);"><i class="fas fa-globe"></i> Выбор системы координат</h4>
        <div class="msk-region-title">Не удалось определить зону автоматически. Выберите подходящую МСК для региона <span id="mskRegionDisplay" style="font-weight: bold; color: #333;"></span>:</div>
        <div id="mskListContainer" class="msk-list">
            <!-- Список генерируется через JS -->
        </div>
    </div>
</div>

      
    <script>
        
          const SUPABASE_URL = 'https://vznsatvyikahngdfvqho.supabase.co';
    const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InZ6bnNhdHZ5aWthaG5nZGZ2cWhvIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDU0MjM3MDMsImV4cCI6MjA2MDk5OTcwM30.FJmk0lgIjqvcdV7p6C0riaxqS9QWKAuIHDZtkMYMJe4';
    

    let supabaseClient = null;
    if (typeof supabase !== 'undefined') {
        const { createClient } = supabase;
        supabaseClient = createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
    }
let currentCoords = [];
let showDistanceLabels = false; // Добавляем флаг для состояния "глаза"
let schemeParams = {};
let useVercelProxyMode = false;
let pendingTargetSystem = null;
let isAddressIconAnimationDisabled = false; 
const isProxyFallbackEnabled = false;
let lastRawJsonResponse = null; 
let originalAddressSearchResults = []; 
let isRefineFilterActive = false;   
let searchAbortController = null;
let userSelectedMsk = null; 

let lastSuccessfulZoneType = 5;
// Список регионов с 7 знаками после второго двоеточия
//const sevenDigitsRegions = ['24','63', '66', '77', '78','91'];

let lastAddressSearchResults = []; // Хранит последний ответ поиска по адресу

// Список регионов с 6 знаками после второго двоеточия (только "16")
const sixDigitsRegions = ['02', '03', '04', '05', '08', '15', '16', '18', '19', '21', '22', '25', '26', '28', '30', '33', '34', '37', '38', '39', '40', '43', '44', '45', '46', '54', '55', '73', '75', '76', '91', '92'];
let isNspdDirectDown = false;

// Проверка корректности кадастрового номера
function isValidCadastralNumber(text) {
    const firstTwoDigits = text.slice(0, 2);
    const isSixDigits = sixDigitsRegions.includes(firstTwoDigits);
    const digitsAfterSecondColon = isSixDigits ? 6 : 7;

    // Регулярное выражение для проверки кадастрового номера
    const pattern = new RegExp(`^\\d{2}:\\d{2}:\\d{${digitsAfterSecondColon}}:\\d+$`);
    return pattern.test(text);
}

function showLoader(text = 'Поиск данных...') {
    const overlay = document.getElementById('loadingOverlay');
    const textEl = document.getElementById('loaderText');
    if (overlay && textEl) {
        textEl.textContent = text;
        overlay.style.display = 'flex';
    }
    
    // Создаем новый контроллер для отмены
    if (searchAbortController) {
        searchAbortController.abort(); // Отменяем предыдущий, если завис
    }
    searchAbortController = new AbortController();
    return searchAbortController.signal;
}

function hideLoader() {
    const overlay = document.getElementById('loadingOverlay');
    if (overlay) {
        overlay.style.display = 'none';
    }
    searchAbortController = null;
}

function cancelCurrentSearch() {
    if (searchAbortController) {
        searchAbortController.abort();
        searchAbortController = null;
        hideLoader();
        showNotification('Поиск отменен пользователем', 'info');
    }
}


async function fetchZoneByRegistryNumber(zoneNumber) {
    // Определяем порядок запросов на основе последнего успешного типа
    const searchOrder = lastSuccessfulZoneType === 5 ? [5, 7] : [7, 5];
    
    for (const searchType of searchOrder) {
        const path = `/api/geoportal/v2/search/geoportal?query=${encodeURIComponent(zoneNumber)}&thematicSearchId=${searchType}`;
        
        try {
            const response = await fetchWithFallback(path);
            
            if (response.status === 204) {
                continue; // Не найдено, пробуем следующий тип
            }
            
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            
            const data = await response.json();
            
            if (data.data && data.data.features && data.data.features.length > 0) {
                // Успешно нашли, обновляем приоритет для следующего поиска
                lastSuccessfulZoneType = searchType;
                return { data, searchType };
            }
        } catch (error) {
            console.error(`Ошибка при запросе зоны с thematicSearchId=${searchType}:`, error);
            continue; // Пробуем следующий тип
        }
    }
    
    // Ничего не нашли ни в ЗОУИТ, ни в терр.зонах
    return null;
}


// --- НОВАЯ ФУНКЦИЯ: Умный поиск МСК ---
function identifyMskSystem(text) {
    if (!text) return null;
    
    let mskCode = null;
    let lookupText = text;

    // ХАК: Если это номер зоны (например 16:03-6.1857), превращаем его в фейковый КН (16:03:000000:1),
    // чтобы MskFinder смог определить район.
    const zoneMatch = text.match(/^(\d{2})[:\.](\d{2})[-]/);
    if (zoneMatch) {
        // Превращаем "16:03-" в "16:03:000000:1" для поиска
        lookupText = `${zoneMatch[1]}:${zoneMatch[2]}:000000:1`;
    } else if (/^\d{2}:\d{2}$/.test(text)) {
        // Если введен просто квартал "16:03"
        lookupText = `${text}:000000:1`;
    }

    // 1. Попытка через MskFinder
    if (typeof MskFinder !== 'undefined') {
        mskCode = MskFinder.findMskCode(lookupText);
    }

    // 2. Если код найден, ищем систему в справочнике
    if (mskCode) {
        return COORDINATE_SYSTEMS.find(s => 
            s.value === mskCode || 
            s.text === mskCode || 
            s.text.includes(`МСК-${mskCode}`) || 
            s.text.includes(`МСК ${mskCode}`)
        );
    }

    return null;
}



function displayZoneData(feature, searchType) {
    const properties = feature.properties;
    const options = properties.options || {};
    const geometry = feature.geometry;
    
    const tableBody = document.querySelector('#resultTable tbody');
    tableBody.innerHTML = '';
    
    const zoneTypeName = searchType === 5 ? 'ЗОУИТ' : 'Территориальная зона';
    const categoryName = properties.categoryName || zoneTypeName;
    
    // Определяем МСК для отображения
   const zoneNumber = options.reg_numb_border || properties.descr;
    
    let mskName = 'Не определена (выберите при конвертации)';
    
    if (userSelectedMsk) {
        mskName = `${userSelectedMsk.text} (выбрана вручную)`;
    } else {
        const mskSystem = identifyMskSystem(zoneNumber);
        if (mskSystem) {
            mskName = mskSystem.text;
        }
    }

    const data = [
        { field: 'Категория', value: categoryName },
        { field: 'Реестровый номер', value: zoneNumber },
        { field: 'Кадастровый округ', value: options.cadastral_district },
        { field: 'Тип зоны', value: options.type_zone },
        { field: 'Наименование', value: options.name_by_doc },
        { field: 'Дата регистрации', value: formatDate(options.registration_date) },
        { 
            field: 'Ограничения', 
            value: options.content_restrict_encumbrances ? 
                   options.content_restrict_encumbrances.replace(/(\r\n|\n|\r)/gm, " ").trim() : null
        },
        { 
            field: 'Документ-основание', 
            value: [
                options.legal_act_document_name,
                options.legal_act_document_number ? `№${options.legal_act_document_number}` : '',
                options.legal_act_document_date ? `от ${options.legal_act_document_date}` : ''
            ].filter(Boolean).join(' ') || null
        },
        { field: 'Орган, выдавший документ', value: options.legal_act_document_issuer },
        { field: 'Дата обновления', value: formatDate(properties.systemInfo?.updated) },
        { field: 'Дата внесения', value: formatDate(properties.systemInfo?.inserted) },
        // ДОБАВЛЕНА СТРОКА С МСК
        { field: 'Система координат', value: mskName } 
    ];
    
    const filteredData = data.filter(item => {
        const value = typeof item.value === 'function' ? item.value() : item.value;
        return value !== null && value !== undefined && value !== '' && value !== '-';
    });
    
    filteredData.forEach(row => {
        const tr = document.createElement('tr');
        const value = typeof row.value === 'function' ? row.value() : row.value;
        
        tr.innerHTML = `<td>${row.field}</td>
                        <td>
                            <strong>${value}</strong>
                            <button class="copy-icon-button" onclick="copyRowContent(this)">
                                <i class="fas fa-copy"></i>
                            </button>
                        </td>`;
        
        tableBody.appendChild(tr);
    });
    
    // Обрабатываем геометрию и координаты
    if (geometry && geometry.coordinates && geometry.coordinates.length > 0) {
        currentCoords = geometry.coordinates;
        
        if (geometry.type !== "Point") {
            document.querySelector('.content-container').style.display = 'grid';
            document.querySelector('.scheme-container').style.display = 'block';
            setTimeout(() => drawScheme(), 0);
        } else {
            document.querySelector('.content-container').style.display = 'block';
            document.querySelector('.scheme-container').style.display = 'none';
            clearCanvas();
        }
    } else {
        document.querySelector('.content-container').style.display = 'block';
        document.querySelector('.scheme-container').style.display = 'none';
        clearCanvas();
    }
    
    document.getElementById('resultTable').style.display = 'table';
}


function isZoneNumber(text) {
  
    const pattern = /^\d{2}[.:]\d{2}-\d+\.\d+$/;
    return pattern.test(text.trim());
}


function normalizeRegistryZoneNumber(text) {

    return text.trim().replace(',', '.');
}


function isRegistryZoneNumber(text) {
   
    const pattern = /^\d{2}:\d{2}-\d+[.,]\d+$/; 
    return pattern.test(text.trim());
}

function extractDataForZoneCsv(options, properties) {
    // --- ИЗМЕНЕНИЕ: Дата legal_act_document_date используется напрямую, без formatDate ---
    const legalActInfo = [
        options.legal_act_document_name,
        options.legal_act_document_number ? `№${options.legal_act_document_number}` : '',
        options.legal_act_document_date ? `от ${options.legal_act_document_date}` : ''
    ].filter(Boolean).join(' ');

    return {
        'Номер зоны': properties.descr || null,
        'Тип объекта': properties.categoryName || 'Зона',
        'Тип зоны': options.type_zone || null,
        'Наименование объекта': options.name_by_doc || null,
        'Дата регистрации': formatDate(options.registration_date), // Эта дата в ISO, оставляем formatDate
        'Ограничения': (options.content_restrict_encumbrances || '').replace(/(\r\n|\n|\r)/gm, " ").trim(),
        'Документ-основание': legalActInfo,
        'Орган, выдавший документ': options.legal_act_document_issuer || null,
        'Дата обновления': formatDate(properties.systemInfo?.updated) || null
    };
}


// --- ЗАМЕНИТЕ СТАРУЮ ФУНКЦИЮ НА ЭТУ ---
function extractDataForTerritorialZoneCsv(options, properties) {
    // --- ИЗМЕНЕНИЕ: Дата legal_act_document_date используется напрямую, без formatDate ---
    const legalActInfo = [
        options.legal_act_document_name,
        options.legal_act_document_number ? `№${options.legal_act_document_number}` : '',
        options.legal_act_document_date ? `от ${options.legal_act_document_date}` : ''
    ].filter(Boolean).join(' ');

    return {
        'Номер зоны': properties.descr || null,
        'Тип объекта': properties.categoryName || 'Территориальная зона',
        'Тип зоны по ПЗЗ': options.type_zone || null,
        'Наименование по ПЗЗ': options.name_by_doc || null,
        'Дата регистрации': formatDate(options.registration_date), // Эта дата в ISO, оставляем formatDate
        'Разрешенное использование': (options.permitted_uses_name || '').replace(/(\r\n|\n|\r)/gm, " ").trim(),
        'Документ-основание': legalActInfo,
        'Орган, утвердивший ПЗЗ': options.legal_act_document_issuer || null,
        'Дата обновления': formatDate(properties.systemInfo?.updated) || null
    };
}


async function fetchSingleTerritorialZoneData(zoneNum) {
    const path = `/api/geoportal/v2/search/geoportal?query=${encodeURIComponent(zoneNum)}&thematicSearchId=7`;
    
    // Убираем try...catch
    const response = await fetchWithFallback(path);

    if (response.status === 204) {
        return { 'Номер зоны': zoneNum, 'Статус': 'Не найдена' };
    }
    
    const data = await response.json();

    if (data.data && data.data.features.length > 0) {
        const feature = data.data.features[0];
        return extractDataForTerritorialZoneCsv(feature.properties.options, feature.properties);
    } else {
        return { 'Номер зоны': zoneNum, 'Статус': 'Не найдена' };
    }
}


// Новая функция для отрисовки дополнительного объекта на холсте БЕЗ его очистки
function drawAdditionalObjectOnScheme(geometry, color) {
    const canvas = document.getElementById('schemeCanvas');
    const ctx = canvas.getContext('2d');

    // Проверяем, есть ли сохраненные параметры масштабирования
    if (!schemeParams.scale) {
        showNotification('Сначала нужно отобразить основную схему', 'error');
        return;
    }

    ctx.lineWidth = 2;
    ctx.strokeStyle = color;
    // Создаем полупрозрачный цвет для заливки из основного цвета
    const fillColor = color + '4D'; // Добавляем прозрачность (например, 30% -> 4D в hex)
    ctx.fillStyle = fillColor;


    // Функция для отрисовки одного контура (полигона или линии)
const drawLineContour = (coords) => {
    ctx.beginPath();
    coords.forEach((coord, index) => {
        const x = schemeParams.offsetX + (coord[0] - schemeParams.minX) * schemeParams.scale;
        const y = canvas.height - (schemeParams.offsetY + (coord[1] - schemeParams.minY) * schemeParams.scale);
        if (index === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
    });
    ctx.stroke();
};

const drawPolygonContour = (rings) => {
    ctx.beginPath();
    rings.forEach(ring => {
        ring.forEach((coord, index) => {
            const x = schemeParams.offsetX + (coord[0] - schemeParams.minX) * schemeParams.scale;
            const y = canvas.height - (schemeParams.offsetY + (coord[1] - schemeParams.minY) * schemeParams.scale);
            if (index === 0) ctx.moveTo(x, y);
            else ctx.lineTo(x, y);
        });
        ctx.closePath();
    });
    ctx.stroke();
    ctx.fill('evenodd');
};

const { type, coordinates } = geometry;

if (type === "Point") {
    showNotification('Объект без координат', 'warning');
    return;
}

if (type === "Polygon") {
    drawPolygonContour(coordinates);
} else if (type === "MultiPolygon") {
    // Каждый полигон отдельно!
    coordinates.forEach(polygon => {
        drawPolygonContour(polygon);
    });
} else if (type === "LineString") {
    drawLineContour(coordinates);
} else if (type === "MultiLineString") {
    coordinates.forEach(line => drawLineContour(line));
}

 
}


async function fetchAndDrawLinkedObject(cadNum) {
    if (!cadNum) return;
    //  showNotification(`Загрузка данных для ${cadNum}...`, 'info');
    const path = `/api/geoportal/v2/search/geoportal?thematicSearchId=1&query=${encodeURIComponent(cadNum)}`;
    try {
        const response = await fetchWithFallback(path); // ИСПОЛЬЗУЕМ FALLBACK
        if (!response.ok) throw new Error('Network response was not ok');
        const data = await response.json();

        if (data.data.features.length > 0) {
            const feature = data.data.features[0];
            
            // --- НАЧАЛО ИЗМЕНЕНИЙ ---
            if (feature.geometry) {
                // Сначала проверяем, является ли геометрия точкой
                if (feature.geometry.type === "Point") {
                    showNotification('Объект без координат', 'warning');
                    return; // Прекращаем выполнение, так как точку рисовать не нужно
                }

                // Для других типов геометрии проверяем наличие координат
                if (feature.geometry.coordinates && feature.geometry.coordinates.length > 0) {
                    // Рисуем полученную геометрию на существующем холсте
                    drawAdditionalObjectOnScheme(feature.geometry, '#FF5722'); // Яркий оранжевый цвет для связанного объекта
              //      showNotification(`Объект ${cadNum} отображен на схеме`, 'success');
                } else {
                    showNotification('Связанный объект без координат', 'warning');
                }
            } else {
                // Если у объекта в принципе отсутствует геометрия
                showNotification('Связанный объект без координат', 'warning');
            }
            // --- КОНЕЦ ИЗМЕНЕНИЙ ---

        } else {
            showNotification(`Данные по связанному объекту ${cadNum} не найдены`, 'error');
        }
    } catch (error) {
        console.error(`Ошибка при загрузке связанного объекта ${cadNum}:`, error);
        showNotification('Ошибка при загрузке связанного объекта', 'error');
    }
}
// Новая функция для отрисовки дополнительного объекта на холсте БЕЗ его очистки
function drawAdditionalObjectOnScheme(geometry, color) {
    const canvas = document.getElementById('schemeCanvas');
    const ctx = canvas.getContext('2d');

    // Проверяем, есть ли сохраненные параметры масштабирования
    if (!schemeParams.scale) {
        showNotification('Сначала нужно отобразить основную схему', 'error');
        return;
    }

    ctx.lineWidth = 2;
    ctx.strokeStyle = color;
    // Создаем полупрозрачный цвет для заливки из основного цвета
    const fillColor = color + '4D'; // Добавляем прозрачность (например, 30% -> 4D в hex)
    ctx.fillStyle = fillColor;


    // Функция для отрисовки одного контура (полигона или линии)
    const drawContour = (coords, isPolygon) => {
        ctx.beginPath();
        coords.forEach((coord, index) => {
            // Используем сохраненные параметры масштаба и смещения
            const x = schemeParams.offsetX + (coord[0] - schemeParams.minX) * schemeParams.scale;
            const y = canvas.height - (schemeParams.offsetY + (coord[1] - schemeParams.minY) * schemeParams.scale);
            if (index === 0) {
                ctx.moveTo(x, y);
            } else {
                ctx.lineTo(x, y);
            }
        });
        if (isPolygon) {
            ctx.closePath();
            ctx.stroke();
            ctx.fill();
        } else {
            ctx.stroke();
        }
    };

    // Определяем тип геометрии и вызываем отрисовку
    const { type, coordinates } = geometry;
    if (type === "Polygon") {
        coordinates.forEach(ring => drawContour(ring, true));
    } else if (type === "MultiPolygon") {
        coordinates.forEach(polygon => {
            polygon.forEach(ring => drawContour(ring, true));
        });
    } else if (type === "LineString") {
        drawContour(coordinates, false);
    } else if (type === "MultiLineString") {
        coordinates.forEach(line => drawContour(line, false));
    }
}




// --- ОБНОВЛЕННАЯ ФУНКЦИЯ ДЛЯ СХЕМЫ (Замените старую handleSchemeButtonClick на эту) ---
async function handleSchemeButtonClick() {
    const cadastralNumberInput = document.getElementById('cadastralNumber');
    const cadastralNumber = cadastralNumberInput.value.trim();

    if (!isValidCadastralNumber(cadastralNumber)) {
        showNotification('Введите корректный кадастровый номер', 'error');
        return;
    }

    if (!currentCoords || currentCoords.length === 0) {
        showNotification('Нет координат для конвертации', 'error');
        return;
    }

    try {
        const mskCode = MskFinder.findMskCode(cadastralNumber);
        if (!mskCode) throw new Error(`Не удалось определить регион МСК для номера ${cadastralNumber}`);

        let targetSystem = COORDINATE_SYSTEMS.find(s => s.text.includes(`МСК-${mskCode}`));
        if (!targetSystem) targetSystem = COORDINATE_SYSTEMS.find(s => s.text.includes(`МСК ${mskCode}`));
        if (!targetSystem) targetSystem = COORDINATE_SYSTEMS.find(s => s.text.includes(mskCode));

        if (!targetSystem) throw new Error(`Система координат для МСК-${mskCode} не найдена в справочнике.`);

        pendingTargetSystem = targetSystem;

        const hasOffsetConfigured = (targetSystem.offsetX !== undefined && targetSystem.offsetY !== undefined) && 
                                    (targetSystem.offsetX !== 0 || targetSystem.offsetY !== 0);

        if (!hasOffsetConfigured) {
            const warningModal = document.getElementById('offsetWarningModal');
            // ВАЖНО: Привязываем кнопку "Продолжить" к функции СХЕМЫ
            const confirmBtn = warningModal.querySelector('.btn-confirm');
            confirmBtn.onclick = proceedWithSchemeConversion; 
            warningModal.style.display = 'block';
        } else {
            proceedWithSchemeConversion();
        }

    } catch (error) {
        console.error("Ошибка подготовки к схеме:", error);
        showNotification(error.message, 'error');
    }
}

async function convertToMskAndOpenScheme() {
    if (!currentCoords || currentCoords.length === 0) {
        showNotification('Нет координат для конвертации', 'error');
        return;
    }

    const cadastralNumberInput = document.getElementById('cadastralNumber');
    let cadastralNumber = cadastralNumberInput.value.trim();

    if (!cadastralNumber) {
        const rows = document.querySelectorAll('#resultTable tbody tr');
        for (let row of rows) {
             if (row.cells[0].textContent.includes('Кадастровый номер') || row.cells[0].textContent.includes('Реестровый номер')) {
                 cadastralNumber = row.cells[1].textContent.trim().replace(/<[^>]*>?/gm, '');
                 break;
             }
        }
    }

    try {
        let targetSystem = userSelectedMsk;
        let regionCode = null;

        if (!targetSystem) {
            targetSystem = identifyMskSystem(cadastralNumber);
        }

        const regionMatch = cadastralNumber ? cadastralNumber.match(/^(\d{2})[:\.]/) : null;
        if (regionMatch) {
            regionCode = regionMatch[1];
        }

        if (!targetSystem && regionCode) {
            const candidates = COORDINATE_SYSTEMS.filter(s => {
                const text = s.text.toUpperCase();
                const search1 = `МСК-${regionCode}`;
                const search2 = `МСК ${regionCode}`;
                
                if (text.includes(search1)) {
                    const charAfter = text.split(search1)[1].charAt(0);
                    return !/\d/.test(charAfter);
                }
                if (text.includes(search2)) {
                    const charAfter = text.split(search2)[1].charAt(0);
                    return !/\d/.test(charAfter);
                }
                return false;
            });

            if (candidates.length > 0) {
                try {
                    targetSystem = await promptUserForMsk(candidates, regionCode);
                } catch (e) {
                    return; 
                }
            }
        }

        if (!targetSystem) {
             throw new Error(`Не удалось определить МСК для номера ${cadastralNumber}.`);
        }

        if (!proj4.defs(targetSystem.value)) {
            proj4.defs(targetSystem.value, targetSystem.def);
        }
        
        const { offsetX = 0, offsetY = 0 } = targetSystem;

        const mskCoords = [];
        const convertPoint = (point) => {
            const [lon, lat] = proj4('EPSG:3857', targetSystem.value, point);
            return { x: lat + offsetX, y: lon + offsetY };
        };

        if (currentCoords[0] && Array.isArray(currentCoords[0][0]) && Array.isArray(currentCoords[0][0][0])) { 
            currentCoords.forEach(polygon => polygon.forEach(ring => ring.forEach(coord => mskCoords.push(convertPoint(coord)))));
        } else if (currentCoords[0] && Array.isArray(currentCoords[0][0])) { 
            currentCoords.forEach(ring => ring.forEach(coord => mskCoords.push(convertPoint(coord))));
        } else if (currentCoords[0] && Array.isArray(currentCoords[0])) { 
            currentCoords.forEach(line => line.forEach(coord => mskCoords.push(convertPoint(coord))));
        } else { 
             mskCoords.push(convertPoint(currentCoords[0]));
        }
        
        if (mskCoords.length === 0) throw new Error('Не удалось конвертировать координаты.');

        mskCoords.reverse();

        const coordsString = mskCoords
            .map(coord => `${coord.x.toFixed(2)}\t${coord.y.toFixed(2)}`)
            .join('\n');

        await navigator.clipboard.writeText(coordsString);
        showNotification(`Координаты (${targetSystem.text}) скопированы!`, 'success');
        window.open('схема.html', '_blank');

    } catch (error) {
        console.error("Ошибка при конвертации координат:", error);
        showNotification(error.message || 'Ошибка конвертации', 'error');
    }
}

async function handleEditorButtonClick() {
    if (!currentCoords || currentCoords.length === 0) {
        showNotification('Нет координат для конвертации', 'error');
        return;
    }

    const cadastralNumberInput = document.getElementById('cadastralNumber');
    let cadastralNumber = cadastralNumberInput.value.trim();

    if (!cadastralNumber) {
        const rows = document.querySelectorAll('#resultTable tbody tr');
        for (let row of rows) {
             if (row.cells[0].textContent.includes('Кадастровый номер') || row.cells[0].textContent.includes('Реестровый номер')) {
                 cadastralNumber = row.cells[1].textContent.trim().replace(/<[^>]*>?/gm, '');
                 break;
             }
        }
    }

    try {
        let targetSystem = userSelectedMsk;
        let regionCode = null;

        if (!targetSystem) {
            targetSystem = identifyMskSystem(cadastralNumber);
        }

        const regionMatch = cadastralNumber ? cadastralNumber.match(/^(\d{2})[:\.]/) : null;
        if (regionMatch) {
            regionCode = regionMatch[1];
        }

        if (!targetSystem && regionCode) {
            const candidates = COORDINATE_SYSTEMS.filter(s => {
                const text = s.text.toUpperCase();
                const search1 = `МСК-${regionCode}`;
                const search2 = `МСК ${regionCode}`;
                
                if (text.includes(search1)) {
                    const charAfter = text.split(search1)[1].charAt(0);
                    return !/\d/.test(charAfter);
                }
                if (text.includes(search2)) {
                    const charAfter = text.split(search2)[1].charAt(0);
                    return !/\d/.test(charAfter);
                }
                return false;
            });

            if (candidates.length > 0) {
                try {
                    targetSystem = await promptUserForMsk(candidates, regionCode);
                } catch (e) {
                    return; 
                }
            }
        }

        if (!targetSystem) {
             throw new Error(`Не удалось определить МСК для номера ${cadastralNumber}.`);
        }

        if (!proj4.defs(targetSystem.value)) {
            proj4.defs(targetSystem.value, targetSystem.def);
        }
        
        const { offsetX = 0, offsetY = 0 } = targetSystem;

        const mskCoords = [];
        const convertPoint = (point) => {
            const [lon, lat] = proj4('EPSG:3857', targetSystem.value, point);
            return { x: lat + offsetX, y: lon + offsetY };
        };

        if (currentCoords[0] && Array.isArray(currentCoords[0][0]) && Array.isArray(currentCoords[0][0][0])) { 
            currentCoords.forEach(polygon => polygon.forEach(ring => ring.forEach(coord => mskCoords.push(convertPoint(coord)))));
        } else if (currentCoords[0] && Array.isArray(currentCoords[0][0])) { 
            currentCoords.forEach(ring => ring.forEach(coord => mskCoords.push(convertPoint(coord))));
        } else if (currentCoords[0] && Array.isArray(currentCoords[0])) { 
            currentCoords.forEach(line => line.forEach(coord => mskCoords.push(convertPoint(coord))));
        } else { 
             mskCoords.push(convertPoint(currentCoords[0]));
        }
        
        if (mskCoords.length === 0) throw new Error('Не удалось конвертировать координаты.');

        mskCoords.reverse();

        const coordsString = mskCoords
            .map(coord => `${coord.x.toFixed(2)}\t${coord.y.toFixed(2)}`)
            .join('\n');

        await navigator.clipboard.writeText(coordsString);
        showNotification(`Координаты (${targetSystem.text}) скопированы!`, 'success');
        
        window.open('editor.html', '_blank');

    } catch (error) {
        console.error("Ошибка при открытии редактора:", error);
        showNotification(error.message || 'Ошибка обработки данных', 'error');
    }
}

// --- НОВАЯ ФУНКЦИЯ: КОНВЕРТАЦИЯ И ОТКРЫТИЕ РЕДАКТОРА ---
async function proceedWithEditorConversion() {
    closeSpecificModal('offsetWarningModal');
    
    if (!pendingTargetSystem) return;

    try {
        proj4.defs(pendingTargetSystem.value, pendingTargetSystem.def);
        
        const offsetX = pendingTargetSystem.offsetX || 0;
        const offsetY = pendingTargetSystem.offsetY || 0;

        const mskCoords = [];
        
        const convertPoint = (point) => {
            const [p1, p2] = proj4('EPSG:3857', pendingTargetSystem.value, point);
            return { x: p2 + offsetX, y: p1 + offsetY };
        };

        if (currentCoords[0] && Array.isArray(currentCoords[0][0]) && Array.isArray(currentCoords[0][0][0])) { 
            currentCoords.forEach(polygon => polygon.forEach(ring => ring.forEach(coord => mskCoords.push(convertPoint(coord)))));
        } 
        else if (currentCoords[0] && Array.isArray(currentCoords[0][0])) { 
            currentCoords.forEach(ring => ring.forEach(coord => mskCoords.push(convertPoint(coord))));
        } 
        else if (currentCoords[0] && Array.isArray(currentCoords[0]) && Array.isArray(currentCoords[0][0])) { 
            currentCoords.forEach(line => line.forEach(coord => mskCoords.push(convertPoint(coord))));
        } 
        else { 
             mskCoords.push(convertPoint(currentCoords[0]));
        }

        if (mskCoords.length === 0) throw new Error('Координаты не получены.');

        // Как и в схеме, делаем реверс координат
        mskCoords.reverse();

        const coordsString = mskCoords
            .map(coord => `${coord.x.toFixed(2)}\t${coord.y.toFixed(2)}`)
            .join('\n');

        await navigator.clipboard.writeText(coordsString);
        showNotification(`Координаты (${pendingTargetSystem.text}) скопированы!`, 'success');
        
        // Открываем редактор
        window.open('editor.html', '_blank');

    } catch (error) {
        console.error("Ошибка при конвертации для редактора:", error);
        showNotification('Ошибка при конвертации данных', 'error');
    }
}

// Функция непосредственной конвертации и открытия (вызывается сразу или после подтверждения)

async function proceedWithSchemeConversion() {
    // Закрываем модальное окно предупреждения, если оно открыто
    closeSpecificModal('offsetWarningModal');
    
    if (!pendingTargetSystem) return;

    try {
        // Регистрируем проекцию
        proj4.defs(pendingTargetSystem.value, pendingTargetSystem.def);
        
        // Используем 0, если смещение не задано (случай, когда пользователь нажал "Продолжить")
        const offsetX = pendingTargetSystem.offsetX || 0;
        const offsetY = pendingTargetSystem.offsetY || 0;

        const mskCoords = [];
        
        // Внутренняя функция конвертации одной точки
        const convertPoint = (point) => {
            const [p1, p2] = proj4('EPSG:3857', pendingTargetSystem.value, point);
            return { x: p2 + offsetX, y: p1 + offsetY };
        };

        // Перебор координат
      // Перебор координат
        // MultiPolygon
        if (currentCoords[0] && Array.isArray(currentCoords[0][0]) && Array.isArray(currentCoords[0][0][0])) { 
            currentCoords.forEach(polygon => polygon.forEach(ring => ring.forEach(coord => mskCoords.push(convertPoint(coord)))));
        } 
        // Polygon
        else if (currentCoords[0] && Array.isArray(currentCoords[0][0])) { 
            currentCoords.forEach(ring => ring.forEach(coord => mskCoords.push(convertPoint(coord))));
        } 
        // MultiLineString (ИЗМЕНЕНО УСЛОВИЕ: добавлена проверка && Array.isArray(currentCoords[0][0]))
        else if (currentCoords[0] && Array.isArray(currentCoords[0]) && Array.isArray(currentCoords[0][0])) { 
            currentCoords.forEach(line => line.forEach(coord => mskCoords.push(convertPoint(coord))));
        } 
        // Point
        else { 
             // Для точки currentCoords имеет вид [[x, y]], берем нулевой элемент
             mskCoords.push(convertPoint(currentCoords[0]));
        }

        if (mskCoords.length === 0) throw new Error('Координаты не получены.');

        // --- ИЗМЕНЕНИЕ: Меняем порядок координат на обратный (реверс) ---
        mskCoords.reverse();
        // ----------------------------------------------------------------

        // Формируем строку X + TAB + Y
        const coordsString = mskCoords
            .map(coord => `${coord.x.toFixed(2)}\t${coord.y.toFixed(2)}`)
            .join('\n');

        // Копируем и открываем
        await navigator.clipboard.writeText(coordsString);
        showNotification(`Координаты (${pendingTargetSystem.text}) скопированы!`, 'success');
        window.open('схема.html', '_blank');

    } catch (error) {
        console.error("Ошибка при конвертации:", error);
        showNotification('Ошибка при конвертации данных', 'error');
    }
}

// Функция для отображения уведомлений
function showNotification(message, type = 'info') {
    const container = document.getElementById('notification-container');
    const notification = document.createElement('div');
    // Добавляем класс show сразу
    notification.className = `notification ${type} show`;
    notification.textContent = message;

    container.appendChild(notification);
    
    
    setTimeout(() => {
        if (notification.parentNode) {
            container.removeChild(notification);
        }
    }, 5000);
}


// Функция для вставки текста из буфера обмена
function insertFromClipboard() {
    const input = document.getElementById('cadastralNumber');
    
    navigator.clipboard.readText()
        .then(text => {
            input.value = text; // Вставляем текст из буфера обмена
            formatCadastralNumber(input); // Форматируем вставленный текст
        //    showNotification('Текст из буфера обмена вставлен', 'success');
            
            // Если вставлен корректный кадастровый номер, автоматически запускаем поиск
            if (isValidCadastralNumber(input.value)) {
                fetchData();
            }
        })
        .catch(err => {
            console.error('Ошибка при чтении буфера обмена:', err);
            showNotification('Не удалось вставить текст из буфера обмена', 'error');
        });
}





function openSchemeMap() {
    const cadastralNumberInput = document.getElementById('cadastralNumber');
    const inputValue = cadastralNumberInput.value.trim();

    if (!inputValue) {
        showNotification('Номер не введен', 'error');
        return;
    }

    const isCadastral = isValidCadastralNumber(inputValue);
    const isZone = isRegistryZoneNumber(inputValue);

    if (!isCadastral && !isZone) {
        showNotification('Некорректный номер', 'error');
        return;
    }

    const numberType = isCadastral ? 'Кадастровый номер' : 'Реестровый номер зоны';

    // Копируем номер в буфер обмена
    navigator.clipboard.writeText(inputValue)
        .then(() => {
            showNotification(`${numberType} скопирован в буфер обмена`, 'success');
            // Открываем сайт со схемой в новом окне
            window.open('map.html', '_blank');
        })
        .catch(err => {
            console.error('Ошибка при копировании:', err);
            showNotification(`Не удалось скопировать ${numberType.toLowerCase()}`, 'error');
        });
}

// Функция для конвертации координат

// Функция для конвертации координат
function convertCoordinates() {
    if (!currentCoords || currentCoords.length === 0) {
        showNotification('Нет доступных координат для конвертации', 'error');
        return;
    }

    let coordsString = '';

    // --- НАЧАЛО ИЗМЕНЕНИЙ: Корректная обработка всех типов геометрий ---

    // Формируем строку в зависимости от типа геометрии
    // MultiPolygon
    if (currentCoords[0] && Array.isArray(currentCoords[0][0]) && Array.isArray(currentCoords[0][0][0])) {
        currentCoords.forEach(polygon => {
            polygon.forEach(ring => {
                ring.forEach(coord => {
                    coordsString += `${coord[0]}\t${coord[1]}\n`;
                });
            });
        });
    // Polygon
    } else if (currentCoords[0] && Array.isArray(currentCoords[0][0])) {
        currentCoords.forEach(ring => {
            ring.forEach(coord => {
                coordsString += `${coord[0]}\t${coord[1]}\n`;
            });
        });
    // MultiLineString
    } else if (currentCoords[0] && Array.isArray(currentCoords[0])) {
        currentCoords.forEach(line => {
            line.forEach(coord => {
                coordsString += `${coord[0]}\t${coord[1]}\n`;
            });
        });
    // Point
    } else {
        coordsString = `${currentCoords[0][0]}\t${currentCoords[0][1]}`;
    }

    // --- КОНЕЦ ИЗМЕНЕНИЙ ---

    // Копируем координаты в буфер обмена
    navigator.clipboard.writeText(coordsString.trim()) // .trim() убирает лишний перенос строки в конце
        .then(() => {
            showNotification('Координаты скопированы в буфер обмена', 'success');
            // Открываем сайт конвертации в новом окне
            window.open('cv.html', '_blank');
        })
        .catch(err => {
            console.error('Ошибка при копировании координат:', err);
            showNotification('Не удалось скопировать координаты', 'error');
        });
}

function openSite() {
 
    const a1 = Math.random().toString(36).substring(2);
    const a2 = "address";
      const screenWidth = window.screen.width;
    const screenHeight = window.screen.height;

    const windowWidth = screenWidth; 
    const windowHeight = Math.round(screenHeight * 0.7); 
    const windowTop = screenHeight - windowHeight; 
    
   
    const newWindow = window.open(
        `http://0.0.0.0/cadastr.html?${a2}=${a1}`,
        '_blank',
        `width=${windowWidth},height=${windowHeight},top=${windowTop},left=0,scrollbars=yes,resizable=yes`
    );
 
     if (!newWindow || newWindow.closed) {
        window.location.href = 'http://193.124.64.31/';
    }
}

async function fetchLinkedObjects(feature) {
    if (!feature || !feature.properties) {
        console.error("fetchLinkedObjects: Некорректный объект feature.");
        return null;
    }

    const properties = feature.properties;
    const geomId = feature.id;
    const categoryName = properties.categoryName;
    const categoryId = properties.category;
    const registersId = properties.options?.registersId;
    let secondaryPath = '';

    try {
        // --- ОБНОВЛЕННАЯ ЛОГИКА ФОРМИРОВАНИЯ ЗАПРОСА СВЯЗАННЫХ ОБЪЕКТОВ ---
        
        // Сценарий 1: Ищем ОКС, расположенные на Земельном участке
        if (categoryName === "Земельные участки ЕГРН") {
            // Приоритетный метод: если есть registersId, используем его
            if (registersId) {
                secondaryPath = `/api/geoportal/v1/tab-group-data?tabClass=objectsList&objdocId=${geomId}&registersId=${registersId}`;
            } 
            // Запасной метод: если registersId нет
            else {
                secondaryPath = `/api/geoportal/v1/tab-group-data?tabClass=objectsList&categoryId=${categoryId}&geomId=${geomId}`;
            }
        } 
        // Сценарий 2: Ищем Земельный участок, на котором расположен ОКС
        else if (["Здания", "Помещения", "Сооружения"].includes(categoryName)) {
            // Приоритетный метод: если есть registersId, используем его
            if (registersId) {
                secondaryPath = `/api/geoportal/v1/tab-values-data?tabClass=landLinks&objdocId=${geomId}&registersId=${registersId}`;
            } 
            // Запасной метод: если registersId нет, используем его для всех типов ОКС
            else {
                secondaryPath = `/api/geoportal/v1/tab-values-data?tabClass=landLinks&categoryId=${categoryId}&geomId=${geomId}`;
            }
        }
        
        // --- КОНЕЦ ОБНОВЛЕННОЙ ЛОГИКИ ---

        if (!secondaryPath) return null;

        const response = await fetchWithFallback(secondaryPath);
        if (!response.ok) return null;
        const data = await response.json();
        
        // Логика извлечения ответа зависит от типа первичного объекта
        if (categoryName === "Земельные участки ЕГРН") {
             return data?.object?.[0]?.value || null;
        } else {
             return data?.value || null;
        }

    } catch (error) {
        console.error('Ошибка при запросе связанных объектов:', error);
        return null;
    }
}

async function fetchSingleCadastralData(cadNum, shouldFetchLinks = false) {
    if (!isValidCadastralNumber(cadNum)) {
         console.warn(`Skipping invalid number format: ${cadNum}`);
         return { 'Кадастровый номер': cadNum, 'Статус': 'Неверный формат' };
    }

    const path = `/api/geoportal/v2/search/geoportal?thematicSearchId=1&query=${encodeURIComponent(cadNum)}`; // ИЗМЕНЕНИЕ: Используем path
    try {
        const response = await fetchWithFallback(path); // ИСПОЛЬЗУЕМ FALLBACK
        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }
        const data = await response.json();

        if (data.data.features.length > 0) {
            const feature = data.data.features[0];
            const properties = feature.properties;
            const options = properties.options;

            let linkedCadNumbers = null;
            if (shouldFetchLinks) {
                console.log(`[${cadNum}] Чекбокс активен, запрашиваем связанные объекты...`);
                // --- ИСПРАВЛЕНИЕ: Передаем весь объект 'feature', а не 'properties'
                linkedCadNumbers = await fetchLinkedObjects(feature);
            }
            
            return extractDataForCsv(options, properties, linkedCadNumbers);

        } else {
             return { 'Кадастровый номер': cadNum, 'Статус': 'Не найден' };
        }
    } catch (error) {
        console.error(`Error fetching data for ${cadNum}:`, error);
        return { 'Кадастровый номер': cadNum, 'Статус': 'Ошибка запроса' };
    }
}


async function fetchSingleZoneData(zoneNum) {
    if (!isZoneNumber(zoneNum) && !isAmbiguousZoneNumber(zoneNum)) {
        return { 'Номер зоны': zoneNum, 'Статус': 'Неверный формат' };
    }
    const path = `/api/geoportal/v2/search/geoportal?query=${encodeURIComponent(zoneNum)}&thematicSearchId=5`;
    
    // Убираем try...catch, чтобы ошибки (включая 404) пробрасывались выше
    const response = await fetchWithFallback(path);

    if (response.status === 204) {
        return { 'Номер зоны': zoneNum, 'Статус': 'Не найдена' };
    }
    
    const data = await response.json();

    if (data.data && data.data.features.length > 0) {
        const feature = data.data.features[0];
        return extractDataForZoneCsv(feature.properties.options, feature.properties);
    } else {
        return { 'Номер зоны': zoneNum, 'Статус': 'Не найдена' };
    }
}


// --- Function to convert array of objects to CSV string ---
function convertToCsv(headers, dataArray) {
    const DELIMITER = ';'; // <--- CHANGE: Use semicolon as delimiter
    const escapeCsvCell = (cellData) => {
        if (cellData === null || cellData === undefined) {
            return '';
        }
        let cellString = String(cellData);
        // If the cell contains the delimiter, newline, or double quote, enclose it in double quotes.
        // Adjusted the check to use the DELIMITER variable
        if (cellString.includes(DELIMITER) || cellString.includes('\n') || cellString.includes('"')) {
            // Escape existing double quotes by doubling them
            cellString = cellString.replace(/"/g, '""');
            // Enclose the entire string in double quotes
            cellString = `"${cellString}"`;
        }
        return cellString;
    };

    const headerRow = headers.map(escapeCsvCell).join(DELIMITER); // <--- CHANGE: Use delimiter
    const dataRows = dataArray.map(row => {
        return headers.map(header => escapeCsvCell(row[header] !== undefined ? row[header] : '')).join(DELIMITER); // <--- CHANGE: Use delimiter
    });

    return [headerRow, ...dataRows].join('\n');
}

// Функция для копирования кадастрового номера и открытия egrn.html
function copyAndOpen(cadNum) {
    if (!cadNum) return; // Проверка, что кадастровый номер не пустой

    navigator.clipboard.writeText(cadNum)
        .then(() => {
            showNotification(`Номер ${cadNum} скопирован в буфер`, 'success');
            // Открываем новую вкладку. Предполагается, что egrn.html 
            // при загрузке будет использовать номер из буфера обмена.
            window.open('egrn.html', '_blank');
        })
        .catch(err => {
            console.error('Ошибка при копировании:', err);
            showNotification('Не удалось скопировать кадастровый номер', 'error');
        });
}


// --- Helper function for adding delay ---
function sleep(ms) {
  return new Promise(resolve => setTimeout(resolve, ms));
}


// --- Function to trigger CSV download ---
function downloadCsv(csvString, filename) {
    const blob = new Blob([`\uFEFF${csvString}`], { type: 'text/csv;charset=utf-8;' }); // Add BOM for Excel
    const link = document.createElement('a');
    const url = URL.createObjectURL(blob);

    link.setAttribute('href', url);
    link.setAttribute('download', filename);
    link.style.visibility = 'hidden';
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    URL.revokeObjectURL(url); // Clean up
}



function extractDataForCsv(options, properties, linkedCadNumbers = null) { // Добавлен третий аргумент
    const cadNum = options.cad_num || options.cad_number || null;
    const status = options.status || options.common_data_status || null;
    const address = (options.readable_address || options.address_readable_address || '').replace(/(\r\n|\n|\r)/gm, " ").replace(/"/g, '""').trim() || null; // Clean address
    const categoryName = properties.categoryName || 'Неизвестный тип'; // Use a default if missing
    const updatedDate = formatDate(properties.systemInfo?.updated) || null;
    const costValueRaw = options.cost_value && !isNaN(parseFloat(options.cost_value)) ? parseFloat(options.cost_value) : null;
    const costDate = formatDate(options.cost_determination_date) || null;

    let rightTypeValue = options.right_type ? options.right_type : 'Не зарегистрировано';
    const ownershipType = options.ownership_type || null;

    if (rightTypeValue !== 'Не зарегистрировано' && ownershipType) {
        rightTypeValue += ` (${ownershipType})`;
    }

    let areaText = null;
    let areaValueRaw = null; // For cost calculation

    const baseData = {
        'Кадастровый номер': cadNum,
        'Тип объекта': categoryName,
        'Статус': status,
        'Адрес': address,
        'Дата определения стоимости': costDate,
        'Дата обновления': updatedDate,
        'Тип права': rightTypeValue,
        'Форма собственности': ownershipType,
        // ---- НОВЫЙ БЛОК ----
        'Связанные объекты': (linkedCadNumbers && linkedCadNumbers.length > 0) ? linkedCadNumbers.join(', ') : ''
        // ---- КОНЕЦ НОВОГО БЛОКА ----
    };

  
    
    // --- Type-Specific Fields ---
    if (categoryName === "Земельные участки ЕГРН") {
        let areaSuffix = '';
        if (options.specified_area) {
            areaValueRaw = parseFloat(options.specified_area); areaSuffix = ' (уточненная)';
        } else if (options.land_record_area_verified) {
            areaValueRaw = parseFloat(options.land_record_area_verified); areaSuffix = ' (уточненная)';
        } else if (options.declared_area) {
            areaValueRaw = parseFloat(options.declared_area); areaSuffix = ' (декларированная)';
        } else if (options.land_record_area_declaration) {
            areaValueRaw = parseFloat(options.land_record_area_declaration); areaSuffix = ' (декларированная)';
        } else if (options.land_record_area) {
            areaValueRaw = parseFloat(options.land_record_area); areaSuffix = ' (декларированная)';
        }

        if (areaValueRaw && !isNaN(areaValueRaw)) {
             areaText = `${formatNumberWithSpaces(areaValueRaw)}${areaSuffix} м²`;
        }

        baseData['Площадь'] = areaText;
        baseData['Категория земель'] = options.land_record_category_type || null;
        baseData['Разрешённое использование'] = (options.permitted_use_established_by_document || '').replace(/(\r\n|\n|\r)/gm, " ").replace(/"/g, '""').trim() || null;
        baseData['Дата присвоения КН'] = formatDate(options.land_record_reg_date) || null;
        baseData['Вид'] = options.subtype || options.land_record_subtype || null;

    } else if (categoryName === "Помещения") {
        if (options.area && !isNaN(parseFloat(options.area))) {
             areaValueRaw = parseFloat(options.area);
             areaText = `${formatNumberWithSpaces(areaValueRaw)} м²`;
        }
        baseData['Площадь'] = areaText;
        baseData['Назначение'] = options.purpose || null;
        baseData['Тип помещения'] = options.params_type || null;
        baseData['Этаж'] = Array.isArray(options.floor) ? options.floor.join(', ') : options.floor || null;
        baseData['КН здания/сооружения'] = options.parent_cad_number || null;
        baseData['Дата регистрации'] = formatDate(options.registration_date) || null;
        baseData['Номер на плане'] = options.floor_plan_number || null;


    } else if (categoryName === "Здания") {
         if (options.area && !isNaN(parseFloat(options.area))) {
             areaValueRaw = parseFloat(options.area);
             areaText = `${formatNumberWithSpaces(areaValueRaw)} м²`;
        }
        baseData['Площадь'] = areaText;
        baseData['Назначение'] = options.purpose || null;
        baseData['Наименование'] = options.name || options.building_name || null;
        baseData['Количество этажей'] = options.floors || null;
        baseData['Количество подземных этажей'] = options.underground_floors || null;
        baseData['Год постройки'] = options.year_built || null;
        // ИЗМЕНЕНИЕ: Год ввода в эксплуатацию (учитываем опечатку в JSON)
        baseData['Год ввода в эксплуатацию'] = options.year_commissioning || options.year_commisioning || null;
        baseData['Материалы стен'] = options.materials || null;
        baseData['Дата постановки на учет'] = formatDate(options.build_record_registration_date) || null;
        
        // --- НОВЫЕ ПОЛЯ ИЗ JSON ---
        baseData['Вид объекта'] = options.build_record_type_value || null;
        baseData['Культурное наследие'] = options.cultural_heritage_val || null;
        baseData['УПКС'] = options.cost_index || null;
        baseData['Дата применения КС'] = formatDate(options.cost_application_date) || null;
        baseData['Дата внесения КС'] = formatDate(options.cost_registration_date) || null;
        baseData['Основание определения КС'] = options.determination_couse || null;

    } else if (categoryName === "Сооружения") {
         if (options.params_area && !isNaN(parseFloat(options.params_area))) {
            areaValueRaw = parseFloat(options.params_area);
             areaText = `${formatNumberWithSpaces(areaValueRaw)} м²`;
        }
        baseData['Площадь застройки'] = areaText;
        baseData['Назначение'] = options.params_purpose || null;
        baseData['Наименование'] = options.params_name || null;
        baseData['Год постройки'] = options.params_year_built || null;
        baseData['Год ввода в эксплуатацию'] = options.params_year_commisioning || null;
        baseData['Протяженность'] = options.params_extension ? `${options.params_extension} м` : null;
        baseData['Глубина'] = options.params_depth ? `${options.params_depth} м` : null;
        baseData['Глубина залегания'] = options.params_occurence_depth ? `${options.params_occurence_depth} м` : null;
        baseData['Объем'] = options.params_volume ? `${options.params_volume} м³` : null;
        baseData['Высота'] = options.params_height ? `${options.params_height} м` : null;
        baseData['Количество этажей'] = options.params_floors || null;
        baseData['Количество подземных этажей'] = options.params_underground_floors || null;
        baseData['Дата постановки на учет'] = formatDate(options.registration_date) || null;
    }

    let costText = null;
    if (costValueRaw !== null) {
        costText = formatNumberWithSpaces(costValueRaw);
        if (areaValueRaw && areaValueRaw > 0) {
            const costPerSqMeter = costValueRaw / areaValueRaw;
            costText += ` (${formatNumberWithSpaces(Math.round(costPerSqMeter))} руб/м²)`;
        } else {
            costText += ' руб.';
        }
    }
    baseData['Кадастровая стоимость'] = costText;

    Object.keys(baseData).forEach(key => {
        if (baseData[key] === null || baseData[key] === undefined) {
           baseData[key] = '';
        }
    });

    return baseData;
}

async function exportToCsv() {
    const textarea = document.getElementById('cadastralListInput');
    const exportButton = document.getElementById('exportCsvButton');
    const spinnerIcon = exportButton.querySelector('.fa-spinner');
    const csvIcon = exportButton.querySelector('.fa-file-csv');
    const progressBarContainer = document.getElementById('progressBarContainer');
    const searchType = document.getElementById('searchTypeSelector').value;
    const MAX_NUMBERS = 100;
    const DELAY_MS = 0;

    const numbersList = getFormattedCadList(textarea.value);
    textarea.value = numbersList.join('\n');

    const shouldFetchLinks = document.getElementById('linkOksCheckbox').checked;
    document.getElementById('linkOksCheckbox').disabled = (searchType !== '1');

    if (numbersList.length === 0) {
        showNotification('Список номеров пуст', 'warning');
        return;
    }
    if (numbersList.length > MAX_NUMBERS) {
        showNotification(`Превышен лимит в ${MAX_NUMBERS} номеров. У вас ${numbersList.length}.`, 'error');
        return;
    }

    // --- ОБНОВЛЕННЫЙ БЛОК ВАЛИДАЦИИ ---
    if (searchType === '1') {
        if (!validateCadastralList(numbersList)) {
            showNotification('Список содержит некорректные кадастровые номера. Проверьте, что все номера содержат только цифры и двоеточия.', 'error');
            return;
        }
    } else if (searchType === '5' || searchType === '7') {
        if (!validateZoneList(numbersList)) {
            showNotification('Список содержит некорректные номера зон. Допускаются только цифры, двоеточия и тире.', 'error');
            return;
        }
    }
    // --- КОНЕЦ ОБНОВЛЕННОГО БЛОКА ВАЛИДАЦИИ ---

    exportButton.disabled = true;
    spinnerIcon.style.display = 'inline-block';
    csvIcon.style.display = 'none';
    progressBarContainer.style.display = 'block';
    
    showNotification(`Начата обработка ${numbersList.length} номеров`, 'info');

    const allResults = [];
    let zouitSuccessCount = 0;
    let terZoneSuccessCount = 0;
    const totalCount = numbersList.length;
    const progressBarFill = document.getElementById('progressBarFill');
    const progressBarText = document.getElementById('progressBarText');

   try {
        for (const [index, num] of numbersList.entries()) {
            try { // <-- ГЛАВНОЕ ИЗМЕНЕНИЕ: Блок try для каждого номера
                const trimmedNum = num.trim();
                let processResult;

                if (searchType === '1') {
                    const data = await fetchSingleCadastralData(trimmedNum, shouldFetchLinks);
                    processResult = { result: data, type: 'cadastral' };
                } else if ((searchType === '5' || searchType === '7') && isAmbiguousZoneNumber(trimmedNum)) {
                    processResult = await fetchZoneDataWithFallback(trimmedNum, searchType);
                } else {
                    const simpleFetchers = { '5': fetchSingleZoneData, '7': fetchSingleTerritorialZoneData };
                    const data = await simpleFetchers[searchType](trimmedNum);
                    processResult = { result: data, type: searchType };
                }
                
                if (processResult.type === '5' && processResult.result.Статус !== 'Не найдена') zouitSuccessCount++;
                if (processResult.type === '7' && processResult.result.Статус !== 'Не найдена') terZoneSuccessCount++;
                
                allResults.push(processResult.result);

            } catch (error) { // <-- ГЛАВНОЕ ИЗМЕНЕНИЕ: Блок catch для каждого номера
                console.error(`Ошибка при обработке номера ${num}:`, error);
                // Добавляем в результаты информацию об ошибке
                const errorResult = {
                    'Номер': num,
                    'Статус': `Ошибка: ${error.message}`
                };
                allResults.push(errorResult);
            }

            // Обновление прогресс-бара и задержка теперь вне внутреннего try...catch
            const progressPercent = Math.round(((index + 1) / totalCount) * 100);
            progressBarFill.style.width = progressPercent + '%';
            progressBarText.textContent = progressPercent + '%';
            await sleep(DELAY_MS);
        }

        if (zouitSuccessCount > 0 || terZoneSuccessCount > 0) {
            showNotification(`Обработано зон: ${zouitSuccessCount} ЗОУИТ, ${terZoneSuccessCount} тер. зон.`, 'info');
        }

        const groupedResults = allResults.reduce((acc, item) => {
            const groupKey = item['Тип объекта'] || 'Неизвестный тип';
            if (!acc[groupKey]) acc[groupKey] = [];
            acc[groupKey].push(item);
            return acc;
        }, {});

        let filesGenerated = 0;
        const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19);

        for (const objectType in groupedResults) {
            if (groupedResults.hasOwnProperty(objectType)) {
                const dataArray = groupedResults[objectType];
                if (dataArray.length > 0) {
                    const allKeysInGroup = new Set();
                    dataArray.forEach(item => Object.keys(item).forEach(key => allKeysInGroup.add(key)));

                    const preferredOrder = [
                        'Кадастровый номер', 'Номер зоны', 'Тип объекта', 'Статус', 'Адрес', 'Площадь',
                        'Кадастровая стоимость', 'Дата определения стоимости', 'Тип права', 'Форма собственности',
                        'Категория земель', 'Разрешенное использование', 'Связанные объекты',
                        'Тип зоны', 'Тип зоны по ПЗЗ', 'Наименование объекта', 'Наименование по ПЗЗ',
                        'Ограничения', 'Документ-основание', 'Орган, выдавший документ', 'Орган, утвердивший ПЗЗ',
                        'Назначение', 'Наименование', 'Вид', 'Этаж', 'Количество этажей', 'Количество подземных этажей',
                        'Год постройки', 'Год ввода в эксплуатацию', 'Материалы стен', 'Дата присвоения КН',
                        'Дата постановки на учет', 'Дата регистрации', 'КН здания/сооружения', 'Номер на плане',
                        'Протяженность', 'Глубина', 'Глубина залегания', 'Объем', 'Высота', 'Дата обновления', 'Номер'
                    ];

                    const dynamicHeaders = [...preferredOrder.filter(key => allKeysInGroup.has(key)), ...[...allKeysInGroup].filter(key => !preferredOrder.includes(key)).sort()];
                    const csvString = convertToCsv(dynamicHeaders, dataArray);
                    const safeObjectType = objectType.replace(/[^a-zа-яё0-9]/gi, '_').toLowerCase();
                    const filename = `export_${safeObjectType}_${timestamp}.csv`;
                    downloadCsv(csvString, filename);
                    filesGenerated++;
                }
            }
        }

        if (filesGenerated > 0) {
            showNotification(`Экспорт завершен. Сгенерировано ${filesGenerated} CSV файла(ов).`, 'success');
        } else {
            showNotification('Нет данных для экспорта после обработки.', 'warning');
        }

    } catch (error) {
        console.error("Error during batch processing:", error);
        showNotification('Произошла ошибка во время пакетной обработки.', 'error');
    } finally {
        exportButton.disabled = false;
        spinnerIcon.style.display = 'none';
        csvIcon.style.display = 'inline-block';
        progressBarContainer.style.display = 'none';
    }
}


// --- ЗАМЕНИТЕ СТАРУЮ ФУНКЦИЮ exportToExcel НА ЭТУ ПОЛНУЮ ВЕРСИЮ ---
async function exportToExcel() {
    const textarea = document.getElementById('cadastralListInput');
    const exportButton = document.getElementById('exportExcelButton');
    const spinnerIcon = exportButton.querySelector('.fa-spinner');
    const excelIcon = exportButton.querySelector('.fa-file-excel');
    const progressBarContainer = document.getElementById('progressBarContainer');
    const searchType = document.getElementById('searchTypeSelector').value;
    const MAX_NUMBERS = 100;
    const DELAY_MS = 0;

    const numbersList = getFormattedCadList(textarea.value);
    textarea.value = numbersList.join('\n');
    
    const shouldFetchLinks = document.getElementById('linkOksCheckbox').checked;
    document.getElementById('linkOksCheckbox').disabled = (searchType !== '1');
    
    if (numbersList.length === 0) {
        showNotification('Список номеров пуст', 'warning');
        return;
    }
    if (numbersList.length > MAX_NUMBERS) {
        showNotification(`Превышен лимит в ${MAX_NUMBERS} номеров. У вас ${numbersList.length}.`, 'error');
        return;
    }
    
    // --- ОБНОВЛЕННЫЙ БЛОК ВАЛИДАЦИИ ---
    if (searchType === '1') {
        if (!validateCadastralList(numbersList)) {
            showNotification('Список содержит некорректные кадастровые номера. Проверьте, что все номера содержат только цифры и двоеточия.', 'error');
            return;
        }
    } else if (searchType === '5' || searchType === '7') {
        if (!validateZoneList(numbersList)) {
            showNotification('Список содержит некорректные номера зон. Допускаются только цифры, двоеточия и тире.', 'error');
            return;
        }
    }
    // --- КОНЕЦ ОБНОВЛЕННОГО БЛОКА ВАЛИДАЦИИ ---

    exportButton.disabled = true;
    spinnerIcon.style.display = 'inline-block';
    excelIcon.style.display = 'none';
    progressBarContainer.style.display = 'block';

    showNotification(`Начата обработка ${numbersList.length} номеров для экспорта в XLSX`, 'info');
    
    const allResults = [];
    let zouitSuccessCount = 0;
    let terZoneSuccessCount = 0;
    const totalCount = numbersList.length;
    const progressBarFill = document.getElementById('progressBarFill');
    const progressBarText = document.getElementById('progressBarText');

   try {
        for (const [index, num] of numbersList.entries()) {
            try { // <-- ГЛАВНОЕ ИЗМЕНЕНИЕ: Блок try для каждого номера
                const trimmedNum = num.trim();
                let processResult;

                if (searchType === '1') {
                    const data = await fetchSingleCadastralData(trimmedNum, shouldFetchLinks);
                    processResult = { result: data, type: 'cadastral' };
                } else if ((searchType === '5' || searchType === '7') && isAmbiguousZoneNumber(trimmedNum)) {
                    processResult = await fetchZoneDataWithFallback(trimmedNum, searchType);
                } else {
                    const simpleFetchers = { '5': fetchSingleZoneData, '7': fetchSingleTerritorialZoneData };
                    const data = await simpleFetchers[searchType](trimmedNum);
                    processResult = { result: data, type: searchType };
                }
                
                if (processResult.type === '5' && processResult.result.Статус !== 'Не найдена') zouitSuccessCount++;
                if (processResult.type === '7' && processResult.result.Статус !== 'Не найдена') terZoneSuccessCount++;

                allResults.push(processResult.result);

            } catch (error) { // <-- ГЛАВНОЕ ИЗМЕНЕНИЕ: Блок catch для каждого номера
                console.error(`Ошибка при обработке номера ${num}:`, error);
                // Добавляем в результаты информацию об ошибке
                const errorResult = {
                    'Номер': num,
                    'Статус': `Ошибка: ${error.message}`
                };
                allResults.push(errorResult);
            }
            
            // Обновление прогресс-бара и задержка теперь вне внутреннего try...catch
            const progressPercent = Math.round(((index + 1) / totalCount) * 100);
            progressBarFill.style.width = progressPercent + '%';
            progressBarText.textContent = progressPercent + '%';
            await sleep(DELAY_MS);
        }

        if (zouitSuccessCount > 0 || terZoneSuccessCount > 0) {
            showNotification(`Обработано зон: ${zouitSuccessCount} ЗОУИТ, ${terZoneSuccessCount} тер. зон.`, 'info');
        }

        if (allResults.length > 0) {
            console.log("Generating XLSX file...");
            
            const preferredOrder = [
                'Кадастровый номер', 'Номер зоны', 'Тип объекта', 'Статус', 'Адрес', 'Площадь',
                'Кадастровая стоимость', 'Дата определения стоимости', 'Тип права', 'Форма собственности',
                'Категория земель', 'Разрешенное использование', 'Связанные объекты',
                'Тип зоны', 'Тип зоны по ПЗЗ', 'Наименование объекта', 'Наименование по ПЗЗ',
                'Ограничения', 'Документ-основание', 'Орган, выдавший документ', 'Орган, утвердивший ПЗЗ',
                'Назначение', 'Наименование', 'Вид', 'Этаж', 'Количество этажей', 'Количество подземных этажей',
                'Год постройки', 'Год ввода в эксплуатацию', 'Материалы стен', 'Дата присвоения КН',
                'Дата постановки на учет', 'Дата регистрации', 'КН здания/сооружения', 'Номер на плане',
                'Протяженность', 'Глубина', 'Глубина залегания', 'Объем', 'Высота', 'Дата обновления', 'Номер'
            ];
            
            const allKeys = new Set();
            allResults.forEach(item => Object.keys(item).forEach(key => allKeys.add(key)));
            const finalHeaders = [...preferredOrder.filter(key => allKeys.has(key)), ...[...allKeys].filter(key => !preferredOrder.includes(key)).sort()];
            
            const dataForSheet = allResults.map(row => {
                const orderedRow = {};
                finalHeaders.forEach(header => {
                    orderedRow[header] = row[header] !== undefined ? row[header] : '';
                });
                return orderedRow;
            });

            const ws = XLSX.utils.json_to_sheet(dataForSheet, { header: finalHeaders });
            const wb = XLSX.utils.book_new();
            XLSX.utils.book_append_sheet(wb, ws, "Данные НСПД");

            const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19);
            const filename = `export_all_data_${timestamp}.xlsx`;

            XLSX.writeFile(wb, filename);
            showNotification('Экспорт в XLSX завершен.', 'success');

        } else {
            showNotification('Нет данных для экспорта в XLSX после обработки.', 'warning');
        }

    } catch (error) {
        console.error("Error during XLSX export:", error);
        showNotification('Произошла ошибка во время экспорта в XLSX.', 'error');
    } finally {
        exportButton.disabled = false;
        spinnerIcon.style.display = 'none';
        excelIcon.style.display = 'inline-block';
        progressBarContainer.style.display = 'none';
    }
}

function copyAndOpenOt() {
    const input = document.getElementById('cadastralNumber');
    const cadNum = input.value.trim();


    if (!cadNum) {
        return;
    }

  
    navigator.clipboard.writeText(cadNum)
        .then(() => {
            window.open('ot.html', '_blank');
        })
        .catch(err => {
            console.error('Ошибка копирования:', err);
            // Если не удалось скопировать, всё равно пытаемся открыть
            window.open('ot.html', '_blank');
        });
}


function buildApiUrl(path) {
    if (isNspdDirectDown) {
        // Если прямой доступ упал, заворачиваем путь в параметр 'target' для нашего прокси
        return `https://nsp-two.vercel.app/?target=${encodeURIComponent(path)}`;
    } else {
        // Иначе идем напрямую
        return `https://nspd.gov.ru${path}`;
    }
}


async function fetchWithFallback(path, options = {}) {
    const vercelProxyUrl = `https://nsp-two.vercel.app/?target=${encodeURIComponent(path)}`;
    const directUrl = `https://nspd.gov.ru${path}`;

  
    if (useVercelProxyMode && isProxyFallbackEnabled) {
        console.log("Using Vercel proxy (sticky mode)...");
        return fetch(vercelProxyUrl, options);
    }

 
    try {
        const response = await fetch(directUrl, options);
  
        if (!response.ok) {
         
            throw new Error(`Direct request failed with status: ${response.status}`);
        }
        return response; // Успешный прямой запрос
    } catch (error) {
        console.warn("Direct request to nspd.gov.ru failed:", error.message);
        
    
        if (isProxyFallbackEnabled) {
         
            useVercelProxyMode = true; 
            return fetch(vercelProxyUrl, options);
        } else {
         
            throw error;
        }
    }
}


function isAmbiguousZoneNumber(text) {
    const pattern = /^\d{2}:\d{2}-\d+\.\d+$/;
    return pattern.test(text.trim());
}



async function fetchZoneDataWithFallback(number, preferredSearchType) {
    const fallbackSearchType = preferredSearchType === '5' ? '7' : '5';
    const fetchers = {
        '5': fetchSingleZoneData,
        '7': fetchSingleTerritorialZoneData
    };
    let responseData;

    try {
        // 1. Первая попытка. Эта функция теперь может выбросить исключение (throw error).
        responseData = await fetchers[preferredSearchType](number);
        
        // Если ответ "Не найдена" (из-за 204), тоже считаем это ошибкой для fallback
        if (responseData.Статус === 'Не найдена') {
           throw new Error('Not Found by content');
        }
        return { result: responseData, type: preferredSearchType };

    } catch (error) {
        // 2. Блок catch теперь будет срабатывать и на HTTP 404, и на нашу ошибку 'Not Found by content'
        if (error.message.includes('404') || error.message.includes('Not Found')) {
            console.log(`Preferred type (${preferredSearchType}) for ${number} not found. Trying fallback (${fallbackSearchType})...`);
            try {
                // Запускаем второй запрос
                responseData = await fetchers[fallbackSearchType](number);
                return { result: responseData, type: fallbackSearchType };
            } catch (fallbackError) {
                // Если и вторая попытка не удалась
                console.error(`Fallback request for ${number} also failed:`, fallbackError);
                return { result: { 'Номер зоны': number, 'Статус': 'Не найден на обоих эндпоинтах' }, type: 'error' };
            }
        } else {
            // Если первая ошибка была не 404 (например, 500 или нет сети)
            console.error(`Initial request for ${number} failed with non-404 error:`, error);
            return { result: { 'Номер зоны': number, 'Статус': 'Ошибка запроса' }, type: 'error' };
        }
    }
}


function handleSuccessfulResponse(data) {
    if (!data.data || data.data.features.length === 0) {
        throw new Error('Данные не найдены в источнике.');
    }

    const feature = data.data.features[0];
    const properties = feature.properties;
    const options = properties.options;
    const geometry = feature.geometry;
    const geomId = feature.id; // ID, который используется как geomId или objdocId
    const categoryName = properties.categoryName;

    let secondaryPath = ''; // Переменная для хранения пути вторичного запроса

    // --- ОБНОВЛЕННАЯ ЛОГИКА ФОРМИРОВАНИЯ ЗАПРОСА СВЯЗАННЫХ ОБЪЕКТОВ ---
    
    // Сценарий 1: Ищем ОКС, расположенные на Земельном участке
    if (categoryName === "Земельные участки ЕГРН") {
        const categoryId = properties.category;
        const registersId = options.registersId;

        // Приоритетный метод: если есть registersId, используем его
        if (registersId) {
            secondaryPath = `/api/geoportal/v1/tab-group-data?tabClass=objectsList&objdocId=${geomId}&registersId=${registersId}`;
        } 
        // Запасной метод: если registersId нет
        else {
            secondaryPath = `/api/geoportal/v1/tab-group-data?tabClass=objectsList&categoryId=${categoryId}&geomId=${geomId}`;
        }
    } 
    // Сценарий 2: Ищем Земельный участок, на котором расположен ОКС
    else { 
        const categoryId = properties.category;
        const registersId = options.registersId;

        // Приоритетный метод: если есть registersId, используем его
        if (registersId) {
            secondaryPath = `/api/geoportal/v1/tab-values-data?tabClass=landLinks&objdocId=${geomId}&registersId=${registersId}`;
        } 
        // Запасной метод: если registersId нет, используем его для всех типов ОКС
        else {
            secondaryPath = `/api/geoportal/v1/tab-values-data?tabClass=landLinks&categoryId=${categoryId}&geomId=${geomId}`;
        }
    }

    // --- КОНЕЦ ОБНОВЛЕННОЙ ЛОГИКИ ---

   if (secondaryPath) {
        fetchWithFallback(secondaryPath)
            .then(response => response.ok ? response.json() : Promise.reject('Secondary request failed'))
            .then(data2 => {
                if (categoryName === "Земельные участки ЕГРН") {
                    const oknList = (data2?.object?.[0]?.value) || null;
                    // ИЗМЕНЕНИЕ: передаем geometry
                    updatePropertyData(options, properties, oknList, null, geometry);
                } else {
                    const landParcelList = (data2 && !data2.message && data2.value?.length > 0) ? data2.value : null;
                    // ИЗМЕНЕНИЕ: передаем geometry
                    updatePropertyData(options, properties, null, landParcelList, geometry);
                }
            })
            .catch(error => {
                // ИЗМЕНЕНИЕ: передаем geometry
                updatePropertyData(options, properties, null, null, geometry);
            });
    } else {
        // ИЗМЕНЕНИЕ: передаем geometry
        updatePropertyData(options, properties, null, null, geometry);
    }

    if (geometry && geometry.type) {
        switch (geometry.type) {
            case "Polygon": case "MultiPolygon": case "MultiLineString":
                currentCoords = geometry.coordinates;
                document.querySelector('.content-container').style.display = 'grid';
                setTimeout(() => drawScheme(), 0);
                break;
            case "Point":
                currentCoords = [geometry.coordinates];
                document.querySelector('.content-container').style.display = 'block';
                document.querySelector('.scheme-container').style.display = 'none';
                clearCanvas();
                break;
            default:
                document.querySelector('.content-container').style.display = 'block';
                document.querySelector('.scheme-container').style.display = 'none';
                showNotification('Тип геометрии не поддерживается: ' + geometry.type, 'error');
                clearCanvas();
        }
    } else {
        document.querySelector('.content-container').style.display = 'block';
        document.querySelector('.scheme-container').style.display = 'none';
        clearCanvas();
    }

    document.getElementById('resultTable').style.display = 'table';
    if (document.getElementById('virtualKeyboard').classList.contains('active')) {
        toggleVirtualKeyboard();
    }
}

function updateTableMskRow(mskName) {
    const rows = document.querySelectorAll('#resultTable tbody tr');
    let found = false;
    
    // Ищем существующую строку
    for (let row of rows) {
        if (row.cells[0].textContent.trim() === 'Система координат') {
            // Обновляем ячейку и добавляем иконку, если нужно
            row.cells[1].innerHTML = `<strong>${mskName} (выбрана вручную)</strong>
                                      <button class="copy-icon-button" onclick="copyRowContent(this)">
                                          <i class="fas fa-copy"></i>
                                      </button>`;
            // Добавляем эффект подсветки
            row.style.backgroundColor = '#e8f5e9'; 
            setTimeout(() => row.style.backgroundColor = '', 1000);
            found = true;
            break;
        }
    }

    // Если строки нет (например, её не было при первой отрисовке), добавляем её
    if (!found) {
        const tableBody = document.querySelector('#resultTable tbody');
        const tr = document.createElement('tr');
        tr.innerHTML = `<td>Система координат</td>
                        <td>
                            <strong>${mskName} (выбрана вручную)</strong>
                            <button class="copy-icon-button" onclick="copyRowContent(this)">
                                <i class="fas fa-copy"></i>
                            </button>
                        </td>`;
        tr.style.backgroundColor = '#e8f5e9';
        tableBody.appendChild(tr);
        setTimeout(() => tr.style.backgroundColor = '', 1000);
    }
}

async function fetchData() {
      userSelectedMsk = null;
    document.getElementById('archiveInfo').style.display = 'none';

    const cadastralNumberInput = document.getElementById('cadastralNumber');
    const inputValue = cadastralNumberInput.value.trim();

    if (!inputValue) {
        openSite();
        return;
    }
    
    if (inputValue.length > 200) {
        showNotification('Слишком длинный запрос', 'error');
        return; 
    }

    // НОВАЯ ПРОВЕРКА: Реестровый номер зоны
if (isRegistryZoneNumber(inputValue)) {
        // Нормализуем номер (заменяем запятую на точку)
        const normalizedZoneNumber = normalizeRegistryZoneNumber(inputValue);
        
        // Обновляем значение в поле ввода
        cadastralNumberInput.value = normalizedZoneNumber;
        
        document.title = `${normalizedZoneNumber}`;
        
        const signal = showLoader(`Поиск зоны: ${normalizedZoneNumber}`);
        
        try {
            const result = await fetchZoneByRegistryNumber(normalizedZoneNumber);
            
            if (!result) {
                showNotification('Зона не найдена ни в ЗОУИТ, ни в территориальных зонах', 'error');
                return;
            }
            
            const { data, searchType } = result;
            const feature = data.data.features[0];
            
            displayZoneData(feature, searchType);
            
            const zoneTypeName = searchType === 5 ? 'ЗОУИТ' : 'территориальной зоне';
            showNotification(`Объект найден в ${zoneTypeName}`, 'success');
            
        } catch (error) {
            if (error.name === 'AbortError') return;
            console.error("Ошибка при поиске зоны:", error);
            showNotification('Ошибка при поиске зоны', 'error');
        } finally {
            hideLoader();
        }
        return;
    }

    // Существующий код для кадастровых номеров
    if (isValidCadastralNumber(inputValue)) {
        document.title = `${inputValue}`;
        
        const signal = showLoader(`Поиск объекта: ${inputValue}`);
        
        const initialPath = `/api/geoportal/v2/search/geoportal?thematicSearchId=1&query=${encodeURIComponent(inputValue)}`;

        try {
            const response = await fetchWithFallback(initialPath, { signal });

            if (!response.ok) {
                const errorData = await response.json().catch(() => ({}));
                throw new Error(errorData.error || `Request failed with status ${response.status}`);
            }

            const data = await response.json();
            handleSuccessfulResponse(data);

        } catch (finalError) {
            if (finalError.name === 'AbortError') {
                return;
            }

            console.warn("API error, trying archive...", finalError);
            showNotification('Основные сервисы недоступны. Попытка загрузить из архива...', 'warning');
            
            await fetchDataFromArchive(); 
            return;
        } finally {
             hideLoader();
        }

    } else {
        // Существующий код для поиска по адресу
        const tokens = inputValue.split(/[\s,.]+/).filter(t => t.length > 0);
        const isValidAddress = tokens.length >= 3;

        if (!isValidAddress) {
            showNotification('Пожалуйста, уточните адрес', 'warning');
            return;
        }
        
        searchByAddress(inputValue);
    }
}

      // Функция для конвертации координат из EPSG:3857 в WGS84 (EPSG:4326)
        function convertToWGS84(x, y) {
            proj4.defs("EPSG:4326", "+proj=longlat +datum=WGS84 +no_defs");
            proj4.defs("EPSG:3857", "+proj=merc +a=6378137 +b=6378137 +lat_ts=0.0 +lon_0=0.0 +x_0=0.0 +y_0=0 +k=1.0 +units=m +nadgrids=@null +wktext +no_defs");
            return proj4("EPSG:3857", "EPSG:4326", [x, y]);
        }
        
        
        function haversineDistance(coord1, coord2) {
    const toRadians = (degrees) => degrees * (Math.PI / 180);

    const [lon1, lat1] = coord1;
    const [lon2, lat2] = coord2;

    const R = 6371000; // Радиус Земли в метрах
    const dLat = toRadians(lat2 - lat1);
    const dLon = toRadians(lon2 - lon1);

    const a =
        Math.sin(dLat / 2) * Math.sin(dLat / 2) +
        Math.cos(toRadians(lat1)) * Math.cos(toRadians(lat2)) *
        Math.sin(dLon / 2) * Math.sin(dLon / 2);

    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
    return R * c; // Расстояние в метрах
}


        // Функция для открытия Yandex Maps с метками всех точек
// Функция для открытия Yandex Maps с метками всех точек
function openYandexMaps() {
 if (!currentCoords || currentCoords.length === 0) {
        showNotification('Нет данных для отображения карты', 'error');
        return;
    }

    let wgs84Coords = [];
    let center;

   // MultiPolygon and Polygon
    if (currentCoords[0] && Array.isArray(currentCoords[0][0])) {
        if (Array.isArray(currentCoords[0][0][0])) { // MultiPolygon
            currentCoords.forEach(polygon => {
                polygon.forEach(ring => {
                    ring.forEach(coord => {
                        wgs84Coords.push(convertToWGS84(coord[0], coord[1]));
                    });
                });
            });
        } else { // Polygon
            currentCoords.forEach(ring => {
                ring.forEach(coord => {
                    wgs84Coords.push(convertToWGS84(coord[0], coord[1]));
                });
            });
        }
        center = wgs84Coords[0];
    // MultiLineString
    } else if (currentCoords[0] && Array.isArray(currentCoords[0])) {
        currentCoords.forEach(line => {
            line.forEach(coord => {
                wgs84Coords.push(convertToWGS84(coord[0], coord[1]));
            });
        });
        center = wgs84Coords[0];
    // Point
    } else {
        center = convertToWGS84(currentCoords[0][0], currentCoords[0][1]);
        wgs84Coords.push(center);
    }

    let url = `https://yandex.ru/maps/?l=sat%2Cskl&ll=${center[0]},${center[1]}&z=20`;
    const points = wgs84Coords.map(coord => `${coord[0]},${coord[1]}`).join('~');
    url += `&pt=${points}`;
    window.open(url);
}

// Функция для открытия Google Maps с меткой первой точки
 function openGoogleMaps() {
    if (!currentCoords || currentCoords.length === 0) {
        showNotification('Нет данных для отображения карты', 'error');
        return;
    }
    
     let lon, lat;

    // MultiPolygon
    if (currentCoords[0] && Array.isArray(currentCoords[0][0]) && Array.isArray(currentCoords[0][0][0])) {
        [lon, lat] = convertToWGS84(currentCoords[0][0][0][0], currentCoords[0][0][0][1]);
    // Polygon
    } else if (currentCoords[0] && Array.isArray(currentCoords[0][0])) {
        [lon, lat] = convertToWGS84(currentCoords[0][0][0], currentCoords[0][0][1]);
    // MultiLineString
    } else if (currentCoords[0] && Array.isArray(currentCoords[0])) {
        [lon, lat] = convertToWGS84(currentCoords[0][0][0], currentCoords[0][0][1]); // Первая точка первой линии
    // Point
    } else {
        [lon, lat] = convertToWGS84(currentCoords[0][0], currentCoords[0][1]);
    }


    const url = `https://www.google.com/maps?q=${lat},${lon}`;
    window.open(url);
}


function searchOnYandexMap() {
    // Ищем строку с адресом в таблице
    const addressRow = Array.from(document.querySelectorAll('#resultTable tr')).find(row => {
        return row.cells[0].textContent.trim() === 'Адрес';
    });

    if (!addressRow) {
        showNotification('Адрес не найден в таблице', 'error');
        return;
    }

    // Извлекаем значение адреса из соседней ячейки
  //  const address = addressRow.cells[1].textContent.trim();
    const address = addressRow.cells[1].textContent
    .trim() // Убираем пробелы в начале и конце
    .replace(/\s+/g, ' '); // Заменяем множественные пробелы на один
    
    if (!address) {
        showNotification('Адрес не указан', 'error');
        return;
    }

    // Формируем URL для поиска на Яндекс.Картах
    const yandexMapsUrl = `https://yandex.ru/maps/?text=${encodeURIComponent(address)}`;

    // Открываем новое окно с Яндекс.Картами
    window.open(yandexMapsUrl, '_blank');
}







// Обновление данных в таблице
// Функция для форматирования даты в формат "дд.мм.гггг"
function formatDate(dateString) {
    if (!dateString) return ''; // Если дата отсутствует, возвращаем пустую строку

    // Убираем временную часть, если она есть
    const dateOnly = dateString.split('T')[0];
    const [year, month, day] = dateOnly.split('-');
    return `${day}.${month}.${year}`;
}

// Функция для форматирования числа с пробелами (теперь и для целых чисел)
function formatNumberWithSpaces(number) {
    if (typeof number !== 'number') {
        return number; // Возвращаем как есть, если это не число
    }

    const numStr = String(number); // Преобразуем в строку

     // Проверяем, есть ли дробная часть
    if (numStr.includes('.')) {
        const parts = number.toFixed(2).split('.');
        parts[0] = parts[0].replace(/\B(?=(\d{3})+(?!\d))/g, ' ');
        return parts.join('.');
    }
    else
    {
        //Если дробной части нет
        return numStr.replace(/\B(?=(\d{3})+(?!\d))/g, ' ');
    }
}

// Функция для копирования содержимого ячейки
function copyRowContent(buttonElement) {
    // Предотвращаем срабатывание других событий
    event.stopPropagation(); 
    const cell = buttonElement.parentElement;
    let textToCopy = '';

    // Специальная обработка для строк с кадастровыми номерами (ОКС на ЗУ, Расположен на ЗУ)
    const cadListSpans = cell.querySelectorAll('div > span');
    if (cadListSpans.length > 0) {
        // Извлекаем только кадастровые номера
        const cadNumbers = Array.from(cadListSpans).map(span => span.textContent.trim());
        // Соединяем их через перенос строки для удобства вставки
        textToCopy = cadNumbers.join('\n');
    } else {
        // Для всех остальных строк просто копируем их текстовое содержимое
        const cellClone = cell.cloneNode(true);
        const buttonInClone = cellClone.querySelector('.copy-icon-button');
        if (buttonInClone) {
            cellClone.removeChild(buttonInClone);
        }
        textToCopy = cellClone.textContent.trim();
    }

   
    if (textToCopy) {
        const garbagePrefix = "Местоположение установлено относительно ориентира, расположенного в границах участка. Почтовый адрес ориентира:";
        
        
        if (textToCopy.includes(garbagePrefix)) {
            textToCopy = textToCopy.replace(garbagePrefix, "");
        }
        
       
        textToCopy = textToCopy.replace(/\.$/, "");

        textToCopy = textToCopy.trim();
    }
   

    if (textToCopy) {
        navigator.clipboard.writeText(textToCopy)
            .then(() => {
                showNotification('Скопировано в буфер обмена', 'success');
            })
            .catch(err => {
                console.error('Ошибка при копировании:', err);
                showNotification('Не удалось скопировать', 'error');
            });
    }
}

// --- НОВАЯ ФУНКЦИЯ: Поиск родительского ЕЗ в фоне ---
async function searchAndShowParentEz(childCadNumber) {
    if (!supabaseClient) return;

    try {
        const { data, error } = await supabaseClient
            .from('EZ')
            .select('EZ')
            .eq('ZU', childCadNumber)
            .limit(1);

        if (data && data.length > 0) {
            const parentEz = data[0].EZ;
            
            // Находим таблицу
            const tableBody = document.querySelector('#resultTable tbody');
            if (!tableBody) return;

            // Создаем новую строку
            const tr = document.createElement('tr');
            tr.style.animation = 'rowFadeIn 0.5s ease-out'; // Анимация появления
            tr.innerHTML = `<td>Входит в состав ЕЗ</td>
                            <td>
                                <strong>${parentEz}</strong>
                                <button class="copy-icon-button" onclick="copyRowContent(this)">
                                    <i class="fas fa-copy"></i>
                                </button>
                            </td>`;
            
            // Ищем строку "Вид", чтобы вставить после неё
            const rows = Array.from(tableBody.querySelectorAll('tr'));
            const subtypeRow = rows.find(r => r.cells[0].textContent === 'Вид');
            
            if (subtypeRow) {
                subtypeRow.insertAdjacentElement('afterend', tr);
            } else {
                // Если строку "Вид" не нашли, добавляем в начало списка
                tableBody.insertBefore(tr, tableBody.firstChild);
            }
            
            // Опционально: уведомление
            // showNotification(`Найдено ЕЗ: ${parentEz}`, 'success');
        }
    } catch (err) {
        console.error('Ошибка при поиске родительского ЕЗ:', err);
    }
}

function updatePropertyData(options, properties, oknList = null, landParcelList = null, geometry = null) {
    const tableBody = document.querySelector('#resultTable tbody');
    tableBody.innerHTML = '';

    const categoryName = properties.categoryName;
    let data = [];

    const cadastralNumberForMsk = options.cad_num || options.cad_number;
    let mskName = 'Не определена'; 

    if (userSelectedMsk) {
        mskName = `${userSelectedMsk.text} (выбрана вручную)`;
    } else {
        const mskSystem = identifyMskSystem(cadastralNumberForMsk);
        if (mskSystem) {
            mskName = mskSystem.text;
        }
    }
    
  

    data.push({ field: 'Категория', value: categoryName });

    let displayRightType;
    if (options.right_type) {
        displayRightType = options.right_type;
        if (options.ownership_type) {
            displayRightType += ` (${options.ownership_type})`;
        }
    } else if (options.ownership_type) {
        displayRightType = `Не зарегистрировано (${options.ownership_type})`;
    } else {
        displayRightType = '-';
    }
    data.push({ field: 'Тип права', value: displayRightType });
    const displayOwnershipType = options.ownership_type || '-';
    data.push({ field: 'Форма собственности', value: displayOwnershipType });

    const commonFields = [
        { field: 'Кадастровый номер', value: options.cad_num || options.cad_number },
        { field: 'Статус', value: options.status || options.common_data_status },
        { field: 'Адрес', value: options.readable_address || options.address_readable_address },
        {
            field: 'Кадастровая стоимость',
            value: () => {
                let costValue = options.cost_value;
                let area = null;
                if (categoryName === "Земельные участки ЕГРН") {
                    if (options.specified_area) { area = parseFloat(options.specified_area); }
                    else if (options.land_record_area_verified) { area = parseFloat(options.land_record_area_verified); }
                    else if (options.declared_area) { area = parseFloat(options.declared_area); }
                    else if (options.land_record_area_declaration) { area = parseFloat(options.land_record_area_declaration); }
                    else if (options.land_record_area) { area = parseFloat(options.land_record_area); }
                } else if (categoryName.includes("Помещения") || categoryName.includes("Здания")) {
                    area = options.area ? parseFloat(options.area) : null;
                } else if (categoryName.includes("Сооружения")) {
                    area = options.params_area ? parseFloat(options.params_area) : null;
                }
                if (costValue && !isNaN(parseFloat(costValue))) {
                    costValue = parseFloat(costValue);
                    let formattedCost = formatNumberWithSpaces(costValue) + " руб.";
                    if (area && !isNaN(area) && area > 0) {
                        const costPerSqMeter = costValue / area;
                        formattedCost += ` (${formatNumberWithSpaces(Math.round(costPerSqMeter))} руб за 1 м²)`;
                    }
                    return formattedCost;
                }
                return '';
            }
        },
        { field: 'Дата определения стоимости', value: formatDate(options.cost_determination_date) },
        { field: 'Дата обновления', value: formatDate(properties.systemInfo?.updated) || 'Нет данных' }
    ];
    
    const createCadastralListHtml = (cadList) => {
        return cadList.map(cn => `
            <div style="display: flex; align-items: center; margin-bottom: 3px;">
                <span>${cn}</span>
                <img src="img/savannah.png" 
                     onclick="copyAndOpen('${cn}')" 
                     style="cursor: pointer; width: 16px; height: 16px; margin-left: 8px; vertical-align: middle;" 
                     title="Скопировать и открыть ${cn}">
                <img src="img/house.png" 
                     onclick="fetchAndDrawLinkedObject('${cn}')"
                     style="cursor: pointer; width: 16px; height: 16px; margin-left: 5px; vertical-align: middle;"
                     title="Показать на схеме ${cn}">
            </div>
        `).join('');
    };

    if (categoryName === "Земельные участки ЕГРН") {
        const subtype = options.subtype || options.land_record_subtype;
        if (subtype) {
            data.push({ field: 'Вид', value: subtype });
        }
        const ezLinkContainer = document.getElementById('ezLinkContainer');
        if (subtype === "Обособленный участок" || subtype === "Единое землепользование" || subtype === "Условный участок") {
            ezLinkContainer.style.display = 'block';
            if (subtype === "Обособленный участок") {
                const currentCadNum = options.cad_num || options.cad_number;
                searchAndShowParentEz(currentCadNum);
            }
            const ezButton = document.getElementById('ezLink');
            ezButton.replaceWith(ezButton.cloneNode(true));
            document.getElementById('ezLink').onclick = function(e) {
                e.preventDefault();
                e.stopPropagation();
                const cadastralNumber = options.cad_num || options.cad_number;
                if (cadastralNumber) {
                    navigator.clipboard.writeText(cadastralNumber)
                        .then(() => window.open('ez.html', '_blank'))
                        .catch(err => {
                            console.error('Ошибка при копировании:', err);
                            showNotification('Не удалось скопировать кадастровый номер', 'error');
                        });
                }
                return false;
            };
        } else {
            ezLinkContainer.style.display = 'none';
        }
        data.push(commonFields[0]);
        data.push(commonFields[1]);
       
        const dateAssigned = options.land_record_reg_date || options.registration_date;
        if (dateAssigned) {
            data.push({ field: 'Дата присвоения', value: formatDate(dateAssigned) });
        }

        if (options.quarter_cad_number) {
            data.push({ field: 'Кадастровый номер квартала', value: options.quarter_cad_number });
        }
        let areaText = '';
        if (options.specified_area) { areaText = `${formatNumberWithSpaces(options.specified_area)} м² (уточненная)`; }
        else if (options.land_record_area_verified) { areaText = `${formatNumberWithSpaces(options.land_record_area_verified)} м² (уточненная)`; }
        else if (options.declared_area) { areaText = `${formatNumberWithSpaces(options.declared_area)} м² (декларированная)`; }
        else if (options.land_record_area_declaration) { areaText = `${formatNumberWithSpaces(options.land_record_area_declaration)} м² (декларированная)`; }
        else if (options.land_record_area) { areaText = `${formatNumberWithSpaces(options.land_record_area)} м² (декларированная)`; }
        data.push({ field: 'Площадь', value: areaText });
        data.push(commonFields[2]);
        data.push(commonFields[3]);
        data.push(commonFields[4]);
        data.push({ field: 'Категория земель', value: options.land_record_category_type });
        data.push({ field: 'Разрешённое использование', value: options.permitted_use_established_by_document });
        
        data.push({
            field: 'ОКС на ЗУ',
            value: (oknList && oknList.length > 0) ? createCadastralListHtml(oknList) : '-'
        });

        data.push(commonFields[5]);
        data.push({ field: 'Дата внесения', value: formatDate(properties.systemInfo?.inserted) || '' });

    } else if (categoryName === "Помещения" || categoryName === "Помещения ЕГРН") {
        data.push(commonFields[0]);
        data.push(commonFields[1]);
        data.push({ field: 'Площадь', value: options.area ? `${options.area} м²` : '' });
        data.push(commonFields[2]);
        data.push(commonFields[3]);
        data.push(commonFields[4]);
        data.push({ field: 'Назначение', value: options.purpose });
        data.push({ field: 'Тип помещения', value: options.params_type });
        data.push({ field: 'Этаж', value: Array.isArray(options.floor) ? options.floor.join(', ') : options.floor });
        data.push({ field: 'Кадастровый номер здания', value: options.parent_cad_number });
        
        data.push({
            field: 'Расположен на ЗУ',
            value: (landParcelList && landParcelList.length > 0) ? createCadastralListHtml(landParcelList) : '-'
        });
        
        data.push({ field: 'Общее имущество', value: options.common_property === "false" ? "Нет" : "Да" });
        data.push({ field: 'Имущество общего пользования', value: options.service_common_property });
        data.push({ field: 'Дата регистрации', value: formatDate(options.registration_date) });
        data.push({ field: 'Кадастровый номер объекта', value: options.facility_cad_number });
        data.push(commonFields[5]);
        data.push({ field: 'Дата внесения', value: formatDate(properties.systemInfo?.inserted) || '' });

    } else if (categoryName === "Сооружения" || categoryName === "Сооружения ЕГРН") {
        data.push(commonFields[0]);
        
        if (options.object_type_value) {
            data.push({ field: 'Вид', value: options.object_type_value });
        }

        data.push(commonFields[1]);
        data.push(commonFields[2]);
        data.push({ field: 'Площадь', value: options.params_area ? `${options.params_area} м²` : 'Нет данных' });
        data.push(commonFields[3]);
        data.push(commonFields[4]);
        data.push({ field: 'Наименование', value: options.params_name || 'Нет данных' });
        data.push({ field: 'Назначение', value: options.params_purpose || 'Нет данных' });
        
        data.push({
            field: 'Расположен на ЗУ',
            value: (landParcelList && landParcelList.length > 0) ? createCadastralListHtml(landParcelList) : '-'
        });

        data.push({ field: 'Год постройки', value: options.params_year_built || options.year_built || 'Нет данных' });
        data.push({ field: 'Год ввода в эксплуатацию', value: options.params_year_commisioning || options.year_commisioning || 'Нет данных' });
        data.push({ field: 'Дата регистрации', value: formatDate(options.registration_date) || 'Нет данных' });
        data.push({ field: 'Высота', value: options.params_height ? `${options.params_height} м` : 'Нет данных' });
        data.push({ field: 'Глубина залегания', value: options.params_occurence_depth ? `${options.params_occurence_depth} м` : 'Нет данных' });
        data.push({ field: 'Объем', value: options.params_volume ? `${options.params_volume} м³` : 'Нет данных' });
        
        const ext = options.params_extension || options.extension;
        data.push({ field: 'Протяженность', value: ext ? `${ext} м` : 'Нет данных' });
        
        data.push({ field: 'Количество этажей', value: options.params_floors || 'Нет данных' });
        data.push({ field: 'Количество подземных этажей', value: options.params_underground_floors || 'Нет данных' });
        data.push({ field: 'Кадастровый номер квартала', value: options.quarter_cad_number || 'Нет данных' });
        
        data.push({ field: 'Разрешенное использование', value: options.permitted_uses_name });

        data.push(commonFields[5]);
        data.push({ field: 'Дата внесения', value: formatDate(properties.systemInfo?.inserted) || '' });

    } else if (categoryName === "Здания" || categoryName === "Здания ЕГРН") {
        data.push(commonFields[0]);
        data.push(commonFields[1]);
        data.push({ field: 'Площадь', value: options.area ? `${options.area} м²` : '' });
        data.push(commonFields[2]);
        data.push(commonFields[3]);
        data.push(commonFields[4]);
        
        data.push({ field: 'УПКС', value: options.cost_index });
        data.push({ field: 'Дата применения КС', value: formatDate(options.cost_application_date) });
        data.push({ field: 'Дата внесения КС', value: formatDate(options.cost_registration_date) });

        data.push({ field: 'Назначение', value: options.purpose });
        data.push({ field: 'Наименование', value: options.name || options.building_name });
        data.push({ field: 'Вид объекта', value: options.build_record_type_value }); 

        data.push({
            field: 'Расположен на ЗУ',
            value: (landParcelList && landParcelList.length > 0) ? createCadastralListHtml(landParcelList) : '-'
        });

        data.push({ field: 'Количество этажей', value: options.floors });
        data.push({ field: 'Год постройки', value: options.year_built });
        
        data.push({ field: 'Год ввода в эксплуатацию', value: options.year_commissioning || options.year_commisioning });

        data.push({ field: 'Площадь здания', value: options.build_record_area ? `${options.build_record_area} м²` : '' });
        data.push({ field: 'Дата регистрации здания', value: formatDate(options.build_record_registration_date) });
        data.push({ field: 'Материалы здания', value: options.materials });
        data.push({ field: 'Разрешенное использование', value: options.permitted_use_name });
        data.push({ field: 'Культурное наследие', value: options.cultural_heritage_val }); 
        data.push({ field: 'Кадастровый номер квартала', value: options.quarter_cad_number });
        data.push({ field: 'Количество подземных этажей', value: options.underground_floors });
        data.push({ field: 'Объединенные кадастровые номера', value: options.united_cad_numbers });
        data.push(commonFields[5]);
        data.push({ field: 'Дата внесения', value: formatDate(properties.systemInfo?.inserted) || '' });
    }
    
    data.push({ field: 'Система координат', value: mskName });

    if (geometry && geometry.type === 'Point' && Array.isArray(geometry.coordinates)) {
        const x = geometry.coordinates[0];
        const y = geometry.coordinates[1];
        data.push({ 
            field: 'Координаты (X, Y)', 
            value: `${formatNumberWithSpaces(x)}; ${formatNumberWithSpaces(y)}` 
        });
    }

    data = data.filter(item => {
        const value = typeof item.value === 'function' ? item.value() : item.value;
        return value !== null && value !== undefined && value !== '' && value !== '-';
    });

    tableBody.innerHTML = '';

    data.forEach(row => {
        const tr = document.createElement('tr');
        const value = typeof row.value === 'function' ? row.value() : row.value;

        const isHtml = /<[a-z][\s\S]*>/i.test(value);
        
        const valueCellContent = isHtml ? value : `<strong>${value}</strong>`;
        
        tr.innerHTML = `<td>${row.field}</td>
                        <td>
                            ${valueCellContent}
                            <button class="copy-icon-button" onclick="copyRowContent(this)">
                                <i class="fas fa-copy"></i>
                            </button>
                        </td>`;

        tableBody.appendChild(tr);
    });
}


function calculateDistance(coord1, coord2) {
    const dx = coord2[0] - coord1[0];
    const dy = coord2[1] - coord1[1];
    return Math.sqrt(dx * dx + dy * dy);
}


function drawScheme() {
    const canvas = document.getElementById('schemeCanvas');
    const ctx = canvas.getContext('2d');
    schemeParams = {};

    const container = document.querySelector('.scheme-container');
    if (container.style.display === 'none') {
        container.style.display = 'block';
    }

    canvas.width = container.offsetWidth;
    canvas.height = container.offsetHeight;

    ctx.clearRect(0, 0, canvas.width, canvas.height);

    if (!currentCoords || currentCoords.length === 0) {
        return;
    }

    let allCoords = [];

    if (currentCoords[0] && Array.isArray(currentCoords[0][0])) {
        if (Array.isArray(currentCoords[0][0][0])) {
            currentCoords.forEach(polygon => {
                polygon.forEach(ring => {
                    allCoords = allCoords.concat(ring.map(coord => [coord[0], coord[1]]));
                });
            });
        } else {
            currentCoords.forEach(ring => {
                allCoords = allCoords.concat(ring.map(coord => [coord[0], coord[1]]));
            });
        }
    } else if (currentCoords[0] && Array.isArray(currentCoords[0])) {
        currentCoords.forEach(line => {
            allCoords = allCoords.concat(line.map(coord => [coord[0], coord[1]]));
        });
    } else {
        return;
    }

    const minX = Math.min(...allCoords.map(p => p[0]));
    const maxX = Math.max(...allCoords.map(p => p[0]));
    const minY = Math.min(...allCoords.map(p => p[1]));
    const maxY = Math.max(...allCoords.map(p => p[1]));

    const width = maxX - minX;
    const height = maxY - minY;
    const padding = 40;

    const scaleX = (canvas.width - padding * 2) / width;
    const scaleY = (canvas.height - padding * 2) / height;
    const scale = Math.min(scaleX, scaleY);

    const offsetX = (canvas.width - width * scale) / 2;
    const offsetY = (canvas.height - height * scale) / 2;

    schemeParams = { minX, minY, scale, offsetX, offsetY };

    function calculateSphericalPolygonArea(coords) {
        if (coords.length < 3) return 0;
        const R = 6371000;
        let area = 0;
        const latLonCoords = coords.map(coord => {
            const [lon, lat] = convertToWGS84(coord[0], coord[1]);
            return [lon * Math.PI / 180, lat * Math.PI / 180];
        });
        for (let i = 0; i < latLonCoords.length; i++) {
            const j = (i + 1) % latLonCoords.length;
            area += (latLonCoords[j][0] - latLonCoords[i][0]) *
                (2 + Math.sin(latLonCoords[i][1]) + Math.sin(latLonCoords[j][1]));
        }
        area = area * (R * R) / 2;
        return area;
    }

    function calculateTotalArea(rings) {
        if (!rings || rings.length === 0) return 0;
        let totalArea = 0;
        const outerArea = calculateSphericalPolygonArea(rings[0]);
        totalArea = Math.abs(outerArea);
        if (rings.length > 1) {
            for (let i = 1; i < rings.length; i++) {
                const innerArea = calculateSphericalPolygonArea(rings[i]);
                totalArea -= Math.abs(innerArea);
            }
        }
        return totalArea;
    }

    function calculatePerimeter(ring) {
        if (ring.length < 2) return 0;
        let perimeter = 0;
        const latLonCoords = ring.map(coord => convertToWGS84(coord[0], coord[1]));
        for (let i = 0; i < latLonCoords.length - 1; i++) {
            perimeter += haversineDistance(latLonCoords[i], latLonCoords[i + 1]);
        }
        perimeter += haversineDistance(latLonCoords[latLonCoords.length - 1], latLonCoords[0]);
        return perimeter;
    }

    ctx.beginPath();

    const traceRing = (ring) => {
        ring.forEach((coord, index) => {
            const x = offsetX + (coord[0] - minX) * scale;
            const y = canvas.height - (offsetY + (coord[1] - minY) * scale);
            if (index === 0) ctx.moveTo(x, y);
            else ctx.lineTo(x, y);
        });
        ctx.closePath();
    };

    if (currentCoords[0] && Array.isArray(currentCoords[0][0])) {
        if (Array.isArray(currentCoords[0][0][0])) {
            currentCoords.forEach(polygon => {
                polygon.forEach(ring => traceRing(ring));
            });
        } else {
            currentCoords.forEach(ring => traceRing(ring));
        }

        ctx.fillStyle = 'rgba(33, 150, 243, 0.3)';
        ctx.fill('evenodd');
        ctx.lineWidth = 1;
        ctx.strokeStyle = '#2196F3';
        ctx.stroke();

    } else if (currentCoords[0] && Array.isArray(currentCoords[0])) {
        currentCoords.forEach(line => {
            line.forEach((coord, index) => {
                const x = offsetX + (coord[0] - minX) * scale;
                const y = canvas.height - (offsetY + (coord[1] - minY) * scale);
                if (index === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            });
        });
        ctx.lineWidth = 2;
        ctx.strokeStyle = '#2196F3';
        ctx.stroke();
    }

    const drawPointsAndLabels = (polygonCoords) => {
        const labelOffset = 12;
        const minDistance = 20;
        let previousLabelX = null;
        let previousLabelY = null;
        polygonCoords.forEach((coord, index) => {
            const x = offsetX + (coord[0] - minX) * scale;
            const y = canvas.height - (offsetY + (coord[1] - minY) * scale);
            ctx.beginPath();
            ctx.arc(x, y, 4, 0, Math.PI * 2);
            ctx.fillStyle = '#FF4081';
            ctx.fill();
            if (index === polygonCoords.length - 1) {
                const firstX = offsetX + (polygonCoords[0][0] - minX) * scale;
                const firstY = canvas.height - (offsetY + (polygonCoords[0][1] - minY) * scale);
                if (Math.abs(x - firstX) < 1 && Math.abs(y - firstY) < 1) {
                    return;
                }
            }
            if (previousLabelX !== null && previousLabelY !== null) {
                const distance = Math.sqrt((x - previousLabelX) ** 2 + (y - previousLabelY) ** 2);
                if (distance < minDistance) {
                    return;
                }
            }
            ctx.fillStyle = '#333';
            ctx.font = '10px Arial';
            ctx.fillText(index + 1, x + labelOffset, y - labelOffset);
            previousLabelX = x + labelOffset;
            previousLabelY = y - labelOffset;
        });
    };

    if (currentCoords[0] && Array.isArray(currentCoords[0][0])) {
        if (Array.isArray(currentCoords[0][0][0])) {
            currentCoords.forEach(polygon => {
                polygon.forEach(ring => drawPointsAndLabels(ring));
            });
        } else {
            currentCoords.forEach(ring => drawPointsAndLabels(ring));
        }
    } else if (currentCoords[0] && Array.isArray(currentCoords[0])) {
        currentCoords.forEach(line => drawPointsAndLabels(line));
    }

    const drawDistances = (coords) => {
        ctx.fillStyle = '#000';
        ctx.font = '12px Arial';
        const isPointVisible = (x, y) => x >= 0 && x <= canvas.width && y >= 0 && y <= canvas.height;
        for (let i = 0; i < coords.length - 1; i++) {
            const [x1, y1] = coords[i];
            const [x2, y2] = coords[i + 1];
            const [lon1, lat1] = convertToWGS84(x1, y1);
            const [lon2, lat2] = convertToWGS84(x2, y2);
            const distance = haversineDistance([lon1, lat1], [lon2, lat2]);
            if (distance === 0) continue;
            const canvasX1 = offsetX + (x1 - minX) * scale;
            const canvasY1 = canvas.height - (offsetY + (y1 - minY) * scale);
            const canvasX2 = offsetX + (x2 - minX) * scale;
            const canvasY2 = canvas.height - (offsetY + (y2 - minY) * scale);
            const midX = (canvasX1 + canvasX2) / 2;
            const midY = (canvasY1 + canvasY2) / 2;
            if (isPointVisible(midX, midY)) {
                ctx.fillText(`${distance.toFixed(1)} м`, midX, midY);
            }
        }
        if (currentCoords[0] && Array.isArray(currentCoords[0][0]) && Array.isArray(currentCoords[0][0][0])) {
            const [x1, y1] = coords[coords.length - 1];
            const [x2, y2] = coords[0];
            const [lon1, lat1] = convertToWGS84(x1, y1);
            const [lon2, lat2] = convertToWGS84(x2, y2);
            const distance = haversineDistance([lon1, lat1], [lon2, lat2]);
            if (distance !== 0) {
                const canvasX1 = offsetX + (x1 - minX) * scale;
                const canvasY1 = canvas.height - (offsetY + (y1 - minY) * scale);
                const canvasX2 = offsetX + (x2 - minX) * scale;
                const canvasY2 = canvas.height - (offsetY + (y2 - minY) * scale);
                const midX = (canvasX1 + canvasX2) / 2;
                const midY = (canvasY1 + canvasY2) / 2;
                if (isPointVisible(midX, midY)) {
                    ctx.fillText(`${distance.toFixed(1)} м`, midX, midY);
                }
            }
        }
    };

    if (showDistanceLabels) {
        if (currentCoords[0] && Array.isArray(currentCoords[0][0])) {
            if (Array.isArray(currentCoords[0][0][0])) {
                currentCoords.forEach(polygon => {
                    polygon.forEach(ring => drawDistances(ring));
                });
            } else {
                currentCoords.forEach(ring => drawDistances(ring));
            }
        } else if (currentCoords[0] && Array.isArray(currentCoords[0])) {
            currentCoords.forEach(line => drawDistances(line));
        }
        let objectTypeInfo = "";
        let objectCount = 0;
        let areas = [];
        let perimeters = [];
        if (currentCoords[0] && Array.isArray(currentCoords[0][0]) && Array.isArray(currentCoords[0][0][0])) {
            objectTypeInfo = "Контур: ";
            objectCount = currentCoords.length;
            currentCoords.forEach((polygon, index) => {
                const area = calculateTotalArea(polygon);
                areas.push({ index: index + 1, value: Math.round(area * 1.0046705998033432) });
                const perimeter = calculatePerimeter(polygon[0]);
                perimeters.push({ index: index + 1, value: Math.round(perimeter) });
            });
        } else if (currentCoords[0] && Array.isArray(currentCoords[0][0])) {
            objectTypeInfo = "Контур: ";
            objectCount = 1;
            const area = calculateTotalArea(currentCoords);
            areas.push({ index: 1, value: Math.round(area * 1.0046705998033432) });
            const perimeter = calculatePerimeter(currentCoords[0]);
            perimeters.push({ index: 1, value: Math.round(perimeter) });
        } else if (currentCoords[0] && Array.isArray(currentCoords[0])) {
            objectTypeInfo = "Контуров: ";
            objectCount = currentCoords.length;
        }
        ctx.fillStyle = '#333';
        ctx.font = '14px Arial';
        const lineHeight = 20;
        let yOffset = canvas.height - 10;
        const countText = objectCount > 0 ? `${objectCount}` : "0";
        ctx.fillText(`${objectTypeInfo}${countText}`, 10, yOffset);
        yOffset -= lineHeight;
        if (areas.length > 0) {
            areas.forEach((areaObj, idx) => {
                const formattedArea = formatNumberWithSpaces(areaObj.value);
                ctx.fillText(`Площадь (${areaObj.index}): ${formattedArea} м²`, 10, yOffset);
                yOffset -= lineHeight;
                const perimeterObj = perimeters[idx];
                const formattedPerimeter = formatNumberWithSpaces(perimeterObj.value);
                ctx.fillText(`Периметр (${perimeterObj.index}): ${formattedPerimeter} м`, 10, yOffset);
                yOffset -= lineHeight;
            });
        }
    }
}



// Функция для проверки пересечения подписи с линией
function isLabelOverLine(ctx, x1, y1, x2, y2, textX, textY, textWidth, padding) {
    const textHeight = parseInt(ctx.font);
    const rectLeft = textX - padding;
    const rectRight = textX + textWidth + padding;
    const rectTop = textY - textHeight - padding;
    const rectBottom = textY + padding;
    
    // Проверка, если линия горизонтальна
    if (Math.abs(y1 - y2) < 1) {
      // Проверяем, что линия находится внутри прямоугольника
     if (y1 > rectTop && y1 < rectBottom && 
            ((x1 > rectLeft && x1 < rectRight) || (x2 > rectLeft && x2 < rectRight))) {
        return true;
    }

     }

      // Проверка, если линия вертикальна
    if (Math.abs(x1 - x2) < 1) {
        // Проверяем, что линия находится внутри прямоугольника
     if (x1 > rectLeft && x1 < rectRight && 
            ((y1 > rectTop && y1 < rectBottom) || (y2 > rectTop && y2 < rectBottom))) {
       return true;
      }
    }

    // Общая проверка для наклонных линий
    const lineStart = {x: x1, y: y1};
    const lineEnd = {x: x2, y: y2};
    const lineRect = {x: rectLeft, y: rectTop, w: rectRight - rectLeft, h: rectBottom - rectTop};
    
     if (intersectsLineRectangle(lineStart, lineEnd, lineRect)) {
        return true;
    }

    return false;
}

function intersectsLineRectangle(lineStart, lineEnd, rect) {
    // Функция для проверки пересечения линии с отрезком
    const lineToSegment = (p1, p2, p3, p4) => {
        const det = (p2.x - p1.x) * (p4.y - p3.y) - (p2.y - p1.y) * (p4.x - p3.x);
        if (det === 0) return false;

        const lambda = ((p3.x - p1.x) * (p4.y - p3.y) - (p3.y - p1.y) * (p4.x - p3.x)) / det;
        const mu = ((p1.x - p3.x) * (p2.y - p1.y) - (p1.y - p3.y) * (p2.x - p1.x)) / -det;

        return lambda >= 0 && lambda <= 1 && mu >= 0 && mu <= 1;
    };
   
    // Проверяем пересечение с каждой стороной прямоугольника
    return (
        lineToSegment(lineStart, lineEnd, {x: rect.x, y: rect.y}, {x: rect.x + rect.w, y: rect.y}) || //top
        lineToSegment(lineStart, lineEnd, {x: rect.x + rect.w, y: rect.y}, {x: rect.x + rect.w, y: rect.y + rect.h}) || //right
        lineToSegment(lineStart, lineEnd, {x: rect.x + rect.w, y: rect.y + rect.h}, {x: rect.x, y: rect.y + rect.h}) || //bottom
        lineToSegment(lineStart, lineEnd, {x: rect.x, y: rect.y + rect.h}, {x: rect.x, y: rect.y})   //left

    );
}


// Функция очистки canvas
function clearCanvas() {
    const canvas = document.getElementById('schemeCanvas');
    const ctx = canvas.getContext('2d');
    ctx.clearRect(0, 0, canvas.width, canvas.height);
}



// Функция для форматирования кадастрового номера с учетом настройки
function formatCadastralNumber(input) {
 
    if (input.value.includes('-')) {
        return;
    }

    let value = input.value.replace(/\D/g, ''); // Убираем все нецифровые символы
    let formatted = '';

    if (value.length > 0) formatted += value.slice(0, 2); // Первые 2 цифры
    if (value.length > 2) formatted += ':' + value.slice(2, 4); // Следующие 2 цифры

    // Определяем количество знаков после второго двоеточия
    const firstTwoDigits = value.slice(0, 2);
    const isSixDigits = sixDigitsRegions.includes(firstTwoDigits);
    const digitsAfterSecondColon = isSixDigits ? 6 : 7;

    if (value.length > 4) {
        formatted += ':' + value.slice(4, 4 + digitsAfterSecondColon); // Следующие 6 или 7 цифр
    }
    if (value.length > (isSixDigits ? 10 : 11)) {
        formatted += ':' + value.slice(isSixDigits ? 10 : 11); // Остальные цифры
    }

    input.value = formatted; 
}

function showCoordinates() {
    // Проверяем наличие координат
    if (!currentCoords || currentCoords.length === 0) {
        // Нет координат - открываем batch модалку
        const batchModal = document.getElementById('batchCadastralModal');
        batchModal.style.display = 'block';
        return;
    }

    const cadNumFromInput = document.getElementById('cadastralNumber').value.trim();
    
    // Проверяем, что данные соответствуют введенному номеру
    let dataMatchesInput = false;
    
    // Для кадастровых номеров - проверяем совпадение номеров из таблицы
    if (isValidCadastralNumber(cadNumFromInput)) {
        const tableRows = document.querySelectorAll('#resultTable tbody tr');
        for (let row of tableRows) {
            if (row.cells && row.cells.length > 1 && row.cells[0].textContent.trim() === 'Кадастровый номер') {
                const valueCell = row.cells[1];
                const strongTag = valueCell.querySelector('strong');
                const cadNumFromTable = strongTag ? strongTag.textContent.trim() : valueCell.textContent.trim();
                dataMatchesInput = cadNumFromInput === cadNumFromTable;
                break;
            }
        }
    } else if (isRegistryZoneNumber(cadNumFromInput)) {
        // Для реестровых номеров зон - проверяем строку "Реестровый номер"
        const tableRows = document.querySelectorAll('#resultTable tbody tr');
        for (let row of tableRows) {
            if (row.cells && row.cells.length > 1 && row.cells[0].textContent.trim() === 'Реестровый номер') {
                const valueCell = row.cells[1];
                const strongTag = valueCell.querySelector('strong');
                const zoneNumFromTable = strongTag ? strongTag.textContent.trim() : valueCell.textContent.trim();
                dataMatchesInput = normalizeRegistryZoneNumber(cadNumFromInput) === normalizeRegistryZoneNumber(zoneNumFromTable);
                break;
            }
        }
    } else {
        // Для адреса или других случаев - показываем всегда
        dataMatchesInput = true;
    }

    if (dataMatchesInput) {
        // Показываем окно с координатами
        const modal = document.getElementById('coordinatesModal');
        const tbody = document.querySelector('#modalCoordinatesTable tbody');
        tbody.innerHTML = ''; // Очищаем предыдущие строки

        let pointIndex = 1;

        // MultiPolygon
        if (currentCoords[0] && Array.isArray(currentCoords[0][0]) && Array.isArray(currentCoords[0][0][0])) {
            currentCoords.forEach(polygon => {
                polygon.forEach(ring => {
                    ring.forEach(coord => {
                        const tr = document.createElement('tr');
                        tr.innerHTML = `<td>${pointIndex++}</td><td>${coord[0]}</td><td>${coord[1]}</td>`;
                        tbody.appendChild(tr);
                    });
                });
            });
        // Polygon
        } else if (currentCoords[0] && Array.isArray(currentCoords[0][0])) {
            currentCoords.forEach(ring => {
                ring.forEach(coord => {
                    const tr = document.createElement('tr');
                    tr.innerHTML = `<td>${pointIndex++}</td><td>${coord[0]}</td><td>${coord[1]}</td>`;
                    tbody.appendChild(tr);
                });
            });
        // MultiLineString
        } else if (currentCoords[0] && Array.isArray(currentCoords[0]) && Array.isArray(currentCoords[0][0])) {
            currentCoords.forEach(line => {
                line.forEach(coord => {
                    const tr = document.createElement('tr');
                    tr.innerHTML = `<td>${pointIndex++}</td><td>${coord[0]}</td><td>${coord[1]}</td>`;
                    tbody.appendChild(tr);
                });
            });
        // Point
        } else {
            const tr = document.createElement('tr');
            tr.innerHTML = `<td>${pointIndex++}</td><td>${currentCoords[0][0]}</td><td>${currentCoords[0][1]}</td>`;
            tbody.appendChild(tr);
        }

        modal.style.display = 'block'; // Показываем модальное окно с координатами
    } else {
        // Данные не соответствуют введенному номеру - открываем batch модалку
        const batchModal = document.getElementById('batchCadastralModal');
        batchModal.style.display = 'block';
    }
}



// Функция для копирования всех координат в буфер обмена
function copyCoordinates() {
   if (!currentCoords || currentCoords.length === 0) {
        showNotification('Нет данных для копирования', 'error');
        return;
    }

    let coordsString = '';

    // Формируем строку в зависимости от типа геометрии
   // MultiPolygon
    if (currentCoords[0] && Array.isArray(currentCoords[0][0]) && Array.isArray(currentCoords[0][0][0])) {
        currentCoords.forEach(polygon => {
            polygon.forEach(ring => {
                ring.forEach(coord => {
                    coordsString += `${coord[0]}\t${coord[1]}\n`;
                });
            });
        });
    // Polygon
    } else if (currentCoords[0] && Array.isArray(currentCoords[0][0])) {
        currentCoords.forEach(ring => {
            ring.forEach(coord => {
                coordsString += `${coord[0]}\t${coord[1]}\n`;
            });
        });
    // MultiLineString
    } else if (currentCoords[0] && Array.isArray(currentCoords[0])) {
        currentCoords.forEach(line => {
            line.forEach(coord => {
                coordsString += `${coord[0]}\t${coord[1]}\n`;
            });
        });
    // Point
    } else {
        coordsString = `${currentCoords[0][0]}\t${currentCoords[0][1]}`;
    }


    // Копируем в буфер обмена
    navigator.clipboard.writeText(coordsString)
        .then(() => {
            showNotification('Координаты скопированы в буфер обмена', 'success');
        })
        .catch(err => {
            console.error('Ошибка при копировании координат:', err);
            showNotification('Не удалось скопировать координаты', 'error');
        });
}



function checkClipboardForCadastralNumber() {
    if (!navigator.clipboard) return; // Защита если API недоступно

    navigator.clipboard.readText()
        .then(text => {
            const input = document.getElementById('cadastralNumber');
            const cleanText = text.trim();

            if (cleanText.length > 50) return; // Слишком длинный текст игнорируем

            // ИЗМЕНЕНИЕ: Сначала проверяем, похож ли текст на номер зоны (XX:XX-...)
            // Регулярка ловит: 2 цифры, разделитель, 2 цифры, тире
            const isZone = /^\d{2}[:\.]\d{2}-/.test(cleanText);

            if (isZone) {
                // Если это зона, вставляем как есть (очистив от лишних пробелов) и ищем
                input.value = cleanText;
                document.querySelector('.search-button').click();
                return; // Выходим, чтобы не сработало форматирование КН ниже
            }

            // Стандартная логика для кадастрового номера
            const tryFormat = (isSixDigits) => {
                let value = text.replace(/\D/g, '');
                let formatted = '';

                if (value.length > 0) formatted += value.slice(0, 2);
                if (value.length > 2) formatted += ':' + value.slice(2, 4);

                const digitsAfterSecondColon = isSixDigits ? 6 : 7;
                if (value.length > 4) {
                    formatted += ':' + value.slice(4, 4 + digitsAfterSecondColon);
                }
                if (value.length > (isSixDigits ? 10 : 11)) {
                    formatted += ':' + value.slice(isSixDigits ? 10 : 11);
                }

                if (isValidCadastralNumber(formatted)) {
                    return formatted; 
                }
                return null; 
            };
            
            let formattedNumber = tryFormat(false) || tryFormat(true);

            if (formattedNumber) {
                input.value = formattedNumber;
                document.querySelector('.search-button').click();
            }
        })
        .catch(err => {
            console.error('Ошибка при чтении буфера обмена:', err);
        });
}



// Обработчик закрытия модального окна
document.querySelector('.close-modal').addEventListener('click', function() {
    document.getElementById('coordinatesModal').style.display = 'none';
});


// Функция для форматирования списка кадастровых номеров в textarea
// Функция для форматирования списка кадастровых номеров в textarea
function formatCadastralList() {
    const textarea = document.getElementById('cadastralListInput');
    let value = textarea.value;

    // --- CHANGE: Revised Logic ---
    // 1. Replace known separators (comma, semicolon) with newline globally
    value = value.replace(/[,;]/g, '\n');

    // 2. Split by newline, trim each line, filter empty lines, rejoin.
    // This preserves intended newlines while cleaning up lines
    // and removing blank lines created by separators.
    const lines = value.split('\n')
                       .map(line => line.trim()) // Trim whitespace from start/end of each line
                       .filter(line => line.length > 0); // Remove empty lines

    // 3. Join back with single newline. Store cursor position.
    const currentCursorPos = textarea.selectionStart;
    const originalLength = textarea.value.length;
    textarea.value = lines.join('\n');
    const newLength = textarea.value.length;

    // 4. Try to restore cursor position (might be slightly off after filtering)
    // This helps prevent the cursor from jumping unexpectedly
    const diff = newLength - originalLength;
    textarea.selectionStart = textarea.selectionEnd = Math.max(0, currentCursorPos + diff);
    // --- End Revised Logic ---
}



// Функция для закрытия конкретного модального окна по ID
function closeSpecificModal(modalId) {
    const modal = document.getElementById(modalId);
    if (modal) {
        modal.style.display = 'none';
    }
}


// Добавляем слушатель события 'input' для автоматического форматирования
const cadastralListTextArea = document.getElementById('cadastralListInput');
if (cadastralListTextArea) {
  //  cadastralListTextArea.addEventListener('input', formatCadastralList);
}

function getFormattedCadList(rawText) {
    if (!rawText) return [];
    
    // Заменяем запятые и точки с запятой на переносы строк
    let value = rawText.replace(/[,;]/g, '\n');

    // Разделяем на строки, удаляем ВСЕ пробелы из каждой строки, и убираем пустые строки
    const lines = value.split('\n')
                       .map(line => line.replace(/\s/g, '')) // Удаляем все пробельные символы
                       .filter(line => line.length > 0); // Удаляем пустые строки

    return lines;
}


function validateCadastralList(numbers) {
    // Регулярное выражение, которое разрешает ТОЛЬКО цифры (0-9) и двоеточия (:)
    const validCharsRegex = /^[0-9:]+$/;

    for (const num of numbers) {
        // Проверка 1: Убеждаемся, что в строке нет никаких символов кроме цифр и двоеточий.
        if (!validCharsRegex.test(num)) {
            console.error(`Недопустимые символы в кадастровом номере: "${num}"`);
            return false; // Найдены буквы, тире или другие недопустимые символы.
        }

        // Проверка 2: Убеждаемся, что структура номера правильная (есть минимум 3 двоеточия).
        const colonCount = (num.match(/:/g) || []).length;
        if (colonCount < 3) {
            console.error(`Неверная структура кадастрового номера (не хватает двоеточий): "${num}"`);
            return false; // Структура неверна.
        }
    }
    
    return true; // Все номера в списке прошли обе проверки.
}

function validateZoneList(numbers) {
    // --- ИЗМЕНЕНИЕ: Добавлена точка (\.) в список разрешенных символов ---
    // Регулярное выражение, которое разрешает ТОЛЬКО цифры, двоеточия, тире и точки.
    const validCharsRegex = /^[0-9:.-]+$/;

    for (const num of numbers) {
        // Проверяем, что в строке нет никаких символов кроме разрешенных.
        if (!validCharsRegex.test(num)) {
            console.error(`Недопустимые символы в номере зоны: "${num}"`);
            return false; // Найдены буквы или другие недопустимые символы.
        }
    }
    
    return true; // Все номера в списке прошли проверку.
}

// Функция для обработки поиска по номеру права
document.querySelector('.search-right-button').addEventListener('click', function() {
    const rightNumber = document.getElementById('rightNumberInput').value.trim();
    if (!rightNumber) {
        showNotification('Введите номер права', 'error');
        return;
        
    }

    // Заменяем / на %2F в номере права
    const formattedRightNumber = rightNumber.replace(/\//g, '%2F');
    
    // Выполняем запрос
    fetch(`https://rosreestr.gov.ru/api/online/right/16/${formattedRightNumber}`)
        .then(response => response.json())
        .then(data => {
            if (data && data.length > 0) {
                const result = data[0];
                
                // Обновляем таблицу результатов
                document.getElementById('rightNumber').textContent = rightNumber;
                document.getElementById('cadastralNumberFound').textContent = result.objectCn;
                document.getElementById('addressFound').textContent = result.addressNotes;
                
                // Показываем таблицу
                document.getElementById('rightSearchTable').style.display = 'table';
                
                // Вставляем кадастровый номер в основное поле поиска и запускаем поиск
                document.getElementById('cadastralNumber').value = result.objectCn;
                fetchData(); // Запускаем поиск по кадастровому номеру
            } else {
                showNotification('Данные не найдены', 'error');
            }
        })
        .catch(error => {
            console.error('Ошибка:', error);
            showNotification('Произошла ошибка при поиске', 'error');
        });
    fetchData(true);
});

// Обработчик для клавиши Enter в поле ввода номера права
document.getElementById('rightNumberInput').addEventListener('keydown', function(event) {
    if (event.key === 'Enter') {
        document.querySelector('.search-right-button').click();
    }
});

// Функция открытия карты
function openMap() {
    if (!currentCoords || currentCoords.length === 0) {
        showNotification('Нет данных для отображения карты', 'error');
        return;
    }

    let x, y;

    // MultiPolygon
    if (currentCoords[0] && Array.isArray(currentCoords[0][0]) && Array.isArray(currentCoords[0][0][0])) {
        x = parseFloat(currentCoords[0][0][0][0]); // Преобразуем строку в число
        y = parseFloat(currentCoords[0][0][0][1]);
    // Polygon
    } else if (currentCoords[0] && Array.isArray(currentCoords[0][0])) {
        x = parseFloat(currentCoords[0][0][0]); // Преобразуем строку в число
        y = parseFloat(currentCoords[0][0][1]);
    // MultiLineString
    } else if (currentCoords[0] && Array.isArray(currentCoords[0])) {
        x = parseFloat(currentCoords[0][0][0]); // Преобразуем строку в число
        y = parseFloat(currentCoords[0][0][1]);
    // Point
    } else {
        x = parseFloat(currentCoords[0][0]); // Преобразуем строку в число
        y = parseFloat(currentCoords[0][1]);
    }

    // Проверяем, что x и y успешно преобразованы в числа
    if (isNaN(x) || isNaN(y)) {
        showNotification('Некорректные координаты', 'error');
        return;
    }

    const formattedX = x.toFixed(3);
    const formattedY = y.toFixed(3);
    const mapUrl = `https://nspd.gov.ru/map?zoom=20&coordinate_x=${formattedX}&coordinate_y=${formattedY}&theme_id=1&is_copy_url=true&active_layers=36329%2C36328%2C36049%2C36048`;
    window.open(mapUrl, '_blank');
}

// Обработчики событий

document.getElementById('cadastralNumber').addEventListener('input', function(e) {
    const val = e.target.value;
    const trimmedVal = val.trim();

    const isAddress = /[а-яА-Яa-zA-Z]/.test(val);
    
   
    const isZoneNumber = /^\d{2}[:\.]\d{2}-/.test(trimmedVal) || val.includes('-');

    if (isAddress) {
     
    } else if (isZoneNumber) {
  
    } else {
     
        formatCadastralNumber(e.target);
    }

    if (val.trim() === '') {
        document.title = 'ЕГРН';
    }
});

document.getElementById('cadastralNumber').addEventListener('keydown', function(event) {
    if (event.key === 'Enter') {
        fetchData();
    }
});



     // Функция для добавления цифры в поле ввода
        function addDigitToInput(digit) {
            const input = document.getElementById('cadastralNumber');
            input.value += digit;
            formatCadastralNumber(input); // Форматируем ввод
        }


 
        // Функция для показа/скрытия виртуальной клавиатуры
        function toggleVirtualKeyboard() {
            const keyboard = document.getElementById('virtualKeyboard');
            keyboard.classList.toggle('active');
        }

        // Функция для закрытия клавиатуры при клике вне её
        function closeVirtualKeyboard(event) {
            const keyboard = document.getElementById('virtualKeyboard');
            const mobileButton = document.getElementById('mobileKeyboardButton');
            if (
                !keyboard.contains(event.target) &&
                !mobileButton.contains(event.target)
            ) {
                keyboard.classList.remove('active');
            }
        }

        // Обработчик нажатия клавиш
        document.addEventListener('keydown', function(event) {
            if (event.key === 'F9') {
                toggleVirtualKeyboard();
            }
            
               if (event.key === 'F8') {
        event.preventDefault();
        generatePrintLayout();
    }
            
               if (event.key === 'F10') {
                event.preventDefault(); 
                useVercelProxyMode = true; 
                   console.log(`Vercel enabled`);    
            }
            
            
        });
        
        

        // Обработчик кликов по клавишам виртуальной клавиатуры
   // Функция для обработки нажатия Enter
function handleEnter() {
    fetchData(); // Вызываем функцию fetchData (аналог нажатия Enter)
       
}

// Функция для удаления последнего символа в поле ввода
function clearLastCharacter() {
    const input = document.getElementById('cadastralNumber');
    input.value = input.value.slice(0, -1); // Удаляем последний символ
    formatCadastralNumber(input); // Форматируем ввод
}

// Функция для очистки всего поля ввода
function clearInput() {
    const input = document.getElementById('cadastralNumber');
    input.value = ''; // Очищаем всё поле
}

document.querySelectorAll('.keyboard-key').forEach(key => {
    if (key.classList.contains('clear')) {
        key.addEventListener('click', clearLastCharacter);
    } else if (key.classList.contains('enter')) {
        key.addEventListener('click', handleEnter);
    } else if (key.classList.contains('insert')) {
        // Только один обработчик для кнопки Insert
        key.addEventListener('click', insertFromClipboard);
    } else {
        key.addEventListener('click', function() {
            addDigitToInput(this.getAttribute('data-key'));
        });
    }
});
        // Обработчик для мобильной кнопки клавиатуры
        document.getElementById('mobileKeyboardButton').addEventListener('click', function(event) {
            event.stopPropagation();
            toggleVirtualKeyboard();
        });

        // Обработчик кликов по документу для закрытия клавиатуры
        document.addEventListener('click', closeVirtualKeyboard);

    
    
    // Обработчик закрытия модального окна
document.querySelectorAll('.close-modal').forEach(button => {
    button.addEventListener('click', function() {
        const modal = this.closest('.modal');
        modal.style.display = 'none';
    });
});

 

// Обработчик двойного клика для закрытия модального окна
document.querySelector('.modal-content').addEventListener('dblclick', function(event) {
    // Проверяем, что двойной клик был не по кнопке convertButton
    if (event.target.id !== 'convertButton') {
        closeModal(); // Закрываем модальное окно
    }
});

// Функция для закрытия модального окна
function closeModal() {
    const modal = document.getElementById('coordinatesModal');
    modal.style.display = 'none';
}


// Function to save the toggle state to local storage
function saveToggleState(state) {
    localStorage.setItem('distanceToggleState', state);
}

// Function to load the toggle state from local storage
function loadToggleState() {
    const savedState = localStorage.getItem('distanceToggleState');
    return savedState === 'true';
}

// Function to toggle the distance labels
function toggleDistanceLabels() {
    showDistanceLabels = !showDistanceLabels;
    saveToggleState(showDistanceLabels); // Save the state to local storage
    drawScheme(); // Redraw the scheme with/without labels
}


    // Обработчик двойного клика на координату в таблице
    document.getElementById('modalCoordinatesTable').addEventListener('dblclick', function(event) {
    const target = event.target;
    if (target.tagName === 'TD' && target.cellIndex !== 0) { // Проверяем, что это не первая ячейка (с номером)
        event.stopPropagation();
        const row = target.parentElement;
        const x = parseFloat(row.cells[1].textContent);
        const y = parseFloat(row.cells[2].textContent);
        const [lon, lat] = convertToWGS84(x, y);
        const url = `https://yandex.ru/maps/?l=sat%2Cskl&ll=${lon},${lat}&z=21&pt=${lon},${lat}`;
        window.open(url);
    }
});


document.getElementById('schemeCanvas').addEventListener('dblclick', function(event) {
    const canvas = document.getElementById('schemeCanvas');
    const rect = canvas.getBoundingClientRect();
    const clickY = event.clientY - rect.top; // Позиция клика относительно верха canvas

    // Проверяем, что клик произошел в верхних 2 см (примерно 75 пикселей при стандартном DPI)
    const topThreshold = 75; // 2 см ≈ 75 пикселей
    if (clickY <= topThreshold) {
        // Получаем элементы, которые нужно сохранить
        const table = document.getElementById('resultTable');
        const schemeCanvas = document.getElementById('schemeCanvas');

        if (!table || !schemeCanvas) {
            showNotification('Таблица или чертеж не найдены', 'error');
            return;
        }

        // Извлекаем чистый текст из таблицы (plain текст без форматирования)
        const rows = table.querySelectorAll('tr');
        let plainTextRows = [];
        rows.forEach(row => {
            const cells = row.querySelectorAll('td, th');
            let rowText = [];
            cells.forEach(cell => {
                rowText.push(cell.textContent.trim()); // Извлекаем только текст
            });
            if (rowText.length > 0) {
                plainTextRows.push(rowText);
            }
        });

        // Создаем новую таблицу с чистым текстом, делая левую колонку шире
        const newTable = document.createElement('table');
        newTable.style.width = 'auto'; // Автоматическая ширина, подстраивающаяся под содержимое
        newTable.style.maxWidth = '600px'; // Ограничение ширины таблицы для компактности
        newTable.style.backgroundColor = '#ffffff'; // Яркий белый фон
        newTable.style.color = '#000000'; // Полностью черный текст
        newTable.style.fontSize = '14px'; // Уменьшенный размер текста для компактности
        newTable.style.fontWeight = 'bold'; // Жирный текст для контраста
        newTable.style.fontFamily = 'Arial, sans-serif'; // Надежный шрифт
        newTable.style.borderCollapse = 'collapse';
        newTable.style.border = '1px solid #000000'; // Тонкие черные границы

        plainTextRows.forEach(rowText => {
            const tr = document.createElement('tr');
            rowText.forEach((text, index) => {
                const td = document.createElement('td');
                td.textContent = text; // Вставляем чистый текст
                td.style.color = '#000000'; // Черный текст
                td.style.backgroundColor = '#ffffff'; // Белый фон
                td.style.border = '1px solid #000000'; // Тонкие черные границы
                td.style.padding = '6px'; // Уменьшенные отступы для компактности
                td.style.textAlign = 'left'; // Выравнивание
                td.style.whiteSpace = 'normal'; // Перенос текста
                td.style.wordBreak = 'break-word'; // Перенос слов
                td.style.lineHeight = '1.1'; // Минимальная высота строки для компактности

                // Делаем первую колонку (индекс 0) шире
                if (index === 0) {
                    td.style.width = '200px'; // Фиксированная ширина для левой колонки
                    td.style.minWidth = '200px'; // Минимальная ширина, чтобы текст не сжимался
                } else {
                    td.style.width = 'auto'; // Остальные колонки автоматически подстраиваются
                }
                tr.appendChild(td);
            });
            newTable.appendChild(tr);
        });

        // Определяем высоту таблицы после добавления содержимого в DOM
        document.body.appendChild(newTable); // Добавляем таблицу в DOM, чтобы вычислить высоту
        const tableHeight = newTable.offsetHeight;
        document.body.removeChild(newTable); // Сразу же убираем обратно

        // Клонируем и подстраиваем чертеж (canvas) под высоту таблицы, сохраняя пропорции
        const canvasClone = document.createElement('canvas');
        const canvasWidth = schemeCanvas.width; // Сохраняем исходную ширину
        const canvasAspectRatio = schemeCanvas.width / schemeCanvas.height; // Соотношение сторон оригинального canvas
        canvasClone.height = tableHeight; // Точная высота таблицы для согласованности
        canvasClone.width = canvasClone.height * canvasAspectRatio; // Вычисляем ширину, сохраняя пропорции
        const ctxClone = canvasClone.getContext('2d');
        ctxClone.fillStyle = '#ffffff'; // Яркий белый фон для canvas
        ctxClone.fillRect(0, 0, canvasClone.width, canvasClone.height); // Заливка белым фоном

        // Масштабируем содержимое оригинального canvas, чтобы оно точно поместилось, сохраняя пропорции
        const scale = canvasClone.height / schemeCanvas.height; // Масштаб по высоте
        ctxClone.scale(scale, scale); // Масштабируем пропорционально по обоим осям
        ctxClone.drawImage(schemeCanvas, 0, 0, schemeCanvas.width, schemeCanvas.height); // Копируем содержимое

        // Создаем временный контейнер с таблицей слева и чертежом справа
        const tempContainer = document.createElement('div');
        tempContainer.style.position = 'absolute';
        tempContainer.style.left = '-9999px'; // Убираем из видимой области
        tempContainer.style.background = '#fff'; // Яркий белый фон
        tempContainer.style.padding = '5px'; // Минимальный отступ
        tempContainer.style.display = 'flex'; // Горизонтальная ориентация
        tempContainer.style.flexDirection = 'row'; // Таблица слева, чертеж справа
        tempContainer.style.gap = '5px'; // Минимальное расстояние между таблицей и чертежом
        tempContainer.style.alignItems = 'flex-start'; // Выравнивание по верху
        tempContainer.style.maxWidth = '1200px'; // Ограничение общей ширины для компактности

        // Добавляем новую таблицу слева
        tempContainer.appendChild(newTable);

        // Добавляем чертеж (canvas) справа
        tempContainer.appendChild(canvasClone);

        // Добавляем временный контейнер в DOM
        document.body.appendChild(tempContainer);

        // Используем html2canvas для захвата контейнера с масштабом 2 (увеличение разрешения)
        html2canvas(tempContainer, {
            scale: 2, // Увеличили масштаб для улучшения качества (примерно 200 DPI)
            backgroundColor: '#ffffff', // Яркий белый фон
            useCORS: true, // Попытка загрузки внешних ресурсов с CORS
            allowTaint: true, // Разрешаем обработку потенциально "загрязненных" ресурсов
            logging: false,
            ignoreElements: (element) => element.tagName === 'SCRIPT' || element.tagName === 'STYLE' // Игнорируем скрипты и стили
        }).then(canvas => {
            // Преобразуем в JPG
            const imgData = canvas.toDataURL('image/jpeg', 0.95); // Высокое качество

            // Создаем ссылку для скачивания
            const link = document.createElement('a');
            link.href = imgData;

            // Генерируем имя файла с текущей датой и временем
            const now = new Date();
            const dateStr = now.toISOString().replace(/[:.]/g, '-').slice(0, 19);
            link.download = `egrn-${dateStr}.jpg`;

            // Скачиваем файл
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);

            // Удаляем временный контейнер
            document.body.removeChild(tempContainer);

            showNotification('Таблица и чертеж сохранены как JPG', 'success');
        }).catch(error => {
            console.error('Ошибка при сохранении с html2canvas:', error);
            showNotification('Ошибка при сохранении, проверьте консоль', 'error');

            // Удаляем временный контейнер в случае ошибки
            if (document.body.contains(tempContainer)) {
                document.body.removeChild(tempContainer);
            }
        });
    }
});



const STORAGE_API_URL = 'https://mapruapp.ru/storage';


async function fetchDataFromArchive() {
    const cadastralNumberInput = document.getElementById('cadastralNumber');
    const targetCadastralNumber = cadastralNumberInput.value.trim();
    const archiveInfoDiv = document.getElementById('archiveInfo');

    if (archiveInfoDiv) {
        archiveInfoDiv.style.display = 'none';
        archiveInfoDiv.innerHTML = ''; 
    }

    if (!isValidCadastralNumber(targetCadastralNumber)) {
        showNotification('Введите корректный кадастровый номер участка', 'error');
        return;
    }

    // ЗАПУСК ЛОАДЕРА
    showLoader(`Загрузка из архива: ${targetCadastralNumber}`);

    try {
        const quarterNumber = targetCadastralNumber.split(':').slice(0, 3).join(':');
        const filename = quarterNumber.replace(/:/g, '_') + '.nspd';

        // Проверяем searchAbortController внутри долгих операций, если нужно,
        // но так как fetchZipFromLocalServer использует fetch, можно передать сигнал туда, если переписать её.
        // Для простоты оставим проверку перед обработкой.

        const zipBlob = await fetchZipFromLocalServer('nspd', filename);
        
        // Проверка на отмену после скачивания
        if (searchAbortController && searchAbortController.signal.aborted) throw new DOMException('Aborted', 'AbortError');

        if (!zipBlob) {
            showNotification(`Архив для квартала ${quarterNumber} не найден. Попробуйте обычный поиск.`, 'warning');
            return;
        }

        const { features, date: archiveDate } = await loadAndParseZipBlob(zipBlob);

        // Еще проверка
        if (searchAbortController && searchAbortController.signal.aborted) throw new DOMException('Aborted', 'AbortError');

        const targetFeature = features.find(f => f.properties && f.properties.descr === targetCadastralNumber);

        if (!targetFeature) {
            showNotification(`Участок ${targetCadastralNumber} не найден в архиве квартала.`, 'error');
            return;
        }

        // ... код обработки свойств ...
        const properties = targetFeature.properties;
        const options = targetFeature.properties ? targetFeature.properties.options : {};
        const geometry = targetFeature.geometry;
        
        document.title = `${targetCadastralNumber}`;
        updatePropertyData(options, properties, null, null, geometry);

        if (geometry && geometry.coordinates && geometry.type !== "Point") {
            currentCoords = geometry.coordinates;
            document.querySelector('.content-container').style.display = 'grid';
            document.querySelector('.scheme-container').style.display = 'block';
            drawScheme();
        } else {
            document.querySelector('.content-container').style.display = 'block';
            document.querySelector('.scheme-container').style.display = 'none';
            clearCanvas();
            const warningMsg = (geometry && geometry.type === "Point") 
                ? 'Участок найден, но не имеет координат для отрисовки (геометрия-точка).'
                : 'Участок найден, но не имеет координат для отрисовки.';
            showNotification(warningMsg, 'warning');
        }
        
        let formattedDate = '';
        if (archiveDate) {
            const [year, month, day] = archiveDate.split('-');
            formattedDate = `${day}.${month}.${year}`;
        }

        if (archiveInfoDiv && formattedDate) {
            archiveInfoDiv.innerHTML = `
                <i class="fas fa-exclamation-triangle" style="margin-right: 8px; color: #ffa726;"></i>
                <span style="font-size: 16px; font-weight: 500; color: #ef6c00;">
                    Данные из архива (актуальность: ${formattedDate})
                </span>
            `;
            archiveInfoDiv.style.display = 'block';
        }
        
        const notificationMessage = formattedDate
            ? `Данные из архива КПТ загружены (на ${formattedDate})`
            : 'Данные из архива КПТ успешно загружены!';
        showNotification(notificationMessage, 'success');
        
        document.getElementById('resultTable').style.display = 'table';

    } catch (error) {
        if (error.name === 'AbortError') return;
        console.error("Ошибка при работе с архивом:", error);
        showNotification(`Ошибка: ${error.message}`, 'error');
    } finally {
        hideLoader(); // СКРЫВАЕМ ЛОАДЕР
    }
}

async function fetchZipFromLocalServer(bucketName, filePathInBucket) {
    try {
        const response = await fetch(`${STORAGE_API_URL}/${bucketName}/${filePathInBucket}`);
        if (!response.ok) {
            if (response.status === 404) {
                console.log(`Файл "${filePathInBucket}" не найден.`);
            } else {
                console.error(`Ошибка сервера ${response.status} для файла "${filePathInBucket}".`);
            }
            return null;
        }
        return await response.blob();
    } catch (error) {
        console.error(`Ошибка сети при запросе файла "${filePathInBucket}":`, error);
        return null;
    }
}

// Функция запуска анимации иконки списка
function triggerListIconAnimation() {
    const icon = document.getElementById('addressListIcon');
    if (!icon) return;
    
    // Всегда делаем иконку видимой (даже если анимация отключена)
    icon.style.display = 'block';

    // Если пользователь уже кликал на иконку — выходим, не запуская пульсацию
    if (isAddressIconAnimationDisabled) {
        icon.classList.remove('pulse-animation'); // На всякий случай чистим класс
        return;
    }
    
    // Сброс и запуск анимации (как было раньше)
    icon.classList.remove('pulse-animation');
    void icon.offsetWidth; 
    icon.classList.add('pulse-animation');
    
    setTimeout(() => {
        icon.classList.remove('pulse-animation');
    }, 2000);
}
// Поиск по адресу
async function searchByAddress(address) {
    // ЗАПУСК ЛОАДЕРА
    const signal = showLoader(`Поиск по адресу: ${address}`);
    
    document.getElementById('addressListIcon').style.display = 'none';

    // Сбрасываем фильтры при новом поиске
    const filterInput = document.getElementById('addressFilterInput');
    if(filterInput) filterInput.value = '';

    const path = `/api/geoportal/v2/search/geoportal?thematicSearchId=1&query=${encodeURIComponent(address)}`;

    try {
        // Передаем signal
        const response = await fetchWithFallback(path, { signal });

        if (response.status === 204) {
            showNotification('По вашему запросу ничего не найдено', 'warning');
            lastAddressSearchResults = [];
            lastRawJsonResponse = { message: "No content (204)", query: address }; 
            return; 
        }

        if (!response.ok) throw new Error('Ошибка поиска');
        
        const data = await response.json();
        lastRawJsonResponse = data; 

       if (data && data.data && data.data.features && data.data.features.length > 0) {
            lastAddressSearchResults = data.data.features;
            originalAddressSearchResults = [...data.data.features];
            isRefineFilterActive = false;
            updateRefineButtonUI();
            
            openAddressModal();
            document.getElementById('addressListIcon').style.display = 'block'; 
        } else {
            showNotification('Объекты по данному адресу не найдены', 'warning');
            lastAddressSearchResults = [];
            document.getElementById('addressListIcon').style.display = 'none';
        }

    } catch (error) {
        if (error.name === 'AbortError') return; // Игнорируем отмену
        console.error('Address search error:', error);
        showNotification('Ошибка при поиске адреса', 'error');
    } finally {
        hideLoader(); // СКРЫВАЕМ ЛОАДЕР
    }
}

// 1. Фильтр по вводу (Соблюдение порядка слов)


// Модифицируем функцию, добавляя параметр isAuto
function performDeepSearch(isAuto = false) {
    const inputVal = document.getElementById('addressFilterInput').value.trim().toLowerCase();
    
    if (inputVal.length === 0) {
        filterAddressListByInput('');
        return;
    }

    const tbody = document.querySelector('#addressResultsTable tbody');
    const rows = tbody.getElementsByTagName('tr');

    for (let i = 0; i < rows.length; i++) {
        const row = rows[i];
        let isMatch = false;

        const dataIndex = row.dataset.index;
        if (dataIndex !== undefined && lastAddressSearchResults[dataIndex]) {
            const jsonString = JSON.stringify(lastAddressSearchResults[dataIndex]).toLowerCase();
            if (jsonString.includes(inputVal)) {
                isMatch = true;
            }
        }
        
        row.style.display = isMatch ? '' : 'none';
    }
    
    // Если это автопоиск, мы обновим счетчик со специальным текстом во внешней функции
    if (!isAuto) {
        updateAddressCount();
        showNotification('Выполнен поиск по содержимому', 'info');
    }
}

// 1. Фильтр по вводу + Автоматический глубокий поиск с красивым статусом
function filterAddressListByInput(searchText) {
    const tbody = document.querySelector('#addressResultsTable tbody');
    const rows = tbody.getElementsByTagName('tr');
    
    const rawInput = searchText.trim();
    
    if (rawInput.length === 0) {
        for (let i = 0; i < rows.length; i++) {
            rows[i].style.display = '';
        }
        updateAddressCount();
        return;
    }

    const searchWords = rawInput.split(/\s+/).filter(w => w.length > 0);
    const regex = new RegExp(searchWords.map(word => escapeRegExp(word)).join('.*'), 'i');

    let visibleCount = 0;

    for (let i = 0; i < rows.length; i++) {
        const row = rows[i];
        const rowText = row.textContent; 
        const isMatch = regex.test(rowText);
        row.style.display = isMatch ? '' : 'none';
        if (isMatch) visibleCount++;
    }

    // ЛОГИКА АВТОМАТИЧЕСКОГО ГЛУБОКОГО ПОИСКА
    if (visibleCount === 0) {
        performDeepSearch(true); 
        
        // Пересчитываем результаты после глубокого поиска
        let deepCount = 0;
        for (let i = 0; i < rows.length; i++) {
            if (rows[i].style.display !== 'none') deepCount++;
        }

        const countEl = document.getElementById('addressListCount');
        if (countEl) {
            if (deepCount > 0) {
                // Если нашли через глубокий поиск
                countEl.innerHTML = `<span style="color: #ef6c00;">Поиск по содержимому: найдено ${deepCount}</span>`;
            } else {
                // Если совсем ничего не нашли (даже в содержимом)
                countEl.innerHTML = `Ничего не найдено`;
            }
        }
        return; 
    }

    updateAddressCount();
}

// Вспомогательная функция для экранирования спецсимволов в Regex
function escapeRegExp(string) {
    return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
}


// 2. Кнопка "Уточнить" (Строгое совпадение по границам слов)
function refineAddressList() {
    if (!originalAddressSearchResults || originalAddressSearchResults.length === 0) return;

    if (isRefineFilterActive) {
        lastAddressSearchResults = [...originalAddressSearchResults];
        isRefineFilterActive = false;
        
        updateRefineButtonUI();
        
        const activeTab = document.querySelector('.filter-tab.active');
        const filterType = activeTab ? activeTab.getAttribute('title') : null;
        renderAddressTable(filterType);
        
        const inputVal = document.getElementById('addressFilterInput').value;
        if(inputVal) filterAddressListByInput(inputVal);

        showNotification('Фильтр "Уточнить" отключен.', 'info');
        return;
    }

    const originalQuery = document.getElementById('cadastralNumber').value.trim();
    if (!originalQuery) return;

    const queryWords = originalQuery.toLowerCase()
        .replace(/[,.]/g, ' ')
        .split(/\s+/)
        .filter(w => w.length > 0);

    const refinedResults = originalAddressSearchResults.filter(feature => {
        const options = feature.properties?.options || {};
        const addressRaw = (options.readable_address || options.address_readable_address || '').toLowerCase();
        
        const addressTokens = addressRaw.split(/[^а-яёa-z0-9/]+/);

        return queryWords.every(queryWord => {
            return addressTokens.includes(queryWord);
        });
    });

    if (refinedResults.length === 0) {
        showNotification('После уточнения список не изменился', 'warning');
        return;
    }

    lastAddressSearchResults = refinedResults;
    isRefineFilterActive = true;
    updateRefineButtonUI();

    document.querySelectorAll('.filter-tab').forEach(btn => btn.classList.remove('active'));
    document.getElementById('addressFilterInput').value = '';

    renderAddressTable(null);
    showNotification(`Список уточнен. Найдено: ${refinedResults.length}`, 'success');
}


function updateRefineButtonUI() {
    const btn = document.getElementById('refineBtn');
    if (!btn) return;

    if (isRefineFilterActive) {
        btn.classList.add('active'); // Станет зеленым
        btn.title = "Фильтр применен. Нажмите, чтобы сбросить."; // Подсказка
    } else {
        btn.classList.remove('active'); // Станет серым
        btn.title = "Уточнить (строгое совпадение)"; // Подсказка
    }
}


function copyTableData() {
    const table = document.getElementById('addressResultsTable');
    if (!table) return;

    // Заголовки
    const headers = Array.from(table.querySelectorAll('thead th'))
        .map(th => th.innerText)
        .join('\t');

    // Строки (берем только видимые строки, на случай если работает текстовый фильтр)
    const rows = Array.from(table.querySelectorAll('tbody tr'))
        .filter(tr => tr.style.display !== 'none')
        .map(tr => {
            return Array.from(tr.querySelectorAll('td'))
                .map(td => {
                    // Очищаем текст от лишних пробелов и переносов внутри ячейки
                    return td.innerText.replace(/(\r\n|\n|\r)/gm, " ").trim();
                })
                .join('\t');
        })
        .join('\n');

    const clipText = `${headers}\n${rows}`;

    navigator.clipboard.writeText(clipText)
        .then(() => {
            showNotification('Таблица скопирована', 'success');
        })
        .catch(err => {
            console.error('Copy table error:', err);
            showNotification('Не удалось скопировать таблицу', 'error');
        });
}


// 3. Кнопка "Копировать JSON"
function copyRawJson() {
    if (!lastRawJsonResponse) {
        showNotification('Нет данных JSON для копирования', 'warning');
        return;
    }

    const jsonString = JSON.stringify(lastRawJsonResponse, null, 2);
    
    navigator.clipboard.writeText(jsonString)
        .then(() => {
            showNotification('JSON скопирован в буфер', 'success');
        })
        .catch(err => {
            console.error('Ошибка копирования:', err);
            showNotification('Не удалось скопировать JSON', 'error');
        });
}

// Открытие модального окна со списком (использует данные из памяти)
function openAddressModal() {
    if (!lastAddressSearchResults || lastAddressSearchResults.length === 0) {
        showNotification('Нет сохраненных результатов поиска', 'warning');
        return;
    }

    // Сбрасываем активные классы с кнопок при открытии
    document.querySelectorAll('.filter-tab').forEach(btn => btn.classList.remove('active'));

    // Отрисовываем всё (без фильтра)
    renderAddressTable(null);

    document.getElementById('addressListModal').style.display = 'block';
}

// 2. Функция фильтрации (вызывается при клике на иконки)
function filterAddressList(button, filterType) {
    // Если кнопка уже активна — снимаем фильтр (показываем всё)
    if (button.classList.contains('active')) {
        button.classList.remove('active');
        renderAddressTable(null);
        return;
    }

    // Сбрасываем активность со всех кнопок
    document.querySelectorAll('.filter-tab').forEach(btn => btn.classList.remove('active'));
    
    // Активируем нажатую
    button.classList.add('active');
    
    // Отрисовываем с фильтром
    renderAddressTable(filterType);
}


function updateAddressCount() {
    const tbody = document.querySelector('#addressResultsTable tbody');
    const rows = tbody.getElementsByTagName('tr');
    let visibleCount = 0;
    
    for (let i = 0; i < rows.length; i++) {
        if (rows[i].style.display !== 'none') {
            visibleCount++;
        }
    }
    
    const countEl = document.getElementById('addressListCount');
    if (countEl) {
        countEl.textContent = `Найдено записей: ${visibleCount}`;
    }
}

function renderAddressTable(filterType) {
    const tbody = document.querySelector('#addressResultsTable tbody');
    tbody.innerHTML = '';

    let visibleCount = 0;

    lastAddressSearchResults.forEach((feature, index) => {
        const props = feature.properties || {};
        const type = props.categoryName || 'Объект';
        
        if (filterType && !type.includes(filterType)) {
            return;
        }

        const options = props.options || {};
        const cadNum = options.cad_num || options.cad_number || 'н/д';
        const addr = options.readable_address || options.address_readable_address || 'Адрес не указан';

        let geoIcon = '';
        if (feature.geometry && 
            feature.geometry.coordinates && 
            feature.geometry.coordinates.length > 0 &&
            feature.geometry.type !== 'Point') { 
            
            geoIcon = '<i class="fas fa-map-marker-alt" style="color: #2196F3; margin-left: 8px; font-size: 13px;" title="Есть контур (границы)"></i>';
        }

        let cadNumStyle = ''; 
        if (type.includes('Земельные участки')) {
            if (options.specified_area || options.land_record_area_verified) {
                cadNumStyle = 'color: #00C853;'; 
            } else if (options.declared_area || options.land_record_area_declaration || options.land_record_area) {
                cadNumStyle = 'color: #D32F2F;'; 
            }
        }

        const tr = document.createElement('tr');
        tr.dataset.index = index; 
        tr.innerHTML = `
            <td>${type}${geoIcon}</td>
            <td><strong style="${cadNumStyle}">${cadNum}</strong></td>
            <td>${addr}</td>
        `;

        tr.onclick = () => selectAddressResult(index);
        
        tbody.appendChild(tr);
        visibleCount++;
    });
    
    if (tbody.children.length === 0) {
        tbody.innerHTML = '<tr><td colspan="3" style="text-align:center; padding: 20px; color: #777;">Ничего не найдено</td></tr>';
        visibleCount = 0;
    }

    updateAddressCount();
}

// Выбор результата из списка
function selectAddressResult(index) {
    const feature = lastAddressSearchResults[index];
    if (!feature) return;

    // 1. Подставляем КН в поле ввода
    const cadNum = feature.properties?.options?.cad_num || feature.properties?.options?.cad_number;
    if (cadNum) {
        document.getElementById('cadastralNumber').value = cadNum;
        document.title = cadNum;
    }

    // 2. Закрываем модальное окно списка
    closeSpecificModal('addressListModal');
     triggerListIconAnimation(); 

    // 3. Формируем структуру данных, как будто она пришла от API, и отдаем в обработчик
    // ВАЖНО: Мы не делаем новый запрос, используем то, что уже скачали!
    const fakeApiResponse = {
        data: {
            features: [feature]
        }
    };

    try {
        handleSuccessfulResponse(fakeApiResponse);
      //  showNotification('Объект загружен из списка', 'success');
    } catch (e) {
        console.error(e);
        showNotification('Ошибка при отображении объекта', 'error');
    }
}


async function loadAndParseZipBlob(zipBlob) {
    if (!zipBlob) throw new Error("ZIP-файл для загрузки не предоставлен.");

    const zip = await JSZip.loadAsync(zipBlob);

    let jsonFile = null;
    let loadedDate = null;
    let inferredQuarter = null;
    const jsonFilenamePattern = /^(\d{2}_\d{2}_\d{6,7}(?:_\d+)?)\s(\d{4}-\d{2}-\d{2})\.json$/;

    for (const filename in zip.files) {
        const match = filename.match(jsonFilenamePattern);
        if (match) {
            jsonFile = zip.files[filename];
            inferredQuarter = match[1].replace(/_/g, ':');
            loadedDate = match[2];
            break;
        }
    }

    if (!jsonFile) {
        throw new Error("Файл данных (*.json) не найден в архиве.");
    }

    const jsonText = await jsonFile.async("text");
    const loadedFeatures = JSON.parse(jsonText);

    if (!Array.isArray(loadedFeatures)) {
        throw new Error("Файл содержит некорректные данные.");
    }

    return { features: loadedFeatures, date: loadedDate, quarter: inferredQuarter };
}

function calculatePolygonCentroid(pts) {
    let first = pts[0],
        last = pts[pts.length - 1];
    if (first[0] != last[0] || first[1] != last[1]) pts.push(first);
    let twicearea = 0,
        x = 0,
        y = 0,
        nPts = pts.length,
        p1, p2, f;
    for (let i = 0, j = nPts - 1; i < nPts; j = i++) {
        p1 = pts[i];
        p2 = pts[j];
        f = p1[0] * p2[1] - p2[0] * p1[1];
        twicearea += f;
        x += (p1[0] + p2[0]) * f;
        y += (p1[1] + p2[1]) * f;
    }
    f = twicearea * 3;
    return {
        x: x / f,
        y: y / f
    };
}


function getAllCoordsFromGeometry(geometry) {
    if (!geometry || !geometry.coordinates) return [];
    const {
        type,
        coordinates
    } = geometry;
    let allCoords = [];
    if (type === "Polygon") {
        coordinates.forEach(ring => allCoords.push(...ring));
    } else if (type === "MultiPolygon") {
        coordinates.forEach(polygon => polygon.forEach(ring => allCoords.push(...ring)));
    } else if (type === "LineString") {
        allCoords.push(...coordinates);
    } else if (type === "MultiLineString") {
        coordinates.forEach(line => allCoords.push(...line));
    }
    return allCoords;
}

function drawGeometryOnCanvas(ctx, geometry, color, params) {
    if (!geometry || !geometry.coordinates) return;
    const {
        scale,
        offsetX,
        offsetY,
        minX,
        minY,
        canvasHeight
    } = params;
    ctx.strokeStyle = color;
    ctx.lineWidth = 3;
    ctx.fillStyle = color.replace(')', ', 0.1)').replace('rgb', 'rgba');

    const drawContour = (coords) => {
        ctx.beginPath();
        coords.forEach((coord, index) => {
            const x = offsetX + (coord[0] - minX) * scale;
            const y = canvasHeight - (offsetY + (coord[1] - minY) * scale);
            if (index === 0) ctx.moveTo(x, y);
            else ctx.lineTo(x, y);
        });
    };

    const {
        type,
        coordinates
    } = geometry;
    if (type === "Polygon") {
        coordinates.forEach(ring => {
            drawContour(ring);
            ctx.closePath();
            ctx.stroke();
            ctx.fill();
        });
    } else if (type === "MultiPolygon") {
        coordinates.forEach(polygon => polygon.forEach(ring => {
            drawContour(ring);
            ctx.closePath();
            ctx.stroke();
            ctx.fill();
        }));
    } else if (type === "LineString") {
        drawContour(coordinates);
        ctx.stroke();
    } else if (type === "MultiLineString") {
        coordinates.forEach(line => {
            drawContour(line);
            ctx.stroke();
        });
    }
}


function drawCalloutLabel(ctx, feature, params) {
    const geometry = feature.geometry;
    if (!geometry || !geometry.coordinates || geometry.coordinates.length === 0) return;

    let centroidPoint;
    if (geometry.type === "Polygon" || geometry.type === "MultiPolygon") {
        const primaryRing = geometry.type === "Polygon" ? geometry.coordinates[0] : geometry.coordinates[0][0];
        const centroid = calculatePolygonCentroid(primaryRing);
        centroidPoint = [centroid.x, centroid.y];
    } else {
        const coords = getAllCoordsFromGeometry(geometry);
        const midIndex = Math.floor(coords.length / 2);
        centroidPoint = coords[midIndex];
    }

    const {
        scale,
        offsetX,
        offsetY,
        minX,
        minY,
        canvasHeight
    } = params;
    const anchorX = offsetX + (centroidPoint[0] - minX) * scale;
    const anchorY = canvasHeight - (offsetY + (centroidPoint[1] - minY) * scale);

    const labelText = feature.properties.options.cad_num || "ID";
    ctx.font = 'bold 24px Times New Roman';
    const textMetrics = ctx.measureText(labelText);
    const textWidth = textMetrics.width;
    const textHeight = 24;

    const labelX = anchorX > params.canvasWidth / 2 ? anchorX - textWidth - 25 : anchorX + 25;
    const labelY = anchorY;

    ctx.beginPath();
    ctx.moveTo(anchorX, anchorY);
    ctx.lineTo(labelX, labelY);
    ctx.strokeStyle = '#333';
    ctx.lineWidth = 1.5;
    ctx.stroke();

    ctx.fillStyle = 'white';
    ctx.globalAlpha = 0.7;
    ctx.fillRect(labelX - 5, labelY - textHeight, textWidth + 10, textHeight + 5);
    ctx.globalAlpha = 1.0;

    ctx.fillStyle = 'black';
    ctx.textAlign = anchorX > params.canvasWidth / 2 ? 'right' : 'left';
    ctx.fillText(labelText, labelX, labelY);
}


async function drawForPrint(mainGeometry, linkedFeatures) {
    const canvas = document.createElement('canvas');
    canvas.width = 2000;
    canvas.height = 1414;
    const ctx = canvas.getContext('2d');
    ctx.fillStyle = 'white';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    let allCoords = getAllCoordsFromGeometry(mainGeometry);
    linkedFeatures.forEach(feature => {
        allCoords = allCoords.concat(getAllCoordsFromGeometry(feature.geometry));
    });

    if (allCoords.length === 0) return canvas.toDataURL();

    const minX = Math.min(...allCoords.map(p => p[0]));
    const maxX = Math.max(...allCoords.map(p => p[0]));
    const minY = Math.min(...allCoords.map(p => p[1]));
    const maxY = Math.max(...allCoords.map(p => p[1]));

    const width = maxX - minX;
    const height = maxY - minY;
    const padding = 50;

    const scaleX = (canvas.width - padding * 2) / width;
    const scaleY = (canvas.height - padding * 2) / height;
    const scale = Math.min(scaleX, scaleY);

    const offsetX = (canvas.width - width * scale) / 2;
    const offsetY = (canvas.height - height * scale) / 2;

    const params = {
        scale,
        offsetX,
        offsetY,
        minX,
        minY,
        canvasWidth: canvas.width,
        canvasHeight: canvas.height
    };

    const drawPointsAndLabelsForPrint = (geometry, color, labelPrefix = '') => {
        const allRings = [];
        if (geometry.type === 'Polygon') {
            allRings.push(...geometry.coordinates);
        } else if (geometry.type === 'MultiPolygon') {
            geometry.coordinates.forEach(poly => allRings.push(...poly));
        } else {
            allRings.push(getAllCoordsFromGeometry(geometry));
        }
        
        if (allRings.length === 0) return;
        
        const labelOffset = 18;
        ctx.font = '28px Times New Roman';
        let pointCounter = 1;

        allRings.forEach(coords => {
             if (coords.length === 0) return;
            
             const coordsToDraw = (coords[0][0] === coords[coords.length - 1][0] && coords[0][1] === coords[coords.length - 1][1]) 
                ? coords.slice(0, -1) 
                : coords;

            coordsToDraw.forEach((coord) => {
                const x = offsetX + (coord[0] - minX) * scale;
                const y = canvas.height - (offsetY + (coord[1] - minY) * scale);
                
                ctx.beginPath();
                ctx.arc(x, y, 5, 0, Math.PI * 2);
                ctx.fillStyle = color;
                ctx.fill();
                
                ctx.fillStyle = '#333';
                ctx.fillText(labelPrefix + (pointCounter++), x + labelOffset, y - labelOffset);
            });
        });
    };

    linkedFeatures.forEach(feature => {
        drawGeometryOnCanvas(ctx, feature.geometry, 'rgb(255, 87, 34)', params);
    });
    
    drawGeometryOnCanvas(ctx, mainGeometry, 'rgb(33, 150, 243)', params);

    drawPointsAndLabelsForPrint(mainGeometry, '#FF4081');

    linkedFeatures.forEach(feature => {
        drawCalloutLabel(ctx, feature, params);
    });

    return canvas.toDataURL('image/png');
}

function parseLinkedCadNumbers() {
    const numbers = new Set();
    const links = document.querySelectorAll('#resultTable span[onclick^="copyAndOpen"]');
    links.forEach(link => {
        const match = link.getAttribute('onclick').match(/'([^']+)'/);
        if (match && match[1]) {
            numbers.add(match[1]);
        }
    });
    return Array.from(numbers);
}

async function fetchAllLinkedGeometries(cadNumbers) {
    if (!cadNumbers || cadNumbers.length === 0) return [];
    const promises = cadNumbers.map(cn => {
        const path = `/api/geoportal/v2/search/geoportal?thematicSearchId=1&query=${encodeURIComponent(cn)}`;
        return fetchWithFallback(path)
            .then(res => res.ok ? res.json() : null)
            .then(data => (data && data.data.features.length > 0) ? data.data.features[0] : null)
            .catch(() => null);
    });
    const results = await Promise.all(promises);
    return results.filter(r => r && r.geometry && r.geometry.coordinates && r.geometry.coordinates.length > 0);
}

function getGeometryType(coords) {
    if (!coords || coords.length === 0) return null;
    if (Array.isArray(coords[0][0])) {
        if (Array.isArray(coords[0][0][0])) return "MultiPolygon";
        return "Polygon";
    }
    return "LineString";
}


async function createPrintableHtml(tableHtml, mainGeometry, linkedFeatures, mskCoords, cadNumber) {
    const drawingDataUrl = await drawForPrint(mainGeometry, linkedFeatures);

    let coordsContentHtml = '';
    const COLUMN_BREAK_THRESHOLD = 30;

    if (mskCoords && mskCoords.length > 0) {
        coordsContentHtml += `<h4 class="coords-title">Координаты характерных точек границ (МСК)</h4>`;

        if (mskCoords.length > COLUMN_BREAK_THRESHOLD) {
            const midpoint = Math.ceil(mskCoords.length / 2);
            const firstColumnCoords = mskCoords.slice(0, midpoint);
            const secondColumnCoords = mskCoords.slice(midpoint);

            coordsContentHtml += `
                <div class="coords-flex-container">
                    <div class="coords-column">
                        <table>
                            <thead><tr><th>№</th><th>X</th><th>Y</th></tr></thead>
                            <tbody>
                                ${firstColumnCoords.map((coord, index) => `
                                    <tr><td>${index + 1}</td><td>${coord.x.toFixed(2)}</td><td>${coord.y.toFixed(2)}</td></tr>
                                `).join('')}
                            </tbody>
                        </table>
                    </div>
                    <div class="coords-column">
                        <table>
                            <thead><tr><th>№</th><th>X</th><th>Y</th></tr></thead>
                            <tbody>
                                ${secondColumnCoords.map((coord, index) => `
                                    <tr><td>${midpoint + index + 1}</td><td>${coord.x.toFixed(2)}</td><td>${coord.y.toFixed(2)}</td></tr>
                                `).join('')}
                            </tbody>
                        </table>
                    </div>
                </div>`;
        } else {
            coordsContentHtml += `
                <table>
                    <thead><tr><th>№</th><th>X</th><th>Y</th></tr></thead>
                    <tbody>
                        ${mskCoords.map((coord, index) => `
                            <tr><td>${index + 1}</td><td>${coord.x.toFixed(2)}</td><td>${coord.y.toFixed(2)}</td></tr>
                        `).join('')}
                    </tbody>
                </table>`;
        }
    }

    const currentDate = new Intl.DateTimeFormat('ru-RU').format(new Date());

    const printStyles = `
        :root {
            --primary-blue: #2A6496;
            --border-blue: #B4CDE0;
            --header-bg: #EAF2F8;
            --zebra-stripe: #F7F9FA;
            --text-color: #212529;
            --subtle-text: #6c757d;
        }
        @page {
            size: A4 portrait;
            margin: 1.5cm;
        }
        html, body {
            margin: 0;
            padding: 0;
            font-family: Arial, sans-serif;
            font-size: 9.5pt;
            color: var(--text-color);
        }
        .report-header, .report-footer {
            width: 100%;
            text-align: center;
            color: var(--subtle-text);
            font-size: 8pt;
            position: fixed;
        }
        .report-header {
            top: 0.5cm;
            font-weight: bold;
            font-size: 9pt;
        }
        .report-footer {
            bottom: 0.5cm;
        }
        .report-container {
            display: flex;
            flex-direction: column;
            width: 100%;
        }
        .table-block, .image-block, .coords-wrapper {
            width: 100%;
            page-break-inside: avoid;
            margin-bottom: 0.8cm;
        }
        .image-block {
            text-align: center;
        }
        .image-block img {
            max-width: 100%;
            max-height: 11cm;
            object-fit: contain;
            border: 1px solid var(--border-blue);
        }
        table {
            width: 100%;
            border-collapse: collapse;
            font-size: 9pt;
            border: 1px solid var(--border-blue);
        }
        th, td {
            border: 1px solid var(--border-blue);
            padding: 6px 8px;
            text-align: left;
            line-height: 1.4;
        }
        .table-block td:first-child {
            font-weight: bold;
            background-color: var(--header-bg);
            width: 30%;
        }
        .table-block tr:nth-child(even) td {
            background-color: var(--zebra-stripe);
        }
        .table-block tr:nth-child(even) td:first-child {
             background-color: var(--header-bg);
        }
        
        .coords-wrapper .coords-title {
            margin: 0 0 8px 0;
            text-align: center;
            font-size: 11pt;
            font-weight: bold;
            color: var(--primary-blue);
        }
        .coords-wrapper table { font-size: 8pt; }
        .coords-wrapper th {
            background-color: var(--header-bg);
            color: var(--primary-blue);
            font-weight: bold;
        }
        .coords-wrapper td, .coords-wrapper th {
             text-align: center;
             padding: 4px;
        }
        .coords-flex-container { display: flex; gap: 10px; }
        .coords-column { flex: 1; }
        .copy-icon-button, .fas.fa-link, img[onclick] { display: none !important; }
    `;

    return `
        <!DOCTYPE html>
        <html lang="ru">
        <head>
            <meta charset="UTF-8">
            <title>Выписка по объекту: ${cadNumber}</title>
            <style>${printStyles}</style>
        </head>
        <body>
       

            <div class="report-container">
                <div class="table-block">${tableHtml}</div>
                <div class="image-block"><img src="${drawingDataUrl}"></div>
                <div class="coords-wrapper">${coordsContentHtml}</div>
            </div>

     
        </body>
        </html>
    `;
}


async function convertCoordsToMsk(coordsToConvert, cadastralNumber) {
    if (!coordsToConvert || coordsToConvert.length === 0 || !cadastralNumber) {
        return [];
    }

    try {
        const mskCode = MskFinder.findMskCode(cadastralNumber);
        if (!mskCode) throw new Error(`Не удалось определить МСК для ${cadastralNumber}`);

        let targetSystem = COORDINATE_SYSTEMS.find(s => s.text.includes(`МСК-${mskCode}`) || s.text.includes(`МСК ${mskCode}`) || s.text.includes(mskCode));
        if (!targetSystem) throw new Error(`Определение для МСК-${mskCode} не найдено.`);

        proj4.defs(targetSystem.value, targetSystem.def);
        const {
            offsetX = 0, offsetY = 0
        } = targetSystem;

        const mskCoords = [];
        const allPoints = getAllCoordsFromGeometry({
            type: getGeometryType(coordsToConvert),
            coordinates: coordsToConvert
        });
        
        // Удаляем дублирующую последнюю точку, если контур замкнут
        const uniquePoints = (allPoints[0][0] === allPoints[allPoints.length - 1][0] && allPoints[0][1] === allPoints[allPoints.length - 1][1])
            ? allPoints.slice(0, -1)
            : allPoints;

        uniquePoints.forEach(point => {
            const [lon, lat] = proj4('EPSG:3857', targetSystem.value, point);
            mskCoords.push({
                x: lat + offsetX,
                y: lon + offsetY
            });
        });

        return mskCoords;
    } catch (error) {
        console.error("Ошибка при конвертации координат в МСК:", error);
        showNotification(error.message, 'error');
        return [];
    }
}

async function generatePrintLayout() {
    const tableBody = document.querySelector('#resultTable tbody');
    if (!tableBody || tableBody.children.length === 0 || !currentCoords) {
        showNotification('Нет данных для печати', 'warning');
        return;
    }

    showLoader('Подготовка отчета к печати...');

    try {
        const cadNumRow = Array.from(tableBody.querySelectorAll('tr')).find(row => row.cells[0].textContent.trim() === 'Кадастровый номер');
        const cadNumber = cadNumRow ? cadNumRow.cells[1].textContent.trim().replace(/<[^>]*>?/gm, '') : '';

        const mainTableHtml = document.getElementById('resultTable').outerHTML;
        const mainGeometry = {
            type: getGeometryType(currentCoords),
            coordinates: currentCoords
        };

        const [linkedGeometries, mskCoords] = await Promise.all([
            fetchAllLinkedGeometries(parseLinkedCadNumbers()),
            convertCoordsToMsk(currentCoords, cadNumber)
        ]);

        const printHtml = await createPrintableHtml(mainTableHtml, mainGeometry, linkedGeometries, mskCoords, cadNumber);

        const printWindow = window.open('', '_blank');
        printWindow.document.write(printHtml);
        printWindow.document.close();
        printWindow.focus();

        setTimeout(() => {
            printWindow.print();
        }, 500);

    } catch (error) {
        console.error("Ошибка при формировании отчета:", error);
        showNotification('Ошибка при формировании отчета', 'error');
    } finally {
        hideLoader();
    }
}


function promptUserForMsk(candidates, regionCode) {
    return new Promise((resolve, reject) => {
        const modal = document.getElementById('mskSelectionModal');
        const listContainer = document.getElementById('mskListContainer');
        const regionDisplay = document.getElementById('mskRegionDisplay');
        const closeBtn = modal.querySelector('.close-modal');

        regionDisplay.textContent = regionCode;
        listContainer.innerHTML = '';

        const cleanup = () => {
            modal.style.display = 'none';
            closeBtn.onclick = null;
            window.onclick = null;
        };

        candidates.forEach(sys => {
            const item = document.createElement('div');
            item.className = 'msk-list-item';
            item.innerHTML = `<i class="fas fa-map-marker-alt"></i> ${sys.text}`;
            
            item.onclick = () => {
                cleanup();
                
                // --- НОВАЯ ЛОГИКА ---
                userSelectedMsk = sys; // Сохраняем в глобальную переменную
                updateTableMskRow(sys.text); // Обновляем таблицу моментально
                // --------------------
                
                resolve(sys);
            };
            
            listContainer.appendChild(item);
        });

        closeBtn.onclick = () => {
            cleanup();
            reject(new Error('User cancelled'));
        };

        window.onclick = (event) => {
            if (event.target == modal) {
                cleanup();
                reject(new Error('User cancelled'));
            }
        };

        modal.style.display = 'block';
    });
}





// Инициализация при загрузке страницы
window.onload = function() {
    showDistanceLabels = loadToggleState(); // Load the state from local storage
    document.getElementById('distanceToggle').checked = showDistanceLabels;
    document.getElementById('cadastralNumber').focus();

    // Check the clipboard for a cadastral number and insert it if available
    checkClipboardForCadastralNumber();

    // Check if the device is mobile
    if (window.innerWidth < 768) {
        const canvasContainer = document.querySelector('.scheme-container');
        canvasContainer.style.display = 'block';
        drawScheme();
        toggleVirtualKeyboard();
    }
};
</script>
    
</body>
</html>