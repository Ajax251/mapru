<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Проверка текста</title>
    <link rel="icon" href="img/check.png" type="image/png">
    <link rel="stylesheet" href="webfonts/all.min.css">
    <style>
        body { font-family: Arial, sans-serif; margin: 0; padding: 0; display: flex; flex-direction: column; min-height: 100vh; background-color: #f0f0f0; }
        h1 { text-align: center; padding: 15px; background-color: #4CAF50; color: white; margin: 0; font-size: 1.5em; }
        #container { display: flex; flex-direction: column; align-items: center; flex: 1; padding: 20px; box-sizing: border-box; }
        #textInput { width: 100%; height: 60vh; padding: 10px; font-size: 16px; border: 2px solid #ccc; border-radius: 5px; box-sizing: border-box; resize: none; margin-bottom: 10px; transition: border-color 0.3s ease; }
        #textInput:focus { border-color: #4CAF50; outline: none; }
        #textInput:disabled { background-color: #e9e9e9; cursor: wait; }
        button { padding: 10px 15px; font-size: 15px; background-color: #4CAF50; color: white; border: none; border-radius: 5px; cursor: pointer; transition: background-color 0.3s; margin-bottom: 20px; display: inline-flex; align-items: center; justify-content: center; }
        button i { margin-right: 8px; }
        button:hover { background-color: #45a049; }
        #resultsContainer { display: flex; width: 100%; justify-content: space-around; flex-wrap: wrap; gap: 15px; }
        #cadastralResult, #linksResult, #foreignLettersResult, #fileNamesResult, #datesResult { flex-basis: calc(33.333% - 20px); flex-grow: 1; min-width: 280px; border: 1px solid #e0e0e0; border-radius: 8px; padding: 15px; box-sizing: border-box; background-color: white; box-shadow: 0 2px 4px rgba(0,0,0,0.1); margin-bottom: 20px; }
        #foreignLettersResult { display: none; }
        .result-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; border-bottom: 2px solid #e0e0e0; padding-bottom: 10px; }
        .result-icon { font-size: 24px; color: #4CAF50; }
        .save-icon { font-size: 20px; color: #4CAF50; cursor: pointer; transition: color 0.3s; }
        .save-icon:hover { color: #45a049; }
        #cadastralResult ul, #linksResult ul, #foreignLettersResult ul, #fileNamesResult ul, #datesResult ul { list-style-type: none; padding: 0; margin: 0; max-height: 220px; overflow-y: auto; }
        #cadastralResult li, #linksResult li, #foreignLettersResult li, #fileNamesResult li, #datesResult li { background-color: #f9f9f9; margin-bottom: 8px; padding: 10px; border-radius: 4px; transition: background-color 0.3s ease; text-align: left;  word-break: break-all; display: flex;  justify-content: space-between;  align-items: center;  }
        #cadastralResult li .cadastral-number-text { cursor: pointer; flex-grow: 1; margin-right: 5px; }
        #cadastralResult li .cadastral-icons img { cursor: pointer; vertical-align: middle; width: 16px; height: 16px; }
        #cadastralResult li .cadastral-icons img:first-child { margin-left: 8px; }
        #cadastralResult li .cadastral-icons img + img { margin-left: 5px; }
        .error-category { background-color: #e0e0e0 !important; font-weight: bold; cursor: default !important; padding: 8px 10px !important; margin-top: 10px !important; margin-bottom: 10px !important; }
        .error-category:first-child { margin-top: 0 !important; }
        #cadastralResult li:hover, #linksResult li:hover, #foreignLettersResult li:not(.error-category):hover, #fileNamesResult li:hover, #datesResult li:hover { background-color: #f0f0f0; }
        #linksResult a { color: #305cde; text-decoration: none; transition: color 0.3s ease; display: block; }
        #linksResult a:hover { color: #1c3fa3; text-decoration: underline; }
        .error { background-color: #ffdddd; color: #f44336; padding: 2px 4px; border-radius: 3px; }
        .foreign-letter span { background-color: #ffe6e6; color: #ff0000; font-weight: bold; padding: 0 1px; }
        .inner-cadastral .cadastral-number-text { color: #39b54a; }
        .not-found .cadastral-number-text { color: red; }
        .not-found { color: red; }
        @keyframes flash { 0% { background-color: #f9f9f9; } 50% { background-color: #4CAF50; color: white; } 100% { background-color: #f9f9f9; } }
        .flash { animation: flash 0.5s; }
        #cadastralResult ul::-webkit-scrollbar, #linksResult ul::-webkit-scrollbar, #foreignLettersResult ul::-webkit-scrollbar, #fileNamesResult ul::-webkit-scrollbar, #datesResult ul::-webkit-scrollbar { width: 8px; }
        #cadastralResult ul::-webkit-scrollbar-track, #linksResult ul::-webkit-scrollbar-track, #foreignLettersResult ul::-webkit-scrollbar-track, #fileNamesResult ul::-webkit-scrollbar-track, #datesResult ul::-webkit-scrollbar-track { background: #f1f1f1; }
        #cadastralResult ul::-webkit-scrollbar-thumb, #linksResult ul::-webkit-scrollbar-thumb, #foreignLettersResult ul::-webkit-scrollbar-thumb, #fileNamesResult ul::-webkit-scrollbar-thumb, #datesResult ul::-webkit-scrollbar-thumb { background: #888; border-radius: 4px; }
        #cadastralResult ul::-webkit-scrollbar-thumb:hover, #linksResult ul::-webkit-scrollbar-thumb:hover, #foreignLettersResult ul::-webkit-scrollbar-thumb:hover, #fileNamesResult ul::-webkit-scrollbar-thumb:hover, #datesResult ul::-webkit-scrollbar-thumb:hover { background: #555; }
        .flash-animation { animation: flashTextarea 0.3s; }
        @keyframes flashTextarea { 0% { border-color: #ccc; } 50% { border-color: #4CAF50; box-shadow: 0 0 5px #4CAF50; } 100% { border-color: #ccc; } }
        #statusBar { position: fixed; bottom: 0; left: 0; right: 0; background-color: #4CAF50; color: white; padding: 8px 12px; font-size: 13px; box-shadow: 0 -2px 5px rgba(0,0,0,0.2); display: flex; align-items: center; flex-wrap: wrap; justify-content: space-around; transition: opacity 0.3s ease, transform 0.3s ease; transform: translateY(100%); opacity: 0; z-index: 900; }
        #statusBar.visible { transform: translateY(0); opacity: 1; }
        #statusBar i { margin-right: 5px; font-size: 14px; }
        #statusBar span { margin: 2px 8px; white-space: nowrap; }
        #buttonContainer { display: flex; justify-content: space-around; flex-wrap: wrap; width: 100%; margin-bottom: 20px; gap: 10px; }
        #copyButton { background-color: #FFA500; }
        #copyButton:hover { background-color: #cc8400; }
        #checkWithAIButton { background-color: #2196F3; }
        #checkWithAIButton:hover { background-color: #1769aa; }
        .flash-button { animation: flashButtonAnim 0.3s; }
        @keyframes flashButtonAnim { 0% { transform: scale(1); } 50% { transform: scale(1.05); filter: brightness(1.2); } 100% { transform: scale(1); } }
        #currentLine { margin-left: auto; padding: 2px 8px; background-color: rgba(255, 255, 255, 0.2); border-radius: 3px; }
        #datesResult li.invalid-date { background-color: #ffdddd; color: #d8000c; font-weight: bold; }
        .ai-modal-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.6); display: flex; justify-content: center; align-items: center; z-index: 1000; padding: 20px; box-sizing: border-box; }
        .ai-modal-content { background-color: white; padding: 25px; border-radius: 8px; box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3); width: 80%; height: 80%; max-width: 1200px; display: flex; flex-direction: column; position: relative; }
        .ai-modal-content h2 { margin-top: 0; margin-bottom: 15px; text-align: center; color: #333; font-size: 1.3em; }
        .ai-modal-close-button { position: absolute; top: 10px; right: 15px; font-size: 32px; font-weight: bold; color: #888; cursor: pointer; line-height: 1; padding: 0 5px; }
        .ai-modal-close-button:hover { color: #555; }
        .ai-result-display-area { flex-grow: 1; overflow-y: auto; border: 1px solid #ddd; padding: 15px; font-size: 16px; line-height: 1.6; background-color: #fdfdfd; white-space: pre-wrap; word-wrap: break-word; color: #333; }
        .ai-result-display-area::-webkit-scrollbar { width: 8px; }
        .ai-result-display-area::-webkit-scrollbar-track { background: #f1f1f1;}
        .ai-result-display-area::-webkit-scrollbar-thumb { background: #888; border-radius: 4px; }
        .ai-result-display-area::-webkit-scrollbar-thumb:hover { background: #555; }
        .ai-correction-item { padding: 3px 0; font-size: 0.9em; }
        .ai-correction-original { text-decoration: line-through; color: #c00; margin-right: 5px; }
        .ai-correction-corrected { color: green; font-weight: bold; }
        #aiCheckModal button.modal-action-button { margin-top: 15px; align-self: center; background-color: #007bff; font-size: 15px; padding: 8px 15px; }
        #aiCheckModal button.modal-action-button:hover { background-color: #0056b3; }
        #aiCheckLoading { text-align: center; padding: 20px; font-size: 1.2em; color: #555; }
        #aiCheckLoading i { font-size: 2.5em; color: #4CAF50; margin-bottom: 10px; }
        .cert-error-guidance-popup { position: fixed; top: 20px; left: 50%; transform: translateX(-50%); background-color: #fff3cd; color: #856404; border: 1px solid #ffeeba; padding: 15px 20px; border-radius: 5px; box-shadow: 0 4px 8px rgba(0,0,0,0.15); z-index: 2000; max-width: 90%; text-align: left; }
        .cert-error-guidance-popup p { margin: 0 0 10px 0; }
        .cert-error-guidance-popup button { background-color: #007bff; color: white; border: none; padding: 8px 12px; border-radius: 4px; cursor: pointer; margin-right: 10px; }
        .cert-error-guidance-popup button:hover { background-color: #0056b3; }
        .cert-error-guidance-popup .close-cert-popup { background-color: #6c757d; }
        .cert-error-guidance-popup .close-cert-popup:hover { background-color: #5a6268; }
    </style>
</head>
<body>
    <h1>Проверка текста</h1>
    <div id="container">
        <textarea id="textInput" placeholder="Введите текст для анализа или вставьте изображение..."></textarea>
        <div id="buttonContainer">
            <button onclick="analyzeText()"><i class="fas fa-check"></i> Проверить</button>
            <button id="checkWithAIButton" onclick="checkGrammarWithAI()"><i class="fas fa-spell-check"></i> Проверить с ИИ</button>
            <button id="copyButton" onclick="copyText()"><i class="fas fa-copy"></i> Копировать</button>
        </div>
        <div id="resultsContainer">
            <div id="cadastralResult"></div>
            <div id="linksResult"></div>
            <div id="foreignLettersResult"></div>
            <div id="datesResult"></div>
            <div id="fileNamesResult"></div>
        </div>
    </div>

    <div id="statusBar">
        <i class="fas fa-info-circle"></i>
        <span id="charCount">Символов: 0</span>
        <span id="wordCount">Слов: 0</span>
        <span id="lineCount">Строк: 0</span>
        <span id="removedSpaces">Удалено пробелов: 0</span>
        <span id="removedLines">Удалено строк: 0</span>
        <span id="addedSpaces">Добавлено пробелов: 0</span>
        <span id="addedPeriods">Добавлено точек: 0</span>
        <span id="currentLine">Строка: -</span>
    </div>

    <div id="aiCheckModal" class="ai-modal-overlay" style="display: none;">
        <div class="ai-modal-content">
            <span class="ai-modal-close-button" onclick="closeAiModal()">&times;</span>
            <h2>Результат проверки ИИ</h2>
            <div id="aiCheckLoading" style="display: none;">
                <i class="fas fa-spinner fa-spin"></i>
                <p>Пожалуйста, подождите...</p>
            </div>
            <div id="aiResultDisplay" class="ai-result-display-area"></div>
            <div id="aiCorrectionsListWrapper" style="margin-top: 15px; min-height: 25vh; overflow-y: auto; border-top: 1px solid #eee; padding-top: 10px; display: none;">
                <h4>Список исправлений:</h4>
                <ul id="aiCorrectionsList"></ul>
            </div>
            <button class="modal-action-button" onclick="copyAiCorrectedTextToClipboard(this)" title="Копировать исправленный текст">
                <i class="fas fa-clipboard"></i> Копировать исправленный текст
            </button>
        </div>
    </div>

    <div id="crop-image-modal" style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; background-color:rgba(0,0,0,0.7); z-index:10001; justify-content:center; align-items:center; flex-direction: column;">
        <div class="crop-modal-content-wrapper" style="background-color:white; padding:20px; border-radius:10px; box-shadow:0 0 15px rgba(0,0,0,0.5); max-width:95vw; max-height:95vh; overflow:auto; text-align:center;">
            <h3 style="margin-top:0;">Обрезать изображение</h3>
            <p style="font-size:0.9em; color:#555;">Нажмите и перетащите на изображении, чтобы выбрать область.</p>
            <div id="crop-image-container" style="position:relative; display:inline-block; border:1px dashed #ccc; user-select:none; touch-action:none; max-width:100%; max-height:calc(85vh - 120px); overflow:hidden; cursor:crosshair;">
                <img id="crop-image-preview" src="#" alt="Preview" style="display:block; max-width:100%; max-height:100%; user-select:none; -webkit-user-drag:none;" />
                <div id="crop-selection-rectangle" style="position:absolute; border:2px solid rgba(0,123,255,0.7); background-color:rgba(0,123,255,0.1); display:none; pointer-events:none;"></div>
            </div>
            <div class="crop-modal-buttons" style="margin-top:15px; display: flex; justify-content: center; gap: 15px;">
                <button id="crop-image-button-confirm" style="padding:10px 20px; background-color:#4CAF50; color:white; border:none; border-radius:8px; cursor:pointer; font-size: 1rem;">
                    <i class="fas fa-check"></i> Применить
                </button>
                <button id="crop-image-button-cancel" style="padding:10px 20px; background-color:#f44336; color:white; border:none; border-radius:8px; cursor:pointer; font-size: 1rem;">
                    <i class="fas fa-times"></i> Использовать всё
                </button>
            </div>
        </div>
    </div>

    <script>
        const VERCEL_PROXY_BASE_URL = "https://ver-olive-delta.vercel.app";
        const MAPRUAPP_PROXY_BASE_URL = "https://mapruapp.ru"; // Ваш прокси
        const OCR_PROMPT_FOR_AI = "Extract all text from the following image. Return ONLY the extracted text, without any preambles, comments, explanations, or any surrounding text. If no text is found, return an empty string.";
      
        // --- ПЕРЕКЛЮЧАТЕЛЬ ПРОКСИ ---
        // 1 = Использовать прокси mapruapp (по умолчанию)
        // 0 = Использовать прокси vercel
        const PROXY_MODE = 1;

        function showCropModal(imageFile) {
            return new Promise((resolve) => {
                const modal = document.getElementById('crop-image-modal');
                const imgPreview = document.getElementById('crop-image-preview');
                const cropContainer = document.getElementById('crop-image-container');
                const selectionRectDiv = document.getElementById('crop-selection-rectangle');
                const confirmButton = document.getElementById('crop-image-button-confirm');
                const cancelButton = document.getElementById('crop-image-button-cancel');
                let cropSelection = { startX: 0, startY: 0, endX: 0, endY: 0, isDrawing: false };
                let imageNaturalSize = { width: 0, height: 0 };
                let imageDisplaySize = { width: 0, height: 0 };
                selectionRectDiv.style.display = 'none';
                cropSelection.isDrawing = false;
                const reader = new FileReader();
                reader.onload = function(e) {
                    imgPreview.src = e.target.result;
                    modal.style.display = 'flex';
                    imgPreview.onload = () => {
                        imageNaturalSize.width = imgPreview.naturalWidth;
                        imageNaturalSize.height = imgPreview.naturalHeight;
                        imageDisplaySize.width = imgPreview.offsetWidth;
                        imageDisplaySize.height = imgPreview.offsetHeight;
                    };
                };
                reader.readAsDataURL(imageFile);
                function updateSelectionRect() {
                    const x = Math.min(cropSelection.startX, cropSelection.endX);
                    const y = Math.min(cropSelection.startY, cropSelection.endY);
                    const width = Math.abs(cropSelection.endX - cropSelection.startX);
                    const height = Math.abs(cropSelection.endY - cropSelection.startY);
                    selectionRectDiv.style.left = `${x}px`;
                    selectionRectDiv.style.top = `${y}px`;
                    selectionRectDiv.style.width = `${width}px`;
                    selectionRectDiv.style.height = `${height}px`;
                }
                function getMousePos(event) {
                    const rect = cropContainer.getBoundingClientRect();
                    let x = event.clientX - rect.left;
                    let y = event.clientY - rect.top;
                    x = Math.max(0, Math.min(x, imageDisplaySize.width));
                    y = Math.max(0, Math.min(y, imageDisplaySize.height));
                    return { x, y };
                }
                const onMouseDown = (e) => {
                    e.preventDefault();
                    cropSelection.isDrawing = true;
                    const pos = getMousePos(e.touches ? e.touches[0] : e);
                    cropSelection.startX = pos.x;
                    cropSelection.startY = pos.y;
                    cropSelection.endX = pos.x;
                    cropSelection.endY = pos.y;
                    selectionRectDiv.style.display = 'block';
                    updateSelectionRect();
                    cropContainer.addEventListener('mousemove', onMouseMove);
                    cropContainer.addEventListener('touchmove', onMouseMove, { passive: false });
                    window.addEventListener('mouseup', onMouseUp);
                    window.addEventListener('touchend', onMouseUp);
                };
                const onMouseMove = (e) => {
                    if (!cropSelection.isDrawing) return;
                    e.preventDefault();
                    const pos = getMousePos(e.touches ? e.touches[0] : e);
                    cropSelection.endX = pos.x;
                    cropSelection.endY = pos.y;
                    updateSelectionRect();
                };
                const onMouseUp = () => {
                    if (!cropSelection.isDrawing) return;
                    cropSelection.isDrawing = false;
                    cropContainer.removeEventListener('mousemove', onMouseMove);
                    window.removeEventListener('mouseup', onMouseUp);
                    cropContainer.removeEventListener('touchmove', onMouseMove);
                    window.removeEventListener('touchend', onMouseUp);
                };
                cropContainer.addEventListener('mousedown', onMouseDown);
                cropContainer.addEventListener('touchstart', onMouseDown, { passive: false });
                const handleConfirm = () => {
                    const selWidth = Math.abs(cropSelection.endX - cropSelection.startX);
                    const selHeight = Math.abs(cropSelection.endY - cropSelection.startY);
                    if (selWidth < 10 || selHeight < 10 || selectionRectDiv.style.display === 'none') {
                        handleCancel();
                        return;
                    }
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    const scaleX = imageNaturalSize.width / imageDisplaySize.width;
                    const scaleY = imageNaturalSize.height / imageDisplaySize.height;
                    const sX = Math.min(cropSelection.startX, cropSelection.endX) * scaleX;
                    const sY = Math.min(cropSelection.startY, cropSelection.endY) * scaleY;
                    const sWidth = selWidth * scaleX;
                    const sHeight = selHeight * scaleY;
                    canvas.width = sWidth;
                    canvas.height = sHeight;
                    ctx.drawImage(imgPreview, sX, sY, sWidth, sHeight, 0, 0, sWidth, sHeight);
                    const croppedImageDataUrl = canvas.toDataURL(imageFile.type || 'image/jpeg');
                    resolve(croppedImageDataUrl);
                    cleanupModal();
                };
                const handleCancel = () => {
                    fileToBase64(imageFile).then(base64 => resolve(base64));
                    cleanupModal();
                };
                const cleanupModal = () => {
                    modal.style.display = 'none';
                    imgPreview.src = '#';
                    imgPreview.onload = null;
                    cropContainer.removeEventListener('mousedown', onMouseDown);
                    cropContainer.removeEventListener('touchstart', onMouseDown);
                    confirmButton.onclick = null;
                    cancelButton.onclick = null;
                };
                confirmButton.onclick = handleConfirm;
                cancelButton.onclick = handleCancel;
            });
        }
      
        document.getElementById('textInput').addEventListener('paste', async function(e) {
            const items = (e.clipboardData || window.clipboardData).items;
            let imageFile = null;
            if (items) {
                for (let i = 0; i < items.length; i++) {
                    if (items[i].kind === 'file' && items[i].type.startsWith('image/')) {
                        imageFile = items[i].getAsFile();
                        break;
                    }
                }
            }
            if (imageFile) {
                e.preventDefault();
                const textInput = document.getElementById('textInput');
                const originalPlaceholder = textInput.placeholder;
                textInput.placeholder = "Обработка изображения...";
                textInput.disabled = true;
                try {
                    const tempImg = new Image();
                    const objectURL = URL.createObjectURL(imageFile);
                    let imageDataUrlForAI;
                    await new Promise((resolve, reject) => {
                        tempImg.onload = resolve;
                        tempImg.onerror = reject;
                        tempImg.src = objectURL;
                    });
                    URL.revokeObjectURL(objectURL);

                    if (tempImg.naturalWidth > 600 || tempImg.naturalHeight > 600) {
                        imageDataUrlForAI = await showCropModal(imageFile);
                    } else {
                        imageDataUrlForAI = await fileToBase64(imageFile);
                    }
                    if (!imageDataUrlForAI) throw new Error("Не удалось получить данные изображения после обработки.");
                    
                    textInput.placeholder = "Распознавание текста из изображения...";
                    let recognizedText = await performOcrWithAI(imageDataUrlForAI);
                    
                    const commonPreambles = [ /^\s*Here is the text extracted from the image:\s*/i, /^\s*The text in the image is:\s*/i, /^\s*Extracted text:\s*/i, /^\s*Recognized text:\s*/i, /^\s*Text from image:\s*/i, /^\s*Вот текст, извлеченный из изображения:\s*/i ];
                    for (const preambleRegex of commonPreambles) { if (preambleRegex.test(recognizedText)) { recognizedText = recognizedText.replace(preambleRegex, ""); break; } }
                    
                    textInput.value = recognizedText.trim();
                    analyzeText();
                } catch (error) {
                    console.error("Image Paste/OCR Error:", error);
                    alert("Не удалось распознать текст из изображения: " + error.message);
                    textInput.value = "";
                    analyzeText();
                } finally {
                    textInput.placeholder = originalPlaceholder;
                    textInput.disabled = false;
                }
            } else {
                setTimeout(function() { analyzeText(); }, 0);
            }
        });

        function fileToBase64(file) { return new Promise((resolve, reject) => { const reader = new FileReader(); reader.onload = () => resolve(reader.result);  reader.onerror = error => reject(error); reader.readAsDataURL(file); }); }

        async function performOcrWithAI(base64DataUrl) {
            const base64ImageData = base64DataUrl.split(',')[1];
            const modelId = "gemini-2.5-flash-lite"; // Модель для OCR остается прежней
            
            let requestUrl;
            let requestBody;

            // Используем переключатель PROXY_MODE для выбора URL и тела запроса
            if (PROXY_MODE === 1) {
                // Логика для прокси mapruapp
                requestUrl = `${MAPRUAPP_PROXY_BASE_URL}/ai/api/v1/chat/completions`;
                requestBody = {
                    model: modelId,
                    messages: [{
                        role: "user",
                        content: [
                            { type: "text", text: OCR_PROMPT_FOR_AI },
                            { type: "image_url", image_url: { url: `data:image/jpeg;base64,${base64ImageData}` } }
                        ]
                    }],
                    max_tokens: 4096
                };
            } else {
                // Логика для прокси vercel
                requestUrl = `${VERCEL_PROXY_BASE_URL}/v1beta/models/${modelId}:generateContent`;
                requestBody = {
                    contents: [{
                        role: "user",
                        parts: [
                            { text: OCR_PROMPT_FOR_AI },
                            { inlineData: { mimeType: "image/jpeg", data: base64ImageData } }
                        ]
                    }]
                };
            }

            try {
                const response = await fetch(requestUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(requestBody)
                });

                const data = await response.json();

                if (!response.ok) {
                    const errorDetail = data?.error?.message || `Статус ${response.status}`;
                    throw new Error(`Ошибка OCR API через прокси: ${errorDetail}`);
                }

                let recognizedText;
                if (PROXY_MODE === 1) {
                    recognizedText = data.choices?.[0]?.message?.content;
                } else {
                    recognizedText = data.candidates?.[0]?.content?.parts?.[0]?.text;
                }
                
                if (typeof recognizedText === 'string') {
                    return recognizedText;
                } else if (data.candidates?.[0]?.finishReason === 'SAFETY') {
                    throw new Error("Ответ заблокирован моделью по соображениям безопасности.");
                } else {
                    console.warn("AI OCR response structure not as expected:", data);
                    throw new Error('ИИ не вернул текстовый ответ для изображения.');
                }
            } catch (error) {
                console.error("Ошибка при вызове OCR API через прокси:", error);
                throw error; // Перебрасываем ошибку для обработки вызывающей функцией
            }
        }

        function extractDates(text) {
            const regex = /(\b\d{2}\.\d{2}\.\d{4}\b)|(\b\d{2}\.\d{2}\.\d{2}\b)|(\b\d{4}-\d{2}-\d{2}\b)/g;
            const matches = text.match(regex) || []; const resultDiv = document.getElementById('datesResult');
            if (matches.length > 0) {
                const uniqueMatches = [...new Set(matches)]; const currentDate = new Date(); const minDate = new Date('1990-01-01');
                resultDiv.innerHTML = '<div class="result-header"><i class="fas fa-calendar-alt result-icon" title="Даты"></i><i class="fas fa-save save-icon" onclick="downloadDates()" title="Сохранить даты"></i></div><ul>' +
                    uniqueMatches.map(dateStr => {
                        let dateObj, isValidDateStruct = true;
                        try {
                            if (dateStr.includes('-')) { const [year, month, day] = dateStr.split('-').map(Number); dateObj = new Date(Date.UTC(year, month - 1, day)); if (dateObj.getUTCFullYear() !== year || dateObj.getUTCMonth() !== month - 1 || dateObj.getUTCDate() !== day) isValidDateStruct = false;
                            } else { const parts = dateStr.split('.').map(Number); let year = parts[2]; if (String(parts[2]).length === 2) year += (year < 70 ? 2000 : 1900); dateObj = new Date(Date.UTC(year, parts[1] - 1, parts[0])); if (dateObj.getUTCFullYear() !== year || dateObj.getUTCMonth() !== parts[1] - 1 || dateObj.getUTCDate() !== parts[0]) isValidDateStruct = false; }
                        } catch (e) { isValidDateStruct = false; }
                        const isOutOfRange = !isValidDateStruct || dateObj < minDate || dateObj > currentDate; const className = isOutOfRange ? 'class="invalid-date"' : '';
                        return `<li ${className} onclick="copyToClipboard('${dateStr}', this)">${dateStr}</li>`;
                    }).join('') + '</ul>';
            } else { resultDiv.innerHTML = '<div class="result-header"><i class="fas fa-calendar-alt result-icon" title="Даты"></i></div><p>Даты не найдены.</p>'; }
        }
        function extractFileNames(text) {
            const regex = /"([^"]+\.[a-zA-Z0-9]{3,5})"/g; const matches = text.matchAll(regex); const fileNames = new Set();
            for (const match of matches) { const fullPath = match[1]; const fileName = fullPath.split(/[\\/]/).pop(); fileNames.add(fileName); }
            const resultDiv = document.getElementById('fileNamesResult');
            if (fileNames.size > 0) { const uniqueFileNames = Array.from(fileNames); resultDiv.innerHTML = '<div class="result-header"><i class="fas fa-file result-icon" title="Имена файлов"></i><i class="fas fa-save save-icon" onclick="downloadFileNames()" title="Сохранить имена файлов"></i></div><ul>' + uniqueFileNames.map(fileName => `<li onclick="copyToClipboard('${fileName}', this)">${fileName}</li>`).join('') + '</ul>';
            } else { resultDiv.innerHTML = '<div class="result-header"><i class="fas fa-file result-icon" title="Имена файлов"></i></div><p>Имена файлов не найдены.</p>'; }
        }
        function addMissingPeriods(text) {
            let lines = text.split('\n'); let addedPeriods = 0;
            for (let i = 0; i < lines.length; i++) {
                let currentLine = lines[i].trim(); if (currentLine === '') continue; let nextNonEmptyLine = '';
                if (i < lines.length - 1) { let j = i + 1; while (j < lines.length) { if (lines[j].trim() !== '') { nextNonEmptyLine = lines[j].trim(); break; } j++; } }
                let lastChar = currentLine[currentLine.length - 1];
                if ( (nextNonEmptyLine && /[А-ЯЁA-Z]/.test(nextNonEmptyLine[0])) || !nextNonEmptyLine ) { if (/[а-яА-ЯёЁa-zA-Z0-9)\]}"]/.test(lastChar) && !/[.!?:;,]$/.test(currentLine)) { lines[i] = currentLine + '.'; addedPeriods++; } }
            } return { text: lines.join('\n'), addedPeriods: addedPeriods };
        }
        function downloadFileNames() { const fileNames = Array.from(document.querySelectorAll('#fileNamesResult li')).map(li => li.textContent); downloadFile('file_names.txt', fileNames.join('\n')); }
        function handleCadastralIconClickEgrn(number, iconElement) { navigator.clipboard.writeText(number).then(() => { const liElement = iconElement.closest('li'); if (liElement) { liElement.classList.add('flash'); setTimeout(() => { liElement.classList.remove('flash'); }, 500); } window.open(`egrn.html#${encodeURIComponent(number)}`, '_blank'); }).catch(err => { console.error('Не удалось скопировать кадастровый номер (EGRN): ', err); alert('Не удалось скопировать кадастровый номер (EGRN).'); }); }
        function handleCadastralIconClickMapHtml(number, iconElement) { navigator.clipboard.writeText(number).then(() => { const liElement = iconElement.closest('li'); if (liElement) { liElement.classList.add('flash'); setTimeout(() => { liElement.classList.remove('flash'); }, 500); } window.open(`map.html#${encodeURIComponent(number)}`, '_blank'); }).catch(err => { console.error('Не удалось скопировать кадастровый номер (Map.html): ', err); alert('Не удалось скопировать кадастровый номер (Map.html).'); }); }
        function extractCadastralNumbers(text) {
            const regex = /\b\d+:\d+:\d{6,7}:\d+(?::\d+)?(?:[:ЗУ]\d*)?\b|\b\d{2}:\d{2}:\d{6,7}:\d+\b/g;
            const matches = text.match(regex) || []; const mpVersionRegex = /MP Version=/; const hasMpVersion = mpVersionRegex.test(text);
            const innerCadastralRegex = /<InnerCadastralNumbers>\s*<CadastralNumber>(\d+:\d+:\d{6,7}:\d+(?::\d+)?(?:[:ЗУ]\d*)?)<\/CadastralNumber>\s*<\/InnerCadastralNumbers>|<InnerCadastralNumbers>\s*<CadastralNumber>(\d{2}:\d{2}:\d{6,7}:\d+)\b<\/CadastralNumber>\s*<\/InnerCadastralNumbers>/g;
            let innerCadastralMatches = []; let match; while ((match = innerCadastralRegex.exec(text)) !== null) { innerCadastralMatches.push(match[1] || match[2]); }
            innerCadastralMatches = [...new Set(innerCadastralMatches)]; const resultDiv = document.getElementById('cadastralResult');
            let resultHTML = '<div class="result-header"><i class="fas fa-map-marker-alt result-icon" title="Кадастровые номера"></i><i class="fas fa-save save-icon" onclick="downloadNumbers()" title="Сохранить кадастровые номера"></i></div><ul>';
            let foundCadastral = false; const iconEgrnTemplate = (number) => `<img src="img/savannah.png" alt="" title="ЕГРН" onclick="handleCadastralIconClickEgrn('${number}', this)">`;
            const iconMapHtmlTemplate = (number) => `<img src="img/map.png" alt="" title="Карта" onclick="handleCadastralIconClickMapHtml('${number}', this)">`;
            if (matches.length > 0) { foundCadastral = true; const uniqueMatches = [...new Set(matches)]; uniqueMatches.forEach(number => { let isInner = innerCadastralMatches.includes(number); let liClass = isInner ? 'class="inner-cadastral"' : ''; let numberSpan = `<span class="cadastral-number-text" onclick="copyToClipboard('${number}', this.closest('li'))">${number}</span>`; let iconsSpan = `<span class="cadastral-icons">${iconEgrnTemplate(number)}${iconMapHtmlTemplate(number)}</span>`; resultHTML += `<li ${liClass}>${numberSpan}${iconsSpan}</li>`; }); }
            if (hasMpVersion) { if (innerCadastralMatches.length > 0) { foundCadastral = true; innerCadastralMatches.forEach(innerNumber => { if (!matches.includes(innerNumber)) { let textSpan = `<span class="cadastral-number-text">ОКС не найден в тексте: <span onclick="copyToClipboard('${innerNumber}', this.closest('li'))">${innerNumber}</span></span>`; let iconsSpan = `<span class="cadastral-icons">${iconEgrnTemplate(innerNumber)}${iconMapHtmlTemplate(innerNumber)}</span>`; resultHTML += `<li class="not-found">${textSpan}${iconsSpan}</li>`; } }); } else if (!foundCadastral) { resultHTML += `<li class="not-found">ОКС не найден (внутренние номера отсутствуют)</li>`; } }
            resultHTML += '</ul>'; if (!foundCadastral && (!hasMpVersion || (hasMpVersion && innerCadastralMatches.length === 0)) ) { resultHTML = '<div class="result-header"><i class="fas fa-map-marker-alt result-icon" title="Кадастровые номера"></i></div><p>Кадастровые номера не найдены.</p>'; }
            resultDiv.innerHTML = resultHTML;
        }
        function extractLinks(text) {
            const regex = /https?:\/\/[^\s«»"'()<>]+/g; const matches = text.match(regex); const resultDiv = document.getElementById('linksResult');
            if (matches) { const uniqueMatches = [...new Set(matches)]; resultDiv.innerHTML = '<div class="result-header"><i class="fas fa-link result-icon" title="HTTP-ссылки"></i><i class="fas fa-save save-icon" onclick="downloadLinks()" title="Сохранить HTTP-ссылки"></i></div><ul>' + uniqueMatches.map(link => `<li onclick="copyToClipboard('${link}', this)"><a href="${link}" target="_blank" rel="noopener noreferrer">${link}</a></li>`).join('') + '</ul>';
            } else { resultDiv.innerHTML = '<div class="result-header"><i class="fas fa-link result-icon" title="HTTP-ссылки"></i></div><p>HTTP-ссылки не найдены.</p>'; }
        }
        const punctuationMarksForClean = [',', '.', ';', ':'];
        function removeExtraSpaces(text) {
            let lines = text.split('\n'); let originalLength = text.length; let addedSpacesCount = 0;
            for (let i = 0; i < lines.length - 1; i++) {
                const currentLine = lines[i].trimEnd(); const nextLine = lines[i + 1].trimStart();
                if (currentLine && nextLine) { const lastCharCurrent = currentLine[currentLine.length - 1]; const firstCharNext = nextLine[0]; if (/[а-яёa-z0-9)\]}"]/i.test(lastCharCurrent) && /[а-яёa-z0-9(\[{"]/i.test(firstCharNext)) { if(!/[\s.,;:!?]$/.test(currentLine) && !/^[\s.,;:!?]/.test(nextLine)) { lines[i] = currentLine + ' ' + nextLine; lines.splice(i + 1, 1); i--; addedSpacesCount++; } } }
            } text = lines.join('\n'); lines = text.split('\n').map(line => line.trim()); let cleanedLines = []; let emptyLineCount = 0;
            for (let i = 0; i < lines.length; i++) { if (lines[i] !== '') { if (emptyLineCount > 0 && cleanedLines.length > 0) { cleanedLines.push(''); } cleanedLines.push(lines[i]); emptyLineCount = 0; } else { emptyLineCount++; } }
            if (cleanedLines.length > 0 && cleanedLines[cleanedLines.length -1] === '') { cleanedLines.pop(); }
            let cleanedText = cleanedLines.join('\n'); punctuationMarksForClean.forEach(mark => { const regex = new RegExp(`\\s+\\${mark}`, 'g'); cleanedText = cleanedText.replace(regex, mark); });
            cleanedText = cleanedText.replace(/ +/g, ' '); cleanedText = cleanedText.replace(/([,:])([а-яА-ЯёЁa-zA-Z0-9(\[{"])/g, (match, p1, p2, offset, string) => { if (p1 === ':' && (/\d:\d/.test(string.slice(Math.max(0, offset - 1), offset + 2)) || /\d:ЗУ/.test(string.slice(Math.max(0, offset - 1), offset + 3)))) return match; if (p1 === ':' && /https?:/.test(string.slice(Math.max(0, offset - 5), offset + 1))) return match; addedSpacesCount++; return p1 + ' ' + p2; });
            cleanedText = cleanedText.replace(/([.!?])([А-ЯA-ZА-ЯЁ(\[{"])/g, (match, p1, p2) => { addedSpacesCount++; return p1 + ' ' + p2; });
            cleanedText = cleanedText.replace(/№(\S)/g, (match, p1) => { addedSpacesCount++; return '№ ' + p1; });
            const digitLetterRegex = /(\d)([а-яА-ЯёЁa-zA-Z])/g; const letterDigitRegex = /([а-яА-ЯёЁa-zA-Z])(\d)/g;
            cleanedText = cleanedText.replace(digitLetterRegex, (match, p1, p2, offset, string) => { const prevChar = string[offset - 1]; if (p1.length === 1 && p2.length === 1 && prevChar === '.' && string[offset-2] === 'д') return match; if (prevChar === ' ' && string[offset-2] && string[offset-2].toUpperCase() === 'Р' && p2.length > 1) return match; if (prevChar === ' ' && string.substring(Math.max(0, offset - 4), offset) === "ГОСТ") return match; addedSpacesCount++; return p1 + ' ' + p2; });
            cleanedText = cleanedText.replace(letterDigitRegex, (match, p1, p2, offset, string) => { if ( (p1.toUpperCase() === 'У' && string.substring(Math.max(0, offset - 1), offset).toUpperCase() === 'З') || (p1.toUpperCase() === 'У' && string.substring(Math.max(0, offset - 1), offset).toUpperCase() === 'Т') ) { return match; } if (string.substring(Math.max(0, offset - 3), offset + p2.length) === `ГОСТ${p2}`) return match; addedSpacesCount++; return p1 + ' ' + p2; });
            let removedSpaces = originalLength - cleanedText.length + addedSpacesCount; let removedLines = text.split('\n').length - cleanedText.split('\n').length;
            return { cleanedText, removedSpaces, removedLines, addedSpaces: addedSpacesCount };
        }
        function analyzeText(event) {
            const textInput = document.getElementById('textInput'); let text = textInput.value;
            if (text.trim() === '') { document.getElementById('cadastralResult').innerHTML = ''; document.getElementById('linksResult').innerHTML = ''; document.getElementById('foreignLettersResult').style.display = 'none'; document.getElementById('foreignLettersResult').innerHTML = ''; document.getElementById('fileNamesResult').innerHTML = ''; document.getElementById('datesResult').innerHTML = ''; updateStatusBar(0,0,0,0); return; }
            let { text: textWithPeriods, addedPeriods } = addMissingPeriods(text); let { cleanedText, removedSpaces, removedLines, addedSpaces } = removeExtraSpaces(textWithPeriods);
            if (textInput.value !== cleanedText) { textInput.value = cleanedText; }
            extractCadastralNumbers(cleanedText); extractLinks(cleanedText); findForeignLettersAndRepeatedWords(cleanedText); extractFileNames(cleanedText); extractDates(cleanedText); updateStatusBar(removedSpaces, removedLines, addedSpaces, addedPeriods);
        }
        function downloadDates() { const dates = Array.from(document.querySelectorAll('#datesResult li')).map(li => li.textContent); downloadFile('dates.txt', dates.join('\n')); }
        function updateStatusBar(removedSpaces, removedLines, addedSpaces, addedPeriods) {
            const text = document.getElementById('textInput').value;
            const charCount = text.length; const wordCount = text.trim() === '' ? 0 : text.trim().split(/\s+/).length; const lineCount = text.trim() === '' ? 0 : text.split(/\r\n|\r|\n/).length;
            document.getElementById('charCount').textContent = `Символов: ${charCount}`; document.getElementById('wordCount').textContent = `Слов: ${wordCount}`; document.getElementById('lineCount').textContent = `Строк: ${lineCount}`;
            removedSpaces = (typeof removedSpaces === 'number' && !isNaN(removedSpaces)) ? removedSpaces : 0; removedLines = (typeof removedLines === 'number' && !isNaN(removedLines)) ? removedLines : 0;
            addedSpaces = (typeof addedSpaces === 'number' && !isNaN(addedSpaces)) ? addedSpaces : 0; addedPeriods = (typeof addedPeriods === 'number' && !isNaN(addedPeriods)) ? addedPeriods : 0;
            document.getElementById('removedSpaces').textContent = `Удалено пробелов: ${removedSpaces}`; document.getElementById('removedLines').textContent = `Удалено строк: ${removedLines}`;
            document.getElementById('addedSpaces').textContent = `Добавлено пробелов: ${addedSpaces}`; document.getElementById('addedPeriods').textContent = `Добавлено точек: ${addedPeriods}`;
            const statusBar = document.getElementById('statusBar'); if (text.trim() !== '') { statusBar.classList.add('visible'); } else { statusBar.classList.remove('visible'); document.getElementById('charCount').textContent = `Символов: 0`; document.getElementById('wordCount').textContent = `Слов: 0`; document.getElementById('lineCount').textContent = `Строк: 0`; document.getElementById('removedSpaces').textContent = `Удалено пробелов: 0`; document.getElementById('removedLines').textContent = `Удалено строк: 0`; document.getElementById('addedSpaces').textContent = `Добавлено пробелов: 0`; document.getElementById('addedPeriods').textContent = `Добавлено точек: 0`; document.getElementById('currentLine').textContent = `Строка: -`; }
            updateCurrentLineInfo();
        }
        function checkBracketsAndQuotes(text) {
            const lines = text.split(/\r?\n/); const errors = []; const pairs = { '"': '"', '«': '»', '(': ')', '{': '}' , '[': ']'};
            lines.forEach((line, lineIndex) => { if (line.trim() === '') return; const stack = []; for (let i = 0; i < line.length; i++) { const char = line[i]; if (pairs[char]) { stack.push({ char: char, expected: pairs[char] }); } else if (Object.values(pairs).includes(char)) { if (stack.length === 0 || stack[stack.length - 1].expected !== char) { if (!(char === ')' && /^\s*\d+\s*\)\s*/.test(line.substring(0, i + 1)))) { errors.push({ sentence: line.trim(), line: lineIndex + 1, char: stack.length > 0 ? stack[stack.length - 1].expected : Object.keys(pairs).find(key => pairs[key] === char) || char, type: 'mismatch_or_missing_open' }); } if (stack.length > 0 && stack[stack.length - 1].expected !== char) stack.pop(); } else { stack.pop(); } } } stack.forEach(unclosed => errors.push({ sentence: line.trim(), line: lineIndex + 1, char: unclosed.expected, type: 'unclosed' })); });
            return errors.filter((error, index, self) => index === self.findIndex((t) => t.sentence === error.sentence && t.line === error.line && t.char === error.char && t.type === error.type));
        }
        function findForeignLettersAndRepeatedWords(text) {
            const lines = text.split(/\r?\n/); const repeatedWords = []; const wordsWithForeignLetters = []; const repeatedPunctuation = []; const punctuationMarksForRepeat = [',', ';', ':', '№', '"', "'", '«', '»', '.', '!', '?'];
            for (let lineNumber = 0; lineNumber < lines.length; lineNumber++) { const line = lines[lineNumber]; const words = line.split(/\s+/); for (let i = 0; i < words.length - 1; i++) { const currentWord = words[i].toLowerCase().replace(/[.,;:!?]$/, ''); const nextWord = words[i+1].toLowerCase().replace(/[.,;:!?]$/, ''); if (currentWord && currentWord === nextWord && /[а-яёa-z0-9]/i.test(currentWord) && currentWord.length > 2) { if (!repeatedWords.some(item => item.word === words[i] && item.line === lineNumber + 1)) { repeatedWords.push({ word: words[i], line: lineNumber + 1 }); } } } for (let mark of punctuationMarksForRepeat) { const escapedMark = mark.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'); const regex = new RegExp(`(${escapedMark})(\\s*\\1)+`, 'g'); let match; while ((match = regex.exec(line)) !== null) { if (!repeatedPunctuation.some(item => item.sequence === match[0].trim() && item.line === lineNumber + 1)) { repeatedPunctuation.push({ sequence: match[0].trim(), line: lineNumber + 1 }); } } } words.forEach(wordOriginal => { const word = wordOriginal.replace(/^[«"'(]+|[»"')]+$/g, ''); if (word.length < 3) return; let hasLatin = false; let hasRussian = false; let markedWordContent = ''; let inForeignSpan = false; let currentSegment = ''; for (let i = 0; i < word.length; i++) { const char = word[i]; if (/[a-zA-Z]/.test(char)) { hasLatin = true; if (!inForeignSpan) { if (currentSegment) markedWordContent += currentSegment; currentSegment = ''; markedWordContent += '<span>'; inForeignSpan = true; } } else { if (inForeignSpan) { markedWordContent += currentSegment + '</span>'; currentSegment = ''; inForeignSpan = false; } } currentSegment += char; if (/[а-яА-ЯёЁ]/.test(char)) { hasRussian = true; } } if (currentSegment) { markedWordContent += currentSegment; if (inForeignSpan) markedWordContent += '</span>'; } if (hasLatin && hasRussian) { let finalDisplayWord = markedWordContent; const prefix = wordOriginal.match(/^[«"'(]+/); const suffix = wordOriginal.match(/[»"')]+$/); if(prefix) finalDisplayWord = prefix[0] + finalDisplayWord; if(suffix) finalDisplayWord = finalDisplayWord + suffix[0]; wordsWithForeignLetters.push({ word: finalDisplayWord, line: lineNumber + 1, hasMixed: true }); } }); }
            const bracketErrors = checkBracketsAndQuotes(text); const resultDiv = document.getElementById('foreignLettersResult'); resultDiv.style.display = 'block'; let resultHTML = '<div class="result-header"><i class="fas fa-language result-icon" title="Смешанные буквы, повторы, парные знаки"></i></div><ul>'; let foundAny = false;
            if (repeatedPunctuation.length > 0) { foundAny = true; resultHTML += '<li class="error-category"><strong>Повторяющиеся знаки препинания:</strong></li>'; repeatedPunctuation.forEach(item => resultHTML += `<li>Найден повтор: "${item.sequence}" (строка ${item.line})</li>`); }
            if (repeatedWords.length > 0) { foundAny = true; resultHTML += '<li class="error-category"><strong>Повторяющиеся слова:</strong></li>'; repeatedWords.forEach(item => resultHTML += `<li>Повтор слова: "${item.word}" (строка ${item.line})</li>`); }
            if (wordsWithForeignLetters.length > 0) { foundAny = true; resultHTML += '<li class="error-category"><strong>Слова со смешанными рус./лат. буквами:</strong></li>'; wordsWithForeignLetters.forEach(item => { resultHTML += `<li class="foreign-letter">${item.word} (строка ${item.line})</li>` }); }
            if (bracketErrors.length > 0) { foundAny = true; resultHTML += '<li class="error-category"><strong>Ошибки в парных знаках:</strong></li>'; bracketErrors.forEach(item => resultHTML += `<li>"${item.sentence}" (строка ${item.line}), не хватает/неверный знак "${item.char}"</li>`); }
            resultHTML += '</ul>'; if (!foundAny) { resultHTML = '<div class="result-header"><i class="fas fa-language result-icon"></i></div><p>Смешанных букв, повторов и ошибок в парных знаках не найдено.</p>'; }
            resultDiv.innerHTML = resultHTML;
        }
        function copyToClipboard(text, element) { navigator.clipboard.writeText(text).then(() => { element.classList.add('flash'); setTimeout(() => { element.classList.remove('flash'); }, 500); }).catch(err => { console.error('Не удалось скопировать текст: ', err); }); }
        function downloadNumbers() { const numbers = Array.from(document.querySelectorAll('#cadastralResult li')).map(li => { const textSpan = li.querySelector('.cadastral-number-text'); if (textSpan) { const copySpan = textSpan.querySelector('span[onclick^="copyToClipboard"]'); if (copySpan) { const match = copySpan.getAttribute('onclick').match(/copyToClipboard\('([^']*)'/); if (match && match[1]) return match[1]; } else { const match = textSpan.getAttribute('onclick').match(/copyToClipboard\('([^']*)'/); if (match && match[1]) return match[1]; } } return null; }).filter(num => num !== null && num.trim() !== "" && !num.startsWith("ОКС не найден")); downloadFile('cadastral_numbers.txt', numbers.join('\n')); }
        function downloadLinks() { const links = Array.from(document.querySelectorAll('#linksResult li a')).map(a => a.href); downloadFile('links.txt', links.join('\n')); }
        function downloadFile(filename, text) { const element = document.createElement('a'); element.setAttribute('href', 'data:text/plain;charset=utf-8,' + encodeURIComponent(text)); element.setAttribute('download', filename); element.style.display = 'none'; document.body.appendChild(element); element.click(); document.body.removeChild(element); }
        function copyText() { const textInput = document.getElementById('textInput'); textInput.select(); textInput.setSelectionRange(0, 99999); navigator.clipboard.writeText(textInput.value).then(() => { const copyButton = document.getElementById('copyButton'); copyButton.classList.add('flash-button'); setTimeout(() => { copyButton.classList.remove('flash-button'); }, 300); }).catch(err => { console.error('Не удалось скопировать текст: ', err); }); }
        function getLineNumberFromPosition(textarea, position) { const textUpToPosition = textarea.value.substring(0, position); return textUpToPosition.split('\n').length; }
        function updateCurrentLineInfo() { const textarea = document.getElementById('textInput'); const lineNumber = getLineNumberFromPosition(textarea, textarea.selectionStart); const currentLineSpan = document.getElementById('currentLine'); currentLineSpan.textContent = `Строка: ${lineNumber}`; }
        function openAiModal() { document.getElementById('aiCheckModal').style.display = 'flex'; }
        function closeAiModal() { document.getElementById('aiCheckModal').style.display = 'none'; document.getElementById('aiResultDisplay').innerHTML = ''; document.getElementById('aiCorrectionsListWrapper').style.display = 'none'; document.getElementById('aiCorrectionsList').innerHTML = ''; document.getElementById('aiCheckLoading').style.display = 'none'; }
        
        async function checkGrammarWithAI() {
            const textInput = document.getElementById('textInput');
            const originalText = textInput.value;
            if (originalText.trim() === '') {
                alert('Пожалуйста, введите текст для проверки.');
                return;
            }

            openAiModal();
            document.getElementById('aiResultDisplay').innerHTML = '';
            document.getElementById('aiCorrectionsListWrapper').style.display = 'none';
            document.getElementById('aiCorrectionsList').innerHTML = '';
            document.getElementById('aiCheckLoading').style.display = 'block';

            const systemPrompt = `Ты — высокоточный редактор и корректор русского языка. Твоя задача — исправить все грамматические и орфографические ошибки в предоставленном пользователем тексте. Верни JSON-объект со следующими двумя полями: 1. "correctedText": строка, содержащая ПОЛНОСТЬЮ ИСПРАВЛЕННЫЙ текст. Сохрани исходное форматирование (абзацы, переносы строк), насколько это возможно. 2. "correctionsMade": массив объектов, где каждый объект описывает одно сделанное исправление и имеет поля: - "original": "слово_или_фраза_с_ошибкой_как_в_оригинале" (точно как в исходном тексте, с учетом регистра) - "corrected": "исправленное_слово_или_фраза". Если ошибок нет, поле "correctionsMade" должно быть пустым массивом [], а "correctedText" должен быть идентичен исходному тексту. Не добавляй никаких объяснений или комментариев, только JSON.`;
            const userPrompt = `${systemPrompt}\n\nТекст для проверки:\n---\n${originalText}`;
            
            let apiUrl;
            let requestBody;
            const modelId = "gemini-2.5-flash-lite"; // Модель не меняем, как вы и просили

            if (PROXY_MODE === 1) {
                // Логика для прокси mapruapp
                apiUrl = `${MAPRUAPP_PROXY_BASE_URL}/ai/api/v1/chat/completions`;
                requestBody = {
                    model: modelId,
                    messages: [{ role: "user", content: userPrompt }],
                    max_tokens: 4096,
                    response_format: { type: "json_object" }
                };
            } else {
                // Логика для прокси vercel
                apiUrl = `${VERCEL_PROXY_BASE_URL}/v1beta/models/${modelId}:generateContent`;
                requestBody = {
                    contents: [{ parts: [{ text: userPrompt }] }],
                    generationConfig: { responseMimeType: "application/json" }
                };
            }
            
            try {
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(requestBody)
                });

                document.getElementById('aiCheckLoading').style.display = 'none';
                const data = await response.json();

                if (!response.ok) {
                    const errorDetail = data?.error?.message || `Статус ${response.status}`;
                    throw new Error(`Ошибка API (${response.status}): ${errorDetail}`);
                }
                
                let aiResponseText;
                if (PROXY_MODE === 1) {
                    aiResponseText = data.choices?.[0]?.message?.content;
                } else {
                    aiResponseText = data.candidates?.[0]?.content?.parts?.[0]?.text;
                }

                if (!aiResponseText) {
                     throw new Error('Не удалось получить ответ от ИИ (пустое поле content).');
                }

                let parsedResponse;
                try {
                    const cleanedText = aiResponseText.trim().replace(/^```json\s*|\s*```$/g, '');
                    parsedResponse = JSON.parse(cleanedText);
                    if (typeof parsedResponse.correctedText !== 'string' || !Array.isArray(parsedResponse.correctionsMade)) {
                        throw new Error("Ответ ИИ имеет неверную структуру JSON.");
                    }
                } catch (e) {
                    console.error("AI Response (raw):", aiResponseText);
                    document.getElementById('aiResultDisplay').innerHTML = `<p style="color: red;">Ошибка при обработке ответа ИИ. Ответ не является корректным JSON.<br>Получено: ${escapeHtmlForDisplay(aiResponseText)}</p>`;
                    return;
                }

                document.getElementById('aiResultDisplay').innerHTML = escapeHtmlForDisplay(parsedResponse.correctedText).replace(/\n/g, '<br>');
                const correctionsListUl = document.getElementById('aiCorrectionsList');

                if (parsedResponse.correctionsMade.length > 0) {
                    parsedResponse.correctionsMade.forEach(correction => {
                        if (correction.original && correction.corrected) {
                            const li = document.createElement('li');
                            li.className = 'ai-correction-item';
                            li.innerHTML = `<span class="ai-correction-original">${escapeHtmlForDisplay(correction.original)}</span> → <span class="ai-correction-corrected">${escapeHtmlForDisplay(correction.corrected)}</span>`;
                            correctionsListUl.appendChild(li);
                        }
                    });
                    document.getElementById('aiCorrectionsListWrapper').style.display = 'block';
                } else {
                    const li = document.createElement('li');
                    li.textContent = "Исправлений не внесено.";
                    correctionsListUl.appendChild(li);
                    document.getElementById('aiCorrectionsListWrapper').style.display = 'block';
                }
            } catch (error) {
                console.error('Ошибка при проверке текста с ИИ:', error);
                document.getElementById('aiCheckLoading').style.display = 'none';
                document.getElementById('aiResultDisplay').innerHTML = `<p style="color: red;">Произошла ошибка: ${error.message}</p>`;
            }
        }
        
        function escapeHtmlForDisplay(unsafe) { if (typeof unsafe !== 'string') return ''; return unsafe.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#039;"); }
        function copyAiCorrectedTextToClipboard(buttonElement) {
            const contentHolder = document.getElementById('aiResultDisplay'); const originalHtml = contentHolder.innerHTML;
            const tempDiv = document.createElement('div'); tempDiv.innerHTML = originalHtml.replace(/<br\s*\/?>/gi, '\n');
            const textToCopy = tempDiv.innerText || tempDiv.textContent || "";
            navigator.clipboard.writeText(textToCopy).then(() => { if (buttonElement) { buttonElement.classList.add('flash-button'); setTimeout(() => { buttonElement.classList.remove('flash-button'); }, 300); } }).catch(err => { alert('Не удалось скопировать текст.'); console.error('Copy error:', err); });
        }
        document.getElementById('textInput').addEventListener('click', updateCurrentLineInfo);
        document.getElementById('textInput').addEventListener('keyup', updateCurrentLineInfo);
        document.getElementById('textInput').addEventListener('select', updateCurrentLineInfo);
        document.getElementById('textInput').addEventListener('input', () => updateStatusBar(0,0,0,0));
        window.addEventListener('load', () => updateStatusBar(0,0,0,0));
    </script>
</body>
</html>