<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Межевой план</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
    <link id="favicon" rel="icon" href="img/mpch.png" type="image/png">
    <style>
        :root {
            --primary-color: #2563eb;
            --secondary-color: #f8fafc;
            --accent-color: #0ea5e9;
            --success-color: #10b981;
            --warning-color: #f97316;
            --error-color: #ef4444;
            --text-primary: #1e293b;
            --text-secondary: #64748b;
            --border-color: #e2e8f0;
            --shadow-sm: 0 1px 2px 0 rgb(0 0 0 / 0.05);
            --shadow-md: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            line-height: 1.6;
            background-color: #f0f4f8;
            color: var(--text-primary);
        }
        .container {
            max-width: 1800px;
            margin: 20px auto;
            background: white;
            border-radius: 16px;
            box-shadow: var(--shadow-lg);
            overflow: hidden;
        }
        .content { padding: 24px; }

        .file-upload-section {
            background: var(--secondary-color);
            border-radius: 12px;
            padding: 12px;
            margin-bottom: 20px;
            border: 2px dashed var(--border-color);
            transition: all 0.3s ease;
        }
        .file-upload-area {
            text-align: center;
            cursor: pointer;
            padding: 12px 16px;
            border-radius: 8px;
            transition: all 0.3s ease;
            position: relative;
            user-select: none;
        }
        .file-upload-area:hover { background: white; transform: translateY(-2px); box-shadow: var(--shadow-sm); }
        .file-upload-area.dragover { background: #dbeafe !important; border-color: var(--primary-color) !important; }
        .file-upload-section.dragover { border-color: var(--primary-color); background: #f0f9ff; }
     .upload-icon {
    margin-bottom: 8px;
    line-height: 1;
}
.upload-icon img {
    width: 48px; /* Размер иконки */
    height: 48px;
    object-fit: contain; /* Чтобы изображение не искажалось */
}
        .upload-text { font-size: 1.1rem; font-weight: 600; color: var(--text-primary); margin-bottom: 4px; }
        .upload-subtext { color: var(--text-secondary); font-size: 0.9rem; }
        #fileInput { display: none; }
        .status-container {
            text-align: center; margin: 24px 0; min-height: 60px;
            display: flex; align-items: center; justify-content: center; gap: 16px;
        }
        .loader {
            width: 32px; height: 32px; border: 3px solid #f3f4f6;
            border-top: 3px solid var(--primary-color); border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        .status-text { font-size: 1.1rem; font-weight: 500; color: var(--text-secondary); }
        .hidden { display: none; }

        #resultsContainer {
            display: grid;
            grid-template-columns: 2fr 1.2fr;
            gap: 24px;
            align-items: start;
        }
        #mainColumn, #sidebarColumn {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .section {
            background: white; border-radius: 12px;
            border: 1px solid var(--border-color); box-shadow: var(--shadow-sm); overflow: hidden;
            width: 100%;
            margin-bottom: 0;
        }
        .section-header {
            background: linear-gradient(135deg, #f8fafc 0%, #eef2f7 100%);
            padding: 16px 20px; border-bottom: 1px solid var(--border-color);
            display: flex;
            align-items: center;
            gap: 12px;
        }
        .section-icon {
            width: 24px;
            height: 24px;
            color: var(--primary-color);
            flex-shrink: 0;
        }
        .section-title { font-size: 1.3rem; font-weight: 600; color: var(--text-primary); margin: 0; }
        
        .header-button {
            margin-left: auto;
            padding: 4px; border-radius: 6px;
            transition: all 0.2s; cursor: pointer;
            display: flex; align-items: center;
            border: none; background: transparent;
            color: var(--primary-color);
        }
        .header-button:hover { background-color: var(--border-color); transform: scale(1.1); }
        .header-button i { font-size: 20px; }

        .info-grid {
            display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 16px; margin-bottom: 16px;
        }
        .info-card {
            background: var(--secondary-color); border-radius: 8px; padding: 16px;
            border: 1px solid var(--border-color);
        }
        .info-label {
            font-size: 0.85rem; font-weight: 600; color: var(--text-secondary);
            text-transform: uppercase; letter-spacing: 0.5px; margin-bottom: 4px;
        }
        .info-value { font-size: 1rem; color: var(--text-primary); font-weight: 500; }
        .info-value code {
            background: #e2e8f0; padding: 2px 6px; border-radius: 4px;
            font-family: 'Courier New', monospace; font-size: 0.95rem;
        }
        .data-table {
            width: 100%; border-collapse: collapse; margin-top: 16px;
            border-radius: 8px; overflow: hidden; box-shadow: var(--shadow-sm);
        }
        .data-table th, .data-table td {
            padding: 12px 16px;
            border-bottom: 1px solid var(--border-color);
            vertical-align: middle;
            text-align: center;
        }
        .data-table th {
            background: var(--primary-color); color: white;
            font-weight: 600; font-size: 0.9rem;
        }
        .data-table tbody tr:hover { background: var(--secondary-color); }
        .data-table tbody tr:last-child td { border-bottom: none; }
        .data-table td:first-child, .data-table .left-align { text-align: left; }
        .data-table .no-wrap { white-space: nowrap; } /* Class to prevent wrapping */
        .coord-table td:first-child { text-align: center; font-weight: 600; }
        .coord-table td:nth-child(4) { text-align: left; }

        .address-display {
            background: linear-gradient(135deg, #f0f9ff 0%, #e0f2fe 100%);
            border: 1px solid #bae6fd; border-radius: 8px; padding: 16px;
            font-size: 1.1rem; font-weight: 500; color: var(--text-primary);
        }
        .conclusion-text {
            background: #f8fafc; border: 1px solid var(--border-color); border-radius: 8px;
            padding: 16px; font-size: 0.95rem;
            line-height: 1.5; white-space: pre-wrap; word-wrap: break-word;
        }
        .error-message {
            background: #fef2f2; border: 1px solid #fecaca; border-radius: 8px;
            padding: 16px; color: var(--error-color); font-weight: 500; text-align: center;
        }
        .subsection { margin-top: 24px; }
        .subsection-title {
            font-size: 1.1rem; font-weight: 600; color: var(--text-primary);
            margin-bottom: 12px; padding-bottom: 8px; border-bottom: 2px solid var(--border-color);
        }
        .file-name {
            font-family: 'Courier New', monospace; background: #e2e8f0; padding: 2px 6px;
            border-radius: 4px; font-size: 0.95rem;
        }

        #printButtonContainer { text-align: center; margin-bottom: 20px; }
        .print-btn {
            background-color: var(--primary-color); color: white; border: none;
            padding: 12px 24px; border-radius: 8px; font-size: 1rem;
            font-weight: 600; cursor: pointer; display: inline-flex;
            align-items: center; gap: 10px; transition: all 0.2s ease;
            box-shadow: var(--shadow-md);
        }
        .print-btn:hover {
            background-color: #1d4ed8; box-shadow: var(--shadow-lg);
            transform: translateY(-2px);
        }
        .print-btn svg { width: 20px; height: 20px; }

        /* Validation Styles */
        .validation-message {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px 16px;
            border-radius: 8px;
            margin-top: 12px;
            font-weight: 500;
        }
        .validation-message:first-child { margin-top: 0; }
        .validation-message .icon { width: 24px; height: 24px; flex-shrink: 0; }
        .validation-error { background-color: #fef2f2; border: 1px solid #fecaca; color: #b91c1c; }
        .validation-warning { background-color: #fffbeb; border: 1px solid #fde68a; color: #b45309; }
        .validation-success { background-color: #f0fdf4; border: 1px solid #bbf7d0; color: #15803d; }
        #cadastralNumbersList {
            list-style-type: none; padding-left: 0;
            display: flex; flex-wrap: wrap; gap: 8px;
        }
        #cadastralNumbersList li {
            padding: 4px 10px; border-radius: 6px; font-family: 'Courier New', monospace;
            border: 1px solid;
        }

        /* AI Modal Styles */
        .ai-modal-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background-color: rgba(30, 41, 59, 0.6);
            /* display: flex; IS NOW HANDLED BY JS TO FIX THE BUG */
            justify-content: center; align-items: center;
            z-index: 1000; padding: 20px;
            display: none; /* Default state is hidden */
        }
        .ai-modal-content {
            background-color: white; padding: 24px; border-radius: 16px;
            box-shadow: var(--shadow-lg);
            width: 90%; height: 85%; max-width: 900px;
            display: flex; flex-direction: column; position: relative;
        }
        .ai-modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding-bottom: 12px;
            border-bottom: 1px solid var(--border-color);
            margin-bottom: 16px;
        }
       .ai-modal-header h2 {
    font-size: 1.5rem;
    color: var(--text-primary);
    width: 100%; /* Make the title take full width to allow centering */
    text-align: center; /* Center the text */
    padding-left: 24px; /* Add padding to compensate for the close button's space */
}
        .ai-modal-close-button {
            font-size: 2rem; font-weight: bold; color: var(--text-secondary);
            cursor: pointer; line-height: 1; padding: 0 5px;
            transition: color 0.2s;
        }
        .ai-modal-close-button:hover { color: var(--text-primary); }
        
        #aiCheckResultDisplay {
            flex-grow: 1;
            overflow-y: auto;
            font-size: 1rem;
            line-height: 1.6;
            color: var(--text-primary);
        }
        
        .ai-spinner {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 16px;
            color: var(--text-secondary);
            font-size: 1.1rem;
            height: 100%;
        }
        .ai-feedback { white-space: pre-wrap; margin-bottom: 16px; background-color: #f8fafc; padding: 12px; border-radius: 8px; border: 1px solid var(--border-color); }
        .ai-corrected-text {
            background-color: #f0fdf4; color: #064e3b; padding: 12px; border: 1px solid #bbf7d0;
            border-radius: 8px; white-space: pre-wrap; font-family: 'Courier New', monospace;
        }
.ai-modal-content h4 {
    font-size: 1.1rem;
    font-weight: 600;
    margin-bottom: 10px;
    color: var(--text-primary);
    display: flex;
    align-items: center;
    justify-content: center; 
    gap: 8px;
}


.ai-modal-content h4 i {
    font-size: 1.2em; 
    background: linear-gradient(135deg, #2563eb, #0ea5e9); 
    -webkit-background-clip: text; 
    -webkit-text-fill-color: transparent; /
    background-clip: text;
    text-fill-color: transparent;
}
        .ai-copy-button {
            margin-top: 16px;
            background-color: var(--success-color); color: white; border: none;
            padding: 10px 20px; border-radius: 8px; font-size: 1rem;
            font-weight: 500; cursor: pointer; display: inline-flex;
            align-items: center; gap: 8px; transition: background-color 0.2s ease;
        }
        .ai-copy-button:hover { background-color: #059669; }
        .ai-copy-button:disabled { background-color: var(--text-secondary); cursor: not-allowed; }
        .ai-copy-button i { font-size: 1rem; }

        .ai-result-error { color: var(--error-color); font-weight: 500; }
        .ai-result-success { color: var(--success-color); font-weight: 500; display: flex; align-items: center; gap: 8px; font-size: 1.1rem; }

        @media (max-width: 1024px) { #resultsContainer { grid-template-columns: 1fr; } }
        @media (max-width: 768px) {
            .container { margin: 0; border-radius: 0; }
            .content { padding: 16px; }
            .info-grid { grid-template-columns: 1fr; }
            .data-table { font-size: 0.8rem; }
            .data-table th, .data-table td { padding: 8px 12px; }
            .ai-modal-content { width: 100%; height: 90%; }
        }

        @media print {
            body, .container {
                padding: 0; margin: 0; box-shadow: none;
                border: none; background: white; color: black;
            }
            .file-upload-section, .status-container, #printButtonContainer, .header-button, .validation-section, .ai-modal-overlay {
                display: none !important;
            }
            #resultsContainer { display: block; gap: 0; }
            #mainColumn, #sidebarColumn { display: block; width: 100%; }
            .section {
                box-shadow: none; border: 1px solid #ccc;
                border-radius: 0; page-break-inside: avoid;
                margin-bottom: 20px;
            }
            .section-header { background: #f0f0f0 !important; }
            .data-table th { background: #e5e5e5 !important; color: black !important; }
            .info-card, .conclusion-text { background: #f9f9f9 !important; }
            * {
                -webkit-print-color-adjust: exact !important;
                print-color-adjust: exact !important;
            }
        }
        
        
        /* --- Стили для сворачивания/разворачивания модального окна --- */
.ai-modal-controls {
    display: flex;
    align-items: center;
    gap: 10px;
    position: absolute; /* Позиционируем блок кнопок */
    top: 16px;
    right: 16px;
}

.ai-modal-minimize-button {
    font-size: 1.1rem; /* Размер иконки сворачивания */
    font-weight: bold;
    color: var(--text-secondary);
    cursor: pointer;
    line-height: 1;
    padding: 5px;
    transition: color 0.2s, transform 0.2s;
}

.ai-modal-minimize-button:hover {
    color: var(--text-primary);
    transform: scale(1.1);
}

/* Состояние "Свернуто" для оверлея */
.ai-modal-overlay.minimized {
    /* Делаем его невидимым, но кликабельным, чтобы вернуть окно */
    background: none;
    pointer-events: none; /* Разрешаем клики "сквозь" оверлей */
    align-items: flex-end; /* Прижимаем к нижнему краю */
    justify-content: flex-end; /* Прижимаем к правому краю */
}

/* Состояние "Свернуто" для контента окна */
.ai-modal-overlay.minimized .ai-modal-content {
    height: auto; /* Высота по содержимому (только заголовок) */
    width: 350px; /* Фиксированная ширина для свернутого состояния */
    min-height: 0;
    box-shadow: var(--shadow-lg);
    cursor: pointer;
    pointer-events: auto; /* Возвращаем кликабельность для самого окна */
    transition: all 0.3s ease-in-out;
}

/* Скрываем тело модального окна в свернутом состоянии */
.ai-modal-overlay.minimized #aiCheckResultDisplay {
    display: none;
}

/* Меняем иконку на "развернуть" в свернутом состоянии */
.ai-modal-overlay.minimized .ai-modal-minimize-button i::before {
    content: "\f2d0"; /* Код иконки "fa-window-maximize" */
}

        .data-table.lengths-table td:first-child {
            text-align: center;
        }
    </style>
</head>
<body>
    <div class="container">
        <main class="content">
            <div class="file-upload-section" id="dropSection">
       <div class="file-upload-area" id="dropArea">
    <div class="upload-icon"><img src="img/mpch.png" alt="Загрузить межевой план"></div>
    <div class="upload-text">Выберите XML или ZIP файл межевого плана или вставьте (Ctrl+V)</div>
    <div class="upload-subtext" id="fileNameDisplay"></div>
</div>
                <input type="file" id="fileInput" accept=".xml,.zip">
            </div>

            <div id="printButtonContainer" class="hidden">
                <button id="printButton" class="print-btn">
                    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" d="M6.72 13.829c-.24.03-.48.062-.72.096m.72-.096a42.415 42.415 0 0110.56 0m-10.56 0L6 18.25M3.75 6.75h16.5M3.75 12h16.5m-16.5 5.25h16.5M17.25 4.5l-1.5-1.5-1.5 1.5M6.75 4.5l1.5-1.5 1.5 1.5m12.75 1.5-1.5-1.5-1.5 1.5M6.75 21l1.5 1.5 1.5-1.5m12.75 1.5l-1.5 1.5-1.5-1.5M12 6.75v10.5" />
                    </svg>
                    <span>Печать</span>
                </button>
            </div>

            <div class="status-container" id="statusContainer">
                <div class="loader hidden" id="loader"></div>
                <div id="messageArea">
                    <div class="status-text" id="statusText"></div>
                </div>
            </div>

            <div id="resultsContainer" class="hidden">
                <div id="mainColumn"></div>
                <div id="sidebarColumn"></div>
            </div>
        </main>
    </div>

<!-- AI Modal Window -->
<div id="aiCheckModal" class="ai-modal-overlay">
    <div class="ai-modal-content">
        <div class="ai-modal-header">
            <h2>Анализ заключения</h2>
            <div class="ai-modal-controls">
                <span class="ai-modal-minimize-button" id="aiModalMinimizeBtn"><i class="fas fa-window-minimize"></i></span>
                <span class="ai-modal-close-button" id="aiModalCloseBtn">×</span>
            </div>
        </div>
        <div id="aiCheckResultDisplay">
            <!-- AI results will be injected here -->
        </div>
    </div>
</div>

<script>
// --- AI-прокси и настройки ---
const MAPRUAPP_PROXY_BASE_URL = "https://mapruapp.ru";
const PROXY_MODE = 1; // 1 = mapruapp

document.addEventListener('DOMContentLoaded', () => {
    // --- Словари и Иконки ---
    const landCategories = { '003001000000': 'Земли сельскохозяйственного назначения', '003002000000': 'Земли населенных пунктов', '003003000000': 'Земли промышленности, энергетики, транспорта и иного специального назначения', '003004000000': 'Земли особо охраняемых территорий и объектов', '003005000000': 'Земли лесного фонда', '003006000000': 'Земли водного фонда', '003007000000': 'Земли запаса', '003008000000': 'Категория не установлена' };
    const accuracyStandards = { '003002000000': 0.10, '003001000000': 0.20, '003003000000': 0.50, '003004000000': 2.50, '003005000000': 5.00, '003006000000': 5.00, '003007000000': 5.00, };
    const planTypes = { '1': 'Выдел', '2': 'Раздел', '3': 'Раздел с измененным земельным участком', '4': 'Перераспределение', '5': 'Образование из земель', '6': 'Объединение', '7': 'Перераспределение с землями' };
    const sectionIcons = {
        generalInfo: `<svg xmlns="http://www.w3.org/2000/svg" class="section-icon" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" /></svg>`,
        participants: `<svg xmlns="http://www.w3.org/2000/svg" class="section-icon" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M17 20h5v-2a3 3 0 00-5.356-1.857M17 20H7m10 0v-2c0-.656-.126-1.283-.356-1.857M7 20H2v-2a3 3 0 015.356-1.857M7 20v-2c0-.656.126-1.283.356-1.857m0 0a5.002 5.002 0 019.288 0M15 7a3 3 0 11-6 0 3 3 0 016 0zm6 3a2 2 0 11-4 0 2 2 0 014 0zM7 10a2 2 0 11-4 0 2 2 0 014 0z" /></svg>`,
        inputData: `<svg xmlns="http://www.w3.org/2000/svg" class="section-icon" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M19 11H5m14 0a2 2 0 012 2v6a2 2 0 01-2 2H5a2 2 0 01-2-2v-6a2 2 0 012-2m14 0V9a2 2 0 00-2-2M5 11V9a2 2 0 012-2m0 0V5a2 2 0 012-2h6a2 2 0 012 2v2M7 7h10" /></svg>`,
        newParcel: `<svg xmlns="http://www.w3.org/2000/svg" class="section-icon" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M9 20l-5.447-2.724A1 1 0 013 16.382V5.618a1 1 0 011.447-.894L9 7m0 13l6-3m-6 3V7m6 10l4.553 2.276A1 1 0 0021 18.382V7.618a1 1 0 00-.553-.894L15 4m0 13V4m0 0L9 7" /></svg>`,
        relatedParcel: `<svg xmlns="http://www.w3.org/2000/svg" class="section-icon" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z" /></svg>`,
        conclusion: `<svg xmlns="http://www.w3.org/2000/svg" class="section-icon" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z" /></svg>`,
        graphics: `<svg xmlns="http://www.w3.org/2000/svg" class="section-icon" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l-1.586-1.586a2 2 0 00-2.828 0L6 14m6-6l.01.01" /><rect x="3" y="3" width="18" height="18" rx="2" ry="2" /></svg>`,
        appendix: `<svg xmlns="http://www.w3.org/2000/svg" class="section-icon" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M15.172 7l-6.586 6.586a2 2 0 102.828 2.828l6.414-6.586a4 4 0 00-5.656-5.656l-6.415 6.585a6 6 0 108.486 8.486L20.5 13" /></svg>`,
        copyXY: `<svg xmlns="http://www.w3.org/2000/svg" class="section-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path><text x="12" y="16.5" font-family="sans-serif" font-size="6" fill="currentColor" text-anchor="middle" font-weight="bold">XY</text></svg>`,
        validation: `<svg xmlns="http://www.w3.org/2000/svg" class="section-icon" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M9 12.75L11.25 15 15 9.75m-3-7.036A11.959 11.959 0 013.598 6 11.99 11.99 0 003 9.749c0 5.592 3.824 10.29 9 11.622 5.176-1.332 9-6.03 9-11.622 0-1.31-.21-2.571-.598-3.751h-.152c-3.196 0-6.1-1.248-8.25-3.286zm0 13.036h.008v.008h-.008v-.008z" /></svg>`,
        errorIcon: `<svg xmlns="http://www.w3.org/2000/svg" class="icon" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M12 9v3.75m-9.303 3.376c-.866 1.5.217 3.374 1.948 3.374h14.71c1.73 0 2.813-1.874 1.948-3.374L13.949 3.378c-.866-1.5-3.032-1.5-3.898 0L2.697 16.126zM12 15.75h.007v.008H12v-.008z" /></svg>`,
        warningIcon: `<svg xmlns="http://www.w3.org/2000/svg" class="icon" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M12 9v3.75m9-.75a9 9 0 11-18 0 9 9 0 0118 0zm-9 3.75h.008v.008H12v-.008z" /></svg>`,
        successIcon: `<svg xmlns="http://www.w3.org/2000/svg" class="icon" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M9 12.75L11.25 15 15 9.75M21 12a9 9 0 11-18 0 9 9 0 0118 0z" /></svg>`
    };

    // --- DOM элементы ---
    const fileInput = document.getElementById('fileInput');
    const loader = document.getElementById('loader');
    const dropArea = document.getElementById('dropArea');
    const dropSection = document.getElementById('dropSection');
    const fileNameDisplay = document.getElementById('fileNameDisplay');
    const statusContainer = document.getElementById('statusContainer');
    const messageArea = document.getElementById('messageArea');
    const resultsContainer = document.getElementById('resultsContainer');
    const mainColumn = document.getElementById('mainColumn');
    const sidebarColumn = document.getElementById('sidebarColumn');
    const printButtonContainer = document.getElementById('printButtonContainer');
    const printButton = document.getElementById('printButton');
    const aiCheckModal = document.getElementById('aiCheckModal');
    const aiModalCloseBtn = document.getElementById('aiModalCloseBtn');
     const aiModalMinimizeBtn = document.getElementById('aiModalMinimizeBtn'); 
    const aiCheckResultDisplay = document.getElementById('aiCheckResultDisplay');

    const E = (el, sel) => el.querySelector(sel);
    const All = (el, sel) => el.querySelectorAll(sel);
    const T = (el, sel) => el?.querySelector(sel)?.textContent.trim() || '—';
    const A = (el, attr) => el?.getAttribute(attr) || '—';

    function clearResults() {
        resultsContainer.classList.add('hidden');
        printButtonContainer.classList.add('hidden');
        mainColumn.innerHTML = '';
        sidebarColumn.innerHTML = '';
    }
    function showStatus(message, isLoading = false) {
        clearResults();
        messageArea.innerHTML = `<div class="status-text">${message}</div>`;
        statusContainer.classList.remove('hidden');
        loader.classList.toggle('hidden', !isLoading);
    }
    function showError(message) {
        clearResults();
        loader.classList.add('hidden');
        statusContainer.classList.remove('hidden');
        messageArea.innerHTML = `<div class="error-message">${message}</div>`;
        console.error(message);
    }

    // --- Обработчики событий ---
    dropArea.addEventListener('click', () => fileInput.click());
    fileInput.addEventListener('change', (event) => {
        const file = event.target.files[0];
        if (file) handleFile(file);
    });
    ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(e => {
        document.body.addEventListener(e, preventDefaults, false);
        dropSection.addEventListener(e, preventDefaults, false);
    });
    function preventDefaults(e) { e.preventDefault(); e.stopPropagation(); }
    ['dragenter', 'dragover'].forEach(e => {
        dropSection.addEventListener(e, () => dropSection.classList.add('dragover'), false);
    });
    ['dragleave', 'drop'].forEach(e => {
        dropSection.addEventListener(e, () => dropSection.classList.remove('dragover'), false);
    });
    dropSection.addEventListener('drop', (e) => {
        const file = e.dataTransfer.files[0];
        if (file) handleFile(file);
    }, false);

    document.body.addEventListener('click', function(event) {
        const copyCoordsBtn = event.target.closest('.copy-coords-btn');
        const aiCheckBtn = event.target.closest('.ai-check-btn');

        if (copyCoordsBtn) {
            event.preventDefault();
            const section = copyCoordsBtn.closest('.section');
            const coordTable = section?.querySelector('.coord-table tbody');
            if (!coordTable) { alert('Ошибка: таблица координат не найдена!'); return; }
            const rows = coordTable.querySelectorAll('tr');
            let coordsToCopy = '';
            rows.forEach(row => {
                const cells = row.querySelectorAll('td');
                if (cells.length >= 3) {
                    const x = cells[1].textContent.trim();
                    const y = cells[2].textContent.trim();
                    coordsToCopy += `${x}\t${y}\n`;
                }
            });
            coordsToCopy = coordsToCopy.trim();
            if (!coordsToCopy) { alert('Нет координат для копирования.'); return; }
            if (navigator.clipboard) {
                navigator.clipboard.writeText(coordsToCopy).then(() => {
                    window.open('схема.html', '_blank');
                }).catch(err => {
                    console.error('Ошибка при копировании в буфер обмена:', err);
                    alert('Не удалось скопировать координаты. Проверьте разрешения вашего браузера.');
                });
            } else {
                alert('Ваш браузер не поддерживает безопасное копирование в буфер обмена.');
            }
        }

        if (aiCheckBtn) {
            const conclusionText = aiCheckBtn.dataset.conclusionText;
            checkConclusionWithAI(conclusionText);
        }
    });
    
        function isXmlString(str) {
        return typeof str === 'string' && str.trim().startsWith('<?xml');
    }

    // Основной обработчик события вставки

    function cleanXmlString(xmlString) {
        // Находим индекс последнего символа '>' в строке.
        // Это надежный способ, так как любой валидный XML заканчивается на '>'.
        const lastBracketIndex = xmlString.lastIndexOf('>');
        
        // Если '>' не найден, что-то совсем не так, но на всякий случай вернем исходную строку.
        if (lastBracketIndex === -1) {
            return xmlString;
        }

        // Возвращаем подстроку от начала до последнего символа '>', включительно.
        // .trim() дополнительно убирает пробельные символы в конце.
        return xmlString.substring(0, lastBracketIndex + 1).trim();
    }
    
    // Основной обработчик события вставки (ПОЛНОСТЬЮ ИСПРАВЛЕННАЯ ВЕРСИЯ)
    function handlePaste(event) {
        // Получаем текст из буфера обмена
        const pastedText = (event.clipboardData || window.clipboardData).getData('text');

        // Если в буфере не XML, то ничего не делаем
        if (!isXmlString(pastedText)) {
            return;
        }

        // Перехватываем событие, чтобы текст не вставился на страницу.
        event.preventDefault();

        // --- ШАГ 1: УДАЛЯЕМ МАРКЕРЫ "+" и "-" ИЗ НАЧАЛА СТРОК ---
        // Регулярное выражение /^[+-]\s*/gm находит в начале каждой строки (флаг "m")
        // символ "+" или "-", за которым могут идти пробелы (\s*), и заменяет все
        // найденные совпадения (флаг "g") на пустую строку.
        let cleanedText = pastedText.replace(/^[+-]\s*/gm, '');

        // --- ШАГ 2: УДАЛЯЕМ БЛОК С ПОДПИСЬЮ В КОНЦЕ (оставляем эту логику) ---
        cleanedText = cleanXmlString(cleanedText);

        // Используем существующие функции для отображения статуса и обработки.
        fileNameDisplay.innerHTML = `<strong>Вставлено из буфера обмена</strong>`;
        showStatus('Обработка XML из буфера обмена...', true);
        
        setTimeout(() => {
            // Передаем в парсер полностью очищенный текст
            parseXmlContent(cleanedText);
        }, 50);
    }
    
    // Вешаем обработчик на весь документ
    document.addEventListener('paste', handlePaste);

    printButton.addEventListener('click', () => { window.print(); });

    // --- Основная логика ---
    function handleFile(file) {
        fileNameDisplay.innerHTML = `Выбран файл: <strong>${file.name}</strong>`;
        showStatus('Обработка файла...', true);
        const fileExtension = file.name.split('.').pop().toLowerCase();
        if (fileExtension === 'zip') handleZipFile(file);
        else if (fileExtension === 'xml') handleXmlFile(file);
        else showError('Неподдерживаемый тип файла. Пожалуйста, выберите .xml или .zip файл.');
    }
    function handleXmlFile(file) {
        const reader = new FileReader();
        reader.onload = e => parseXmlContent(e.target.result);
        reader.onerror = e => showError('Не удалось прочитать файл.', e);
        reader.readAsText(file, 'UTF-8');
    }
    function handleZipFile(file) {
        JSZip.loadAsync(file).then(zip => {
            const xmlFileName = Object.keys(zip.files).find(name => !zip.files[name].dir && name.toLowerCase().endsWith('.xml'));
            if (!xmlFileName) throw new Error('XML файл не найден в архиве.');
            return zip.files[xmlFileName].async('string');
        }).then(parseXmlContent).catch(err => showError('Ошибка при обработке ZIP архива: ' + err.message));
    }
    function parseXmlContent(xmlString) {
        try {
            const parser = new DOMParser();
            const xmlDoc = parser.parseFromString(xmlString, "application/xml");
            if (E(xmlDoc, "parsererror")) throw new Error("Не удалось разобрать XML. Файл поврежден или имеет неверный формат.");
            displayData(xmlDoc, xmlString);
        } catch (err) {
            showError(err.message);
        } finally {
            loader.classList.add('hidden');
        }
    }
    
    // --- Утилиты ---
    function escapeHtml(unsafe) {
        if (typeof unsafe !== 'string') return '';
        return unsafe.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#039;");
    }
    

 function createSpatialDataHtml(entitySpatial) {
        if (!entitySpatial) return '';

        let spatialHtml = '';
        let tableContent = '';
        
        // Ищем Ordinate в разных возможных вложениях для универсальности
        const ordinates = All(entitySpatial, 'SpatialElement Ordinate, SpelementUnit > Ordinate, SpelementUnit > NewOrdinate');
        
        // --- ИЗМЕНЕНИЕ: Убрана проверка на уникальность точек (uniquePoints.has).
        // Теперь все точки, включая замыкающую, будут добавлены в таблицу.
        ordinates.forEach(ord => {
            const pointName = `${A(ord, 'PointPref') || ''}${A(ord, 'NumGeopoint')}`;
            // Пропускаем только точки, у которых нет имени
            if (pointName && pointName !== '—') {
                // Сразу формируем и добавляем HTML-строку для таблицы
                tableContent += `<tr>
                    <td>${pointName}</td>
                    <td>${A(ord, 'X')}</td>
                    <td>${A(ord, 'Y')}</td>
                    <td class="left-align">${A(ord, 'GeopointZacrep')}</td>
                    <td>${A(ord, 'DeltaGeopoint')}</td>
                </tr>`;
            }
        });

        if (tableContent) {
             spatialHtml += `<div class="subsection" id="main-coord-section"><div class="subsection-title">Координаты характерных точек</div><table class="data-table coord-table"><thead><tr><th>Обозначение</th><th>X</th><th>Y</th><th class="left-align">Метод закрепления</th><th>Погрешность, м</th></tr></thead><tbody>${tableContent}</tbody></table></div>`;
        }

        const borders = All(entitySpatial, 'Borders > Border');
        if (borders.length > 0) {
             spatialHtml += `<div class="subsection"><div class="subsection-title">Длины линий</div>
                      <table class="data-table lengths-table"><thead><tr><th>Участок</th><th>Длина, м</th></tr></thead><tbody>
                      ${Array.from(borders).map(b => `<tr><td>${A(b,'Point1')}-${A(b,'Point2')}</td><td>${T(b,'Edge > Length') || T(b, 'Length')}</td></tr>`).join('')}
                      </tbody></table></div>`;
        }
        return spatialHtml;
    }


    // --- ОСНОВНАЯ ФУНКЦИЯ ОТОБРАЖЕНИЯ (ПОЛНОСТЬЮ ОБНОВЛЕННАЯ) ---
    function displayData(xmlDoc, xmlText) {
        let mainHtml = '';
        let sidebarHtml = '';
        let sectionsFound = 0;

        // --- SIDEBAR: Общая информация ---
        const formParcels = E(xmlDoc, 'FormParcels');
        const reasonText = T(xmlDoc, 'GeneralCadastralWorks > Reason');
        if (formParcels || reasonText !== '—') {
            sectionsFound++;
            let generalInfoContent = '';
            if (formParcels) {
                const method = A(formParcels, 'Method');
                generalInfoContent += `<div class="info-card">
                    <div class="info-label">Способ образования ЗУ</div>
                    <div class="info-value">${planTypes[method] || `Неизвестный (${method})`}</div>
                </div>`;
            }
            if (reasonText !== '—') {
                 generalInfoContent += `<div class="info-card" style="grid-column: 1 / -1;">
                    <div class="info-label">Основание для работ</div>
                    <div class="info-value">${reasonText}</div>
                </div>`;
            }
            sidebarHtml += `<div class="section">
                <div class="section-header">${sectionIcons.generalInfo}<h3 class="section-title">Общая информация</h3></div>
                <div class="section-content" style="padding:16px"><div class="info-grid">${generalInfoContent}</div></div>
            </div>`;
        }
        
        // --- SIDEBAR: Участники работ ---
        const contractor = E(xmlDoc, 'Contractor');
        const client = E(xmlDoc, 'Client Person, Client Organization'); // Ищем физ. или юр. лицо
        if (contractor || client) {
            sectionsFound++;
            let participantsHtml = `<div class="section"><div class="section-header">${sectionIcons.participants}<h3 class="section-title">Участники работ</h3></div><div class="section-content" style="padding:16px">`;
            if (contractor) {
                const cadWork = E(contractor, 'AgreementCadWork');
                participantsHtml += `<div class="subsection" style="margin-top:0;"><div class="subsection-title">Кадастровый инженер</div>
                    <div class="info-grid">
                        <div class="info-card"><div class="info-label">ФИО</div><div class="info-value">${T(contractor, 'FamilyName')} ${T(contractor, 'FirstName')} ${T(contractor, 'Patronymic')}</div></div>
                        <div class="info-card"><div class="info-label">№ в реестре</div><div class="info-value">${T(contractor, 'CadastralEngineerRegistryNumber')} (от ${T(contractor, 'DateEntering')})</div></div>
                        <div class="info-card"><div class="info-label">СНИЛС</div><div class="info-value">${T(contractor, 'SNILS')}</div></div>
                        <div class="info-card" style="grid-column: 1 / -1;"><div class="info-label">Контакты</div><div class="info-value">Тел: ${T(contractor, 'Telephone')}, Email: ${T(contractor, 'Email')}</div></div>
                        <div class="info-card" style="grid-column: 1 / -1;"><div class="info-label">СРО</div><div class="info-value">${T(contractor, 'SelfRegulatoryOrganization')}</div></div>
                        <div class="info-card" style="grid-column: 1 / -1;"><div class="info-label">Договор</div><div class="info-value">${T(cadWork, 'Name')} №${T(cadWork, 'NumberAgreement')} от ${T(cadWork, 'DateAgreement')}</div></div>
                    </div></div>`;
            }
            if (client) {
                const isOrg = !!E(client, 'Organization');
                participantsHtml += `<div class="subsection"><div class="subsection-title">Заказчик</div>
                    <div class="info-grid">`;
                if(isOrg) {
                    participantsHtml += `
                        <div class="info-card" style="grid-column: 1 / -1;"><div class="info-label">Наименование</div><div class="info-value">${T(client, 'Organization > Name')}</div></div>
                        <div class="info-card"><div class="info-label">ИНН</div><div class="info-value">${T(client, 'Organization > INN')}</div></div>
                        <div class="info-card"><div class="info-label">ОГРН</div><div class="info-value">${T(client, 'Organization > OGRN')}</div></div>`;
                } else {
                    participantsHtml += `
                        <div class="info-card"><div class="info-label">ФИО</div><div class="info-value">${T(client, 'FamilyName')} ${T(client, 'FirstName')} ${T(client, 'Patronymic')}</div></div>
                        <div class="info-card"><div class="info-label">СНИЛС</div><div class="info-value">${T(client, 'SNILS')}</div></div>`;
                }
                participantsHtml += `</div></div>`;
            }
            participantsHtml += `</div></div>`;
            sidebarHtml += participantsHtml;
        }

        // --- SIDEBAR: Исходные данные ---
        const inputData = E(xmlDoc, 'InputData');
        if (inputData) {
            sectionsFound++;
            let inputDataHtml = `<div class="section"><div class="section-header">${sectionIcons.inputData}<h3 class="section-title">Исходные данные</h3></div><div class="section-content" style="padding:16px">`;
            const documents = All(inputData, 'Documents > Document');
            if (documents.length > 0) {
                 inputDataHtml += `<div class="subsection" style="margin-top:0;"><div class="subsection-title">Документы</div>
                 <table class="data-table"><thead><tr><th class="left-align">Наименование</th><th class="no-wrap">№</th><th class="no-wrap">Дата</th></tr></thead><tbody>
                 ${Array.from(documents).map(doc => `<tr><td class="left-align">${T(doc, 'Name')}</td><td class="no-wrap">${T(doc, 'Number')}</td><td class="no-wrap">${T(doc, 'Date')}</td></tr>`).join('')}
                 </tbody></table></div>`;
            }
            const geoBases = All(inputData, 'GeodesicBases > GeodesicBase');
            if (geoBases.length > 0) {
                 inputDataHtml += `<div class="subsection"><div class="subsection-title">Геодезическая основа</div>
                 <table class="data-table"><thead><tr><th class="left-align">Пункт</th><th>Класс</th><th>X</th><th>Y</th></tr></thead><tbody>
                 ${Array.from(geoBases).map(base => `<tr><td class="left-align">${T(base, 'PName')} (${T(base, 'PKind')})</td><td>${T(base, 'PKlass')}</td><td>${T(base, 'OrdX')}</td><td>${T(base, 'OrdY')}</td></tr>`).join('')}
                 </tbody></table></div>`;
            }
            const meanSurvey = E(inputData, 'MeansSurvey > MeanSurvey');
            if (meanSurvey) {
                  inputDataHtml += `<div class="subsection"><div class="subsection-title">Средства измерений</div>
                    <div class="info-grid">
                        <div class="info-card" style="grid-column: 1 / -1;"><div class="info-label">Прибор</div><div class="info-value">${T(meanSurvey, 'Name')}</div></div>
                        <div class="info-card"><div class="info-label">Номер</div><div class="info-value">${T(meanSurvey, 'Number')}</div></div>
                        <div class="info-card"><div class="info-label">Поверка</div><div class="info-value">${T(meanSurvey, 'CertificateVerification')}</div></div>
                    </div></div>`;
            }
            inputDataHtml += `</div></div>`;
            sidebarHtml += inputDataHtml;
        }

        // --- MAIN: Образуемый участок ---
              // --- MAIN: Образуемые участки (с циклом для поддержки нескольких) ---
        const newParcels = All(xmlDoc, 'NewParcel');
        for (const newParcel of newParcels) { // <-- ИЗМЕНЕНИЕ: Добавлен цикл for..of
            sectionsFound++;
            const categoryCode = A(E(newParcel, 'Category'), 'Category');
            const categoryName = landCategories[categoryCode] || 'Категория не определена';
            let sectionContent = `
                <div class="info-grid">
                    <div class="info-card"><div class="info-label">Кадастровый квартал</div><div class="info-value">${T(newParcel, 'CadastralBlock')}</div></div>
                    <div class="info-card"><div class="info-label">Площадь, кв.м.</div><div class="info-value">${T(newParcel, 'Area > Area')} (±${T(newParcel, 'Area > Inaccuracy')})</div></div>
                    <div class="info-card"><div class="info-label">Категория земель</div><div class="info-value">${categoryName} <code>${categoryCode}</code></div></div>
                    <div class="info-card"><div class="info-label">Вид разрешенного использования</div><div class="info-value">${A(E(newParcel, 'PermittedUseEstablished, PermittedUsesLand > PermittedUseEstablished'), 'ByDocument')}</div></div>
                    <div class="info-card"><div class="info-label">Обеспечение доступа</div><div class="info-value">${T(newParcel, 'ProvidingPassCadastralNumbers > Other, ProvidingPassCadastralNumbers > CadastralNumber')}</div></div>
                </div>
                ${T(newParcel, 'Area > Formula') !== '—' ? `<div class="subsection"><div class="subsection-title">Формула погрешности</div><div class="conclusion-text">${T(newParcel, 'Area > Formula')}</div></div>` : ''}
                ${All(newParcel, 'ObjectsRealty CadastralNumber').length > 0 ? `<div class="subsection"><div class="subsection-title">ОКС на участке</div><div class="info-grid">${Array.from(All(newParcel, 'ObjectsRealty CadastralNumber')).map(node => `<div class="info-card"><div class="info-value">${node.textContent}</div></div>`).join('')}</div></div>` : ''}
                ${E(newParcel, 'Address') ? `<div class="subsection"><div class="subsection-title">Адрес</div><div class="address-display">${[T(E(newParcel, 'Address'), 'RussianFederation'), T(E(newParcel, 'Address'), 'Region') !== '—' ? `Респ. ${T(E(newParcel, 'Address'), 'Region')}` : '', T(E(newParcel, 'Address'), 'District') !== '—' ? `${A(E(E(newParcel, 'Address'), 'District'), 'Type')} ${T(E(newParcel, 'Address'), 'District')}` : '', T(E(newParcel, 'Address'), 'City') !== '—' ? `${A(E(E(newParcel, 'Address'), 'City'), 'Type')} ${T(E(newParcel, 'Address'), 'City')}` : '', T(E(newParcel, 'Address'), 'Locality') !== '—' ? `${A(E(E(newParcel, 'Address'), 'Locality'), 'Type')} ${T(E(newParcel, 'Address'), 'Locality')}` : '', T(E(newParcel, 'Address'), 'Street') !== '—' ? `${A(E(E(newParcel, 'Address'), 'Street'), 'Type')} ${T(E(newParcel, 'Address'), 'Street')}` : '', T(E(newParcel, 'Address'), 'Level1') ? `${A(E(E(newParcel, 'Address'), 'Level1'), 'Type')} ${A(E(E(newParcel, 'Address'), 'Level1'), 'Value')}` : '', T(E(newParcel, 'Address'), 'Other')].filter(p => p && p.trim() && p !== '—' && !p.includes('—')).join(', ')}</div><div class="info-grid" style="margin-top: 16px;"><div class="info-card"><div class="info-label">FIAS</div><div class="info-value">${T(E(newParcel, 'Address'), 'FIAS')}</div></div></div></div>` : ''}
            `;
            
            // Добавляем парсинг координат для образуемого участка
            const entitySpatial = E(newParcel, 'EntitySpatial');
            if (entitySpatial) {
                sectionContent += createSpatialDataHtml(entitySpatial);
            }

            // Добавляем кнопку копирования, если есть координаты
            const hasCoords = !!entitySpatial;
            mainHtml += `<div class="section">
                <div class="section-header">
                    ${sectionIcons.newParcel}
                    <h3 class="section-title">Сведения об образуемом участке (${A(newParcel, 'Definition')})</h3>
                    ${hasCoords ? `<button class="header-button copy-coords-btn" title="Скопировать координаты и открыть схему">${sectionIcons.copyXY}</button>` : ''}
                </div>
                <div class="section-content" style="padding:16px">${sectionContent}</div>
            </div>`;
        }
        
        // --- MAIN: Уточняемый участок (для исправления ошибок / уточнения границ) ---
        const specifiedParcels = All(xmlDoc, 'SpecifyParcel > ExistParcel');
        for (const parcel of specifiedParcels) {
            sectionsFound++;
            const cadNum = A(parcel, 'CadastralNumber');
            const categoryCode = A(E(parcel, 'Category'), 'Category');
            const categoryName = landCategories[categoryCode] || 'Категория не определена';
            let sectionContent = `
                <div class="info-grid">
                    <div class="info-card"><div class="info-label">Кадастровый номер</div><div class="info-value"><code>${cadNum}</code></div></div>
                    <div class="info-card"><div class="info-label">Кадастровый квартал</div><div class="info-value">${T(parcel, 'CadastralBlock')}</div></div>
                    ${categoryCode && categoryCode !== '—' ? `<div class="info-card"><div class="info-label">Категория земель</div><div class="info-value">${categoryName} <code>${categoryCode}</code></div></div>` : ''}
                    <div class="info-card"><div class="info-label">Уточненная площадь, кв.м.</div><div class="info-value">${T(parcel, 'Area > Area')} (погрешность ±${T(parcel, 'Area > Inaccuracy')})</div></div>
                    <div class="info-card"><div class="info-label">Площадь по ЕГРН, кв.м.</div><div class="info-value">${T(parcel, 'AreaInGKN')}</div></div>
                    <div class="info-card"><div class="info-label">Разница площадей, кв.м.</div><div class="info-value">${T(parcel, 'DeltaArea')}</div></div>
                    <div class="info-card" style="grid-column: 1 / -1;"><div class="info-label">Обеспечение доступа</div><div class="info-value">${T(parcel, 'ProvidingPassCadastralNumbers > Other')}</div></div>
                </div>
                ${T(parcel, 'Area > Formula') !== '—' ? `<div class="subsection"><div class="subsection-title">Формула погрешности</div><div class="conclusion-text">${T(parcel, 'Area > Formula')}</div></div>` : ''}
            `;

            // Используем новую общую функцию для парсинга координат
            const entitySpatial = E(parcel, 'EntitySpatial');
            if (entitySpatial) {
                sectionContent += createSpatialDataHtml(entitySpatial);
            }

            mainHtml += `<div class="section">
                <div class="section-header">
                    ${sectionIcons.newParcel}
                    <h3 class="section-title">Сведения об уточняемом участке</h3>
                    <button class="header-button copy-coords-btn" title="Скопировать координаты и открыть схему">${sectionIcons.copyXY}</button>
                </div>
                <div class="section-content" style="padding:16px">${sectionContent}</div>
            </div>`;
        }

        // --- MAIN: Уточнение смежного ---
        const specifyRelatedParcel = E(xmlDoc, 'SpecifyRelatedParcel');
        if(specifyRelatedParcel){
            sectionsFound++;
            let tableContent = '';
            All(specifyRelatedParcel, 'ChangeBorder').forEach(ch => {
                const oldOrd = E(ch, 'OldOrdinate');
                const newOrd = E(ch, 'NewOrdinate');
                tableContent += `<tr>
                            <td>${A(oldOrd || newOrd, 'NumGeopoint') || A(newOrd, 'PointPref') + A(newOrd, 'NumGeopoint')}</td>
                            <td>${oldOrd ? `${A(oldOrd, 'X')}, ${A(oldOrd, 'Y')}` : '—'}</td>
                            <td>${newOrd ? `${A(newOrd, 'X')}, ${A(newOrd, 'Y')}` : '—'}</td>
                            <td class="left-align">${newOrd ? `Δ=${A(newOrd, 'DeltaGeopoint')} м, ${A(newOrd, 'GeopointZacrep')}`: 'Точка удалена'}</td>
                        </tr>`;
            });
            mainHtml += `<div class="section">
                <div class="section-header">${sectionIcons.relatedParcel}<h3 class="section-title">Уточнение смежного участка: ${A(specifyRelatedParcel, 'CadastralNumber')}</h3></div>
                <div class="section-content" style="padding:16px"><table class="data-table"><thead><tr><th>Точка</th><th>Старые коорд. (X, Y)</th><th>Новые коорд. (X, Y)</th><th class="left-align">Примечание</th></tr></thead><tbody>${tableContent}</tbody></table></div>
            </div>`;
        }
        
        // --- MAIN: Заключение инженера с проверкой ИИ ---
        const conclusion = E(xmlDoc, 'Conclusion');
        if (conclusion && conclusion.textContent.trim()) {
            sectionsFound++;
            mainHtml += `<div class="section">
                <div class="section-header">
                    ${sectionIcons.conclusion}
                    <h3 class="section-title">Заключение кадастрового инженера</h3>
                    <button class="header-button ai-check-btn" 
                            data-conclusion-text="${escapeHtml(conclusion.textContent.trim())}" 
                            title="Проверить заключение с помощью ИИ">
                        <i class="fas fa-atom"></i>
                    </button>
                </div>
                <div class="section-content" style="padding:16px">
                    <div class="conclusion-text">${conclusion.textContent.trim()}</div>
                </div>
            </div>`;
        }

        // --- MAIN: Остальные блоки ---
        const graphicFiles = [
            { title: 'Схема геодезических построений', file: A(E(xmlDoc, 'SchemeGeodesicPlotting'), 'Name') },
            { title: 'Схема расположения ЗУ', file: A(E(xmlDoc, 'SchemeDisposition'), 'Name') },
            { title: 'Чертеж земельного участка', file: A(E(xmlDoc, 'DiagramParcelsSubParcels > AppliedFile'), 'Name') },
            { title: 'Акт согласования границ', file: A(E(xmlDoc, 'AgreementDocument > AppliedFile'), 'Name') }
        ].filter(f => f.file !== '—');
        if(graphicFiles.length > 0) {
            sectionsFound++;
            mainHtml += `<div class="section"><div class="section-header">${sectionIcons.graphics}<h3 class="section-title">Графические разделы</h3></div><div class="section-content" style="padding:16px">
                    <table class="data-table"><thead><tr><th class="left-align">Наименование раздела</th><th class="left-align">Имя файла</th></tr></thead><tbody>
                    ${graphicFiles.map(f => `<tr><td class="left-align">${f.title}</td><td class="left-align"><span class="file-name">${f.file}</span></td></tr>`).join('')}
                    </tbody></table></div></div>`;
        }
        const appendixFiles = All(xmlDoc, 'Appendix > AppliedFiles');
        if(appendixFiles.length > 0) {
            sectionsFound++;
            mainHtml += `<div class="section"><div class="section-header">${sectionIcons.appendix}<h3 class="section-title">Приложения</h3></div><div class="section-content" style="padding:16px">
                    <table class="data-table"><thead><tr><th>№</th><th class="left-align">Наименование</th><th class="left-align">Имя файла</th></tr></thead><tbody>
                    ${Array.from(appendixFiles).map(f => `<tr><td>${T(f, 'NumberAppendix')}</td><td class="left-align">${T(f, 'NameAppendix')}</td><td class="left-align"><span class="file-name">${A(E(f, 'AppliedFile'), 'Name')}</span></td></tr>`).join('')}
                    </tbody></table></div></div>`;
        }

        const validationHtml = runValidation(xmlDoc, xmlText);
        if(validationHtml) {
             mainHtml += `<div class="section validation-section">
                <div class="section-header">${sectionIcons.validation}<h3 class="section-title">Проверка межевого плана</h3></div>
                <div class="section-content" style="padding:16px">${validationHtml}</div>
            </div>`;
        }

        if (sectionsFound > 0) {
            mainColumn.innerHTML = mainHtml;
            sidebarColumn.innerHTML = sidebarHtml;
            resultsContainer.classList.remove('hidden');
            statusContainer.classList.add('hidden');
            printButtonContainer.classList.remove('hidden');
            messageArea.innerHTML = '';
        } else {
            showError('Файл успешно прочитан, но в нем не найдено известных разделов межевого плана. Возможно, это XML другого типа.');
        }
    }

    function runValidation(xmlDoc, xmlText) {
        let messages = [];
        
        // --- НОВЫЙ БЛОК: Проверка дат ---
        const dateWarnings = [];
        const foundDates = new Set(); // Для исключения дубликатов
        const dateRegex = /(?:\b(\d{2})\.(\d{2})\.(\d{4})\b)|(?:\b(\d{4})-(\d{2})-(\d{2})\b)/g;
        const minDate = new Date(1990, 0, 1); // 1 января 1990
        const currentDate = new Date();
        currentDate.setHours(23, 59, 59, 999); // Устанавливаем конец текущего дня для корректного сравнения

        let match;
        while ((match = dateRegex.exec(xmlText)) !== null) {
            const fullMatch = match[0];
            if (foundDates.has(fullMatch)) continue; // Пропускаем уже проверенные даты
            foundDates.add(fullMatch);

            let day, month, year, parsedDate;
            if (match[1]) { // Формат ДД.ММ.ГГГГ
                day = parseInt(match[1], 10);
                month = parseInt(match[2], 10);
                year = parseInt(match[3], 10);
            } else { // Формат ГГГГ-ММ-ДД
                year = parseInt(match[4], 10);
                month = parseInt(match[5], 10);
                day = parseInt(match[6], 10);
            }
            
            // Проверяем корректность самой даты (например, 30.02.2024 не пройдет)
            parsedDate = new Date(year, month - 1, day);
            if (parsedDate.getFullYear() !== year || parsedDate.getMonth() !== month - 1 || parsedDate.getDate() !== day) {
                continue; // Это некорректная дата, пропускаем её
            }

            if (parsedDate < minDate) {
                dateWarnings.push(`"${fullMatch}"`);
            } else if (parsedDate > currentDate) {
                dateWarnings.push(`"${fullMatch}" (будущая дата)`);
            }
        }

        if (dateWarnings.length > 0) {
            messages.push(`<div class="validation-message validation-warning">${sectionIcons.warningIcon} <strong>Предупреждение о датах:</strong> Найдены даты за пределами допустимого диапазона (01.01.1990 - сегодня): ${dateWarnings.join(', ')}.</div>`);
        }
        // --- КОНЕЦ НОВОГО БЛОКА ---

        const knRegex = /\d{2}:\d{2}:\d{6,7}:\d+/g;
        const blockRegex = /\d{2}:\d{2}:\d{6,7}/;
        let allNumbers = new Set((xmlText.match(knRegex) || []));
        All(xmlDoc, 'CadastralBlock').forEach(b => allNumbers.add(b.textContent.trim()));
        const quarters = new Map();
        allNumbers.forEach(num => {
            const match = num.match(blockRegex);
            if (match) {
                const quarter = match[0];
                if (!quarters.has(quarter)) quarters.set(quarter, []);
                quarters.get(quarter).push(num);
            }
        });
        const colors = ['#1d4ed8', '#b91c1c', '#c2410c', '#15803d', '#86198f'];
        let colorIndex = 0;
        const quarterColors = new Map();
        for (const q of quarters.keys()) { quarterColors.set(q, colors[colorIndex % colors.length]); colorIndex++; }
        if (quarters.size > 1) { messages.push(`<div class="validation-message validation-warning">${sectionIcons.warningIcon} <strong>Предупреждение:</strong> Найдены объекты из разных кадастровых кварталов.</div>`); }
        let numberListHtml = '<ul id="cadastralNumbersList">';
        quarters.forEach((numbers, quarter) => { const color = quarterColors.get(quarter); numbers.sort().forEach(num => { numberListHtml += `<li style="border-color:${color}; color:${color};">${num}</li>`; }); });
        numberListHtml += '</ul>';
        messages.push(`<div class="subsection" style="margin-top:0"><div class="subsection-title">Все кадастровые номера в документе</div>${numberListHtml}</div>`);
        const mainParcel = E(xmlDoc, 'NewParcel') || E(xmlDoc, 'ExistParcel');
        if (mainParcel) {
            const categoryCode = A(E(mainParcel, 'Category'), 'Category');
            const requiredMt = accuracyStandards[categoryCode];
            const area = parseFloat(T(mainParcel, 'Area > Area'));
            const statedAreaInaccuracy = parseFloat(T(mainParcel, 'Area > Inaccuracy'));
            const ordinates = All(mainParcel, 'SpelementUnit > NewOrdinate, SpelementUnit > Ordinate');
            if (ordinates.length > 0) {
                const accuracies = new Set();
                let allFixingsFilled = true;
                ordinates.forEach(ord => {
                    const delta = A(ord, 'DeltaGeopoint');
                    if(delta && delta !== '—') accuracies.add(parseFloat(delta));
                    if(A(ord, 'GeopointZacrep') === '—') allFixingsFilled = false;
                });
                if (!allFixingsFilled) { messages.push(`<div class="validation-message validation-warning">${sectionIcons.warningIcon} <strong>Предупреждение:</strong> Не для всех точек указан метод закрепления на местности.</div>`);}
                if (accuracies.size > 1) { messages.push(`<div class="validation-message validation-warning">${sectionIcons.warningIcon} <strong>Предупреждение:</strong> У точек главного участка разные значения погрешности (${Array.from(accuracies).join(', ')}).</div>`); }
                const actualMt = accuracies.size > 0 ? accuracies.values().next().value : null;
                if (requiredMt && actualMt) {
                    if (actualMt > requiredMt) { messages.push(`<div class="validation-message validation-error">${sectionIcons.errorIcon} <strong>Ошибка Mt:</strong> Погрешность точек <strong>${actualMt}</strong> превышает норматив <strong>${requiredMt}</strong> для категории "${landCategories[categoryCode]}".</div>`); } 
                    else { messages.push(`<div class="validation-message validation-success">${sectionIcons.successIcon} <strong>Проверка Mt:</strong> Погрешность точек <strong>${actualMt}</strong> соответствует нормативу для данной категории земель.</div>`); }
                } else if (!requiredMt) { messages.push(`<div class="validation-message validation-warning">${sectionIcons.warningIcon} <strong>Проверка Mt:</strong> Не удалось определить норматив погрешности, так как категория земель не указана</div>`); }
                if (area && actualMt && statedAreaInaccuracy) {
                    const calculatedAreaInaccuracy = Math.round(3.5 * actualMt * Math.sqrt(area));
                    if (calculatedAreaInaccuracy !== statedAreaInaccuracy) { messages.push(`<div class="validation-message validation-error">${sectionIcons.errorIcon} <strong>Ошибка ΔP:</strong> Расчетная погрешность площади <strong>(${calculatedAreaInaccuracy} м²)</strong> не совпадает с указанной в XML <strong>(${statedAreaInaccuracy} м²)</strong>.</div>`); } 
                    else { messages.push(`<div class="validation-message validation-success">${sectionIcons.successIcon} <strong>Проверка ΔP:</strong> Расчетная погрешность площади <strong>(${calculatedAreaInaccuracy} м²)</strong> совпадает с указанной в XML</div>`); }
                }
            }
        }
        return messages.length > 0 ? messages.join('') : '';
    }
    // --- Логика модального окна и проверки ИИ ---
    function openAiModal() { aiCheckModal.style.display = 'flex'; }
    function closeAiModal() { aiCheckModal.style.display = 'none'; aiCheckResultDisplay.innerHTML = ''; }
    aiModalCloseBtn.addEventListener('click', closeAiModal);
    aiCheckModal.addEventListener('click', (event) => { if (event.target === aiCheckModal) closeAiModal(); });

 
    aiModalMinimizeBtn.addEventListener('click', () => {
        aiCheckModal.classList.toggle('minimized');
    });

        async function checkConclusionWithAI(conclusionText) {
        if (!conclusionText) {
            alert("Текст заключения пуст. Проверка невозможна.");
            return;
        }
        openAiModal();
        aiCheckResultDisplay.innerHTML = `<div class="ai-spinner"><div class="loader"></div><span></span></div>`;

        const systemPrompt = `Ты — эксперт-помощник кадастрового инженера в России. Твоя задача — проанализировать "Заключение кадастрового инженера" из межевого плана.
Проверь текст на:
1.  **Полноту:** Упомянуты ли основания для работ (договор, проект), исходные документы, способ образования/уточнения, кадастровые номера?
2.  **Ясность и однозначность:** Формулировки должны быть четкими, без двусмысленности.
3.  **Корректность терминологии:** Правильно ли используются кадастровые термины.
4.  **Логичность:** Обоснованы ли выполненные действия (например, почему площадь изменилась, как обеспечен доступ).
5.  **Орфографию и грамматику.**

Верни ответ СТРОГО в формате JSON с тремя полями:
- "is_correct": boolean (true, если текст идеален и не требует правок, иначе false).
- "feedback": string (детальный, но краткий анализ на русском языке, с пунктами по существу дела, можно использовать Markdown для списков).
- "corrected_text": string (улучшенная версия заключения. Если правок нет, верни исходный текст).

Не добавляй никаких комментариев или объяснений вне JSON.`;

        const userPrompt = `${systemPrompt}\n\nТекст для проверки:\n---\n${conclusionText}`;
        let apiUrl;
        let requestBody;
        const modelId = "gemini-2.5-flash-lite-preview-06-17";

        if (PROXY_MODE === 1) {
            apiUrl = `${MAPRUAPP_PROXY_BASE_URL}/ai/api/v1/chat/completions`;
            requestBody = { 
                model: modelId, 
                messages: [{ role: "user", content: userPrompt }], 
                max_tokens: 4096, // <-- ИЗМЕНЕНИЕ: Увеличено с 2048 до 4096
                response_format: { type: "json_object" } 
            };
        } else {
            aiCheckResultDisplay.innerHTML = `<div class="ai-result-error">Режим прокси не настроен.</div>`;
            return;
        }
        
        try {
            const response = await fetch(apiUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(requestBody) });
            const data = await response.json();
            if (!response.ok) { throw new Error(`Ошибка API (${response.status}): ${data?.error?.message || `Статус ${response.status}`}`); }
            
            let aiResponseText = data.choices?.[0]?.message?.content;
            if (!aiResponseText) { throw new Error('Не удалось получить ответ от ИИ (пустое поле content).'); }
            
            let parsedResponse;
            try {
                // Очистка от markdown-обертки JSON
                const cleanedText = aiResponseText.trim().replace(/^```json\s*|\s*```$/g, '');
                parsedResponse = JSON.parse(cleanedText);
            } catch (e) { 
                console.error("AI Response (raw):", aiResponseText); 
                throw new Error("Ответ ИИ имеет неверную структуру JSON."); 
            }

            let resultHtml = '';
            if (parsedResponse.is_correct) {
                resultHtml = `<div class="ai-result-success"><i class="fas fa-check-circle"></i> <strong>Вердикт ИИ:</strong> Заключение составлено хорошо. Замечаний нет.</div>`;
            } else {
                resultHtml += `<h4><i class="fas fa-lightbulb"></i> Анализ ИИ:</h4><div class="ai-feedback">${escapeHtml(parsedResponse.feedback)}</div>`;
                if (parsedResponse.corrected_text && parsedResponse.corrected_text !== conclusionText) {
                    resultHtml += `<h4><i class="fas fa-magic-wand-sparkles"></i> Предложенная редакция:</h4><pre class="ai-corrected-text">${escapeHtml(parsedResponse.corrected_text)}</pre>
                    <button class="ai-copy-button" id="aiCopyBtn">
                        <i class="fas fa-copy"></i>
                        <span>Копировать исправленный текст</span>
                    </button>`;
                }
            }
            aiCheckResultDisplay.innerHTML = resultHtml;

        } catch (error) {
            console.error('Ошибка при проверке заключения с ИИ:', error);
            aiCheckResultDisplay.innerHTML = `<div class="ai-result-error"><strong>Произошла ошибка:</strong> ${error.message}</div>`;
        }
    }

    aiCheckResultDisplay.addEventListener('click', (event) => {
        const copyButton = event.target.closest('#aiCopyBtn');
        if(copyButton) {
            const correctedTextElement = aiCheckResultDisplay.querySelector('.ai-corrected-text');
            if (!correctedTextElement) return;

            const textToCopy = correctedTextElement.textContent;
            navigator.clipboard.writeText(textToCopy).then(() => {
                const buttonSpan = copyButton.querySelector('span');
                const originalText = buttonSpan.textContent;
                buttonSpan.textContent = 'Скопировано!';
                copyButton.disabled = true;
                setTimeout(() => {
                    buttonSpan.textContent = originalText;
                    copyButton.disabled = false;
                }, 2000);
            }).catch(err => {
                alert('Не удалось скопировать текст.');
                console.error('Copy error:', err);
            });
        }
    });

});
</script>
</body>
</html>