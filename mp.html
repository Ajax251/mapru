<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Межевой/Технический план</title>
  <script src="webfonts/jszip.min.js"></script>
    <link rel="stylesheet" href="webfonts/all.min.css">
    <link id="favicon" rel="icon" href="img/mpch.png" type="image/png">
    <style>
        :root {
            --primary-color: #2563eb;
            --secondary-color: #f8fafc;
            --accent-color: #0ea5e9;
            --success-color: #10b981;
            --warning-color: #f97316;
            --error-color: #ef4444;
            --info-color: #8b5cf6;
            --text-primary: #1e293b;
            --text-secondary: #64748b;
            --border-color: #e2e8f0;
            --shadow-sm: 0 1px 2px 0 rgb(0 0 0 / 0.05);
            --shadow-md: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            line-height: 1.6;
            background-color: #f0f4f8;
            color: var(--text-primary);
        }
        .container {
            max-width: 1800px;
            margin: 20px auto;
            background: white;
            border-radius: 16px;
            box-shadow: var(--shadow-lg);
            overflow: hidden;
        }
        .content { padding: 24px; }

        .file-upload-section {
            background: var(--secondary-color);
            border-radius: 12px;
            padding: 12px;
            margin-bottom: 20px;
            border: 2px dashed var(--border-color);
            transition: all 0.3s ease;
        }
        .file-upload-area {
            text-align: center;
            cursor: pointer;
            padding: 12px 16px;
            border-radius: 8px;
            transition: all 0.3s ease;
            position: relative;
            user-select: none;
        }
        .file-upload-area:hover { background: white; transform: translateY(-2px); box-shadow: var(--shadow-sm); }
        .file-upload-area.dragover { background: #dbeafe !important; border-color: var(--primary-color) !important; }
        .file-upload-section.dragover { border-color: var(--primary-color); background: #f0f9ff; }
        .upload-icon {
            margin-bottom: 8px;
            line-height: 1;
        }
        .upload-icon img {
            width: 48px;
            height: 48px;
            object-fit: contain;
        }
        .upload-text { font-size: 1.1rem; font-weight: 600; color: var(--text-primary); margin-bottom: 4px; }
        .upload-subtext { color: var(--text-secondary); font-size: 0.9rem; }
        #fileInput { display: none; }
        .status-container {
            text-align: center; margin: 24px 0; min-height: 60px;
            display: flex; align-items: center; justify-content: center; gap: 16px;
        }
        .loader {
            width: 32px; height: 32px; border: 3px solid #f3f4f6;
            border-top: 3px solid var(--primary-color); border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        .status-text { font-size: 1.1rem; font-weight: 500; color: var(--text-secondary); }
        .hidden { display: none; }

        #resultsContainer {
            display: grid;
            grid-template-columns: 2fr 1.2fr;
            gap: 24px;
            align-items: start;
        }
        #mainColumn, #sidebarColumn {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .section {
            background: white; border-radius: 12px;
            border: 1px solid var(--border-color); box-shadow: var(--shadow-sm); overflow: hidden;
            width: 100%;
            margin-bottom: 0;
        }
        .section-header {
            background: linear-gradient(135deg, #f8fafc 0%, #eef2f7 100%);
            padding: 16px 20px; border-bottom: 1px solid var(--border-color);
            display: flex;
            align-items: center;
            gap: 12px;
        }
        .section-icon {
            width: 24px;
            height: 24px;
            color: var(--primary-color);
            flex-shrink: 0;
        }
        .section-title { font-size: 1.3rem; font-weight: 600; color: var(--text-primary); margin: 0; }
        
        .header-button {
            margin-left: auto;
            padding: 4px; border-radius: 6px;
            transition: all 0.2s; cursor: pointer;
            display: flex; align-items: center;
            border: none; background: transparent;
            color: var(--primary-color);
        }
        .header-button:hover { background-color: var(--border-color); transform: scale(1.1); }
        .header-button i { font-size: 20px; }

        .info-grid {
            display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 16px; margin-bottom: 16px;
        }
        .info-card {
            background: var(--secondary-color); border-radius: 8px; padding: 16px;
            border: 1px solid var(--border-color);
        }
        .info-label {
            font-size: 0.85rem; font-weight: 600; color: var(--text-secondary);
            text-transform: uppercase; letter-spacing: 0.5px; margin-bottom: 4px;
        }
        .info-value { font-size: 1rem; color: var(--text-primary); font-weight: 500; }
        .info-value code {
            background: #e2e8f0; padding: 2px 6px; border-radius: 4px;
            font-family: 'Courier New', monospace; font-size: 0.95rem;
        }
        .data-table {
            width: 100%; border-collapse: collapse; margin-top: 16px;
            border-radius: 8px; overflow: hidden; box-shadow: var(--shadow-sm);
        }
        .data-table th, .data-table td {
            padding: 12px 16px;
            border-bottom: 1px solid var(--border-color);
            vertical-align: middle;
            text-align: center;
        }
        .data-table th {
            background: var(--primary-color); color: white;
            font-weight: 600; font-size: 0.9rem;
        }
        .data-table tbody tr:hover { background: var(--secondary-color); }
        .data-table tbody tr:last-child td { border-bottom: none; }
        .data-table td:first-child, .data-table .left-align { text-align: left; }
        .data-table .no-wrap { white-space: nowrap; }
        .coord-table td:first-child { text-align: center; font-weight: 600; }
        .coord-table td:nth-child(4) { text-align: left; }
        .data-table.lengths-table td:first-child { text-align: center; }

        .address-display {
            background: linear-gradient(135deg, #f0f9ff 0%, #e0f2fe 100%);
            border: 1px solid #bae6fd; border-radius: 8px; padding: 16px;
            font-size: 1.1rem; font-weight: 500; color: var(--text-primary);
        }
        .conclusion-text {
            background: #f8fafc; border: 1px solid var(--border-color); border-radius: 8px;
            padding: 16px; font-size: 0.95rem;
            line-height: 1.5; white-space: pre-wrap; word-wrap: break-word;
        }
        .error-message {
            background: #fef2f2; border: 1px solid #fecaca; border-radius: 8px;
            padding: 16px; color: var(--error-color); font-weight: 500; text-align: center;
        }
        .subsection { margin-top: 24px; }
        .subsection-title {
            font-size: 1.1rem; font-weight: 600; color: var(--text-primary);
            margin-bottom: 12px; padding-bottom: 8px; border-bottom: 2px solid var(--border-color);
        }
        .file-name {
            font-family: 'Courier New', monospace; background: #e2e8f0; padding: 2px 6px;
            border-radius: 4px; font-size: 0.95rem;
        }

        #printButtonContainer {
            text-align: center; margin-bottom: 20px;
            display: flex; justify-content: center; gap: 16px;
        }
        .print-btn {
            background-color: var(--primary-color); color: white; border: none;
            padding: 12px 24px; border-radius: 8px; font-size: 1rem;
            font-weight: 600; cursor: pointer; display: inline-flex;
            align-items: center; gap: 10px; transition: all 0.2s ease;
            box-shadow: var(--shadow-md);
        }
        .print-btn:hover {
            background-color: #1d4ed8; box-shadow: var(--shadow-lg);
            transform: translateY(-2px);
        }
        .print-btn svg, .print-btn i { width: 20px; height: 20px; }
    
        .docs-btn {
            background-color: #22c55e;
        }
        .docs-btn:hover {
            background-color: #16a34a;
        }
        .paste-btn {
            background-color: var(--warning-color);
        }
        .paste-btn:hover {
            background-color: #ea580c;
        }
        .contradiction-btn {
             background-color: var(--info-color);
        }
        .contradiction-btn:hover {
            background-color: #7c3aed;
        }

        .validation-message {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px 16px;
            border-radius: 8px;
            margin-top: 12px;
            font-weight: 500;
        }
        .validation-message:first-child { margin-top: 0; }
        .validation-message .icon { width: 24px; height: 24px; flex-shrink: 0; }
        .validation-error { background-color: #fef2f2; border: 1px solid #fecaca; color: #b91c1c; }
        .validation-warning { background-color: #fffbeb; border: 1px solid #fde68a; color: #b45309; }
        .validation-success { background-color: #f0fdf4; border: 1px solid #bbf7d0; color: #15803d; }
        #cadastralNumbersList {
            list-style-type: none; padding-left: 0;
            display: flex; flex-wrap: wrap; gap: 8px;
        }
        #cadastralNumbersList li {
            padding: 4px 10px; border-radius: 6px; font-family: 'Courier New', monospace;
            border: 1px solid;
        }
        .doc-check-list { list-style: none; padding: 0; margin-top: 12px; }
        .doc-check-list li { display: flex; align-items: center; gap: 8px; padding: 4px 0; font-weight: 500; }
        .doc-check-list .fa-check-circle { color: var(--success-color); }
        .doc-check-list .fa-times-circle { color: var(--error-color); }

        .contradiction-table {
            width: 100%;
            border-collapse: separate;
            border-spacing: 0;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            overflow: hidden;
            box-shadow: var(--shadow-sm);
        }
        .contradiction-table th, .contradiction-table td {
            padding: 12px;
            text-align: left;
            border-bottom: 1px solid var(--border-color);
        }
        .contradiction-table th {
            background-color: var(--info-color);
            color: white;
            font-weight: 600;
        }
        .contradiction-table td {
            font-size: 0.9rem;
            vertical-align: top;
        }
        .contradiction-table tbody tr:last-child td { border-bottom: none; }
        .contradiction-table tbody tr:nth-child(even) { background-color: #f8fafc; }
        .contradiction-table td:nth-child(1) { font-weight: bold; color: var(--text-primary); }
        .contradiction-table td:nth-child(3), .contradiction-table td:nth-child(5) {
            font-family: 'Courier New', monospace;
            background-color: #f1f5f9;
            border-radius: 4px;
            padding: 8px;
            word-break: break-word;
        }
        .contradiction-table .source-label {
            font-size: 0.8rem;
            color: var(--text-secondary);
            font-weight: 600;
            display: block;
            margin-bottom: 4px;
        }

        .modal-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background-color: rgba(30, 41, 59, 0.6);
            justify-content: center; align-items: center;
            z-index: 1000; padding: 20px;
            display: none;
        }

        .ai-modal-content {
            background-color: white; padding: 24px; border-radius: 16px;
            box-shadow: var(--shadow-lg);
            width: 90%; height: 85%; max-width: 900px;
            display: flex; flex-direction: column; position: relative;
        }
        .ai-modal-header {
            display: flex; justify-content: space-between; align-items: center;
            padding-bottom: 12px; border-bottom: 1px solid var(--border-color); margin-bottom: 16px;
        }
        .ai-modal-header h2 {
            font-size: 1.5rem; color: var(--text-primary); width: 100%; text-align: center;
            padding-left: 24px;
        }
        .ai-modal-close-button {
            font-size: 2rem; font-weight: bold; color: var(--text-secondary);
            cursor: pointer; line-height: 1; padding: 0 5px;
            transition: color 0.2s;
        }
        .ai-modal-close-button:hover { color: var(--text-primary); }
        #aiCheckResultDisplay { flex-grow: 1; overflow-y: auto; font-size: 1rem; line-height: 1.6; color: var(--text-primary); }
        .ai-spinner { display: flex; align-items: center; justify-content: center; gap: 16px; color: var(--text-secondary); font-size: 1.1rem; height: 100%; }
        .ai-feedback { white-space: pre-wrap; margin-bottom: 16px; background-color: #f8fafc; padding: 12px; border-radius: 8px; border: 1px solid var(--border-color); }
        .ai-corrected-text { background-color: #f0fdf4; color: #064e3b; padding: 12px; border: 1px solid #bbf7d0; border-radius: 8px; white-space: pre-wrap; font-family: 'Courier New', monospace; }
        .ai-modal-content h4 { font-size: 1.1rem; font-weight: 600; margin-bottom: 10px; color: var(--text-primary); display: flex; align-items: center; justify-content: center; gap: 8px; }
        .ai-modal-content h4 i { font-size: 1.2em; background: linear-gradient(135deg, #2563eb, #0ea5e9); -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text; text-fill-color: transparent; }
        .ai-copy-button { margin-top: 16px; background-color: var(--success-color); color: white; border: none; padding: 10px 20px; border-radius: 8px; font-size: 1rem; font-weight: 500; cursor: pointer; display: inline-flex; align-items: center; gap: 8px; transition: background-color 0.2s ease; }
        .ai-copy-button:hover { background-color: #059669; }
        .ai-copy-button:disabled { background-color: var(--text-secondary); cursor: not-allowed; }
        .ai-copy-button i { font-size: 1rem; }
        .ai-result-error { color: var(--error-color); font-weight: 500; }
        .ai-result-success { color: var(--success-color); font-weight: 500; display: flex; align-items: center; gap: 8px; font-size: 1.1rem; }
        .ai-modal-controls { display: flex; align-items: center; gap: 10px; position: absolute; top: 16px; right: 16px; }
        .ai-modal-minimize-button { font-size: 1.1rem; font-weight: bold; color: var(--text-secondary); cursor: pointer; line-height: 1; padding: 5px; transition: color 0.2s, transform 0.2s; }
        .ai-modal-minimize-button:hover { color: var(--text-primary); transform: scale(1.1); }
        .ai-modal-overlay.minimized { background: none; pointer-events: none; align-items: flex-end; justify-content: flex-end; }
        .ai-modal-overlay.minimized .ai-modal-content { height: auto; width: 350px; min-height: 0; box-shadow: var(--shadow-lg); cursor: pointer; pointer-events: auto; transition: all 0.3s ease-in-out; }
        .ai-modal-overlay.minimized #aiCheckResultDisplay { display: none; }
        .ai-modal-overlay.minimized .ai-modal-minimize-button i::before { content: "\f2d0"; }

        .docs-modal-content {
            background-color: white; padding: 24px; border-radius: 16px;
            box-shadow: var(--shadow-lg);
            width: 90%; max-width: 600px;
            display: flex; flex-direction: column;
        }
        .docs-modal-header {
            display: flex; justify-content: space-between; align-items: center;
            padding-bottom: 12px; border-bottom: 1px solid var(--border-color); margin-bottom: 16px;
        }
        .docs-modal-header h2 { font-size: 1.5rem; color: var(--text-primary); }
        #docsListTextarea {
            width: 100%; min-height: 200px; flex-grow: 1;
            padding: 12px; border-radius: 8px; border: 1px solid var(--border-color);
            font-family: 'Courier New', monospace; font-size: 1rem; line-height: 1.5;
            resize: vertical;
        }
        .docs-modal-footer { margin-top: 16px; display: flex; justify-content: flex-end; gap: 12px; }
        .docs-modal-btn {
            padding: 10px 20px; font-size: 1rem; font-weight: 500;
            border-radius: 8px; border: none; cursor: pointer;
            transition: all 0.2s ease;
        }
        #saveDocsListBtn { background-color: var(--primary-color); color: white; }
        #saveDocsListBtn:hover { background-color: #1d4ed8; }
        .docs-modal-close-button { background-color: var(--secondary-color); color: var(--text-primary); border: 1px solid var(--border-color); }
        .docs-modal-close-button:hover { background-color: var(--border-color); }

        @media (max-width: 1024px) { #resultsContainer { grid-template-columns: 1fr; } }
        @media (max-width: 768px) {
            .container { margin: 0; border-radius: 0; }
            .content { padding: 16px; }
            .info-grid { grid-template-columns: 1fr; }
            .data-table, .contradiction-table { font-size: 0.8rem; }
            .data-table th, .data-table td, .contradiction-table th, .contradiction-table td { padding: 8px 12px; }
            .ai-modal-content { width: 100%; height: 90%; }
        }

        @media print {
            body, .container { padding: 0; margin: 0; box-shadow: none; border: none; background: white; color: black; }
            .file-upload-section, .status-container, #printButtonContainer, .header-button, .validation-section, .ai-modal-overlay, .docs-modal-overlay { display: none !important; }
            #resultsContainer { display: block; gap: 0; }
            #mainColumn, #sidebarColumn { display: block; width: 100%; }
            .section { box-shadow: none; border: 1px solid #ccc; border-radius: 0; page-break-inside: avoid; margin-bottom: 20px; }
            .section-header { background: #f0f0f0 !important; }
            .data-table th, .contradiction-table th { background: #e5e5e5 !important; color: black !important; }
            .info-card, .conclusion-text { background: #f9f9f9 !important; }
            * { -webkit-print-color-adjust: exact !important; print-color-adjust: exact !important; }
        }
    </style>
</head>
<body>
    <div class="container">
        <main class="content">
            <div class="file-upload-section" id="dropSection">
                <div class="file-upload-area" id="dropArea">
                    <div class="upload-icon"><img src="img/mpch.png" alt="Загрузить файл"></div>
                    <div class="upload-text">Выберите XML или ZIP файл (МП, ТП, Акт) или вставьте (Ctrl+V)</div>
                    <div class="upload-subtext" id="fileNameDisplay"></div>
                </div>
                <input type="file" id="fileInput" accept=".xml,.zip">
            </div>

       <div id="printButtonContainer" class="hidden">
    <button id="printButton" class="print-btn">
        <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor">
            <path stroke-linecap="round" stroke-linejoin="round" d="M6.72 13.829c-.24.03-.48.062-.72.096m.72-.096a42.415 42.415 0 0110.56 0m-10.56 0L6 18.25M3.75 6.75h16.5M3.75 12h16.5m-16.5 5.25h16.5M17.25 4.5l-1.5-1.5-1.5 1.5M6.75 4.5l1.5-1.5 1.5 1.5m12.75 1.5-1.5-1.5-1.5 1.5M6.75 21l1.5 1.5 1.5-1.5m12.75 1.5l-1.5 1.5-1.5-1.5M12 6.75v10.5" />
        </svg>
        <span>Печать</span>
    </button>
    <button id="docsButton" class="print-btn docs-btn">
        <i class="fas fa-file-alt"></i>
        <span>Документы</span>
    </button>
  
    <button id="pasteButton" class="print-btn paste-btn">
        <i class="fas fa-paste"></i>
        <span>Вставить</span>
    </button>
</div>

            <div class="status-container" id="statusContainer">
                <div class="loader hidden" id="loader"></div>
                <div id="messageArea">
                    <div class="status-text" id="statusText"></div>
                </div>
            </div>

            <div id="resultsContainer" class="hidden">
                <div id="mainColumn"></div>
                <div id="sidebarColumn"></div>
            </div>
        </main>
    </div>

<div id="aiCheckModal" class="ai-modal-overlay modal-overlay">
    <div class="ai-modal-content">
        <div class="ai-modal-header">
            <h2>Анализ заключения</h2>
            <div class="ai-modal-controls">
                <span class="ai-modal-minimize-button" id="aiModalMinimizeBtn"><i class="fas fa-window-minimize"></i></span>
                <span class="ai-modal-close-button" id="aiModalCloseBtn">×</span>
            </div>
        </div>
        <div id="aiCheckResultDisplay"></div>
    </div>
</div>

<div id="docsModal" class="docs-modal-overlay modal-overlay">
    <div class="docs-modal-content">
        <div class="docs-modal-header">
            <h2>Обязательные документы</h2>
            <span class="ai-modal-close-button docs-modal-close-button">×</span>
        </div>
        <p style="color: var(--text-secondary); margin-bottom: 12px;">Введите названия документов для проверки наличия (каждое с новой строки)</p>
        <textarea id="docsListTextarea" placeholder="Например:&#10;Акт&#10;Постановление&#10;Схема"></textarea>
        <div class="docs-modal-footer">
            <button class="docs-modal-btn docs-modal-close-button">Отмена</button>
            <button class="docs-modal-btn" id="saveDocsListBtn">Сохранить</button>
        </div>
    </div>
</div>

<script>
const MAPRUAPP_PROXY_BASE_URL = "https://mapruapp.ru";
const PROXY_MODE = 1;
const DOCS_LIST_KEY = 'requiredDocsList';

let lastXmlDoc = null;
let lastXmlText = null;

document.addEventListener('DOMContentLoaded', () => {
    const landCategories = { '003001000000': 'Земли сельскохозяйственного назначения', '003002000000': 'Земли населенных пунктов', '003003000000': 'Земли промышленности, энергетики, транспорта и иного специального назначения', '003004000000': 'Земли особо охраняемых территорий и объектов', '003005000000': 'Земли лесного фонда', '003006000000': 'Земли водного фонда', '003007000000': 'Земли запаса', '003008000000': 'Категория не установлена' };
    const accuracyStandards = { '003002000000': 0.10, '003001000000': 2.50, '003003000000': 0.50, '003004000000': 2.50, '003005000000': 5.00, '003006000000': 5.00, '003007000000': 5.00, '003008000000': 2.50 };
    const planTypes = { '1': 'Выдел', '2': 'Раздел', '3': 'Раздел с измененным земельным участком', '4': 'Перераспределение', '5': 'Образование из земель', '6': 'Объединение', '7': 'Перераспределение с землями' };
    const keyParameterTypes = { '01': 'Протяженность, м', '02': 'Площадь, кв. м', '03': 'Объем, куб. м', '04': 'Высота, м', '05': 'Глубина, м', '06': 'Глубина залегания, м' };
       const geopointMethods = {
        '692001000000': 'Геодезический метод',
        '692002000000': 'Фотограмметрический метод',
        '692003000000': 'Картометрический метод',
        '692004000000': 'Иное описание',
        '692005000000': 'Метод спутниковых геодезических измерений (определений)',
        '692006000000': 'Аналитический метод'
    };
    const sectionIcons = {
        generalInfo: `<svg xmlns="http://www.w3.org/2000/svg" class="section-icon" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" /></svg>`,
        participants: `<svg xmlns="http://www.w3.org/2000/svg" class="section-icon" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M17 20h5v-2a3 3 0 00-5.356-1.857M17 20H7m10 0v-2c0-.656-.126-1.283-.356-1.857M7 20H2v-2a3 3 0 015.356-1.857M7 20v-2c0-.656.126-1.283.356-1.857m0 0a5.002 5.002 0 019.288 0M15 7a3 3 0 11-6 0 3 3 0 016 0zm6 3a2 2 0 11-4 0 2 2 0 014 0zM7 10a2 2 0 11-4 0 2 2 0 014 0z" /></svg>`,
        inputData: `<svg xmlns="http://www.w3.org/2000/svg" class="section-icon" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M19 11H5m14 0a2 2 0 012 2v6a2 2 0 01-2 2H5a2 2 0 01-2-2v-6a2 2 0 012-2m14 0V9a2 2 0 00-2-2M5 11V9a2 2 0 012-2m0 0V5a2 2 0 012-2h6a2 2 0 012 2v2M7 7h10" /></svg>`,
        newParcel: `<svg xmlns="http://www.w3.org/2000/svg" class="section-icon" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M9 20l-5.447-2.724A1 1 0 013 16.382V5.618a1 1 0 011.447-.894L9 7m0 13l6-3m-6 3V7m6 10l4.553 2.276A1 1 0 0021 18.382V7.618a1 1 0 00-.553-.894L15 4m0 13V4m0 0L9 7" /></svg>`,
        relatedParcel: `<svg xmlns="http://www.w3.org/2000/svg" class="section-icon" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z" /></svg>`,
        conclusion: `<svg xmlns="http://www.w3.org/2000/svg" class="section-icon" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z" /></svg>`,
        graphics: `<svg xmlns="http://www.w3.org/2000/svg" class="section-icon" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l-1.586-1.586a2 2 0 00-2.828 0L6 14m6-6l.01.01" /><rect x="3" y="3" width="18" height="18" rx="2" ry="2" /></svg>`,
        appendix: `<svg xmlns="http://www.w3.org/2000/svg" class="section-icon" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M15.172 7l-6.586 6.586a2 2 0 102.828 2.828l6.414-6.586a4 4 0 00-5.656-5.656l-6.415 6.585a6 6 0 108.486 8.486L20.5 13" /></svg>`,
        copyXY: `<svg xmlns="http://www.w3.org/2000/svg" class="section-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path><text x="12" y="16.5" font-family="sans-serif" font-size="6" fill="currentColor" text-anchor="middle" font-weight="bold">XY</text></svg>`,
        validation: `<svg xmlns="http://www.w3.org/2000/svg" class="section-icon" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M9 12.75L11.25 15 15 9.75m-3-7.036A11.959 11.959 0 013.598 6 11.99 11.99 0 003 9.749c0 5.592 3.824 10.29 9 11.622 5.176-1.332 9-6.03 9-11.622 0-1.31-.21-2.571-.598-3.751h-.152c-3.196 0-6.1-1.248-8.25-3.286zm0 13.036h.008v.008h-.008v-.008z" /></svg>`,
        contradiction: `<i class="fas fa-balance-scale-right section-icon" style="color: var(--info-color);"></i>`,
        errorIcon: `<svg xmlns="http://www.w3.org/2000/svg" class="icon" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M12 9v3.75m-9.303 3.376c-.866 1.5.217 3.374 1.948 3.374h14.71c1.73 0 2.813-1.874 1.948-3.374L13.949 3.378c-.866-1.5-3.032-1.5-3.898 0L2.697 16.126zM12 15.75h.007v.008H12v-.008z" /></svg>`,
        warningIcon: `<svg xmlns="http://www.w3.org/2000/svg" class="icon" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M12 9v3.75m9-.75a9 9 0 11-18 0 9 9 0 0118 0zm-9 3.75h.008v.008H12v-.008z" /></svg>`,
        successIcon: `<svg xmlns="http://www.w3.org/2000/svg" class="icon" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M9 12.75L11.25 15 15 9.75M21 12a9 9 0 11-18 0 9 9 0 0118 0z" /></svg>`
    };

    const fileInput = document.getElementById('fileInput');
    const loader = document.getElementById('loader');
    const dropArea = document.getElementById('dropArea');
    const dropSection = document.getElementById('dropSection');
    const fileNameDisplay = document.getElementById('fileNameDisplay');
    const statusContainer = document.getElementById('statusContainer');
    const messageArea = document.getElementById('messageArea');
    const resultsContainer = document.getElementById('resultsContainer');
    const mainColumn = document.getElementById('mainColumn');
    const sidebarColumn = document.getElementById('sidebarColumn');
    const printButtonContainer = document.getElementById('printButtonContainer');
    const printButton = document.getElementById('printButton');
    const docsButton = document.getElementById('docsButton');
    const pasteButton = document.getElementById('pasteButton');
    const aiCheckModal = document.getElementById('aiCheckModal');
    const aiModalCloseBtn = document.getElementById('aiModalCloseBtn');
    const aiModalMinimizeBtn = document.getElementById('aiModalMinimizeBtn');
    const aiCheckResultDisplay = document.getElementById('aiCheckResultDisplay');
    const docsModal = document.getElementById('docsModal');
    const docsModalCloseButtons = document.querySelectorAll('.docs-modal-close-button');
    const saveDocsListBtn = document.getElementById('saveDocsListBtn');
    const docsListTextarea = document.getElementById('docsListTextarea');

    const E = (el, sel) => el.querySelector(sel);
    const All = (el, sel) => el.querySelectorAll(sel);
    const T = (el, sel) => el?.querySelector(sel)?.textContent.trim() || '—';
    const A = (el, attr) => el?.getAttribute(attr) || '—';

const getFullAddress = (addrEl) => {
        if (!addrEl) return '—';

        // Вспомогательная функция для получения части адреса (Район, Город, Нас.пункт, Улица)
        // Она проверяет и текст внутри тега, и атрибут Name
        const getAddrPart = (tagName) => {
            const el = addrEl.querySelector(tagName);
            if (!el) return '';
            
            // Получаем тип (например, "г", "ул", "м.р-н")
            const type = el.getAttribute('Type') || '';
            
            // Получаем название. Сначала пробуем текст внутри тега, если пусто — берем атрибут Name
            let val = el.textContent.trim();
            if (!val) val = el.getAttribute('Name') || '';
            
            if (!val) return '';
            return `${type} ${val}`.trim();
        };

        return [
            T(addrEl, 'RussianFederation'), 
            T(addrEl, 'Region') !== '—' ? `Респ. ${T(addrEl, 'Region')}` : '',
            
            // Используем новую функцию для структурных элементов
            getAddrPart('District'),       // Район
            getAddrPart('City'),           // Город
            getAddrPart('UrbanDistrict'),  // Городской район
            getAddrPart('SovietVillage'),  // Сельсовет
            getAddrPart('Locality'),       // Населенный пункт
            getAddrPart('Street'),         // Улица
            
            // Для Дома (Level1) и Квартиры (Apartment) значения обычно в атрибуте Value, а не Name
            E(addrEl, 'Level1') ? `${A(E(addrEl, 'Level1'), 'Type') !== '—' ? A(E(addrEl, 'Level1'), 'Type') : ''} ${A(E(addrEl, 'Level1'), 'Value') !== '—' ? A(E(addrEl, 'Level1'), 'Value') : ''}` : '',
            E(addrEl, 'Apartment') ? `${A(E(addrEl, 'Apartment'), 'Type') !== '—' ? A(E(addrEl, 'Apartment'), 'Type') : ''} ${A(E(addrEl, 'Apartment'), 'Value') !== '—' ? A(E(addrEl, 'Apartment'), 'Value') : ''}` : '',
            
            // Неформализованное описание
            T(addrEl, 'Other')
        ].filter(p => p && p.trim() && p !== '—' && !p.includes('—')).join(', ');
    };

    function clearResults() {
        resultsContainer.classList.add('hidden');
        printButtonContainer.classList.add('hidden');
        mainColumn.innerHTML = '';
        sidebarColumn.innerHTML = '';
        lastXmlDoc = null;
        lastXmlText = null;
    }
    function showStatus(message, isLoading = false) {
        clearResults();
        messageArea.innerHTML = `<div class="status-text">${message}</div>`;
        statusContainer.classList.remove('hidden');
        loader.classList.toggle('hidden', !isLoading);
    }
    function showError(message) {
        clearResults();
        loader.classList.add('hidden');
        statusContainer.classList.remove('hidden');
        messageArea.innerHTML = `<div class="error-message">${message}</div>`;
        console.error(message);
    }
    function escapeHtml(unsafe) {
        if (typeof unsafe !== 'string') return '';
        return unsafe.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#039;");
    }

    function setupEventListeners() {
        dropArea.addEventListener('click', () => fileInput.click());
        fileInput.addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (file) handleFile(file);
        });
        ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(e => {
            document.body.addEventListener(e, (evt) => { evt.preventDefault(); evt.stopPropagation(); }, false);
            dropSection.addEventListener(e, (evt) => { evt.preventDefault(); evt.stopPropagation(); }, false);
        });
        ['dragenter', 'dragover'].forEach(e => {
            dropSection.addEventListener(e, () => dropSection.classList.add('dragover'), false);
        });
        ['dragleave', 'drop'].forEach(e => {
            dropSection.addEventListener(e, () => dropSection.classList.remove('dragover'), false);
        });
        dropSection.addEventListener('drop', (e) => {
            const file = e.dataTransfer.files[0];
            if (file) handleFile(file);
        }, false);
        document.addEventListener('paste', handlePaste);
        pasteButton.addEventListener('click', async () => {
            try {
                const text = await navigator.clipboard.readText();
                if (text) processPastedXml(text); else showError('Буфер обмена пуст.');
            } catch (err) {
                console.error('Ошибка чтения из буфера обмена:', err);
                showError('Не удалось прочитать данные из буфера обмена. Проверьте разрешения в браузере.');
            }
        });
        printButton.addEventListener('click', () => window.print());
        docsButton.addEventListener('click', openDocsModal);
        docsModalCloseButtons.forEach(btn => btn.addEventListener('click', closeDocsModal));
        docsModal.addEventListener('click', (e) => { if (e.target === docsModal) closeDocsModal(); });
        saveDocsListBtn.addEventListener('click', () => {
            const list = docsListTextarea.value.trim();
            localStorage.setItem(DOCS_LIST_KEY, list);
            closeDocsModal();
            if (lastXmlDoc && lastXmlText) {
                const validationSection = document.querySelector('.validation-section .section-content');
                if (validationSection) {
                    validationSection.innerHTML = runValidation(lastXmlDoc, lastXmlText);
                }
            }
        });
        aiModalCloseBtn.addEventListener('click', closeAiModal);
        aiCheckModal.addEventListener('click', (event) => { if (event.target === aiCheckModal) closeAiModal(); });
        aiModalMinimizeBtn.addEventListener('click', () => aiCheckModal.classList.toggle('minimized'));

   document.body.addEventListener('click', function(event) {
            const copyCoordsBtn = event.target.closest('.copy-coords-btn');
            const aiCheckBtn = event.target.closest('.ai-check-btn');
            const contradictionCheckBtn = event.target.closest('#contradictionCheckBtn');
            const aiCopyBtn = event.target.closest('#aiCopyBtn');

            if (copyCoordsBtn) {
                event.preventDefault();
                const sectionContainer = copyCoordsBtn.closest('.section');
                
                // Ищем все таблицы в разделе (для всех контуров)
                const coordTables = sectionContainer?.querySelectorAll('.coord-table tbody');
                
                if (!coordTables || coordTables.length === 0) { 
                    alert('Ошибка: таблицы координат не найдены!'); 
                    return; 
                }

                let coordsToCopy = '';
                
                coordTables.forEach(tbody => {
                    const rows = tbody.querySelectorAll('tr');
                    let pointsAddedInThisContour = false; // Флаг: были ли добавлены точки из этого контура

                    rows.forEach(row => { 
                        const cells = row.querySelectorAll('td'); 
                        if (cells.length >= 3) { 
                            const val1 = cells[1].textContent.trim(); 
                            const val2 = cells[2].textContent.trim(); 
                            
                            // Проверка: это должны быть числа (X, Y), а не составные строки с запятыми
                            if (val1 && val2 && val1 !== '—' && !val1.includes(',')) {
                                coordsToCopy += `${val1}\t${val2}\n`; 
                                pointsAddedInThisContour = true;
                            }
                        } 
                    });

                    // ИЗМЕНЕНИЕ: Если в этом контуре были точки, добавляем пустую строку после него
                    if (pointsAddedInThisContour) {
                        coordsToCopy += '\n';
                    }
                });

                // Убираем лишние пробелы/переносы в самом конце всей строки
                coordsToCopy = coordsToCopy.trim();
                
                if (!coordsToCopy) { 
                    alert('Нет координат для копирования.'); 
                    return; 
                }
                
                if (navigator.clipboard) { 
                    navigator.clipboard.writeText(coordsToCopy).then(() => { 
                        // Визуальный эффект на кнопке
                        const originalHtml = copyCoordsBtn.innerHTML;
                        copyCoordsBtn.innerHTML = `${sectionIcons.successIcon} Скопировано`;
                        
                        // Открываем схему
                        setTimeout(() => {
                             copyCoordsBtn.innerHTML = originalHtml;
                             window.open('схема.html', '_blank'); 
                        }, 500);
                    }).catch(err => { 
                        console.error('Ошибка при копировании в буфер обмена:', err); 
                        alert('Не удалось скопировать координаты.'); 
                    }); 
                } else { 
                    alert('Ваш браузер не поддерживает безопасное копирование в буфер обмена.'); 
                }
            }

            // ... остальные обработчики (без изменений) ...
            if (aiCheckBtn) {
                const conclusionText = aiCheckBtn.dataset.conclusionText;
                checkConclusionWithAI(conclusionText);
            }
            if (contradictionCheckBtn) {
                performContradictionAnalysis();
            }
            if (aiCopyBtn) {
                const correctedTextElement = aiCheckResultDisplay.querySelector('.ai-corrected-text'); if (!correctedTextElement) return;
                const textToCopy = correctedTextElement.textContent;
                navigator.clipboard.writeText(textToCopy).then(() => { const buttonSpan = aiCopyBtn.querySelector('span'); const originalText = buttonSpan.textContent; buttonSpan.textContent = 'Скопировано'; aiCopyBtn.disabled = true; setTimeout(() => { buttonSpan.textContent = originalText; aiCopyBtn.disabled = false; }, 2000); }).catch(err => { alert('Не удалось скопировать текст.'); console.error('Copy error:', err); });
            }
        });
    }

    function cleanXmlString(xmlString) {
        const lastBracketIndex = xmlString.lastIndexOf('>');
        if (lastBracketIndex === -1) return xmlString;
        return xmlString.substring(0, lastBracketIndex + 1).trim();
    }
    
    function processPastedXml(pastedText) {
        const xmlStartIndex = pastedText.indexOf('<');
        if (xmlStartIndex === -1) { showError('В буфере обмена не найден текст, похожий на XML.'); return; }
        let textToParse = pastedText.substring(xmlStartIndex);
        let cleanedText = textToParse.replace(/<\?\s+xml/i, '<?xml');
        cleanedText = cleanedText.replace(/^[+-]\s*/gm, '');
        cleanedText = cleanXmlString(cleanedText);
        fileNameDisplay.innerHTML = `<strong>Вставлено из буфера обмена</strong>`;
        showStatus('Обработка XML из буфера обмена...', true);
        setTimeout(() => parseXmlContent(cleanedText), 50);
    }

    function handlePaste(event) {
        const pastedText = (event.clipboardData || window.clipboardData).getData('text');
        if (!pastedText || pastedText.trim() === '') return;
        if (pastedText.trim().startsWith('<')) {
           event.preventDefault();
           processPastedXml(pastedText);
        }
    }

    function openDocsModal() {
        docsListTextarea.value = localStorage.getItem(DOCS_LIST_KEY) || '';
        docsModal.style.display = 'flex';
    }
    function closeDocsModal() {
        docsModal.style.display = 'none';
    }

    function handleFile(file) {
        fileNameDisplay.innerHTML = `Выбран файл: <strong>${file.name}</strong>`;
        showStatus('Обработка файла...', true);
        const fileExtension = file.name.split('.').pop().toLowerCase();
        if (fileExtension === 'zip') handleZipFile(file);
        else if (fileExtension === 'xml') handleXmlFile(file);
        else showError('Неподдерживаемый тип файла. Пожалуйста, выберите .xml или .zip файл.');
    }
    function handleXmlFile(file) {
        const reader = new FileReader();
        reader.onload = e => parseXmlContent(e.target.result);
        reader.onerror = e => showError('Не удалось прочитать файл.', e);
        reader.readAsText(file, 'UTF-8');
    }
    function handleZipFile(file) {
        JSZip.loadAsync(file).then(zip => {
            const xmlFileName = Object.keys(zip.files).find(name => !zip.files[name].dir && name.toLowerCase().endsWith('.xml'));
            if (!xmlFileName) throw new Error('XML файл не найден в архиве.');
            return zip.files[xmlFileName].async('string');
        }).then(parseXmlContent).catch(err => showError('Ошибка при обработке ZIP архива: ' + err.message));
    }
    function parseXmlContent(xmlString) {
        try {
            const parser = new DOMParser();
            const xmlDoc = parser.parseFromString(xmlString, "application/xml");
            if (E(xmlDoc, "parsererror")) throw new Error("Не удалось разобрать XML. Файл поврежден или имеет неверный формат.");
            lastXmlDoc = xmlDoc;
            lastXmlText = xmlString;
            displayData(xmlDoc, xmlString);
        } catch (err) {
            showError(err.message);
        } finally {
            loader.classList.add('hidden');
        }
    }
    
    function displayData(xmlDoc, xmlText) {
        const isSurveyPlan = !!E(xmlDoc, 'NewParcel, SpecifyParcel, FormParcels');
        const isInspectionAct = xmlDoc.documentElement.tagName === 'InspectionAct';
        const isTechPlan = xmlDoc.documentElement.tagName === 'TP';

        if (isTechPlan) {
            displayTechPlanData(xmlDoc, xmlText);
        } else if (isSurveyPlan) {
            displaySurveyPlanData(xmlDoc, xmlText);
        } else if (isInspectionAct) {
            displayInspectionActData(xmlDoc, xmlText);
        } else {
            showError('Файл успешно прочитан, но его тип не определен (не является Межевым планом, Техническим планом или Актом обследования).');
        }
    }
    
    function displayTechPlanData(xmlDoc, xmlText) {
        let mainHtml = '';
        let sidebarHtml = '';
        let sectionsFound = 0;
        const construction = E(xmlDoc, 'NewConstruction, ExistConstruction');

        if(construction) {
            sectionsFound++;
            const keyParam = E(construction, 'KeyParameter');
            const keyParamType = keyParam ? A(keyParam, 'Type') : '';
            const keyParamValue = keyParam ? A(keyParam, 'Value') : '—';

            let mainInfoHtml = `<div class="info-grid">
                <div class="info-card" style="grid-column: 1 / -1;"><div class="info-label">Наименование объекта</div><div class="info-value">${T(construction, 'Name')}</div></div>
                <div class="info-card"><div class="info-label">Назначение</div><div class="info-value">${T(construction, 'AssignationName')}</div></div>
                <div class="info-card"><div class="info-label">Год постройки</div><div class="info-value">${A(E(construction, 'ExploitationChar'), 'YearBuilt')}</div></div>
                <div class="info-card"><div class="info-label">${keyParameterTypes[keyParamType] || 'Ключевой параметр'}</div><div class="info-value">${keyParamValue}</div></div>
            </div>`;
            
            mainInfoHtml += `<div class="subsection"><div class="subsection-title">Кадастровые кварталы</div><ul id="cadastralNumbersList">${Array.from(All(construction, 'CadastralBlock')).map(n => `<li style="border-color:#1d4ed8; color:#1d4ed8;">${n.textContent}</li>`).join('')}</ul></div>`;
            mainInfoHtml += `<div class="subsection"><div class="subsection-title">Земельные участки</div><ul id="cadastralNumbersList">${Array.from(All(construction, 'ParentCadastralNumbers CadastralNumber')).map(n => `<li style="border-color:#15803d; color:#15803d;">${n.textContent}</li>`).join('')}</ul></div>`;
            mainInfoHtml += `<div class="subsection"><div class="subsection-title">Адрес</div><div class="address-display">${getFullAddress(E(construction, 'Address'))}</div></div>`;
            mainHtml += `<div class="section"><div class="section-header">${sectionIcons.newParcel}<h3 class="section-title">Сведения об объекте капитального строительства</h3></div><div class="section-content" style="padding:16px">${mainInfoHtml}</div></div>`;
        }

        const contractor = E(xmlDoc, 'GeneralCadastralWorks > Contractor');
        const client = E(xmlDoc, 'GeneralCadastralWorks > Clients > Client');
        if (contractor || client) {
            sectionsFound++;
            let participantsHtml = `<div class="section"><div class="section-header">${sectionIcons.participants}<h3 class="section-title">Участники работ</h3></div><div class="section-content" style="padding:16px">`;
            if (contractor) {
                const cadWork = E(contractor, 'AgreementCadWork');
                participantsHtml += `<div class="subsection" style="margin-top:0;"><div class="subsection-title">Кадастровый инженер</div><div class="info-grid"><div class="info-card"><div class="info-label">ФИО</div><div class="info-value">${T(contractor, 'FamilyName')} ${T(contractor, 'FirstName')} ${T(contractor, 'Patronymic')}</div></div><div class="info-card"><div class="info-label">№ в реестре</div><div class="info-value">${T(contractor, 'CadastralEngineerRegistryNumber')} (от ${T(contractor, 'DateEntering')})</div></div><div class="info-card"><div class="info-label">СНИЛС</div><div class="info-value">${T(contractor, 'SNILS')}</div></div><div class="info-card" style="grid-column: 1 / -1;"><div class="info-label">Контакты</div><div class="info-value">Тел: ${T(contractor, 'Telephone')}, Email: ${T(contractor, 'Email')}</div></div><div class="info-card" style="grid-column: 1 / -1;"><div class="info-label">СРО</div><div class="info-value">${T(contractor, 'SelfRegulatoryOrganization')}</div></div><div class="info-card" style="grid-column: 1 / -1;"><div class="info-label">Договор</div><div class="info-value">${T(cadWork, 'Name')} №${T(cadWork, 'NumberAgreement')} от ${T(cadWork, 'DateAgreement')}</div></div></div></div>`;
            }
            if (client) {
                participantsHtml += `<div class="subsection"><div class="subsection-title">Заказчик</div><div class="info-grid">`;
                if(E(client, 'Organization')) { participantsHtml += `<div class="info-card" style="grid-column: 1 / -1;"><div class="info-label">Наименование</div><div class="info-value">${T(client, 'Organization > Name')}</div></div><div class="info-card"><div class="info-label">ИНН</div><div class="info-value">${T(client, 'Organization > INN')}</div></div><div class="info-card"><div class="info-label">ОГРН</div><div class="info-value">${T(client, 'Organization > OGRN')}</div></div>`; }
                else if (E(client, 'Person')) { participantsHtml += `<div class="info-card"><div class="info-label">ФИО</div><div class="info-value">${T(client, 'FamilyName')} ${T(client, 'FirstName')} ${T(client, 'Patronymic')}</div></div><div class="info-card"><div class="info-label">СНИЛС</div><div class="info-value">${T(client, 'SNILS')}</div></div>`; }
                participantsHtml += `</div></div>`;
            }
            participantsHtml += `</div></div>`;
            sidebarHtml += participantsHtml;
        }

        const inputData = E(xmlDoc, 'InputData');
        if (inputData) {
            sectionsFound++;
            let inputDataHtml = `<div class="section"><div class="section-header">${sectionIcons.inputData}<h3 class="section-title">Исходные данные</h3></div><div class="section-content" style="padding:16px">`;
            const documents = All(inputData, 'Documents > Document');
            if (documents.length > 0) { inputDataHtml += `<div class="subsection" style="margin-top:0;"><div class="subsection-title">Документы</div><table class="data-table"><thead><tr><th class="left-align">Наименование</th><th class="no-wrap">№</th><th class="no-wrap">Дата</th></tr></thead><tbody>${Array.from(documents).map(doc => `<tr><td class="left-align">${T(doc, 'Name')}</td><td class="no-wrap">${T(doc, 'Number')}</td><td class="no-wrap">${T(doc, 'Date')}</td></tr>`).join('')}</tbody></table></div>`; }
            const geoBases = All(inputData, 'GeodesicBases > GeodesicBase');
            if (geoBases.length > 0) { inputDataHtml += `<div class="subsection"><div class="subsection-title">Геодезическая основа</div><table class="data-table"><thead><tr><th class="left-align">Пункт</th><th>Класс</th><th>X</th><th>Y</th></tr></thead><tbody>${Array.from(geoBases).map(base => `<tr><td class="left-align">${T(base, 'PName')} (${T(base, 'PKind')})</td><td>${T(base, 'PKlass')}</td><td>${T(base, 'OrdX')}</td><td>${T(base, 'OrdY')}</td></tr>`).join('')}</tbody></table></div>`; }
            const meanSurvey = E(inputData, 'MeansSurvey > MeanSurvey');
            if (meanSurvey) { inputDataHtml += `<div class="subsection"><div class="subsection-title">Средства измерений</div><div class="info-grid"><div class="info-card" style="grid-column: 1 / -1;"><div class="info-label">Прибор</div><div class="info-value">${T(meanSurvey, 'Name')}</div></div><div class="info-card"><div class="info-label">Номер</div><div class="info-value">${T(meanSurvey, 'Number')}</div></div><div class="info-card"><div class="info-label">Поверка</div><div class="info-value">${T(meanSurvey, 'CertificateVerification')}</div></div></div></div>`; }
            inputDataHtml += `</div></div>`;
            sidebarHtml += inputDataHtml;
        }
        
        const contours = All(construction, 'Contours > NewContour, Contours > Contour');
        if (contours.length > 0) {
            sectionsFound++;
            let contoursHtml = '';
            contours.forEach(contour => {
                const ordinates = Array.from(All(contour, 'Ordinate')).map(ord => ({ x: A(ord, 'X'), y: A(ord, 'Y')}));
                let isAreal = false;
                if (ordinates.length > 1) {
                    const first = ordinates[0];
                    const last = ordinates[ordinates.length - 1];
                    if (first.x === last.x && first.y === last.y) {
                        isAreal = true;
                    }
                }
                const contourType = isAreal ? 'Площадной' : 'Линейный';
                
                let tableContent = '';
                All(contour, 'Ordinate').forEach(ord => {
                     // Логика получения метода координат для Техплана
                     const methodCode = A(ord, 'GeopointOpred');
                     const methodName = geopointMethods[methodCode] || (methodCode !== '—' ? methodCode : '—');

                     tableContent += `<tr>
                        <td>${A(ord, 'NumGeopoint') || A(ord, 'SuNmb')}</td>
                        <td>${A(ord, 'X')}</td>
                        <td>${A(ord, 'Y')}</td>
                        <td class="left-align" style="font-size: 0.85em;">${methodName}</td>
                        <td>${A(ord, 'DeltaGeopoint')}</td>
                     </tr>`;
                });
                
                // Добавлен заголовок "Метод определения" в thead
                contoursHtml += `
                    <div class="subsection">
                        <div class="section-header" style="background: var(--secondary-color); padding: 12px 16px;">
                            <h4 class="subsection-title" style="margin:0; border:0; padding:0;">Контур ${A(contour, 'Definition')} (${contourType})</h4>
                            <button class="header-button copy-coords-btn" title="Скопировать координаты и открыть схему">${sectionIcons.copyXY}</button>
                        </div>
                        <table class="data-table coord-table">
                            <thead><tr><th>Точка</th><th>X</th><th>Y</th><th class="left-align">Метод определения</th><th>Погрешность, м</th></tr></thead>
                            <tbody>${tableContent}</tbody>
                        </table>
                    </div>
                `;
            });
            mainHtml += `<div class="section"><div class="section-header">${sectionIcons.graphics}<h3 class="section-title">Координаты</h3></div><div class="section-content" style="padding:16px">${contoursHtml}</div></div>`;
        }

        const conclusion = E(xmlDoc, 'Conclusion');
        if (conclusion && conclusion.textContent.trim()) {
            sectionsFound++;
            mainHtml += `<div class="section"><div class="section-header">${sectionIcons.conclusion}<h3 class="section-title">Заключение кадастрового инженера</h3><button class="header-button ai-check-btn" data-conclusion-text="${escapeHtml(conclusion.textContent.trim())}" title="Проверить заключение с помощью ИИ"><i class="fas fa-atom"></i></button></div><div class="section-content" style="padding:16px"><div class="conclusion-text">${conclusion.textContent.trim()}</div></div></div>`;
        }

        const graphicFiles = [
            { title: 'Схема геодезических построений', file: A(E(xmlDoc, 'SchemeGeodesicPlotting'), 'Name') }, 
            { title: 'Схема расположения ОКС', file: A(E(xmlDoc, 'SchemeDisposition'), 'Name') }, 
            { title: 'Чертеж контура ОКС', file: A(E(xmlDoc, 'DiagramContour'), 'Name') }
        ].filter(f => f.file && f.file !== '—');
        if(graphicFiles.length > 0) {
            sectionsFound++;
            mainHtml += `<div class="section"><div class="section-header">${sectionIcons.graphics}<h3 class="section-title">Графические разделы</h3></div><div class="section-content" style="padding:16px"><table class="data-table"><thead><tr><th class="left-align">Наименование раздела</th><th class="left-align">Имя файла</th></tr></thead><tbody>${graphicFiles.map(f => `<tr><td class="left-align">${f.title}</td><td class="left-align"><span class="file-name">${f.file}</span></td></tr>`).join('')}</tbody></table></div></div>`;
        }
        
        const appendixFiles = All(xmlDoc, 'Appendix > AppliedFiles');
        if(appendixFiles.length > 0) {
            sectionsFound++;
            mainHtml += `<div class="section"><div class="section-header">${sectionIcons.appendix}<h3 class="section-title">Приложения</h3></div><div class="section-content" style="padding:16px"><table class="data-table"><thead><tr><th>№</th><th class="left-align">Наименование</th><th class="left-align">Имя файла</th></tr></thead><tbody>${Array.from(appendixFiles).map(f => `<tr><td>${T(f, 'NumberAppendix')}</td><td class="left-align">${T(f, 'NameAppendix')}</td><td class="left-align"><span class="file-name">${A(E(f, 'AppliedFile'), 'Name')}</span></td></tr>`).join('')}</tbody></table></div></div>`;
        }

        if (sectionsFound > 0) {
            mainColumn.innerHTML = mainHtml;
            sidebarColumn.innerHTML = sidebarHtml;
            resultsContainer.classList.remove('hidden');
            statusContainer.classList.add('hidden');
            printButtonContainer.classList.remove('hidden');
            messageArea.innerHTML = '';
        } else {
            showError('Файл Технического плана прочитан, но в нем не найдено данных для отображения.');
        }
    }

    function displayInspectionActData(xmlDoc, xmlText) {
        let mainHtml = '';
        let sidebarHtml = '';
        let sectionsFound = 0;

        const objectTypes = { '002001002000': 'Здание', '002001003000': 'Сооружение', '002001004000': 'Помещение', '002001005000': 'Машино-место', '002001006000': 'Объект незавершенного строительства', '002001008000': 'Единый недвижимый комплекс', '002001009000': 'Предприятие как имущественный комплекс' };
        const rightTypes = { '1': 'Права зарегистрированы', '2': 'Права не зарегистрированы' };

        const contractor = E(xmlDoc, 'Contractor');
        const client = E(xmlDoc, 'Client');
        if (contractor || client) {
            sectionsFound++;
            let participantsHtml = `<div class="section"><div class="section-header">${sectionIcons.participants}<h3 class="section-title">Участники работ</h3></div><div class="section-content" style="padding:16px">`;
            if (contractor) {
                const cadWork = E(contractor, 'AgreementCadWork');
                participantsHtml += `<div class="subsection" style="margin-top:0;"><div class="subsection-title">Кадастровый инженер</div><div class="info-grid"><div class="info-card"><div class="info-label">ФИО</div><div class="info-value">${T(contractor, 'FamilyName')} ${T(contractor, 'FirstName')} ${T(contractor, 'Patronymic')}</div></div><div class="info-card"><div class="info-label">№ в реестре</div><div class="info-value">${T(contractor, 'CadastralEngineerRegistryNumber')} (от ${T(contractor, 'DateEntering')})</div></div><div class="info-card"><div class="info-label">СНИЛС</div><div class="info-value">${T(contractor, 'SNILS')}</div></div><div class="info-card" style="grid-column: 1 / -1;"><div class="info-label">Контакты</div><div class="info-value">Тел: ${T(contractor, 'Telephone')}, Email: ${T(contractor, 'Email')}</div></div><div class="info-card" style="grid-column: 1 / -1;"><div class="info-label">СРО</div><div class="info-value">${T(contractor, 'SelfRegulatoryOrganization')}</div></div><div class="info-card" style="grid-column: 1 / -1;"><div class="info-label">Договор</div><div class="info-value">${T(cadWork, 'Name')} №${T(cadWork, 'NumberAgreement')} от ${T(cadWork, 'DateAgreement')}</div></div></div></div>`;
            }
            if (client) {
                participantsHtml += `<div class="subsection"><div class="subsection-title">Заказчик</div><div class="info-grid">`;
                if(E(client, 'Governance')) {
                     participantsHtml += `<div class="info-card" style="grid-column: 1 / -1;"><div class="info-label">Наименование</div><div class="info-value">${T(client, 'Governance > Name')}</div></div>`;
                } else if (E(client, 'Person')) {
                     participantsHtml += `<div class="info-card"><div class="info-label">ФИО</div><div class="info-value">${T(client, 'FamilyName')} ${T(client, 'FirstName')} ${T(client, 'Patronymic')}</div></div><div class="info-card"><div class="info-label">СНИЛС</div><div class="info-value">${T(client, 'SNILS')}</div></div>`;
                }
                participantsHtml += `</div></div>`;
            }
            participantsHtml += `</div></div>`;
            sidebarHtml += participantsHtml;
        }

        const objectEl = E(xmlDoc, 'Object');
        if (objectEl) {
            sectionsFound++;
            const objectType = T(objectEl, 'ObjectType');
            const rightType = T(objectEl, 'RightRegisteredUnregistered');
            let objectInfoContent = `
                <div class="info-card"><div class="info-label">Кадастровый номер</div><div class="info-value"><code>${T(objectEl, 'CadastralNumber')}</code></div></div>
                <div class="info-card"><div class="info-label">Тип объекта</div><div class="info-value">${objectTypes[objectType] || `Неизвестный тип (${objectType})`}</div></div>
                <div class="info-card"><div class="info-label">Регистрация прав</div><div class="info-value">${rightTypes[rightType] || 'Не указано'}</div></div>
                <div class="info-card"><div class="info-label">Дата прекращения существования</div><div class="info-value">${T(objectEl, 'DateTermination')}</div></div>
            `;
            mainHtml += `<div class="section"><div class="section-header">${sectionIcons.newParcel}<h3 class="section-title">Сведения об объекте обследования</h3></div><div class="section-content" style="padding:16px"><div class="info-grid">${objectInfoContent}</div></div></div>`;
        }

        const documents = All(xmlDoc, 'Documents > Document');
        if (documents.length > 0) {
            sectionsFound++;
            let docsHtml = `<div class="section"><div class="section-header">${sectionIcons.inputData}<h3 class="section-title">Документы-основания</h3></div><div class="section-content" style="padding:16px">`;
            docsHtml += `<table class="data-table"><thead><tr><th class="left-align">Наименование</th><th class="no-wrap">№</th><th class="no-wrap">Дата</th><th class="left-align">Имя файла</th></tr></thead><tbody>`;
            documents.forEach(doc => {
                const appliedFileEl = E(doc, 'AppliedFile');
                const fileName = appliedFileEl ? A(appliedFileEl, 'Name') : '—';
                docsHtml += `<tr><td class="left-align">${T(doc, 'Name')}</td><td class="no-wrap">${T(doc, 'Number')}</td><td class="no-wrap">${T(doc, 'Date')}</td><td class="left-align"><span class="file-name">${fileName}</span></td></tr>`;
            });
            docsHtml += `</tbody></table></div></div>`;
            mainHtml += docsHtml;
        }

        const conclusion = E(xmlDoc, 'Conclusion');
        if (conclusion && conclusion.textContent.trim()) {
            sectionsFound++;
            mainHtml += `<div class="section"><div class="section-header">${sectionIcons.conclusion}<h3 class="section-title">Заключение кадастрового инженера</h3><button class="header-button ai-check-btn" data-conclusion-text="${escapeHtml(conclusion.textContent.trim())}" title="Проверить заключение с помощью ИИ"><i class="fas fa-atom"></i></button></div><div class="section-content" style="padding:16px"><div class="conclusion-text">${conclusion.textContent.trim()}</div></div></div>`;
        }

        if (sectionsFound > 0) {
            mainColumn.innerHTML = mainHtml;
            sidebarColumn.innerHTML = sidebarHtml;
            resultsContainer.classList.remove('hidden');
            statusContainer.classList.add('hidden');
            printButtonContainer.classList.remove('hidden');
            messageArea.innerHTML = '';
        } else {
            showError('Файл Акта обследования прочитан, но в нем не найдено данных для отображения.');
        }
    }
    
function createSpatialDataHtml(entitySpatial) {
        if (!entitySpatial) return '';
        let spatialHtml = '';
        let tableContent = '';
        const ordinates = All(entitySpatial, 'SpatialElement Ordinate, SpelementUnit > Ordinate, SpelementUnit > NewOrdinate');
        ordinates.forEach(ord => {
            const pointName = `${A(ord, 'PointPref') || ''}${A(ord, 'NumGeopoint')}`;
            // Получаем код метода и расшифровку
            const methodCode = A(ord, 'GeopointOpred');
            const methodName = geopointMethods[methodCode] || (methodCode !== '—' ? methodCode : '—');

            if (pointName && pointName !== '—') {
                tableContent += `<tr>
                    <td>${pointName}</td>
                    <td>${A(ord, 'X')}</td>
                    <td>${A(ord, 'Y')}</td>
                    <td class="left-align" style="font-size: 0.85em;">${methodName}</td> <!-- Новая ячейка -->
                    <td class="left-align">${A(ord, 'GeopointZacrep')}</td>
                    <td>${A(ord, 'DeltaGeopoint')}</td>
                </tr>`;
            }
        });
        if (tableContent) {
             // Обновлен заголовок таблицы (добавлен столбец Метод определения)
             spatialHtml += `<div class="subsection" id="main-coord-section"><div class="subsection-title">Координаты характерных точек</div><table class="data-table coord-table"><thead><tr><th>Обозначение</th><th>X</th><th>Y</th><th class="left-align">Метод определения</th><th class="left-align">Метод закрепления</th><th>Погрешность, м</th></tr></thead><tbody>${tableContent}</tbody></table></div>`;
        }
        const borders = All(entitySpatial, 'Borders > Border');
        if (borders.length > 0) {
             spatialHtml += `<div class="subsection"><div class="subsection-title">Длины линий</div><table class="data-table lengths-table"><thead><tr><th>Участок</th><th>Длина, м</th></tr></thead><tbody>${Array.from(borders).map(b => `<tr><td>${A(b,'Point1')}-${A(b,'Point2')}</td><td>${T(b,'Edge > Length') || T(b, 'Length')}</td></tr>`).join('')}</tbody></table></div>`;
        }
        return spatialHtml;
    }

function displaySurveyPlanData(xmlDoc, xmlText) {
        let mainHtml = '';
        let sidebarHtml = '';
        let sectionsFound = 0;
        const formParcels = E(xmlDoc, 'FormParcels');
        const reasonText = T(xmlDoc, 'GeneralCadastralWorks > Reason');
        if (formParcels || reasonText !== '—') {
            sectionsFound++;
            let generalInfoContent = '';
            if (formParcels) {
                const method = A(formParcels, 'Method');
                generalInfoContent += `<div class="info-card"><div class="info-label">Способ образования ЗУ</div><div class="info-value">${planTypes[method] || `Неизвестный (${method})`}</div></div>`;
            }
            if (reasonText !== '—') {
                 generalInfoContent += `<div class="info-card" style="grid-column: 1 / -1;"><div class="info-label">Основание для работ</div><div class="info-value">${reasonText}</div></div>`;
            }
            sidebarHtml += `<div class="section"><div class="section-header">${sectionIcons.generalInfo}<h3 class="section-title">Общая информация</h3></div><div class="section-content" style="padding:16px"><div class="info-grid">${generalInfoContent}</div></div></div>`;
        }
        const contractor = E(xmlDoc, 'Contractor');
        const client = E(xmlDoc, 'Client');
        if (contractor || client) {
            sectionsFound++;
            let participantsHtml = `<div class="section"><div class="section-header">${sectionIcons.participants}<h3 class="section-title">Участники работ</h3></div><div class="section-content" style="padding:16px">`;
            if (contractor) {
                const cadWork = E(contractor, 'AgreementCadWork');
                participantsHtml += `<div class="subsection" style="margin-top:0;"><div class="subsection-title">Кадастровый инженер</div><div class="info-grid"><div class="info-card"><div class="info-label">ФИО</div><div class="info-value">${T(contractor, 'FamilyName')} ${T(contractor, 'FirstName')} ${T(contractor, 'Patronymic')}</div></div><div class="info-card"><div class="info-label">№ в реестре</div><div class="info-value">${T(contractor, 'CadastralEngineerRegistryNumber')} (от ${T(contractor, 'DateEntering')})</div></div><div class="info-card"><div class="info-label">СНИЛС</div><div class="info-value">${T(contractor, 'SNILS')}</div></div><div class="info-card" style="grid-column: 1 / -1;"><div class="info-label">Контакты</div><div class="info-value">Тел: ${T(contractor, 'Telephone')}, Email: ${T(contractor, 'Email')}</div></div><div class="info-card" style="grid-column: 1 / -1;"><div class="info-label">СРО</div><div class="info-value">${T(contractor, 'SelfRegulatoryOrganization')}</div></div><div class="info-card" style="grid-column: 1 / -1;"><div class="info-label">Договор</div><div class="info-value">${T(cadWork, 'Name')} №${T(cadWork, 'NumberAgreement')} от ${T(cadWork, 'DateAgreement')}</div></div></div></div>`;
            }
            if (client) {
                const org = E(client, 'Organization');
                const gov = E(client, 'Governance');
                const clientOrgEntity = org || gov;
                
                participantsHtml += `<div class="subsection"><div class="subsection-title">Заказчик</div><div class="info-grid">`;
                if(clientOrgEntity) { 
                    participantsHtml += `<div class="info-card" style="grid-column: 1 / -1;"><div class="info-label">Наименование</div><div class="info-value">${T(clientOrgEntity, 'Name')}</div></div><div class="info-card"><div class="info-label">ИНН</div><div class="info-value">${T(clientOrgEntity, 'INN')}</div></div><div class="info-card"><div class="info-label">ОГРН</div><div class="info-value">${T(clientOrgEntity, 'OGRN')}</div></div>`; 
                } else { 
                    participantsHtml += `<div class="info-card"><div class="info-label">ФИО</div><div class="info-value">${T(client, 'FamilyName')} ${T(client, 'FirstName')} ${T(client, 'Patronymic')}</div></div><div class="info-card"><div class="info-label">СНИЛС</div><div class="info-value">${T(client, 'SNILS')}</div></div>`; 
                }
                participantsHtml += `</div></div>`;
            }
            participantsHtml += `</div></div>`;
            sidebarHtml += participantsHtml;
        }
        const inputData = E(xmlDoc, 'InputData');
        if (inputData) {
            sectionsFound++;
            let inputDataHtml = `<div class="section"><div class="section-header">${sectionIcons.inputData}<h3 class="section-title">Исходные данные</h3></div><div class="section-content" style="padding:16px">`;
            const documents = All(inputData, 'Documents > Document');
            if (documents.length > 0) { inputDataHtml += `<div class="subsection" style="margin-top:0;"><div class="subsection-title">Документы</div><table class="data-table"><thead><tr><th class="left-align">Наименование</th><th class="no-wrap">№</th><th class="no-wrap">Дата</th></tr></thead><tbody>${Array.from(documents).map(doc => `<tr><td class="left-align">${T(doc, 'Name')}</td><td class="no-wrap">${T(doc, 'Number')}</td><td class="no-wrap">${T(doc, 'Date')}</td></tr>`).join('')}</tbody></table></div>`; }
            const geoBases = All(inputData, 'GeodesicBases > GeodesicBase');
            if (geoBases.length > 0) { inputDataHtml += `<div class="subsection"><div class="subsection-title">Геодезическая основа</div><table class="data-table"><thead><tr><th class="left-align">Пункт</th><th>Класс</th><th>X</th><th>Y</th></tr></thead><tbody>${Array.from(geoBases).map(base => `<tr><td class="left-align">${T(base, 'PName')} (${T(base, 'PKind')})</td><td>${T(base, 'PKlass')}</td><td>${T(base, 'OrdX')}</td><td>${T(base, 'OrdY')}</td></tr>`).join('')}</tbody></table></div>`; }
            const meanSurvey = E(inputData, 'MeansSurvey > MeanSurvey');
            if (meanSurvey) { inputDataHtml += `<div class="subsection"><div class="subsection-title">Средства измерений</div><div class="info-grid"><div class="info-card" style="grid-column: 1 / -1;"><div class="info-label">Прибор</div><div class="info-value">${T(meanSurvey, 'Name')}</div></div><div class="info-card"><div class="info-label">Номер</div><div class="info-value">${T(meanSurvey, 'Number')}</div></div><div class="info-card"><div class="info-label">Поверка</div><div class="info-value">${T(meanSurvey, 'CertificateVerification')}</div></div></div></div>`; }
            inputDataHtml += `</div></div>`;
            sidebarHtml += inputDataHtml;
        }
        const newParcels = All(xmlDoc, 'NewParcel');
        for (const newParcel of newParcels) {
            sectionsFound++;
            const categoryCode = A(E(newParcel, 'Category'), 'Category');
            const categoryName = landCategories[categoryCode] || 'Категория не определена';
            
            // Безопасное получение площади
            let areaVal = '—';
            let areaInacc = '—';
            const directAreaNode = Array.from(newParcel.children).find(el => el.tagName === 'Area');
            if (directAreaNode) {
                areaVal = T(directAreaNode, 'Area');
                areaInacc = T(directAreaNode, 'Inaccuracy');
            } else {
                 areaVal = T(newParcel, 'Area > Area');
                 areaInacc = T(newParcel, 'Area > Inaccuracy');
            }

            let sectionContent = `<div class="info-grid"><div class="info-card"><div class="info-label">Кадастровый квартал</div><div class="info-value">${T(newParcel, 'CadastralBlock')}</div></div><div class="info-card"><div class="info-label">Площадь, кв.м.</div><div class="info-value">${areaVal} (±${areaInacc})</div></div><div class="info-card"><div class="info-label">Категория земель</div><div class="info-value">${categoryName} <code>${categoryCode}</code></div></div><div class="info-card"><div class="info-label">Вид разрешенного использования</div><div class="info-value">${A(E(newParcel, 'PermittedUseEstablished, PermittedUsesLand > PermittedUseEstablished'), 'ByDocument')}</div></div><div class="info-card"><div class="info-label">Обеспечение доступа</div><div class="info-value">${T(newParcel, 'ProvidingPassCadastralNumbers > Other, ProvidingPassCadastralNumbers > CadastralNumber')}</div></div></div>`;

            // ----- НОВОЕ: Обработка сведений о перераспределении -----
            const prevRedist = E(newParcel, 'PrevWithRedistributed');
            if (prevRedist) {
                let redistRows = '';
                All(prevRedist, 'PrevWithRedistribute').forEach(item => {
                    // Источник может быть КН участка или Квартал (земли)
                    const kn = T(item, 'CadastralNumber');
                    const block = T(item, 'CadastralBlock');
                    const sourceName = kn !== '—' ? kn : (block !== '—' ? `Квартал ${block}` : '—');
                    
                    // Площадь источника
                    // Ищем Area внутри текущего PrevWithRedistribute, но не внутри IncludedPart
                    let sourceArea = '—';
                    for(let child of item.children) {
                        if (child.tagName === 'Area') {
                            sourceArea = T(child, 'Area');
                            break;
                        }
                    }

                    const partName = T(item, 'IncludedPart > Definition');
                    const partArea = T(item, 'IncludedPart > Area > Area');

                    redistRows += `<tr>
                        <td class="left-align">${sourceName}</td>
                        <td>${sourceArea}</td>
                        <td>${partName}</td>
                        <td>${partArea}</td>
                    </tr>`;
                });

                if (redistRows) {
                    sectionContent += `
                    <div class="subsection">
                        <div class="subsection-title">Сведения о перераспределении</div>
                        <table class="data-table">
                            <thead>
                                <tr>
                                    <th class="left-align">Источник образования (ЗУ или Квартал)</th>
                                    <th>Площадь источника, м²</th>
                                    <th>Обозначение части</th>
                                    <th>Площадь части, м²</th>
                                </tr>
                            </thead>
                            <tbody>${redistRows}</tbody>
                        </table>
                    </div>`;
                }
            }
            // --------------------------------------------------------

            if (T(newParcel, 'Area > Formula') !== '—') {
                 sectionContent += `<div class="subsection"><div class="subsection-title">Формула погрешности</div><div class="conclusion-text">${T(newParcel, 'Area > Formula')}</div></div>`;
            }
            if (All(newParcel, 'ObjectsRealty CadastralNumber').length > 0) {
                 sectionContent += `<div class="subsection"><div class="subsection-title">ОКС на участке</div><div class="info-grid">${Array.from(All(newParcel, 'ObjectsRealty CadastralNumber')).map(node => `<div class="info-card"><div class="info-value">${node.textContent}</div></div>`).join('')}</div></div>`;
            }
            if (E(newParcel, 'Address')) {
                 sectionContent += `<div class="subsection"><div class="subsection-title">Адрес</div><div class="address-display">${getFullAddress(E(newParcel, 'Address'))}</div><div class="info-grid" style="margin-top: 16px;"><div class="info-card"><div class="info-label">FIAS</div><div class="info-value">${T(E(newParcel, 'Address'), 'FIAS')}</div></div></div></div>`;
            }

            const entitySpatial = E(newParcel, 'EntitySpatial');
            if (entitySpatial) { sectionContent += createSpatialDataHtml(entitySpatial); }
            const hasCoords = !!entitySpatial;
            mainHtml += `<div class="section"><div class="section-header">${sectionIcons.newParcel}<h3 class="section-title">Сведения об образуемом участке (${A(newParcel, 'Definition')})</h3>${hasCoords ? `<button class="header-button copy-coords-btn" title="Скопировать координаты и открыть схему">${sectionIcons.copyXY}</button>` : ''}</div><div class="section-content" style="padding:16px">${sectionContent}</div></div>`;
        }
        const specifiedParcels = All(xmlDoc, 'SpecifyParcel > ExistParcel');
        for (const parcel of specifiedParcels) {
            sectionsFound++;
            const cadNum = A(parcel, 'CadastralNumber');
            const categoryCode = A(E(parcel, 'Category'), 'Category');
            const categoryName = landCategories[categoryCode] || 'Категория не определена';
            let sectionContent = `<div class="info-grid"><div class="info-card"><div class="info-label">Кадастровый номер</div><div class="info-value"><code>${cadNum}</code></div></div><div class="info-card"><div class="info-label">Кадастровый квартал</div><div class="info-value">${T(parcel, 'CadastralBlock')}</div></div>${categoryCode && categoryCode !== '—' ? `<div class="info-card"><div class="info-label">Категория земель</div><div class="info-value">${categoryName} <code>${categoryCode}</code></div></div>` : ''}<div class="info-card"><div class="info-label">Уточненная площадь, кв.м.</div><div class="info-value">${T(parcel, 'Area > Area')} (погрешность ±${T(parcel, 'Area > Inaccuracy')})</div></div><div class="info-card"><div class="info-label">Площадь по ЕГРН, кв.м.</div><div class="info-value">${T(parcel, 'AreaInGKN')}</div></div><div class="info-card"><div class="info-label">Разница площадей, кв.м.</div><div class="info-value">${T(parcel, 'DeltaArea')}</div></div><div class="info-card" style="grid-column: 1 / -1;"><div class="info-label">Обеспечение доступа</div><div class="info-value">${T(parcel, 'ProvidingPassCadastralNumbers > Other')}</div></div></div>
                ${T(parcel, 'Area > Formula') !== '—' ? `<div class="subsection"><div class="subsection-title">Формула погрешности</div><div class="conclusion-text">${T(parcel, 'Area > Formula')}</div></div>` : ''}`;
            const entitySpatial = E(parcel, 'EntitySpatial');
            if (entitySpatial) { sectionContent += createSpatialDataHtml(entitySpatial); }
            mainHtml += `<div class="section"><div class="section-header">${sectionIcons.newParcel}<h3 class="section-title">Сведения об уточняемом участке</h3><button class="header-button copy-coords-btn" title="Скопировать координаты и открыть схему">${sectionIcons.copyXY}</button></div><div class="section-content" style="padding:16px">${sectionContent}</div></div>`;
        }
        
     const specifyRelatedParcel = E(xmlDoc, 'SpecifyRelatedParcel');
        if(specifyRelatedParcel){
            sectionsFound++;
            const relatedCadNum = A(specifyRelatedParcel, 'CadastralNumber');
            let relatedContentHtml = '';

            const contours = All(specifyRelatedParcel, 'Contours > NewContour, Contours > Contour');
            if (contours.length > 0) {
                 contours.forEach(cnt => {
                      const definition = A(cnt, 'Definition');
                      const entSpatial = E(cnt, 'EntitySpatial');
                      if (entSpatial) {
                           relatedContentHtml += `<div class="subsection"><div class="subsection-title">Контур ${definition}</div>${createSpatialDataHtml(entSpatial)}</div>`;
                      }
                 });
            } else {
                const entSpatial = E(specifyRelatedParcel, 'EntitySpatial');
                if (entSpatial) {
                    relatedContentHtml += createSpatialDataHtml(entSpatial);
                }
            }
            
            if (!relatedContentHtml) {
                 let tableContent = '';
                 All(specifyRelatedParcel, 'ChangeBorder').forEach(ch => {
                    const oldOrd = E(ch, 'OldOrdinate'); const newOrd = E(ch, 'NewOrdinate');
                    tableContent += `<tr><td>${A(oldOrd || newOrd, 'NumGeopoint') || A(newOrd, 'PointPref') + A(newOrd, 'NumGeopoint')}</td><td>${oldOrd ? `${A(oldOrd, 'X')}, ${A(oldOrd, 'Y')}` : '—'}</td><td>${newOrd ? `${A(newOrd, 'X')}, ${A(newOrd, 'Y')}` : '—'}</td><td class="left-align">${newOrd ? `Δ=${A(newOrd, 'DeltaGeopoint')} м, ${A(newOrd, 'GeopointZacrep')}`: 'Точка удалена'}</td></tr>`;
                });
                if (tableContent) {
                     // Добавлен класс coord-table, чтобы скрипт копирования видел эту таблицу
                     relatedContentHtml += `<table class="data-table coord-table"><thead><tr><th>Точка</th><th>Старые коорд. (X, Y)</th><th>Новые коорд. (X, Y)</th><th class="left-align">Примечание</th></tr></thead><tbody>${tableContent}</tbody></table>`;
                }
            }

            if (relatedContentHtml) {
                const randomId = 'rel_' + Math.floor(Math.random() * 10000);
                mainHtml += `
                <div class="section">
                    <div class="section-header">
                        ${sectionIcons.relatedParcel}
                        <h3 class="section-title">Уточнение смежного участка: ${relatedCadNum}</h3>
                        <!-- ДОБАВЛЕНА КНОПКА ДЛЯ КОПИРОВАНИЯ -->
                        <button class="header-button copy-coords-btn" title="Скопировать координаты и открыть схему">${sectionIcons.copyXY}</button>
                    </div>
                    <div class="section-content" style="padding:16px">
                        <div class="info-card" style="margin-bottom: 12px; background: #fff8e1; border-color: #ffe0b2;">
                            <div class="info-value">Координаты смежного земельного участка</div>
                        </div>
                        <button class="print-btn" style="padding: 8px 16px; font-size: 0.9rem;" onclick="document.getElementById('${randomId}').classList.toggle('hidden'); this.textContent = this.textContent.includes('Раскрыть') ? 'Скрыть координаты' : 'Раскрыть список координат';">
                            Раскрыть список координат
                        </button>
                        <div id="${randomId}" class="hidden" style="margin-top: 16px;">
                            ${relatedContentHtml}
                        </div>
                    </div>
                </div>`;
            }
        }
        
        const conclusion = E(xmlDoc, 'Conclusion');
        if (conclusion && conclusion.textContent.trim()) {
            sectionsFound++;
            mainHtml += `<div class="section"><div class="section-header">${sectionIcons.conclusion}<h3 class="section-title">Заключение кадастрового инженера</h3><button class="header-button ai-check-btn" data-conclusion-text="${escapeHtml(conclusion.textContent.trim())}" title="Проверить заключение с помощью ИИ"><i class="fas fa-atom"></i></button></div><div class="section-content" style="padding:16px"><div class="conclusion-text">${conclusion.textContent.trim()}</div></div></div>`;
        }
        const graphicFiles = [{ title: 'Схема геодезических построений', file: A(E(xmlDoc, 'SchemeGeodesicPlotting'), 'Name') }, { title: 'Схема расположения ЗУ', file: A(E(xmlDoc, 'SchemeDisposition'), 'Name') }, { title: 'Чертеж земельного участка', file: A(E(xmlDoc, 'DiagramParcelsSubParcels > AppliedFile'), 'Name') }, { title: 'Акт согласования границ', file: A(E(xmlDoc, 'AgreementDocument > AppliedFile'), 'Name') }].filter(f => f.file !== '—');
        if(graphicFiles.length > 0) {
            sectionsFound++;
            mainHtml += `<div class="section"><div class="section-header">${sectionIcons.graphics}<h3 class="section-title">Графические разделы</h3></div><div class="section-content" style="padding:16px"><table class="data-table"><thead><tr><th class="left-align">Наименование раздела</th><th class="left-align">Имя файла</th></tr></thead><tbody>${graphicFiles.map(f => `<tr><td class="left-align">${f.title}</td><td class="left-align"><span class="file-name">${f.file}</span></td></tr>`).join('')}</tbody></table></div></div>`;
        }
        const appendixFiles = All(xmlDoc, 'Appendix > AppliedFiles');
        if(appendixFiles.length > 0) {
            sectionsFound++;
            mainHtml += `<div class="section"><div class="section-header">${sectionIcons.appendix}<h3 class="section-title">Приложения</h3></div><div class="section-content" style="padding:16px"><table class="data-table"><thead><tr><th>№</th><th class="left-align">Наименование</th><th class="left-align">Имя файла</th></tr></thead><tbody>${Array.from(appendixFiles).map(f => `<tr><td>${T(f, 'NumberAppendix')}</td><td class="left-align">${T(f, 'NameAppendix')}</td><td class="left-align"><span class="file-name">${A(E(f, 'AppliedFile'), 'Name')}</span></td></tr>`).join('')}</tbody></table></div></div>`;
        }
        const validationHtml = runValidation(xmlDoc, xmlText);
        if(validationHtml) {
             mainHtml += `<div class="section validation-section"><div class="section-header">${sectionIcons.validation}<h3 class="section-title">Проверка межевого плана</h3></div><div class="section-content" style="padding:16px">${validationHtml}</div></div>`;
        }
        if (sectionsFound > 0) {
            mainColumn.innerHTML = mainHtml;
            sidebarColumn.innerHTML = sidebarHtml;
            resultsContainer.classList.remove('hidden');
            statusContainer.classList.add('hidden');
            printButtonContainer.classList.remove('hidden');
            messageArea.innerHTML = '';
        } else {
            showError('Файл успешно прочитан, но в нем не найдено известных разделов межевого плана. Возможно, это XML другого типа.');
        }
    }

function runValidation(xmlDoc, xmlText) {
        let messages = [];
        const requiredDocsList = (localStorage.getItem(DOCS_LIST_KEY) || '').trim();
        if (requiredDocsList) {
            const requiredDocs = requiredDocsList.split('\n').map(d => d.trim().toLowerCase()).filter(Boolean);
            const foundDocs = [];
            [A(E(xmlDoc, 'SchemeGeodesicPlotting'), 'Name'), A(E(xmlDoc, 'SchemeDisposition'), 'Name'), A(E(xmlDoc, 'DiagramParcelsSubParcels > AppliedFile'), 'Name'), A(E(xmlDoc, 'AgreementDocument > AppliedFile'), 'Name')].forEach(file => { if (file && file !== '—') foundDocs.push({ type: 'file', text: file }); });
            All(xmlDoc, 'InputData Documents Document').forEach(doc => { const name = T(doc, 'Name'); if (name && name !== '—') foundDocs.push({ type: 'docName', text: name }); });
            All(xmlDoc, 'Appendix > AppliedFiles').forEach(f => { const name = T(f, 'NameAppendix'); const file = A(E(f, 'AppliedFile'), 'Name'); if (name && name !== '—') foundDocs.push({ type: 'docName', text: name }); if (file && file !== '—') foundDocs.push({ type: 'file', text: file }); });
            const searchableDocsText = foundDocs.map(item => item.text.toLowerCase());
            let docCheckHtml = `<div class="subsection"><div class="subsection-title">Проверка обязательных документов</div><ul class="doc-check-list">`;
            requiredDocs.forEach(reqDoc => {
                let foundMatch = null; const matchIndex = searchableDocsText.findIndex(searchableText => searchableText.includes(reqDoc));
                if (matchIndex !== -1) { foundMatch = foundDocs[matchIndex].text; }
                if (foundMatch) { docCheckHtml += `<li><i class="fas fa-check-circle"></i> ${escapeHtml(reqDoc)} - <span style="color:var(--success-color)">Найден</span> <span style="color: var(--text-secondary); font-size: 0.9em;">(${escapeHtml(foundMatch)})</span></li>`; }
                else { docCheckHtml += `<li><i class="fas fa-times-circle"></i> ${escapeHtml(reqDoc)} - <span style="color:var(--error-color)">Не найден</span></li>`; }
            });
            docCheckHtml += `</ul></div>`; messages.push(docCheckHtml);
        }

        const today = new Date(); const currentDateString = `${today.getFullYear()}-${String(today.getMonth() + 1).padStart(2, '0')}-${String(today.getDate()).padStart(2, '0')}`;
        const generalWorksEl = E(xmlDoc, 'GeneralCadastralWorks');
        if (generalWorksEl) { const cadWorkDate = A(generalWorksEl, 'DateCadastral'); if (cadWorkDate && cadWorkDate !== currentDateString) { messages.push(`<div class="validation-message validation-warning">${sectionIcons.warningIcon} <strong>Предупреждение:</strong> Дата кадастровых работ (${cadWorkDate}) не является текущей датой.</div>`); } }
        const allDocuments = All(xmlDoc, 'InputData Documents Document');
        for (const doc of allDocuments) { if (T(doc, 'Name') === 'Сведения о геодезической основе') { const docDate = T(doc, 'Date'); if (docDate && docDate !== currentDateString) { messages.push(`<div class="validation-message validation-warning">${sectionIcons.warningIcon} <strong>Предупреждение:</strong> Дата в документе "Сведения о геодезической основе" (${docDate}) не является текущей датой.</div>`); } break; } }
        
        // Проверка дат геодезической основы
        const geoBasePoints = All(xmlDoc, 'GeodesicBases GeodesicBase ConditionPoint');
        let geoDateMismatch = false;
        for (const point of geoBasePoints) { const pointDate = A(point, 'AsOfDate'); if (pointDate && pointDate !== currentDateString) { geoDateMismatch = true; break; } }
        if (geoDateMismatch) { messages.push(`<div class="validation-message validation-warning">${sectionIcons.warningIcon} <strong>Предупреждение:</strong> Одна или несколько дат состояния пунктов геодезической основы не являются текущей датой.</div>`); }
        
        // === НОВАЯ ЛОГИКА: ПРОВЕРКА МЕТОДА КООРДИНАТ И НАЛИЧИЯ ДАТ ===
        // 1. Определяем, какие методы использованы в документе
        let usedAnalytical = false;
        let usedSatellite = false;
        const allOrdinates = All(xmlDoc, 'Ordinate');
        for (const ord of allOrdinates) {
            const m = A(ord, 'GeopointOpred');
            if (m === '692006000000') usedAnalytical = true;
            if (m === '692005000000') usedSatellite = true;
        }

        // 2. Определяем, есть ли заполненные даты обследования пунктов
        let hasGeoBaseDates = false;
        for (const point of geoBasePoints) { 
            const d = A(point, 'AsOfDate');
            if (d && d !== '—') {
                hasGeoBaseDates = true;
                break;
            } 
        }

        // 3. Условие: Если Спутниковый метод (692005000000), даты ОБЯЗАНЫ быть
        if (usedSatellite && !hasGeoBaseDates) {
             messages.push(`<div class="validation-message validation-error">${sectionIcons.errorIcon} <strong>Ошибка метода:</strong> Использован "Метод спутниковых геодезических измерений", но отсутствуют сведения о дате состояния пунктов геодезической основы (AsOfDate).</div>`);
        }

        // 4. Условие: Если только Аналитический метод (692006000000), дат быть НЕ ДОЛЖНО (предупреждение)
        // Мы проверяем !usedSatellite, чтобы не ругаться в комбинированных случаях (когда часть точек снята спутником, а часть аналитически)
        if (usedAnalytical && !usedSatellite && hasGeoBaseDates) {
             messages.push(`<div class="validation-message validation-warning">${sectionIcons.warningIcon} <strong>Предупреждение:</strong> Использован только "Аналитический метод", но заполнены даты состояния пунктов геодезической основы. При аналитическом методе пункты ГГС обычно не обследуются.</div>`);
        }
        // ==============================================================

        const dateWarnings = []; const foundDates = new Set(); const dateRegex = /(?:\b(\d{2})\.(\d{2})\.(\d{4})\b)|(?:\b(\d{4})-(\d{2})-(\d{2})\b)/g; const minDate = new Date(1990, 0, 1); const currentDate = new Date(); currentDate.setHours(23, 59, 59, 999); let match;
        while ((match = dateRegex.exec(xmlText)) !== null) {
            const fullMatch = match[0]; if (foundDates.has(fullMatch)) continue; foundDates.add(fullMatch);
            let day, month, year, parsedDate;
            if (match[1]) { day = parseInt(match[1], 10); month = parseInt(match[2], 10); year = parseInt(match[3], 10); } else { year = parseInt(match[4], 10); month = parseInt(match[5], 10); day = parseInt(match[6], 10); }
            parsedDate = new Date(year, month - 1, day); if (parsedDate.getFullYear() !== year || parsedDate.getMonth() !== month - 1 || parsedDate.getDate() !== day) continue;
            if (parsedDate < minDate) dateWarnings.push(`"${fullMatch}"`); else if (parsedDate > currentDate) dateWarnings.push(`"${fullMatch}" (будущая дата)`);
        }
        if (dateWarnings.length > 0) { messages.push(`<div class="validation-message validation-warning">${sectionIcons.warningIcon} <strong>Предупреждение о датах:</strong> Найдены даты за пределами допустимого диапазона (01.01.1990 - сегодня): ${dateWarnings.join(', ')}.</div>`); }
        const knRegex = /\d{2}:\d{2}:\d{6,7}:\d+/g; const blockRegex = /\d{2}:\d{2}:\d{6,7}/; let allNumbers = new Set((xmlText.match(knRegex) || [])); All(xmlDoc, 'CadastralBlock').forEach(b => allNumbers.add(b.textContent.trim())); const quarters = new Map();
        allNumbers.forEach(num => { const match = num.match(blockRegex); if (match) { const quarter = match[0]; if (!quarters.has(quarter)) quarters.set(quarter, []); quarters.get(quarter).push(num); } });
        const colors = ['#1d4ed8', '#b91c1c', '#c2410c', '#15803d', '#86198f']; let colorIndex = 0; const quarterColors = new Map(); for (const q of quarters.keys()) { quarterColors.set(q, colors[colorIndex % colors.length]); colorIndex++; }
        if (quarters.size > 1) { messages.push(`<div class="validation-message validation-warning">${sectionIcons.warningIcon} <strong>Предупреждение:</strong> Найдены объекты из разных кадастровых кварталов.</div>`); }
        let numberListHtml = '<ul id="cadastralNumbersList">'; quarters.forEach((numbers, quarter) => { const color = quarterColors.get(quarter); numbers.sort().forEach(num => { numberListHtml += `<li style="border-color:${color}; color:${color};">${num}</li>`; }); }); numberListHtml += '</ul>'; messages.push(`<div class="subsection" style="margin-top:0"><div class="subsection-title">Все кадастровые номера в документе</div>${numberListHtml}</div>`);
        
        const mainParcel = E(xmlDoc, 'NewParcel') || E(xmlDoc, 'ExistParcel');
        if (mainParcel) {
            const categoryCode = A(E(mainParcel, 'Category'), 'Category'); 
            const requiredMt = accuracyStandards[categoryCode]; 

            let area = 0;
            let statedAreaInaccuracy = 0;
            const directAreaNode = Array.from(mainParcel.children).find(el => el.tagName === 'Area');
            if (directAreaNode) {
                area = parseFloat(T(directAreaNode, 'Area'));
                statedAreaInaccuracy = parseFloat(T(directAreaNode, 'Inaccuracy'));
            } else {
                 area = parseFloat(T(mainParcel, 'Area > Area'));
                 statedAreaInaccuracy = parseFloat(T(mainParcel, 'Area > Inaccuracy'));
            }

            const ordinates = Array.from(All(mainParcel, 'EntitySpatial > SpatialElement > SpelementUnit > NewOrdinate, EntitySpatial > SpatialElement > SpelementUnit > Ordinate'));
            
            if (ordinates.length > 0) {
                const accuracies = new Set(); let allFixingsFilled = true;
                ordinates.forEach(ord => { const delta = A(ord, 'DeltaGeopoint'); if(delta && delta !== '—') accuracies.add(parseFloat(delta)); if(A(ord, 'GeopointZacrep') === '—') allFixingsFilled = false; });
                if (!allFixingsFilled) { messages.push(`<div class="validation-message validation-warning">${sectionIcons.warningIcon} <strong>Предупреждение:</strong> Не для всех точек указан метод закрепления на местности.</div>`);}
                if (accuracies.size > 1) { messages.push(`<div class="validation-message validation-warning">${sectionIcons.warningIcon} <strong>Предупреждение:</strong> У точек главного участка разные значения погрешности (${Array.from(accuracies).join(', ')}).</div>`); }
                const actualMt = accuracies.size > 0 ? accuracies.values().next().value : null;
                if (requiredMt && actualMt) { if (actualMt !== requiredMt) { messages.push(`<div class="validation-message validation-error">${sectionIcons.errorIcon} <strong>Ошибка Mt:</strong> Указанная погрешность точек <strong>${actualMt}</strong> не соответствует нормативу <strong>${requiredMt}</strong> для категории "${landCategories[categoryCode]}".</div>`); } else { messages.push(`<div class="validation-message validation-success">${sectionIcons.successIcon} <strong>Проверка Mt:</strong> Погрешность точек <strong>${actualMt}</strong> соответствует нормативу для данной категории земель.</div>`); } } else if (!requiredMt) { messages.push(`<div class="validation-message validation-warning">${sectionIcons.warningIcon} <strong>Проверка Mt:</strong> Не удалось определить норматив погрешности, так как категория земель не указана</div>`); }
                
                if (area && actualMt && statedAreaInaccuracy) { 
                    const calculatedAreaInaccuracy = Math.round(3.5 * actualMt * Math.sqrt(area)); 
                    if (calculatedAreaInaccuracy !== statedAreaInaccuracy) { 
                        messages.push(`<div class="validation-message validation-error">${sectionIcons.errorIcon} <strong>Ошибка ΔP:</strong> Расчетная погрешность площади <strong>(${calculatedAreaInaccuracy} м²)</strong> не совпадает с указанной в XML <strong>(${statedAreaInaccuracy} м²)</strong>.</div>`); 
                    } else { 
                        messages.push(`<div class="validation-message validation-success">${sectionIcons.successIcon} <strong>Проверка ΔP:</strong> Расчетная погрешность площади <strong>(${calculatedAreaInaccuracy} м²)</strong> совпадает с указанной в XML</div>`); 
                    } 
                }
            }
        }
        
        const contradictionHtml = `
            <div class="subsection">
                <div class="subsection-title" style="display:flex; align-items:center; gap: 8px;">
                    ${sectionIcons.contradiction}
                    <span>Проверка данных</span>
                </div>
                <button id="contradictionCheckBtn" class="print-btn contradiction-btn">
                    <i class="fas fa-balance-scale-right"></i>
                    <span>Найти несоответствия</span>
                </button>
                <div id="contradictionAnalysisResult" style="margin-top: 16px;"></div>
            </div>
        `;
        messages.push(contradictionHtml);
        
        return messages.length > 0 ? messages.join('') : '';
    }

    function openAiModal() { aiCheckModal.style.display = 'flex'; }
    function closeAiModal() { aiCheckModal.style.display = 'none'; aiCheckResultDisplay.innerHTML = ''; }

    async function checkConclusionWithAI(conclusionText) {
        if (!conclusionText) { alert("Текст заключения пуст. Проверка невозможна."); return; }
        openAiModal();
        aiCheckResultDisplay.innerHTML = `<div class="ai-spinner"><div class="loader"></div><span>Анализирую текст...</span></div>`;
        const systemPrompt = `Ты — эксперт-помощник кадастрового инженера в России. Твоя задача — проанализировать "Заключение кадастрового инженера" из межевого плана. Проверь текст на: 1. **Полноту:** Упомянуты ли основания для работ (договор, проект), исходные документы, способ образования/уточнения, кадастровые номера? 2. **Ясность и однозначность:** Формулировки должны быть четкими, без двусмысленности. 3. **Корректность терминологии:** Правильно ли используются кадастровые термины. 4. **Логичность:** Обоснованы ли выполненные действия (например, почему площадь изменилась, как обеспечен доступ). 5. **Орфографию и грамматику.** Верни ответ СТРОГО в формате JSON с тремя полями: - "is_correct": boolean (true, если текст идеален и не требует правок, иначе false). - "feedback": string (детальный, но краткий анализ на русском языке, с пунктами по существу дела, можно использовать Markdown для списков). - "corrected_text": string (улучшенная версия заключения. Если правок нет, верни исходный текст). Не добавляй никаких комментариев или объяснений вне JSON.`;
        const userPrompt = `${systemPrompt}\n\nТекст для проверки:\n---\n${conclusionText}`;
        let apiUrl, requestBody; 
        const modelId = "gemini-2.5-flash-lite"; 
        
        if (PROXY_MODE === 1) { 
            apiUrl = `${MAPRUAPP_PROXY_BASE_URL}/ai/api/v1/chat/completions`; 
            requestBody = { model: modelId, messages: [{ role: "user", content: userPrompt }], max_tokens: 8192, response_format: { type: "json_object" } }; 
        } else { 
            aiCheckResultDisplay.innerHTML = `<div class="ai-result-error">Режим прокси не настроен.</div>`; 
            return; 
        }
        try {
            const response = await fetch(apiUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(requestBody) });
            const data = await response.json(); if (!response.ok) { throw new Error(`Ошибка API (${response.status}): ${data?.error?.message || `Статус ${response.status}`}`); }
            let aiResponseText = data.choices?.[0]?.message?.content; if (!aiResponseText) { throw new Error('Не удалось получить ответ от ИИ (пустое поле content).'); }
            let parsedResponse; try { const cleanedText = aiResponseText.trim().replace(/^```json\s*|\s*```$/g, ''); parsedResponse = JSON.parse(cleanedText); } catch (e) { console.error("AI Response (raw):", aiResponseText); throw new Error("Ответ ИИ имеет неверную структуру JSON."); }
            let resultHtml = '';
            if (parsedResponse.is_correct) { resultHtml = `<div class="ai-result-success"><i class="fas fa-check-circle"></i> <strong>Вердикт ИИ:</strong> Заключение составлено хорошо. Замечаний нет.</div>`; }
            else { resultHtml += `<h4><i class="fas fa-lightbulb"></i> Анализ ИИ:</h4><div class="ai-feedback">${escapeHtml(parsedResponse.feedback)}</div>`; if (parsedResponse.corrected_text && parsedResponse.corrected_text !== conclusionText) { resultHtml += `<h4><i class="fas fa-magic-wand-sparkles"></i> Предложенная редакция:</h4><pre class="ai-corrected-text">${escapeHtml(parsedResponse.corrected_text)}</pre><button class="ai-copy-button" id="aiCopyBtn"><i class="fas fa-copy"></i><span>Копировать исправленный текст</span></button>`; } }
            aiCheckResultDisplay.innerHTML = resultHtml;
        } catch (error) { console.error('Ошибка при проверке заключения с ИИ:', error); aiCheckResultDisplay.innerHTML = `<div class="ai-result-error"><strong>Произошла ошибка:</strong> ${error.message}</div>`; }
    }

    function extractDataDigest(xmlDoc) {
        let digestParts = [];
        
        const mainParcel = E(xmlDoc, 'NewParcel, SpecifyParcel > ExistParcel');
        if (mainParcel) {
            const parcelType = mainParcel.tagName === 'NewParcel' ? `ОБРАЗУЕМЫЙ УЧАСТОК (${A(mainParcel, 'Definition') || ''})` : `УТОЧНЯЕМЫЙ УЧАСТОК (${A(mainParcel, 'CadastralNumber') || ''})`;
            let parcelInfo = `[${parcelType}]\n`;
            parcelInfo += `Квартал: ${T(mainParcel, 'CadastralBlock')}\n`;
            parcelInfo += `Площадь: ${T(mainParcel, 'Area > Area')} (±${T(mainParcel, 'Area > Inaccuracy')})\n`;
            parcelInfo += `Адрес: ${getFullAddress(E(mainParcel, 'Address'))}\n`;
            parcelInfo += `Формула погрешности: ${T(mainParcel, 'Area > Formula')}\n`;
            digestParts.push(parcelInfo);

            const oksNodes = All(mainParcel, 'ObjectsRealty CadastralNumber');
            if (oksNodes.length > 0) {
                let oksInfo = '[ОКС НА УЧАСТКЕ]\n';
                oksInfo += `Номера ОКС: ${Array.from(oksNodes).map(node => node.textContent.trim()).join(', ')}\n`;
                digestParts.push(oksInfo);
            }
        }

        const reasonText = T(xmlDoc, 'GeneralCadastralWorks > Reason');
        if (reasonText !== '—') {
            digestParts.push(`[ОСНОВАНИЕ ДЛЯ РАБОТ]\nТекст: ${reasonText}\n`);
        }
        
        const conclusionText = T(xmlDoc, 'Conclusion');
        if (conclusionText !== '—') {
            digestParts.push(`[ЗАКЛЮЧЕНИЕ ИНЖЕНЕРА]\nТекст: ${conclusionText}\n`);
        }
        
        const inputDocs = All(xmlDoc, 'InputData Documents Document');
        if (inputDocs.length > 0) {
            let docsInfo = '[ИСХОДНЫЕ ДОКУМЕНТЫ]\n';
            inputDocs.forEach(doc => {
                docsInfo += `- Наименование: ${T(doc, 'Name')}, Номер: ${T(doc, 'Number')}, Дата: ${T(doc, 'Date')}\n`;
            });
            digestParts.push(docsInfo);
        }

        const appendixDocs = All(xmlDoc, 'Appendix > AppliedFiles');
        if (appendixDocs.length > 0) {
            let appendixInfo = '[ПРИЛОЖЕНИЯ]\n';
            appendixDocs.forEach(doc => {
                 const name = T(doc, 'NameAppendix');
                 const fileName = A(E(doc, 'AppliedFile'), 'Name');
                 appendixInfo += `- Наименование: ${name}, Имя файла: ${fileName}\n`;
            });
            digestParts.push(appendixInfo);
        }

        return digestParts.join('\n');
    }

    async function performContradictionAnalysis() {
        const resultContainer = document.getElementById('contradictionAnalysisResult');
        if (!lastXmlDoc) {
            resultContainer.innerHTML = `<div class="error-message">Сначала загрузите XML файл.</div>`;
            return;
        }
        
        resultContainer.innerHTML = `<div style="display:flex; align-items:center; gap: 12px; justify-content:center; padding: 10px; color: var(--text-secondary);"><div class="loader"></div><span>Анализ документа на наличие противоречий...</span></div>`;

        const dataDigest = extractDataDigest(lastXmlDoc);
        if (!dataDigest) {
            resultContainer.innerHTML = `<div class="validation-message validation-warning">${sectionIcons.warningIcon} Недостаточно данных в XML для проведения анализа.</div>`;
            return;
        }

        const systemPrompt = `Ты — внимательный и педантичный эксперт-аудитор кадастровых данных. Твоя задача — найти значимые смысловые расхождения в ключевых параметрах документа.

Противоречие — это когда адрес указывает на разные места, площади не совпадают, номера документов или кадастровые кварталы разные.

Что считать НЕЗНАЧИТЕЛЬНЫМ (игнорировать):
- Разный формат дат ('16.07.2025' и '2025-07-16').
- Разный формат площади, если числовое значение совпадает ('29' и '29 кв.м.').
- Небольшие различия в тексте, не меняющие смысл ('Респ. 16' и 'Республика Татарстан, Нурлатский...').

Твой отчет должен содержать ТОЛЬКО реальные ошибки. Если данные полностью совпадают по смыслу, не включай их в ответ. Если противоречий нет, верни пустой массив [].

Твой ответ должен быть СТРОГО в формате JSON-массива с ключами на АНГЛИЙСКОМ языке ("parameter", "value1", "source1", "value2", "source2", "comment").
`;
        
        const userPrompt = `${systemPrompt}\n\n[ДАННЫЕ ДЛЯ АНАЛИЗА]\n${dataDigest}`;

        let apiUrl, requestBody; 
        const modelId = "gemini-2.5-flash-lite";

        if (PROXY_MODE === 1) {
            apiUrl = `${MAPRUAPP_PROXY_BASE_URL}/ai/api/v1/chat/completions`;
            requestBody = { model: modelId, messages: [{ role: "user", content: userPrompt }], max_tokens: 8192, response_format: { type: "json_object" } };
        } else {
            resultContainer.innerHTML = `<div class="error-message">Режим прокси не настроен.</div>`;
            return;
        }

        try {
            const response = await fetch(apiUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(requestBody) });
            const data = await response.json(); if (!response.ok) { throw new Error(`Ошибка API (${response.status}): ${data?.error?.message || `Статус ${response.status}`}`); }
            let aiResponseText = data.choices?.[0]?.message?.content; if (!aiResponseText) { throw new Error('Не удалось получить ответ от ИИ (пустое поле content).'); }
            let parsedResponse;
            try {
                const cleanedText = aiResponseText.trim().replace(/^```json\s*|\s*```$/g, '');
                if (cleanedText === '{}' || cleanedText === '') {
                    parsedResponse = [];
                } else {
                    parsedResponse = JSON.parse(cleanedText);
                }
            } catch (e) { console.error("AI Response (raw):", aiResponseText); throw new Error("Ответ ИИ имеет неверную структуру JSON."); }
            
            displayContradictionResults(parsedResponse);

        } catch (error) {
            console.error('Ошибка при анализе противоречий:', error);
            resultContainer.innerHTML = `<div class="error-message"><strong>Произошла ошибка:</strong> ${error.message}</div>`;
        }
    }

   function displayContradictionResults(resultsArray) {
        const resultContainer = document.getElementById('contradictionAnalysisResult');
        if (!Array.isArray(resultsArray)) {
            resultContainer.innerHTML = `<div class="error-message">Получен некорректный ответ от ИИ (не является массивом).</div>`;
            return;
        }
        if (resultsArray.length === 0) {
            resultContainer.innerHTML = `<div class="validation-message validation-success">${sectionIcons.successIcon} <strong>Несоответствий не найдено.</strong> Все ключевые данные в документе согласованы.</div>`;
            return;
        }

        const firstItem = resultsArray[0];
        const requiredKeys = ['parameter', 'value1', 'source1', 'value2', 'source2', 'comment'];
        const hasRequiredKeys = requiredKeys.every(key => key in firstItem);

        if (!hasRequiredKeys) {
            resultContainer.innerHTML = `<div class="error-message"><strong>Ошибка формата ответа ИИ.</strong> Модель вернула данные с неверными ключами. Попробуйте еще раз.</div>`;
            console.error("Неверный формат от ИИ:", firstItem);
            return;
        }

        let tableHtml = `<table class="contradiction-table">
            <thead>
                <tr>
                    <th>Параметр</th>
                    <th>Источник 1</th>
                    <th>Источник 2</th>
                    <th>Комментарий</th>
                </tr>
            </thead>
            <tbody>`;
        
        resultsArray.forEach(item => {
            tableHtml += `
                <tr>
                    <td>${escapeHtml(item.parameter)}</td>
                    <td>
                        <span class="source-label">${escapeHtml(item.source1)}</span>
                        <div>${escapeHtml(item.value1)}</div>
                    </td>
                    <td>
                        <span class="source-label">${escapeHtml(item.source2)}</span>
                        <div>${escapeHtml(item.value2)}</div>
                    </td>
                    <td>${escapeHtml(item.comment)}</td>
                </tr>`;
        });

        tableHtml += `</tbody></table>`;
        resultContainer.innerHTML = tableHtml;
    }

    setupEventListeners();
});
</script>
</body>
</html>