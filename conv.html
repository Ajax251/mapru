<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Конвертер XML</title>
    <link rel="icon" href="img/kpt11.png" type="image/png">
    <!-- Подключаем библиотеку для работы с ZIP -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <style>
        :root {
            --primary-color: #0078d4;
            --primary-hover: #106ebe;
            --primary-light: #deecf9;
            --primary-bg: #f3f9fd;
            --success-color: #107c10;
            --success-bg: #dff6dd;
            --danger-color: #d13438;
            --danger-bg: #fde7e9;
            --light-bg: #faf9f8;
            --text-color: #323130;
            --text-light: #605e5c;
            --border-color: #edebe9;
            --border-light: #e1dfdd;
            --border-radius: 8px;
            --box-shadow: 0 1.6px 3.6px 0 rgba(0,0,0,.132), 0 0.3px 0.9px 0 rgba(0,0,0,.108);
            --box-shadow-hover: 0 6.4px 14.4px 0 rgba(0,0,0,.132), 0 1.2px 3.6px 0 rgba(0,0,0,.108);
        }
        
        body {
            font-family: 'Segoe UI', -apple-system, BlinkMacSystemFont, Roboto, Helvetica, Arial, sans-serif;
            line-height: 1.6;
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            color: var(--text-color);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: flex-start;
        }

        .container {
            max-width: 800px;
            width: 100%;
            background: #ffffff;
            padding: 40px;
            border-radius: 12px;
            box-shadow: var(--box-shadow);
            text-align: center;
            margin: 20px;
        }

        h1 {
            color: var(--text-color);
            margin-bottom: 8px;
            font-size: 32px;
            font-weight: 600;
        }

        .subtitle {
            color: var(--text-light);
            margin-bottom: 40px;
            font-size: 16px;
        }

        .stage {
            display: none;
            margin-top: 25px;
        }

        .stage.active {
            display: block;
        }

        .upload-area {
            position: relative;
            border: 2px dashed var(--border-light);
            border-radius: var(--border-radius);
            padding: 60px 40px;
            background: var(--light-bg);
            cursor: pointer;
            transition: all 0.3s ease;
            min-height: 200px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }

        .upload-area:hover {
            border-color: var(--primary-color);
            background: var(--primary-bg);
            transform: translateY(-2px);
            box-shadow: var(--box-shadow-hover);
        }

        .upload-area.dragover {
            border-color: var(--primary-color);
            background: var(--primary-light);
            transform: scale(1.02);
            box-shadow: var(--box-shadow-hover);
        }

        .upload-icon {
            width: 64px;
            height: 64px;
            margin-bottom: 24px;
            background: var(--primary-light);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
        }

        .upload-area:hover .upload-icon,
        .upload-area.dragover .upload-icon {
            background: var(--primary-color);
            transform: scale(1.1);
        }

        .upload-icon svg {
            width: 32px;
            height: 32px;
            fill: var(--primary-color);
            transition: all 0.3s ease;
        }

        .upload-area:hover .upload-icon svg,
        .upload-area.dragover .upload-icon svg {
            fill: #ffffff;
        }

        .upload-text {
            font-size: 20px;
            font-weight: 600;
            color: var(--text-color);
            margin-bottom: 8px;
        }

        .upload-text .highlight {
            color: var(--primary-color);
            text-decoration: underline;
        }

        .upload-hint {
            color: var(--text-light);
            font-size: 14px;
            margin-bottom: 24px;
        }

        .file-types {
            display: flex;
            gap: 16px;
            justify-content: center;
            margin-top: 20px;
        }

        .file-type {
            background: #ffffff;
            border: 1px solid var(--border-color);
            border-radius: 6px;
            padding: 8px 16px;
            font-size: 12px;
            font-weight: 500;
            color: var(--text-light);
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .file-type::before {
            content: "📄";
            font-size: 14px;
        }

        .encoding-selector {
            margin-top: 30px;
            text-align: center;
            padding: 20px;
            background: var(--light-bg);
            border-radius: var(--border-radius);
        }

        .encoding-selector label {
            display: block;
            margin-bottom: 8px;
            color: var(--text-color);
            font-weight: 500;
        }

        .encoding-selector select {
            padding: 10px 16px;
            border-radius: 6px;
            border: 1px solid var(--border-color);
            background-color: #ffffff;
            cursor: pointer;
            font-size: 14px;
            min-width: 200px;
            transition: border-color 0.2s ease;
        }

        .encoding-selector select:focus {
            outline: none;
            border-color: var(--primary-color);
            box-shadow: 0 0 0 2px var(--primary-light);
        }

        input[type="file"] {
            display: none;
        }

        #options-stage h2 {
            font-size: 24px;
            margin-bottom: 8px;
            text-align: left;
            color: var(--text-color);
            font-weight: 600;
        }

        .file-info {
            background: var(--primary-bg);
            border: 1px solid var(--primary-light);
            border-radius: var(--border-radius);
            padding: 16px;
            margin-bottom: 24px;
            text-align: left;
        }

        .file-info .file-name {
            font-weight: 600;
            color: var(--primary-color);
            margin-bottom: 4px;
        }

        .file-info .file-details {
            font-size: 14px;
            color: var(--text-light);
        }

        .options-list {
            list-style: none;
            padding: 0;
            margin: 0;
            text-align: left;
        }

        .options-list li {
            background: #ffffff;
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius);
            padding: 16px;
            margin-bottom: 8px;
            transition: all 0.2s ease;
        }

        .options-list li:hover {
            background: var(--light-bg);
            border-color: var(--primary-color);
            transform: translateX(4px);
        }
        
        #conversion-info {
            text-align: left;
            margin-bottom: 24px;
            font-size: 16px;
        }

        .custom-checkbox {
            display: flex;
            align-items: center;
            cursor: pointer;
            width: 100%;
        }

        .custom-checkbox input {
            display: none;
        }

        .custom-checkbox .checkmark {
            min-width: 20px;
            height: 20px;
            border: 2px solid var(--border-color);
            border-radius: 4px;
            margin-right: 16px;
            display: inline-block;
            position: relative;
            transition: all 0.2s ease;
            background: #ffffff;
        }

        .custom-checkbox input:checked ~ .checkmark {
            background-color: var(--primary-color);
            border-color: var(--primary-color);
        }

        .custom-checkbox .checkmark::after {
            content: "";
            position: absolute;
            display: none;
            left: 6px;
            top: 2px;
            width: 5px;
            height: 10px;
            border: solid white;
            border-width: 0 3px 3px 0;
            transform: rotate(45deg);
        }

        .custom-checkbox input:checked ~ .checkmark::after {
            display: block;
        }

        .custom-checkbox .label-text {
            font-weight: 500;
            flex: 1;
        }

        .custom-checkbox .count {
            background: var(--primary-light);
            color: var(--primary-color);
            padding: 4px 12px;
            border-radius: 12px;
            font-size: 14px;
            font-weight: 600;
        }

        .actions {
            margin-top: 30px;
            display: flex;
            justify-content: flex-end;
            gap: 12px;
        }

        .btn {
            padding: 12px 24px;
            font-size: 14px;
            font-weight: 600;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s ease;
            min-width: 120px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }

        .btn-primary {
            background-color: var(--primary-color);
            color: white;
            box-shadow: 0 2px 4px rgba(0, 120, 212, 0.3);
        }

        .btn-primary:hover {
            background-color: var(--primary-hover);
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(0, 120, 212, 0.4);
        }

        .btn-secondary {
            background-color: #ffffff;
            color: var(--text-color);
            border: 1px solid var(--border-color);
        }

        .btn-secondary:hover {
            background-color: var(--light-bg);
            border-color: var(--primary-color);
        }

        #result-content {
            padding: 24px;
            border-radius: var(--border-radius);
            margin-top: 20px;
            text-align: center;
        }

        #result-content.success {
            background-color: var(--success-bg);
            border: 1px solid var(--success-color);
            color: var(--success-color);
        }

        #result-content.error {
            background-color: var(--danger-bg);
            border: 1px solid var(--danger-color);
            color: var(--danger-color);
        }

        #result-content p {
            margin: 0 0 16px;
            font-weight: 600;
            font-size: 16px;
        }

        #result-content .success-icon,
        #result-content .error-icon {
            font-size: 48px;
            margin-bottom: 16px;
            display: block;
        }

        #loader {
            text-align: center;
            padding: 40px;
        }

        .spinner {
            border: 4px solid var(--border-light);
            width: 40px;
            height: 40px;
            border-radius: 50%;
            border-left-color: var(--primary-color);
            animation: spin 1s ease infinite;
            margin: 0 auto 20px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .loading-text {
            color: var(--text-light);
            font-size: 16px;
        }

        @media (max-width: 768px) {
            .container {
                padding: 20px;
                margin: 10px;
            }
            .upload-area { padding: 40px 20px; }
            .actions { flex-direction: column; }
            .btn { width: 100%; }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Конвертер XML</h1>
        <p class="subtitle">Преобразование между версиями 8/9/10 и 11</p>
        
        <div id="upload-stage" class="stage active">
            <input type="file" id="fileInput" accept=".xml,.zip">
            <label for="fileInput" class="upload-area" id="uploadArea">
                <div class="upload-icon">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
                        <path d="M14,2H6A2,2 0 0,0 4,4V20A2,2 0 0,0 6,22H18A2,2 0 0,0 20,20V8L14,2M18,20H6V4H13V9H18V20Z"/>
                    </svg>
                </div>
                <div class="upload-text">
                    <span class="highlight">Выберите файл</span> или перетащите
                </div>
                <div class="file-types">
                    <div class="file-type">XML или ZIP файлы (выписки и КПТ)</div>
                </div>
            </label>
            
            <div class="encoding-selector">
                <label for="encodingSelector">Кодировка исходного файла:</label>
                <select id="encodingSelector">
                    <option value="UTF-8">UTF-8</option>
                    <option value="windows-1251">Windows-1251</option>
                </select>
            </div>
        </div>

        <div id="options-stage" class="stage">
            <h2 id="options-title">Выберите объекты для конвертации</h2>
            <div class="file-info">
                <div class="file-name" id="fileName"></div>
                <div class="file-details" id="fileDetails"></div>
            </div>
            <div id="conversion-info"></div>
            <ul id="optionsList" class="options-list"></ul>
            <div class="actions">
                <button id="resetButton" class="btn btn-secondary">🔄 Начать заново</button>
                <button id="convertButton" class="btn btn-primary">🚀 Конвертировать</button>
            </div>
        </div>

        <div id="result-stage" class="stage">
            <div id="loader">
                <div class="spinner"></div>
                <div class="loading-text">Обработка файла, пожалуйста подождите...</div>
            </div>
            <div id="result-content"></div>
            <div class="actions" style="justify-content: center; margin-top: 30px;">
                <button id="backToOptionsButton" class="btn btn-secondary" style="display: none;">↩️ Вернуться к выбору</button>
                <button id="startOverButton" class="btn btn-primary">📁 Выбрать другой файл</button>
            </div>
        </div>
    </div>

<script>
let currentXmlDoc = null;
let currentFileName = '';
let conversionDirection = null;
let sourceVersion = null;

const stages = {
    upload: document.getElementById('upload-stage'),
    options: document.getElementById('options-stage'),
    result: document.getElementById('result-stage')
};

const fileInput = document.getElementById('fileInput');
const uploadArea = document.getElementById('uploadArea');
const optionsList = document.getElementById('optionsList');
const fileName = document.getElementById('fileName');
const fileDetails = document.getElementById('fileDetails');
const convertButton = document.getElementById('convertButton');
const resetButton = document.getElementById('resetButton');
const startOverButton = document.getElementById('startOverButton');
const loader = document.getElementById('loader');
const resultContent = document.getElementById('result-content');
const encodingSelector = document.getElementById('encodingSelector');
const optionsTitle = document.getElementById('options-title');
const conversionInfo = document.getElementById('conversion-info');
const backToOptionsButton = document.getElementById('backToOptionsButton');

const OBJECT_TYPES = {
    parcels: { label: 'Земельные участки', selector: 'land_record', prefix: 'zu' },
    buildings: { label: 'Здания', selector: 'build_record', prefix: 'oks' },
    constructions: { label: 'Сооружения', selector: 'construction_record', prefix: 'cons' },
    bounds: { label: 'Границы (муниципальные, н.п.)', selector: 'municipal_boundary_record, inhabited_locality_boundary_record', prefix: 'bounds' },
    zones: { label: 'Зоны и территории', selector: 'zones_and_territories_record', prefix: 'zones' }
};

fileInput.addEventListener('change', () => handleFileSelect(fileInput.files));
uploadArea.addEventListener('drop', handleFileDrop, false);
['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => uploadArea.addEventListener(eventName, preventDefaults, false));
['dragenter', 'dragover'].forEach(eventName => uploadArea.addEventListener(eventName, () => uploadArea.classList.add('dragover'), false));
['dragleave', 'drop'].forEach(eventName => uploadArea.addEventListener(eventName, () => uploadArea.classList.remove('dragover'), false));
convertButton.addEventListener('click', handleConversion);
resetButton.addEventListener('click', resetApp);
startOverButton.addEventListener('click', resetApp);
backToOptionsButton.addEventListener('click', () => updateUIState('options'));

function preventDefaults(e) { e.preventDefault(); e.stopPropagation(); }
function updateUIState(activeStage) {
    Object.values(stages).forEach(stage => stage.classList.remove('active'));
    if (stages[activeStage]) stages[activeStage].classList.add('active');
}

function resetApp() {
    currentXmlDoc = null;
    currentFileName = '';
    conversionDirection = null;
    sourceVersion = null; 
    fileInput.value = '';
    resultContent.innerHTML = '';
    resultContent.className = '';
    backToOptionsButton.style.display = 'none'; 
    updateUIState('upload');
}

function handleFileDrop(e) { fileInput.files = e.dataTransfer.files; handleFileSelect(e.dataTransfer.files); }
function handleFileSelect(files) {
    if (files.length === 0) return;
    if (currentFileName === files[0].name && currentXmlDoc) return;
    const file = files[0]; currentFileName = file.name;
    showLoaderWithMessage(`Анализ файла: ${file.name}`);
    if (file.name.toLowerCase().endsWith('.zip')) { handleZipFile(file); } else { handleXmlFile(file); }
}
function handleZipFile(file) {
    const encoding = encodingSelector.value;
    JSZip.loadAsync(file).then(zip => {
        const xmlFile = Object.values(zip.files).find(f => f.name.toLowerCase().endsWith('.xml'));
        if (xmlFile) return xmlFile.async("blob");
        throw new Error("XML-файл не найден в ZIP-архиве.");
    }).then(blob => {
        const reader = new FileReader();
        reader.onload = e => processXmlString(e.target.result);
        reader.onerror = () => showError('Не удалось прочитать XML из ZIP.');
        reader.readAsText(blob, encoding);
    }).catch(error => showError(`Ошибка при обработке ZIP: ${error.message}`));
}
function handleXmlFile(file) {
    const encoding = encodingSelector.value;
    const reader = new FileReader();
    reader.onload = (event) => processXmlString(event.target.result);
    reader.onerror = () => showError('Не удалось прочитать XML-файл.');
    reader.readAsText(file, encoding);
}

function processXmlString(xmlString) {
    try {
        const parser = new DOMParser();
        const xmlDoc = parser.parseFromString(xmlString, "application/xml");
        const parserError = xmlDoc.querySelector("parsererror");
        
        if (parserError) {
            throw new Error(`Ошибка разбора XML: ${parserError.textContent}. Попробуйте сменить кодировку.`);
        }
        
        currentXmlDoc = xmlDoc;
        const root = xmlDoc.documentElement;
        const rootNS = root.namespaceURI || '';

        if (root.tagName.startsWith('extract_')) {
            conversionDirection = '11to10';
            sourceVersion = 11;
            setupOptionsFor11to10(xmlDoc);
        } 
        else if (root.tagName === 'KPT' && rootNS.includes('kpt/10')) {
            conversionDirection = '10to11';
            sourceVersion = 10;
            setupOptionsFor10to11(xmlDoc);
        }
        else if (root.tagName === 'KPT' && rootNS.includes('kpt/9')) {
            conversionDirection = '10to11';
            sourceVersion = 9;
            setupOptionsFor10to11(xmlDoc);
        }
        else if (root.tagName === 'Region_Cadastr' && root.getAttribute('Version') === '08') {
             conversionDirection = '10to11';
             sourceVersion = 8;
             setupOptionsFor10to11(xmlDoc);
        }
        else {
            throw new Error(`Не удалось определить версию XML файла. Корневой тег "${root.tagName}" не соответствует поддерживаемым форматам (КПТ v.8/9/10 или выписки v.11).`);
        }

    } catch (error) {
        showError(`Ошибка: ${error.message}`);
    }
}

function setupOptionsFor11to10(xmlDoc) {
    optionsTitle.textContent = 'Выберите объекты для конвертации';
    conversionInfo.innerHTML = `<strong>Направление:</strong> XML v.11 ➔ XML v.10`;
    optionsList.style.display = 'block';
    analyzeAndDisplayOptions(xmlDoc);
}
function setupOptionsFor10to11(xmlDoc) {
    optionsTitle.textContent = 'Подтверждение конвертации';
   
    conversionInfo.innerHTML = `<strong>Направление:</strong> XML КПТ v.${sourceVersion} ➔ XML v.11`;
    optionsList.innerHTML = '';
    optionsList.style.display = 'none';
    const totalObjects = xmlDoc.querySelectorAll('Parcel, Building, Construction, Bound, Zone').length;
    fileName.textContent = currentFileName;
    fileDetails.textContent = `Найдено объектов: ${totalObjects}`;
    backToOptionsButton.style.display = 'none';
    updateUIState('options');
}

function analyzeAndDisplayOptions(xmlDoc) {
    optionsList.innerHTML = '';
    let hasObjects = false; let totalObjects = 0;
    Object.entries(OBJECT_TYPES).forEach(([key, config]) => {
        const count = xmlDoc.querySelectorAll(config.selector).length;
        totalObjects += count;
        if (count > 0) {
            hasObjects = true;
            const listItem = document.createElement('li');
            listItem.innerHTML = `<label class="custom-checkbox"><input type="checkbox" data-type="${key}" checked><span class="checkmark"></span><span class="label-text">${config.label}</span><span class="count">${count}</span></label>`;
            optionsList.appendChild(listItem);
        }
    });
    if (!hasObjects) { showError('В файле не найдено поддерживаемых объектов для конвертации.'); return; }
    fileName.textContent = currentFileName;
    fileDetails.textContent = `Найдено объектов: ${totalObjects}`;
    const isKptFile = xmlDoc.querySelectorAll('cadastral_block').length > 0;
    backToOptionsButton.style.display = isKptFile ? 'inline-flex' : 'none';
    updateUIState('options');
}

function handleConversion() {
    if (!currentXmlDoc) { showError('XML документ не загружен.'); return; }
    updateUIState('result');
    loader.style.display = 'block';
    resultContent.style.display = 'none';
    
    setTimeout(() => {
        try {
            let newXmlString, downloadFileName;

            if (conversionDirection === '11to10') {
                const selection = {};
                optionsList.querySelectorAll('input[type="checkbox"]').forEach(checkbox => { selection[checkbox.dataset.type] = checkbox.checked; });
                newXmlString = convertXml11to10(currentXmlDoc, selection);
                const isKptFile = currentXmlDoc.querySelectorAll('cadastral_block').length > 0;
                let numForFileName;
                if (isKptFile) {
                    numForFileName = currentXmlDoc.querySelector('cadastral_block > cadastral_number')?.textContent || 'unknown';
                } else {
                    numForFileName = currentXmlDoc.querySelector('object common_data cad_number')?.textContent || currentXmlDoc.querySelector('quarter_cad_number')?.textContent || 'unknown';
                }
                downloadFileName = generateFileName11to10(numForFileName, selection, isKptFile);
                 showSuccess(downloadFileName, 11, 10); // Передаем версии
            } else if (conversionDirection === '10to11') {
                newXmlString = convertXml10to11(currentXmlDoc);
                const cadNum = currentXmlDoc.querySelector('Cadastral_Block, CadastralBlock')?.getAttribute('CadastralNumber') || 'unknown';
                // Используем новую переменную для имени файла
                downloadFileName = `KPT_${cadNum.replace(/:/g, '_')}_v11 (из v${sourceVersion}).xml`;
                showSuccess(downloadFileName, sourceVersion, 11); // Передаем версии
            } else {
                throw new Error("Не определено направление конвертации.");
            }

            const blob = new Blob([newXmlString], { type: 'application/xml;charset=utf-8' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url; a.download = downloadFileName; document.body.appendChild(a);
            a.click(); document.body.removeChild(a); URL.revokeObjectURL(url);
            
        } catch (error) {
            console.error(error);
            showError(`Ошибка конвертации: ${error.message}`);
        } finally {
            loader.style.display = 'none';
        }
    }, 100);
}

function generateFileName11to10(cadNum, selection, isKptFile) {
    const cleanedCadNum = cadNum.replace(/:/g, '_');
    if (isKptFile) {
        const baseName = `KPT_${cleanedCadNum}`;
        const selectedTypes = Object.entries(selection).filter(([key, isSelected]) => isSelected && OBJECT_TYPES[key]).map(([key]) => OBJECT_TYPES[key].prefix);
        const allSelected = Object.keys(selection).every(type => selection[type] !== false);
        if (!allSelected && selectedTypes.length > 0) return `${baseName}_${selectedTypes.join('_')}_v10.xml`;
        return `${baseName}_v10.xml`;
    } else {
        const selectedTypes = Object.entries(selection).filter(([key, isSelected]) => isSelected && OBJECT_TYPES[key]).map(([key]) => OBJECT_TYPES[key].prefix);
        const prefix = (selectedTypes.length > 0 ? selectedTypes[0] : 'EXTRACT').toUpperCase();
        return `${prefix}_${cleanedCadNum}_v10.xml`;
    }
}
function showLoaderWithMessage(message) {
    updateUIState('result'); loader.style.display = 'block';
    loader.querySelector('.loading-text').textContent = message;
    resultContent.style.display = 'none';
}
function showSuccess(fileName, fromVersion, toVersion) {
    let message = 'Конвертация успешно завершена!'; 
    if (fromVersion && toVersion) {
        message = `Конвертация из ${fromVersion} версии в ${toVersion} успешно завершена!`;
    }
    
    resultContent.className = 'success';
    resultContent.innerHTML = `
        <span class="success-icon">✅</span>
        <p>${message}</p>
        <p>Файл <strong>${fileName}</strong> скачивается...</p>
    `;
    resultContent.style.display = 'block';
}
function showError(message) {
    updateUIState('result'); loader.style.display = 'none';
    resultContent.className = 'error';
    resultContent.innerHTML = `<span class="error-icon">❌</span><p>Произошла ошибка!</p><p>${message}</p>`;
    resultContent.style.display = 'block';
}

// =======================================================================
// ==================== CONVERSION LOGIC 11 -> 10 ========================
// =======================================================================
const NS_V10 = { KPT: "urn://x-artefacts-rosreestr-ru/outgoing/kpt/10.0.1", ADR: "urn://x-artefacts-rosreestr-ru/commons/complex-types/address-output/4.0.1", SPATIAL: "urn://x-artefacts-rosreestr-ru/commons/complex-types/entity-spatial/5.0.1", OKS: "urn://x-artefacts-rosreestr-ru/commons/complex-types/parameters-oks/2.0.1", CERT: "urn://x-artefacts-rosreestr-ru/commons/complex-types/certification-doc/1.0", DOC: "urn://x-artefacts-rosreestr-ru/commons/complex-types/document-output/4.0.1", SMEV: "urn://x-artefacts-smev-gov-ru/supplementary/commons/1.0.1" };
const getNodeValue = (parent, selector) => parent.querySelector(selector)?.textContent.trim() || '';
function convertXml11to10(oldDoc, selection) { const newDoc = document.implementation.createDocument(NS_V10.KPT, 'KPT', null); const root = newDoc.documentElement; root.setAttributeNS('http://www.w3.org/2000/xmlns/', 'xmlns', NS_V10.KPT); root.setAttributeNS('http://www.w3.org/2000/xmlns/', 'xmlns:adrOut4', NS_V10.ADR); root.setAttributeNS('http://www.w3.org/2000/xmlns/', 'xmlns:ns3', NS_V10.SPATIAL); root.setAttributeNS('http://www.w3.org/2000/xmlns/', 'xmlns:ns4', NS_V10.OKS); root.setAttributeNS('http://www.w3.org/2000/xmlns/', 'xmlns:ns5', NS_V10.DOC); root.setAttributeNS('http://www.w3.org/2000/xmlns/', 'xmlns:ns6', NS_V10.CERT); root.setAttributeNS('http://www.w3.org/2000/xmlns/', 'xmlns:ns7', NS_V10.SMEV); const coordSystems = new Map(); const csCounter = { value: 1 }; const cadastralBlocks = createElement(newDoc, NS_V10.KPT, 'CadastralBlocks'); const oldBlocks = oldDoc.querySelectorAll('cadastral_block'); if (oldBlocks.length > 0) { oldBlocks.forEach(oldBlock => { const newBlock = createElement(newDoc, NS_V10.KPT, 'CadastralBlock'); newBlock.setAttribute('CadastralNumber', getNodeValue(oldBlock, 'cadastral_number')); const area = createElement(newDoc, NS_V10.KPT, 'Area'); area.appendChild(createElementWithText(newDoc, NS_V10.KPT, 'Total', getNodeValue(oldBlock, 'area_quarter area'))); area.appendChild(createElementWithText(newDoc, NS_V10.KPT, 'Unit', getNodeValue(oldBlock, 'area_quarter unit'))); newBlock.appendChild(area); if (selection.parcels) appendChildIfNotEmpty(newBlock, convertParcels11to10(oldBlock, newDoc, coordSystems, csCounter)); if (selection.buildings || selection.constructions) appendChildIfNotEmpty(newBlock, convertObjectsRealty11to10(oldBlock, newDoc, coordSystems, csCounter, selection)); if (selection.bounds) appendChildIfNotEmpty(newBlock, convertBounds11to10(oldBlock, newDoc, coordSystems, csCounter)); if (selection.zones) appendChildIfNotEmpty(newBlock, convertZones11to10(oldBlock, newDoc, coordSystems, csCounter)); appendChildIfNotEmpty(newBlock, convertSpatialData11to10(oldBlock, newDoc, coordSystems, csCounter)); cadastralBlocks.appendChild(newBlock); }); } else { const quarterNum = getNodeValue(oldDoc, 'quarter_cad_number'); if (!quarterNum) throw new Error('Не удалось определить номер кадастрового квартала в выписке (тег quarter_cad_number не найден).'); const newBlock = createElement(newDoc, NS_V10.KPT, 'CadastralBlock'); newBlock.setAttribute('CadastralNumber', quarterNum); if (selection.parcels) appendChildIfNotEmpty(newBlock, convertParcels11to10(oldDoc, newDoc, coordSystems, csCounter)); if (selection.buildings || selection.constructions) appendChildIfNotEmpty(newBlock, convertObjectsRealty11to10(oldDoc, newDoc, coordSystems, csCounter, selection)); if (selection.bounds) appendChildIfNotEmpty(newBlock, convertBounds11to10(oldDoc, newDoc, coordSystems, csCounter)); if (selection.zones) appendChildIfNotEmpty(newBlock, convertZones11to10(oldDoc, newDoc, coordSystems, csCounter)); appendChildIfNotEmpty(newBlock, convertSpatialData11to10(oldDoc, newDoc, coordSystems, csCounter)); cadastralBlocks.appendChild(newBlock); } root.appendChild(cadastralBlocks); root.appendChild(createCoordSystemsNode11to10(newDoc, coordSystems)); root.appendChild(createCertificationDocNode11to10(oldDoc, newDoc)); const serializer = new XMLSerializer(); let xmlString = serializer.serializeToString(newDoc); const styleSheet = '<?xml-stylesheet type="text/xsl" href="https://portal.rosreestr.ru/xsl/GKN/KPT_b/10/common.xsl"?>'; return `<?xml version="1.0" encoding="UTF-8"?>\n${styleSheet}\n` + xmlString; }
function appendChildIfNotEmpty(parent, child) { if (child && child.hasChildNodes()) parent.appendChild(child); }
function createElement(doc, ns, qualifiedName) { return doc.createElementNS(ns, qualifiedName); }
function createElementWithText(doc, ns, qualifiedName, text) { const el = createElement(doc, ns, qualifiedName); if (text) el.textContent = text; return el; }
function createCertificationDocNode11to10(oldDoc, newDoc) { const certDoc = createElement(newDoc, NS_V10.KPT, 'CertificationDoc'); const statement = oldDoc.querySelector('details_statement'); if (!statement) return certDoc; certDoc.appendChild(createElementWithText(newDoc, NS_V10.CERT, 'ns6:Organization', getNodeValue(statement, 'organ_registr_rights'))); certDoc.appendChild(createElementWithText(newDoc, NS_V10.CERT, 'ns6:Date', getNodeValue(statement, 'date_formation'))); certDoc.appendChild(createElementWithText(newDoc, NS_V10.CERT, 'ns6:Number', getNodeValue(statement, 'registration_number'))); return certDoc; }
function createAddressNode11to10(oldAddress, newDoc) {const locationNode = createElement(newDoc, NS_V10.KPT, 'Location');if (!oldAddress) return locationNode;const address = createElement(newDoc, NS_V10.KPT, 'Address');locationNode.appendChild(address);const addressTypeCode = getNodeValue(oldAddress, 'address_type code');if (addressTypeCode === '02') address.setAttribute('adrOut4:AddressOrLocation', '0');const addrSource = oldAddress.querySelector('address, location');if (!addrSource) return locationNode;const createAdrEl = (name, val) => !val ? null : createElementWithText(newDoc, NS_V10.ADR, `adrOut4:${name}`, val);const createAdrElWithAttr = (name, attrs) => {if (!Object.values(attrs).some(v => v)) return null;const el = createElement(newDoc, NS_V10.ADR, `adrOut4:${name}`);Object.entries(attrs).forEach(([key, value]) => value && el.setAttribute(key, value));return el;};const elements = [createAdrEl('OKATO', getNodeValue(addrSource, 'okato')), createAdrEl('KLADR', getNodeValue(addrSource, 'kladr')),createAdrEl('PostalCode', getNodeValue(addrSource, 'postal_code')),createAdrEl('Region', getNodeValue(addrSource, 'region code, region value')),createAdrElWithAttr('District', { Type: getNodeValue(addrSource, 'district type_district, district type'), Name: getNodeValue(addrSource, 'district name_district, district name') }),createAdrElWithAttr('City', { Type: getNodeValue(addrSource, 'city type_city, city type'), Name: getNodeValue(addrSource, 'city name_city, city name') }),createAdrElWithAttr('Street', { Type: getNodeValue(addrSource, 'street type_street, street type'), Name: getNodeValue(addrSource, 'street name_street, street name') }),createAdrElWithAttr('Level1', { Type: getNodeValue(addrSource, 'level1 type_level1, level1 type'), Value: getNodeValue(addrSource, 'level1 name_level1, level1 value') }),createAdrEl('Note', getNodeValue(oldAddress, 'readable_address'))];elements.forEach(el => el && address.appendChild(el));return locationNode;}
function createEntitySpatialNode11to10(oldSpatial, newDoc, coordSystems, csCounter) {const entSpatial = createElement(newDoc, NS_V10.KPT, 'EntitySpatial');if (!oldSpatial) return entSpatial;const csId = getNodeValue(oldSpatial, 'sk_id') || 'UNKNOWN_CS';let sysId = coordSystems.get(csId);if (!sysId) { sysId = `ID${csCounter.value++}`; coordSystems.set(csId, sysId); }entSpatial.setAttribute('EntSys', sysId);const spatialElements = oldSpatial.querySelectorAll('contour > entity_spatial > spatials_elements > spatial_element, spatials_elements > spatial_element');spatialElements.forEach(oldElement => {const spatialElementNode = createElement(newDoc, NS_V10.SPATIAL, 'ns3:SpatialElement');oldElement.querySelectorAll(':scope > ordinates > ordinate').forEach(ord => {const suNmb = getNodeValue(ord, 'ord_nmb') || getNodeValue(ord, 'number_pp');const spelementUnit = createElement(newDoc, NS_V10.SPATIAL, 'ns3:SpelementUnit');spelementUnit.setAttribute('TypeUnit', 'Точка');if (suNmb) spelementUnit.setAttribute('SuNmb', suNmb);const ordinate = createElement(newDoc, NS_V10.SPATIAL, 'ns3:Ordinate');ordinate.setAttribute('X', getNodeValue(ord, 'x'));ordinate.setAttribute('Y', getNodeValue(ord, 'y'));ordinate.setAttribute('OrdNmb', '1');const numGeopoint = getNodeValue(ord, 'num_geopoint');if (numGeopoint) ordinate.setAttribute('NumGeopoint', numGeopoint);const delta = getNodeValue(ord, 'delta_geopoint');if (delta) ordinate.setAttribute('DeltaGeopoint', delta);const zacrep = getNodeValue(ord, 'geopoint_zacrep');if (zacrep && zacrep !== "-") { ordinate.setAttribute('GeopointZacrep', zacrep); } else if (!numGeopoint) { ordinate.setAttribute('GeopointZacrep', 'Закрепление отсутствует'); }spelementUnit.appendChild(ordinate);spatialElementNode.appendChild(spelementUnit);});if (spatialElementNode.hasChildNodes()) entSpatial.appendChild(spatialElementNode);});return entSpatial;}
function createCoordSystemsNode11to10(newDoc, coordSystems) {const csNode = createElement(newDoc, NS_V10.KPT, 'CoordSystems');for (const [name, id] of coordSystems.entries()) {const system = createElement(newDoc, NS_V10.SPATIAL, 'ns3:CoordSystem');system.setAttribute('Name', name);system.setAttribute('CsId', id);csNode.appendChild(system);}return csNode;}
function convertParcels11to10(dataSource, newDoc, coordSystems, csCounter) {const parcelsNode = createElement(newDoc, NS_V10.KPT, 'Parcels');dataSource.querySelectorAll('land_record').forEach(oldParcel => {const newParcel = createElement(newDoc, NS_V10.KPT, 'Parcel');newParcel.setAttribute('CadastralNumber', getNodeValue(oldParcel, 'object common_data cad_number'));newParcel.setAttribute('State', '01');const areaNode = createElement(newDoc, NS_V10.KPT, 'Area');areaNode.appendChild(createElementWithText(newDoc, NS_V10.KPT, 'Area', getNodeValue(oldParcel, 'params area value')));areaNode.appendChild(createElementWithText(newDoc, NS_V10.KPT, 'Unit', '055'));const inaccuracy = getNodeValue(oldParcel, 'params area inaccuracy');if (inaccuracy) areaNode.appendChild(createElementWithText(newDoc, NS_V10.KPT, 'Inaccuracy', inaccuracy));newParcel.appendChild(areaNode);if (getNodeValue(oldParcel, 'object subtype value').toLowerCase().includes('землепользование')) {newParcel.appendChild(createElementWithText(newDoc, NS_V10.KPT, 'Name', '01'));}newParcel.appendChild(createAddressNode11to10(oldParcel.querySelector('address_location'), newDoc));newParcel.appendChild(createElementWithText(newDoc, NS_V10.KPT, 'Category', getNodeValue(oldParcel, 'params category type code')));const utilNode = createElement(newDoc, NS_V10.KPT, 'Utilization');utilNode.setAttribute('ByDoc', getNodeValue(oldParcel, 'params permitted_use by_document, params permitted_use permitted_use_established by_document'));newParcel.appendChild(utilNode);const costVal = getNodeValue(oldParcel, 'cost value');if (costVal) {const costNode = createElement(newDoc, NS_V10.KPT, 'CadastralCost');costNode.setAttribute('Value', costVal);costNode.setAttribute('Unit', '383');newParcel.appendChild(costNode);}const oldSpatial = oldParcel.querySelector('contours_location, entity_spatial');if (oldSpatial) newParcel.appendChild(createEntitySpatialNode11to10(oldSpatial, newDoc, coordSystems, csCounter));parcelsNode.appendChild(newParcel);});return parcelsNode;}
function convertObjectsRealty11to10(dataSource, newDoc, coordSystems, csCounter, selection) {const objectsNode = createElement(newDoc, NS_V10.KPT, 'ObjectsRealty');if (selection.buildings) {dataSource.querySelectorAll('build_record').forEach(oldBuild => {const objectRealty = createElement(newDoc, NS_V10.KPT, 'ObjectRealty');const building = createElement(newDoc, NS_V10.KPT, 'Building');building.setAttribute('CadastralNumber', getNodeValue(oldBuild, 'object common_data cad_number'));building.appendChild(createElementWithText(newDoc, NS_V10.KPT, 'ObjectType', getNodeValue(oldBuild, 'object common_data type code')));building.appendChild(createElementWithText(newDoc, NS_V10.KPT, 'AssignationBuilding', getNodeValue(oldBuild, 'params purpose code')));building.appendChild(createElementWithText(newDoc, NS_V10.KPT, 'Area', getNodeValue(oldBuild, 'params area')));building.appendChild(createAddressNode11to10(oldBuild.querySelector('address_location'), newDoc));const cost = getNodeValue(oldBuild, 'cost value');if(cost) {const costNode = createElement(newDoc, NS_V10.KPT, 'CadastralCost');costNode.setAttribute('Value', cost); costNode.setAttribute('Unit', '383');building.appendChild(costNode);}const oldSpatial = oldBuild.querySelector('contours, entity_spatial');if (oldSpatial) building.appendChild(createEntitySpatialNode11to10(oldSpatial, newDoc, coordSystems, csCounter));objectRealty.appendChild(building);objectsNode.appendChild(objectRealty);});}if (selection.constructions) {dataSource.querySelectorAll('construction_record').forEach(oldConstr => {const objectRealty = createElement(newDoc, NS_V10.KPT, 'ObjectRealty');const constr = createElement(newDoc, NS_V10.KPT, 'Construction');constr.setAttribute('CadastralNumber', getNodeValue(oldConstr, 'object common_data cad_number'));constr.appendChild(createElementWithText(newDoc, NS_V10.KPT, 'ObjectType', getNodeValue(oldConstr, 'object common_data type code')));constr.appendChild(createElementWithText(newDoc, NS_V10.KPT, 'AssignationName', getNodeValue(oldConstr, 'params purpose')));const extension = getNodeValue(oldConstr, 'base_parameters extension, params base_parameters base_parameter extension');if (extension) {const keyParams = createElement(newDoc, NS_V10.KPT, 'KeyParameters');const keyParam = createElement(newDoc, NS_V10.OKS, 'ns4:KeyParameter');keyParam.setAttribute('Type', '01');keyParam.setAttribute('Value', extension);keyParams.appendChild(keyParam);constr.appendChild(keyParams);}constr.appendChild(createAddressNode11to10(oldConstr.querySelector('address_location'), newDoc));const cost = getNodeValue(oldConstr, 'cost value');if(cost) {const costNode = createElement(newDoc, NS_V10.KPT, 'CadastralCost');costNode.setAttribute('Value', cost); costNode.setAttribute('Unit', '383');constr.appendChild(costNode);}const oldSpatial = oldConstr.querySelector('contours, entity_spatial');if (oldSpatial) constr.appendChild(createEntitySpatialNode11to10(oldSpatial, newDoc, coordSystems, csCounter));objectRealty.appendChild(constr);objectsNode.appendChild(objectRealty);});}return objectsNode;}
function convertSpatialData11to10(dataSource, newDoc, coordSystems, csCounter) {const spatialNode = createElement(newDoc, NS_V10.KPT, 'SpatialData');const oldSpatial = dataSource.querySelector(':scope > spatial_data > entity_spatial');if (oldSpatial) spatialNode.appendChild(createEntitySpatialNode11to10(oldSpatial, newDoc, coordSystems, csCounter));return spatialNode;}
function convertBounds11to10(dataSource, newDoc, coordSystems, csCounter) {const boundsNode = createElement(newDoc, NS_V10.KPT, 'Bounds');dataSource.querySelectorAll('municipal_boundary_record, inhabited_locality_boundary_record').forEach(oldBoundRec => {const boundNode = createElement(newDoc, NS_V10.KPT, 'Bound');const bObject = oldBoundRec.querySelector('b_object');boundNode.appendChild(createElementWithText(newDoc, NS_V10.KPT, 'Description', getNodeValue(bObject, 'type_boundary value')));boundNode.appendChild(createElementWithText(newDoc, NS_V10.KPT, 'AccountNumber', getNodeValue(bObject, 'reg_numb_border')));const boundaries = createElement(newDoc, NS_V10.KPT, 'Boundaries');const oldSpatial = oldBoundRec.querySelector('b_contours_location');if (oldSpatial) {const boundary = createElement(newDoc, NS_V10.KPT, 'Boundary');boundary.appendChild(createEntitySpatialNode11to10(oldSpatial, newDoc, coordSystems, csCounter));boundaries.appendChild(boundary);}appendChildIfNotEmpty(boundNode, boundaries);boundsNode.appendChild(boundNode);});return boundsNode;}
function convertZones11to10(dataSource, newDoc, coordSystems, csCounter) {const zonesNode = createElement(newDoc, NS_V10.KPT, 'Zones');dataSource.querySelectorAll('zones_and_territories_record').forEach(oldZoneRec => {const zoneNode = createElement(newDoc, NS_V10.KPT, 'Zone');const bObject = oldZoneRec.querySelector('b_object_zones_and_territories');zoneNode.appendChild(createElementWithText(newDoc, NS_V10.KPT, 'Description', getNodeValue(bObject, 'type_boundary value')));zoneNode.appendChild(createElementWithText(newDoc, NS_V10.KPT, 'AccountNumber', getNodeValue(bObject, 'b_object reg_numb_border')));const oldSpatial = oldZoneRec.querySelector('b_contours_location');if(oldSpatial) zoneNode.appendChild(createEntitySpatialNode11to10(oldSpatial, newDoc, coordSystems, csCounter));const specialZone = createElement(newDoc, NS_V10.KPT, 'SpecialZone');const content = `${getNodeValue(bObject, 'type_zone code')} ${getNodeValue(bObject, 'type_zone value')}`;specialZone.appendChild(createElementWithText(newDoc, NS_V10.KPT, 'ContentRestrictions', content.trim()));zoneNode.appendChild(specialZone);zonesNode.appendChild(zoneNode);});return zonesNode;}

// =======================================================================
// ==================== CONVERSION LOGIC 8/9/10 -> 11 ====================
// =======================================================================
const NS_V11 = { KPT: "urn://x-artefacts-rosreestr-ru/outgoing/kpt/11.1.0", EXTRACT_BASE: "urn://x-artefacts-rosreestr-ru/commons/extract-base/5.0.1", ADDRESS: "urn://x-artefacts-rosreestr-ru/commons/complex-types/address/2.0.1", SPATIAL: "urn://x-artefacts-rosreestr-ru/commons/complex-types/entity-spatial/2.0.1" };

// Добавляем справочник для категорий земель
const CATEGORY_MAP = {
    '003001000000': 'Земли сельскохозяйственного назначения',
    '003002000000': 'Земли населенных пунктов',
    '003003000000': 'Земли промышленности, энергетики, транспорта, связи, радиовещания, телевидения, информатики, земли для обеспечения космической деятельности, земли обороны, безопасности и земли специального назначения',
    '003004000000': 'Земли особо охраняемых территорий и объектов',
    '003005000000': 'Земли лесного фонда',
    '003006000000': 'Земли водного фонда',
    '003007000000': 'Земли запаса',
    '003008000000': 'Категория не установлена'
};


function convertXml10to11(oldDoc) {
    const newDoc = document.implementation.createDocument(null, 'extract_cadastral_plan_territory', null);
    const root = newDoc.documentElement;
    root.setAttributeNS('http://www.w3.org/2000/xmlns/', 'xmlns', NS_V11.KPT);
    root.setAttributeNS('http://www.w3.org/2000/xmlns/', 'xmlns:base_e', NS_V11.EXTRACT_BASE);
    root.setAttributeNS('http://www.w3.org/2000/xmlns/', 'xmlns:ad', NS_V11.ADDRESS);
    root.setAttributeNS('http://www.w3.org/2000/xmlns/', 'xmlns:es', NS_V11.SPATIAL);
    const detailsStatement = newDoc.createElement('details_statement');
    const certDoc = oldDoc.querySelector('CertificationDoc');
    if (certDoc) {
        detailsStatement.appendChild(createElementWithText(newDoc, null, 'date_formation', getNodeValue(certDoc, '*|Date')));
        detailsStatement.appendChild(createElementWithText(newDoc, null, 'registration_number', getNodeValue(certDoc, '*|Number')));
        detailsStatement.appendChild(createElementWithText(newDoc, null, 'organ_registr_rights', getNodeValue(certDoc, '*|Organization')));
    }
    root.appendChild(detailsStatement);
    const cadastralBlocks = newDoc.createElement('cadastral_blocks');
    root.appendChild(cadastralBlocks);
    const coordSystemsMap = new Map();
    oldDoc.querySelectorAll('CoordSystems > *|CoordSystem').forEach(cs => {
        coordSystemsMap.set(cs.getAttribute('CsId'), cs.getAttribute('Name'));
    });
    oldDoc.querySelectorAll('Cadastral_Block, CadastralBlock').forEach(oldBlock => {
        const newBlock = newDoc.createElement('cadastral_block');
        newBlock.appendChild(createElementWithText(newDoc, null, 'cadastral_number', oldBlock.getAttribute('CadastralNumber')));
        appendChildIfNotEmpty(newBlock, convertParcels10to11(oldBlock, newDoc, coordSystemsMap));
        appendChildIfNotEmpty(newBlock, convertObjectsRealty10to11(oldBlock, newDoc, coordSystemsMap));
        cadastralBlocks.appendChild(newBlock);
    });
    const serializer = new XMLSerializer();
    let xmlString = serializer.serializeToString(newDoc);
    return `<?xml version="1.0" encoding="UTF-8"?>\n` + xmlString;
}


function convertParcels10to11(oldBlock, newDoc, coordSystemsMap) {
    const recordContainer = newDoc.createElement('record_data');
    oldBlock.querySelectorAll('Parcel').forEach(oldParcel => {
        const landRecord = newDoc.createElement('land_record');
        const object = newDoc.createElement('object');
        const commonData = newDoc.createElement('common_data');
        
        const type = newDoc.createElement('type');
        type.appendChild(createElementWithText(newDoc, null, 'code', '002001001000'));
        type.appendChild(createElementWithText(newDoc, null, 'value', 'Земельный участок'));
        commonData.appendChild(type);

        commonData.appendChild(createElementWithText(newDoc, null, 'cad_number', oldParcel.getAttribute('CadastralNumber')));
        object.appendChild(commonData);
        landRecord.appendChild(object);

        const params = newDoc.createElement('params');
        const area = newDoc.createElement('area');
        area.appendChild(createElementWithText(newDoc, null, 'value', getNodeValue(oldParcel, 'Area > Area')));
        const inaccuracy = getNodeValue(oldParcel, 'Area > Inaccuracy, Area > Innccuracy');
        if (inaccuracy) area.appendChild(createElementWithText(newDoc, null, 'inaccuracy', inaccuracy));
        params.appendChild(area);
        
        const categoryNode = oldParcel.querySelector('Category');
        const categoryCode = categoryNode?.textContent.trim() || categoryNode?.getAttribute('Category') || '';
        if(categoryCode) {
             const category = newDoc.createElement('category');
             const typeCategory = newDoc.createElement('type');
             typeCategory.appendChild(createElementWithText(newDoc, null, 'code', categoryCode));
             if (CATEGORY_MAP[categoryCode]) {
                 typeCategory.appendChild(createElementWithText(newDoc, null, 'value', CATEGORY_MAP[categoryCode]));
             }
             category.appendChild(typeCategory);
             params.appendChild(category);
        }
       
        const utilizationNode = oldParcel.querySelector('Utilization');
        const byDoc = utilizationNode?.getAttribute('ByDoc') || '';
        if (byDoc) {
             const permittedUse = newDoc.createElement('permitted_use');
             const permittedUseEstablished = newDoc.createElement('permitted_use_established'); // Исправлено: добавлен вложенный тег
             permittedUseEstablished.appendChild(createElementWithText(newDoc, null, 'by_document', byDoc));
             permittedUse.appendChild(permittedUseEstablished);
             params.appendChild(permittedUse);
        }
        landRecord.appendChild(params);

        const cost = oldParcel.querySelector('CadastralCost');
        if (cost) {
            const costNode = newDoc.createElement('cost');
            costNode.appendChild(createElementWithText(newDoc, null, 'value', cost.getAttribute('Value')));
            landRecord.appendChild(costNode); // Исправлено: добавлялся не тот узел
        }

        landRecord.appendChild(convertAddress10to11(oldParcel.querySelector('Location > Address'), newDoc));
        
        const oldSpatial = oldParcel.querySelector('Entity_Spatial, EntitySpatial');
        if (oldSpatial) {
            const contoursLocation = newDoc.createElement('contours_location');
            contoursLocation.appendChild(convertSpatial10to11(oldSpatial, newDoc, coordSystemsMap));
            landRecord.appendChild(contoursLocation);
        }

        recordContainer.appendChild(landRecord);
    });
    return recordContainer;
}


function convertObjectsRealty10to11(oldBlock, newDoc, coordSystemsMap) {
    const recordContainer = newDoc.createElement('record_data');
    oldBlock.querySelectorAll('ObjectRealty').forEach(oldObj => {
        const oldBuilding = oldObj.querySelector('Building');
        if (oldBuilding) {
            const buildRecord = newDoc.createElement('build_record');
            const object = newDoc.createElement('object');
            const commonData = newDoc.createElement('common_data');
            
            // --- ИЗМЕНЕНИЕ ЗДЕСЬ: Добавляем тип объекта ---
            const type = newDoc.createElement('type');
            // Используем код из старой схемы если есть, иначе - по умолчанию
            const typeCode = getNodeValue(oldBuilding, 'ObjectType') || '002001002000';
            type.appendChild(createElementWithText(newDoc, null, 'code', typeCode));
            type.appendChild(createElementWithText(newDoc, null, 'value', 'Здание')); // Значение всегда "Здание"
            commonData.appendChild(type);
            // --- КОНЕЦ ИЗМЕНЕНИЯ ---

            commonData.appendChild(createElementWithText(newDoc, null, 'cad_number', oldBuilding.getAttribute('CadastralNumber')));
            object.appendChild(commonData);
            buildRecord.appendChild(object);
            const params = newDoc.createElement('params');
            const purpose = newDoc.createElement('purpose');
            purpose.appendChild(createElementWithText(newDoc, null, 'code', getNodeValue(oldBuilding, 'AssignationBuilding')));
            params.appendChild(purpose);
            params.appendChild(createElementWithText(newDoc, null, 'area', getNodeValue(oldBuilding, 'Area')));
            buildRecord.appendChild(params);
            buildRecord.appendChild(convertAddress10to11(oldBuilding.querySelector('Location > Address'), newDoc));
            const oldSpatial = oldBuilding.querySelector('Entity_Spatial, EntitySpatial');
            if(oldSpatial) {
                const contours = newDoc.createElement('contours');
                contours.appendChild(convertSpatial10to11(oldSpatial, newDoc, coordSystemsMap));
                buildRecord.appendChild(contours);
            }
            recordContainer.appendChild(buildRecord);
        }
    });
    return recordContainer;
}

function convertAddress10to11(oldAddress, newDoc) {
    const addressLocation = newDoc.createElement('address_location');
    if (!oldAddress) return addressLocation;

    const address = newDoc.createElement('address');

    // --- ИСПРАВЛЕНИЕ: ПРИОРИТЕТ ДЛЯ <Note> ---
    // 1. Сначала извлекаем полный адрес из тега Note
    const readableAddressText = getNodeValue(oldAddress, '*|Note, Note');
    if (readableAddressText) {
        address.appendChild(createElementWithText(newDoc, null, 'readable_address', readableAddressText));
    }

    // 2. Затем, по возможности, собираем структурированный адрес ФИАС
    const addressFias = newDoc.createElement('address_fias');
    const levelSettlement = newDoc.createElement('level_settlement');
    
    const okato = getNodeValue(oldAddress, '*|OKATO, Code_OKATO');
    if (okato) levelSettlement.appendChild(createElementWithText(newDoc, null, 'okato', okato));
    
    const kladr = getNodeValue(oldAddress, '*|KLADR, Code_KLADR');
    if (kladr) levelSettlement.appendChild(createElementWithText(newDoc, null, 'kladr', kladr));

    const postalCode = getNodeValue(oldAddress, '*|PostalCode, PostalCode');
     if (postalCode) levelSettlement.appendChild(createElementWithText(newDoc, null, 'postal_code', postalCode));
    
    const regionCode = getNodeValue(oldAddress, '*|Region, Region');
    if (regionCode) {
        const region = newDoc.createElement('region');
        region.appendChild(createElementWithText(newDoc, null, 'code', regionCode));
        levelSettlement.appendChild(region);
    }
    
    const district = oldAddress.querySelector('*|District, District');
    if(district) {
        const districtNode = newDoc.createElement('district');
        districtNode.appendChild(createElementWithText(newDoc, null, 'type_district', district.getAttribute('Type')));
        districtNode.appendChild(createElementWithText(newDoc, null, 'name_district', district.getAttribute('Name')));
        levelSettlement.appendChild(districtNode);
    }

    const city = oldAddress.querySelector('*|City, City');
    if(city) {
        const cityNode = newDoc.createElement('city');
        cityNode.appendChild(createElementWithText(newDoc, null, 'type_city', city.getAttribute('Type')));
        cityNode.appendChild(createElementWithText(newDoc, null, 'name_city', city.getAttribute('Name')));
        levelSettlement.appendChild(cityNode);
    }
    
    if (levelSettlement.hasChildNodes()) {
        addressFias.appendChild(levelSettlement);
    }

    const detailedLevel = newDoc.createElement('detailed_level');
    const street = oldAddress.querySelector('*|Street, Street');
    if (street) {
        const streetNode = newDoc.createElement('street');
        streetNode.appendChild(createElementWithText(newDoc, null, 'type_street', street.getAttribute('Type')));
        streetNode.appendChild(createElementWithText(newDoc, null, 'name_street', street.getAttribute('Name')));
        detailedLevel.appendChild(streetNode);
    }

    const level1 = oldAddress.querySelector('*|Level1, Level1');
    if (level1) {
        const level1Node = newDoc.createElement('level1');
        level1Node.appendChild(createElementWithText(newDoc, null, 'type_level1', level1.getAttribute('Type')));
        level1Node.appendChild(createElementWithText(newDoc, null, 'name_level1', level1.getAttribute('Value')));
        detailedLevel.appendChild(level1Node);
    }
    
    if (detailedLevel.hasChildNodes()) {
        addressFias.appendChild(detailedLevel);
    }

    if (addressFias.hasChildNodes()) {
        address.appendChild(addressFias);
    }
    
    // 3. Добавляем итоговый блок <address> в <address_location>, только если он не пустой
    if (address.hasChildNodes()) {
        addressLocation.appendChild(address);
    }
    
    return addressLocation;
}

function convertSpatial10to11(oldSpatial, newDoc, coordSystemsMap) {
    const newSpatial = newDoc.createElement('entity_spatial');
    const entSys = oldSpatial.getAttribute('EntSys') || oldSpatial.getAttribute('Ent_Sys');
    const skId = coordSystemsMap.get(entSys) || (entSys ? `ID${entSys}` : 'UNKNOWN');
    newSpatial.appendChild(createElementWithText(newDoc, null, 'sk_id', skId));
    const spatialsElements = newDoc.createElement('spatials_elements');
    oldSpatial.querySelectorAll('Spatial_Element, *|SpatialElement').forEach(oldElement => {
        const spatialElement = newDoc.createElement('spatial_element');
        const ordinates = newDoc.createElement('ordinates');
        oldElement.querySelectorAll('Spelement_Unit, *|SpelementUnit').forEach(oldUnit => {
            const oldOrd = oldUnit.querySelector('Ordinate, *|Ordinate');
            if (oldOrd) {
                const ordinate = newDoc.createElement('ordinate');
                ordinate.appendChild(createElementWithText(newDoc, null, 'x', oldOrd.getAttribute('X')));
                ordinate.appendChild(createElementWithText(newDoc, null, 'y', oldOrd.getAttribute('Y')));
                const suNmb = oldUnit.getAttribute('SuNmb') || oldUnit.getAttribute('Su_Nmb');
                if(suNmb) ordinate.appendChild(createElementWithText(newDoc, null, 'ord_nmb', suNmb));
                const numGeopoint = oldOrd.getAttribute('NumGeopoint') || oldOrd.getAttribute('Num_Geopoint');
                if (numGeopoint) ordinate.appendChild(createElementWithText(newDoc, null, 'num_geopoint', numGeopoint));
                const delta = oldOrd.getAttribute('DeltaGeopoint') || oldOrd.getAttribute('Delta_Geopoint');
                if (delta) ordinate.appendChild(createElementWithText(newDoc, null, 'delta_geopoint', delta));
                const zacrep = oldOrd.getAttribute('GeopointZacrep');
                if(zacrep) ordinate.appendChild(createElementWithText(newDoc, null, 'geopoint_zacrep', zacrep));
                ordinates.appendChild(ordinate);
            }
        });
        spatialElement.appendChild(ordinates);
        spatialsElements.appendChild(spatialElement);
    });
    newSpatial.appendChild(spatialsElements);
    return newSpatial;
}
</script>
</body>
</html>