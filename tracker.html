<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Трекер</title>
    <link rel="icon" href="https://img.icons8.com/?size=100&id=2QJGabZSZCjy&format=png&color=000000" type="image/png">
    <script src="https://api-maps.yandex.ru/2.1/?apikey=dde71a0e-b612-44b7-b53b-82533420240f&lang=ru_RU" type="text/javascript"></script>
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <style>
        html, body { height: 100%; margin: 0; padding: 0; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; overflow: hidden; background-color: #f4f4f4; }
        #map { width: 100%; height: 100%; position: absolute; top: 0; left: 0; z-index: 1; }
        #login-modal { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.6); display: flex; justify-content: center; align-items: center; z-index: 1000; }
        #login-form { background-color: white; padding: 35px 45px; border-radius: 12px; box-shadow: 0 5px 20px rgba(0, 0, 0, 0.15); text-align: center; width: 90%; max-width: 380px; box-sizing: border-box; }
        #login-form h2 { margin-top: 0; margin-bottom: 25px; color: #333; font-weight: 600; }
        #login-form label { display: block; margin-bottom: 8px; text-align: left; color: #555; font-weight: 500; font-size: 0.95em; }
        #login-form input { width: 100%; padding: 12px 15px; margin-bottom: 20px; border: 1px solid #ccc; border-radius: 6px; box-sizing: border-box; font-size: 1em; }
        #login-form input:focus { border-color: #007bff; outline: none; box-shadow: 0 0 0 2px rgba(0, 123, 255, 0.2); }
        #login-form input:invalid { border-color: #dc3545; }
        #login-form button { background-color: #007bff; color: white; padding: 14px 25px; border: none; border-radius: 6px; cursor: pointer; font-size: 1.05em; font-weight: 500; transition: background-color 0.3s ease, transform 0.1s ease; width: 100%; margin-top: 10px; }
        #login-form button:hover { background-color: #0056b3; }
        #login-form button:active { transform: scale(0.98); }
        #login-form button:disabled { background-color: #6c757d; cursor: not-allowed; }
        #login-error { color: #dc3545; margin-top: 15px; min-height: 1.2em; font-size: 0.9em; font-weight: 500; }
        .hidden { display: none !important; }
        #users-panel { position: absolute; top: 15px; left: 15px; background-color: rgba(255, 255, 255, 0.95); backdrop-filter: blur(5px); border-radius: 10px; box-shadow: 0 4px 15px rgba(0, 0, 0, 0.15); z-index: 100; max-height: calc(100vh - 100px); overflow-y: auto; width: 280px; padding: 0; box-sizing: border-box; border: 1px solid rgba(0,0,0,0.05); }
        #users-panel h3 { margin: 0; padding: 15px 20px; color: #333; font-size: 1.1em; font-weight: 600; border-bottom: 1px solid #e0e0e0; background-color: rgba(248, 249, 250, 0.8); border-top-left-radius: 10px; border-top-right-radius: 10px; position: sticky; top: 0; z-index: 1; }
        #users-list { padding: 10px 10px 15px 10px; }
        .user-item { display: flex; align-items: center; padding: 12px 15px; margin-bottom: 5px; border-radius: 6px; cursor: pointer; transition: background-color 0.2s ease, border-left 0.2s ease; border-left: 4px solid transparent; }
        .user-item:hover { background-color: #f1f3f5; }
        .user-item.active { background-color: #e9ecef; border-left: 4px solid #007bff; }
        .user-color { width: 24px; height: 24px; border-radius: 50%; margin-right: 12px; border: 1px solid rgba(0,0,0,0.1); flex-shrink: 0; }
        .user-details { display: flex; flex-direction: column; flex-grow: 1; overflow: hidden; }
        .user-name { font-weight: 500; color: #343a40; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; font-size: 0.95em; line-height: 1.2; }
        .user-last-update { font-size: 0.8em; color: #6c757d; line-height: 1.2; margin-top: 2px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .user-item.active .user-name { font-weight: 600; }
        .user-item.active .user-last-update { color: #495057; }
        .no-users { color: #6c757d; font-style: italic; text-align: center; padding: 20px 15px; font-size: 0.9em; }
        #users-panel::-webkit-scrollbar { width: 6px; }
        #users-panel::-webkit-scrollbar-track { background: #f1f1f1; border-radius: 10px; }
        #users-panel::-webkit-scrollbar-thumb { background: #adb5bd; border-radius: 10px; }
        #users-panel::-webkit-scrollbar-thumb:hover { background: #868e96; }
         #controls-panel { position: absolute; bottom: 15px; left: 15px; background-color: rgba(255, 255, 255, 0.95); backdrop-filter: blur(5px); border-radius: 10px; box-shadow: 0 4px 15px rgba(0, 0, 0, 0.15); z-index: 100; padding: 10px 15px; display: flex; gap: 10px; align-items: center; border: 1px solid rgba(0,0,0,0.05); flex-wrap: wrap; }
         .control-button { color: white; padding: 8px 15px; border: none; border-radius: 6px; cursor: pointer; font-size: 0.9em; font-weight: 500; transition: background-color 0.3s ease, transform 0.1s ease; }
         .control-button:hover { filter: brightness(90%); }
         .control-button:active { transform: scale(0.98); }
         .control-button:disabled { background-color: #6c757d !important; cursor: not-allowed; }
         #delete-button { background-color: #dc3545; }
         #lock-button { background-color: #ffc107; color: #212529; }
         #lock-button.locked { background-color: #28a745; color: white; }

    </style>
</head>
<body>

    <div id="login-modal">
        <div id="login-form">
            <h2>Вход в Трекер</h2>
            <label for="session-id">ID Сессии (мин 7 знаков):</label>
            <input type="text" id="session-id" name="session_id" required minlength="7"
                   pattern=".{7,}" title="Введите ID сессии (7 знаков)">
            <label for="user-name">Ваше Имя:</label>
            <input type="text" id="user-name" name="name" required>
     <label for="update-interval">
  Программа отслеживает местоположение.<br>
  Интервал отправки своих координат (сек):
</label>
            <input type="number" id="update-interval" name="update_interval" value="30" min="15" max="300" placeholder="5-300" title="Как часто отправлять СВОИ координаты на сервер">
            <button type="button" id="login-button">Войти / Присоединиться</button>
            <div id="login-error"></div>
        </div>
    </div>

    <div id="map" class="hidden"></div>

    <div id="users-panel" class="hidden">
        <h3 id="session-title">Сессия: Загрузка...</h3>
        <div id="users-list">
            <div class="no-users">Нет активных пользователей</div>
        </div>
    </div>

     <div id="controls-panel" class="hidden">
         <button id="delete-button" class="control-button">Удалить данные сессии</button>
         <button id="lock-button" class="control-button">Запретить вход новым</button>
     </div>


    <script>
        const SUPABASE_URL = "https://krbqraivfbowmzvucjxz.supabase.co";
        const SUPABASE_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImtyYnFyYWl2ZmJvd216dnVjanh6Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDU1MDA0MTAsImV4cCI6MjA2MTA3NjQxMH0.Aun2UJDEW_75_Di-2hIcap42gqyZAu2XY9xiZpmShPc";
        const supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_KEY);

        let myMap;
        let myPlacemark = null;
        let otherPlacemarks = {};
        let currentSessionId = null;
        let currentUserName = null;
        let myClientId = null;
        let userPresets = {};
        let isLoggingIn = false;
        let watchId = null;
        let lastKnownCoords = null;
        let updateIntervalMs = 30 * 1000;
        let periodicUpdateTimerId = null;
        let sessionChannel = null;
        let sessionEncryptionKey = null;
        const KDF_ITERATIONS = 100000;
        const SALT_PREFIX = "tracker-salt:";
        const LOCK_RECORD_USERNAME = "__SESSION_LOCKED__";

        const loginModal = document.getElementById('login-modal');
        const loginForm = document.getElementById('login-form');
        const sessionIdInput = document.getElementById('session-id');
        const userNameInput = document.getElementById('user-name');
        const updateIntervalInput = document.getElementById('update-interval');
        const loginButton = document.getElementById('login-button');
        const loginError = document.getElementById('login-error');
        const mapContainer = document.getElementById('map');
        const usersPanel = document.getElementById('users-panel');
        const usersList = document.getElementById('users-list');
        const sessionTitle = document.getElementById('session-title');
        const controlsPanel = document.getElementById('controls-panel');
        const deleteButton = document.getElementById('delete-button');
        const lockButton = document.getElementById('lock-button');

        const PRESETS_WITH_CAPTIONS = [
            'islands#greenDotIconWithCaption', 'islands#redDotIconWithCaption',
            'islands#violetDotIconWithCaption', 'islands#darkOrangeDotIconWithCaption',
            'islands#yellowDotIconWithCaption', 'islands#darkBlueIconWithCaption', // Changed to darkBlueIcon to avoid caption overlap
            'islands#nightDotIconWithCaption', 'islands#pinkDotIconWithCaption',
            'islands#grayDotIconWithCaption', 'islands#lightBlueDotIconWithCaption',
            'islands#brownDotIconWithCaption', 'islands#oliveDotIconWithCaption'
        ];
        const PRESET_TO_COLOR = {
            'islands#blueDotIconWithCaption': '#1E98FF', 'islands#greenDotIconWithCaption': '#56DB40',
            'islands#redDotIconWithCaption': '#FF4040', 'islands#violetDotIconWithCaption': '#B842F5',
            'islands#darkOrangeDotIconWithCaption': '#FF931E', 'islands#yellowDotIconWithCaption': '#FFD91E',
            'islands#darkBlueDotIconWithCaption': '#177BC9', 'islands#nightDotIconWithCaption': '#424A5C',
            'islands#pinkDotIconWithCaption': '#F542AD', 'islands#grayDotIconWithCaption': '#AAAAAA',
            'islands#lightBlueDotIconWithCaption': '#82CDFF', 'islands#brownDotIconWithCaption': '#A0522D',
            'islands#oliveDotIconWithCaption': '#808000', 'islands#darkBlueIconWithCaption': '#177BC9' // Added darkBlueIcon
        };

        function showLoginError(message) {
            loginError.textContent = message;
        }

        function getRandomPreset(userId) {
            if (userPresets[userId]) return userPresets[userId];
            let hash = 0;
            if (!userId || userId.length === 0) return PRESETS_WITH_CAPTIONS[0];
            for (let i = 0; i < userId.length; i++) {
                const char = userId.charCodeAt(i);
                hash = ((hash << 5) - hash) + char;
                hash = hash & hash;
            }
            const presetIndex = Math.abs(hash) % PRESETS_WITH_CAPTIONS.length;
            userPresets[userId] = PRESETS_WITH_CAPTIONS[presetIndex];
            return userPresets[userId];
        }

        function formatTimeAgo(timestampStr) {
            if (!timestampStr) return 'нет данных';
            const lastUpdate = new Date(timestampStr);
            const now = new Date();
            const secondsAgo = Math.round((now.getTime() - lastUpdate.getTime()) / 1000);
            if (secondsAgo < 5) return 'только что';
            if (secondsAgo < 60) return `${secondsAgo} сек назад`;
            if (secondsAgo < 3600) return `${Math.floor(secondsAgo / 60)} мин назад`;
            if (secondsAgo < 86400) return `${Math.floor(secondsAgo / 3600)} ч назад`;
            const day = String(lastUpdate.getDate()).padStart(2, '0');
            const month = String(lastUpdate.getMonth() + 1).padStart(2, '0');
            const hours = String(lastUpdate.getHours()).padStart(2, '0');
            const minutes = String(lastUpdate.getMinutes()).padStart(2, '0');
            return `${day}.${month} ${hours}:${minutes}`;
        }

        function arrayBufferToBase64(buffer) {
            let binary = '';
            const bytes = new Uint8Array(buffer);
            const len = bytes.byteLength;
            for (let i = 0; i < len; i++) {
                binary += String.fromCharCode(bytes[i]);
            }
            return window.btoa(binary);
        }

        function base64ToArrayBuffer(base64) {
            const binary_string = window.atob(base64);
            const len = binary_string.length;
            const bytes = new Uint8Array(len);
            for (let i = 0; i < len; i++) {
                bytes[i] = binary_string.charCodeAt(i);
            }
            return bytes.buffer;
        }

        async function deriveKey(secretPart, saltString) {
            try {
                const encoder = new TextEncoder();
                const today = new Date();
                const year = today.getFullYear();
                const month = String(today.getMonth() + 1).padStart(2, '0');
                const day = String(today.getDate()).padStart(2, '0');
                const dateString = `${year}${month}${day}`;
                const combinedSecret = secretPart + dateString;
                const secretBuffer = encoder.encode(combinedSecret);
                const saltBuffer = encoder.encode(SALT_PREFIX + saltString);
                const importedSecretKey = await window.crypto.subtle.importKey(
                    "raw", secretBuffer, { name: "PBKDF2" }, false, ["deriveKey"]
                );
                const derivedAesKey = await window.crypto.subtle.deriveKey(
                    { name: "PBKDF2", salt: saltBuffer, iterations: KDF_ITERATIONS, hash: "SHA-256" },
                    importedSecretKey,
                    { name: "AES-GCM", length: 256 },
                    true, ["encrypt", "decrypt"]
                );
                return derivedAesKey;
            } catch (error) {
                console.error("❌ Error deriving key:", error);
                throw new Error("Не удалось создать ключ.");
            }
        }

        async function encryptCoords(lat, lon, key) {
            if (!key) throw new Error("Ключ не установлен.");
            try {
                const encoder = new TextEncoder();
                const dataString = JSON.stringify({ lat, lon });
                const dataBuffer = encoder.encode(dataString);
                const iv = window.crypto.getRandomValues(new Uint8Array(12));
                const encryptedData = await window.crypto.subtle.encrypt(
                    { name: "AES-GCM", iv: iv }, key, dataBuffer
                );
                const combinedBuffer = new Uint8Array(iv.length + encryptedData.byteLength);
                combinedBuffer.set(iv, 0);
                combinedBuffer.set(new Uint8Array(encryptedData), iv.length);
                const base64String = arrayBufferToBase64(combinedBuffer.buffer);
                return base64String;
            } catch (error) {
                console.error("❌ Error encrypting coordinates:", error);
                throw new Error("Ошибка шифрования координат.");
            }
        }

        async function decryptCoords(base64String, key) {
            if (!key) throw new Error("Ключ не установлен.");
            if (!base64String) return null;
            try {
                const combinedBuffer = base64ToArrayBuffer(base64String);
                const iv = combinedBuffer.slice(0, 12);
                const encryptedData = combinedBuffer.slice(12);
                if (iv.byteLength !== 12) throw new Error("Invalid IV length.");
                if (encryptedData.byteLength === 0) throw new Error("Encrypted data empty.");
                const decryptedBuffer = await window.crypto.subtle.decrypt(
                    { name: "AES-GCM", iv: iv }, key, encryptedData
                );
                const decoder = new TextDecoder();
                const decryptedString = decoder.decode(decryptedBuffer);
                const coords = JSON.parse(decryptedString);
                if (typeof coords.lat !== 'number' || typeof coords.lon !== 'number') {
                     throw new Error("Decrypted data is not valid coords.");
                }
                return coords;
            } catch (error) {
                console.error("❌ Error decrypting coordinates:", error);
                return null;
            }
        }

        async function handleLogin() {
            if (isLoggingIn) return;
            isLoggingIn = true;
            const fullSessionInput = sessionIdInput.value.trim();
            const userName = userNameInput.value.trim();
            const requestedUpdateInterval = parseInt(updateIntervalInput.value, 10);

            showLoginError('');

            if (fullSessionInput.length < 7) {
                showLoginError('ID Сессии должен содержать минимум 7 знаков.');
                isLoggingIn = false; return;
            }
            if (!userName) {
                showLoginError('Пожалуйста, введите ваше имя.');
                isLoggingIn = false; return;
            }
            if (userName === LOCK_RECORD_USERNAME) {
                 showLoginError(`Имя "${LOCK_RECORD_USERNAME}" зарезервировано.`);
                 isLoggingIn = false; return;
            }
            if (isNaN(requestedUpdateInterval) || requestedUpdateInterval < 5 || requestedUpdateInterval > 300) {
                showLoginError('Интервал обновления должен быть от 5 до 300 секунд.');
                isLoggingIn = false; return;
            }
            updateIntervalMs = requestedUpdateInterval * 1000;

            loginButton.disabled = true;
            loginButton.textContent = 'Вход...';
            sessionEncryptionKey = null;

            try {
                const secretPart = fullSessionInput.slice(-3);
                const saltPart = fullSessionInput.slice(0, -3);

                if (!saltPart || !secretPart || secretPart.length !== 3) {
                    showLoginError('Не удалось обработать ID сессии.');
                    throw new Error('Invalid session input format for splitting.');
                }
                 console.log(`Processing Session ID: "${fullSessionInput}"`);

                sessionEncryptionKey = await deriveKey(secretPart, saltPart);
                if (!sessionEncryptionKey) {
                    showLoginError("Критическая ошибка: не удалось подготовить сессию.");
                    throw new Error("Failed to derive key.");
                }

                // Check if session is locked using limit(1) instead of single()
                const { data: lockCheckData, error: lockCheckError } = await supabase
                    .from('tracker')
                    .select('client_id')
                    .eq('session_id', fullSessionInput)
                    .eq('user_name', LOCK_RECORD_USERNAME)
                    .limit(1); // Removed .single()

                // With limit(1) and no single(), error will only be non-null for actual query errors, not 'no rows found'
                if (lockCheckError) {
                    console.error("Error checking session lock:", lockCheckError);
                    throw new Error("Ошибка проверки статуса сессии.");
                }

                // Check if data is an array and contains at least one element
                const isLocked = Array.isArray(lockCheckData) && lockCheckData.length > 0;

                if (isLocked) {
                    const { data: userCheckData, error: userCheckError } = await supabase
                        .from('tracker')
                        .select('client_id')
                        .eq('session_id', fullSessionInput)
                        .eq('user_name', userName)
                        .limit(1)
                        .single();

                     if (userCheckError && userCheckError.code !== 'PGRST116') {
                         console.error("Error checking existing user:", userCheckError);
                         throw new Error("Ошибка проверки существующего пользователя.");
                     }

                     if (!userCheckData) {
                         showLoginError("Вход для новых участников в эту сессию запрещен.");
                         isLoggingIn = false;
                         loginButton.disabled = false;
                         loginButton.textContent = 'Войти / Присоединиться';
                         return;
                     }
                     console.log("Session is locked, but user already exists. Allowing login.");
                }

                const newClientId = crypto.randomUUID();
                const { data, error } = await supabase
                    .from('tracker')
                    .upsert({
                        session_id: fullSessionInput,
                        user_name: userName,
                        client_id: newClientId,
                        lat: null,
                        lon: null,
                        location_data: null,
                        last_update: new Date().toISOString()
                    }, {
                        onConflict: 'session_id, user_name'
                    })
                    .select()
                    .single();

                if (error) {
                    console.error('❌ Supabase login/upsert error:', error);
                    sessionEncryptionKey = null;
                    if (error.status === 400) {
                        showLoginError(`Ошибка запроса (400).`);
                    } else if (error.message && error.message.includes("column") && error.message.includes("does not exist")) {
                         showLoginError(`Ошибка БД: Колонка не найдена.`);
                    } else if (error.code === '23505') {
                        showLoginError(`Ошибка: Конфликт данных.`);
                    } else {
                        showLoginError(`Ошибка входа: ${error.message || 'Неизвестная ошибка'}`);
                    }
                     throw error;
                } else if (data) {
                    currentSessionId = data.session_id;
                    currentUserName = data.user_name;
                    myClientId = data.client_id;

                    loginModal.classList.add('hidden');
                    mapContainer.classList.remove('hidden');
                    usersPanel.classList.remove('hidden');
                    controlsPanel.classList.remove('hidden');
                    deleteButton.disabled = false; // Ensure delete button is enabled on successful login

                    sessionTitle.textContent = `Сессия: ${currentSessionId}`;
                    deleteButton.textContent = `Удалить данные сессии ${currentSessionId}`;

                    setTimeout(() => {
                        if (!myMap) {
                            ymaps.ready(initMap);
                        }
                         requestUserLocation();
                         startPeriodicUpdates();
                         if (!sessionChannel) {
                             subscribeToSessionChanges();
                         }
                         fetchAndDisplayAllUsersInSession(); // This will also call checkSessionLockStatus
                    }, 50);

                } else {
                    sessionEncryptionKey = null;
                    showLoginError('Неизвестная ошибка входа.');
                    throw new Error('Unknown login error.');
                }
            } catch (error) {
                console.error('❌ Error during login process:', error);
                sessionEncryptionKey = null;
                if (!loginError.textContent) {
                     showLoginError(`Критическая ошибка входа: ${error.message || 'Неизвестная ошибка'}.`);
                }
                loginButton.disabled = false;
                loginButton.textContent = 'Войти / Присоединиться';
                isLoggingIn = false;
            } finally {
                 if (!currentSessionId || !myClientId) {
                    isLoggingIn = false;
                 }
            }
        }

        async function sendMyLocationToSupabase(lat, lon) {
            if (!currentSessionId || !myClientId || !sessionEncryptionKey) {
                return;
            }
            lastKnownCoords = [lat, lon];

            try {
                const encryptedLocation = await encryptCoords(lat, lon, sessionEncryptionKey);
                const { error } = await supabase
                    .from('tracker')
                    .update({
                        location_data: encryptedLocation,
                        lat: null,
                        lon: null,
                        last_update: new Date().toISOString()
                    })
                    .eq('session_id', currentSessionId)
                    .eq('client_id', myClientId);

                if (error) {
                    console.error('❌ Supabase update location error:', error);
                    if (error.code === 'PGRST301' || (error.message && error.message.includes('Policy enforcement error'))) {
                        handleSessionEnd("Ошибка обновления.");
                    } else {
                        console.warn(`Could not update location: ${error.message}`);
                    }
                }
            } catch (error) {
                console.error('❌ Unexpected error sending location:', error);
            }
        }

        function periodicLocationUpdate() {
            if (lastKnownCoords && sessionEncryptionKey) {
                sendMyLocationToSupabase(lastKnownCoords[0], lastKnownCoords[1]);
            }
        }

        function requestUserLocation() {
            if (navigator.geolocation) {
                 if (watchId !== null) {
                     navigator.geolocation.clearWatch(watchId);
                     watchId = null;
                 }
                 watchId = navigator.geolocation.watchPosition(
                      handleLocationUpdate, handleLocationError,
                      { enableHighAccuracy: true, timeout: 15000, maximumAge: 5000 }
                 );
                 navigator.geolocation.getCurrentPosition(
                     (position) => {
                        const coords = [position.coords.latitude, position.coords.longitude];
                        if(sessionEncryptionKey) {
                             updateMyMapPosition(coords, true);
                             sendMyLocationToSupabase(coords[0], coords[1]);
                        }
                     },
                     (error) => { console.warn(`⚠️ Initial position error (${error.code}): ${error.message}`); },
                     { enableHighAccuracy: true, timeout: 10000, maximumAge: 0 }
                 );
            } else {
                alert("Браузер не поддерживает геолокацию.");
            }
        }

        function handleLocationUpdate(position) {
             if(sessionEncryptionKey) {
                 const coords = [position.coords.latitude, position.coords.longitude];
                 updateMyMapPosition(coords, false);
                 sendMyLocationToSupabase(coords[0], coords[1]);
             }
        }

        function handleLocationError(error) {
             console.warn(`⚠️ watchPosition error (${error.code}): ${error.message}`);
             let errorMessage = "Ошибка отслеживания местоположения.";
             if (error.code === error.PERMISSION_DENIED) {
                 errorMessage = "Отслеживание остановлено: доступ запрещен.";
                 if (watchId !== null && navigator.geolocation) {
                     navigator.geolocation.clearWatch(watchId); watchId = null;
                 }
                 stopPeriodicUpdates();
                 alert(errorMessage);
             }
        }

        function initMap() {
             if (myMap) { myMap.destroy(); myMap = null; }
             mapContainer.innerHTML = '';
            myMap = new ymaps.Map("map", {
                center: [55.751244, 37.618423], zoom: 10,
                controls: ['zoomControl', 'geolocationControl', 'fullscreenControl', 'typeSelector']
            }, { typeSelectorSize: 'medium', typeSelectorPosition: { top: '15px', right: '15px' } });
            fetchAndDisplayAllUsersInSession();
        }

        function updateMyMapPosition(coords, centerMap = false) {
             if (!myMap || !myClientId || !currentUserName) return;
             const selfPreset = 'islands#blueDotIconWithCaption';
             if (myPlacemark) {
                 myPlacemark.geometry.setCoordinates(coords);
                 myPlacemark.properties.set({
                     iconCaption: `${currentUserName} (Вы)`,
                     hintContent: `${currentUserName} (Вы)<br>только что`
                 });
             } else {
                 myPlacemark = new ymaps.Placemark(coords, {
                     iconCaption: `${currentUserName} (Вы)`, hintContent: `${currentUserName} (Вы)<br>только что`
                 }, { preset: selfPreset, iconCaptionMaxWidth: '150', hideIconOnBalloonOpen: false });
                 myMap.geoObjects.add(myPlacemark);
                 myPlacemark.events.add('click', () => centerMapOnUser(myClientId));
             }
             if (centerMap) {
                 myMap.panTo(coords, { flying: true, duration: 800 })
                     .then(() => { if (myMap.getZoom() < 12) { myMap.setZoom(15, { duration: 500 }); } })
                     .catch(err => console.error("❌ Map pan error:", err));
             }
        }

        async function fetchAndDisplayAllUsersInSession() {
            console.log("➡️ fetchAndDisplayAllUsersInSession called.");
            if (!currentSessionId || !myMap || !sessionEncryptionKey) {
                console.warn("🚫 Cannot fetch users: Session ID, Map or Key not ready.");
                usersList.innerHTML = '<div class="no-users">Не удалось загрузить список.</div>';
                return;
            }
            try {
                const { data, error } = await supabase
                    .from('tracker')
                    .select('client_id, user_name, location_data, last_update')
                    .eq('session_id', currentSessionId);

                if (error) {
                    console.error('❌ Supabase fetch error:', error);
                    if (error.code === 'PGRST301') { handleSessionEnd("Ошибка загрузки."); }
                    else { showLoginError(`Ошибка данных: ${error.message}`); usersList.innerHTML = '<div class="no-users" style="color: red;">Ошибка данных</div>'; }
                    return;
                }
                if (data) {
                    console.log(`✅ Fetched ${data.length} records.`);
                    const filteredData = data.filter(user => user.user_name !== LOCK_RECORD_USERNAME);
                     const decryptedUsers = await Promise.all(filteredData.map(async (user) => {
                         const decryptedCoords = await decryptCoords(user.location_data, sessionEncryptionKey);
                         return { ...user, lat: decryptedCoords?.lat ?? null, lon: decryptedCoords?.lon ?? null, decryption_error: !decryptedCoords && !!user.location_data };
                    }));
                    console.log('Decrypted data prepared:', decryptedUsers.length);
                    updateMapAndUsersPanel(decryptedUsers);
                    showLoginError('');
                    checkSessionLockStatus(); // Check lock status after fetching users
                } else {
                    console.log("No data for session fetch.");
                    updateMapAndUsersPanel([]);
                    showLoginError('');
                }
            } catch (error) {
                console.error('❌ Unexpected error fetching/decrypting:', error);
                showLoginError('Ошибка сети или дешифровки.');
                usersList.innerHTML = '<div class="no-users" style="color: red;">Ошибка сети/дешифровки</div>';
            }
            console.log("➡️ fetchAndDisplayAllUsersInSession finished.");
        }

        function updateMapAndUsersPanel(users) {
            console.log("➡️ updateMapAndUsersPanel users:", users.length);
            if (!myMap) return;
            const activeClientIds = new Set(users.map(u => u.client_id));
            const currentOthersOnMap = new Set(Object.keys(otherPlacemarks));
            users.forEach(user => {
                const clientId = user.client_id;
                const coords = (user.lat !== null && user.lon !== null) ? [user.lat, user.lon] : null;
                if (clientId === myClientId) {
                    if (coords) {
                        if (myPlacemark) {
                             myPlacemark.geometry.setCoordinates(coords);
                              myPlacemark.properties.set({ iconCaption: `${currentUserName} (Вы)`, hintContent: `${currentUserName} (Вы)<br>${formatTimeAgo(user.last_update)}` });
                         } else { updateMyMapPosition(coords, false); }
                         if (myPlacemark && myMap.geoObjects.indexOf(myPlacemark) === -1) { myMap.geoObjects.add(myPlacemark); }
                    } else { if (myPlacemark && myMap.geoObjects.indexOf(myPlacemark) !== -1) { myMap.geoObjects.remove(myPlacemark); } }
                    return;
                }
                if (coords) {
                    const userName = user.user_name; const userPreset = getRandomPreset(clientId); const lastUpdateText = formatTimeAgo(user.last_update);
                    if (otherPlacemarks[clientId]) {
                        otherPlacemarks[clientId].geometry.setCoordinates(coords);
                        otherPlacemarks[clientId].properties.set({ iconCaption: userName, hintContent: `${userName}<br>${lastUpdateText}` });
                        if (otherPlacemarks[clientId].options.get('preset') !== userPreset) { otherPlacemarks[clientId].options.set('preset', userPreset); }
                         if (myMap.geoObjects.indexOf(otherPlacemarks[clientId]) === -1) { myMap.geoObjects.add(otherPlacemarks[clientId]); }
                    } else {
                        otherPlacemarks[clientId] = new ymaps.Placemark(coords, { iconCaption: userName, hintContent: `${userName}<br>${lastUpdateText}` }, { preset: userPreset, iconCaptionMaxWidth: '150', hideIconOnBalloonOpen: false });
                        myMap.geoObjects.add(otherPlacemarks[clientId]);
                        otherPlacemarks[clientId].events.add('click', () => centerMapOnUser(clientId));
                    }
                    currentOthersOnMap.delete(clientId);
                } else {
                     if (user.decryption_error) { console.warn(`Decryption failed for ${user.user_name} (${clientId}).`); }
                    if (otherPlacemarks[clientId]) {
                        if (myMap.geoObjects.indexOf(otherPlacemarks[clientId]) !== -1) { myMap.geoObjects.remove(otherPlacemarks[clientId]); }
                        delete otherPlacemarks[clientId]; delete userPresets[clientId];
                    }
                }
            });
            currentOthersOnMap.forEach(clientId => {
                if (otherPlacemarks[clientId]) {
                    if (myMap.geoObjects.indexOf(otherPlacemarks[clientId]) !== -1) { myMap.geoObjects.remove(otherPlacemarks[clientId]); }
                    delete otherPlacemarks[clientId]; delete userPresets[clientId];
                }
            });
            updateUsersPanel(users);
            console.log("➡️ updateMapAndUsersPanel finished.");
        }

         function updateUsersPanel(users) {
             console.log("➡️ updateUsersPanel users:", users.length);
            usersList.innerHTML = ''; let currentUserData = null; const otherUsers = [];
            users.forEach(user => { (user.client_id === myClientId ? currentUserData = user : otherUsers.push(user)); });
            const createUserItem = (user, isSelf = false) => {
                const item = document.createElement('div'); item.className = 'user-item'; item.setAttribute('data-id', user.client_id);
                const name = isSelf ? `${currentUserName} (Вы)` : user.user_name;
                const preset = isSelf ? 'islands#blueDotIconWithCaption' : (userPresets[user.client_id] || getRandomPreset(user.client_id));
                const color = PRESET_TO_COLOR[preset] || '#AAAAAA';
                const timeAgo = formatTimeAgo(user.last_update);
                const errorIndicator = user.decryption_error ? '<span style="color:red; font-size:0.8em; margin-left: 5px;">(ошибка данных?)</span>' : '';
                item.innerHTML = `<div class="user-color" style="background-color: ${color};"></div><div class="user-details"><div class="user-name">${name}${errorIndicator}</div><div class="user-last-update">${timeAgo}</div></div>`;
                item.addEventListener('click', () => centerMapOnUser(user.client_id)); return item;
            };
            if (currentUserData) { usersList.appendChild(createUserItem(currentUserData, true)); }
            if (otherUsers.length > 0) {
                otherUsers.sort((a, b) => a.user_name.localeCompare(b.user_name));
                otherUsers.forEach(user => { usersList.appendChild(createUserItem(user, false)); });
            }
             if (usersList.children.length === 0) { usersList.innerHTML = '<div class="no-users">Нет активных участников.</div>'; }
             else if (usersList.children.length === 1 && currentUserData) {
                 const noOthers = document.createElement('div'); noOthers.className = 'no-users'; noOthers.textContent = 'Нет других участников.'; noOthers.style.padding = "10px 15px"; usersList.appendChild(noOthers);
             }
            const currentlyHighlighted = usersList.querySelector('.user-item.active'); const highlightId = currentlyHighlighted ? currentlyHighlighted.getAttribute('data-id') : myClientId;
            if (highlightId) { highlightUserInPanel(highlightId); }
            console.log("➡️ updateUsersPanel finished.");
         }

        function centerMapOnUser(clientId) {
             console.log(`➡️ centerMapOnUser: ${clientId}`); let targetCoords = null;
             if (clientId === myClientId && myPlacemark && myMap.geoObjects.indexOf(myPlacemark) !== -1) { targetCoords = myPlacemark.geometry.getCoordinates(); }
             else if (otherPlacemarks[clientId] && myMap.geoObjects.indexOf(otherPlacemarks[clientId]) !== -1) { targetCoords = otherPlacemarks[clientId].geometry.getCoordinates(); }
             if (targetCoords && myMap) {
                  myMap.panTo(targetCoords, { flying: true, duration: 800 })
                      .then(() => { if (myMap.getZoom() < 15) { myMap.setZoom(15, { duration: 500 }); } })
                      .catch(err => console.error("❌ Map pan error:", err));
                  highlightUserInPanel(clientId);
             } else { console.warn(`Placemark not found for client ID: ${clientId}`); }
        }

        function highlightUserInPanel(clientId) {
             document.querySelectorAll('.user-item').forEach(item => { item.classList.toggle('active', item.getAttribute('data-id') === clientId); });
        }

        function subscribeToSessionChanges() {
             console.log("➡️ subscribeToSessionChanges called."); if (!currentSessionId) return;
             if (sessionChannel) { sessionChannel.unsubscribe(); sessionChannel = null; }
             sessionChannel = supabase.channel(`session:${currentSessionId}`)
                .on('postgres_changes', { event: '*', schema: 'public', table: 'tracker', filter: `session_id=eq.${currentSessionId}` }, (payload) => {
                        console.log('⚡️ Realtime change:', payload.eventType);
                        fetchAndDisplayAllUsersInSession();
                    })
                .subscribe(async (status, err) => {
                    console.log(`📡 Realtime status: ${status}`);
                    if (err) console.error('❌ Realtime error:', err);
                    if (status === 'SUBSCRIBED') { console.log(`✅ Realtime subscribed: ${currentSessionId}`); }
                });
             console.log("➡️ subscribeToSessionChanges finished.");
        }

        function startPeriodicUpdates() {
            stopPeriodicUpdates(false);
            if (updateIntervalMs >= 5000) {
                 console.log(`Starting periodic updates: ${updateIntervalMs / 1000}s`);
                 periodicUpdateTimerId = setInterval(periodicLocationUpdate, updateIntervalMs);
            }
        }

        function stopPeriodicUpdates(fullStop = true) {
             if (periodicUpdateTimerId) { clearInterval(periodicUpdateTimerId); periodicUpdateTimerId = null; }
             if (fullStop) {
                  if (watchId !== null && navigator.geolocation) { navigator.geolocation.clearWatch(watchId); watchId = null; }
                  if (sessionChannel) { sessionChannel.unsubscribe(); sessionChannel = null; }
                  console.log("Stopped updates, watch, channel.");
             } else { console.log("Stopped update timer only."); }
        }

        async function handleLockSession() {
             if (!currentSessionId) return;
             const lockConfirmed = confirm(`Вы уверены, что хотите запретить вход новым участникам в сессию "${currentSessionId}"?\nСуществующие участники смогут продолжить работу.`);
             if (!lockConfirmed) return;

             lockButton.disabled = true;
             lockButton.textContent = 'Блокировка...';

             try {
                 const lockClientId = crypto.randomUUID(); // Need a client_id even for the lock record
                 const { error } = await supabase
                     .from('tracker')
                     .upsert({
                         session_id: currentSessionId,
                         user_name: LOCK_RECORD_USERNAME, // Special username
                         client_id: lockClientId,         // Unique ID for this lock action
                         last_update: new Date().toISOString(),
                         location_data: null, lat: null, lon: null
                     }, {
                         onConflict: 'session_id, user_name' // Ensure only one lock record per session
                     });

                 if (error) {
                     console.error("Error locking session:", error);
                     alert(`Не удалось заблокировать сессию: ${error.message}`);
                     updateLockButtonState(false); // Revert button state on error
                 } else {
                     console.log("Session locked successfully.");
                     updateLockButtonState(true); // Update button to locked state
                 }
             } catch (error) {
                 console.error("Unexpected error during lock:", error);
                 alert("Произошла ошибка при блокировке сессии.");
                 updateLockButtonState(false);
             } finally {
                 // Re-enable lock button only if it wasn't successfully locked
                 if (!lockButton.classList.contains('locked')) {
                     lockButton.disabled = false;
                 }
             }
        }

        function updateLockButtonState(isLocked) {
            if (isLocked) {
                lockButton.textContent = 'Вход Запрещен';
                lockButton.classList.add('locked');
                lockButton.disabled = true; // Keep it disabled once locked
            } else {
                lockButton.textContent = 'Запретить вход новым';
                lockButton.classList.remove('locked');
                lockButton.disabled = false;
            }
        }

        async function checkSessionLockStatus() {
            if (!currentSessionId) return;
            try {
                 // Check lock status using limit(1) instead of single()
                 const { data, error } = await supabase
                    .from('tracker')
                    .select('client_id')
                    .eq('session_id', currentSessionId)
                    .eq('user_name', LOCK_RECORD_USERNAME)
                    .limit(1); // Removed .single()

                // With limit(1) and no single(), error will only be non-null for actual query errors
                if (error) {
                    console.error("Error checking lock status:", error);
                    return; // Don't change button state if check fails
                }
                // Update based on whether data is an array and contains at least one element
                updateLockButtonState(Array.isArray(data) && data.length > 0);
            } catch(error) {
                 console.error("Unexpected error checking lock status:", error);
            }
        }


        async function handleDeleteSessionData() {
            if (!currentSessionId) return;
            const confirmed = confirm(`Вы уверены, что хотите удалить ВСЕ данные для сессии "${currentSessionId}"?`);
            if (!confirmed) return;
            deleteButton.disabled = true; deleteButton.textContent = 'Удаление...';
            try {
                 const { error } = await supabase.from('tracker').delete().eq('session_id', currentSessionId);
                 if (error) { console.error('❌ Supabase delete error:', error); alert(`Ошибка при удалении: ${error.message}`); }
                 else { handleSessionEnd(`Данные сессии "${currentSessionId}" удалены.`); }
            } catch (error) { console.error('❌ Unexpected delete error:', error); alert('Ошибка сети при удалении.'); }
            finally {
                // This finally block is primarily for cases where the delete API call itself fails.
                // If handleSessionEnd was called, it already reset the button.
                // We only re-enable here if handleSessionEnd was NOT called.
                if (currentSessionId !== null) { // Check if handleSessionEnd was NOT called
                     deleteButton.disabled = false;
                     deleteButton.textContent = `Удалить данные сессии ${currentSessionId}`;
                }
            }
        }

        function handleSessionEnd(message) {
             console.log("➡️ handleSessionEnd", { message });
             stopPeriodicUpdates(true);
             if (myMap) { myMap.destroy(); myMap = null; }
             myPlacemark = null; otherPlacemarks = {}; currentSessionId = null; currentUserName = null; myClientId = null;
             userPresets = {}; lastKnownCoords = null; sessionEncryptionKey = null; isLoggingIn = false;
             mapContainer.classList.add('hidden'); usersPanel.classList.add('hidden'); controlsPanel.classList.add('hidden');
             loginModal.classList.remove('hidden'); showLoginError(message || '');
             usersList.innerHTML = '<div class="no-users">Нет активных участников.</div>'; sessionTitle.textContent = 'Сессия: Загрузка...';
             deleteButton.textContent = 'Удалить данные сессии';
             deleteButton.disabled = false; // Ensure button is enabled when returning to login state
             updateLockButtonState(false); // Reset lock button
             loginButton.disabled = false; loginButton.textContent = 'Войти / Присоединиться';
             sessionIdInput.value = ''; userNameInput.value = ''; updateIntervalInput.value = '30';
             console.log("✅ Session ended.");
        }

        loginButton.addEventListener('click', handleLogin);
        lockButton.addEventListener('click', handleLockSession);
        sessionIdInput.addEventListener('keypress', (e) => { if (e.key === 'Enter') { e.preventDefault(); handleLogin(); } });
        userNameInput.addEventListener('keypress', (e) => { if (e.key === 'Enter') { e.preventDefault(); handleLogin(); } });
        updateIntervalInput.addEventListener('keypress', (e) => { if (e.key === 'Enter') { e.preventDefault(); handleLogin(); } });
        deleteButton.addEventListener('click', handleDeleteSessionData);
        window.addEventListener('beforeunload', () => stopPeriodicUpdates(true));

    </script>
</body>
</html>