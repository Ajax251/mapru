<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Анализатор структуры XML</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            line-height: 1.6;
            margin: 0;
            padding: 20px;
            background-color: #f4f4f9;
            color: #333;
        }
        .container {
            max-width: 1200px;
            margin: auto;
            background: #fff;
            padding: 25px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        h1, h2 {
            color: #0056b3;
            border-bottom: 2px solid #e0e0e0;
            padding-bottom: 10px;
        }
        .file-input-group {
            margin-bottom: 20px;
            padding: 15px;
            background-color: #e9ecef;
            border-radius: 5px;
        }
        label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        }
        input[type="file"] {
            width: 100%;
            padding: 8px;
            box-sizing: border-box;
        }
        button {
            display: block;
            width: 100%;
            padding: 12px;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 5px;
            font-size: 16px;
            cursor: pointer;
            transition: background-color 0.3s;
        }
        button:hover {
            background-color: #0056b3;
        }
        .output-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-top: 30px;
        }
        .result-box {
            background: #282c34;
            color: #abb2bf;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            height: 60vh;
        }
        pre {
            white-space: pre;
            font-family: "Courier New", Courier, monospace;
            font-size: 14px;
            margin: 0;
        }
        .tag { color: #e06c75; }
        .attr-name { color: #d19a66; }
        .attr-value { color: #98c379; }
        .content { color: #61afef; font-style: italic; }
        #loader {
            display: none;
            text-align: center;
            font-size: 18px;
            margin-top: 20px;
        }
    </style>
</head>
<body>

    <div class="container">
        <h1>Анализатор структуры XML для конвертации КПТ</h1>
        <p>Эта утилита поможет извлечь структуру и примеры данных из двух версий XML-файлов. Результат анализа позволит создать корректный конвертер.</p>

        <div class="file-input-group">
            <label for="oldXmlInput">1. Выберите старый XML-файл (например, `extract_cadastral_plan_territory`)</label>
            <input type="file" id="oldXmlInput" accept=".xml">
        </div>

        <div class="file-input-group">
            <label for="newXmlInput">2. Выберите новый XML-файл (версия 10, `KPT`)</label>
            <input type="file" id="newXmlInput" accept=".xml">
        </div>

        <button id="analyzeBtn">Проанализировать структуру XML</button>
        
        <div id="loader">Анализирую файлы... Это может занять некоторое время для больших файлов.</div>

        <div class="output-container">
            <div>
                <h2>Структура старого XML</h2>
                <div class="result-box">
                    <pre id="oldStructureOutput"></pre>
                </div>
            </div>
            <div>
                <h2>Структура нового XML (версия 10)</h2>
                <div class="result-box">
                    <pre id="newStructureOutput"></pre>
                </div>
            </div>
        </div>
    </div>

    <script>
        document.getElementById('analyzeBtn').addEventListener('click', handleAnalysis);

        function handleAnalysis() {
            const oldFileInput = document.getElementById('oldXmlInput');
            const newFileInput = document.getElementById('newXmlInput');
            const loader = document.getElementById('loader');

            if (oldFileInput.files.length === 0 || newFileInput.files.length === 0) {
                alert('Пожалуйста, выберите оба файла для анализа.');
                return;
            }

            loader.style.display = 'block';
            document.getElementById('oldStructureOutput').innerHTML = '';
            document.getElementById('newStructureOutput').innerHTML = '';

            // Используем setTimeout, чтобы браузер успел отрисовать лоадер
            setTimeout(() => {
                const oldFile = oldFileInput.files[0];
                const newFile = newFileInput.files[0];

                Promise.all([
                    processFile(oldFile),
                    processFile(newFile)
                ]).then(([oldStructure, newStructure]) => {
                    document.getElementById('oldStructureOutput').innerHTML = oldStructure;
                    document.getElementById('newStructureOutput').innerHTML = newStructure;
                }).catch(error => {
                    console.error('Ошибка анализа:', error);
                    alert('Произошла ошибка при анализе файла. Подробности в консоли разработчика.');
                }).finally(() => {
                    loader.style.display = 'none';
                });
            }, 50);
        }

        function processFile(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = (event) => {
                    try {
                        const xmlString = event.target.result;
                        const parser = new DOMParser();
                        const xmlDoc = parser.parseFromString(xmlString, "application/xml");
                        
                        // Проверка на ошибку парсинга
                        const parserError = xmlDoc.querySelector("parsererror");
                        if (parserError) {
                            console.error("Ошибка парсинга:", parserError.textContent);
                            throw new Error("Не удалось разобрать XML. Возможно, файл поврежден или имеет неверный формат.");
                        }

                        const structure = generateStructure(xmlDoc.documentElement);
                        resolve(structure);
                    } catch (e) {
                        reject(e);
                    }
                };
                reader.onerror = (error) => reject(error);
                reader.readAsText(file, 'UTF-8');
            });
        }

        function generateStructure(node, depth = 0, structureMap = new Map()) {
            let result = '';
            const indent = '  '.repeat(depth);
            
            // Собираем уникальный ключ для ноды, чтобы не дублировать информацию о структуре
            const parentKey = arguments[3] || '';
            const nodeKey = parentKey + '/' + node.nodeName;

            // Если такую структуру еще не встречали, добавляем ее
            if (!structureMap.has(nodeKey)) {
                structureMap.set(nodeKey, 0); // Добавляем ключ, значение не важно
                
                // Формируем строку с тегом и атрибутами
                let attributes = '';
                if (node.attributes.length > 0) {
                    for (let i = 0; i < node.attributes.length; i++) {
                        const attr = node.attributes[i];
                        attributes += ` <span class="attr-name">${attr.name}</span>="<span class="attr-value">${attr.value}</span>"`;
                    }
                }
                
                result += `${indent}<span class="tag">&lt;${node.nodeName}</span>${attributes}<span class="tag">&gt;</span>\n`;

                // Проверяем, есть ли у ноды простой текстовый контент
                const childElements = Array.from(node.children);
                if (childElements.length === 0 && node.textContent.trim()) {
                    let content = node.textContent.trim();
                    if (content.length > 100) {
                        content = content.substring(0, 100) + '...';
                    }
                    result += `${indent}  <span class="content">(Пример текста: "${content}")</span>\n`;
                }
            }

            // Рекурсивно обходим дочерние элементы
            const children = Array.from(node.children);
            children.forEach(child => {
                result += generateStructure(child, depth + 1, structureMap, nodeKey);
            });

            return result;
        }

    </script>
</body>
</html>