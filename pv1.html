<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <title>PDF Viewer</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/pdf-lib/dist/pdf-lib.min.js"></script>
    <link rel="icon" href="https://img.icons8.com/?size=100&id=3IEVgAKImW4C&format=png&color=000000" type="image/png">
    <style>
        * {
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        :root {
            --bg-primary: #f5f7fa;
            --bg-secondary: #e8ecf1;
            --bg-card: #ffffff;
            --accent: #3b82f6;
            --accent-hover: #2563eb;
            --text-primary: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --shadow: 0 2px 8px rgba(0,0,0,0.08);
            --shadow-lg: 0 4px 16px rgba(0,0,0,0.12);
            --radius: 12px;
            --radius-sm: 8px;
        }

        body, html {
            margin: 0;
            padding: 0;
            height: 100%;
            overflow: hidden;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            -webkit-font-smoothing: antialiased;
        }

        #container {
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
        }

        /* Start Screen */
        #startScreen {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100%;
            padding: 20px;
        }

        #dropArea {
            background: var(--bg-card);
            border: 2px dashed var(--border);
            border-radius: var(--radius);
            padding: 40px 60px;
            text-align: center;
            cursor: pointer;
            box-shadow: var(--shadow);
        }

        #dropArea:hover, #dropArea.highlighted {
            border-color: var(--accent);
            background: #f0f7ff;
        }

        #dropArea .drop-icon {
            width: 64px;
            height: 64px;
            margin-bottom: 16px;
            color: var(--accent);
        }

        #dropArea h3 {
            margin: 0 0 8px 0;
            font-size: 18px;
            font-weight: 600;
            color: var(--text-primary);
        }

        #dropArea p {
            margin: 0;
            font-size: 14px;
            color: var(--text-secondary);
        }

        /* Viewer */
        #viewer {
            flex: 1;
            overflow-y: auto;
            overflow-x: hidden;
            background: var(--bg-secondary);
            display: none;
            -webkit-overflow-scrolling: touch;
        }

        #pdfContainer {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 60px 10px 80px 10px;
            gap: 16px;
            min-height: 100%;
        }

        /* PDF Selector */
        #pdfSelector {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            z-index: 50;
            background: var(--bg-card);
            border-bottom: 1px solid var(--border);
            padding: 10px 16px;
            display: none;
        }

        #pdfSelector select {
            width: 100%;
            padding: 10px 12px;
            font-size: 14px;
            border: 1px solid var(--border);
            border-radius: var(--radius-sm);
            background: var(--bg-primary);
            color: var(--text-primary);
            outline: none;
        }

        #pdfSelector select:focus {
            border-color: var(--accent);
        }

        /* Page Canvas */
        canvas.page-canvas {
            background: var(--bg-card);
            box-shadow: var(--shadow);
            border-radius: var(--radius-sm);
            max-width: 100%;
            display: block;
        }

        canvas.page-canvas.current {
            box-shadow: 0 0 0 3px var(--accent), var(--shadow-lg);
        }

        .page-placeholder {
            background: var(--bg-card);
            border: 1px dashed var(--border);
            border-radius: var(--radius-sm);
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--text-secondary);
            font-size: 14px;
            max-width: 100%;
        }

        /* Controls */
        #controls {
            position: fixed;
            bottom: 16px;
            left: 50%;
            transform: translateX(-50%);
            display: none;
            gap: 8px;
            background: var(--bg-card);
            border: 1px solid var(--border);
            box-shadow: var(--shadow-lg);
            padding: 8px 12px;
            border-radius: 50px;
            z-index: 100;
            align-items: center;
        }

        .btn {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            border: none;
            background: transparent;
            color: var(--text-primary);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
        }

        .btn:hover {
            background: var(--bg-secondary);
        }

        .btn:active {
            background: var(--border);
        }

        .btn.active {
            background: var(--accent);
            color: white;
        }

        .btn .icon {
            width: 22px;
            height: 22px;
            fill: currentColor;
        }

        #pageInfo {
            font-size: 14px;
            font-weight: 500;
            color: var(--text-primary);
            padding: 0 8px;
            min-width: 50px;
            text-align: center;
        }

        #fileInfo {
            position: fixed;
            bottom: 70px;
            left: 50%;
            transform: translateX(-50%);
            background: var(--bg-card);
            border: 1px solid var(--border);
            box-shadow: var(--shadow);
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 12px;
            color: var(--text-secondary);
            z-index: 99;
            max-width: 90%;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            opacity: 0;
            pointer-events: none;
        }

        #fileInfo.visible {
            opacity: 1;
        }

        /* Loading */
        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(255,255,255,0.9);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 500;
        }

        .loading-overlay.active {
            display: flex;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--accent);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Hidden input */
        #upload { display: none; }

        /* Thumbnail Overlay */
        #thumbnailOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.5);
            z-index: 200;
            display: none;
            align-items: center;
            justify-content: center;
        }

        #thumbnailViewArea {
            width: 95%;
            height: 90%;
            max-width: 1200px;
            background: var(--bg-card);
            border-radius: var(--radius);
            box-shadow: var(--shadow-lg);
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        #thumbnailHeader {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 12px 16px;
            border-bottom: 1px solid var(--border);
            background: var(--bg-primary);
        }

        #thumbnailHeader h3 {
            margin: 0;
            font-size: 16px;
            font-weight: 600;
        }

        #thumbnailActions {
            display: flex;
            gap: 8px;
        }

        #thumbnailContainer {
            flex: 1;
            overflow-y: auto;
            padding: 16px;
            display: grid;
            gap: 12px;
            align-content: start;
            -webkit-overflow-scrolling: touch;
        }

        .thumbnail-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 8px;
            background: var(--bg-secondary);
            border-radius: var(--radius-sm);
            cursor: pointer;
            border: 2px solid transparent;
        }

        .thumbnail-item:hover {
            background: var(--border);
        }

        .thumbnail-item.current {
            border-color: var(--accent);
            background: #e0edff;
        }

        .thumbnail-canvas {
            max-width: 100%;
            background: white;
            box-shadow: var(--shadow);
            border-radius: 4px;
        }

        .thumbnail-pagenum {
            margin-top: 6px;
            font-size: 12px;
            color: var(--text-secondary);
            font-weight: 500;
        }

        .thumbnail-separator {
            grid-column: 1 / -1;
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 8px 0;
            font-size: 13px;
            font-weight: 600;
            color: var(--text-secondary);
        }

        .thumbnail-separator::before,
        .thumbnail-separator::after {
            content: '';
            flex: 1;
            height: 1px;
            background: var(--border);
        }

        .thumbnail-separator span {
            max-width: 200px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        /* Preview Modal */
        #previewModal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.85);
            z-index: 300;
            display: none;
            align-items: center;
            justify-content: center;
            cursor: pointer;
        }

        #previewModal.active {
            display: flex;
        }

        #previewCanvas {
            max-width: 95%;
            max-height: 95%;
            background: white;
            border-radius: var(--radius-sm);
        }

        /* Merge Modal */
        #mergeModal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.5);
            z-index: 250;
            display: none;
            align-items: center;
            justify-content: center;
        }

        #mergeModal.active {
            display: flex;
        }

        .merge-content {
            width: 95%;
            max-width: 600px;
            max-height: 85vh;
            background: var(--bg-card);
            border-radius: var(--radius);
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .merge-header {
            padding: 16px 20px;
            border-bottom: 1px solid var(--border);
        }

        .merge-header h3 {
            margin: 0 0 4px 0;
            font-size: 18px;
        }

        .merge-header p {
            margin: 0;
            font-size: 13px;
            color: var(--text-secondary);
        }

        .merge-list {
            flex: 1;
            overflow-y: auto;
            padding: 12px;
            -webkit-overflow-scrolling: touch;
        }

        .merge-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px 12px;
            background: var(--bg-secondary);
            border-radius: var(--radius-sm);
            margin-bottom: 8px;
        }

        .merge-item.dragging {
            opacity: 0.5;
        }

        .drag-handle {
            cursor: grab;
            color: var(--text-secondary);
            display: flex;
        }

        .drag-handle:active {
            cursor: grabbing;
        }

        .merge-item-name {
            flex: 1;
            font-size: 13px;
            font-weight: 500;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .merge-item-input {
            width: 80px;
            padding: 6px 8px;
            border: 1px solid var(--border);
            border-radius: 6px;
            font-size: 12px;
            text-align: center;
        }

        .merge-item-input:focus {
            outline: none;
            border-color: var(--accent);
        }

        .merge-item-count {
            font-size: 11px;
            color: var(--text-secondary);
            min-width: 50px;
            text-align: right;
        }

        .merge-footer {
            display: flex;
            gap: 10px;
            padding: 16px 20px;
            border-top: 1px solid var(--border);
            justify-content: flex-end;
        }

        .merge-btn {
            padding: 10px 20px;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            border: none;
        }

        .merge-btn.cancel {
            background: var(--bg-secondary);
            color: var(--text-primary);
        }

        .merge-btn.cancel:hover {
            background: var(--border);
        }

        .merge-btn.confirm {
            background: var(--accent);
            color: white;
        }

        .merge-btn.confirm:hover {
            background: var(--accent-hover);
        }

        /* Error message */
        .error-msg {
            padding: 20px;
            margin: 20px;
            background: #fef2f2;
            border: 1px solid #fecaca;
            border-radius: var(--radius-sm);
            color: #dc2626;
            text-align: center;
        }

        /* Mobile optimizations */
        @media (max-width: 600px) {
            #dropArea {
                padding: 30px 40px;
            }

            #dropArea .drop-icon {
                width: 48px;
                height: 48px;
            }

            #controls {
                padding: 6px 10px;
                gap: 4px;
            }

            .btn {
                width: 36px;
                height: 36px;
            }

            .btn .icon {
                width: 20px;
                height: 20px;
            }

            #pdfContainer {
                padding: 56px 8px 76px 8px;
                gap: 12px;
            }
        }
    </style>
</head>
<body>
    <div id="container">
        <!-- Start Screen -->
        <div id="startScreen">
            <div id="dropArea">
                <svg class="drop-icon" viewBox="0 0 24 24" fill="currentColor">
                    <path d="M14 2H6c-1.1 0-2 .9-2 2v16c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V8l-6-6zm4 18H6V4h7v5h5v11zM8 15h8v2H8v-2zm0-4h8v2H8v-2z"/>
                </svg>
                <h3>Открыть PDF или ZIP</h3>
                <p>Нажмите или перетащите файлы</p>
            </div>
        </div>

        <!-- PDF Viewer -->
        <div id="viewer">
            <div id="pdfSelector">
                <select id="pdfSelectDropdown"></select>
            </div>
            <div id="pdfContainer"></div>
        </div>

        <!-- Controls -->
        <div id="controls">
            <button class="btn" id="openFile" title="Открыть файл">
                <svg class="icon" viewBox="0 0 24 24">
                    <path d="M9 16h6v-6h4l-7-7-7 7h4v6zm-4 2h14v2H5v-2z"/>
                </svg>
            </button>
            <button class="btn" id="prevPage" title="Предыдущая">
                <svg class="icon" viewBox="0 0 24 24">
                    <path d="M15.41 7.41L14 6l-6 6 6 6 1.41-1.41L10.83 12z"/>
                </svg>
            </button>
            <div id="pageInfo">0/0</div>
            <button class="btn" id="nextPage" title="Следующая">
                <svg class="icon" viewBox="0 0 24 24">
                    <path d="M10 6L8.59 7.41 13.17 12l-4.58 4.59L10 18l6-6z"/>
                </svg>
            </button>
            <button class="btn" id="thumbnailBtn" title="Эскизы">
                <svg class="icon" viewBox="0 0 24 24">
                    <path d="M4 8h4V4H4v4zm6 12h4v-4h-4v4zm-6 0h4v-4H4v4zm0-6h4v-4H4v4zm6 0h4v-4h-4v4zm6-10v4h4V4h-4zm-6 4h4V4h-4v4zm6 6h4v-4h-4v4zm0 6h4v-4h-4v4z"/>
                </svg>
            </button>
            <button class="btn" id="toggleFit" title="Режим просмотра">
                <svg class="icon" id="fitIcon" viewBox="0 0 24 24">
                    <path d="M19 12h-2v3h-3v2h5v-5zM7 9h3V7H5v5h2V9zm14-6H3c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h18c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm0 16.01H3V4.99h18v14.02z"/>
                </svg>
            </button>
            <button class="btn" id="fullscreenBtn" title="Полный экран">
                <svg class="icon" id="fullscreenIcon" viewBox="0 0 24 24">
                    <path d="M7 14H5v5h5v-2H7v-3zm-2-4h2V7h3V5H5v5zm12 7h-3v2h5v-5h-2v3zM14 5v2h3v3h2V5h-5z"/>
                </svg>
            </button>
        </div>

        <div id="fileInfo"></div>
    </div>

    <!-- Loading Overlay -->
    <div class="loading-overlay" id="loadingOverlay">
        <div class="spinner"></div>
    </div>

    <!-- Thumbnail Overlay -->
    <div id="thumbnailOverlay">
        <div id="thumbnailViewArea">
            <div id="thumbnailHeader">
                <h3>Эскизы страниц</h3>
                <div id="thumbnailActions">
                    <button class="btn" id="mergeBtn" title="Объединить PDF" style="display:none;">
                        <svg class="icon" viewBox="0 0 24 24">
                            <path d="M17 20.41L18.41 19 15 15.59 13.59 17 17 20.41zM7.5 8H11v5.59L5.59 19 7 20.41l6-6V8h3.5L12 3.5 7.5 8z"/>
                        </svg>
                    </button>
                    <button class="btn" id="closeThumbnails" title="Закрыть">
                        <svg class="icon" viewBox="0 0 24 24">
                            <path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/>
                        </svg>
                    </button>
                </div>
            </div>
            <div id="thumbnailContainer"></div>
        </div>
    </div>

    <!-- Preview Modal -->
    <div id="previewModal">
        <canvas id="previewCanvas"></canvas>
    </div>

    <!-- Merge Modal -->
    <div id="mergeModal">
        <div class="merge-content">
            <div class="merge-header">
                <h3>Объединить PDF</h3>
                <p>Укажите диапазоны страниц (например: 1-5 7 9-10)</p>
            </div>
            <div class="merge-list" id="mergeList"></div>
            <div class="merge-footer">
                <button class="merge-btn cancel" id="cancelMerge">Отмена</button>
                <button class="merge-btn confirm" id="confirmMerge">Объединить</button>
            </div>
        </div>
    </div>

    <input type="file" id="upload" accept=".pdf,.zip" multiple>

    <script>
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';

        // State
        const state = {
            pdfDoc: null,
            pageNum: 1,
            fitMode: 'width',
            currentFile: null,
            currentArchiveName: '',
            filesMode: null,
            thumbnailsGenerated: false
        };

        const extractedPdfs = new Map();
        const originalFilesMap = new Map();
        const canvasMap = new Map();
        const renderTaskMap = new Map();
        const pdfDocCache = new Map();
        let observer = null;
        let draggedItem = null;

        // DOM Elements
        const $ = id => document.getElementById(id);

        // Utility functions
        function showLoading(show) {
            $('loadingOverlay').classList.toggle('active', show);
        }

        function formatSize(bytes) {
            if (!bytes) return '-';
            const k = 1024;
            const sizes = ['B', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(1)) + ' ' + sizes[i];
        }

        function updatePageCounter() {
            const total = state.pdfDoc ? state.pdfDoc.numPages : 0;
            const current = state.pdfDoc ? state.pageNum : 0;
            $('pageInfo').textContent = `${current}/${total}`;
        }

        function updateFileInfo() {
            const el = $('fileInfo');
            if (!el) return;
            
            let text = state.currentArchiveName || 'Файл не загружен';
            const dropdown = $('pdfSelectDropdown');
            
            if ((state.filesMode === 'zip' || state.filesMode === 'multiple') && dropdown && dropdown.value) {
                text += ' → ' + dropdown.value.split('/').pop();
            }
            
            el.textContent = text;
            el.title = text;
        }

        function showError(msg) {
            const container = $('pdfContainer');
            container.innerHTML = `<div class="error-msg">${msg}</div>`;
            $('controls').style.display = 'none';
            state.pdfDoc = null;
            updatePageCounter();
            showLoading(false);
        }

        // File handling
        function handleFiles(files) {
            if (!files || !files.length) return;

            state.thumbnailsGenerated = false;
            $('thumbnailContainer').innerHTML = '';
            extractedPdfs.clear();
            originalFilesMap.clear();
            pdfDocCache.clear();
            state.pdfDoc = null;

            showLoading(true);
            $('startScreen').style.display = 'none';
            $('viewer').style.display = 'block';
            $('controls').style.display = 'flex';
            $('pdfSelector').style.display = 'none';

            if (files.length === 1) {
                const file = files[0];
                state.currentFile = file;
                state.currentArchiveName = file.name;

                const reader = new FileReader();
                reader.onload = async (e) => {
                    const data = e.target.result;
                    
                    if (file.name.toLowerCase().endsWith('.zip')) {
                        state.filesMode = 'zip';
                        await handleZip(data, file.name);
                    } else if (file.name.toLowerCase().endsWith('.pdf')) {
                        state.filesMode = 'single';
                        const uint8 = new Uint8Array(data);
                        extractedPdfs.set(file.name, uint8);
                        originalFilesMap.set(file.name, file);
                        await loadPdf(uint8, file.name);
                    } else {
                        showError('Неподдерживаемый формат файла');
                    }
                };
                reader.onerror = () => showError('Ошибка чтения файла');
                reader.readAsArrayBuffer(file);
            } else {
                state.filesMode = 'multiple';
                state.currentArchiveName = 'Несколько файлов';
                handleMultipleFiles(files);
            }
        }

        async function handleMultipleFiles(files) {
            const pdfFiles = Array.from(files).filter(f => f.name.toLowerCase().endsWith('.pdf'));
            
            if (!pdfFiles.length) {
                showError('PDF файлы не найдены');
                return;
            }

            pdfFiles.sort((a, b) => a.name.localeCompare(b.name, undefined, {numeric: true}));

            try {
                for (const file of pdfFiles) {
                    const data = await file.arrayBuffer();
                    const uint8 = new Uint8Array(data);
                    extractedPdfs.set(file.name, uint8);
                    originalFilesMap.set(file.name, file);
                }

                populateSelector(pdfFiles.map(f => f.name));
                $('pdfSelector').style.display = 'block';
                showThumbnails();
            } catch (err) {
                showError('Ошибка загрузки файлов');
            } finally {
                showLoading(false);
            }
        }

        async function handleZip(data, fileName) {
            state.currentArchiveName = fileName;
            
            const decodeFilename = bytes => {
                const decoders = ['utf-8', 'cp866', 'windows-1251'];
                for (const enc of decoders) {
                    try {
                        return new TextDecoder(enc, {fatal: true}).decode(bytes);
                    } catch {}
                }
                return new TextDecoder().decode(bytes);
            };

            try {
                const zip = await JSZip.loadAsync(data, {decodeFileName: decodeFilename});
                const pdfEntries = [];
                
                zip.forEach((path, entry) => {
                    if (!entry.dir && path.toLowerCase().endsWith('.pdf')) {
                        pdfEntries.push(entry);
                    }
                });

                if (!pdfEntries.length) {
                    showError('PDF файлы в архиве не найдены');
                    return;
                }

                pdfEntries.sort((a, b) => a.name.localeCompare(b.name, undefined, {numeric: true}));

                for (const entry of pdfEntries) {
                    const uint8 = await entry.async('uint8array');
                    extractedPdfs.set(entry.name, uint8);
                }

                populateSelector(pdfEntries.map(e => e.name));
                $('pdfSelector').style.display = 'block';
                showThumbnails();
            } catch (err) {
                showError('Ошибка чтения ZIP архива');
            } finally {
                showLoading(false);
            }
        }

        function populateSelector(names) {
            const select = $('pdfSelectDropdown');
            select.innerHTML = names.map(n => `<option value="${n}">${n}</option>`).join('');
        }

        // PDF loading and rendering
        async function loadPdf(data, name, initialPage = 1) {
            if (observer) observer.disconnect();
            canvasMap.clear();
            renderTaskMap.forEach(t => t && t.cancel && t.cancel());
            renderTaskMap.clear();
            $('pdfContainer').innerHTML = '';
            
            state.pdfDoc = null;
            state.pageNum = initialPage;
            state.thumbnailsGenerated = false;
            $('thumbnailContainer').innerHTML = '';
            pdfDocCache.clear();
            
            showLoading(true);

            try {
                const uint8 = data instanceof Uint8Array ? data : new Uint8Array(data);
                const pdf = await pdfjsLib.getDocument({data: uint8.slice()}).promise;
                
                state.pdfDoc = pdf;
                pdfDocCache.set(name, pdf);
                
                if (state.pageNum > pdf.numPages) state.pageNum = pdf.numPages;
                if (state.pageNum < 1) state.pageNum = 1;
                
                updatePageCounter();
                updateFileInfo();
                createPlaceholders();
                setupObserver();
                
                setTimeout(() => {
                    renderVisiblePages();
                    scrollToPage(state.pageNum);
                }, 50);
                
                return pdf;
            } catch (err) {
                console.error('PDF load error:', err);
                showError(`Ошибка загрузки PDF: ${name}`);
                throw err;
            } finally {
                showLoading(false);
            }
        }

        function createPlaceholders() {
            const container = $('pdfContainer');
            container.innerHTML = '';
            
            for (let i = 1; i <= state.pdfDoc.numPages; i++) {
                const placeholder = document.createElement('div');
                placeholder.className = 'page-placeholder';
                placeholder.id = `placeholder-${i}`;
                placeholder.dataset.pageNumber = i;
                placeholder.textContent = `Страница ${i}`;
                container.appendChild(placeholder);
            }
            
            updatePlaceholderSizes();
        }

        async function updatePlaceholderSizes() {
            if (!state.pdfDoc) return;
            
            const viewer = $('viewer');
            const container = $('pdfContainer');
            const containerWidth = container.clientWidth || viewer.clientWidth * 0.95;
            const viewerHeight = viewer.clientHeight - 100;

            const placeholders = document.querySelectorAll('.page-placeholder');
            
            for (const placeholder of placeholders) {
                const pageNum = parseInt(placeholder.dataset.pageNumber, 10);
                if (canvasMap.has(pageNum)) continue;
                
                try {
                    const page = await state.pdfDoc.getPage(pageNum);
                    const viewport = page.getViewport({scale: 1});
                    
                    let scale;
                    if (state.fitMode === 'width') {
                        scale = containerWidth / viewport.width;
                    } else {
                        scale = Math.min(viewerHeight / viewport.height, containerWidth / viewport.width);
                    }
                    
                    placeholder.style.width = Math.floor(viewport.width * scale) + 'px';
                    placeholder.style.height = Math.floor(viewport.height * scale) + 'px';
                } catch {}
            }
        }

        async function renderPage(num, placeholder) {
            if (!state.pdfDoc || num < 1 || num > state.pdfDoc.numPages) return;
            if (renderTaskMap.has(num)) return;

            try {
                const page = await state.pdfDoc.getPage(num);
                const viewer = $('viewer');
                const container = $('pdfContainer');
                const containerWidth = container.clientWidth || viewer.clientWidth * 0.95;
                const viewerHeight = viewer.clientHeight - 100;
                
                const viewport = page.getViewport({scale: 1});
                let scale;
                
                if (state.fitMode === 'width') {
                    scale = containerWidth / viewport.width;
                } else {
                    scale = Math.min(viewerHeight / viewport.height, containerWidth / viewport.width);
                }

                const dpr = window.devicePixelRatio || 1;
                const scaledViewport = page.getViewport({scale: scale * dpr});

                let canvas = canvasMap.get(num);
                const isNew = !canvas;

                if (!canvas) {
                    canvas = document.createElement('canvas');
                    canvas.id = `page-${num}`;
                    canvas.className = 'page-canvas';
                    canvas.dataset.pageNumber = num;
                    canvasMap.set(num, canvas);
                    
                    canvas.addEventListener('click', () => {
                        if (num !== state.pageNum) {
                            state.pageNum = num;
                            updatePageCounter();
                            highlightCurrentPage();
                        }
                    });
                }

                canvas.width = Math.floor(scaledViewport.width);
                canvas.height = Math.floor(scaledViewport.height);
                canvas.style.width = Math.floor(scaledViewport.width / dpr) + 'px';
                canvas.style.height = Math.floor(scaledViewport.height / dpr) + 'px';

                const ctx = canvas.getContext('2d', {alpha: false});
                const renderTask = page.render({canvasContext: ctx, viewport: scaledViewport});
                renderTaskMap.set(num, renderTask);

                await renderTask.promise;
                
                const actualPlaceholder = placeholder || $(`placeholder-${num}`);
                if (actualPlaceholder && actualPlaceholder.parentNode === container) {
                    container.replaceChild(canvas, actualPlaceholder);
                } else if (isNew && !document.getElementById(canvas.id)) {
                    const stillThere = $(`placeholder-${num}`);
                    if (stillThere && stillThere.parentNode === container) {
                        container.replaceChild(canvas, stillThere);
                    }
                }
                
                highlightCurrentPage();
                renderTaskMap.delete(num);
            } catch (err) {
                renderTaskMap.delete(num);
                if (err.name !== 'RenderingCancelledException') {
                    console.error(`Render error page ${num}:`, err);
                }
            }
        }

        function highlightCurrentPage() {
            document.querySelectorAll('.page-canvas').forEach(c => c.classList.remove('current'));
            const current = canvasMap.get(state.pageNum);
            if (current) current.classList.add('current');
        }

        function setupObserver() {
            if (observer) observer.disconnect();
            
            const viewer = $('viewer');
            observer = new IntersectionObserver(entries => {
                entries.forEach(entry => {
                    if (entry.isIntersecting) {
                        const num = parseInt(entry.target.dataset.pageNumber, 10);
                        if (entry.target.classList.contains('page-placeholder') && !canvasMap.has(num)) {
                            renderPage(num, entry.target);
                        }
                    }
                });
            }, {
                root: viewer,
                rootMargin: '300px 0px',
                threshold: 0.01
            });

            document.querySelectorAll('.page-placeholder').forEach(p => observer.observe(p));
        }

        function renderVisiblePages() {
            if (!state.pdfDoc) return;
            
            const viewer = $('viewer');
            const rect = viewer.getBoundingClientRect();
            
            document.querySelectorAll('.page-placeholder').forEach(p => {
                const pRect = p.getBoundingClientRect();
                if (pRect.bottom > rect.top - 300 && pRect.top < rect.bottom + 300) {
                    const num = parseInt(p.dataset.pageNumber, 10);
                    if (!canvasMap.has(num) && !renderTaskMap.has(num)) {
                        renderPage(num, p);
                    }
                }
            });
        }

        function scrollToPage(pageNum) {
            const target = canvasMap.get(pageNum) || $(`placeholder-${pageNum}`);
            if (!target) return;
            
            const viewer = $('viewer');
            const selector = $('pdfSelector');
            const offset = selector && selector.style.display !== 'none' ? selector.offsetHeight + 10 : 10;
            
            const viewerRect = viewer.getBoundingClientRect();
            const targetRect = target.getBoundingClientRect();
            const scrollTop = viewer.scrollTop + targetRect.top - viewerRect.top - offset;
            
            viewer.scrollTo({top: scrollTop, behavior: 'smooth'});
        }

        // Navigation
        function prevPage() {
            if (!state.pdfDoc || state.pageNum <= 1) return;
            state.pageNum--;
            scrollToPage(state.pageNum);
            updatePageCounter();
            highlightCurrentPage();
        }

        function nextPage() {
            if (!state.pdfDoc || state.pageNum >= state.pdfDoc.numPages) return;
            state.pageNum++;
            scrollToPage(state.pageNum);
            updatePageCounter();
            highlightCurrentPage();
        }

        // Fit mode
        function toggleFit() {
            state.fitMode = state.fitMode === 'width' ? 'height' : 'width';
            updateFitIcon();
            if (state.pdfDoc) {
                updatePlaceholderSizes();
                canvasMap.forEach((canvas, num) => {
                    if (document.body.contains(canvas)) renderPage(num, null);
                });
            }
        }

        function updateFitIcon() {
            const icon = $('fitIcon');
            const isHeight = state.fitMode === 'height';
            icon.innerHTML = isHeight
                ? '<path d="M10 4H8v4H4v2h6V4zm6 16h2v-4h4v-2h-6v6zm-8-2H4v-4H2v6h6v-2zM18 8V4h-2v6h6V8h-4z"/>'
                : '<path d="M19 12h-2v3h-3v2h5v-5zM7 9h3V7H5v5h2V9zm14-6H3c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h18c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm0 16.01H3V4.99h18v14.02z"/>';
            $('toggleFit').classList.toggle('active', isHeight);
        }

        // Fullscreen
        function toggleFullscreen() {
            const doc = document.documentElement;
            if (!document.fullscreenElement) {
                if (doc.requestFullscreen) doc.requestFullscreen();
                else if (doc.webkitRequestFullscreen) doc.webkitRequestFullscreen();
            } else {
                if (document.exitFullscreen) document.exitFullscreen();
                else if (document.webkitExitFullscreen) document.webkitExitFullscreen();
            }
        }

        function updateFullscreenIcon() {
            const isFs = !!document.fullscreenElement || !!document.webkitFullscreenElement;
            $('fullscreenIcon').innerHTML = isFs
                ? '<path d="M5 16h3v3h2v-5H5v2zm3-8H5v2h5V5H8v3zm6 11h2v-3h3v-2h-5v5zm2-11V5h-2v5h5V8h-3z"/>'
                : '<path d="M7 14H5v5h5v-2H7v-3zm-2-4h2V7h3V5H5v5zm12 7h-3v2h5v-5h-2v3zM14 5v2h3v3h2V5h-5z"/>';
        }

        // Thumbnails
        function showThumbnails() {
            if (!extractedPdfs.size) return;
            
            $('thumbnailOverlay').style.display = 'flex';
            $('mergeBtn').style.display = extractedPdfs.size >= 2 ? 'flex' : 'none';
            
            if (!state.thumbnailsGenerated) {
                setTimeout(() => generateThumbnails(), 50);
            } else {
                highlightCurrentThumbnail();
            }
        }

        function hideThumbnails() {
            $('thumbnailOverlay').style.display = 'none';
            
            if (!state.pdfDoc) {
                $('startScreen').style.display = 'flex';
                $('viewer').style.display = 'none';
                $('controls').style.display = 'none';
            }
        }

        async function generateThumbnails() {
            showLoading(true);
            const container = $('thumbnailContainer');
            container.innerHTML = '';
            
            const containerWidth = container.clientWidth || 500;
            const cols = Math.max(2, Math.min(6, Math.floor(containerWidth / 140)));
            container.style.gridTemplateColumns = `repeat(${cols}, 1fr)`;
            const thumbWidth = Math.floor((containerWidth - (cols - 1) * 12) / cols) - 16;

            const sortedNames = Array.from(extractedPdfs.keys()).sort((a, b) => 
                a.localeCompare(b, undefined, {numeric: true}));

            for (const pdfName of sortedNames) {
                const pdfData = extractedPdfs.get(pdfName);
                if (!pdfData) continue;

                if (state.filesMode === 'zip' || state.filesMode === 'multiple') {
                    const sep = document.createElement('div');
                    sep.className = 'thumbnail-separator';
                    sep.innerHTML = `<span title="${pdfName}">${pdfName.split('/').pop()}</span>`;
                    container.appendChild(sep);
                }

                try {
                    let doc = pdfDocCache.get(pdfName);
                    if (!doc) {
                        doc = await pdfjsLib.getDocument({data: pdfData.slice()}).promise;
                        pdfDocCache.set(pdfName, doc);
                    }

                    for (let i = 1; i <= doc.numPages; i++) {
                        await createThumbnail(doc, pdfName, i, container, thumbWidth);
                    }
                } catch (err) {
                    console.error(`Thumbnail error for ${pdfName}:`, err);
                }
            }

            state.thumbnailsGenerated = true;
            highlightCurrentThumbnail();
            showLoading(false);
        }

        async function createThumbnail(doc, pdfName, pageNum, container, maxWidth) {
            const item = document.createElement('div');
            item.className = 'thumbnail-item';
            item.dataset.pageNumber = pageNum;
            item.dataset.pdfName = pdfName;

            const canvas = document.createElement('canvas');
            canvas.className = 'thumbnail-canvas';

            const label = document.createElement('div');
            label.className = 'thumbnail-pagenum';
            label.textContent = pageNum;

            item.appendChild(canvas);
            item.appendChild(label);
            container.appendChild(item);

            let clickTimer = null;

            item.addEventListener('click', e => {
                clearTimeout(clickTimer);
                clickTimer = setTimeout(() => {
                    showPreview(pdfName, pageNum);
                }, 200);
            });

            item.addEventListener('dblclick', async () => {
                clearTimeout(clickTimer);
                
                if (extractedPdfs.has(pdfName)) {
                    showLoading(true);
                    $('pdfSelectDropdown').value = pdfName;
                    await loadPdf(extractedPdfs.get(pdfName).slice(), pdfName, pageNum);
                    hidePreview();
                    hideThumbnails();
                    showLoading(false);
                }
            });

            try {
                const page = await doc.getPage(pageNum);
                const viewport = page.getViewport({scale: 1});
                const scale = maxWidth / viewport.width;
                const dpr = window.devicePixelRatio || 1;
                const scaledViewport = page.getViewport({scale: scale * dpr});

                canvas.width = Math.floor(scaledViewport.width);
                canvas.height = Math.floor(scaledViewport.height);
                canvas.style.width = Math.floor(scaledViewport.width / dpr) + 'px';
                canvas.style.height = Math.floor(scaledViewport.height / dpr) + 'px';

                const ctx = canvas.getContext('2d', {alpha: false});
                await page.render({canvasContext: ctx, viewport: scaledViewport}).promise;
            } catch (err) {
                canvas.style.display = 'none';
                label.textContent = `Ошибка ${pageNum}`;
                label.style.color = '#dc2626';
            }
        }

        function highlightCurrentThumbnail() {
            const dropdown = $('pdfSelectDropdown');
            const currentPdf = (state.filesMode === 'zip' || state.filesMode === 'multiple') 
                ? dropdown?.value 
                : state.currentArchiveName;

            document.querySelectorAll('.thumbnail-item').forEach(t => {
                t.classList.remove('current');
                if (t.dataset.pdfName === currentPdf && parseInt(t.dataset.pageNumber) === state.pageNum) {
                    t.classList.add('current');
                }
            });
        }

        // Preview
        async function showPreview(pdfName, pageNum) {
            showLoading(true);
            const modal = $('previewModal');
            const canvas = $('previewCanvas');

            try {
                let doc = pdfDocCache.get(pdfName);
                if (!doc && extractedPdfs.has(pdfName)) {
                    doc = await pdfjsLib.getDocument({data: extractedPdfs.get(pdfName).slice()}).promise;
                    pdfDocCache.set(pdfName, doc);
                }
                if (!doc) throw new Error('Document not found');

                const page = await doc.getPage(pageNum);
                const viewport = page.getViewport({scale: 1});
                
                const maxW = window.innerWidth * 0.9;
                const maxH = window.innerHeight * 0.9;
                const scale = Math.min(maxW / viewport.width, maxH / viewport.height);
                const scaledViewport = page.getViewport({scale});

                canvas.width = scaledViewport.width;
                canvas.height = scaledViewport.height;

                const ctx = canvas.getContext('2d');
                await page.render({canvasContext: ctx, viewport: scaledViewport}).promise;

                modal.classList.add('active');
            } catch (err) {
                console.error('Preview error:', err);
            } finally {
                showLoading(false);
            }
        }

        function hidePreview() {
            $('previewModal').classList.remove('active');
        }

        // Merge
        async function showMergeModal() {
            if (extractedPdfs.size < 2) {
                alert('Нужно минимум 2 PDF файла');
                return;
            }

            showLoading(true);
            const list = $('mergeList');
            list.innerHTML = '';

            const sortedNames = Array.from(extractedPdfs.keys()).sort((a, b) => 
                a.localeCompare(b, undefined, {numeric: true}));

            for (const name of sortedNames) {
                try {
                    let doc = pdfDocCache.get(name);
                    if (!doc) {
                        doc = await pdfjsLib.getDocument({data: extractedPdfs.get(name).slice()}).promise;
                        pdfDocCache.set(name, doc);
                    }

                    const item = document.createElement('div');
                    item.className = 'merge-item';
                    item.draggable = true;
                    item.dataset.pdfName = name;
                    item.dataset.maxPages = doc.numPages;

                    item.innerHTML = `
                        <div class="drag-handle">
                            <svg style="width:18px;height:18px" viewBox="0 0 24 24" fill="currentColor">
                                <path d="M3 15h18v-2H3v2zm0 4h18v-2H3v2zm0-8h18V9H3v2zm0-6v2h18V5H3z"/>
                            </svg>
                        </div>
                        <span class="merge-item-name" title="${name}">${name.split('/').pop()}</span>
                        <input class="merge-item-input" type="text" placeholder="1-${doc.numPages}">
                        <span class="merge-item-count">${doc.numPages} стр.</span>
                    `;

                    list.appendChild(item);
                } catch {}
            }

            showLoading(false);
            $('mergeModal').classList.add('active');
        }

        function hideMergeModal() {
            $('mergeModal').classList.remove('active');
        }

        function parseRanges(str, max) {
            const pages = new Set();
            if (!str.trim()) {
                for (let i = 1; i <= max; i++) pages.add(i);
                return Array.from(pages);
            }

            const parts = str.replace(/,/g, ' ').split(/\s+/);
            for (const part of parts) {
                if (!part) continue;
                
                if (part.includes('-')) {
                    const [start, end] = part.split('-').map(n => parseInt(n, 10));
                    if (!isNaN(start) && !isNaN(end) && start <= end && start > 0 && end <= max) {
                        for (let i = start; i <= end; i++) pages.add(i);
                    }
                } else {
                    const n = parseInt(part, 10);
                    if (!isNaN(n) && n > 0 && n <= max) pages.add(n);
                }
            }
            
            return Array.from(pages).sort((a, b) => a - b);
        }

        async function executeMerge() {
            showLoading(true);
            
            try {
                const {PDFDocument} = PDFLib;
                const merged = await PDFDocument.create();
                const items = document.querySelectorAll('.merge-item');

                for (const item of items) {
                    const name = item.dataset.pdfName;
                    const max = parseInt(item.dataset.maxPages, 10);
                    const range = item.querySelector('.merge-item-input').value;
                    const pages = parseRanges(range, max);
                    
                    if (!pages.length) continue;

                    const srcBytes = extractedPdfs.get(name);
                    const srcDoc = await PDFDocument.load(srcBytes);
                    const copied = await merged.copyPages(srcDoc, pages.map(n => n - 1));
                    copied.forEach(p => merged.addPage(p));
                }

                if (merged.getPageCount() === 0) {
                    alert('Не выбрано ни одной страницы');
                    showLoading(false);
                    return;
                }

                const bytes = await merged.save();
                const blob = new Blob([bytes], {type: 'application/pdf'});
                const url = URL.createObjectURL(blob);
                
                const a = document.createElement('a');
                a.href = url;
                a.download = 'merged.pdf';
                a.click();
                
                URL.revokeObjectURL(url);
                hideMergeModal();
            } catch (err) {
                console.error('Merge error:', err);
                alert('Ошибка при объединении: ' + err.message);
            } finally {
                showLoading(false);
            }
        }

        // Drag handlers for merge
        function setupMergeDrag() {
            const list = $('mergeList');
            
            list.addEventListener('dragstart', e => {
                if (e.target.classList.contains('merge-item')) {
                    draggedItem = e.target;
                    setTimeout(() => e.target.classList.add('dragging'), 0);
                }
            });

            list.addEventListener('dragend', () => {
                if (draggedItem) {
                    draggedItem.classList.remove('dragging');
                    draggedItem = null;
                }
            });

            list.addEventListener('dragover', e => {
                e.preventDefault();
                const dragging = document.querySelector('.merge-item.dragging');
                if (!dragging) return;
                
                const siblings = [...list.querySelectorAll('.merge-item:not(.dragging)')];
                const next = siblings.find(s => {
                    const rect = s.getBoundingClientRect();
                    return e.clientY < rect.top + rect.height / 2;
                });
                
                if (next) list.insertBefore(dragging, next);
                else list.appendChild(dragging);
            });
        }

        // Event listeners
        document.addEventListener('DOMContentLoaded', () => {
            // File input
            $('upload').addEventListener('change', e => {
                handleFiles(e.target.files);
                e.target.value = null;
            });

            // Drop area & open buttons
            $('dropArea').addEventListener('click', () => $('upload').click());
            $('openFile').addEventListener('click', () => $('upload').click());

            // Drag & drop
            const dropArea = $('dropArea');
            const container = $('container');
            
            ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(ev => {
                dropArea.addEventListener(ev, e => { e.preventDefault(); e.stopPropagation(); });
                container.addEventListener(ev, e => { e.preventDefault(); e.stopPropagation(); });
            });

            ['dragenter', 'dragover'].forEach(ev => {
                dropArea.addEventListener(ev, () => dropArea.classList.add('highlighted'));
            });

            ['dragleave', 'drop'].forEach(ev => {
                dropArea.addEventListener(ev, () => dropArea.classList.remove('highlighted'));
            });

            dropArea.addEventListener('drop', e => handleFiles(e.dataTransfer.files));
            container.addEventListener('drop', e => handleFiles(e.dataTransfer.files));

            // Navigation
            $('prevPage').addEventListener('click', prevPage);
            $('nextPage').addEventListener('click', nextPage);
            $('toggleFit').addEventListener('click', toggleFit);
            $('fullscreenBtn').addEventListener('click', toggleFullscreen);

            // PDF selector
            $('pdfSelectDropdown').addEventListener('change', async e => {
                const name = e.target.value;
                if (extractedPdfs.has(name)) {
                    showLoading(true);
                    state.thumbnailsGenerated = false;
                    $('thumbnailContainer').innerHTML = '';
                    pdfDocCache.clear();
                    await loadPdf(extractedPdfs.get(name).slice(), name);
                    showLoading(false);
                }
            });

            // Thumbnails
            $('thumbnailBtn').addEventListener('click', () => {
                if ($('thumbnailOverlay').style.display === 'flex') {
                    hideThumbnails();
                } else {
                    showThumbnails();
                }
            });

            $('closeThumbnails').addEventListener('click', hideThumbnails);
            $('thumbnailOverlay').addEventListener('click', e => {
                if (e.target === $('thumbnailOverlay')) hideThumbnails();
            });

            // Preview
            $('previewModal').addEventListener('click', hidePreview);

            // Merge
            $('mergeBtn').addEventListener('click', showMergeModal);
            $('cancelMerge').addEventListener('click', hideMergeModal);
            $('confirmMerge').addEventListener('click', executeMerge);
            $('mergeModal').addEventListener('click', e => {
                if (e.target === $('mergeModal')) hideMergeModal();
            });

            setupMergeDrag();

            // Keyboard
            document.addEventListener('keydown', e => {
                if ($('thumbnailOverlay').style.display === 'flex' && e.key === 'Escape') {
                    hideThumbnails();
                    return;
                }
                if ($('previewModal').classList.contains('active') && e.key === 'Escape') {
                    hidePreview();
                    return;
                }
                if ($('mergeModal').classList.contains('active') && e.key === 'Escape') {
                    hideMergeModal();
                    return;
                }
                
                if (!state.pdfDoc || e.target.closest('input, select')) return;
                
                if (e.key === 'ArrowRight' || e.key === ' ') nextPage();
                else if (e.key === 'ArrowLeft') prevPage();
            });

            // Resize
            let resizeTimer;
            window.addEventListener('resize', () => {
                clearTimeout(resizeTimer);
                resizeTimer = setTimeout(() => {
                    if (state.pdfDoc) {
                        updatePlaceholderSizes();
                        canvasMap.forEach((canvas, num) => {
                            if (document.body.contains(canvas)) renderPage(num, null);
                        });
                    }
                }, 200);
            });

            // Fullscreen change
            ['fullscreenchange', 'webkitfullscreenchange'].forEach(ev => {
                document.addEventListener(ev, updateFullscreenIcon);
            });

            // File info hover
            let infoTimer;
            $('controls').addEventListener('mouseenter', () => {
                clearTimeout(infoTimer);
                $('fileInfo').classList.add('visible');
            });
            $('controls').addEventListener('mouseleave', () => {
                infoTimer = setTimeout(() => {
                    $('fileInfo').classList.remove('visible');
                }, 500);
            });

            updateFitIcon();
        });
    </script>
</body>
</html>