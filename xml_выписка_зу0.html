

<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Просмотр XML-выписки</title>
    <link rel="stylesheet" href="webfonts/all.min.css">
    <script src="webfonts/jszip.min.js"></script>
<link rel="icon" href="https://img.icons8.com/?size=100&id=12053&format=png&color=000000" type="image/png">
    <style>
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            margin: 20px;
            background-color: #f0f0f0;
        }
        .file-input-wrapper {
            position: relative;
            display: inline-block;
            margin: 20px auto;
            text-align: center;
            width: 100%;
        }
        .file-input-wrapper input[type="file"] {
            position: absolute;
            left: -9999px;
        }
        .file-input-wrapper label {
            display: inline-block;
            padding: 10px 20px;
            background-color: #4CAF50;
            color: white;
            cursor: pointer;
            border-radius: 5px;
            font-size: 16px;
            transition: all 0.3s ease;
            transform: translateY(-50px);
            opacity: 0;
            animation: dropIn 0.5s forwards;
        }
        @keyframes dropIn {
            0% {
                transform: translateY(-50px);
                opacity: 0;
            }
            100% {
                transform: translateY(0);
                opacity: 1;
            }
        }
        .file-input-wrapper label:hover {
            background-color: #45a049;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.1);
        }
        td, th {
            border: 1px solid #ddd;
            padding: 12px;
            text-align: left;
            transition: background-color 0.3s;
        }
        tr:nth-child(even) {
            background-color: #f8f8f8;
        }
        tr:nth-child(odd) {
            background-color: #ffffff;
        }
        tr:hover {
            background-color: #f8f8f8;
            box-shadow: 0 0 10px rgba(0, 0, 255, 0.2);
        }
        .copyable {
            cursor: pointer;
            transition: color 0.3s;
        }
        .copyable:hover {
            color: black;
        }
        .flash {
            animation: flash 1s;
        }
        @keyframes flash {
            0%, 100% { background-color: inherit; }
            50% { background-color:  #00FF7F; }
        }
        .clickable {
            cursor: pointer;
            color: black;
         
            transition: color 0.3s;
        }
        .clickable:hover {
         
        }
        .coordinates-table {
            width: 100%;
            border-collapse: collapse;
            display: none;
            margin-top: 10px;
        }
        .coordinates-table th, .coordinates-table td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: center;
        }
        .coordinates-table th {
            background-color: #f2f2f2;
        }
        .button-group {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 10px;
        }
        .button {
            padding: 14px 21px;
            color: white;
            border: none;
            border-radius: 12px;
            cursor: pointer;
            font-size: 16px;
            transition: all 0.6s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: rgba(76, 175, 80, 0.9);
            position: relative;
            overflow: hidden;
        }
        .button:hover {
            background-color: rgba(76, 175, 80, 0.9);
        }
        .button:active {
            transform: translateY(1px);
        }
        .button i {
            margin-right: 5px;
        }
        .button::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: #0FF7F;
            transform: rotate(45deg);
            transition: all 0.3s ease;
            opacity: 0;
        }
        .button:hover::before {
            animation: flashButton 0.6s;
        }
        .button.export {
            background-color: rgba(65, 105, 225, 0.7);
        }
        .button.export:hover {
            background-color: rgba(65, 105, 225, 0.9);
        }
        @keyframes flashButton {
            0% {
                opacity: 0;
                transform: translate(-50%, -50%) rotate(45deg);
            }
            50% {
                opacity: 1;
            }
            100% {
                opacity: 0;
                transform: translate(50%, 50%) rotate(45deg);
            }
        }
        .rights-header {
            cursor: pointer;
            color: black;
        }
        .rights-header:hover {
   
        }
        .rights-info {
            cursor: default;
        }
        .right-info {
            cursor: pointer;
        }
        .right-info:hover {
            background-color: #f0f0f0;
        }
    </style>
</head>
<body>
    <div class="file-input-wrapper">
            <input type="file" id="fileInput" accept=".xml,.zip">
        <label for="fileInput" id="fileInputLabel">Открыть XML выписку земельного участка</label>
    </div>
    <div id="output"></div>
    


    <script>
    
    let currentCoords = null;
let schemeCreated = false;
let showDistances = true;
let showPointNumbers = true;


   
    function getElementValue(element, tagName) {
        if (!element) return '';
        const parts = tagName.split('>');
        let currentElement = element;
        for (let part of parts) {
            currentElement = currentElement.querySelector(part);
            if (!currentElement) return '';
        }
        return currentElement.textContent.trim();
    }

function extractCoordinatesFromXML(xmlContent) {
    const parser = new DOMParser();
    const xmlDoc = parser.parseFromString(xmlContent, "text/xml");
    const contours = [];

    const contoursElements = xmlDoc.querySelectorAll("contours > contour:not(object_parts contours > contour)");
    
    contoursElements.forEach((contourElement) => {
        const contour = [];
        const ordinates = contourElement.querySelectorAll("ordinates > ordinate");
        ordinates.forEach((ordinate) => {
            const x = parseFloat(ordinate.querySelector("x")?.textContent || "");
            const y = parseFloat(ordinate.querySelector("y")?.textContent || "");
            const ordNmb = parseInt(ordinate.querySelector("ord_nmb")?.textContent || "");
            const delta = parseFloat(ordinate.querySelector("delta_geopoint")?.textContent || "0");
            if (!isNaN(x) && !isNaN(y)) {
                contour.push({x, y, ordNmb: isNaN(ordNmb) ? null : ordNmb, delta});
            }
        });
        if (contour.length > 0) {
            contours.push(contour);
        }
    });

    if (contours.length === 0) {
        const spatialElement = xmlDoc.querySelector("spatial_element:not(object_parts spatial_element)");
        if (spatialElement) {
            const contour = [];
            const ordinates = spatialElement.querySelectorAll("ordinate");
            ordinates.forEach((ordinate) => {
                const x = parseFloat(ordinate.querySelector("x")?.textContent || "");
                const y = parseFloat(ordinate.querySelector("y")?.textContent || "");
                const ordNmb = parseInt(ordinate.querySelector("ord_nmb")?.textContent || "");
                const delta = parseFloat(ordinate.querySelector("delta_geopoint")?.textContent || "0");
                if (!isNaN(x) && !isNaN(y)) {
                    contour.push({x, y, ordNmb: isNaN(ordNmb) ? null : ordNmb, delta});
                }
            });
            if (contour.length > 0) {
                contours.push(contour);
            }
        }
    }

    if (contours.length === 0) {
        console.error('Не удалось извлечь координаты из XML');
    }

    return contours;
}


    function extractShortAddress(fullAddress) {
        let settlement = fullAddress.match(/\s(с|г|город|д|д\.)\s([А-Яа-я\-]+)/);
        settlement = settlement ? settlement[2] : '';

        let street = fullAddress.match(/\s(ул|ул\.|улица)\s*\.?\s*([А-Яа-я\-]+)/);
        street = street ? street[2] : '';

        let houseNumber = fullAddress.match(/(\d+)(?!.*\d)/);
        houseNumber = houseNumber ? houseNumber[1] : '';

        let shortAddress = [settlement, street, houseNumber].filter(Boolean).join(' ');

        return shortAddress;
    }
    
    function generateSearchUrl(surname, name) {
    return `https://www.np-okirt.ru/o-partnerstve/reestr-chlenov-partnerstva/index.php?search-type=SECOND_NAME&search-type-value=${encodeURIComponent(surname)}&search-type-2=NAME&search-type-value-2=${encodeURIComponent(name)}&region=&city=`;
}


function extractData(xmlContent) {
    const parser = new DOMParser();
    const xmlDoc = parser.parseFromString(xmlContent, "text/xml");

    // ... (остальной код функции extractData без изменений, до блока с координатами) ...
    // Извлечение данных о кадастровом инженере
    const surname = getElementValue(xmlDoc, 'cad_works > cad_work > fio_cad_ingineer > surname') || '';
    const name = getElementValue(xmlDoc, 'cad_works > cad_work > fio_cad_ingineer > name') || '';
    const patronymic = getElementValue(xmlDoc, 'cad_works > cad_work > fio_cad_ingineer > patronymic') || '';
    const cadastralEngineerNumber = getElementValue(xmlDoc, 'cad_works > cad_work > cadastral_engineer_registry_number') || '';
    const cadastralEngineer = `${surname} ${name} ${patronymic} (№ ${cadastralEngineerNumber})`.trim();

    // Извлечение основных данных об объекте
    const cadNumber = getElementValue(xmlDoc, 'land_record > object > common_data > cad_number') || '';
    const formattedCadNumber = cadNumber.replace(/:/g, '_');
    const date = getElementValue(xmlDoc, 'details_statement > group_top_requisites > date_formation') || '';
    const objectType = getElementValue(xmlDoc, 'land_record > object > common_data > type > value') || '';
    const category = getElementValue(xmlDoc, 'land_record > params > category > type > value') || '';
    const address = getElementValue(xmlDoc, 'land_record > address_location > address > readable_address') || '';
    const shortAddress = extractShortAddress(address);

    const includedObjectsElements = xmlDoc.querySelectorAll('land_record > cad_links > included_objects > included_object > cad_number') || [];
    const includedObjects = Array.from(includedObjectsElements).map(el => el.textContent);
    const includedObjectsString = includedObjects.join(' ');

    const areaElement = xmlDoc.querySelector('land_record > params > area');
    const areaType = areaElement ? getElementValue(areaElement, 'type > value') : '';
    const areaValues = areaElement ? areaElement.querySelectorAll('value') : [];

    const searchUrl = generateSearchUrl(surname, name);

    let areaValue = '';
    if (areaValues.length > 0) {
        for (let valueElement of areaValues) {
            const value = valueElement.textContent.trim();
            if (/^\d+(\.\d+)?$/.test(value)) {
                areaValue = value;
                break;
            }
        }
    }
    const areaInaccuracy = areaElement ? getElementValue(areaElement, 'inaccuracy') : '';

    let areaString = '';
    if (areaValue) {
        if (areaInaccuracy && areaInaccuracy !== '') {
            areaString = `${areaValue} +/- ${areaInaccuracy} кв.м.`;
        } else {
            areaString = `${areaValue} кв.м.`;
        }
    }

    let displayAreaType = areaType || 'Площадь';

    const permittedUse = getElementValue(xmlDoc, 'land_record > params > permitted_use > permitted_use_established > by_document') || '';

    const registrationDate = getElementValue(xmlDoc, 'land_record > record_info > registration_date') || '';
    const formattedRegistrationDate = registrationDate ? new Date(registrationDate).toLocaleDateString('ru-RU') : '';

    const regNumber = getElementValue(xmlDoc, 'details_statement > group_top_requisites > registration_number') || '';
    const organ = getElementValue(xmlDoc, 'details_statement > group_top_requisites > organ_registr_rights') || '';

    const cadastralValue = getElementValue(xmlDoc, 'land_record > cost > value') || '';
    const formattedCadastralValue = cadastralValue ? parseFloat(cadastralValue).toLocaleString('ru-RU', { minimumFractionDigits: 2, maximumFractionDigits: 2 }) + ' руб.' : 'Нет данных';

    // Извлечение данных о правах
    const rightRecords = xmlDoc.querySelectorAll('right_records > right_record') || [];
    let rightsInfo = [];

    rightRecords.forEach((record, index) => {
        const rightType = getElementValue(record, 'right_data > right_type > value') || '';
        const rightNumber = getElementValue(record, 'right_data > right_number') || '';
        const registrationDate = getElementValue(record, 'record_info > registration_date') || '';
        const formattedRegistrationDate = registrationDate ? new Date(registrationDate).toLocaleDateString('ru-RU') : '';

        const shares = record.querySelector('right_data > shares > share');
        let shareInfo = '';
        if (shares) {
            const numerator = getElementValue(shares, 'numerator') || '';
            const denominator = getElementValue(shares, 'denominator') || '';
            if (numerator && denominator) {
                shareInfo = `${numerator}/${denominator}`;
            }
        }

        const shareDescription = getElementValue(record, 'right_data > share_description') || '';

        const rightHolders = record.querySelectorAll('right_holders > right_holder') || [];
        rightHolders.forEach((holder) => {
            const individual = holder.querySelector('individual');
            const legalEntity = holder.querySelector('legal_entity');
            const publicFormation = holder.querySelector('public_formation');

            let ownerInfo = '';
            if (individual) {
                const surname = getElementValue(individual, 'surname') || '';
                const name = getElementValue(individual, 'name') || '';
                const patronymic = getElementValue(individual, 'patronymic') || '';
                const birthDate = getElementValue(individual, 'birth_date') || '';
                const formattedBirthDate = birthDate ? new Date(birthDate).toLocaleDateString('ru-RU') : '-';
                ownerInfo = `${surname} ${name} ${patronymic} ${formattedBirthDate}`.trim();
            } else if (legalEntity) {
                ownerInfo = getElementValue(legalEntity, 'entity > government_entity > full_name') ||
                           getElementValue(legalEntity, 'entity > resident > name') ||
                           getElementValue(legalEntity, 'name') ||
                           '';
            } else if (publicFormation) {
                ownerInfo = getElementValue(publicFormation, 'public_formation_type > municipality > name') ||
                           getElementValue(publicFormation, 'name') ||
                           '';
            }

            if (ownerInfo) {
                rightsInfo.push(`<span class="right-info" data-index="${index}">${ownerInfo}   ${rightType}   ${shareInfo} ${shareDescription}   ${rightNumber} от ${formattedRegistrationDate}</span>`);
            }
        });
    });

    const rightsInfoString = rightsInfo.join('<br>');

    // Извлечение данных об ограничениях и обременениях
    const restrictRecords = xmlDoc.querySelectorAll('restrict_records > restrict_record') || [];
    let restrictionsInfo = [];

    restrictRecords.forEach((record) => {
        const restrictionType = getElementValue(record, 'restrictions_encumbrances_data > restriction_encumbrance_type > value') || '';
        const restrictionNumber = getElementValue(record, 'restrictions_encumbrances_data > restriction_encumbrance_number') || '';
        const registrationDate = getElementValue(record, 'record_info > registration_date') || '';
        const formattedRegistrationDate = registrationDate ? new Date(registrationDate).toLocaleDateString('ru-RU') : '';

        const periodStart = getElementValue(record, 'restrictions_encumbrances_data > period > period_info > start_date') || '';
        const periodEnd = getElementValue(record, 'restrictions_encumbrances_data > period > period_info > end_date') || '';
        const periodInfo = periodStart && periodEnd ? ` (${periodStart} - ${periodEnd})` : '';

        const rightHolders = record.querySelectorAll('right_holders > right_holder') || [];
        rightHolders.forEach((holder) => {
            const legalEntity = holder.querySelector('legal_entity');
            if (legalEntity) {
                const name = getElementValue(legalEntity, 'entity > resident > name') || '';
                const inn = getElementValue(legalEntity, 'entity > resident > inn') || '';
                const ogrn = getElementValue(legalEntity, 'entity > resident > ogrn') || '';
                restrictionsInfo.push(`${restrictionType} ${restrictionNumber} от ${formattedRegistrationDate}${periodInfo} (${name}, ИНН: ${inn}, ОГРН: ${ogrn})`);
            }
        });

        const underlyingDocument = record.querySelector('underlying_documents > underlying_document');
        if (underlyingDocument) {
            const documentName = getElementValue(underlyingDocument, 'document_name') || '';
            const documentNumber = getElementValue(underlyingDocument, 'document_number') || '';
            const documentDate = getElementValue(underlyingDocument, 'document_date') || '';
            restrictionsInfo.push(`Документ: ${documentName} №${documentNumber} от ${documentDate}`);
        }
    });

    const restrictionsInfoString = restrictionsInfo.join('<br>') || 'Нет данных';

    // Извлечение данных из раздела special_notes
    const specialNotes = getElementValue(xmlDoc, 'special_notes') || '';
    const specialNotesString = specialNotes || 'Нет данных';

       // Извлечение координат
    const coordinates = extractCoordinatesFromXML(xmlContent);
    let coordinatesString = '';
    if (coordinates.length > 0) {
        coordinatesString = `
        <div class="button-group">
        <button class="button" id="toggleCoordinates"><i class="fas fa-eye"></i></button>
        <button class="button" id="copyCoordinates"><i class="fas fa-copy"></i></button>
<button class="button" id="copyCoordinatesAndMap" onclick="copyCoordinatesAndOpenMap()"><i class="fas fa-map-marked"></i></button>
        <button class="button secondary" id="exportDXF"><i class="fas fa-file-export"></i>DXF</button>
        <button class="button secondary" id="exportMIF"><i class="fas fa-file-export"></i>MIF</button>
        <button class="button secondary" id="exportCSV"><i class="fas fa-file-csv"></i>CSV</button>
    </div>
    <table class="coordinates-table">
                <tr>
                    <th>Контур</th>
                    <th>№ точки</th>
                    <th>Координата X</th>
                    <th>Координата Y</th>
                    <th>Погрешность</th>
                </tr>
                ${coordinates.map((contour, contourIndex) =>
                    contour.map((coord, pointIndex) => `
                        <tr>
                            <td>${contourIndex + 1}</td>
                            <td>${coord.ordNmb || pointIndex + 1}</td>
                            <td>${typeof coord.x === 'number' ? coord.x.toFixed(2) : ''}</td>
                            <td>${typeof coord.y === 'number' ? coord.y.toFixed(2) : ''}</td>
                            <td>${coord.delta.toFixed(2)}</td>
                        </tr>
                    `).join('')
                ).join('')}
            </table>
        `;
    } else {
        coordinatesString = '<p>Координаты не найдены</p>';
    }

     return `
        <table>
        <tr><td class="clickable" onclick="copyCadNumberAndOpenSite('${cadNumber}')">Кадастровый номер</td><td><span class="copyable">${cadNumber}</span></td></tr>
        <tr><td>Тип объекта</td><td><span class="copyable">${objectType}</span></td></tr>
        <tr><td>Категория</td><td><span class="copyable">${category}</span></td></tr>
        <tr><td class="clickable" onclick="window.open('https://yandex.ru/maps/?text=${encodeURIComponent(shortAddress)}', '_blank')">Адрес</td><td><span class="copyable">${address}</span></td></tr>
        <tr><td class="clickable" onclick="window.open('https://pkk.rosreestr.ru/#/search/?text=${includedObjectsString}&type=5', '_blank')">ОКС</td><td><span class="copyable">${includedObjectsString}</span></td></tr>
        <tr><td>${displayAreaType}</td><td><span class="copyable">${areaString}</span></td></tr>
        <tr><td>Вид разрешенного использования</td><td><span class="copyable">${permittedUse}</span></td></tr>
        <tr><td>Дата постановки на учет</td><td><span class="copyable">${formattedRegistrationDate}</span></td></tr>
        <tr><td class="clickable" onclick="window.open('${searchUrl}', '_blank')">Кадастровый инженер</td><td><span class="copyable">${cadastralEngineer}</span></td></tr>
        <tr><td>Кадастровая стоимость</td><td><span class="copyable">${formattedCadastralValue}</span></td></tr>
        <tr><td class="clickable" onclick="copyXMLAndOpenFile(event)">Номер выписки</td><td><span class="copyable">${regNumber}</span></td></tr>
        <tr><td>Дата выписки</td><td><span class="copyable">${date}</span></td></tr>
        <tr><td class="rights-header">Сведения о правах</td><td class="rights-info">${rightsInfoString}</td></tr>
        <tr><td>Ограничение права и обременение</td><td><span class="copyable">${restrictionsInfoString}</span></td></tr>
        <tr><td>Особые отметки</td><td><span class="copyable">${specialNotesString}</span></td></tr>
        <tr><td>Координаты</td><td>${coordinatesString}</td></tr>
    </table>`;
}



// Добавляем новую функцию для копирования XML и открытия файла
function copyXMLAndOpenFile(event) {
    event.preventDefault();
    if (window.xmlContent) {
        navigator.clipboard.writeText(window.xmlContent)
            .then(() => {
                event.target.closest('tr').classList.add('flash');
                setTimeout(() => {
                    event.target.closest('tr').classList.remove('flash');
                }, 1000);
                window.open('xml.html', '_blank');
            })
            .catch(err => {
                console.error('Failed to copy XML content:', err);
            });
    }
}


function copyCadNumberAndOpenSite(cadNumber) {
    // Копируем кадастровый номер в буфер обмена
    navigator.clipboard.writeText(cadNumber).then(() => {
        console.log('Кадастровый номер скопирован: ', cadNumber);
    }).catch(err => {
        console.error('Ошибка при копировании: ', err);
    });

    // Открываем сайт https://nspd.gov.ru/map
    window.open('https://nspd.gov.ru/map', '_blank');
}


function copyHandler(event) {
    const element = event.target;
    let textToCopy = '';
    
       // Add new condition for "Номер выписки"
    if (element.textContent.trim() === 'Номер выписки') {
        // Copy entire XML content
        textToCopy = window.xmlContent;
        copyToClipboard(textToCopy, element.closest('tr'));
        // Open xml.html in new tab
        window.open('xml.html', '_blank');
        return;
    }

    if (element.classList.contains('rights-header')) {
        // Получаем все элементы с классом right-info внутри rights-info
        const rightInfoElements = element.nextElementSibling.querySelectorAll('.right-info');
        
        // Извлекаем текст каждого элемента и создаем многострочный текст
        textToCopy = Array.from(rightInfoElements)
            .map(el => el.textContent.trim())
            .join('\n');
    } else if (element.classList.contains('right-info') || element.closest('.right-info')) {
        const rightInfo = element.classList.contains('right-info') ? element.textContent : element.closest('.right-info').textContent;
        const parts = rightInfo.split(/\s{3,}/);
        textToCopy = parts[0].trim();
    } else if (element.classList.contains('copyable')) {
        textToCopy = element.textContent;
    } else {
        return;
    }

    if (textToCopy) {
        copyToClipboard(textToCopy, element.closest('tr'));
    }
}


    function copyToClipboard(text, element) {
        navigator.clipboard.writeText(text).then(() => {
            element.classList.add('flash');
            setTimeout(() => {
                element.classList.remove('flash');
            }, 1000);
        }).catch(err => {
            console.error('Ошибка при копировании: ', err);
        });
    }

 function copyCoordinates() {
        const contours = extractCoordinatesFromXML(window.xmlContent);
        const textToCopy = contours.map(contour => 
            contour.map(coord => `${coord.x.toFixed(2)}\t${coord.y.toFixed(2)}`).join('\n')
        ).join('\n\n');

        navigator.clipboard.writeText(textToCopy).then(() => {
            const copyButton = document.getElementById('copyCoordinates');
            copyButton.classList.add('flash');
            setTimeout(() => {
                copyButton.classList.remove('flash');
            }, 1000);
        }).catch(err => {
            console.error('Ошибка при копировании: ', err);
        });
    }
    
function copyCoordinatesAndOpenMap() {
    console.log("copyCoordinatesAndOpenMap function called!");
    
    const button = document.getElementById('copyCoordinatesAndMap');
    if (!button) {
        console.error("Button element not found!");
        return;
    }
    
    if (!window.xmlContent) {
        console.error("No XML content available");
        return;
    }

    const contours = extractCoordinatesFromXML(window.xmlContent);
    if (!contours || contours.length === 0) {
        console.error("No coordinates found in XML");
        return;
    }

    const textToCopy = contours.map(contour => 
        contour.map(coord => `${coord.x.toFixed(2)}\t${coord.y.toFixed(2)}`).join('\n')
    ).join('\n\n');

    try {
        navigator.clipboard.writeText(textToCopy);
        console.log("Coordinates copied successfully");
        window.open('схема.html', '_blank');
    } catch (err) {
        console.error('Ошибка:', err);
    }
}


    
    function toggleCoordinates() {
        const table = document.querySelector('.coordinates-table');
        if (table.style.display === "none" || table.style.display === "") {
            table.style.display = "table";
        } else {
            table.style.display = "none";
        }
    }
    
    function isContourInside(innerContour, outerContour) {
    return innerContour.some(point => isPointInside(point, outerContour));
}

function isPointInside(point, polygon) {
    let inside = false;
    for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
        const xi = polygon[i].x, yi = polygon[i].y;
        const xj = polygon[j].x, yj = polygon[j].y;
        
        const intersect = ((yi > point.y) !== (yj > point.y))
            && (point.x < (xj - xi) * (point.y - yi) / (yj - yi) + xi);
        if (intersect) inside = !inside;
    }
    return inside;
}



function generateDXF(contours) {
    if (!Array.isArray(contours) || contours.length === 0) {
        console.error('Неверный формат данных контуров');
        return '';
    }

    let dxfContent = `0\nSECTION\n2\nHEADER\n0\nENDSEC\n`;
    dxfContent += `0\nSECTION\n2\nTABLES\n0\nENDSEC\n`;
    dxfContent += `0\nSECTION\n2\nBLOCKS\n0\nENDSEC\n`;
    dxfContent += `0\nSECTION\n2\nENTITIES\n`;

    contours.forEach((contour, contourIndex) => {
        if (!Array.isArray(contour) || contour.length === 0) {
            console.warn(`Пропущен недопустимый контур с индексом ${contourIndex}`);
            return;
        }

        const isClosed = isClosedContour(contour);
        const pointsToProcess = isClosed ? contour.length - 1 : contour.length;

        dxfContent += `0\nLWPOLYLINE\n8\n${contourIndex}\n70\n${isClosed ? 1 : 0}\n`;
        dxfContent += `90\n${pointsToProcess}\n`;

        for (let i = 0; i < pointsToProcess; i++) {
            const point = contour[i];
            if (typeof point !== 'object' || !('x' in point) || !('y' in point)) {
                console.warn(`Пропущена недопустимая точка в контуре ${contourIndex}, индекс ${i}`);
                continue;
            }
            dxfContent += `10\n${point.y.toFixed(2)}\n20\n${point.x.toFixed(2)}\n`;
        }
    });

    dxfContent += `0\nENDSEC\n0\nSECTION\n2\nOBJECTS\n0\nENDSEC\n0\nEOF\n`;
    return dxfContent;
}


    function isClosedContour(contour) {
        if (contour.length < 3) return false;
        const firstPoint = contour[0];
        const lastPoint = contour[contour.length - 1];
        return Math.abs(firstPoint.x - lastPoint.x) < 0.001 && 
               Math.abs(firstPoint.y - lastPoint.y) < 0.001;
    }
    
    

function generateMIF(contours) {
    if (!Array.isArray(contours) || contours.length === 0) {
        console.error('Неверный формат данных контуров');
        return '';
    }

    // Находим границы для всех контуров
    const allPoints = contours.reduce((acc, contour) => acc.concat(contour), []);
    const minX = Math.min(...allPoints.map(p => p.x));
    const minY = Math.min(...allPoints.map(p => p.y));
    const maxX = Math.max(...allPoints.map(p => p.x));
    const maxY = Math.max(...allPoints.map(p => p.y));

    let mifContent = `Version 300
Charset "WindowsCyrillic"
Delimiter ";"
CoordSys Nonearth Units "m" Bounds 
(${minY.toFixed(2)}, ${minX.toFixed(2)}) (${maxY.toFixed(2)}, ${maxX.toFixed(2)})
Columns 7
LayerName Char(32)
LayerNumber Integer
ObjectName Char(32)
ObjectCode Integer
ObjectNumber Integer
ObjectLocal Integer
ObjectKey Char(32)
Data
`;

    contours.forEach((contour, index) => {
        if (!Array.isArray(contour) || contour.length === 0) {
            console.warn(`Пропущен недопустимый контур с индексом ${index}`);
            return;
        }

        mifContent += `Pline ${contour.length}\n`;
        contour.forEach(point => {
            if (typeof point !== 'object' || !('x' in point) || !('y' in point)) {
                console.warn(`Пропущена недопустимая точка в контуре ${index}`);
                return;
            }
            mifContent += `${point.y.toFixed(3)} ${point.x.toFixed(3)}\n`;
        });
        mifContent += `Pen (1,2,16733695)\n`;
        if (index < contours.length - 1) {
            mifContent += '\n';
        }
    });

    return mifContent;
}

function generateAndDownloadMIF() {
    const contours = extractCoordinatesFromXML(window.xmlContent);
    if (!Array.isArray(contours) || contours.length === 0) {
        alert('Не удалось извлечь координаты из XML. Пожалуйста, проверьте формат файла.');
        return;
    }

    const mifContent = generateMIF(contours);
    if (mifContent === '') {
        alert('Не удалось сгенерировать MIF. Пожалуйста, проверьте данные координат.');
        return;
    }

    const blob = new Blob([mifContent], { type: 'text/plain' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'output.mif';
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
}

function generateAndDownloadDXF() {
    const contours = extractCoordinatesFromXML(window.xmlContent);
    if (!Array.isArray(contours) || contours.length === 0) {
        alert('Не удалось извлечь координаты из XML. Пожалуйста, проверьте формат файла.');
        return;
    }

    const dxfContent = generateDXF(contours);
    if (dxfContent === '') {
        alert('Не удалось сгенерировать DXF. Пожалуйста, проверьте данные координат.');
        return;
    }

    const blob = new Blob([dxfContent], { type: 'application/dxf' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'output.dxf';
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
}

function generateCSV(contours) {
    if (!Array.isArray(contours) || contours.length === 0) {
        console.error('Неверный формат данных контуров');
        return '';
    }

    let csvContent = "Контур;Префикс номера;Номер;Старый X;Старый Y;Новый X;Новый Y;Метод определения;Формула;Радиус;Погрешность;Описание закрепления\n";
    csvContent += ";;;;;;;;;;;\n";

    let mainContourIndex = 1;
    let innerContourIndex = 1;

    contours.forEach((contour, contourIndex) => {
        if (!Array.isArray(contour) || contour.length === 0) {
            console.warn(`Пропущен недопустимый контур с индексом ${contourIndex}`);
            return;
        }

        if (contourIndex > 0) {
            csvContent += ";;;;;;;;;;;\n";
        }

        let contourName;
        let isInner = false;
        if (contourIndex === 0) {
            contourName = `${mainContourIndex}`;
            mainContourIndex++;
        } else if (isContourInside(contour, contours[0])) {
            contourName = `${mainContourIndex - 1}.${innerContourIndex}`;
            innerContourIndex++;
            isInner = true;
        } else {
            contourName = `${mainContourIndex}`;
            mainContourIndex++;
            innerContourIndex = 1;
        }

        const isClosed = isClosedContour(contour);

        contour.forEach((point, index) => {
            if (typeof point !== 'object' || !('x' in point) || !('y' in point) || !('delta' in point)) {
                console.warn(`Пропущена недопустимая точка в контуре ${contourName}, индекс ${index}`);
                return;
            }

            let pointNumber = index + 1;
            let prefix = isInner ? '' : 'н';

            if (isClosed && index === contour.length - 1) {
                pointNumber = 1;
            }

            csvContent += `[${contourName}];${prefix};${pointNumber};;;${point.x.toFixed(2)};${point.y.toFixed(2)};;;;${point.delta.toFixed(2)};Долговременный межевой знак\n`;
        });
    });

    return csvContent;
}


function generateAndDownloadCSV() {
    const contours = extractCoordinatesFromXML(window.xmlContent);
    if (!Array.isArray(contours) || contours.length === 0) {
        alert('Не удалось извлечь координаты из XML. Пожалуйста, проверьте формат файла.');
        return;
    }

    const csvContent = generateCSV(contours);
    if (csvContent === '') {
        alert('Не удалось сгенерировать CSV. Пожалуйста, проверьте данные координат.');
        return;
    }
    
    const bom = '\uFEFF';
    const csvWithBom = bom + csvContent;
    
    const blob = new Blob([csvWithBom], { type: 'text/csv;charset=utf-8;' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'output.csv';
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
}




function processXMLContent(xmlContent) {
    console.log("processXMLContent: Начало обработки XML контента.");
    // Сохраняем XML контент глобально для доступа из других функций (например, копирования)
    window.xmlContent = xmlContent;

    try {
        const extractedData = extractData(xmlContent);
        document.getElementById('output').innerHTML = extractedData;
        console.log("processXMLContent: Данные извлечены и добавлены в DOM.");

        // Добавляем обработчики для копирования (клик на .copyable и т.д.)
        const copyables = document.querySelectorAll('.copyable, .rights-header, .right-info, .clickable');
        copyables.forEach(el => {
            // Удаляем старые обработчики, если они есть (на всякий случай)
             // el.removeEventListener('click', copyHandler); // Возможно, не нужно, если DOM полностью перестраивается
             // el.removeEventListener('click', specificClickHandler); // Пример для других кликов
            if (el.classList.contains('clickable') && el.textContent.trim() === 'Кадастровый номер') {
                 const cadNumberSpan = el.nextElementSibling.querySelector('.copyable');
                 if (cadNumberSpan) {
                     const cadNumber = cadNumberSpan.textContent.trim();
                     el.onclick = () => copyCadNumberAndOpenSite(cadNumber); // Обновляем обработчик
                 }
            } else if (el.classList.contains('clickable') && el.textContent.trim() === 'Адрес') {
                 const addressSpan = el.nextElementSibling.querySelector('.copyable');
                 if(addressSpan){
                    const fullAddress = addressSpan.textContent.trim();
                    const shortAddress = extractShortAddress(fullAddress); // Используем существующую функцию
                    el.onclick = () => window.open(`https://yandex.ru/maps/?text=${encodeURIComponent(shortAddress)}`, '_blank');
                 }
            } else if (el.classList.contains('clickable') && el.textContent.trim() === 'ОКС') {
                const oksSpan = el.nextElementSibling.querySelector('.copyable');
                if (oksSpan) {
                    const includedObjectsString = oksSpan.textContent.trim();
                    el.onclick = () => window.open(`https://pkk.rosreestr.ru/#/search/?text=${encodeURIComponent(includedObjectsString)}&type=5`, '_blank');
                }
            } else if (el.classList.contains('clickable') && el.textContent.trim() === 'Кадастровый инженер') {
                 const engineerSpan = el.nextElementSibling.querySelector('.copyable');
                 if (engineerSpan) {
                    // Извлекаем ФИО для поиска (нужно доработать extractData или передавать ФИО отдельно)
                    // Пока просто оставим как есть или можно добавить открытие поиска по тексту
                    const engineerText = engineerSpan.textContent.trim();
                    // Пытаемся извлечь фамилию и имя из текста
                    const fioMatch = engineerText.match(/^([А-Яа-яЁё\-]+)\s+([А-Яа-яЁё\-]+)/);
                    if (fioMatch) {
                        const surname = fioMatch[1];
                        const name = fioMatch[2];
                        const searchUrl = generateSearchUrl(surname, name);
                        el.onclick = () => window.open(searchUrl, '_blank');
                    } else {
                        // Запасной вариант, если регулярка не сработала
                         el.onclick = () => window.open(`https://www.google.com/search?q=${encodeURIComponent(engineerText)}`, '_blank');
                    }
                 }
            } else if (el.classList.contains('clickable') && el.textContent.trim() === 'Номер выписки') {
                el.onclick = copyXMLAndOpenFile; // Используем специальную функцию
            } else {
                el.addEventListener('click', copyHandler);
            }
        });
        console.log("processXMLContent: Обработчики кликов (копирование и ссылки) добавлены.");

        // Ищем группу кнопок для координат и добавляем обработчики
        const buttonGroup = document.querySelector('.button-group');
        if (buttonGroup) {
            console.log("processXMLContent: Группа кнопок координат найдена.");

            const toggleCoordinatesButton = buttonGroup.querySelector('#toggleCoordinates');
            if (toggleCoordinatesButton) {
                // toggleCoordinatesButton.removeEventListener('click', toggleCoordinates); // Очистка старого
                toggleCoordinatesButton.onclick = toggleCoordinates; // Простой способ назначения
                console.log("processXMLContent: Обработчик для toggleCoordinates добавлен.");
            }

            const copyCoordinatesButton = buttonGroup.querySelector('#copyCoordinates');
            if (copyCoordinatesButton) {
                // copyCoordinatesButton.removeEventListener('click', copyCoordinates); // Очистка старого
                copyCoordinatesButton.onclick = copyCoordinates;
                console.log("processXMLContent: Обработчик для copyCoordinates добавлен.");
            }
            
            const copyCoordinatesAndMapButton = buttonGroup.querySelector('#copyCoordinatesAndMap');
             if (copyCoordinatesAndMapButton) {
                // copyCoordinatesAndMapButton.removeEventListener('click', copyCoordinatesAndOpenMap); // Очистка старого
                copyCoordinatesAndMapButton.onclick = copyCoordinatesAndOpenMap;
                 console.log("processXMLContent: Обработчик для copyCoordinatesAndOpenMap добавлен.");
            }


            const exportDXFButton = buttonGroup.querySelector('#exportDXF');
            if (exportDXFButton) {
                // exportDXFButton.removeEventListener('click', generateAndDownloadDXF); // Очистка старого
                exportDXFButton.onclick = generateAndDownloadDXF;
                console.log("processXMLContent: Обработчик для exportDXF добавлен.");
            }

            const exportMIFButton = buttonGroup.querySelector('#exportMIF');
            if (exportMIFButton) {
                // exportMIFButton.removeEventListener('click', generateAndDownloadMIF); // Очистка старого
                exportMIFButton.onclick = generateAndDownloadMIF;
                console.log("processXMLContent: Обработчик для exportMIF добавлен.");
            }

            const exportCSVButton = buttonGroup.querySelector('#exportCSV');
            if (exportCSVButton) {
                // exportCSVButton.removeEventListener('click', generateAndDownloadCSV); // Очистка старого
                exportCSVButton.onclick = generateAndDownloadCSV;
                console.log("processXMLContent: Обработчик для exportCSV добавлен.");
            }
        } else {
            console.warn("processXMLContent: Группа кнопок для координат не найдена в DOM.");
        }

        // Метка файла уже обновляется в вызывающем коде (или в processZipFile)

    } catch (error) {
        console.error("processXMLContent: Ошибка во время обработки XML или обновления DOM:", error);
        document.getElementById('output').innerHTML = `<p style="color: red;">Ошибка при обработке XML: ${error.message}</p>`;
        // Можно также сбросить метку файла
        const label = document.getElementById('fileInputLabel');
        label.textContent = 'Ошибка обработки. Выберите файл.';
    }

    console.log("processXMLContent: Обработка XML завершена.");
}




    
function processZipFile(zipContent, originalZipFileName) {
    const label = document.getElementById('fileInputLabel');
    label.textContent = `Распаковка ${originalZipFileName}...`; // Промежуточная обратная связь

    JSZip.loadAsync(zipContent).then(function(zip) {
        let xmlFileEntry = null;
        let foundXmlFileName = '';

        // Ищем первый попавшийся XML файл в архиве
        zip.forEach(function(relativePath, zipEntry) {
            // Учитываем только файлы (не папки) и ищем расширение .xml
            // Игнорируем системные папки типа __MACOSX
            if (!zipEntry.dir && relativePath.toLowerCase().endsWith('.xml') && !relativePath.startsWith('__MACOSX/')) {
                if (!xmlFileEntry) { // Берем первый найденный
                    xmlFileEntry = zipEntry;
                    // Получаем только имя файла, отсекая путь внутри архива, если он есть
                    foundXmlFileName = relativePath.split('/').pop();
                    console.log(`Найден XML файл в ZIP: ${foundXmlFileName} (путь: ${relativePath})`);
                } else {
                    // Можно добавить предупреждение, если найдено несколько XML
                    console.warn(`Найдено несколько XML файлов в ZIP. Используется первый: ${foundXmlFileName}. Другой файл: ${relativePath}`);
                }
            }
        });

        if (xmlFileEntry) {
            // Асинхронно извлекаем содержимое найденного XML файла как текст
            xmlFileEntry.async('string').then(function(xmlContent) {
                console.log(`XML контент из ${foundXmlFileName} успешно извлечен.`);
                // Передаем содержимое XML в основную функцию обработки
                processXMLContent(xmlContent);
                // Обновляем метку, показывая имя ZIP и извлеченного XML
                label.textContent = `${originalZipFileName} -> ${foundXmlFileName}`;

                // ------------- Добавлено: Отрисовка схемы после загрузки из ZIP -------------
                currentCoords = extractCoordinatesFromXML(xmlContent);
                showScheme();
                // -------------------------------------------------------------------------

            }).catch(function(error) {
                console.error(`Ошибка при извлечении содержимого XML (${foundXmlFileName}) из ZIP:`, error);
                alert(`Ошибка при чтении XML файла '${foundXmlFileName}' внутри архива.`);
                label.textContent = 'Открыть XML выписку земельного участка'; // Сброс метки
            });
        } else {
            console.log('XML файл не найден в предоставленном ZIP архиве.');
            alert('XML-файл не найден в архиве ZIP.');
            label.textContent = 'Открыть XML выписку земельного участка'; // Сброс метки
        }
    }).catch(function(error) {
        console.error('Ошибка при загрузке или обработке ZIP-файла:', error);
        alert('Ошибка при обработке ZIP-файла. Возможно, архив поврежден или имеет неверный формат.');
        label.textContent = 'Открыть XML выписку земельного участка'; // Сброс метки
    });
}

          
       // Глобальная переменная для отслеживания, была ли уже создана схема



function showScheme() {
    const coords = currentCoords || extractCoordinatesFromXML(window.xmlContent);
    const cadNumber = extractCadastralNumber(window.xmlContent);

    // Удаляем существующий контейнер схемы, если он есть
    const existingContainer = document.getElementById('schemeContainer');
    if (existingContainer) {
        existingContainer.remove();
    }

    // Создаем новый контейнер схемы
    const schemeContainer = document.createElement('div');
    schemeContainer.id = 'schemeContainer';
    schemeContainer.style.width = '100%';
    schemeContainer.style.height = '600px';
    schemeContainer.style.margin = '20px auto';
    schemeContainer.style.position = 'relative';

    const canvas = document.createElement('canvas');
    canvas.id = 'schemeCanvas';
    canvas.style.width = '100%';
    canvas.style.height = '100%';
    canvas.style.border = '1px solid #007bff';
    canvas.style.borderRadius = '10px';

    schemeContainer.appendChild(canvas);

    // Добавляем canvas в конец body
    document.body.appendChild(schemeContainer);

    // Добавляем кнопку "глаз"
    const eyeButton = document.createElement('button');
    eyeButton.innerHTML = '<i class="fas fa-eye"></i>';
    eyeButton.style.position = 'absolute';
    eyeButton.style.top = '10px';
    eyeButton.style.right = '10px';
    eyeButton.style.zIndex = '1000';
    eyeButton.style.background = 'white';
    eyeButton.style.border = '1px solid #007bff';
    eyeButton.style.borderRadius = '5px';
    eyeButton.style.padding = '5px 10px';
    schemeContainer.appendChild(eyeButton);

    eyeButton.addEventListener('click', () => {
        if (showDistances && showPointNumbers) {
            showDistances = false;
        } else if (!showDistances && showPointNumbers) {
            showPointNumbers = false;
        } else {
            showDistances = true;
            showPointNumbers = true;
        }
        drawScheme();
    });

    schemeCreated = true;
    currentCoords = coords;

    // Вызываем функцию отрисовки схемы
    drawScheme();

    // Добавляем обработчик события изменения размера окна
    window.addEventListener('resize', drawScheme);
}


    
function drawScheme() {
    const canvas = document.getElementById('schemeCanvas');
    if (!canvas) return;

    const ctx = canvas.getContext('2d');
    canvas.width = canvas.offsetWidth;
    canvas.height = canvas.offsetHeight;

    ctx.fillStyle = 'white';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    if (!currentCoords || currentCoords.length === 0) return;

    const allCoords = currentCoords.flat();
    const minX = Math.min(...allCoords.map(p => p.x));
    const minY = Math.min(...allCoords.map(p => p.y));
    const maxX = Math.max(...allCoords.map(p => p.x));
    const maxY = Math.max(...allCoords.map(p => p.y));

    const scaleX = (canvas.width - 60) / (maxY - minY);
    const scaleY = (canvas.height - 60) / (maxX - minX);
    const scale = Math.min(scaleX, scaleY) * 0.9;

    const offsetX = (canvas.width - (maxY - minY) * scale) / 2;
    const offsetY = (canvas.height - (maxX - minX) * scale) / 2;

    const transformCoord = (x, y) => [
        offsetX + (y - minY) * scale,
        canvas.height - (offsetY + (x - minX) * scale)
    ];

    currentCoords.forEach((contour, contourIndex) => {
        ctx.beginPath();
        contour.forEach(({x, y}, index) => {
            const [canvasX, canvasY] = transformCoord(x, y);
            if (index === 0) {
                ctx.moveTo(canvasX, canvasY);
            } else {
                ctx.lineTo(canvasX, canvasY);
            }
        });

        if (isClosedContour(contour)) {
            ctx.closePath();
        }

        ctx.strokeStyle = contourIndex === 0 ? 'black' : 'red';
        ctx.lineWidth = 2;
        ctx.stroke();

        if (showPointNumbers) {
            ctx.fillStyle = contourIndex === 0 ? 'red' : 'blue';
            ctx.font = '14px Arial';
            contour.forEach(({x, y, ordNmb}, index) => {
                if (index === contour.length - 1 && isClosedContour(contour)) return;
                const [canvasX, canvasY] = transformCoord(x, y);
                ctx.beginPath();
                ctx.arc(canvasX, canvasY, 4, 0, 2 * Math.PI);
                ctx.fill();
                ctx.fillText(ordNmb, canvasX + 7, canvasY - 7);
            });
        }

        if (showDistances) {
            ctx.font = '12px Arial';
            ctx.fillStyle = 'black';
            contour.forEach(({x: x1, y: y1}, index) => {
                const {x: x2, y: y2} = contour[(index + 1) % contour.length];
                if (index === contour.length - 1 && isClosedContour(contour)) return;
                const [canvasX1, canvasY1] = transformCoord(x1, y1);
                const [canvasX2, canvasY2] = transformCoord(x2, y2);
                const distance = Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);
                const midX = (canvasX1 + canvasX2) / 2;
                const midY = (canvasY1 + canvasY2) / 2;

                const angle = Math.atan2(canvasY2 - canvasY1, canvasX2 - canvasX1);
                const offset = 15;
                const textX = midX + offset * Math.sin(angle);
                const textY = midY - offset * Math.cos(angle);

                ctx.save();
                ctx.translate(textX, textY);
                ctx.rotate(angle);
                ctx.fillText(`${distance.toFixed(2)} м`, 0, 0);
                ctx.restore();
            });
        }
    });

    ctx.fillStyle = 'black';
    ctx.font = '16px Arial';
    ctx.fillText(`Кадастровый номер: ${extractCadastralNumber(window.xmlContent)}`, 10, 20);

    const totalPerimeter = currentCoords.reduce((sum, contour) => sum + calculatePerimeter(contour), 0);
    const totalArea = currentCoords.reduce((sum, contour) => sum + calculateArea(contour), 0);
    ctx.font = '16px Arial';
    ctx.fillText(`Периметр: ${totalPerimeter.toFixed(2)} м`, 10, 50);
    ctx.fillText(`Площадь: ${totalArea.toFixed(2)} кв.м`, 10, 80);

    drawRulers(ctx, minX, minY, maxX, maxY, offsetX, offsetY, scale, canvas.width, canvas.height);
}

function drawRulers(ctx, minX, minY, maxX, maxY, offsetX, offsetY, scale, canvasWidth, canvasHeight) {
    ctx.strokeStyle = 'royalblue';
    ctx.fillStyle = 'royalblue';
    ctx.font = '12px Arial';
    ctx.textAlign = 'center';

    function getOptimalStep(range) {
        const steps = [5, 10, 20, 50, 100, 200, 500, 1000];
        const targetDivisions = 5;
        return steps.find(step => range / step <= targetDivisions) || steps[steps.length - 1];
    }

    const bottomY = canvasHeight - 20;
    ctx.beginPath();
    ctx.moveTo(offsetX, bottomY);
    ctx.lineTo(canvasWidth - offsetX, bottomY);
    ctx.stroke();

    const horizontalRange = maxY - minY;
    const horizontalStep = getOptimalStep(horizontalRange);
    for (let y = Math.ceil(minY / horizontalStep) * horizontalStep; y <= maxY; y += horizontalStep) {
        const canvasX = offsetX + (y - minY) * scale;
        ctx.beginPath();
        ctx.moveTo(canvasX, bottomY);
        ctx.lineTo(canvasX, bottomY + 5);
        ctx.stroke();
        ctx.fillText(`${Math.round(y - minY)} м`, canvasX, bottomY + 15);
    }

    const rightX = canvasWidth - 20;
    ctx.beginPath();
    ctx.moveTo(rightX, offsetY);
    ctx.lineTo(rightX, canvasHeight - offsetY - 30);
    ctx.stroke();

    ctx.textAlign = 'right';
    const verticalRange = maxX - minX;
    const verticalStep = getOptimalStep(verticalRange);
    for (let x = Math.ceil(minX / verticalStep) * verticalStep; x <= maxX; x += verticalStep) {
        const canvasY = canvasHeight - (offsetY + (x - minX) * scale);
        ctx.beginPath();
        ctx.moveTo(rightX, canvasY);
        ctx.lineTo(rightX + 5, canvasY);
        ctx.stroke();
        ctx.fillText(`${Math.round(x - minX)} м`, rightX - 5, canvasY + 4);
    }
}

function calculatePerimeter(contour) {
    let perimeter = 0;
    for (let i = 0; i < contour.length; i++) {
        const {x: x1, y: y1} = contour[i];
        const {x: x2, y: y2} = contour[(i + 1) % contour.length];
        perimeter += Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);
    }
    return perimeter;
}

function calculateArea(contour) {
    let area = 0;
    for (let i = 0; i < contour.length; i++) {
        const {x: x1, y: y1} = contour[i];
        const {x: x2, y: y2} = contour[(i + 1) % contour.length];
        area += x1 * y2 - y1 * x2;
    }
    return Math.abs(area) / 2;
}

    // Вызываем функцию отрисовки схемы
    drawScheme();

    // Добавляем обработчик события изменения размера окна
    window.addEventListener('resize', drawScheme);


// Добавим функцию для извлечения кадастрового номера из XML
function extractCadastralNumber(xmlContent) {
    const parser = new DOMParser();
    const xmlDoc = parser.parseFromString(xmlContent, "text/xml");
    const cadNumberElement = xmlDoc.querySelector('land_record > object > common_data > cad_number');
    return cadNumberElement ? cadNumberElement.textContent : 'Не найден';
}


document.getElementById('fileInput').addEventListener('change', function(event) {
    const file = event.target.files[0];
    const outputDiv = document.getElementById('output');
    const label = document.getElementById('fileInputLabel');

    // Очищаем предыдущий вывод и сбрасываем состояние
    outputDiv.innerHTML = '';
    window.xmlContent = null; // Сбрасываем глобальный XML
    currentCoords = null; // Сбрасываем координаты
    const existingScheme = document.getElementById('schemeContainer');
    if (existingScheme) {
        existingScheme.remove(); // Удаляем старую схему, если есть
        schemeCreated = false;
    }

    if (!file) {
        label.textContent = 'Открыть XML выписку земельного участка'; // Файл не выбран
        return;
    }

    const fileName = file.name;
    const fileExtension = fileName.split('.').pop().toLowerCase();
    console.log(`Выбран файл: ${fileName}, тип: ${fileExtension}`);

    if (fileExtension === 'xml') {
        label.textContent = `Чтение ${fileName}...`;
        const reader = new FileReader();
        reader.onload = function(e) {
            try {
                const xmlContent = e.target.result;
                processXMLContent(xmlContent); // Обрабатываем XML
                label.textContent = fileName; // Устанавливаем имя файла на метку

                // ------------- Добавлено: Отрисовка схемы после загрузки XML -------------
                 currentCoords = extractCoordinatesFromXML(xmlContent);
                 showScheme();
                // ----------------------------------------------------------------------
            } catch (error) {
                 console.error("Ошибка при чтении или первоначальной обработке XML:", error);
                 outputDiv.innerHTML = `<p style="color: red;">Не удалось обработать XML файл: ${error.message}</p>`;
                 label.textContent = 'Ошибка чтения XML. Выберите файл.';
            }
        };
        reader.onerror = function() {
            console.error("Ошибка FileReader при чтении XML.");
            outputDiv.innerHTML = `<p style="color: red;">Ошибка при чтении файла ${fileName}.</p>`;
            label.textContent = 'Ошибка чтения. Выберите файл.';
        };
        reader.readAsText(file); // Читаем XML как текст
    } else if (fileExtension === 'zip') {
        label.textContent = `Чтение ${fileName}...`;
        const reader = new FileReader();
        reader.onload = function(e) {
            try {
                const zipContent = e.target.result; // Это ArrayBuffer
                // Передаем ArrayBuffer и имя файла в функцию обработки ZIP
                processZipFile(zipContent, fileName);
                // Метка будет обновлена внутри processZipFile
            } catch (error) {
                 console.error("Ошибка при чтении ZIP как ArrayBuffer:", error);
                 outputDiv.innerHTML = `<p style="color: red;">Не удалось прочитать ZIP файл: ${error.message}</p>`;
                 label.textContent = 'Ошибка чтения ZIP. Выберите файл.';
            }
        };
        reader.onerror = function() {
             console.error("Ошибка FileReader при чтении ZIP.");
            outputDiv.innerHTML = `<p style="color: red;">Ошибка при чтении файла ${fileName}.</p>`;
            label.textContent = 'Ошибка чтения. Выберите файл.';
        };
        reader.readAsArrayBuffer(file); // Читаем ZIP как ArrayBuffer
    } else {
        console.log(`Неподдерживаемый тип файла: ${fileExtension}`);
        alert('Пожалуйста, выберите файл с расширением .xml или .zip');
        label.textContent = 'Открыть XML выписку земельного участка';
        event.target.value = ''; // Очищаем выбор файла в input
    }
});


        function getRandomColor() {
            return '#' + Math.floor(Math.random()*16777215).toString(16);
        } 
        
        
    </script>
</body>
</html>                    