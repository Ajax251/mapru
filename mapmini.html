<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Карта Мини</title>
    <script src="https://api-maps.yandex.ru/2.1/?apikey=dde71a0e-b612-44b7-b53b-82533420240f&lang=ru_RU" type="text/javascript"></script>
    <script src="webfonts/proj4.js"></script>
   <link id="favicon" rel="icon" href="https://img.icons8.com/?size=100&id=aEzGn44qkM4S&format=png&color=000000" type="image/png">
    <link rel="stylesheet" href="webfonts/all.min.css">

    <style>
    html, body {
        margin: 0;
        padding: 0;
        height: 100%;
        width: 100%;
        overflow: hidden;
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
        background-color: #f8f9fa;
        touch-action: manipulation;
    }

    #map-container {
        height: calc(100% - 70px);
        width: 100%;
        position: relative;
    }

    #map {
        height: 100%;
        width: 100%;
        border: none;
    }

    #input-field-container {
        height: 70px;
        width: 100%;
        background-color: cornflowerblue;
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 0 15px;
        box-sizing: border-box;
        position: fixed;
        bottom: 0;
        left: 0;
        z-index: 1000;
        border-top: 1px solid #4682B4;
        box-shadow: 0 -3px 15px rgba(0, 0, 0, 0.1);
        gap: 10px;
    }
    #search-input {
        flex-grow: 1;
        max-width: 550px;
        padding: 14px 25px;
        font-size: 17px;
        color: #333;
        background-color: #ffffff;
        border: 1px solid #dddddd;
        border-radius: 30px;
        box-shadow: 0 5px 15px rgba(0, 0, 0, 0.08);
        outline: none;
        transition: border-color 0.3s ease, box-shadow 0.3s ease, transform 0.2s ease;
        text-align: center;
    }

    #search-input:focus {
        border-color: #bbbbbb;
        box-shadow: 0 8px 20px rgba(0, 0, 0, 0.1),
                    0 0 0 4px rgba(187, 187, 187, 0.1);
        transform: translateY(-1px);
    }

    #search-input::placeholder {
        color: #b0b0b0;
    }

    #open-search-button {
       padding: 10px 12px;
       font-size: 17px;
       color: #ffffff;
       background-color: #28a745;
       border: none;
       border-radius: 50%;
       width: 44px;
       height: 44px;
       cursor: pointer;
       box-shadow: 0 3px 10px rgba(0, 0, 0, 0.1);
       transition: background-color 0.3s ease, transform 0.2s ease;
       display: flex;
       align-items: center;
       justify-content: center;
       flex-shrink: 0;
   }

   #open-search-button:hover {
       background-color: #218838;
       transform: translateY(-1px);
   }

   #open-search-button:active {
       background-color: #1e7e34;
       transform: translateY(0);
   }

    #clear-map-button {
       padding: 10px 12px;
       font-size: 17px;
       color: #ffffff;
       background-color: #4a71d4;
       border: none;
       border-radius: 50%;
       width: 44px;
       height: 44px;
       cursor: pointer;
       box-shadow: 0 3px 10px rgba(0, 0, 0, 0.1);
       transition: background-color 0.3s ease, transform 0.2s ease;
       display: flex;
       align-items: center;
       justify-content: center;
       flex-shrink: 0;
   }

   #clear-map-button:hover {
       background-color: #3e60b3;
       transform: translateY(-1px);
   }

   #clear-map-button:active {
       background-color: #355294;
       transform: translateY(0);
   }

    .custom-context-menu {
        position: absolute;
        background: rgba(255, 255, 255, 0.97);
        backdrop-filter: blur(8px);
        border-radius: 5px;
        box-shadow: 0 5px 20px rgba(0, 0, 0, 0.15);
        padding: 8px 0;
        min-width: 230px;
        z-index: 10000;
        display: none;
        font-size: 14px;
    }

    .custom-context-menu-item {
        padding: 11px 20px;
        cursor: pointer;
        transition: background-color 0.2s, color 0.2s;
        color: #2c3e50;
        display: flex;
        align-items: center;
        position: relative;
    }

    .custom-context-menu-item i {
        margin-right: 12px;
        color: #3498db;
        width: 18px;
        text-align: center;
        transition: transform 0.2s ease;
    }

    .custom-context-menu-item:hover {
        background-color: #ecf0f1;
        color: #2980b9;
    }
    .custom-context-menu-item:hover i {
        transform: scale(1.1);
    }

    .custom-context-menu-item:active {
        background-color: #bdc3c7;
    }

    .custom-context-menu-item.has-submenu {
        position: relative;
    }

    .custom-context-submenu {
        display: none;
        position: absolute;
        left: 100%;
        top: -8px;
        background: rgba(255, 255, 255, 0.98);
        backdrop-filter: blur(10px);
        border-radius: 5px;
        box-shadow: 3px 3px 12px rgba(0, 0, 0, 0.12);
        padding: 8px 0;
        min-width: 240px;
        z-index: 10001;
        margin-left: 1px;
    }

    .custom-context-menu-item.has-submenu:hover > .custom-context-submenu {
        display: block;
    }

    .custom-context-menu-item.has-submenu::after {
        content: '\f0da';
        font-family: 'Font Awesome 5 Free';
        font-weight: 900;
        position: absolute;
        right: 12px;
        top: 50%;
        transform: translateY(-50%);
        color: #7f8c8d;
        transition: color 0.2s ease;
    }

    .custom-context-menu-item.has-submenu:hover::after {
        color: #2980b9;
    }

    .custom-context-submenu .custom-context-menu-item {
    }

    .custom-placemark-label {
        font-family: Arial, sans-serif;
        font-size: 10px;
        font-weight: bold;
        color: #000000;
        text-shadow:
            -1px -1px 0 #fff,
             1px -1px 0 #fff,
            -1px  1px 0 #fff,
             1px  1px 0 #fff,
             0 0 2px #fff;
        white-space: nowrap;
        pointer-events: none;
    }

    .loader-container {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.6);
        display: none;
        justify-content: center;
        align-items: center;
        z-index: 10001;
        backdrop-filter: blur(3px);
        flex-direction: column;
    }
    .spinner {
        border: 6px solid #f3f3f3;
        border-top: 6px solid #3498db;
        border-radius: 50%;
        width: 50px;
        height: 50px;
        animation: spin 1s linear infinite;
    }
    @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
    }
    .loading-text {
        color: #ffffff;
        font-size: 16px;
        margin-top: 15px;
        font-weight: 500;
    }

    .notification {
        position: fixed;
        bottom: 80px;
        left: 50%;
        transform: translateX(-50%);
        padding: 12px 20px;
        color: white;
        border-radius: 6px;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
        opacity: 0;
        transition: opacity 0.3s, transform 0.3s;
        z-index: 9999;
        font-size: 14px;
        display: flex;
        align-items: center;
        gap: 10px;
        max-width: 90%;
        text-align: center;
    }
    .notification.success { background: linear-gradient(135deg, #43cea2, #185a9d); }
    .notification.error { background: linear-gradient(135deg, #ff6b6b, #ff3d3d); }
    .notification.warning { background: linear-gradient(135deg, #ffc107, #ff9800); }
    .notification.info { background: linear-gradient(135deg, #2196F3, #2962FF); }
    .notification.show { opacity: 1; transform: translateX(-50%) translateY(0); }
    .notification i { font-size: 16px; }

    .modal-container {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.6);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 10002;
        backdrop-filter: blur(5px);
        opacity: 0;
        visibility: hidden;
        transition: opacity 0.3s ease, visibility 0.3s ease;
    }
    .modal-container.show {
        opacity: 1;
        visibility: visible;
    }
    .modal-content {
        background: linear-gradient(135deg, #ffffff, #f0f0f0);
        padding: 30px;
        border-radius: 15px;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.25);
        text-align: center;
        max-width: 400px;
        width: 90%;
        transform: translateY(-20px);
        transition: transform 0.3s ease;
        display: flex;
        flex-direction: column;
        gap: 15px;
    }
    .modal-container.show .modal-content {
        transform: translateY(0);
    }
    .modal-content h3 {
        margin-top: 0;
        color: #333;
        font-size: 22px;
        font-weight: 600;
    }
    .modal-button {
        padding: 14px 25px;
        font-size: 18px;
        border: none;
        border-radius: 30px;
        cursor: pointer;
        transition: transform 0.2s ease, box-shadow 0.2s ease, background-color 0.3s ease;
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 10px;
        font-weight: 500;
    }
    .modal-button i {
        font-size: 20px;
    }
    .modal-button.primary {
        background: linear-gradient(45deg, #4CAF50, #2E8B57);
        color: white;
    }
    .modal-button.primary:hover {
        transform: translateY(-2px);
        box-shadow: 0 5px 15px rgba(0, 0, 0, 0.15);
        background: linear-gradient(45deg, #45a049, #287a4a);
    }
    .modal-button.secondary {
        background: linear-gradient(45deg, #2196F3, #1976D2);
        color: white;
    }
    .modal-button.secondary:hover {
        transform: translateY(-2px);
        box-shadow: 0 5px 15px rgba(0, 0, 0, 0.15);
        background: linear-gradient(45deg, #1e88e5, #1565c0);
    }
    .modal-button.cancel {
        background-color: #f44336;
        color: white;
        margin-top: 10px;
    }
    .modal-button.cancel:hover {
        transform: translateY(-2px);
        box-shadow: 0 5px 15px rgba(0, 0, 0, 0.15);
        background-color: #d32f2f;
    }

    .route-info-panel {
        position: fixed;
        top: 15px;
        right: 15px;
        background-color: rgba(255, 255, 255, 0.97);
        backdrop-filter: blur(10px);
        border-radius: 12px;
        box-shadow: 0 8px 25px rgba(0, 0, 0, 0.18);
        padding: 0;
        max-width: 380px;
        width: 90%;
        z-index: 9998;
        display: none;
        flex-direction: column;
        font-size: 14px;
        color: #333;
        transition: opacity 0.3s ease, transform 0.3s ease, box-shadow 0.3s ease;
        opacity: 0;
        transform: translateY(-20px);
        max-height: calc(100vh - 100px);
        overflow: hidden;
    }
    .route-info-panel.show {
        display: flex;
        opacity: 1;
        transform: translateY(0);
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.22);
    }
    #routeInfoContent {
        padding: 20px;
        overflow-y: auto;
        flex-grow: 1;
    }
    .route-info-panel h3 {
        margin-top: 0;
        margin-bottom: 15px;
        color: #2c3e50;
        font-size: 19px;
        font-weight: 600;
        text-align: center;
        border-bottom: 1px solid #e0e0e0;
        padding-bottom: 10px;
    }
    .route-info-panel h4 {
        margin-top: 15px;
        margin-bottom: 10px;
        color: #34495e;
        font-size: 17px;
        font-weight: 500;
        padding-bottom: 5px;
        border-bottom: 1px solid #e0e0e0;
    }
    .route-info-panel p {
        margin: 6px 0;
        line-height: 1.5;
    }
    .route-info-panel ul {
        list-style-type: none;
        padding-left: 0;
        margin: 0;
    }
    .route-info-panel li {
        padding: 12px 15px;
        margin-bottom: 8px;
        border-radius: 8px;
        background-color: #f8f9fa;
        border-left: 4px solid transparent;
        transition: background-color 0.2s ease, border-left-color 0.2s ease;
        line-height: 1.5;
        font-size: 14px;
    }
    .route-info-panel li:hover {
        background-color: #eef2f7;
    }
    .route-info-panel li.route-point-start {
        border-left-color: #28a745;
        background-color: #e6ffed;
    }
    .route-info-panel li.route-point-intermediate {
        border-left-color: #fd7e14;
    }
    .route-info-panel li.route-point-end {
        border-left-color: #dc3545;
        background-color: #ffebee;
    }
    .route-info-panel .point-type-label {
        font-weight: 600;
        font-size: 0.9em;
        color: #555;
        display: block;
        margin-bottom: 4px;
        text-transform: uppercase;
        letter-spacing: 0.5px;
    }
    .route-info-panel li.route-point-start .point-type-label { color: #1c7430; }
    .route-info-panel li.route-point-intermediate .point-type-label { color: #c65e0a; }
    .route-info-panel li.route-point-end .point-type-label { color: #b02a37; }
    .route-info-panel .point-display-name {
        font-weight: 500;
        font-size: 1.05em;
        color: #2c3e50;
        display: block;
        margin-bottom: 5px;
    }
    .route-info-panel .point-distance-details {
        font-size: 0.95em;
        color: #495057;
        display: flex;
        justify-content: space-between;
        flex-wrap: wrap;
        gap: 10px;
        padding-top: 5px;
        border-top: 1px dashed #ddd;
        margin-top: 8px;
    }
    .route-info-panel .dist-from-prev { color: #007bff; }
    .route-info-panel .dist-total { font-weight: 500; }
    .route-info-panel li:last-child { margin-bottom: 0; }
    .route-info-panel li.route-point-start .point-distance-details {
       border-top: none;
       margin-top: 0;
       padding-top: 0;
       justify-content: flex-start;
    }
    .route-info-panel .close-button {
        position: absolute;
        top: 12px;
        right: 12px;
        background: rgba(255,255,255,0.7);
        border-radius: 50%;
        border: none;
        font-size: 22px;
        color: #888;
        cursor: pointer;
        transition: color 0.2s ease, transform 0.2s ease, background-color 0.2s ease;
        padding: 5px;
        width: 32px;
        height: 32px;
        display: flex;
        align-items: center;
        justify-content: center;
        line-height: 1;
        z-index: 10;
    }
    .route-info-panel .close-button:hover {
        color: #333;
        background-color: rgba(230,230,230,0.9);
        transform: scale(1.1);
    }
    #routeInfoContent::-webkit-scrollbar { width: 8px; }
    #routeInfoContent::-webkit-scrollbar-track { background: #f9f9f9; border-radius: 10px; }
    #routeInfoContent::-webkit-scrollbar-thumb { background-color: #cccccc; border-radius: 10px; border: 2px solid #f9f9f9; }
    #routeInfoContent::-webkit-scrollbar-thumb:hover { background-color: #b3b3b3; }

    @media (max-width: 600px) {
        #map-container { height: calc(100% - 55px); }
        #input-field-container { height: 55px; padding: 0 10px; }
        #search-input { padding: 10px 15px; font-size: 15px; border-radius: 25px; max-width: calc(100% - 100px); }
        #open-search-button, #clear-map-button { padding: 8px 10px; font-size: 15px; width: 38px; height: 38px; }
        .custom-context-menu { min-width: 160px; font-size: 12px; padding: 4px 0; }
        .custom-context-menu-item { padding: 7px 12px; }
        .custom-context-menu-item i { margin-right: 8px; width: 14px; font-size: 12px; }
        .custom-context-submenu { min-width: 170px; top: -4px; padding: 4px 0; }
        .custom-context-menu-item.has-submenu::after { right: 8px; }
        .notification { bottom: 65px; padding: 10px 15px; font-size: 13px; gap: 8px; }
        .notification i { font-size: 14px; }
        .modal-content { padding: 20px; gap: 10px; }
        .modal-content h3 { font-size: 18px; }
        .modal-button { padding: 12px 20px; font-size: 16px; }
        .modal-button i { font-size: 18px; }
        .route-info-panel { top: 10px; right: 10px; left: 10px; max-width: none; max-height: calc(100vh - 80px); }
        #routeInfoContent { padding: 15px; }
        .route-info-panel h3 { font-size: 16px; }
        .route-info-panel h4 { font-size: 14px; }
        .route-info-panel .close-button { font-size: 18px; width: 28px; height: 28px; top: 8px; right: 8px; }
    }
    </style>
</head>
<body>

    <div id="map-container">
        <div id="map"></div>
    </div>

    <div id="input-field-container">
        <input type="text" id="search-input" placeholder="Кадастровый номер или адрес">
        <button id="open-search-button" title="Открыть"><i class="fas fa-search"></i></button>
        <button id="clear-map-button" title="Очистить"><i class="fas fa-sync-alt"></i></button>
    </div>

    <div class="custom-context-menu" id="customContextMenu">
        <div class="custom-context-menu-item" id="ctx-menu-open-zu"><i class="fas fa-draw-polygon"></i>Открыть ЗУ</div>
        <div class="custom-context-menu-item" id="ctx-menu-open-oks"><i class="fas fa-building"></i>Открыть ОКС</div>
        <div class="custom-context-menu-item" id="ctx-menu-parcels-in-quarter"><i class="fas fa-layer-group"></i>ЗУ в квартале</div>
        <div class="custom-context-menu-item has-submenu">
            <i class="fas fa-ruler-combined"></i>Границы
            <div class="custom-context-submenu">
                <div class="custom-context-menu-item" id="ctx-menu-terr-zones"><i class="fas fa-globe-europe"></i>Территориальные зоны</div>
                <div class="custom-context-menu-item" id="ctx-menu-zouit"><i class="fas fa-exclamation-triangle"></i>ЗОУИТ</div>
                <div class="custom-context-menu-item" id="ctx-menu-settlements"><i class="fas fa-city"></i>Населенные пункты</div>
                <div class="custom-context-menu-item" id="ctx-menu-municipal"><i class="fas fa-landmark"></i>Муниципальные образования</div>
                <div class="custom-context-menu-item" id="ctx-menu-quarter-bounds"><i class="fas fa-th-large"></i>Квартал</div>
            </div>
        </div>
        <div class="custom-context-menu-item" id="ctx-menu-egrn"><i class="fas fa-file-alt"></i>ЕГРН</div>
        <div class="custom-context-menu-item" id="ctx-menu-build-route"><i class="fas fa-route"></i>Маршрут</div>
        <div class="custom-context-menu-item" id="ctx-menu-yandex-navi"><i class="fas fa-car"></i>Навигатор</div>
    </div>

    <div id="routeSelectionModal" class="modal-container">
        <div class="modal-content">
            <h3>Выберите начальную точку маршрута</h3>
            <button id="routeFromCurrentLocation" class="modal-button primary"><i class="fas fa-location-arrow"></i> Местоположение</button>
            <button id="routeFromMapPoint" class="modal-button secondary"><i class="fas fa-map-marker-alt"></i> Откуда (выбрать на карте)</button>
            <button id="closeRouteModal" class="modal-button cancel"><i class="fas fa-times"></i> Отмена</button>
        </div>
    </div>

    <div id="routeInfoPanel" class="route-info-panel">
        <button id="closeRouteInfoPanel" class="close-button"><i class="fas fa-times"></i></button>
        <div id="routeInfoContent"></div>
    </div>

    <div class="loader-container" id="loaderContainer">
        <div class="spinner"></div>
        <div class="loading-text" id="loaderText">Загрузка...</div>
    </div>

    <script>

const sevenDigitsRegions = [
  '06', '07', '09', '10', '11', '12', '13', '14', '17', '23',
  '24', '27', '31', '32', '35', '36', '41', '42', '47', '48',
  '50', '52', '53', '56', '57', '58', '59', '60', '61', '62',
  '63', '64', '65', '66', '67', '69', '70', '71', '72', '74',
  '77', '78', '79'];


function isExactlyZeroQuarterNumber(numberString) {
    if (!numberString || typeof numberString !== 'string') {
        return false;
    }

    const parts = numberString.trim().split(':');
    
    // Блокируем, только если это номер квартала (ровно 3 части).
    // Строка вида "16:50:0000000:123" (4 части) эту проверку не пройдет.
    if (parts.length !== 3) {
        return false;
    }

    const regionPart = parts[0];
    const blockPart = parts[2]; // Третья часть - номер квартала
    
    // Определяем, используется ли 7-значный формат для региона
    const isSevenDigitsRegion = sevenDigitsRegions.includes(regionPart);
    const expectedZerosLength = isSevenDigitsRegion ? 7 : 6;

    // Проверяем, состоит ли блок только из нулей и имеет ли он правильную длину
    if (/^0+$/.test(blockPart) && blockPart.length === expectedZerosLength) {
        return true; // Это запрос к нулевому кварталу
    }

    return false;
}
// --- КОНЕЦ БЛОКА ИЗМЕНЕНИЙ ---

let map;
let mapObjects = [];
const mapOffsetX = -4.5;
const mapOffsetY = -1;
const polygonStyle = {
    declaredZuColor: '#FF0000', specifiedZuColor: '#00FF00', oksColor: '#9370DB', quarterOutlineColor: '#AAAAAA', genericLayerColor: '#4682B4',
    satelliteDeclaredZuColor: '#FF0000', satelliteSpecifiedZuColor: '#00FF00', satelliteOksColor: '#DA70D6', satelliteQuarterOutlineColor: '#FFFFFF', satelliteGenericLayerColor: '#FFFF00',
    width: 2, labelVisibleZoom: 15
};
// const sevenDigitsRegions = ['24','63', '66', '77','78','91']; // Перенесено выше
let CadastralLabelLayout;
let selectedMapPolygon = null;
let globalAbortController = null;
let routeDestinationCoords = null;
let mapClickListener = null;

const routeSelectionModal = document.getElementById('routeSelectionModal');
const routeFromCurrentLocationBtn = document.getElementById('routeFromCurrentLocation');
const routeFromMapPointBtn = document.getElementById('routeFromMapPoint');
const closeRouteModalBtn = document.getElementById('closeRouteModal');
const routeInfoPanel = document.getElementById('routeInfoPanel');
const routeInfoContent = document.getElementById('routeInfoContent');
const closeRouteInfoPanelBtn = document.getElementById('closeRouteInfoPanel');


let useVercelProxy = false; 

async function fetchWithFallback(path, options = {}) {
    const vercelProxyUrl = `https://nsp-two.vercel.app/?target=${encodeURIComponent(path)}`;

 
    if (useVercelProxy) {
        return fetch(vercelProxyUrl, options);
    }

    const directUrl = `https://nspd.gov.ru${path}`;
    try {
        const response = await fetch(directUrl, options);
        if (!response.ok) {
            throw new Error(`Direct request failed with status: ${response.status}`);
        }
        return response; 
    } catch (error) {
 
        useVercelProxy = true;


     
        return fetch(vercelProxyUrl, options);
    }
}


function showRouteModal() { routeSelectionModal.classList.add('show'); }
function hideRouteModal() { routeSelectionModal.classList.remove('show'); }
function displayRouteInfo(htmlContent) { routeInfoContent.innerHTML = htmlContent; routeInfoPanel.classList.add('show'); }
function hideRouteInfo() { routeInfoPanel.classList.remove('show'); routeInfoContent.innerHTML = ''; }
function isMobileDevice() { return window.innerWidth <= 600; }

proj4.defs("EPSG:3857", "+proj=merc +a=6378137 +b=6378137 +lat_ts=0.0 +lon_0=0.0 +x_0=0.0 +y_0=0 +k=1.0 +units=m +nadgrids=@null +wktext +no_defs");
proj4.defs("EPSG:4326", "+proj=longlat +datum=WGS84 +no_defs");

function toEPSG3857(latitude, longitude) { const RADIUS = 6378137; const x = RADIUS * longitude * Math.PI / 180; const y = RADIUS * Math.log(Math.tan(Math.PI / 4 + latitude * Math.PI / 360)); return { x: x, y: y }; }
function showLoader(message = "Загрузка...") { const loaderContainer = document.getElementById('loaderContainer'); const loaderText = document.getElementById('loaderText'); if (loaderText) loaderText.textContent = message; if (loaderContainer) loaderContainer.style.display = 'flex'; }
function hideLoader() { const loaderContainer = document.getElementById('loaderContainer'); if (loaderContainer) loaderContainer.style.display = 'none'; }
function showNotification(message, type = 'info', icon = 'info-circle') { const existingNotification = document.querySelector('.notification'); if (existingNotification) existingNotification.remove(); const notification = document.createElement('div'); notification.className = `notification ${type}`; notification.innerHTML = `<i class="fas fa-${icon}"></i> ${message}`; document.body.appendChild(notification); setTimeout(() => notification.classList.add('show'), 10); setTimeout(() => { notification.classList.remove('show'); setTimeout(() => notification.remove(), 500); }, 4000); }
function showConfirmationDialog(title, message, confirmText = 'Да', cancelText = 'Нет') { return new Promise((resolve) => { const existingModal = document.getElementById('confirmationModal'); if (existingModal) existingModal.remove(); const modalContainer = document.createElement('div'); modalContainer.id = 'confirmationModal'; modalContainer.className = 'modal-container'; modalContainer.innerHTML = ` <div class="modal-content"> <h3>${title}</h3> <p style="font-size: 1rem; color: #495057; line-height: 1.6; margin: 15px 0 20px;">${message}</p> <div style="display: flex; justify-content: center; flex-wrap: wrap; gap: 15px;"> <button id="confirmBtn" class="modal-button primary" style="flex-grow: 1; min-width: 120px;"> <i class="fas fa-check"></i> ${confirmText} </button> <button id="cancelBtn" class="modal-button cancel" style="flex-grow: 1; min-width: 120px;"> <i class="fas fa-times"></i> ${cancelText} </button> </div> </div> `; document.body.appendChild(modalContainer); setTimeout(() => modalContainer.classList.add('show'), 10); const closeModal = (result) => { modalContainer.classList.remove('show'); setTimeout(() => { if (document.body.contains(modalContainer)) document.body.removeChild(modalContainer); resolve(result); }, 300); }; modalContainer.querySelector('#confirmBtn').onclick = () => closeModal(true); modalContainer.querySelector('#cancelBtn').onclick = () => closeModal(false); }); }
function clearMapObjects() { if (map) map.geoObjects.removeAll(); mapObjects = []; selectedMapPolygon = null; hideRouteInfo(); }


async function queryNSPD_WMS(latitude, longitude, layerId, signal) {
    const centerPoint = toEPSG3857(latitude, longitude);
    const bboxSize = 0.15;
    const bbox = `${centerPoint.x - bboxSize / 2},${centerPoint.y - bboxSize / 2},${centerPoint.x + bboxSize / 2},${centerPoint.y + bboxSize / 2}`;
    const path = `/api/aeggis/v4/${layerId}/wms?REQUEST=GetFeatureInfo&QUERY_LAYERS=${layerId}&SERVICE=WMS&VERSION=1.3.0&FORMAT=image%2Fpng%2F&STYLES=&TRANSPARENT=true&LAYERS=${layerId}&RANDOM=${Math.random()}&INFO_FORMAT=application%2Fjson&FEATURE_COUNT=10&I=256&J=256&WIDTH=512&HEIGHT=512&CRS=EPSG%3A3857&BBOX=${bbox}`;
    try {
        const response = await fetchWithFallback(path, { signal });
        if (!response.ok) throw new Error(`HTTP error ${response.status}`);
        return await response.json();
    } catch (error) {
        if (error.name === 'AbortError') throw error;
        console.error(`Error fetching NSPD WMS layer ${layerId}:`, error);
        showNotification(`Ошибка запроса слоя ${layerId}`, 'error');
        return null;
    }
}
async function queryNSPD_Search(query, thematicSearchId, signal) {
    const path = `/api/geoportal/v2/search/geoportal?thematicSearchId=${thematicSearchId}&query=${encodeURIComponent(query)}`;
    try {
        const response = await fetchWithFallback(path, { signal });
        if (!response.ok) throw new Error(`HTTP error ${response.status}`);
        const data = await response.json();
        if (data && data.data && data.data.features && data.data.features.length > 0) {
            return data.data.features[0];
        }
        return null;
    } catch (error) {
        if (error.name === 'AbortError') throw error;
        console.error(`Error fetching NSPD Search (ID ${thematicSearchId}, Query ${query}):`, error);
        showNotification(`Ошибка поиска объекта ${query}`, 'error');
        return null;
    }
}
async function handleParcelsInQuarter(lat, lon) {
    if (globalAbortController) globalAbortController.abort();
    globalAbortController = new AbortController();
    const { signal } = globalAbortController;
    try {
        showLoader("Определение квартала...");
        const wmsData = await queryNSPD_WMS(lat, lon, 36048, signal);
        if (signal.aborted) throw new DOMException('Aborted by user', 'AbortError');
        if (!wmsData || !wmsData.features || wmsData.features.length === 0) {
            showNotification('Не удалось определить ЗУ в точке', 'warning'); return;
        }
        const initialFeature = wmsData.features[0];
        if (!initialFeature.properties || !initialFeature.properties.descr) {
            showNotification('Не удалось получить КН исходного ЗУ', 'error'); return;
        }
        const initialCN = initialFeature.properties.descr;
        if (initialCN.split(':').length < 3) {
            showNotification('Некорректный КН для определения квартала', 'error'); return;
        }
        const quarterNumber = initialCN.split(':').slice(0, 3).join(':');
        
        // --- ИЗМЕНЕНИЕ: Замена диалога подтверждения на простую проверку ---
        if (isExactlyZeroQuarterNumber(quarterNumber)) {
            hideLoader();
            showNotification('Поиск в нулевом квартале не выполняется', 'warning');
            if (globalAbortController && globalAbortController.signal === signal) globalAbortController = null;
            return;
        }
        // --- КОНЕЦ ИЗМЕНЕНИЯ ---

        showLoader(`Загрузка ЗУ в квартале ${quarterNumber}...`);
        const quarterFeature = await queryNSPD_Search(quarterNumber, 2, signal);
        if (signal.aborted) throw new DOMException('Aborted by user', 'AbortError');
        if (!quarterFeature) { showNotification(`Квартал ${quarterNumber} не найден`, 'error'); return; }
        const quarterDrawResult = drawNspdFeature(quarterFeature, { baseColorType: 'quarterOutline', hintText: `Квартал: ${quarterNumber}`, zIndex: 200 });
        const requestBody = { "geom": { "type": "FeatureCollection", "features": [{ "type": "Feature", "geometry": quarterFeature.geometry, "properties": {} }] }, "categories": [{ "id": 36368 }] };
        
        const intersectsPath = '/api/geoportal/v1/intersects?typeIntersect=fullObject';
        const intersectsResponse = await fetchWithFallback(intersectsPath, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(requestBody), signal });

        if (signal.aborted) throw new DOMException('Aborted by user', 'AbortError');
        if (!intersectsResponse.ok) { showNotification(`Ошибка запроса участков для ${quarterNumber}`, 'error'); return; }
        const parcelsData = await intersectsResponse.json();
        if (signal.aborted) throw new DOMException('Aborted by user', 'AbortError');
        if (!parcelsData.features || parcelsData.features.length === 0) {
            showNotification(`Участки в квартале ${quarterNumber} не найдены`, 'info');
            if (quarterDrawResult && quarterDrawResult.bounds) map.setBounds(quarterDrawResult.bounds, { checkZoomRange: true, duration: 300 });
            return;
        }
        let overallBounds = quarterDrawResult ? quarterDrawResult.bounds : null;
        parcelsData.features.forEach(parcelFeature => {
            const cn = parcelFeature.properties?.descr; if (!cn) return; const parts = cn.split(':'); const labelTextForParcel = parts.length > 3 ? `:${parts.pop()}` : cn; const declared = isZuDeclared(parcelFeature.properties?.options); const baseColorTypeForParcel = declared ? 'declaredZU' : 'specifiedZU'; const parcelDrawResult = drawNspdFeature(parcelFeature, { baseColorType: baseColorTypeForParcel, hintText: cn, labelText: labelTextForParcel, zIndex: 300, isSelectable: true }); if (parcelDrawResult && parcelDrawResult.bounds) { if (!overallBounds) overallBounds = [[parcelDrawResult.bounds[0][0], parcelDrawResult.bounds[0][1]], [parcelDrawResult.bounds[1][0], parcelDrawResult.bounds[1][1]]]; else { overallBounds[0][0] = Math.min(overallBounds[0][0], parcelDrawResult.bounds[0][0]); overallBounds[0][1] = Math.min(overallBounds[0][1], parcelDrawResult.bounds[0][1]); overallBounds[1][0] = Math.max(overallBounds[1][0], parcelDrawResult.bounds[1][0]); overallBounds[1][1] = Math.max(overallBounds[1][1], parcelDrawResult.bounds[1][1]); } }
        }); if (overallBounds) map.setBounds(overallBounds, { checkZoomRange: true, duration: 300 });
        showNotification(`Загружено ${parcelsData.features.length} ЗУ в квартале ${quarterNumber}`, 'success');
    } catch (error) {
        if (error.name === 'AbortError') showNotification('Операция отменена', 'warning', 'ban');
        else { console.error('Error in handleParcelsInQuarter:', error); showNotification('Произошла ошибка при загрузке ЗУ в квартале', 'error'); }
    } finally {
        hideLoader(); if (globalAbortController && globalAbortController.signal === signal) globalAbortController = null;
    }
}

function isZuDeclared(nspdPropertiesOptions) { if (!nspdPropertiesOptions) return false; const hasSpecified = nspdPropertiesOptions.specified_area !== undefined && nspdPropertiesOptions.specified_area !== null; const hasVerified = nspdPropertiesOptions.land_record_area_verified !== undefined && nspdPropertiesOptions.land_record_area_verified !== null; const hasLandRecordArea = nspdPropertiesOptions.land_record_area !== undefined && nspdPropertiesOptions.land_record_area !== null; if (hasSpecified || hasVerified || hasLandRecordArea) return false; const hasDeclared = nspdPropertiesOptions.declared_area !== undefined && nspdPropertiesOptions.declared_area !== null; const hasLandRecordDeclaration = nspdPropertiesOptions.land_record_area_declaration !== undefined && nspdPropertiesOptions.land_record_area_declaration !== null; return hasDeclared || hasLandRecordDeclaration; }
function getCurrentStrokeColor(baseColorType) { if (!map) return polygonStyle.genericLayerColor; const currentMapType = map.getType(); const isSatelliteView = currentMapType === 'yandex#satellite' || currentMapType === 'yandex#hybrid'; switch (baseColorType) { case 'declaredZU': return isSatelliteView ? polygonStyle.satelliteDeclaredZuColor : polygonStyle.declaredZuColor; case 'specifiedZU': return isSatelliteView ? polygonStyle.satelliteSpecifiedZuColor : polygonStyle.specifiedZuColor; case 'oks': return isSatelliteView ? polygonStyle.satelliteOksColor : polygonStyle.oksColor; case 'quarterOutline': return isSatelliteView ? polygonStyle.satelliteQuarterOutlineColor : polygonStyle.quarterOutlineColor; default: if (typeof baseColorType === 'string' && baseColorType.startsWith('#')) { return isSatelliteView ? polygonStyle.satelliteGenericLayerColor : baseColorType; } return isSatelliteView ? polygonStyle.satelliteGenericLayerColor : polygonStyle.genericLayerColor; } }
function drawNspdFeature(feature, options = {}) { let { baseColorType = 'generic', fillColorOpacity = 0.2, hintText = null, labelText = null, zIndex = 300, isSelectable = false } = options; const actualStrokeColor = getCurrentStrokeColor(baseColorType); const actualCalculatedFillColor = (baseColorType === 'quarterOutline' || baseColorType === '#AAAAAA') ? '#00000000' : `${actualStrokeColor}${Math.round(fillColorOpacity * 255).toString(16).padStart(2, '0')}`; if (!feature || !feature.geometry || !feature.geometry.coordinates) return null; const geometryType = feature.geometry.type; let allContoursCoords = []; if (geometryType === "Polygon") { if (Array.isArray(feature.geometry.coordinates) && feature.geometry.coordinates.length > 0 && Array.isArray(feature.geometry.coordinates[0])) { allContoursCoords = [feature.geometry.coordinates[0]]; } else { return null; } } else if (geometryType === "MultiPolygon") { if (Array.isArray(feature.geometry.coordinates)) { allContoursCoords = feature.geometry.coordinates.map(poly => (Array.isArray(poly) && poly.length > 0 && Array.isArray(poly[0])) ? poly[0] : null).filter(Boolean); } else { return null; } } else { return null; } if (allContoursCoords.length === 0) return null; const yandexPolygonsGeometries = []; let combinedBounds = null; allContoursCoords.forEach(contour => { if (!Array.isArray(contour)) return; const wgsCoords = contour.map(coord => { if (!Array.isArray(coord) || coord.length !== 2) return null; try { const p = proj4('EPSG:3857', 'EPSG:4326', coord); return [p[1], p[0]]; } catch (e) { return null; } }).filter(Boolean); if (wgsCoords.length < 3) return; const offsetCoords = wgsCoords.map(c => [c[0] - mapOffsetY * 0.000008983, c[1] - mapOffsetX * 0.000008983]); yandexPolygonsGeometries.push(offsetCoords); }); if (yandexPolygonsGeometries.length > 0) { const mapPolygon = new ymaps.Polygon(yandexPolygonsGeometries, { hintContent: hintText || feature.properties?.descr || feature.properties?.label || 'Объект', baseColorType: baseColorType, isSelectableForFill: isSelectable, originalFillOpacity: isSelectable ? null : fillColorOpacity }, { strokeColor: actualStrokeColor, strokeWidth: polygonStyle.width, fillColor: isSelectable ? '#00000000' : actualCalculatedFillColor, strokeOpacity: 0.8, zIndex: zIndex }); if (isSelectable) { mapPolygon.events.add('click', function (e) { if (selectedMapPolygon && selectedMapPolygon !== mapPolygon) { selectedMapPolygon.options.set('fillColor', '#00000000'); } const currentStroke = mapPolygon.options.get('strokeColor'); mapPolygon.options.set('fillColor', `${currentStroke}${Math.round(0.05 * 255).toString(16).padStart(2, '0')}`); selectedMapPolygon = mapPolygon; map.balloon.open(e.get('coords'), `<strong>${mapPolygon.properties.get('hintContent') || "Информация об объекте"}</strong>`); }); } map.geoObjects.add(mapPolygon); mapObjects.push(mapPolygon); const currentObjectBounds = mapPolygon.geometry.getBounds(); if (currentObjectBounds) { if (!combinedBounds) { combinedBounds = [[currentObjectBounds[0][0], currentObjectBounds[0][1]], [currentObjectBounds[1][0], currentObjectBounds[1][1]]]; } else { combinedBounds[0][0] = Math.min(combinedBounds[0][0], currentObjectBounds[0][0]); combinedBounds[0][1] = Math.min(combinedBounds[0][1], currentObjectBounds[0][1]); combinedBounds[1][0] = Math.max(combinedBounds[1][0], currentObjectBounds[1][0]); combinedBounds[1][1] = Math.max(combinedBounds[1][1], currentObjectBounds[1][1]); } } if (labelText && currentObjectBounds) { const centerLat = (currentObjectBounds[0][0] + currentObjectBounds[1][0]) / 2; const centerLon = (currentObjectBounds[0][1] + currentObjectBounds[1][1]) / 2; const cnLabel = new ymaps.Placemark([centerLat, centerLon], { iconContent: labelText, zoomFontSize: 10 }, { iconLayout: CadastralLabelLayout, visible: map.getZoom() >= polygonStyle.labelVisibleZoom, zIndex: zIndex + 10 }); map.geoObjects.add(cnLabel); mapObjects.push(cnLabel); } return { mapObject: mapPolygon, bounds: combinedBounds }; } return null; }
async function getAddressByCoords(coords) { try { const res = await ymaps.geocode(coords); const firstGeoObject = res.geoObjects.get(0); return firstGeoObject ? firstGeoObject.getAddressLine() : 'Адрес не найден'; } catch (error) { console.error("Ошибка геокодирования:", error); return 'Ошибка получения адреса'; } }
function isValidCadastralNumber(text) { return /^\d{2}:\d{2}:\d{6,7}:\d+$/.test(text.trim()); }
function isCadastralQuarter(text) { return /^\d{2}:\d{2}:\d{6,7}$/.test(text.trim()); }
function formatPotentialCadastralNumber(value) { if (/[a-zA-Zа-яА-ЯЁё]/.test(value)) return value; let cleanedValue = value.replace(/\D/g, ''); const firstTwoDigits = cleanedValue.slice(0, 2); const isSevenDigitsRegion = sevenDigitsRegions.includes(firstTwoDigits); const thirdBlockLength = isSevenDigitsRegion ? 7 : 6; let formatted = ''; if (cleanedValue.length > 0) formatted += cleanedValue.slice(0, 2); if (cleanedValue.length > 2) formatted += ':' + cleanedValue.slice(2, 4); if (cleanedValue.length > 4) { const remaining = cleanedValue.slice(4); if (remaining.length <= thirdBlockLength) formatted += ':' + remaining; else { formatted += ':' + remaining.slice(0, thirdBlockLength); if (remaining.length > thirdBlockLength) formatted += ':' + remaining.slice(thirdBlockLength); } } return formatted; }
async function handleQuarterBounds(lat, lon) { if (globalAbortController) globalAbortController.abort(); globalAbortController = new AbortController(); const { signal } = globalAbortController; try { showLoader("Определение квартала..."); const wmsData = await queryNSPD_WMS(lat, lon, 36048, signal); if (signal.aborted) throw new DOMException('Aborted by user', 'AbortError'); if (!wmsData || !wmsData.features || wmsData.features.length === 0) { showNotification('Не удалось определить ЗУ в точке для квартала', 'warning'); return; } const initialFeature = wmsData.features[0]; if (!initialFeature.properties || !initialFeature.properties.descr) { showNotification('Не удалось получить КН исходного ЗУ', 'error'); return; } const initialCN = initialFeature.properties.descr; if (initialCN.split(':').length < 3) { showNotification('Некорректный КН для определения квартала', 'error'); return; } const quarterNumber = initialCN.split(':').slice(0, 3).join(':'); 
    
    // --- ИЗМЕНЕНИЕ: Добавлена проверка на нулевой квартал ---
    if (isExactlyZeroQuarterNumber(quarterNumber)) {
        showNotification('Запрос границ нулевого квартала не выполняется', 'warning');
        hideLoader();
        return;
    }
    // --- КОНЕЦ ИЗМЕНЕНИЯ ---

    showLoader(`Загрузка границ квартала ${quarterNumber}...`); const quarterFeature = await queryNSPD_Search(quarterNumber, 2, signal); if (signal.aborted) throw new DOMException('Aborted by user', 'AbortError'); if (!quarterFeature) { showNotification(`Границы квартала ${quarterNumber} не найдены`, 'error'); return; } const drawResult = drawNspdFeature(quarterFeature, { baseColorType: 'quarterOutline', hintText: `Квартал: ${quarterNumber}`, labelText: quarterNumber }); if (drawResult && drawResult.bounds) map.setBounds(drawResult.bounds, { checkZoomRange: true, duration: 300 }); } catch (error) { if (error.name === 'AbortError') { showNotification('Операция отменена', 'warning', 'ban'); } else { console.error('Error in handleQuarterBounds:', error); showNotification('Произошла ошибка при загрузке границ квартала', 'error'); } } finally { hideLoader(); if (globalAbortController && globalAbortController.signal === signal) { globalAbortController = null; } } }
async function handleOpenZU(lat, lon) { if (globalAbortController) globalAbortController.abort(); globalAbortController = new AbortController(); const { signal } = globalAbortController; try { showLoader("Поиск ЗУ..."); const parcelData = await queryNSPD_WMS(lat, lon, 36048, signal); if (signal.aborted) throw new DOMException('Aborted by user', 'AbortError'); if (!parcelData || !parcelData.features || parcelData.features.length === 0) { showNotification('ЗУ в этой точке не найден', 'warning'); return; } const feature = parcelData.features[0]; const cn = feature.properties?.descr; if (!cn) { showNotification('КН для ЗУ не найден', 'error'); return; } const parts = cn.split(':'); const labelTextForParcel = parts.length > 3 ? `:${parts.pop()}` : cn; const declared = isZuDeclared(feature.properties?.options); const baseColorTypeForZU = declared ? 'declaredZU' : 'specifiedZU'; const drawResult = drawNspdFeature(feature, { baseColorType: baseColorTypeForZU, hintText: cn, labelText: labelTextForParcel, isSelectable: true }); if (drawResult && drawResult.bounds) map.setBounds(drawResult.bounds, { checkZoomRange: true, duration: 300 }); } catch (error) { if (error.name === 'AbortError') { showNotification('Операция отменена', 'warning', 'ban'); } else { console.error('Error in handleOpenZU:', error); showNotification('Произошла ошибка при открытии ЗУ', 'error'); } } finally { hideLoader(); if (globalAbortController && globalAbortController.signal === signal) { globalAbortController = null; } } }
async function handleOpenOKS(lat, lon) { if (globalAbortController) globalAbortController.abort(); globalAbortController = new AbortController(); const { signal } = globalAbortController; try { showLoader("Поиск ОКС..."); const oksData = await queryNSPD_WMS(lat, lon, 36049, signal); if (signal.aborted) throw new DOMException('Aborted by user', 'AbortError'); if (!oksData || !oksData.features || oksData.features.length === 0) { showNotification('ОКС в этой точке не найден', 'warning'); return; } const feature = oksData.features[0]; const cn = feature.properties?.descr; if (!cn) { showNotification('КН для ОКС не найден', 'error'); return; } const parts = cn.split(':'); const labelTextForOKS = parts.length > 3 ? `:${parts.pop()}` : cn; const drawResult = drawNspdFeature(feature, { baseColorType: 'oks', hintText: cn, labelText: labelTextForOKS, isSelectable: true }); if (drawResult && drawResult.bounds) map.setBounds(drawResult.bounds, { checkZoomRange: true, duration: 300 }); } catch (error) { if (error.name === 'AbortError') { showNotification('Операция отменена', 'warning', 'ban'); } else { console.error('Error in handleOpenOKS:', error); showNotification('Произошла ошибка при открытии ОКС', 'error'); } } finally { hideLoader(); if (globalAbortController && globalAbortController.signal === signal) { globalAbortController = null; } } }
async function handleGenericLayer(lat, lon, layerId, layerName, colorHex, thematicId = null) { if (globalAbortController) globalAbortController.abort(); globalAbortController = new AbortController(); const { signal } = globalAbortController; try { showLoader(`Поиск ${layerName}...`); let featureCollection; if (thematicId) { const pointData = await queryNSPD_WMS(lat, lon, 36048, signal); if (signal.aborted) throw new DOMException('Aborted by user', 'AbortError'); if (!pointData || !pointData.features || pointData.features.length === 0) { showNotification(`Не удалось определить объект в точке для поиска ${layerName}`, 'warning'); return; } const refFeature = pointData.features[0]; if (!refFeature.properties || !refFeature.properties.descr) { showNotification(`Не удалось получить КН для поиска ${layerName}`, 'error'); return; } const refDescr = refFeature.properties.descr; const searchFeature = await queryNSPD_Search(refDescr, thematicId, signal); if (signal.aborted) throw new DOMException('Aborted by user', 'AbortError'); featureCollection = searchFeature ? { features: [searchFeature] } : null; } else { featureCollection = await queryNSPD_WMS(lat, lon, layerId, signal); if (signal.aborted) throw new DOMException('Aborted by user', 'AbortError'); } if (!featureCollection || !featureCollection.features || featureCollection.features.length === 0) { showNotification(`${layerName} в этой точке не найден(ы)`, 'warning'); return; } let overallBounds = null; let featuresDrawn = 0; featureCollection.features.forEach(feature => { let objectName = feature.properties?.options?.name || feature.properties?.options?.name_by_doc || feature.properties?.name_by_doc || feature.properties?.label || feature.properties?.name || feature.properties?.descr || layerName; objectName = String(objectName).trim(); const regNumbBorder = feature.properties?.options?.reg_numb_border || feature.properties?.reg_numb_border; let displayText = objectName; if (regNumbBorder && (layerId === 37579 || layerId === 36315)) { displayText = `${regNumbBorder} - ${objectName}`; } else if (layerId === 36281 && feature.properties?.type_name) { displayText = `${feature.properties.type_name.trim()} ${objectName}`; } else if (layerId === 36278 && feature.properties?.type) { displayText = `${feature.properties.type.trim()} ${objectName}`; } const drawResult = drawNspdFeature(feature, { baseColorType: colorHex, fillColorOpacity: 0.15, hintText: displayText, labelText: displayText, isSelectable: true }); if (drawResult && drawResult.bounds) { featuresDrawn++; if (!overallBounds) overallBounds = [[drawResult.bounds[0][0], drawResult.bounds[0][1]], [drawResult.bounds[1][0], drawResult.bounds[1][1]]]; else { overallBounds[0][0] = Math.min(overallBounds[0][0], drawResult.bounds[0][0]); overallBounds[0][1] = Math.min(overallBounds[0][1], drawResult.bounds[0][1]); overallBounds[1][0] = Math.max(overallBounds[1][0], drawResult.bounds[1][0]); overallBounds[1][1] = Math.max(overallBounds[1][1], drawResult.bounds[1][1]); } } }); if (featuresDrawn > 0 && overallBounds) { map.setBounds(overallBounds, { checkZoomRange: true, duration: 300 }); } else if (featuresDrawn === 0) { showNotification(`${layerName} не найден(ы) или не удалось отобразить`, 'warning'); } } catch (error) { if (error.name === 'AbortError') { showNotification('Операция отменена', 'warning', 'ban'); } else { console.error(`Error in handleGenericLayer (${layerName}):`, error); showNotification(`Произошла ошибка при загрузке слоя ${layerName}`, 'error'); } } finally { hideLoader(); if (globalAbortController && globalAbortController.signal === signal) { globalAbortController = null; } } }
async function handleEgrnInfo(lat, lon) { if (globalAbortController) globalAbortController.abort(); globalAbortController = new AbortController(); const { signal } = globalAbortController; try { showLoader("Поиск объекта ЕГРН..."); const parcelData = await queryNSPD_WMS(lat, lon, 36048, signal); if (signal.aborted) throw new DOMException('Aborted by user', 'AbortError'); let feature = null; if (parcelData && parcelData.features && parcelData.features.length > 0) { feature = parcelData.features[0]; } else { const oksData = await queryNSPD_WMS(lat, lon, 36049, signal); if (signal.aborted) throw new DOMException('Aborted by user', 'AbortError'); if (oksData && oksData.features && oksData.features.length > 0) feature = oksData.features[0]; } if (!feature) { showNotification('Объект ЕГРН в этой точке не найден', 'warning'); return; } const cadastralNumber = feature.properties?.descr; if (!cadastralNumber) { showNotification('Не удалось определить кадастровый номер объекта', 'error'); return; } const isZU = (feature.properties?.category && feature.properties.category.toString() === '36048') || (parcelData && parcelData.features && parcelData.features.length > 0 && parcelData.features[0].id === feature.id); let baseColorTypeForEGRN; if (isZU) { const declared = isZuDeclared(feature.properties?.options); baseColorTypeForEGRN = declared ? 'declaredZU' : 'specifiedZU'; } else { baseColorTypeForEGRN = 'oks'; } const drawResult = drawNspdFeature(feature, { baseColorType: baseColorTypeForEGRN, hintText: `ЕГРН: ${cadastralNumber}`, labelText: cadastralNumber, isSelectable: true }); if (drawResult && drawResult.bounds) map.setBounds(drawResult.bounds, { checkZoomRange: true, duration: 300 }); try { await navigator.clipboard.writeText(cadastralNumber); showNotification(`КН ${cadastralNumber} скопирован. Открытие страницы ЕГРН...`, 'success'); window.open('egrn.html', '_blank'); } catch (err) { showNotification('Ошибка копирования КН. Открытие страницы ЕГРН...', 'warning'); window.open('egrn.html', '_blank'); } } catch (error) { if (error.name === 'AbortError') { showNotification('Операция отменена', 'warning', 'ban'); } else { console.error('Error in handleEgrnInfo:', error); showNotification('Произошла ошибка при обработке ЕГРН', 'error'); } } finally { hideLoader(); if (globalAbortController && globalAbortController.signal === signal) { globalAbortController = null; } } }
async function processMainInput(inputText) { 
    clearMapObjects(); 
    if (globalAbortController) globalAbortController.abort(); 
    globalAbortController = new AbortController(); 
    const { signal } = globalAbortController; 
    
    // --- ИЗМЕНЕНИЕ: Добавлена проверка на нулевой квартал ---
    if (isExactlyZeroQuarterNumber(inputText)) {
        showNotification('Загрузка всего нулевого квартала не выполняется. Укажите полный кадастровый номер объекта.', 'warning');
        return; // Прерываем выполнение
    }
    // --- КОНЕЦ ИЗМЕНЕНИЯ ---

    try { 
        showLoader("Обработка..."); 
        if (isCadastralQuarter(inputText)) { 
            const quarterFeature = await queryNSPD_Search(inputText, 2, signal); 
            if (signal.aborted) throw new DOMException('Aborted by user', 'AbortError'); 
            if (quarterFeature) { 
                const drawResult = drawNspdFeature(quarterFeature, { baseColorType: 'quarterOutline', hintText: `Квартал: ${inputText}`, labelText: inputText, zIndex: 100 }); 
                if (drawResult && drawResult.bounds) map.setBounds(drawResult.bounds, { checkZoomRange: true, duration: 300 }); 
            } else showNotification(`Квартал ${inputText} не найден`, 'error'); 
        } else if (isValidCadastralNumber(inputText)) { 
            const feature = await queryNSPD_Search(inputText, 1, signal); 
            if (signal.aborted) throw new DOMException('Aborted by user', 'AbortError'); 
            if (feature) { 
                const isZU = feature.properties?.categoryName?.includes("Земельные участки"); 
                const cn = feature.properties?.descr; 
                if (!cn) { 
                    showNotification('Не удалось получить КН объекта', 'error'); 
                    return; 
                } 
                const parts = cn.split(':'); 
                const labelTextForObject = parts.length > 3 ? `:${parts.pop()}` : cn; 
                let baseColorTypeForObject; 
                if (isZU) { 
                    const declared = isZuDeclared(feature.properties?.options); 
                    baseColorTypeForObject = declared ? 'declaredZU' : 'specifiedZU'; 
                } else baseColorTypeForObject = 'oks'; 
                const drawResult = drawNspdFeature(feature, { baseColorType: baseColorTypeForObject, hintText: cn, labelText: labelTextForObject, isSelectable: true }); 
                if (drawResult && drawResult.bounds) map.setBounds(drawResult.bounds, { checkZoomRange: true, duration: 300 }); 
            } else showNotification(`Объект с КН ${inputText} не найден`, 'error'); 
        } else { 
            const res = await ymaps.geocode(inputText, { results: 1 }); 
            if (signal.aborted) throw new DOMException('Aborted by user', 'AbortError'); 
            const firstGeoObject = res.geoObjects.get(0); 
            if (firstGeoObject) { 
                const coords = firstGeoObject.geometry.getCoordinates(); 
                map.setCenter(coords, 17); 
                const placemark = new ymaps.Placemark(coords, { hintContent: firstGeoObject.getAddressLine() }, { preset: 'islands#redDotIcon', zIndex: 500 }); 
                map.geoObjects.add(placemark); 
                mapObjects.push(placemark); 
                document.getElementById('search-input').placeholder = firstGeoObject.getAddressLine(); 
                showNotification('Адрес найден', 'success'); 
            } else { 
                showNotification('Адрес не найден', 'error'); 
                document.getElementById('search-input').placeholder = "Кадастровый номер или адрес"; 
            } 
        } 
    } catch (error) { 
        if (error.name === 'AbortError') { 
            showNotification('Операция отменена', 'warning', 'ban'); 
            document.getElementById('search-input').placeholder = "Кадастровый номер или адрес"; 
        } else { 
            console.error('Error in processMainInput:', error); 
            showNotification('Произошла ошибка при обработке запроса', 'error'); 
            document.getElementById('search-input').placeholder = "Кадастровый номер или адрес"; 
        } 
    } finally { 
        hideLoader(); 
        if (globalAbortController && globalAbortController.signal === signal) { 
            globalAbortController = null; 
        } 
    } 
}
async function buildRoute(originCoords, destinationCoords) { clearMapObjects(); showLoader("Построение маршрута..."); try { const route = await ymaps.route([originCoords, destinationCoords], { mapStateAutoApply: true, routingMode: 'auto' }); map.geoObjects.add(route); mapObjects.push(route); const totalLengthMeters = route.getLength(); const totalLengthKm = (totalLengthMeters / 1000).toFixed(2); let routeInfoHtml = `<h3>Информация о маршруте</h3><p><strong>Общая длина:</strong> ${totalLengthKm} км</p>`; const paths = route.getPaths(); let originFullAddress = 'Начальная точка'; let originLocalityName = 'Начальный НП'; try { const originGeoFull = await ymaps.geocode(originCoords, { results: 1 }); if (originGeoFull.geoObjects.getLength() > 0) { originFullAddress = originGeoFull.geoObjects.get(0).getAddressLine(); } const originGeoLocality = await ymaps.geocode(originCoords, { kind: 'locality', results: 1 }); if (originGeoLocality.geoObjects.getLength() > 0) { const loc = originGeoLocality.geoObjects.get(0); originLocalityName = loc.getLocalities().length > 0 ? loc.getLocalities().join(', ') : loc.getThoroughfare() || loc.getPremise() || originFullAddress; } else { originLocalityName = originFullAddress; } } catch (e) { console.warn('Error geocoding origin:', e); } let destinationFullAddress = 'Конечная точка'; let destinationLocalityName = 'Конечный НП'; try { const destGeoFull = await ymaps.geocode(destinationCoords, { results: 1 }); if (destGeoFull.geoObjects.getLength() > 0) { destinationFullAddress = destGeoFull.geoObjects.get(0).getAddressLine(); } const destGeoLocality = await ymaps.geocode(destinationCoords, { kind: 'locality', results: 1 }); if (destGeoLocality.geoObjects.getLength() > 0) { const loc = destGeoLocality.geoObjects.get(0); destinationLocalityName = loc.getLocalities().length > 0 ? loc.getLocalities().join(', ') : loc.getThoroughfare() || loc.getPremise() || destinationFullAddress; } else { destinationLocalityName = destinationFullAddress; } } catch (e) { console.warn('Error geocoding destination:', e); } const displayPoints = []; let accumulatedDistanceMeters = 0; let lastPushedLocalityName = originLocalityName; displayPoints.push({ type: 'start', displayName: originFullAddress, localityName: originLocalityName, distanceFromStartKm: 0, distanceFromPreviousKm: 0 }); if (paths.getLength() > 0) { for (let i = 0; i < paths.getLength(); i++) { const path = paths.get(i); const pathSegments = path.getSegments(); for (let j = 0; j < pathSegments.length; j++) { const segment = pathSegments[j]; const segmentLengthMeters = segment.getLength(); const segmentCoords = segment.getCoordinates(); const segmentEndPoint = segmentCoords[segmentCoords.length - 1]; const distanceAtSegmentStart = accumulatedDistanceMeters; accumulatedDistanceMeters += segmentLengthMeters; if (! (i === paths.getLength() - 1 && j === pathSegments.length - 1 && accumulatedDistanceMeters >= totalLengthMeters -1 ) ) { try { let currentSegmentLocalityName = null; const segmentGeoLocality = await ymaps.geocode(segmentEndPoint, { kind: 'locality', results: 1 }); if (segmentGeoLocality.geoObjects.getLength() > 0) { const loc = segmentGeoLocality.geoObjects.get(0); currentSegmentLocalityName = loc.getLocalities().length > 0 ? loc.getLocalities().join(', ') : loc.getThoroughfare() || loc.getPremise(); } else { const segmentGeoFull = await ymaps.geocode(segmentEndPoint, { results: 1 }); if(segmentGeoFull.geoObjects.getLength() > 0){ currentSegmentLocalityName = segmentGeoFull.geoObjects.get(0).getAddressLine(); } } if (currentSegmentLocalityName && currentSegmentLocalityName !== lastPushedLocalityName && currentSegmentLocalityName !== destinationLocalityName) { const distanceFromStartKm = parseFloat((distanceAtSegmentStart / 1000).toFixed(2)); const prevPoint = displayPoints[displayPoints.length - 1]; const distanceFromPreviousKm = parseFloat(((distanceAtSegmentStart - (prevPoint.distanceFromStartKm * 1000)) / 1000).toFixed(2)); displayPoints.push({ type: 'intermediate', displayName: currentSegmentLocalityName, localityName: currentSegmentLocalityName, distanceFromStartKm: distanceFromStartKm, distanceFromPreviousKm: distanceFromPreviousKm < 0 ? 0 : distanceFromPreviousKm }); lastPushedLocalityName = currentSegmentLocalityName; } } catch (e) { console.warn('Geocoding error for intermediate segment point:', segmentEndPoint, e); } } } } } const lastPointInDisplayList = displayPoints.length > 0 ? displayPoints[displayPoints.length - 1] : null; if (!lastPointInDisplayList || lastPointInDisplayList.localityName !== destinationLocalityName || lastPointInDisplayList.type !== 'end' || (lastPointInDisplayList.localityName === destinationLocalityName && lastPointInDisplayList.displayName !== destinationFullAddress) ) { const prevPoint = displayPoints.length > 0 ? displayPoints[displayPoints.length - 1] : { distanceFromStartKm: 0 }; let distanceFromPreviousKm = parseFloat(((totalLengthMeters - (prevPoint.distanceFromStartKm * 1000)) / 1000).toFixed(2)); if(lastPointInDisplayList && lastPointInDisplayList.localityName === destinationLocalityName && lastPointInDisplayList.type === 'intermediate'){ displayPoints.pop(); const newPrevPoint = displayPoints.length > 0 ? displayPoints[displayPoints.length - 1] : { distanceFromStartKm: 0 }; distanceFromPreviousKm = parseFloat(((totalLengthMeters - (newPrevPoint.distanceFromStartKm * 1000)) / 1000).toFixed(2)); } displayPoints.push({ type: 'end', displayName: destinationFullAddress, localityName: destinationLocalityName, distanceFromStartKm: parseFloat(totalLengthKm), distanceFromPreviousKm: distanceFromPreviousKm < 0 ? 0 : distanceFromPreviousKm }); } else if (lastPointInDisplayList && lastPointInDisplayList.localityName === destinationLocalityName && lastPointInDisplayList.type === 'intermediate') { lastPointInDisplayList.type = 'end'; lastPointInDisplayList.displayName = destinationFullAddress; lastPointInDisplayList.distanceFromStartKm = parseFloat(totalLengthKm); if (displayPoints.length > 1) { const oneBeforeLast = displayPoints[displayPoints.length - 2]; lastPointInDisplayList.distanceFromPreviousKm = parseFloat((parseFloat(totalLengthKm) - oneBeforeLast.distanceFromStartKm).toFixed(2)); if(lastPointInDisplayList.distanceFromPreviousKm < 0) lastPointInDisplayList.distanceFromPreviousKm = 0; } else { lastPointInDisplayList.distanceFromPreviousKm = parseFloat(totalLengthKm); } } const trulyFinalPoints = []; if (displayPoints.length > 0) { trulyFinalPoints.push(displayPoints[0]); for (let i = 1; i < displayPoints.length; i++) { const currentRoutPoint = displayPoints[i]; const prevTrulyFinalPoint = trulyFinalPoints[trulyFinalPoints.length - 1]; if (currentRoutPoint.displayName !== prevTrulyFinalPoint.displayName || currentRoutPoint.type === 'end' && prevTrulyFinalPoint.type !== 'end') { currentRoutPoint.distanceFromPreviousKm = parseFloat((currentRoutPoint.distanceFromStartKm - prevTrulyFinalPoint.distanceFromStartKm).toFixed(2)); if(currentRoutPoint.distanceFromPreviousKm < 0) currentRoutPoint.distanceFromPreviousKm = 0; if (prevTrulyFinalPoint.type === 'intermediate' && currentRoutPoint.type === 'end' && prevTrulyFinalPoint.displayName === currentRoutPoint.displayName) { trulyFinalPoints.pop(); } trulyFinalPoints.push(currentRoutPoint); } else { prevTrulyFinalPoint.distanceFromStartKm = currentRoutPoint.distanceFromStartKm; if (currentRoutPoint.type === 'end') prevTrulyFinalPoint.type = 'end'; } } } if(trulyFinalPoints.length > 0){ const veryLastPoint = trulyFinalPoints[trulyFinalPoints.length-1]; veryLastPoint.distanceFromStartKm = parseFloat(totalLengthKm); if(veryLastPoint.type !== 'start' && trulyFinalPoints.length > 1){ veryLastPoint.distanceFromPreviousKm = parseFloat((parseFloat(totalLengthKm) - trulyFinalPoints[trulyFinalPoints.length-2].distanceFromStartKm).toFixed(2)); if(veryLastPoint.distanceFromPreviousKm < 0) veryLastPoint.distanceFromPreviousKm =0; } else if (veryLastPoint.type !== 'start' && trulyFinalPoints.length === 1) { veryLastPoint.distanceFromPreviousKm = parseFloat(totalLengthKm); } } const uniqueLocalitiesCount = new Set(trulyFinalPoints.map(p => p.localityName)).size; if (trulyFinalPoints.length <= 2 && uniqueLocalitiesCount <= 1 ) { routeInfoHtml += `<p><strong>Откуда:</strong> ${originFullAddress}</p><p><strong>Куда:</strong> ${destinationFullAddress}</p>`; } else if (trulyFinalPoints.length > 0) { routeInfoHtml += `<h4>Промежуточные пункты:</h4><ul>`; for (let k = 0; k < trulyFinalPoints.length; k++) { const point = trulyFinalPoints[k]; let listItemClass = 'route-point-intermediate'; let typeLabel = ''; if (point.type === 'start') { listItemClass = 'route-point-start'; typeLabel = 'Начало'; } else if (point.type === 'end') { listItemClass = 'route-point-end'; typeLabel = 'Конец'; } routeInfoHtml += `<li class="${listItemClass}">`; if (typeLabel) { routeInfoHtml += `<span class="point-type-label">${typeLabel}</span>`; } routeInfoHtml += `<span class="point-display-name">${point.displayName}</span>`; if (point.type === 'start' && trulyFinalPoints.length == 1 && parseFloat(totalLengthKm) > 0){ routeInfoHtml += `<div class="point-distance-details"><span class="dist-total">Всего: ${point.distanceFromStartKm.toFixed(2)} км</span></div>`; } else if (point.type !== 'start') { const distPrev = point.distanceFromPreviousKm; routeInfoHtml += `<div class="point-distance-details"><span class="dist-from-prev">+ ${distPrev >= 0 ? distPrev.toFixed(2) : '-'} км</span><span class="dist-total">Всего: ${point.distanceFromStartKm.toFixed(2)} км</span></div>`; } else if (point.type === 'start' && trulyFinalPoints.length > 1){ routeInfoHtml += `<div class="point-distance-details"><span class="dist-total">Всего: 0.00 км</span></div>`; } routeInfoHtml += `</li>`; } routeInfoHtml += `</ul>`; } else { routeInfoHtml += `<p><strong>Откуда:</strong> ${originFullAddress}</p><p><strong>Куда:</strong> ${destinationFullAddress}</p>`; } displayRouteInfo(routeInfoHtml); showNotification('Маршрут построен.', 'success', 'route'); } catch (error) { console.error("[buildRoute] Ошибка построения маршрута:", error, error.stack); showNotification('Не удалось построить маршрут: ' + (error.message || error.statusText || 'Неизвестная ошибка'), 'error'); } finally { hideLoader(); } }
ymaps.ready(function () {
    CadastralLabelLayout = ymaps.templateLayoutFactory.createClass( '<div class="custom-placemark-label" style="font-size: {{properties.zoomFontSize}}px;">$[properties.iconContent]</div>', { build: function () { this.constructor.superclass.build.call(this); this.updateZoomFontSize(); if (this.getData().geoObject) this.getData().geoObject.events.add('mapchange', this.onMapChange, this); }, clear: function () { if (this.getData().geoObject) this.getData().geoObject.events.remove('mapchange', this.onMapChange, this); this.constructor.superclass.clear.call(this); }, onMapChange: function () { if (this.getData().geoObject && this.getData().geoObject.getMap()) this.updateZoomFontSize(); }, updateZoomFontSize: function () { const geoObjectData = this.getData(); if (!geoObjectData || !geoObjectData.geoObject || !geoObjectData.geoObject.getMap()) return; const currentMap = geoObjectData.geoObject.getMap(); const zoom = currentMap.getZoom(); let fontSize = 10; if (zoom > 15) fontSize = 11; if (zoom > 16) fontSize = 12; if (zoom > 17) fontSize = 13; if (zoom > 18) fontSize = 14; if (geoObjectData.properties && typeof geoObjectData.properties.set === 'function') { geoObjectData.properties.set('zoomFontSize', fontSize); } } } );
    let initialCenter = [54.8492, 50.7910]; let initialZoom = 9; let initialType = 'yandex#map'; const savedLat = localStorage.getItem('mapCenterLat'); const savedLon = localStorage.getItem('mapCenterLon'); const savedZoom = localStorage.getItem('mapZoom'); const savedType = localStorage.getItem('mapTypeSimple');
    if (savedLat && savedLon && savedZoom) { initialCenter = [parseFloat(savedLat), parseFloat(savedLon)]; initialZoom = parseInt(savedZoom, 10); } if (savedType) initialType = savedType;
    map = new ymaps.Map('map', { center: initialCenter, zoom: initialZoom, type: initialType, controls: ['zoomControl', 'fullscreenControl', 'geolocationControl', 'typeSelector'] });
    map.events.add('boundschange', function (e) { const currentZoom = e.get('newZoom'); const currentCenter = map.getCenter(); localStorage.setItem('mapCenterLat', currentCenter[0]); localStorage.setItem('mapCenterLon', currentCenter[1]); localStorage.setItem('mapZoom', currentZoom); mapObjects.forEach(obj => { if (obj instanceof ymaps.Placemark && obj.options.get('iconLayout') === CadastralLabelLayout) { obj.options.set('visible', currentZoom >= polygonStyle.labelVisibleZoom); if (e.get('oldZoom') !== currentZoom) { const layout = obj.getOverlaySync()?.getLayoutSync(); if (layout && typeof layout.updateZoomFontSize === 'function') layout.updateZoomFontSize(); } } }); });
    map.events.add('typechange', function () { const newType = map.getType(); localStorage.setItem('mapTypeSimple', newType); mapObjects.forEach(obj => { if (obj instanceof ymaps.Polygon) { const baseColorType = obj.properties.get('baseColorType') || 'generic'; const newStrokeColor = getCurrentStrokeColor(baseColorType); let newFillColor; const originalFillOpacity = obj.properties.get('originalFillOpacity'); const isSelectablePolygon = obj.properties.get('isSelectableForFill'); if (baseColorType === 'quarterOutline' || baseColorType === '#AAAAAA') { newFillColor = '#00000000'; } else if (isSelectablePolygon) { if (selectedMapPolygon === obj) { newFillColor = `${newStrokeColor}${Math.round(0.05 * 255).toString(16).padStart(2, '0')}`; } else { newFillColor = '#00000000'; } } else { const defaultOpacity = (originalFillOpacity !== null && originalFillOpacity !== undefined) ? originalFillOpacity : 0.2; newFillColor = `${newStrokeColor}${Math.round(defaultOpacity * 255).toString(16).padStart(2, '0')}`; } obj.options.set('strokeColor', newStrokeColor); obj.options.set('fillColor', newFillColor); } }); });
    map.events.add('click', function(e) { const target = e.get('target'); if (selectedMapPolygon && selectedMapPolygon !== target && (target === map || !map.geoObjects.contains(target))) { selectedMapPolygon.options.set('fillColor', '#00000000'); selectedMapPolygon = null; map.balloon.close(); } });
    const searchInput = document.getElementById('search-input'); searchInput.addEventListener('keydown', function(event) { if (event.key === 'Enter') { const query = this.value.trim(); if (query) processMainInput(query); } }); searchInput.addEventListener('input', function() { this.value = formatPotentialCadastralNumber(this.value); });
    document.getElementById('open-search-button').addEventListener('click', function() { const query = searchInput.value.trim(); if (query) processMainInput(query); });
    document.getElementById('clear-map-button').addEventListener('click', function() { if (globalAbortController) { globalAbortController.abort(); globalAbortController = null; hideLoader(); } if (mapClickListener) { map.events.remove('click', mapClickListener); mapClickListener = null; map.container.getElement().style.cursor = ''; } clearMapObjects(); });
    const contextMenuEl = document.getElementById('customContextMenu'); map.events.add('contextmenu', function (e) { e.preventDefault(); const coords = e.get('coords'); const position = e.get('position'); contextMenuEl.style.left = position[0] + 'px'; contextMenuEl.style.top = position[1] + 'px'; contextMenuEl.style.display = 'block'; contextMenuEl.dataset.lat = coords[0].toFixed(8); contextMenuEl.dataset.lon = coords[1].toFixed(8); }); document.addEventListener('click', function (e) { if (!contextMenuEl.contains(e.target)) contextMenuEl.style.display = 'none'; });
    document.addEventListener('keydown', function(event) { if (event.key === 'Escape') { if (globalAbortController) { globalAbortController.abort(); } const activeContextMenu = document.getElementById('customContextMenu'); if (activeContextMenu && activeContextMenu.style.display === 'block') { activeContextMenu.style.display = 'none'; } if (routeSelectionModal.classList.contains('show')) { hideRouteModal(); if (mapClickListener) { map.events.remove('click', mapClickListener); mapClickListener = null; map.container.getElement().style.cursor = ''; showNotification('Выбор начальной точки отменен.', 'info', 'ban'); } } hideRouteInfo(); } });
    document.getElementById('ctx-menu-parcels-in-quarter').addEventListener('click', (e) => { handleParcelsInQuarter(parseFloat(contextMenuEl.dataset.lat), parseFloat(contextMenuEl.dataset.lon)); contextMenuEl.style.display = 'none'; });
    document.getElementById('ctx-menu-quarter-bounds').addEventListener('click', (e) => { handleQuarterBounds(parseFloat(contextMenuEl.dataset.lat), parseFloat(contextMenuEl.dataset.lon)); contextMenuEl.style.display = 'none'; });
    document.getElementById('ctx-menu-open-zu').addEventListener('click', (e) => { handleOpenZU(parseFloat(contextMenuEl.dataset.lat), parseFloat(contextMenuEl.dataset.lon)); contextMenuEl.style.display = 'none'; });
    document.getElementById('ctx-menu-open-oks').addEventListener('click', (e) => { handleOpenOKS(parseFloat(contextMenuEl.dataset.lat), parseFloat(contextMenuEl.dataset.lon)); contextMenuEl.style.display = 'none'; });
    document.getElementById('ctx-menu-terr-zones').addEventListener('click', (e) => { handleGenericLayer(parseFloat(contextMenuEl.dataset.lat), parseFloat(contextMenuEl.dataset.lon), 36315, 'Тер. зоны', '#4682B4'); contextMenuEl.style.display = 'none'; });
    document.getElementById('ctx-menu-zouit').addEventListener('click', (e) => { handleGenericLayer(parseFloat(contextMenuEl.dataset.lat), parseFloat(contextMenuEl.dataset.lon), 37579, 'ЗОУИТ', '#FF6347'); contextMenuEl.style.display = 'none'; });
    document.getElementById('ctx-menu-settlements').addEventListener('click', (e) => { handleGenericLayer(parseFloat(contextMenuEl.dataset.lat), parseFloat(contextMenuEl.dataset.lon), 36281, 'Нас. пункты', '#3CB371'); contextMenuEl.style.display = 'none'; });
    document.getElementById('ctx-menu-municipal').addEventListener('click', (e) => { handleGenericLayer(parseFloat(contextMenuEl.dataset.lat), parseFloat(contextMenuEl.dataset.lon), 36278, 'Муниц. образ.', '#DAA520'); contextMenuEl.style.display = 'none'; });
    document.getElementById('ctx-menu-egrn').addEventListener('click', (e) => { handleEgrnInfo(parseFloat(contextMenuEl.dataset.lat), parseFloat(contextMenuEl.dataset.lon)); contextMenuEl.style.display = 'none'; });
    document.getElementById('ctx-menu-build-route').addEventListener('click', async (e) => { routeDestinationCoords = [parseFloat(contextMenuEl.dataset.lat), parseFloat(contextMenuEl.dataset.lon)]; if (isNaN(routeDestinationCoords[0]) || isNaN(routeDestinationCoords[1])) { showNotification('Не удалось получить координаты для маршрута.', 'error'); contextMenuEl.style.display = 'none'; return; } contextMenuEl.style.display = 'none'; if (isMobileDevice()) { showLoader("Определение местоположения..."); if (navigator.geolocation) { navigator.geolocation.getCurrentPosition( (position) => { const userCoords = [position.coords.latitude, position.coords.longitude]; buildRoute(userCoords, routeDestinationCoords); }, (error) => { hideLoader(); let errorMessage = 'Не удалось определить текущее местоположение.'; if (error.code === error.PERMISSION_DENIED) errorMessage = 'Доступ к геолокации запрещен.'; else if (error.code === error.POSITION_UNAVAILABLE) errorMessage = 'Информация о местоположении недоступна.'; else if (error.code === error.TIMEOUT) errorMessage = 'Время ожидания определения местоположения истекло.'; showNotification(errorMessage + ' Маршрут не построен.', 'warning', 'exclamation-triangle'); }, { enableHighAccuracy: true, timeout: 10000, maximumAge: 0 } ); } else { hideLoader(); showNotification('Геолокация не поддерживается.', 'error', 'times-circle'); } } else { showRouteModal(); } });
    routeFromCurrentLocationBtn.addEventListener('click', () => { hideRouteModal(); showLoader("Определение местоположения..."); if (navigator.geolocation) { navigator.geolocation.getCurrentPosition( (position) => { const userCoords = [position.coords.latitude, position.coords.longitude]; buildRoute(userCoords, routeDestinationCoords); }, (error) => { hideLoader(); let errorMessage = 'Не удалось определить текущее местоположение.'; if (error.code === error.PERMISSION_DENIED) errorMessage = 'Доступ к геолокации запрещен.'; else if (error.code === error.POSITION_UNAVAILABLE) errorMessage = 'Информация о местоположении недоступна.'; else if (error.code === error.TIMEOUT) errorMessage = 'Время ожидания определения местоположения истекло.'; showNotification(errorMessage + ' Маршрут не построен.', 'warning', 'exclamation-triangle'); }, { enableHighAccuracy: true, timeout: 10000, maximumAge: 0 } ); } else { hideLoader(); showNotification('Геолокация не поддерживается.', 'error', 'times-circle'); } });
    routeFromMapPointBtn.addEventListener('click', () => { hideRouteModal(); showNotification('Нажмите на карту, чтобы выбрать начальную точку.', 'info', 'hand-pointer'); map.container.getElement().style.cursor = 'crosshair'; if (mapClickListener) map.events.remove('click', mapClickListener); mapClickListener = (e) => { const originCoords = e.get('coords'); map.events.remove('click', mapClickListener); mapClickListener = null; map.container.getElement().style.cursor = ''; const originPlacemark = new ymaps.Placemark(originCoords, { hintContent: 'Начальная точка' }, { preset: 'islands#blueDotIcon', zIndex: 500 }); map.geoObjects.add(originPlacemark); mapObjects.push(originPlacemark); buildRoute(originCoords, routeDestinationCoords); }; map.events.add('click', mapClickListener); });
    closeRouteModalBtn.addEventListener('click', () => { hideRouteModal(); if (mapClickListener) { map.events.remove('click', mapClickListener); mapClickListener = null; map.container.getElement().style.cursor = ''; showNotification('Выбор начальной точки отменен.', 'info', 'ban'); } });
    closeRouteInfoPanelBtn.addEventListener('click', hideRouteInfo);
    document.getElementById('ctx-menu-yandex-navi').addEventListener('click', (e) => { const destinationLat = parseFloat(contextMenuEl.dataset.lat); const destinationLon = parseFloat(contextMenuEl.dataset.lon); if (isNaN(destinationLat) || isNaN(destinationLon)) { showNotification('Не удалось получить координаты.', 'error'); contextMenuEl.style.display = 'none'; return; } showLoader("Определение местоположения..."); contextMenuEl.style.display = 'none'; if (navigator.geolocation) { navigator.geolocation.getCurrentPosition( (position) => { hideLoader(); const userLat = position.coords.latitude; const userLon = position.coords.longitude; const yandexNaviUrl = `https://yandex.ru/maps/?rtext=${userLat},${userLon}~${destinationLat},${destinationLon}&rtt=auto`; window.open(yandexNaviUrl, '_blank'); showNotification('Открытие Яндекс Навигатора...', 'info', 'car'); }, (error) => { hideLoader(); let errorMessage = 'Не удалось определить местоположение.'; if (error.code === error.PERMISSION_DENIED) errorMessage = 'Доступ к геолокации запрещен.'; else if (error.code === error.POSITION_UNAVAILABLE) errorMessage = 'Информация о местоположении недоступна.'; else if (error.code === error.TIMEOUT) errorMessage = 'Время ожидания определения местоположения истекло.'; showNotification(errorMessage + ' Открытие навигатора только до точки.', 'warning', 'exclamation-triangle'); const yandexNaviUrlFallback = `https://yandex.ru/maps/?rtext=~${destinationLat},${destinationLon}&rtt=auto`; window.open(yandexNaviUrlFallback, '_blank'); }, { enableHighAccuracy: true, timeout: 10000, maximumAge: 0 } ); } else { hideLoader(); showNotification('Геолокация не поддерживается. Открытие навигатора только до точки.', 'error', 'times-circle'); const yandexNaviUrlNoGeo = `https://yandex.ru/maps/?rtext=~${destinationLat},${destinationLon}&rtt=auto`; window.open(yandexNaviUrlNoGeo, '_blank'); } });
});
</script>
</body>
</html>