<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Обработка изображений</title>
    <script src="/webfonts/pdf-lib.min.js"></script>
    <script src="/webfonts/FileSaver.min.js"></script>
    <link rel="icon" href="https://img.icons8.com/?size=100&id=NMU5Y3T2BsxR&format=png&color=000000" type="image/png">
    <script src="/webfonts/jszip.min.js"></script>

    <style>
      body {
        font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        margin: 0;
        padding: 20px;
        background-color: #f0f0f0;
        color: #333;
    }
    .container {
        max-width: 800px;
        margin: 0 auto;
        background-color: white;
        padding: 30px;
        border-radius: 10px;
        box-shadow: 0 0 20px rgba(0,0,0,0.1);
    }
    h1 {
        text-align: center;
        color: #2c3e50;
        margin-bottom: 30px;
    }
    #drop-area {
        border: 3px dashed #3498db;
        border-radius: 20px;
        width: 95%;
        margin: 20px auto;
        padding: 20px;
        text-align: center;
    }
    #drop-area.highlight {
        border-color: #2980b9;
        background-color: #ecf0f1;
    }
    #file-input {
        display: none;
    }
    .button {
        display: inline-block;
        padding: 10px 20px;
        background: #3498db;
        color: white;
        cursor: pointer;
        border-radius: 5px;
        border: none;
        font-size: 16px;
        margin: 10px;
    }
    #file-list {
        margin-top: 20px;
    }
    .file-item {
        background-color: #ecf0f1;
        padding: 10px;
        margin: 5px 0;
        border-radius: 5px;
        display: flex;
        justify-content: space-between;
        align-items: center;
    }
    .file-item button {
        background-color: #e74c3c;
        color: white;
        border: none;
        padding: 5px 10px;
        border-radius: 3px;
        cursor: pointer;
    }
    #settings {
        margin-top: 20px;
        padding: 20px;
        background-color: #ecf0f1;
        border-radius: 10px;
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 20px;
    }
    .setting-group {
        display: flex;
        flex-direction: column;
    }
    label {
        margin-bottom: 5px;
        color: #2c3e50;
    }
    select, input {
        width: 100%;
        padding: 10px;
        border: 1px solid #bdc3c7;
        border-radius: 5px;
        font-size: 16px;
    }
    .spinedit {
        display: flex;
        align-items: center;
        border: 1px solid #bdc3c7;
        border-radius: 5px;
        overflow: hidden;
    }
    .spinedit input {
        border: none;
        text-align: center;
        flex-grow: 1;
        padding: 10px 0;
        font-size: 16px;
    }
    .spinedit button {
        background-color: #ecf0f1;
        border: none;
        color: #2c3e50;
        cursor: pointer;
        font-size: 16px;
        padding: 10px;
    }
    #process-button, #merge-button, #contact-sheet-button {
        display: none;
        width: 100%;
        padding: 15px;
        color: white;
        border: none;
        border-radius: 5px;
        cursor: pointer;
        margin-top: 20px;
        font-size: 18px;
    }
    #process-button {
        background-color: #2ecc71;
    }
    #merge-button {
        background-color: #3498db;
    }
    #contact-sheet-button {
        background-color: #9b59b6;
    }
    #merge-dialog, #contact-sheet-dialog {
        display: none;
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background-color: white;
        padding: 20px;
        border-radius: 10px;
        box-shadow: 0 0 10px rgba(0,0,0,0.3);
        z-index: 1000;
    }
    #merge-dialog input, #contact-sheet-dialog input {
        width: 50px;
        margin-right: 10px;
    }
    #folder-input {
        display: none;
    }
    #folder-path {
        margin-top: 10px;
        font-style: italic;
    }
    #progress-container {
        margin-top: 20px;
        display: none;
    }
    #progress-bar {
        width: 100%;
        height: 20px;
        background-color: #f0f0f0;
        border-radius: 10px;
        overflow: hidden;
    }
    #progress {
        width: 0;
        height: 100%;
        background-color: #4CAF50;
        transition: width 0.3s;
    }
    #progress-text {
        margin-top: 10px;
        text-align: center;
    }
    #preview-image {
        max-width: 100%;
        max-height: 200px;
        margin-bottom: 10px;
    }

    /* Новые стили для диалогового окна контактного листа */
  #contact-sheet-dialog {
    background-color: #f8f9fa;
    border-radius: 10px;
    box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
    padding: 20px;
    width: 700px;
    max-width: 90vw;
    max-height: 90vh;
    overflow-y: auto;
}

.contact-sheet-title {
    color: #2c3e50;
    font-size: 24px;
    text-align: center;
    margin-bottom: 20px;
    border-bottom: 2px solid #3498db;
    padding-bottom: 10px;
}

.dialog-content {
    display: flex;
    justify-content: space-between;
}

.settings-column {
    width: 45%;
}

.preview-column {
    width: 50%;
}

#preview-canvas {
    width: 100%;
    height: auto;
    border: 1px solid #bdc3c7;
    border-radius: 4px;
}

.input-group {
    margin-bottom: 15px;
}

.input-group label {
    display: block;
    margin-bottom: 5px;
    color: #34495e;
}

.input-group input[type="number"],
.input-group select {
    width: 100%;
    padding: 8px;
    border: 1px solid #bdc3c7;
    border-radius: 4px;
    font-size: 14px;
}

.input-group.checkbox {
    display: flex;
    align-items: center;
}

.input-group.checkbox label {
    margin-left: 10px;
    margin-bottom: 0;
}

.button-group {
    display: flex;
    justify-content: space-between;
    margin-top: 20px;
}

.btn {
    padding: 10px 20px;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    font-size: 16px;
    transition: background-color 0.3s;
}

.btn-primary {
    background-color: #3498db;
    color: white;
}

.btn-primary:hover {
    background-color: #2980b9;
}

.btn-secondary {
    background-color: #ffb343;
    color: white;
}

.btn-secondary:hover {
    background-color: #db9a39;
}

#merge-dialog {
    display: none;
    position: fixed;
    left: 50%;
    top: 50%;
    transform: translate(-50%, -50%);
    background-color: white;
    padding: 30px;
    border-radius: 10px;
    box-shadow: 0 0 20px rgba(0,0,0,0.2);
    z-index: 1000;
    width: 300px;
    max-width: 90%;
    font-family: Arial, sans-serif;
}

#merge-dialog h3 {
    margin-top: 0;
    color: #333;
    text-align: center;
}

#merge-dialog p {
    margin-bottom: 20px;
    color: #666;
}

#merge-dialog .grid-size-container {
    margin-bottom: 20px;
}

#merge-dialog label {
    display: block;
    margin-bottom: 5px;
    color: #333;
}

#merge-dialog .grid-size-input {
    display: flex;
    align-items: center;
    border: 1px solid #ccc;
    border-radius: 5px;
}

#merge-dialog .grid-size-input button {
    padding: 10px 15px;
    background: none;
    border: none;
    cursor: pointer;
    font-size: 18px;
}

#merge-dialog #grid-size {
    flex-grow: 1;
    border: none;
    text-align: center;
    font-size: 16px;
    padding: 10px 0;
    -moz-appearance: textfield;
}

#merge-dialog #empty-cell-color {
    width: 100%;
    height: 40px;
    padding: 0;
    border: 1px solid #ccc;
    border-radius: 5px;
}

#merge-dialog .button-group {
    display: flex;
    justify-content: space-between;
    margin-top: 20px;
}

#merge-dialog .button-group button {
    padding: 10px 20px;
    color: white;
    border: none;
    border-radius: 5px;
    cursor: pointer;
}

#merge-dialog #merge-confirm {
    background-color: #4CAF50;
}

#merge-dialog #merge-cancel {
    background-color: #f44336;
}

      #mirror-button {
          display: none;
          width: 100%;
          padding: 15px;
          color: white;
          border: none;
          border-radius: 5px;
          cursor: pointer;
          margin-top: 20px;
          font-size: 18px;
          background-color: #e67e22;
      }
      
      .file-item {
    display: flex;
    align-items: center;
    gap: 10px;
    background-color: #ecf0f1;
    padding: 10px;
    margin: 5px 0;
    border-radius: 5px;
}

.file-item img {
    width: 50px;
    height: 50px;
    object-fit: cover;
    border-radius: 5px;
    cursor: pointer;
}

#preview-modal {
    display: none;
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.8);
    z-index: 1000;
    justify-content: center;
    align-items: center;
}

#modal-image {
    max-width: 90%;
    max-height: 90%;
}

#close-modal {
    position: absolute;
    top: 20px;
    right: 20px;
    background: #e74c3c;
    color: white;
    border: none;
    padding: 10px 20px;
    cursor: pointer;
}


      
    </style>
</head>
<body>
     <div class="container">
        <h1>Обработка изображений</h1>
        <div>
            <label class="button" for="folder-input">Выбрать каталог</label>
            <input type="file" id="folder-input" webkitdirectory directory multiple>
            <div id="folder-path"></div>
            
            <div id="preview-container" style="display: none; margin-top: 20px;">
    <img id="preview-image" src="" alt="Превью изображения" style="max-width: 100%; max-height: 200px;">
</div>
        </div>
        
        <div id="progress-container" style="display: none;">
            <div id="progress-bar"><div id="progress"></div></div>
            <div id="progress-text"></div>
        </div>
        
        <div id="drop-area">
            <form class="my-form">
                <p>Перетащите изображения сюда или выберите</p>
                <input type="file" id="file-input" multiple accept="image/*">
                <label class="button" for="file-input">Выбрать файлы</label>
            </form>
            <div id="file-list"></div>
        </div>
        <div id="settings">
            <div class="setting-group">
                <label for="output-format">Формат выходного файла:</label>
                <select id="output-format">
                    <option value="jpg">JPG</option>
                    <option value="pdf">Многостраничный PDF</option>
                </select>
            </div>
            <div class="setting-group">
                <label for="color-mode">Цветность:</label>
                <select id="color-mode">
                    <option value="bw">Черно-белое</option>
                    <option value="16">16 цветов</option>
                    <option value="256" selected>256 цветов</option>
                    <option value="original">Оригинальная цветность</option>
                </select>
            </div>
            <div class="setting-group">
                <label for="quality-input">Качество сжатия JPG (%):</label>
                <div class="spinedit">
                    <button class="spinedit-down">&#9664;</button>
                    <input type="number" id="quality-input" value="80" min="10" max="100" step="10" readonly>
                    <button class="spinedit-up">&#9654;</button>
                </div>
            </div>
            <div class="setting-group">
                <label for="size-input">Размер изображения (% от оригинала):</label>
                <div class="spinedit">
                    <button class="spinedit-down">&#9664;</button>
                    <input type="number" id="size-input" value="100" min="10" max="100" step="10" readonly>
                    <button class="spinedit-up">&#9654;</button>
                </div>
            </div>
        </div>
        <button id="process-button">Выполнить</button>
        <button id="merge-button">Склеить изображения</button>
        <button id="contact-sheet-button">Контактный лист</button>
        <button id="mirror-button">Отзеркалить</button>
    </div>
    
<div id="merge-dialog">
    <h3>Настройка склейки изображений</h3>
    <p>Количество изображений: <span id="image-count"></span></p>
    <div class="grid-size-container">
        <label for="grid-size">Размер сетки:</label>
        <div class="grid-size-input">
            <button id="decrease-grid">-</button>
            <input type="text" id="grid-size" readonly>
            <button id="increase-grid">+</button>
        </div>
    </div>
    <p>Итоговый размер: <span id="grid-dimensions"></span></p>
    <div>
        <label for="empty-cell-color">Цвет пустых ячеек:</label>
        <input type="color" id="empty-cell-color" value="#FFFFFF">
    </div>
    <div class="button-group">
        <button id="merge-confirm">Склеить</button>
        <button id="merge-cancel">Отмена</button>
    </div>
</div>

    <div id="contact-sheet-dialog">
        <h3 class="contact-sheet-title">Контактный лист</h3>
        <div class="dialog-content">
            <div class="settings-column">
                <div class="input-group">
                    <label for="image-width">Ширина изображения (см):</label>
                    <input type="number" id="image-width" min="0.1" step="0.1">
                </div>
                <div class="input-group">
                    <label for="image-height">Высота изображения (см):</label>
                    <input type="number" id="image-height" min="0.1" value="5" step="0.1">
                </div>
                <div class="input-group checkbox">
                    <input type="checkbox" id="keep-aspect-ratio" checked>
                    <label for="keep-aspect-ratio">Сохранять пропорции</label>
                </div>
                <div class="input-group">
                    <label for="page-orientation">Ориентация листа:</label>
                    <select id="page-orientation">
                        <option value="portrait">Книжная</option>
                        <option value="landscape">Альбомная</option>
                    </select>
                </div>
                <div class="button-group">
                    <button id="create-contact-sheet" class="btn btn-primary">Создать</button>
                    <button id="cancel-contact-sheet" class="btn btn-secondary">Отмена</button>
                </div>
            </div>
            <div class="preview-column">
                <canvas id="preview-canvas"></canvas>
            </div>
        </div>
    </div>
    

<!-- Модальное окно для увеличенного просмотра -->
<div id="preview-modal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.8); z-index: 1000; justify-content: center; align-items: center;">
    <img id="modal-image" src="" alt="Увеличенное изображение" style="max-width: 90%; max-height: 90%;">
    <button id="close-modal" style="position: absolute; top: 20px; right: 20px; background: #e74c3c; color: white; border: none; padding: 10px 20px; cursor: pointer;">Закрыть</button>
</div>
    
    
    
    <script>
        let dropArea = document.getElementById('drop-area');
    let fileInput = document.getElementById('file-input');
    let fileList = document.getElementById('file-list');
    let processButton = document.getElementById('process-button');
    let mergeButton = document.getElementById('merge-button');
    let contactSheetButton = document.getElementById('contact-sheet-button');
    let mergeDialog = document.getElementById('merge-dialog');
    let contactSheetDialog = document.getElementById('contact-sheet-dialog');

let originalFileNames = new Map();

    let files = [];
    let settings = {
        outputFormat: 'jpg',
        quality: 80,
        size: 100,
        colorMode: '256'
    };

    ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
        dropArea.addEventListener(eventName, preventDefaults, false);
    });

    let folderInput = document.getElementById('folder-input');
    let folderPath = document.getElementById('folder-path');

    folderInput.addEventListener('change', handleFolderSelect, false);

    let progressContainer = document.getElementById('progress-container');
    let progressBar = document.getElementById('progress');
    let progressText = document.getElementById('progress-text');

    function updateProgress(current, total, message) {
        let percent = (current / total) * 100;
        progressBar.style.width = percent + '%';
        progressText.textContent = message;
    }

 // Обновим handleFolderSelect для поддержки ZIP в папках
async function handleFolderSelect(event) {
    const files = event.target.files;
    if (files.length > 0) {
        const folderName = files[0].webkitRelativePath.split('/')[0] || 'UnnamedFolder';
        folderPath.textContent = `Выбранный каталог: ${folderName}`;
        
        const filesByFolder = {};
        for (let file of files) {
            if (file.name.endsWith('.zip')) {
                const extractedFiles = await extractImagesFromZip(file);
                const folder = file.name.replace('.zip', '');
                filesByFolder[folder] = extractedFiles;
            } else {
                const pathParts = file.webkitRelativePath.split('/');
                if (pathParts.length > 1) {
                    const folder = pathParts[1];
                    if (!filesByFolder[folder]) {
                        filesByFolder[folder] = [];
                    }
                    filesByFolder[folder].push(file);
                    originalFileNames.set(file, file.webkitRelativePath);
                }
            }
        }
        
        progressContainer.style.display = 'block';
        const totalFolders = Object.keys(filesByFolder).length;
        let processedFolders = 0;

        for (let folder in filesByFolder) {
            filesByFolder[folder].sort((a, b) => {
                const nameA = originalFileNames.get(a) || a.name;
                const nameB = originalFileNames.get(b) || b.name;
                return nameA.localeCompare(nameB);
            });
            
            updateProgress(processedFolders, totalFolders, `Обработка папки: ${folder}`);
            await processFolderImages(folder, filesByFolder[folder]);
            processedFolders++;
        }

        updateProgress(1, 1, 'Обработка завершена');
    }
}

async function processFolderImages(folderName, folderFiles) {
    const pdfDoc = await PDFLib.PDFDocument.create();
    
    const totalFiles = folderFiles.length;
    let processedFiles = 0;

    for (let file of folderFiles) {
        if (file.type.startsWith('image/')) {
            const displayName = originalFileNames.get(file) || file.name;
            updateProgress(processedFiles, totalFiles, `Обработка файла: ${displayName}`);
            const processedImage = await processImage(file, settings);
            const jpgImage = await pdfDoc.embedJpg(await processedImage.arrayBuffer());
            const page = pdfDoc.addPage([jpgImage.width, jpgImage.height]);
            page.drawImage(jpgImage, {
                x: 0,
                y: 0,
                width: jpgImage.width,
                height: jpgImage.height,
            });
            processedFiles++;
        }
    }
    
    const pdfBytes = await pdfDoc.save();
    const blob = new Blob([pdfBytes], { type: 'application/pdf' });
    saveAs(blob, `${folderName}.pdf`);
}

    function preventDefaults(e) {
        e.preventDefault();
        e.stopPropagation();
    }

    ['dragenter', 'dragover'].forEach(eventName => {
        dropArea.addEventListener(eventName, highlight, false);
    });

    ['dragleave', 'drop'].forEach(eventName => {
        dropArea.addEventListener(eventName, unhighlight, false);
    });

    function highlight(e) {
        dropArea.classList.add('highlight');
    }

    function unhighlight(e) {
        dropArea.classList.remove('highlight');
    }

    dropArea.addEventListener('drop', handleDrop, false);
    fileInput.addEventListener('change', handleFiles, false);

// Обновленная функция handleDrop
function handleDrop(e) {
    let dt = e.dataTransfer;
    let newFiles = dt.files;
    processFiles(newFiles);
}

// Обновленная функция handleFiles
function handleFiles(e) {
    processFiles(e.target.files);
}

// Новая функция для обработки файлов (включая ZIP)
async function processFiles(fileList) {
    let newFiles = [];
    
    for (let file of fileList) {
        if (file.type === 'application/zip' || file.name.endsWith('.zip')) {
            try {
                const zipFiles = await extractImagesFromZip(file);
                newFiles = newFiles.concat(zipFiles);
            } catch (error) {
                console.error('Ошибка при обработке ZIP:', error);
                alert('Ошибка при распаковке ZIP-файла');
            }
        } else if (file.type.startsWith('image/')) {
            newFiles.push(file);
            originalFileNames.set(file, file.name);
        }
    }
    
    files = [...files, ...newFiles];
    updateFileList();
}

// Новая функция для извлечения изображений из ZIP
async function extractImagesFromZip(zipFile) {
    const zip = new JSZip();
    const extractedFiles = [];
    
    try {
        const zipContent = await zip.loadAsync(zipFile);
        
        for (let filename in zipContent.files) {
            const file = zipContent.files[filename];
            if (!file.dir && isImageFile(filename)) {
                const blob = await file.async('blob');
                const newFile = new File([blob], filename.split('/').pop(), {
                    type: getImageMimeType(filename),
                    lastModified: Date.now()
                });
                extractedFiles.push(newFile);
                originalFileNames.set(newFile, filename); // Сохраняем полное имя с путем
            }
        }
    } catch (error) {
        throw error;
    }
    
    return extractedFiles;
}

// Вспомогательная функция для проверки, является ли файл изображением
function isImageFile(filename) {
    const imageExtensions = ['.jpg', '.jpeg', '.png', '.gif', '.bmp', '.webp'];
    return imageExtensions.some(ext => filename.toLowerCase().endsWith(ext));
}

// Вспомогательная функция для определения MIME-типа изображения
function getImageMimeType(filename) {
    const extension = filename.toLowerCase().split('.').pop();
    switch (extension) {
        case 'jpg':
        case 'jpeg':
            return 'image/jpeg';
        case 'png':
            return 'image/png';
        case 'gif':
            return 'image/gif';
        case 'bmp':
            return 'image/bmp';
        case 'webp':
            return 'image/webp';
        default:
            return 'image/jpeg';
    }
}



// Добавляем объявление переменной mirrorButton
let mirrorButton = document.getElementById('mirror-button');

// Функция для обновления списка файлов
function updateFileList() {
    fileList.innerHTML = '';
    files.forEach((file, index) => {
        let fileDiv = document.createElement('div');
        fileDiv.className = 'file-item';

        let img = document.createElement('img');
        img.src = URL.createObjectURL(file);
        img.alt = file.name;
        img.onclick = () => openModal(img.src);

        const displayName = originalFileNames.get(file) || file.name;
        
        fileDiv.innerHTML = `
            <span>${displayName}</span>
            <button onclick="removeFile(${index})">Удалить</button>
        `;
        fileDiv.prepend(img);
        fileList.appendChild(fileDiv);
    });

    processButton.style.display = files.length > 0 ? 'block' : 'none';
    mergeButton.style.display = files.length > 1 ? 'block' : 'none';
    contactSheetButton.style.display = files.length === 1 ? 'block' : 'none';
    mirrorButton.style.display = files.length === 1 ? 'block' : 'none';

    if (files.length > 2) {
        document.getElementById('grid-size').value = Math.ceil(Math.sqrt(files.length));
        updateDimensions();
    }

    if (files.length === 1) {
        showPreviewImage(files[0]);
    } else {
        document.getElementById('preview-container').style.display = 'none';
    }
}

// Функция для открытия модального окна
function openModal(imageSrc) {
    const modal = document.getElementById('preview-modal');
    const modalImage = document.getElementById('modal-image');
    modalImage.src = imageSrc;
    modal.style.display = 'flex';
}

// Функция для закрытия модального окна
function closeModal() {
    const modal = document.getElementById('preview-modal');
    modal.style.display = 'none';
}

// Закрытие модального окна при клике на кнопку
document.getElementById('close-modal').onclick = closeModal;

// Закрытие модального окна при клике вне изображения
document.getElementById('preview-modal').onclick = (e) => {
    if (e.target === document.getElementById('preview-modal')) {
        closeModal();
    }
};

function showPreviewImage(file) {
    let reader = new FileReader();
    reader.onload = function (e) {
        // Показываем контейнер с превью
        const previewContainer = document.getElementById('preview-container');
        previewContainer.style.display = 'block';

        // Устанавливаем src для изображения
        const previewImage = document.getElementById('preview-image');
        previewImage.src = e.target.result;
    };
    reader.readAsDataURL(file);
}

    function removeFile(index) {
        files.splice(index, 1);
        updateFileList();
    }

    document.getElementById('output-format').addEventListener('change', updateSettings);
    document.getElementById('color-mode').addEventListener('change', updateSettings);

    function updateSettings() {
        settings.outputFormat = document.getElementById('output-format').value;
        settings.quality = parseInt(document.getElementById('quality-input').value);
        settings.size = parseInt(document.getElementById('size-input').value);
        settings.colorMode = document.getElementById('color-mode').value;
    }

    function setupSpinedit(inputId, min, max, step) {
        const input = document.getElementById(inputId);
        const downButton = input.previousElementSibling;
        const upButton = input.nextElementSibling;

        function updateValue(delta) {
            let value = parseInt(input.value) + delta;
            value = Math.max(min, Math.min(max, value));
            input.value = value;
            updateSettings();
        }

        downButton.addEventListener('click', () => updateValue(-step));
        upButton.addEventListener('click', () => updateValue(step));
    }

    setupSpinedit('quality-input', 10, 100, 10);
    setupSpinedit('size-input', 10, 100, 10);

    async function processImage(file, settings) {
        return new Promise((resolve, reject) => {
            let img = new Image();
            img.onload = function() {
                let canvas = document.createElement('canvas');
                let ctx = canvas.getContext('2d');

                let scale = settings.size / 100;
                canvas.width = img.width * scale;
                canvas.height = img.height * scale;

                ctx.drawImage(img, 0, 0, canvas.width, canvas.height);

                // Применение настроек цветности
                if (settings.colorMode === 'bw') {
                    let imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                    for (let i = 0; i < imageData.data.length; i += 4) {
                        let avg = (imageData.data[i] + imageData.data[i + 1] + imageData.data[i + 2]) / 3;
                        imageData.data[i] = imageData.data[i + 1] = imageData.data[i + 2] = avg > 128 ? 255 : 0;
                    }
                    ctx.putImageData(imageData, 0, 0);
                } else if (settings.colorMode === '16' || settings.colorMode === '256') {
                    let numColors = settings.colorMode === '16' ? 16 : 256;
                    let imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                    for (let i = 0; i < imageData.data.length; i += 4) {
                        imageData.data[i] = Math.round(imageData.data[i] / 256 * numColors) / numColors * 256;
                        imageData.data[i + 1] = Math.round(imageData.data[i + 1] / 256 * numColors) / numColors * 256;
                        imageData.data[i + 2] = Math.round(imageData.data[i + 2] / 256 * numColors) / numColors * 256;
                    }
                    ctx.putImageData(imageData, 0, 0);
                }

                canvas.toBlob(resolve, 'image/jpeg', settings.quality / 100);
            };
            img.onerror = reject;
            img.src = URL.createObjectURL(file);
        });
    }

    processButton.onclick = async function() {
        let processedImages = [];
        for (let file of files) {
            let processedImage = await processImage(file, settings);
            processedImages.push({blob: processedImage, name: file.name});
        }
        
        if (settings.outputFormat === 'jpg') {
            processedImages.forEach((image, index) => {
                const filename = `processed_${image.name}`;
                saveAs(image.blob, filename);
            });
        } else if (settings.outputFormat === 'pdf') {
            const pdfDoc = await PDFLib.PDFDocument.create();
                    
            for (let image of processedImages) {
                const jpgImage = await pdfDoc.embedJpg(await image.blob.arrayBuffer());
                const imgWidth = jpgImage.width;
                const imgHeight = jpgImage.height;
                
                const page = pdfDoc.addPage([imgWidth, imgHeight]);
                
                page.drawImage(jpgImage, {
                    x: 0,
                    y: 0,
                    width: imgWidth,
                    height: imgHeight,
                });
            }
                    
            const pdfBytes = await pdfDoc.save();
            const blob = new Blob([pdfBytes], { type: 'application/pdf' });
            saveAs(blob, 'processed_images.pdf');
        }
    }

  mergeButton.onclick = showMergeDialog;

function showMergeDialog() {
    if (files.length < 2) {
        alert("Выберите как минимум два изображения для склейки.");
        return;
    }

    let suggestedSize = Math.ceil(Math.sqrt(files.length));
    
    document.getElementById('merge-dialog').style.display = 'block';
    document.getElementById('image-count').textContent = files.length;
    document.getElementById('grid-size').value = suggestedSize;

    updateDimensions();
}

function updateDimensions() {
    let size = parseInt(document.getElementById('grid-size').value);
    document.getElementById('grid-dimensions').textContent = `${size} x ${Math.ceil(files.length / size)}`;
}

document.getElementById('decrease-grid').addEventListener('click', () => updateGridSize(-1));
document.getElementById('increase-grid').addEventListener('click', () => updateGridSize(1));

function updateGridSize(delta) {
    let gridSizeInput = document.getElementById('grid-size');
    let newValue = parseInt(gridSizeInput.value) + delta;
    if (newValue >= 1 && newValue <= files.length) {
        gridSizeInput.value = newValue;
        updateDimensions();
    }
}

document.getElementById('merge-confirm').onclick = async function() {
    let gridSize = parseInt(document.getElementById('grid-size').value);
    let emptyColor = document.getElementById('empty-cell-color').value;
    await mergeImages(gridSize, emptyColor);
    document.getElementById('merge-dialog').style.display = 'none';
};

document.getElementById('merge-cancel').onclick = function() {
    document.getElementById('merge-dialog').style.display = 'none';
};

async function mergeImages(gridSize, emptyColor) {
    let images = await Promise.all(files.map(file => createImageBitmap(file)));

    let canvas = document.createElement('canvas');
    let ctx = canvas.getContext('2d');

    let maxWidth = Math.max(...images.map(img => img.width));
    let maxHeight = Math.max(...images.map(img => img.height));

    let columns = gridSize;
    let rows = Math.ceil(files.length / gridSize);

    canvas.width = maxWidth * columns;
    canvas.height = maxHeight * rows;

    // Заполняем canvas выбранным цветом
    ctx.fillStyle = emptyColor;
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // Функция для отрисовки изображения с растяжением до нужного размера
    function drawResizedImage(img, x, y, width, height) {
        ctx.drawImage(img, x, y, width, height);
    }

    images.forEach((img, index) => {
        let row = Math.floor(index / columns);
        let col = index % columns;
        drawResizedImage(img, maxWidth * col, maxHeight * row, maxWidth, maxHeight);
    });

    return new Promise(resolve => {
        canvas.toBlob(blob => {
            saveAs(blob, 'merged_grid.jpg');
            resolve();
        }, 'image/jpeg', 0.95);
    });
}

    // Код для контактного листа
    contactSheetButton.onclick = showContactSheetDialog;

    async function showContactSheetDialog() {
        contactSheetDialog.style.display = 'block';
        
        // Загрузка изображения для получения его размеров
        originalImage = await createImageBitmap(files[0]);
        originalAspectRatio = originalImage.width / originalImage.height;
        
        // Установка высоты 5 см и пропорциональной ширины
        document.getElementById('image-height').value = 5;
        document.getElementById('image-width').value = (5 * originalAspectRatio).toFixed(1);
        
        // Создание превью
        updatePreview();
    }

      function updatePreview() {
        let imageWidth = parseFloat(document.getElementById('image-width').value) * 37.795275591; // Convert cm to pixels (96 DPI)
        let imageHeight = parseFloat(document.getElementById('image-height').value) * 37.795275591;
        let orientation = document.getElementById('page-orientation').value;

        // A4 размеры в пикселях при 96 DPI
        let pageWidth = orientation === 'portrait' ? 794 : 1123;
        let pageHeight = orientation === 'portrait' ? 1123 : 794;

        let previewCanvas = document.getElementById('preview-canvas');
        let previewCtx = previewCanvas.getContext('2d');

        // Устанавливаем размеры canvas
        let scale = previewCanvas.offsetWidth / pageWidth;
        previewCanvas.width = pageWidth * scale;
        previewCanvas.height = pageHeight * scale;

        // Масштабируем контекст
        previewCtx.scale(scale, scale);

        // Заполняем canvas белым цветом
        previewCtx.fillStyle = 'white';
        previewCtx.fillRect(0, 0, pageWidth, pageHeight);

        let cols = Math.floor(pageWidth / imageWidth);
        let rows = Math.floor(pageHeight / imageHeight);

        for (let i = 0; i < rows; i++) {
            for (let j = 0; j < cols; j++) {
                let x = j * imageWidth;
                let y = i * imageHeight;
                previewCtx.drawImage(originalImage, x, y, imageWidth, imageHeight);
            }
        }

        // Сбрасываем масштаб
        previewCtx.setTransform(1, 0, 0, 1, 0, 0);
    }

    function updateImageDimensions(changedInput) {
        let keepAspectRatio = document.getElementById('keep-aspect-ratio').checked;
        if (keepAspectRatio) {
            if (changedInput === 'width') {
                let newWidth = parseFloat(document.getElementById('image-width').value);
                document.getElementById('image-height').value = (newWidth / originalAspectRatio).toFixed(1);
            } else {
                let newHeight = parseFloat(document.getElementById('image-height').value);
                document.getElementById('image-width').value = (newHeight * originalAspectRatio).toFixed(1);
            }
        }
        updatePreview();
    }

    document.getElementById('image-width').addEventListener('input', () => updateImageDimensions('width'));
    document.getElementById('image-height').addEventListener('input', () => updateImageDimensions('height'));
    document.getElementById('page-orientation').addEventListener('change', updatePreview);
    document.getElementById('keep-aspect-ratio').addEventListener('change', updatePreview);

    document.getElementById('create-contact-sheet').onclick = async function() {
        let imageWidth = parseFloat(document.getElementById('image-width').value) * 37.795275591; // Convert cm to pixels (96 DPI)
        let imageHeight = parseFloat(document.getElementById('image-height').value) * 37.795275591;
        let orientation = document.getElementById('page-orientation').value;

        await createContactSheet(imageWidth, imageHeight, orientation);
        contactSheetDialog.style.display = 'none';
    };

    document.getElementById('cancel-contact-sheet').onclick = function() {
        contactSheetDialog.style.display = 'none';
    };

    async function createContactSheet(imageWidth, imageHeight, orientation) {
        let img = await createImageBitmap(files[0]);

        let canvas = document.createElement('canvas');
        let ctx = canvas.getContext('2d');

        // A4 размеры в пикселях при 96 DPI
        let pageWidth = orientation === 'portrait' ? 794 : 1123;
        let pageHeight = orientation === 'portrait' ? 1123 : 794;

        canvas.width = pageWidth;
        canvas.height = pageHeight;

        // Заполняем canvas белым цветом
        ctx.fillStyle = 'white';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        let cols = Math.floor(pageWidth / imageWidth);
        let rows = Math.floor(pageHeight / imageHeight);

        let x = 0;
        let y = 0;

        for (let i = 0; i < rows; i++) {
            for (let j = 0; j < cols; j++) {
                ctx.drawImage(img, x, y, imageWidth, imageHeight);
                x += imageWidth;
            }
            x = 0;
            y += imageHeight;
        }

        return new Promise(resolve => {
            canvas.toBlob(blob => {
                saveAs(blob, 'contact_sheet.jpg');
                resolve();
            }, 'image/jpeg', 1.0); // Максимальное качество
        });
    }
    
           // Добавляем обработчик для кнопки "Отзеркалить"
        document.getElementById('mirror-button').onclick = async function() {
            if (files.length !== 1) return;

            let img = await createImageBitmap(files[0]);

            // Создаем два варианта отзеркаленных изображений
            await createMirroredImages(img);
        };

async function createMirroredImages(img) {
    let canvas = document.createElement('canvas');
    let ctx = canvas.getContext('2d');

    // Устанавливаем размер canvas для двух изображений
    canvas.width = img.width * 2; // Ширина canvas = ширина изображения * 2
    canvas.height = img.height;   // Высота canvas = высота изображения

    // Вариант 1: Оригинальное изображение слева, отзеркаленное справа
    ctx.drawImage(img, 0, 0); // Оригинальное изображение слева
    ctx.save(); // Сохраняем текущее состояние контекста
    ctx.translate(canvas.width, 0); // Перемещаем начало координат в правый верхний угол
    ctx.scale(-1, 1); // Отражаем по горизонтали
    ctx.drawImage(img, 0, 0); // Рисуем отзеркаленное изображение справа
    ctx.restore(); // Восстанавливаем состояние контекста

    // Сохраняем первый вариант
    canvas.toBlob(blob => {
        saveAs(blob, 'mirrored_right.jpg');
    }, 'image/jpeg', 0.95);

    // Вариант 2: Оригинальное изображение справа, отзеркаленное слева
    ctx.clearRect(0, 0, canvas.width, canvas.height); // Очищаем canvas
    ctx.save(); // Сохраняем текущее состояние контекста
    ctx.translate(0, 0); // Начинаем с левого верхнего угла
    ctx.scale(-1, 1); // Отражаем по горизонтали
    ctx.drawImage(img, -img.width, 0); // Рисуем отзеркаленное изображение слева
    ctx.restore(); // Восстанавливаем состояние контекста
    ctx.drawImage(img, img.width, 0); // Рисуем оригинальное изображение справа

    // Сохраняем второй вариант
    canvas.toBlob(blob => {
        saveAs(blob, 'mirrored_left.jpg');
    }, 'image/jpeg', 0.95);
}

    </script>
</body>
</html>