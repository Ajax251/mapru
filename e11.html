<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Актуальность XML</title>
    <link rel="stylesheet" href="webfonts/all.min.css">
    <script src="webfonts/jszip.min.js"></script>
    <script src="webfonts/proj4.js"></script>
    <link rel="icon" href="img/zu.png" type="image/png">
    <script src="sk.js"></script>
    <script src="msk.js"></script>
    <style>
        :root {
            --bg-gradient: linear-gradient(145deg, #ffffff 0%, #f0f7ff 50%, #e8f2ff 100%);
            --bg-primary: #f8fafc;
            --bg-secondary: #ffffff;
            --bg-tertiary: #f0f7ff;
            --bg-frost: rgba(255, 255, 255, 0.98);
            --text-primary: #0f172a;
            --text-secondary: #334155;
            --text-muted: #94a3b8;
            --accent-color: #2563eb;
            --accent-hover: #1d4ed8;
            --accent-light: #e0eaff;
            --accent-gradient: linear-gradient(135deg, #2563eb 0%, #3b82f6 100%);
            --border-color: #c7d9f1;
            --border-light: #a8c5e8;
            --shadow-soft: 0 2px 8px rgba(37, 99, 235, 0.06);
            --shadow-card: 0 4px 16px rgba(37, 99, 235, 0.08);
            --shadow-hover: 0 8px 24px rgba(37, 99, 235, 0.12);
            --color-xml: #2563eb;
            --color-egrn: #22c55e;
            --color-match: #22c55e;
            --color-mismatch: #ef4444;
            --danger-color: #ef4444;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            line-height: 1.6;
            margin: 0;
            padding: 0;
            background: var(--bg-gradient);
            background-attachment: fixed;
            color: var(--text-primary);
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            -webkit-font-smoothing: antialiased;
        }

        .container {
            width: 100%;
            max-width: 600px;
            padding: 20px;
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .input-section {
            background-color: var(--bg-secondary);
            padding: 15px;
            border-radius: 12px;
            box-shadow: var(--shadow-card);
            display: flex;
            flex-direction: column;
            gap: 10px;
            position: relative;
            border: 1px solid var(--border-color);
        }

        #cadastralInput {
            width: 100%;
            padding: 14px 18px;
            border: 1px solid var(--border-color);
            border-radius: 10px;
            box-sizing: border-box;
            font-size: 17px;
            text-align: center;
            transition: all 0.2s ease;
            background: var(--bg-tertiary);
        }

        #cadastralInput:focus {
            border-color: var(--accent-color);
            box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.15);
            outline: none;
            background: var(--bg-secondary);
        }

        #loadParcelBtn {
            padding: 12px 18px;
            background: var(--accent-gradient);
            color: white;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 600;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            box-shadow: var(--shadow-soft);
        }

        #loadParcelBtn:hover {
            box-shadow: var(--shadow-hover);
            transform: translateY(-1px);
        }
        
        #loadParcelBtn:disabled {
            background: linear-gradient(135deg, #94a3b8 0%, #cbd5e1 100%);
            cursor: not-allowed;
            transform: none;
        }

        .loader-common {
            text-align: center;
            padding: 10px;
            font-size: 16px;
            color: var(--accent-color);
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }
        
        .loader-common .loader-text {
            margin-bottom: 8px;
        }
        
        .loader-common i.fa-spinner {
            margin-left: 8px;
            display: inline-block;
        }
        
        .loader-common .progress-bar-container {
            width: 80%;
            margin: 10px auto 0;
            background-color: var(--bg-tertiary);
            border-radius: 6px;
            overflow: hidden;
            height: 10px;
            display: none;
            border: 1px solid var(--border-color);
        }
        
        .loader-common .progress-bar {
            width: 0%;
            height: 100%;
            background: var(--accent-gradient);
            transition: width 0.2s ease-out;
        }

        .error-messages-common {
            color: #b91c1c;
            padding: 12px 16px;
            background-color: #fef2f2;
            border: 1px solid #fecaca;
            border-radius: 10px;
            margin-top: 10px;
            font-weight: 500;
        }

        .results-parent-container {
            width: 100%;
            max-width: 1240px;
            padding: 0 20px;
            box-sizing: border-box;
            margin-top: 20px;
        }

        .results-container {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .info-section, .drawing-section {
            background-color: var(--bg-secondary);
            padding: 15px;
            border-radius: 12px;
            box-shadow: var(--shadow-card);
            border: 1px solid var(--border-color);
        }

        .info-section h2 {
            margin-top: 0;
            color: var(--accent-hover);
            font-size: 1.2em;
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 8px;
            margin-bottom: 15px;
            text-align: center;
        }

        .info-section h2.clickable-header {
            color: white;
            padding: 12px 18px;
            border-radius: 10px;
            font-size: 1.1em;
            cursor: pointer;
            transition: all 0.2s ease;
            border-bottom: none;
            box-shadow: var(--shadow-soft);
            display: block;
            text-align: center;
            margin-bottom: 15px;
            margin-top: 0;
        }

        #h2XMLHeader.clickable-header {
            background: linear-gradient(135deg, #2563eb 0%, #3b82f6 100%);
        }
        
        #h2XMLHeader.clickable-header:hover {
            box-shadow: var(--shadow-hover);
            transform: translateY(-1px);
        }

        #h2EGRNHeader.clickable-header {
            background: linear-gradient(135deg, #16a34a 0%, #22c55e 100%);
        }
        
        #h2EGRNHeader.clickable-header:hover {
            box-shadow: var(--shadow-hover);
            transform: translateY(-1px);
        }

        .drawing-section h2 {
            margin-top: 0;
            color: var(--accent-hover);
            font-size: 1.2em;
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 8px;
            margin-bottom: 15px;
            text-align: center;
        }

        #parcelCanvasXML, #parcelCanvasEGRN {
            width: 100%;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            display: block;
            background-color: var(--bg-tertiary);
        }
        
        .drawing-section {
            padding: 5px;
            position: relative;
        }

        .parcel-data-table table {
            width: 100%;
            border-collapse: separate;
            border-spacing: 0;
            font-size: 0.9em;
            border-radius: 8px;
            overflow: hidden;
            border: 1px solid var(--border-color);
        }
        
        .parcel-data-table th, .parcel-data-table td {
            border-bottom: 1px solid var(--border-color);
            padding: 10px 12px;
            text-align: left;
            word-break: break-word;
        }
        
        .parcel-data-table tr:last-child th,
        .parcel-data-table tr:last-child td {
            border-bottom: none;
        }
        
        .parcel-data-table th {
            background-color: var(--bg-tertiary);
            font-weight: 600;
            width: 40%;
            color: var(--text-secondary);
        }
        
        .parcel-data-table tr.area-same {
            background-color: #dcfce7 !important;
        }
        
        .parcel-data-table tr.area-different {
            background-color: #fef2f2 !important;
        }

        .parcel-data-table tr.accuracy-good-row {
            background-color: #dcfce7 !important;
        }

        .parcel-data-table tr.accuracy-bad-row {
            background-color: #fef2f2 !important;
        }

        .parcel-data-table tr.points-same {
            background-color: #dcfce7 !important;
        }
        
        .parcel-data-table tr.points-different {
            background-color: #fef2f2 !important;
        }

        .export-section {
            display: flex;
            justify-content: space-around;
            padding: 15px;
            background-color: var(--bg-secondary);
            border-radius: 12px;
            box-shadow: var(--shadow-card);
            margin-top: 15px;
            border: 1px solid var(--border-color);
        }

        .export-section button {
            color: white;
            border: none;
            border-radius: 50%;
            width: 48px;
            height: 48px;
            font-size: 18px;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: var(--shadow-soft);
        }
        
        .export-section button:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: var(--shadow-hover);
        }
        
        .export-section button:disabled {
            background-color: #cbd5e1 !important;
            color: #94a3b8 !important;
            cursor: not-allowed;
            transform: none;
        }

        .toggle-container {
            position: absolute;
            top: 10px;
            right: 10px;
            z-index: 10;
        }
        
        .toggle-container .toggle {
            display: none;
        }
        
        .toggle-container .toggle + label {
            display: inline-block;
            width: 44px;
            height: 24px;
            background-color: #cbd5e1;
            border-radius: 24px;
            position: relative;
            cursor: pointer;
            transition: all 0.3s ease;
            border: 1px solid var(--border-color);
        }
        
        .toggle-container .toggle + label:after {
            content: '';
            display: inline-block;
            position: absolute;
            width: 18px;
            height: 18px;
            background-color: #fff;
            top: 2px;
            left: 3px;
            border-radius: 50%;
            transition: all 0.3s ease;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
        
        .toggle-container .toggle:checked + label {
            background: var(--accent-gradient);
            border-color: var(--accent-color);
        }
        
        .toggle-container .toggle:checked + label:after {
            left: 22px;
        }

        #outdatedDataNotification {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: #fef3c7;
            color: #92400e;
            padding: 24px 32px;
            border-radius: 16px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.2);
            z-index: 1000;
            text-align: center;
            font-size: 1.1em;
            font-weight: 600;
            border: 1px solid #f59e0b;
        }
        
        #outdatedDataNotification i {
            margin-right: 12px;
            color: #dc2626;
        }

        #comparisonSection {
            margin-top: 15px;
        }
        
        .comparison-toggle-btn {
            width: 100%;
            padding: 14px 18px;
            border-radius: 10px;
            border: none;
            color: white;
            font-weight: 600;
            font-size: 15px;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            box-shadow: var(--shadow-soft);
        }
        
        .comparison-toggle-btn.success { 
            background: linear-gradient(135deg, #16a34a 0%, #22c55e 100%); 
        }
        
        .comparison-toggle-btn.failure { 
            background: linear-gradient(135deg, #dc2626 0%, #ef4444 100%); 
        }
        
        .comparison-toggle-btn:hover { 
            box-shadow: var(--shadow-hover);
            transform: translateY(-1px);
        }

        /* ===== МОДАЛЬНОЕ ОКНО СРАВНЕНИЯ ===== */
        .modal-overlay {
            position: fixed;
            inset: 0;
            background: rgba(15, 23, 42, 0.5);
            backdrop-filter: blur(6px);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 2000;
            padding: 20px;
        }

        .modal-overlay.active {
            display: flex;
        }

        .modal-content {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 16px;
            width: 100%;
            max-width: 900px;
            max-height: 90vh;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            box-shadow: 0 25px 50px rgba(15, 23, 42, 0.25);
        }

        .modal-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 16px 24px;
            border-bottom: 1px solid var(--border-color);
            background: var(--bg-tertiary);
            flex-shrink: 0;
        }

        .modal-header h2 {
            font-size: 18px;
            font-weight: 700;
            display: flex;
            align-items: center;
            gap: 12px;
            color: var(--text-primary);
            margin: 0;
        }

        .modal-header h2 i {
            color: var(--accent-color);
        }

        .modal-header-status {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 6px 14px;
            border-radius: 20px;
            font-size: 13px;
            font-weight: 600;
        }

        .modal-header-status.match {
            background: #dcfce7;
            color: #166534;
        }

        .modal-header-status.mismatch {
            background: #fef2f2;
            color: #991b1b;
        }

        .modal-close {
            width: 36px;
            height: 36px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 10px;
            color: var(--text-secondary);
            cursor: pointer;
            font-size: 16px;
            transition: all 0.2s ease;
        }

        .modal-close:hover {
            background: var(--danger-color);
            color: white;
            border-color: var(--danger-color);
        }

        /* ИСПРАВЛЕНИЕ 1: Скролл для modal-body */
        .modal-body {
            padding: 24px;
            overflow-y: auto;
            flex: 1;
            min-height: 0; /* Важно для flex контейнера */
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .comparison-canvas-section {
            background: var(--bg-tertiary);
            border-radius: 12px;
            padding: 16px;
            border: 1px solid var(--border-color);
            flex-shrink: 0; /* Не сжимается */
        }

        .comparison-canvas-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 12px;
            flex-wrap: wrap;
            gap: 10px;
        }

        .comparison-canvas-title {
            font-weight: 600;
            color: var(--text-primary);
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .comparison-legend {
            display: flex;
            gap: 16px;
            font-size: 13px;
            flex-wrap: wrap;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .legend-color {
            width: 16px;
            height: 4px;
            border-radius: 2px;
        }

        .legend-color.xml { background: var(--color-xml); }
        .legend-color.egrn { background: var(--color-egrn); }

        .legend-marker {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            border: 2px solid;
        }

        .legend-marker.match { 
            border-color: var(--color-match); 
            background: rgba(34, 197, 94, 0.2);
        }

        .legend-marker.mismatch { 
            border-color: var(--color-mismatch); 
            background: rgba(239, 68, 68, 0.2);
        }

        #comparisonCanvas {
            width: 100%;
            border-radius: 8px;
            background: white;
            border: 1px solid var(--border-color);
            display: block;
        }

        .comparison-table-section {
            background: var(--bg-secondary);
            border-radius: 12px;
            border: 1px solid var(--border-color);
            overflow: hidden;
            flex-shrink: 0; /* Не сжимается */
            display: flex;
            flex-direction: column;
            min-height: 200px; /* Минимальная высота */
            max-height: 350px; /* Максимальная высота */
        }

        .comparison-table-header {
            padding: 14px 18px;
            background: var(--bg-tertiary);
            border-bottom: 1px solid var(--border-color);
            font-weight: 600;
            color: var(--text-primary);
            display: flex;
            align-items: center;
            gap: 8px;
            flex-shrink: 0;
        }

        .comparison-table-wrapper {
            flex: 1;
            overflow-y: auto;
            min-height: 0; /* Важно для скролла */
        }

        .comparison-table {
            width: 100%;
            border-collapse: collapse;
        }

        .comparison-table th {
            position: sticky;
            top: 0;
            background: var(--accent-gradient);
            color: white;
            padding: 12px 16px;
            text-align: center;
            font-weight: 600;
            font-size: 13px;
            z-index: 1;
        }

        .comparison-table td {
            padding: 10px 16px;
            text-align: center;
            border-bottom: 1px solid var(--border-color);
            font-size: 13px;
            font-family: 'SF Mono', 'Monaco', 'Consolas', monospace;
        }

        .comparison-table tbody tr:last-child td {
            border-bottom: none;
        }

        .comparison-table .match-row {
            background-color: #f0fdf4;
        }

        .comparison-table .mismatch-row {
            background-color: #fef2f2;
        }

        .comparison-table .match-row td:first-child {
            border-left: 3px solid var(--color-match);
        }

        .comparison-table .mismatch-row td:first-child {
            border-left: 3px solid var(--color-mismatch);
        }

        .construction-info {
            padding: 16px;
            background: #fef3c7;
            border: 1px solid #fbbf24;
            border-radius: 10px;
            color: #92400e;
            font-size: 14px;
            display: flex;
            align-items: flex-start;
            gap: 12px;
            flex-shrink: 0;
        }

        .construction-info i {
            font-size: 18px;
            margin-top: 2px;
        }

        @media (min-width: 769px) {
            .container {
                max-width: 800px;
            }
            .results-container {
                display: grid;
                grid-template-columns: 1fr 1fr;
                grid-template-rows: auto auto;
                grid-template-areas:
                    "xmlInfo egrnInfo"
                    "xmlDrawing egrnDrawing";
                gap: 20px;
            }
            #parcelInfoSectionXML { grid-area: xmlInfo; }
            #parcelInfoSectionEGRN { grid-area: egrnInfo; }
            #drawingSectionXML { grid-area: xmlDrawing; }
            #drawingSectionEGRN { grid-area: egrnDrawing; }
            .export-section {
                max-width: 600px;
                margin: 20px auto;
            }
        }
        
             .modal-header-status.warning {
            background: #fef3c7;
            color: #92400e;
        }
        
        .legend-marker.warning {
            border-color: #f59e0b;
            background: rgba(245, 158, 11, 0.25);
        }
        
        .comparison-table .warning-row {
            background-color: #fffbeb;
        }
        
        .comparison-table .warning-row td:first-child {
            border-left: 3px solid #f59e0b;
        }
        
        /* ===== МОДАЛЬНОЕ ОКНО ВЫБОРА МСК ===== */
        #mskSelectionModal .modal-content {
            max-width: 500px;
        }

        .msk-list {
            display: flex;
            flex-direction: column;
            gap: 10px;
            max-height: 400px;
            overflow-y: auto;
            padding-right: 5px;
        }

        .msk-list-item {
            padding: 12px 16px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
            font-size: 14px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .msk-list-item:hover {
            background: var(--accent-light);
            border-color: var(--accent-color);
            transform: translateX(2px);
        }

        .msk-list-item i {
            color: var(--accent-color);
        }

        .msk-region-title {
            font-size: 14px;
            color: var(--text-muted);
            margin-bottom: 10px;
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 5px;
        }

        @media (max-width: 768px) {
            .modal-content {
                max-height: 95vh;
            }
            .modal-body {
                padding: 16px;
            }
            .comparison-legend {
                flex-wrap: wrap;
                gap: 8px;
            }
            .modal-header {
                flex-wrap: wrap;
                gap: 12px;
            }
            .comparison-table-section {
                max-height: 250px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="input-section">
            <input type="text" id="cadastralInput" placeholder="Кадастровый номер">
            <button id="loadParcelBtn"><i class="fas fa-search"></i> Загрузить</button>
        </div>
        <div id="loaderXML" class="loader-common">
            <span class="loader-text">Загрузка XML...</span> <i class="fas fa-spinner fa-spin"></i>
            <div class="progress-bar-container">
                <div class="progress-bar"></div>
            </div>
        </div>
        <div id="errorMessagesXML" class="error-messages-common" style="display:none;"></div>
    </div>

    <div class="results-parent-container">
        <div class="results-container" style="display:none;">
            <div id="parcelInfoSectionXML" class="info-section" style="display:none;">
                <h2 id="h2XMLHeader">XML КПТ</h2>
                <div id="parcelDataTableXML" class="parcel-data-table"></div>
                <div id="comparisonSection" style="display:none;">
                    <button id="comparisonToggleBtn" class="comparison-toggle-btn"></button>
                </div>
            </div>

            <div id="parcelInfoSectionEGRN" class="info-section" style="display:none;">
                <h2 id="h2EGRNHeader">ЕГРН</h2>
                <div id="loaderEGRN" class="loader-common" style="padding: 5px 0;">
                    <span class="loader-text"></span><i class="fas fa-spinner fa-spin"></i>
                </div>
                <div id="errorMessagesEGRN" class="error-messages-common" style="display:none;"></div>
                <div id="parcelDataTableEGRN" class="parcel-data-table"></div>
            </div>

            <div id="drawingSectionXML" class="drawing-section" style="display:none;">
                <div class="toggle-container toggle-container-xml">
                    <input type="checkbox" id="distanceToggleXML" class="toggle">
                    <label for="distanceToggleXML" title="Показать/скрыть длины линий и площадь/периметр (XML)"></label>
                </div>
                <canvas id="parcelCanvasXML"></canvas>
            </div>

            <div id="drawingSectionEGRN" class="drawing-section" style="display:none;">
                <div class="toggle-container toggle-container-egrn">
                    <input type="checkbox" id="distanceToggleEGRN" class="toggle">
                    <label for="distanceToggleEGRN" title="Показать/скрыть длины линий и площадь/периметр (ЕГРН)"></label>
                </div>
                <canvas id="parcelCanvasEGRN"></canvas>
            </div>
        </div>

        <div id="exportSectionXML" class="export-section" style="display:none;">
            <button id="generateSchemaBtn" title="Схема"><i class="fas fa-sitemap"></i></button>
            <button id="exportMifBtn" title="Экспорт в MIF (из XML)" disabled><i class="fas fa-file-invoice"></i></button>
            <button id="exportDxfBtn" title="Экспорт в DXF (из XML)" disabled><i class="fas fa-drafting-compass"></i></button>
            <button id="exportTxtBtn" title="Экспорт в TXT (из XML)" disabled><i class="fas fa-file-alt"></i></button>
        </div>
    </div>

    <div id="outdatedDataNotification">
        <i class="fas fa-exclamation-triangle"></i>Данные в XML не актуальны
    </div>

    <!-- МОДАЛЬНОЕ ОКНО СРАВНЕНИЯ -->
    <div id="comparisonModal" class="modal-overlay">
        <div class="modal-content">
            <div class="modal-header">
                <h2><i class="fas fa-layer-group"></i> Сравнение координат</h2>
                <div id="modalStatusBadge" class="modal-header-status match">
                    <i class="fas fa-check-circle"></i>
                    <span>Совпадают</span>
                </div>
                <button class="modal-close" id="closeComparisonModal"><i class="fas fa-times"></i></button>
            </div>
            <div class="modal-body">
                <div id="constructionInfoBlock" class="construction-info" style="display:none;">
                    <i class="fas fa-info-circle"></i>
                    <div>
                        <strong>Сооружение:</strong> Проверяется вхождение точек XML внутрь полигона ЕГРН (с допуском 2 см на границе). 
                        Зелёные точки — внутри полигона или на границе, красные — за пределами.
                    </div>
                </div>
                
                <div class="comparison-canvas-section">
                    <div class="comparison-canvas-header">
                        <div class="comparison-canvas-title">
                            <i class="fas fa-draw-polygon"></i>
                            Наложение контуров
                        </div>
                        <div class="comparison-legend">
                            <div class="legend-item">
                                <div class="legend-color xml"></div>
                                <span>XML</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color egrn"></div>
                                <span>ЕГРН</span>
                            </div>
                            
                            <div class="legend-item">
                                <div class="legend-marker match"></div>
                                <span>Совпадает</span>
                            </div>
                            
                                <div class="legend-item">
    <div class="legend-marker warning"></div>
    <span>Другой порядок</span>
</div>

                            <div class="legend-item">
                                <div class="legend-marker mismatch"></div>
                                <span>Расхождение</span>
                            </div>
                        
                        </div>
                    </div>
                    <canvas id="comparisonCanvas"></canvas>
                </div>

                <div class="comparison-table-section">
                    <div class="comparison-table-header">
                        <i class="fas fa-table"></i>
                        Таблица сравнения точек
                    </div>
                    <div class="comparison-table-wrapper">
                        <table class="comparison-table">
                            <thead>
                                <tr>
                                    <th>№</th>
                                    <th>XML (X, Y)</th>
                                    <th>ЕГРН (X, Y)</th>
                                    <th>Δ, м</th>
                                </tr>
                            </thead>
                            <tbody id="comparisonTableBody"></tbody>
                        </table>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
      <div id="mskSelectionModal" class="modal-overlay">
        <div class="modal-content">
            <div class="modal-header">
                <h2><i class="fas fa-globe"></i> Выбор системы координат</h2>
                <button class="modal-close" id="closeMskModal"><i class="fas fa-times"></i></button>
            </div>
            <div class="modal-body">
                <div class="msk-region-title">Не удалось определить зону автоматически. Выберите подходящую МСК для региона <span id="mskRegionDisplay"></span>:</div>
                <div id="mskListContainer" class="msk-list">
                    <!-- Список генерируется через JS -->
                </div>
            </div>
        </div>
    </div>

    <script src="cb.js"></script>
    <script>
        let currentParcelDataXML = null;
        let currentParcelContoursXML = null;
        let convertedEgrnContours = null;
        let kptDate = '';
        let kptRegNum = '';
        let currentEgrnFeature = null;
        let currentRecordType = 'land';

        let showDistanceLabelsXML = false;
        let showDistanceLabelsEGRN = false;

        let areaXMLValue = null;
        let areaEGRNValue = null;
        let xmlTotalPointCount = null;
        let egrnTotalPointCount = null;
        let xmlIsDeclared = false;
        let egrnIsDeclared = false;
        
        let lastComparisonResult = null;
        let selectedMskSystem = null;

        const STORAGE_API_URL = 'https://mapruapp.ru/storage';
        const BUCKET_NAME = 'kpt';

        const cadastralInput = document.getElementById('cadastralInput');
        const loadParcelBtn = document.getElementById('loadParcelBtn');
        const loaderXMLDiv = document.getElementById('loaderXML');
        const loaderXMLTextSpan = loaderXMLDiv.querySelector('.loader-text');
        const progressBarContainerXML = loaderXMLDiv.querySelector('.progress-bar-container');
        const progressBarXML = loaderXMLDiv.querySelector('.progress-bar');
        const spinnerIconXML = loaderXMLDiv.querySelector('.fa-spinner');
        const errorMessagesXMLDiv = document.getElementById('errorMessagesXML');

        const drawingSectionXMLDiv = document.getElementById('drawingSectionXML');
        const parcelCanvasXML = document.getElementById('parcelCanvasXML');
        const distanceToggleXML = document.getElementById('distanceToggleXML');
        const parcelInfoSectionXMLDiv = document.getElementById('parcelInfoSectionXML');
        const parcelDataTableXMLDiv = document.getElementById('parcelDataTableXML');

        const exportSectionXMLDiv = document.getElementById('exportSectionXML');
        const generateSchemaBtn = document.getElementById('generateSchemaBtn');
        const exportMifBtn = document.getElementById('exportMifBtn');
        const exportDxfBtn = document.getElementById('exportDxfBtn');
        const exportTxtBtn = document.getElementById('exportTxtBtn');

        const loaderEGRNDiv = document.getElementById('loaderEGRN');
        const loaderEGRNTextSpan = loaderEGRNDiv.querySelector('.loader-text');
        const errorMessagesEGRNDiv = document.getElementById('errorMessagesEGRN');
        const drawingSectionEGRNDiv = document.getElementById('drawingSectionEGRN');
        const parcelCanvasEGRN = document.getElementById('parcelCanvasEGRN');
        const distanceToggleEGRN = document.getElementById('distanceToggleEGRN');
        const parcelInfoSectionEGRNDiv = document.getElementById('parcelInfoSectionEGRN');
        const parcelDataTableEGRNDiv = document.getElementById('parcelDataTableEGRN');
        const comparisonSectionDiv = document.getElementById('comparisonSection');

        const resultsContainerDiv = document.querySelector('.results-container');
        const outdatedDataNotificationDiv = document.getElementById('outdatedDataNotification');
        
        const comparisonModal = document.getElementById('comparisonModal');
        const closeComparisonModalBtn = document.getElementById('closeComparisonModal');
        const comparisonCanvas = document.getElementById('comparisonCanvas');
        const comparisonTableBody = document.getElementById('comparisonTableBody');
        const modalStatusBadge = document.getElementById('modalStatusBadge');
        const constructionInfoBlock = document.getElementById('constructionInfoBlock');
        
        const sevenDigitsRegions = ['06', '07', '09', '10', '11', '12', '13', '14', '17', '23','24', '27', '31', '32', '35', '36', '41', '42', '47', '48','50', '52', '53', '56', '57', '58', '59', '60', '61', '62','63', '64', '65', '66', '67', '69', '70', '71', '72', '74','77', '78', '79', '91'];

        if (typeof proj4 === 'undefined' || typeof COORDINATE_SYSTEMS === 'undefined' || typeof MskFinder === 'undefined') {
            console.error("Proj4, sk.js, or msk.js library not loaded.");
            showError("Ошибка загрузки библиотек. Функционал сравнения координат ЕГРН может быть ограничен.", 'egrn');
        }

        loadParcelBtn.addEventListener('click', handleLoadParcel);
        cadastralInput.addEventListener('input', () => { formatCadastralNumber(cadastralInput); });
        cadastralInput.addEventListener('keypress', (e) => { if (e.key === 'Enter') handleLoadParcel(); });

        distanceToggleXML.addEventListener('change', () => {
            showDistanceLabelsXML = distanceToggleXML.checked;
            localStorage.setItem('showDistanceLabelsXML', String(showDistanceLabelsXML));
            if (currentParcelContoursXML && currentParcelContoursXML.length > 0) {
                drawParcelOnCanvasXML(currentParcelContoursXML);
            }
        });

        distanceToggleEGRN.addEventListener('change', () => {
            showDistanceLabelsEGRN = distanceToggleEGRN.checked;
            localStorage.setItem('showDistanceLabelsEGRN', String(showDistanceLabelsEGRN));
            if (currentEgrnFeature && currentEgrnFeature.geometry) {
                drawEgrnParcelOnCanvas();
            }
        });

        showDistanceLabelsXML = localStorage.getItem('showDistanceLabelsXML') === 'true';
        distanceToggleXML.checked = showDistanceLabelsXML;
        showDistanceLabelsEGRN = localStorage.getItem('showDistanceLabelsEGRN') === 'true';
        distanceToggleEGRN.checked = showDistanceLabelsEGRN;
        
        closeComparisonModalBtn.addEventListener('click', () => {
            comparisonModal.classList.remove('active');
        });
        
        comparisonModal.addEventListener('click', (e) => {
            if (e.target === comparisonModal) {
                comparisonModal.classList.remove('active');
            }
        });

        function getRandomColor() {
            const letters = '0123456789ABCDEF';
            let color = '#';
            for (let i = 0; i < 6; i++) color += letters[Math.floor(Math.random() * 16)];
            return color;
        }

        function getContrastYIQ(hexcolor) {
            hexcolor = hexcolor.replace('#', '');
            const r = parseInt(hexcolor.substr(0, 2), 16);
            const g = parseInt(hexcolor.substr(2, 2), 16);
            const b = parseInt(hexcolor.substr(4, 2), 16);
            const yiq = ((r * 299) + (g * 587) + (b * 114)) / 1000;
            return (yiq >= 128) ? 'black' : 'white';
        }

        function setRandomExportButtonColors() {
            [generateSchemaBtn, exportMifBtn, exportDxfBtn, exportTxtBtn].forEach(button => {
                const randomColor = getRandomColor();
                button.style.backgroundColor = randomColor;
                button.style.color = getContrastYIQ(randomColor);
            });
        }
        setRandomExportButtonColors();

        function drawRotatedText(ctx, text, x1, y1, x2, y2, font, color, yOffset = -3) {
            ctx.save();
            ctx.translate((x1 + x2) / 2, (y1 + y2) / 2);
            let angle = Math.atan2(y2 - y1, x2 - x1);
            if (angle < -Math.PI / 2 || angle > Math.PI / 2) {
                angle += Math.PI;
            }
            ctx.rotate(angle);
            ctx.fillStyle = color;
            ctx.font = font;
            ctx.textAlign = 'center';
            ctx.fillText(text, 0, yOffset);
            ctx.restore();
        }

        function makeHeaderClickable(headerElement, urlToOpen, descriptiveText) {
            if (!headerElement) return;
            headerElement.classList.add('clickable-header');
            headerElement.setAttribute('title', `Нажмите, чтобы скопировать КН и открыть ${descriptiveText} в новой вкладке`);
            if (headerElement._clickHandler) {
                headerElement.removeEventListener('click', headerElement._clickHandler);
            }
            headerElement._clickHandler = async function() {
                const cadNumber = cadastralInput.value.trim();
                if (cadNumber) {
                    try {
                        await navigator.clipboard.writeText(cadNumber);
                    } catch (err) {
                        console.error('Не удалось скопировать кадастровый номер:', err);
                    }
                }
                window.open(urlToOpen, '_blank');
            };
            headerElement.addEventListener('click', headerElement._clickHandler);
        }

        function resetButtonHeader(headerElement) {
            if (!headerElement) return;
            headerElement.classList.remove('clickable-header');
            headerElement.removeAttribute('title');
            if (headerElement._initialTextContent) {
                headerElement.textContent = headerElement._initialTextContent;
            }
            if (headerElement._clickHandler) {
                headerElement.removeEventListener('click', headerElement._clickHandler);
                delete headerElement._clickHandler;
            }
        }

async function handleLoadParcel() {
            const fullCadNumber = cadastralInput.value.trim();
            if (!isValidCadastralNumber(fullCadNumber)) {
                showError("Неверный формат кадастрового номера. Ожидается XX:XX:XXXXXX(X):YY", 'xml');
                return;
            }
            const parts = fullCadNumber.split(':');
            const quarterNumber = parts.slice(0, 3).join(':');
            resetUI();
            resultsContainerDiv.style.display = 'grid';

            const xmlProcessingPromise = async () => {
                showLoaderXML(true, null, 0);
                parcelInfoSectionXMLDiv.style.display = 'block';
                try {
                    // ИЗМЕНЕНИЕ: Получаем не только контент, но и флаг типа файла
                    const { fileContent, kptFileName, isJson } = await fetchAndProcessKPT(quarterNumber, fullCadNumber);
                    
                    showLoaderXML(true, isJson ? "Обработка JSON..." : "Обработка XML...", 95);
                    
                    let resultData;
                    if (isJson) {
                        // ИЗМЕНЕНИЕ: Обработка JSON
                        resultData = processJSONData(fileContent, fullCadNumber, kptFileName);
                        // Меняем заголовок, чтобы было понятно, что данные из JSON
                        document.getElementById('h2XMLHeader').textContent = "Данные из JSON (только координаты)";
                    } else {
                        // Стандартная обработка XML
                        resultData = await processXMLData(fileContent, fullCadNumber, kptFileName);
                        document.getElementById('h2XMLHeader').textContent = "XML КПТ";
                    }

                    const { parcelData, parcelContours } = resultData;
                    
                    currentParcelDataXML = parcelData;
                    displayParcelInfoTableXML(currentParcelDataXML);
                    
                    if (currentParcelDataXML) {
                        makeHeaderClickable(document.querySelector('#h2XMLHeader'), 'схема_xml.html', 'схему');
                    }
                    
                    if (currentParcelContoursXML && currentParcelContoursXML.length > 0 && currentParcelContoursXML.some(c => c.length > 0)) {
                        drawingSectionXMLDiv.style.display = 'block';
                        drawParcelOnCanvasXML(currentParcelContoursXML);
                        setExportButtonsState(true);
                        exportSectionXMLDiv.style.display = 'flex';
                    } else {
                        drawingSectionXMLDiv.style.display = 'none';
                        setExportButtonsState(false);
                        exportSectionXMLDiv.style.display = 'none';
                        if (currentParcelDataXML) {
                            showError(`Координаты для участка ${fullCadNumber} не найдены или пусты в файле`, 'xml');
                        }
                    }
                    showLoaderXML(true, ``, 100);
                    await new Promise(resolve => setTimeout(resolve, 500));
                    return { success: true };
                } catch (error) {
                    console.error("Error in File processing:", error);
                    showError(error.message || "Произошла ошибка при загрузке данных", 'xml');
                    setExportButtonsState(false);
                    exportSectionXMLDiv.style.display = 'none';
                    drawingSectionXMLDiv.style.display = 'none';
                    displayParcelInfoTableXML(null);
                    return { success: false, error };
                } finally {
                    showLoaderXML(false);
                }
            };

            const egrnProcessingPromise = async () => {
                showLoaderEGRN(true, '');
                parcelInfoSectionEGRNDiv.style.display = 'block';
                try {
                    await fetchAndProcessEGRN(fullCadNumber);
                    if (currentEgrnFeature) {
                        makeHeaderClickable(document.querySelector('#h2EGRNHeader'), 'egrn.html', 'данные ЕГРН');
                    }
                    return { success: true };
                } catch (error) {
                    console.error("Error in EGRN processing:", error);
                    let egrnErrorMessage;
                    if (error.message === 'EGRN_NOT_FOUND_404' || error.message === 'Участок не найден в ЕГРН') {
                        egrnErrorMessage = "Кадастровый номер не найден в ЕГРН";
                    } else if (error.message && error.message.startsWith('Ошибка сети ЕГРН')) {
                        egrnErrorMessage = "Сервер ЕГРН не доступен.";
                    } else if (error instanceof SyntaxError) {
                        egrnErrorMessage = "Ошибка обработки ответа от сервера ЕГРН (неверный формат).";
                    } else {
                        egrnErrorMessage = error.message || "Произошла непредвиденная ошибка при загрузке данных ЕГРН.";
                    }
                    showError(egrnErrorMessage, 'egrn');
                    drawingSectionEGRNDiv.style.display = 'none';
                    parcelDataTableEGRNDiv.innerHTML = `<p style="color:red;">Данные ЕГРН не загружены: ${egrnErrorMessage}</p>`;
                    return { success: false, error };
                } finally {
                    showLoaderEGRN(false);
                }
            };

            await Promise.allSettled([xmlProcessingPromise(), egrnProcessingPromise()]);

            // Логика сравнения работает идентично для JSON и XML, так как формат currentParcelContoursXML унифицирован
            if (currentParcelContoursXML && convertedEgrnContours) {
                if (currentRecordType === 'construction') {
                    lastComparisonResult = compareConstructionCoordinates(currentParcelContoursXML, convertedEgrnContours);
                } else {
                    lastComparisonResult = compareParcelCoordinates(currentParcelContoursXML, convertedEgrnContours);
                }
                displayComparisonResultUI(lastComparisonResult);
            }
            
            if (currentRecordType !== 'construction') {
                compareAndHighlightAreas();
                compareAndHighlightPointCounts();
            }
        }

        function showLoaderXML(show, message = null, progress = null) {
            if (show) {
                loaderXMLDiv.style.display = 'flex';
                loadParcelBtn.disabled = true;
                if (progress !== null && progress >= 0 && progress <= 100) {
                    progressBarContainerXML.style.display = 'block';
                    progressBarXML.style.width = `${progress}%`;
                    loaderXMLTextSpan.style.display = 'none';
                    spinnerIconXML.style.display = 'none';
                    if (progress === 100 && message && message.includes("Готово")) {
                        loaderXMLTextSpan.textContent = message;
                        loaderXMLTextSpan.style.display = 'block';
                    }
                } else {
                    progressBarContainerXML.style.display = 'none';
                    progressBarXML.style.width = `0%`;
                    loaderXMLTextSpan.textContent = message || "Загрузка XML...";
                    loaderXMLTextSpan.style.display = 'block';
                    spinnerIconXML.style.display = 'inline-block';
                }
            } else {
                loaderXMLDiv.style.display = 'none';
                loadParcelBtn.disabled = false;
            }
        }

        function showLoaderEGRN(show, message = "Загрузка ЕГРН...") {
            loaderEGRNTextSpan.textContent = message;
            loaderEGRNDiv.style.display = show ? 'flex' : 'none';
        }

async function fetchAndProcessKPT(quarterNumber, fullCadNumber) {
            const serverQuarterPrefix = quarterNumber.replace(/:/g, '_');
            
            // ИЗМЕНЕНИЕ: Проверка на "нулевой" квартал или ЕЗ (6 или 7 нулей в номере квартала)
            // Ищем паттерн :000000: или :0000000: или в конце строки
            const isZeroQuarter = /:0{6,7}$/.test(quarterNumber) || /:0{6,7}:/.test(fullCadNumber);

            showLoaderXML(true, null, 10);
            const responseList = await fetch(`${STORAGE_API_URL}/${BUCKET_NAME}?search=${serverQuarterPrefix}`);
            if (!responseList.ok) throw new Error(`Ошибка получения списка файлов: ${responseList.statusText}`);
            const fileList = await responseList.json();
            if (!fileList || fileList.length === 0) throw new Error(`КПТ для квартала ${quarterNumber} не найдены на сервере.`);
            showLoaderXML(true, null, 25);

            let matchingFiles = [];
            let preferJson = false;

            // ИЗМЕНЕНИЕ: Логика приоритета JSON
            if (isZeroQuarter) {
                // Пытаемся найти .json.zip
                const jsonFiles = fileList.filter(file => file.name.startsWith(serverQuarterPrefix) && file.name.toLowerCase().endsWith('.json.zip'));
                if (jsonFiles.length > 0) {
                    matchingFiles = jsonFiles;
                    preferJson = true;
                    // Выводим уведомление об оптимизации
                    const errorDiv = document.getElementById('errorMessagesXML');
                    errorDiv.innerHTML = '<i class="fas fa-bolt"></i> Обнаружен нулевой квартал<br>Для ускорения используется JSON-формат';
                    errorDiv.style.display = 'block';
                    errorDiv.style.backgroundColor = '#ecfdf5'; // Зеленоватый фон
                    errorDiv.style.color = '#047857';
                    errorDiv.style.borderColor = '#6ee7b7';
                }
            }

            // Если JSON не нужен или не найден, ищем обычный ZIP (XML)
            if (matchingFiles.length === 0) {
                matchingFiles = fileList.filter(file => file.name.startsWith(serverQuarterPrefix) && file.name.toLowerCase().endsWith('.zip') && !file.name.toLowerCase().endsWith('.json.zip'));
            }

            if (matchingFiles.length === 0) throw new Error(`Подходящие архивы КПТ для квартала ${quarterNumber} не найдены.`);
            
            const latestFile = findLatestKptFile(matchingFiles);
            if (!latestFile) throw new Error("Не удалось определить последний файл КПТ.");
            
            showLoaderXML(true, `Загрузка ${latestFile.name}...`, 40);

            const responseDownload = await fetch(`${STORAGE_API_URL}/${BUCKET_NAME}/${latestFile.name}`);
            if (!responseDownload.ok) throw new Error(`Ошибка загрузки файла ${latestFile.name}: ${responseDownload.statusText}`);
            const blob = await responseDownload.blob();
            if (!blob) throw new Error("Не удалось получить содержимое файла КПТ с сервера.");
            showLoaderXML(true, null, 65);

            const zip = await JSZip.loadAsync(blob);
            
            let fileContent = null;
            let isJsonResult = false;

            // ИЗМЕНЕНИЕ: Распаковка в зависимости от типа
            if (preferJson) {
                const jsonEntry = Object.values(zip.files).find(f => f.name.toLowerCase().endsWith('.json') && !f.dir);
                if (jsonEntry) {
                    fileContent = await jsonEntry.async('string');
                    isJsonResult = true;
                }
            }

            // Если JSON не найден (или не искали), ищем XML
            if (!fileContent) {
                const xmlFileEntry = Object.values(zip.files).find(f => f.name.toLowerCase().endsWith('.xml') && !f.dir);
                if (xmlFileEntry) {
                    fileContent = await xmlFileEntry.async('string');
                    isJsonResult = false;
                }
            }

            if (!fileContent) throw new Error("В архиве не найдены файлы данных (XML или JSON).");
            
            showLoaderXML(true, null, 85);
            return { fileContent, kptFileName: latestFile.name, isJson: isJsonResult };
        }
        
        function processJSONData(jsonContent, fullCadNumber, kptFileName) {
            let data;
            try {
                data = JSON.parse(jsonContent);
            } catch (e) {
                throw new Error("Ошибка парсинга JSON файла.");
            }

            // Ищем объект по ID (кадастровому номеру)
            const targetObj = data.objects.find(o => o.id === fullCadNumber);
            
            if (!targetObj) {
                throw new Error(`Объект ${fullCadNumber} не найден в JSON файле ${kptFileName}.`);
            }

            // Парсим метаданные файла (для отображения даты/номера КПТ)
            // В JSON обычно source_xml_name_in_zip хранит имя, из него можно вытащить дату
            if (kptFileName) {
                const dateMatch = kptFileName.match(/(\d{4})[_-](\d{2})[_-](\d{2})/);
                if (dateMatch) {
                    kptDate = `${dateMatch[3]}.${dateMatch[2]}.${dateMatch[1]}`;
                } else {
                    kptDate = 'из имени файла';
                }
                kptRegNum = 'JSON выписка';
            }

            // Определяем тип записи
            if (targetObj.type === 'parcel') currentRecordType = 'land';
            else if (targetObj.type === 'building') currentRecordType = 'build';
            else if (targetObj.type === 'construction') currentRecordType = 'construction';
            else currentRecordType = 'land';

            // Извлекаем контуры
            // Формат в JSON обычно: [[{x,y, ord_nmb, delta}, ...], [...]]
            // Нам нужно: [[{x,y}, ...], ...] (delta обрабатываем отдельно для статистики)
            const allDeltas = [];
            currentParcelContoursXML = targetObj.contours.map(contour => {
                return contour.map(point => {
                    if (point.delta !== undefined && point.delta !== null) {
                        allDeltas.push(parseFloat(point.delta));
                    }
                    return { x: point.x, y: point.y };
                });
            });

            xmlTotalPointCount = currentParcelContoursXML ? currentParcelContoursXML.reduce((sum, contour) => sum + contour.length, 0) : 0;

            // Формируем parcelData
            const opts = targetObj.options || {};
            const parcelData = {};

            parcelData.cadNumber = targetObj.id;
            
            // Тип объекта
            if (opts.land_record_type) parcelData.objectType = opts.land_record_type;
            else if (targetObj.type === 'building') parcelData.objectType = 'Здание';
            else if (targetObj.type === 'construction') parcelData.objectType = 'Сооружение';
            else parcelData.objectType = 'Земельный участок';

            parcelData.address = opts.readable_address || 'Нет данных';

            // Площадь
            let areaVal = opts.area || opts.specified_area || opts.land_record_area_verified || opts.declared_area || opts.build_record_area;
            if (currentRecordType === 'construction' && opts.params_area) areaVal = opts.params_area;
            
            parcelData.areaNumeric = areaVal ? parseFloat(String(areaVal).replace(',', '.')) : null;
            
            // Определение декларированной площади (для ЗУ)
            const isDeclared = (targetObj.type === 'parcel') && 
                               (opts.specified_area === null || opts.specified_area === undefined) && 
                               (opts.land_record_area_verified === null || opts.land_record_area_verified === undefined);
            
            if (parcelData.areaNumeric !== null) {
                const inaccuracy = opts.inaccuracy || opts.area_inaccuracy;
                if (currentRecordType === 'land') {
                    parcelData.areaString = isDeclared 
                        ? `Декларированная: ${formatNumberWithSpaces(parcelData.areaNumeric)} кв.м.` 
                        : `Уточненная: ${formatNumberWithSpaces(parcelData.areaNumeric)} ${inaccuracy ? '±' + inaccuracy : ''} кв.м.`;
                } else {
                    parcelData.areaString = `${formatNumberWithSpaces(parcelData.areaNumeric)} кв.м.`;
                }
            } else {
                parcelData.areaString = 'Нет данных';
            }

            // Прочие поля
            parcelData.permittedUse = opts.permitted_use_established_by_document || opts.purpose || opts.params_purpose || 'Нет данных';
            parcelData.category = opts.land_record_category_type || (opts.floors ? `Этажность: ${opts.floors}` : 'Нет данных');
            
            const cost = opts.cost_value;
            parcelData.cadastralValue = cost ? parseFloat(cost).toLocaleString('ru-RU') + ' руб.' : 'Нет данных';

            // Погрешность (max delta)
            parcelData.maxDeltaGeopoint = allDeltas.length > 0 ? Math.max(...allDeltas).toString() : '—';

            return { parcelData, parcelContours: currentParcelContoursXML };
        }
        
        async function processXMLData(xmlContent, fullCadNumber, kptFileName) {
            const parser = new DOMParser();
            const xmlDoc = parser.parseFromString(xmlContent, "text/xml");

            kptDate = getElementValue(xmlDoc, 'extract_cadastral_plan_territory > details_statement > group_top_requisites > date_formation')?.split('-').reverse().join('.') || '';
            kptRegNum = getElementValue(xmlDoc, 'extract_cadastral_plan_territory > details_statement > group_top_requisites > registration_number') || '';

            let foundRecord = Array.from(xmlDoc.querySelectorAll('land_record')).find(record => getElementValue(record, 'object > common_data > cad_number') === fullCadNumber);
            currentRecordType = 'land';

            if (!foundRecord) {
                foundRecord = Array.from(xmlDoc.querySelectorAll('build_record')).find(record => getElementValue(record, 'object > common_data > cad_number') === fullCadNumber);
                currentRecordType = 'build';
            }
            if (!foundRecord) {
                foundRecord = Array.from(xmlDoc.querySelectorAll('construction_record')).find(record => getElementValue(record, 'object > common_data > cad_number') === fullCadNumber);
                currentRecordType = 'construction';
            }

            if (!foundRecord) throw new Error(`Объект ${fullCadNumber} не найден в XML файле ${kptFileName}.`);

            const parcelData = extractParcelDataXML(foundRecord, currentRecordType);
            currentParcelContoursXML = extractParcelCoordinatesXML(foundRecord);

            xmlTotalPointCount = currentParcelContoursXML ? currentParcelContoursXML.reduce((sum, contour) => sum + contour.length, 0) : 0;
            return { parcelData, parcelContours: currentParcelContoursXML };
        }

        function resetUI() {
            [resultsContainerDiv, errorMessagesXMLDiv, drawingSectionXMLDiv, parcelInfoSectionXMLDiv, exportSectionXMLDiv, errorMessagesEGRNDiv, drawingSectionEGRNDiv, parcelInfoSectionEGRNDiv, outdatedDataNotificationDiv, comparisonSectionDiv].forEach(el => el.style.display = 'none');
            [errorMessagesXMLDiv, parcelDataTableXMLDiv, errorMessagesEGRNDiv, parcelDataTableEGRNDiv].forEach(el => el.innerHTML = '');
            [parcelCanvasXML, parcelCanvasEGRN].forEach(canvas => canvas && canvas.getContext('2d').clearRect(0, 0, canvas.width, canvas.height));
            resetButtonHeader(document.getElementById('h2XMLHeader'));
            resetButtonHeader(document.getElementById('h2EGRNHeader'));
            currentParcelDataXML = currentParcelContoursXML = convertedEgrnContours = currentEgrnFeature = areaXMLValue = areaEGRNValue = xmlTotalPointCount = egrnTotalPointCount = null;
            kptDate = kptRegNum = '';
            xmlIsDeclared = egrnIsDeclared = false;
            currentRecordType = 'land';
            lastComparisonResult = null;
            selectedMskSystem = null;
            setExportButtonsState(false);
        }

        function showError(message, type = 'xml') {
            let errorDiv = (type === 'egrn') ? errorMessagesEGRNDiv : errorMessagesXMLDiv;
            errorDiv.textContent = message;
            errorDiv.style.display = 'block';
        }

        function extractParcelDataXML(recordNode, recordType = 'land') {
            const data = {};
            data.cadNumber = getElementValue(recordNode, 'object > common_data > cad_number');
            data.objectType = getElementValue(recordNode, 'object > common_data > type > value');
            data.address = getElementValue(recordNode, 'address_location > address > readable_address') || 'Нет данных';

            data.areaNumeric = null;
            data.areaString = 'Нет данных';

            if (recordType === 'land') {
                const areaElement = recordNode.querySelector('params > area');
                const areaValueText = getElementValue(areaElement, 'value');
                data.areaNumeric = areaValueText ? parseFloat(areaValueText.replace(',', '.')) : null;
                const inaccuracy = getElementValue(areaElement, 'inaccuracy');
                data.areaString = data.areaNumeric !== null ? (inaccuracy ? `Уточненная: ${formatNumberWithSpaces(data.areaNumeric)} ±${inaccuracy} кв.м.` : `Декларированная: ${formatNumberWithSpaces(data.areaNumeric)} кв.м.`) : 'Нет данных';

                data.permittedUse = getElementValue(recordNode, 'params > permitted_use > permitted_use_established > by_document') || 'Нет данных';
                data.category = getElementValue(recordNode, 'params > category > type > value') || 'Нет данных';

            } else if (recordType === 'build') {
                const areaValueText = getElementValue(recordNode, 'params > area');
                data.areaNumeric = areaValueText ? parseFloat(areaValueText.replace(',', '.')) : null;
                data.areaString = data.areaNumeric ? `${formatNumberWithSpaces(data.areaNumeric)} кв.м.` : 'Нет данных';

                data.permittedUse = getElementValue(recordNode, 'params > purpose > value') || getElementValue(recordNode, 'params > purpose') || 'Нет данных';
                data.category = getElementValue(recordNode, 'params > floors') ? `Этажность: ${getElementValue(recordNode, 'params > floors')}` : '—';

            } else if (recordType === 'construction') {
                const baseParam = recordNode.querySelector('params > base_parameters > base_parameter');
                if (baseParam) {
                    let paramName = 'Характеристика';
                    let paramValue = '';

                    if (baseParam.querySelector('area')) { paramName = 'Площадь'; paramValue = getElementValue(baseParam, 'area') + ' кв.м.'; data.areaNumeric = parseFloat(getElementValue(baseParam, 'area')); }
                    else if (baseParam.querySelector('extension')) { paramName = 'Протяженность'; paramValue = getElementValue(baseParam, 'extension') + ' м'; }
                    else if (baseParam.querySelector('depth')) { paramName = 'Глубина'; paramValue = getElementValue(baseParam, 'depth') + ' м'; }
                    else if (baseParam.querySelector('volume')) { paramName = 'Объем'; paramValue = getElementValue(baseParam, 'volume') + ' м³'; }
                    else if (baseParam.querySelector('built_up_area')) { paramName = 'Площадь застройки'; paramValue = getElementValue(baseParam, 'built_up_area') + ' кв.м.'; }

                    data.areaString = `${paramName}: ${paramValue}`;
                }

                data.permittedUse = getElementValue(recordNode, 'params > purpose') || 'Нет данных';
                data.category = 'Сооружение';
            }

            const costValue = getElementValue(recordNode, 'cost > value');
            data.cadastralValue = costValue ? parseFloat(costValue).toLocaleString('ru-RU') + ' руб.' : 'Нет данных';

            const allDeltaValues = Array.from(recordNode.querySelectorAll("delta_geopoint"))
                .map(el => parseFloat(el.textContent.trim()))
                .filter(val => !isNaN(val));

            data.maxDeltaGeopoint = allDeltaValues.length > 0 ? Math.max(...allDeltaValues).toString() : '—';
            return data;
        }

        function displayParcelInfoTableXML(data) {
            areaXMLValue = null;
            xmlIsDeclared = false;
            if (!data && !kptDate && !kptRegNum) {
                parcelInfoSectionXMLDiv.style.display = 'none';
                currentParcelDataXML = null;
                xmlTotalPointCount = null;
                compareAndHighlightAreas();
                compareAndHighlightPointCounts();
                return;
            }
            let tableHTML = '<table>';
            const displayOrder = [
                { key: 'cadNumber', label: 'Кадастровый номер' },
                { key: 'objectType', label: 'Тип объекта' },
                { key: 'address', label: 'Адрес' },
                { key: 'areaString', label: 'Площадь' },
                { key: 'permittedUse', label: 'Разрешенное использование' },
                { key: 'category', label: 'Категория земель' },
                { key: 'maxDeltaGeopoint', label: 'Погрешность' },
                { key: 'cadastralValue', label: 'Кадастровая стоимость' }
            ];
            if (data) {
                displayOrder.forEach(item => {
                    if (data[item.key] || data[item.key] === '—' || typeof data[item.key] === 'number') {
                        let rowAttributes = '';
                        if (item.key === 'areaString') {
                            areaXMLValue = data.areaNumeric;
                            rowAttributes += ' id="xmlAreaRow"';
                            if (data.areaString && data.areaString.startsWith("Декларированная:")) xmlIsDeclared = true;
                        }
                        if (item.key === 'maxDeltaGeopoint' && data[item.key] !== '—') {
                            const deltaValue = parseFloat(data[item.key]);
                            if (!isNaN(deltaValue)) {
                                let accuracyClass = (deltaValue === 0.1) ? 'accuracy-good-row' : (deltaValue === 0.2 || deltaValue === 0.3) ? 'accuracy-bad-row' : '';
                                if (accuracyClass) rowAttributes += ` class="${accuracyClass}"`;
                            }
                        }
                        tableHTML += `<tr${rowAttributes}><th>${item.label}</th><td>${data[item.key]}</td></tr>`;
                    }
                });
            }
            if (kptDate || kptRegNum) {
                let fileInfoText = [kptRegNum, kptDate].filter(Boolean).join(' от ');
                tableHTML += `<tr><th>Источник XML</th><td>${fileInfoText}</td></tr>`;
            }
            let pointDisplayText = xmlTotalPointCount !== null ? (xmlTotalPointCount > 0 ? xmlTotalPointCount : '0 (нет координат)') : '—';
            tableHTML += `<tr id="xmlPointCountRow"><th>Кол-во точек (XML)</th><td>${pointDisplayText}</td></tr>`;
            tableHTML += '</table>';
            parcelDataTableXMLDiv.innerHTML = tableHTML;
            parcelInfoSectionXMLDiv.style.display = 'block';
        }

        function drawParcelOnCanvasXML(contours) {
            const canvas = parcelCanvasXML;
            const ctx = canvas.getContext('2d');
            const resolvedContainerWidth = drawingSectionXMLDiv.clientWidth > 0 ? drawingSectionXMLDiv.clientWidth : 300;
            canvas.width = resolvedContainerWidth;
            canvas.height = canvas.width * (3 / 4);
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            const allPoints = contours.flat();
            if (allPoints.length === 0) return;

            const { minGeoX, maxGeoX, minGeoY, maxGeoY, scale, offsetX_canvas, offsetY_canvas } = calculateCanvasTransforms(allPoints, canvas);

            ctx.strokeStyle = '#2563eb'; ctx.lineWidth = 2; ctx.fillStyle = 'rgba(37, 99, 235, 0.1)';
            let totalGeometricAreaXML = 0, totalGeometricPerimeterXML = 0;

            contours.forEach(contour => {
                if (contour.length < 1) return;
                ctx.beginPath();
                const canvasPoints = contour.map(point => ({
                    x_canvas: offsetX_canvas + (point.y - minGeoY) * scale,
                    y_canvas: offsetY_canvas + (maxGeoX - point.x) * scale
                }));
                canvasPoints.forEach((cp, index) => (index === 0) ? ctx.moveTo(cp.x_canvas, cp.y_canvas) : ctx.lineTo(cp.x_canvas, cp.y_canvas));
                const isClosed = contour.length > 2 && Math.abs(contour[0].x - contour[contour.length - 1].x) < 1e-6 && Math.abs(contour[0].y - contour[contour.length - 1].y) < 1e-6;
                if (isClosed) { ctx.closePath(); ctx.fill(); }
                ctx.stroke();

                if (showDistanceLabelsXML) {
                    let contourPerimeter = 0;
                    for (let i = 0; i < contour.length; i++) {
                        const p1 = contour[i], p2 = contour[(i + 1) % contour.length];
                        if (i === contour.length - 1 && !isClosed) break;
                        const dist = Math.sqrt(Math.pow(p2.y - p1.y, 2) + Math.pow(p2.x - p1.x, 2));
                        contourPerimeter += dist;
                        const cp1 = canvasPoints[i], cp2 = canvasPoints[(i + 1) % contour.length];
                        drawRotatedText(ctx, dist.toFixed(2) + "м", cp1.x_canvas, cp1.y_canvas, cp2.x_canvas, cp2.y_canvas, '10px Arial', 'black');
                    }
                    totalGeometricPerimeterXML += contourPerimeter;
                    if (isClosed) totalGeometricAreaXML += calculatePolygonArea(contour);
                }
            });

            if (showDistanceLabelsXML) {
                ctx.fillStyle = 'black'; ctx.font = '11px Arial'; ctx.textAlign = 'left';
                ctx.fillText(`Площадь (XML): ~${formatNumberWithSpaces(Math.round(totalGeometricAreaXML))} м²`, 10, canvas.height - 25);
                ctx.fillText(`Периметр (XML): ~${formatNumberWithSpaces(Math.round(totalGeometricPerimeterXML))} м`, 10, canvas.height - 10);
            }
        }

        function calculateCanvasTransforms(points, canvas) {
            let minGeoX = Infinity, maxGeoX = -Infinity, minGeoY = Infinity, maxGeoY = -Infinity;
            points.forEach(p => {
                minGeoX = Math.min(minGeoX, p.x); maxGeoX = Math.max(maxGeoX, p.x);
                minGeoY = Math.min(minGeoY, p.y); maxGeoY = Math.max(maxGeoY, p.y);
            });
            const dataGeoWidth = (maxGeoY - minGeoY) || 1;
            const dataGeoHeight = (maxGeoX - minGeoX) || 1;
            const jsInternalPadding = 30, scaleMultiplier = 0.85;
            const effectiveCanvasWidth = canvas.width - 2 * jsInternalPadding;
            const effectiveCanvasHeight = canvas.height - 2 * jsInternalPadding;
            const scale = Math.min(effectiveCanvasWidth / dataGeoWidth, effectiveCanvasHeight / dataGeoHeight) * scaleMultiplier;
            const offsetX_canvas = jsInternalPadding + (effectiveCanvasWidth - dataGeoWidth * scale) / 2;
            const offsetY_canvas = jsInternalPadding + (effectiveCanvasHeight - dataGeoHeight * scale) / 2;
            return { minGeoX, maxGeoX, minGeoY, maxGeoY, scale, offsetX_canvas, offsetY_canvas };
        }

        function calculatePolygonArea(contour) {
            let area = 0;
            for (let j = 0; j < contour.length; j++) {
                const p_curr = contour[j], p_next = contour[(j + 1) % contour.length];
                area += (p_curr.y * p_next.x - p_next.y * p_curr.x);
            }
            return Math.abs(area / 2.0);
        }

        function setExportButtonsState(enabled) {
            exportMifBtn.disabled = !enabled;
            exportDxfBtn.disabled = !enabled;
            exportTxtBtn.disabled = !enabled;
        }

        function getElementValue(element, tagName) {
            if (!element) return '';
            const node = element.querySelector(tagName.replace(/ > /g, ' '));
            return node ? node.textContent.trim() : '';
        }

        function formatCadastralNumber(input) {
            let value = input.value.replace(/[^\d]/g, '');
            let formatted = '';
            const originalLength = value.length;
            if (originalLength > 0) formatted += value.substring(0, Math.min(2, originalLength));
            if (originalLength > 2) formatted += ':' + value.substring(2, Math.min(4, originalLength));
            const firstTwoDigits = value.substring(0, 2);
            const quarterMaxLength = sevenDigitsRegions.includes(firstTwoDigits) ? 7 : 6;
            if (originalLength > 4) formatted += ':' + value.substring(4, Math.min(4 + quarterMaxLength, originalLength));
            if (originalLength > (4 + quarterMaxLength)) formatted += ':' + value.substring(4 + quarterMaxLength);
            input.value = formatted;
        }

        function isValidCadastralNumber(text) {
            if (!text) return false;
            const firstTwoDigits = text.slice(0, 2);
            const digitsAfterSecondColon = sevenDigitsRegions.includes(firstTwoDigits) ? 7 : 6;
            const pattern = new RegExp(`^\\d{2}:\\d{2}:\\d{${digitsAfterSecondColon}}:\\d+$`);
            return pattern.test(text);
        }

        function findLatestKptFile(files) {
            if (!files || files.length === 0) return null;
            return files.sort((a, b) => b.name.localeCompare(a.name))[0];
        }

        function extractParcelCoordinatesXML(recordNode) {
            const result = [];
            let parentNodeForContours = recordNode.querySelector("contours_location");
            if (!parentNodeForContours) {
                parentNodeForContours = recordNode.querySelector("contours");
                if (parentNodeForContours && parentNodeForContours.children.length === 0) { }
                if (!parentNodeForContours) parentNodeForContours = recordNode;
            }

            if (parentNodeForContours) {
                const processSpatialElements = (container) => {
                    const spatialElements = container.querySelectorAll("entity_spatial > spatials_elements > spatial_element, spatial_element");
                    spatialElements.forEach(el => {
                        const contourCoords = Array.from(el.querySelectorAll("ordinates > ordinate")).map(ord => {
                            const x = parseFloat(getElementValue(ord, "x")), y = parseFloat(getElementValue(ord, "y"));
                            return !isNaN(x) && !isNaN(y) ? { x, y } : null;
                        }).filter(Boolean);
                        if (contourCoords.length > 0) result.push(contourCoords);
                    });
                };

                const contourNodes = parentNodeForContours.querySelectorAll("contour");
                if (contourNodes.length > 0) {
                    contourNodes.forEach(c => processSpatialElements(c));
                } else {
                    processSpatialElements(parentNodeForContours);
                }
            }
            return result;
        }

async function fetchAndProcessEGRN(cadNumber) {
            const url = `https://nspd.gov.ru/api/geoportal/v2/search/geoportal?thematicSearchId=1&query=${encodeURIComponent(cadNumber)}`;
            try {
                const response = await fetch(url);
                if (response.status === 404) throw new Error('EGRN_NOT_FOUND_404');
                if (!response.ok) throw new Error(`Ошибка сети ЕГРН: ${response.status} ${response.statusText}`);
                const data = await response.json();
                if (data.data?.features?.length > 0) {
                    currentEgrnFeature = data.data.features[0];
                    if (currentEgrnFeature.geometry) {
                        // ИЗМЕНЕНИЕ: Добавлен await, так как функция теперь асинхронная (может ждать выбора пользователя)
                        const { convertedContours, detectedMskName } = await autoDetectAndConvertEgrnCoords(currentEgrnFeature.geometry, cadNumber);
                        convertedEgrnContours = convertedContours;

                        const allPointsFlat = convertedEgrnContours.flat();
                        egrnTotalPointCount = allPointsFlat.length;
                        drawingSectionEGRNDiv.style.display = 'block';
                        drawEgrnParcelOnCanvas();
                    } else {
                        egrnTotalPointCount = 0;
                        convertedEgrnContours = null;
                        showError('Геометрия не найдена в ЕГРН для данного объекта.', 'egrn');
                        drawingSectionEGRNDiv.style.display = 'none';
                    }
                    displayEgrnInfoTable(currentEgrnFeature.properties.options, currentEgrnFeature.properties);
                } else {
                    throw new Error('Участок не найден в ЕГРН');
                }
            } catch (error) {
                if (error instanceof TypeError && error.message === 'Failed to fetch') throw new Error('Ошибка сети ЕГРН: Не удалось выполнить запрос (Failed to fetch)');
                throw error;
            }
        }

        function displayEgrnInfoTable(options, properties) {
    parcelDataTableEGRNDiv.innerHTML = '';
    areaEGRNValue = null;
    egrnIsDeclared = false;
    let tableHTML = '<table>';
    const categoryName = properties.categoryName || "Неизвестный тип";
    const dataRows = [];
    
    // ДОБАВИТЬ ЗДЕСЬ В НАЧАЛО:
    if (selectedMskSystem) {
        dataRows.push({ label: 'Система координат', value: selectedMskSystem });
    }
    
    dataRows.push({ label: 'Тип объекта', value: categoryName });
    dataRows.push({ label: 'Кадастровый номер', value: options.cad_num || options.cad_number });
    dataRows.push({ label: 'Статус', value: options.status || options.common_data_status });
    dataRows.push({ label: 'Адрес', value: options.readable_address || options.address_readable_address });
    let areaValueForCost = null, areaDisplayValue = 'Нет данных';
    let isAreaRowForEGRN = false;
    if (categoryName === "Земельные участки ЕГРН") {
        const areaValue = options.specified_area || options.land_record_area_verified || options.declared_area || options.land_record_area_declaration || options.land_record_area;
        if (areaValue && !isNaN(parseFloat(areaValue))) {
            areaValueForCost = parseFloat(areaValue);
            const isDeclared = !options.specified_area && !options.land_record_area_verified;
            areaDisplayValue = `${isDeclared ? 'Декларированная' : 'Уточненная'}: ${formatNumberWithSpaces(areaValueForCost)} м²`;
            egrnIsDeclared = isDeclared;
        }
        dataRows.push({ label: 'Площадь', value: areaDisplayValue, isArea: true });
        isAreaRowForEGRN = true;
        dataRows.push({ label: 'Категория земель', value: options.land_record_category_type });
        dataRows.push({ label: 'Разрешенное использование', value: options.permitted_use_established_by_document });
        dataRows.push({ label: 'Дата присвоения КН', value: formatDateEGRN(options.land_record_reg_date) });
    }
    if (isAreaRowForEGRN) areaEGRNValue = areaValueForCost;
    let costDisplayValue = 'Нет данных';
    if (options.cost_value && !isNaN(parseFloat(options.cost_value))) {
        const cost = parseFloat(options.cost_value);
        costDisplayValue = formatNumberWithSpaces(cost) + " руб.";
        if (areaValueForCost > 0) costDisplayValue += ` (${formatNumberWithSpaces(Math.round(cost / areaValueForCost))} руб/м²)`;
    }
    dataRows.push({ label: 'Кадастровая стоимость', value: costDisplayValue });
    dataRows.push({ label: 'Дата определения КС', value: formatDateEGRN(options.cost_determination_date) });
    dataRows.push({ label: 'Дата обновления в ЕГРН', value: formatDateEGRN(properties.systemInfo?.updated) });
    
   
    dataRows.forEach(row => {
        if (row.value) tableHTML += `<tr${row.isArea ? ' id="egrnAreaRow"' : ''}><th>${row.label}</th><td>${row.value}</td></tr>`;
    });
    
   
    
    tableHTML += `<tr id="egrnPointCountRow"><th>Кол-во точек (ЕГРН)</th><td>${egrnTotalPointCount ?? '—'}</td></tr>`;
    tableHTML += '</table>';
    parcelDataTableEGRNDiv.innerHTML = tableHTML;
}

        function compareAndHighlightAreas() {
            const xmlAreaRow = document.getElementById('xmlAreaRow'), egrnAreaRow = document.getElementById('egrnAreaRow');
            if (xmlAreaRow) xmlAreaRow.classList.remove('area-same', 'area-different');
            if (egrnAreaRow) egrnAreaRow.classList.remove('area-same', 'area-different');
            outdatedDataNotificationDiv.style.display = 'none';
            const areasComparable = areaXMLValue !== null && areaEGRNValue !== null;
            const areasDiffer = areasComparable && Math.round(areaXMLValue) !== Math.round(areaEGRNValue);
            if (xmlAreaRow) xmlAreaRow.classList.add(xmlIsDeclared || (areasComparable && areasDiffer) ? 'area-different' : 'area-same');
            if (egrnAreaRow) egrnAreaRow.classList.add(egrnIsDeclared ? 'area-different' : (areasComparable ? (areasDiffer ? 'area-different' : 'area-same') : ''));
            if ((areasComparable && areasDiffer) || (xmlIsDeclared && !egrnIsDeclared && areaXMLValue !== null && areaEGRNValue !== null) || (xmlTotalPointCount !== null && egrnTotalPointCount !== null && xmlTotalPointCount !== egrnTotalPointCount)) {
                outdatedDataNotificationDiv.style.display = 'block';
            }
        }

        function compareAndHighlightPointCounts() {
            const xmlRow = document.getElementById('xmlPointCountRow'), egrnRow = document.getElementById('egrnPointCountRow');
            if (xmlRow) xmlRow.className = ''; if (egrnRow) egrnRow.className = '';
            if (xmlTotalPointCount !== null && egrnTotalPointCount !== null && xmlRow && egrnRow) {
                const className = xmlTotalPointCount === egrnTotalPointCount ? 'points-same' : 'points-different';
                xmlRow.classList.add(className); egrnRow.classList.add(className);
            }
        }

    function getCoordinatesForSchema(contours) {
            if (!contours || !Array.isArray(contours) || contours.length === 0) return '';

            // Проходим по каждому контуру
            return contours.map(contour => {
                // Преобразуем точки контура в строки "X Y"
                return contour.map(p => `${p.x.toFixed(2)}\t${p.y.toFixed(2)}`).join('\n');
            }).join('\n\n'); // Объединяем контуры двойным переносом (пустая строка между ними)
        }

        generateSchemaBtn.addEventListener('click', async () => {
            const coordsString = getCoordinatesForSchema(currentParcelContoursXML);
            if (coordsString) {
                try {
                    await navigator.clipboard.writeText(coordsString);
                    window.open('схема.html', '_blank');
                } catch (err) { console.error('Не удалось скопировать координаты: ', err); }
            }
        });

        function formatDateEGRN(dateString) {
            if (!dateString) return '';
            try { return new Date(dateString).toLocaleDateString('ru-RU'); } catch (e) { return dateString; }
        }

        function formatNumberWithSpaces(number) {
            return number?.toLocaleString('ru-RU', { maximumFractionDigits: 2 }) ?? number;
        }

        function drawEgrnParcelOnCanvas() {
            const canvas = parcelCanvasEGRN;
            const ctx = canvas.getContext('2d');
            const resolvedContainerWidthEGRN = drawingSectionEGRNDiv.clientWidth > 0 ? drawingSectionEGRNDiv.clientWidth : 300;
            canvas.width = resolvedContainerWidthEGRN;
            canvas.height = canvas.width * (3 / 4);
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            if (!convertedEgrnContours || convertedEgrnContours.length === 0) return;
            const allPointsFlat = convertedEgrnContours.flat();
            if (allPointsFlat.length === 0) return;

            const { minGeoX, maxGeoX, minGeoY, maxGeoY, scale, offsetX_canvas, offsetY_canvas } = calculateCanvasTransforms(allPointsFlat, canvas);

            ctx.strokeStyle = '#22c55e'; ctx.lineWidth = 2; ctx.fillStyle = 'rgba(34, 197, 94, 0.1)';
            let totalGeometricAreaEGRN = 0, totalGeometricPerimeterEGRN = 0;

            convertedEgrnContours.forEach(contour => {
                if (contour.length < 1) return;
                ctx.beginPath();
                const canvasPoints = contour.map(point => ({
                    x_canvas: offsetX_canvas + (point.y - minGeoY) * scale,
                    y_canvas: offsetY_canvas + (maxGeoX - point.x) * scale
                }));
                canvasPoints.forEach((cp, index) => (index === 0) ? ctx.moveTo(cp.x_canvas, cp.y_canvas) : ctx.lineTo(cp.x_canvas, cp.y_canvas));
                const isClosed = contour.length > 2 && Math.abs(contour[0].x - contour[contour.length - 1].x) < 1e-6 && Math.abs(contour[0].y - contour[contour.length - 1].y) < 1e-6;
                if (isClosed) { ctx.closePath(); ctx.fill(); }
                ctx.stroke();

                if (showDistanceLabelsEGRN) {
                    let contourPerimeter = 0;
                    for (let i = 0; i < contour.length; i++) {
                        const p1 = contour[i], p2 = contour[(i + 1) % contour.length];
                        if (i === contour.length - 1 && !isClosed) break;
                        const dist = Math.sqrt(Math.pow(p2.y - p1.y, 2) + Math.pow(p2.x - p1.x, 2));
                        contourPerimeter += dist;
                        const cp1 = canvasPoints[i], cp2 = canvasPoints[(i + 1) % contour.length];
                        drawRotatedText(ctx, dist.toFixed(2) + "м", cp1.x_canvas, cp1.y_canvas, cp2.x_canvas, cp2.y_canvas, '10px Arial', 'black');
                    }
                    totalGeometricPerimeterEGRN += contourPerimeter;
                    if (isClosed) totalGeometricAreaEGRN += calculatePolygonArea(contour);
                }
            });

            if (showDistanceLabelsEGRN) {
                ctx.fillStyle = 'black'; ctx.font = '11px Arial'; ctx.textAlign = 'left';
                ctx.fillText(`Площадь (ЕГРН): ~${formatNumberWithSpaces(Math.round(totalGeometricAreaEGRN))} м²`, 10, canvas.height - 25);
                ctx.fillText(`Периметр (ЕГРН): ~${formatNumberWithSpaces(Math.round(totalGeometricPerimeterEGRN))} м`, 10, canvas.height - 10);
            }
        }

async function autoDetectAndConvertEgrnCoords(geometry, cadNumber) {
            let mskCode = MskFinder.findMskCode(cadNumber);
            let targetSystem = null;

            // 1. Попытка автоматического поиска по коду из msk.js
            if (mskCode) {
                targetSystem = COORDINATE_SYSTEMS.find(s => s.text.includes(`МСК-${mskCode}`)) ||
                               COORDINATE_SYSTEMS.find(s => s.text.includes(`МСК ${mskCode}`)) ||
                               COORDINATE_SYSTEMS.find(s => s.text.includes(mskCode));
            }

            // 2. Если не найдено автоматически, ищем по коду региона (первые 2 цифры КН)
            if (!targetSystem) {
                const regionCode = cadNumber.split(':')[0];
                
                // Фильтруем системы, относящиеся к этому региону (ищем "МСК XX-" или "МСК-XX")
                const candidates = COORDINATE_SYSTEMS.filter(s => 
                    s.text.includes(`МСК ${regionCode}-`) || 
                    s.text.includes(`МСК-${regionCode}`) ||
                    s.text.includes(`МСК ${regionCode} `)
                );

                if (candidates.length > 0) {
                    // Спрашиваем пользователя
                    try {
                        targetSystem = await promptUserForMsk(candidates, regionCode);
                    } catch (e) {
                        throw new Error("Выбор МСК отменен пользователем.");
                    }
                }
            }

            if (!targetSystem) {
                throw new Error(mskCode 
                    ? `Определение для МСК-${mskCode} не найдено.` 
                    : `Не удалось автоматически определить МСК для региона ${cadNumber.split(':')[0]} и подходящие варианты не найдены.`);
            }

            // Применяем выбранную систему
            if (proj4.defs(targetSystem.value) === undefined) {
                 proj4.defs(targetSystem.value, targetSystem.def);
            }
            
            const { offsetX = 0, offsetY = 0 } = targetSystem;

            const convertedContours = [];
            const convertRing = ring => ring.map(coord => {
                const [lon, lat] = proj4('EPSG:3857', targetSystem.value, coord);
                return { x: lat + offsetX, y: lon + offsetY };
            });

            const processGeom = (geom) => {
                if (!geom) return;
                if (geom.type === 'Polygon') {
                    geom.coordinates.forEach(ring => convertedContours.push(convertRing(ring)));
                } else if (geom.type === 'MultiPolygon') {
                    geom.coordinates.forEach(polygon => polygon.forEach(ring => convertedContours.push(convertRing(ring))));
                } else if (geom.type === 'GeometryCollection') {
                    geom.geometries.forEach(processGeom);
                }
            };

            processGeom(geometry);
            selectedMskSystem = targetSystem.text;
            return { convertedContours, detectedMskName: targetSystem.text };
        }

        function promptUserForMsk(candidates, regionCode) {
            return new Promise((resolve, reject) => {
                const modal = document.getElementById('mskSelectionModal');
                const listContainer = document.getElementById('mskListContainer');
                const regionDisplay = document.getElementById('mskRegionDisplay');
                const closeBtn = document.getElementById('closeMskModal');

                regionDisplay.textContent = regionCode;
                listContainer.innerHTML = '';

                // Функция очистки и закрытия
                const cleanup = () => {
                    modal.classList.remove('active');
                    closeBtn.removeEventListener('click', onClose);
                };

                const onClose = () => {
                    cleanup();
                    reject(new Error('User cancelled'));
                };

                // Заполняем список
                candidates.forEach(sys => {
                    const item = document.createElement('div');
                    item.className = 'msk-list-item';
                    item.innerHTML = `<i class="fas fa-map-marker-alt"></i> ${sys.text}`;
                    
                    item.addEventListener('click', () => {
                        cleanup();
                        resolve(sys);
                    });
                    
                    listContainer.appendChild(item);
                });

                closeBtn.addEventListener('click', onClose);
                modal.classList.add('active');
            });
        }

        // ===== ИСПРАВЛЕНИЕ 2: Расстояние от точки до отрезка =====
        function distancePointToSegment(point, segStart, segEnd) {
            const dx = segEnd.x - segStart.x;
            const dy = segEnd.y - segStart.y;
            const lengthSquared = dx * dx + dy * dy;
            
            if (lengthSquared === 0) {
                // Отрезок вырождается в точку
                return Math.sqrt(Math.pow(point.x - segStart.x, 2) + Math.pow(point.y - segStart.y, 2));
            }
            
            // Параметр t определяет ближайшую точку на отрезке
            let t = ((point.x - segStart.x) * dx + (point.y - segStart.y) * dy) / lengthSquared;
            t = Math.max(0, Math.min(1, t)); // Ограничиваем t в [0, 1]
            
            const nearestX = segStart.x + t * dx;
            const nearestY = segStart.y + t * dy;
            
            return Math.sqrt(Math.pow(point.x - nearestX, 2) + Math.pow(point.y - nearestY, 2));
        }

        // ===== Расстояние от точки до границы полигона =====
        function distanceToPolygonBoundary(point, polygon) {
            let minDistance = Infinity;
            for (let i = 0; i < polygon.length; i++) {
                const j = (i + 1) % polygon.length;
                const dist = distancePointToSegment(point, polygon[i], polygon[j]);
                if (dist < minDistance) {
                    minDistance = dist;
                }
            }
            return minDistance;
        }

        // ===== ИСПРАВЛЕНИЕ 2: Проверка точки внутри полигона с допуском на границу =====
        function isPointInPolygon(point, polygon) {
            let inside = false;
            for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
                const xi = polygon[i].x, yi = polygon[i].y;
                const xj = polygon[j].x, yj = polygon[j].y;
                
                const intersect = ((yi > point.y) !== (yj > point.y)) &&
                    (point.x < (xj - xi) * (point.y - yi) / (yj - yi) + xi);
                if (intersect) inside = !inside;
            }
            return inside;
        }

        // ===== Проверка с допуском 2 см на границу =====
        function isPointInOrOnPolygon(point, polygon, tolerance = 0.02) {
            // Сначала проверяем, внутри ли точка
            if (isPointInPolygon(point, polygon)) {
                return true;
            }
            // Если не внутри, проверяем расстояние до границы
            const distToBoundary = distanceToPolygonBoundary(point, polygon);
            return distToBoundary <= tolerance;
        }

        // ===== СРАВНЕНИЕ КООРДИНАТ ДЛЯ СООРУЖЕНИЙ =====
function compareConstructionCoordinates(xmlContours, egrnContours) {
    const comparisonTable = [];
    let overallMatch = true;
    const boundaryTolerance = 0.02; // 2 см допуск на границе
    
    const egrnPolygons = egrnContours.filter(c => c.length > 2);
    
    if (egrnPolygons.length === 0) {
        return { 
            status: 'mismatch', 
            isConstruction: true,
            comparisonTable: [{ message: 'Полигон ЕГРН не найден или некорректен' }] 
        };
    }

    let pointIndex = 0;
    xmlContours.forEach(xmlContour => {
        xmlContour.forEach(xmlPoint => {
            pointIndex++;
            let isInside = false;
            let minDistToBoundary = Infinity;
            
            for (const polygon of egrnPolygons) {
                if (isPointInOrOnPolygon(xmlPoint, polygon, boundaryTolerance)) {
                    isInside = true;
                    break;
                }
                const dist = distanceToPolygonBoundary(xmlPoint, polygon);
                if (dist < minDistToBoundary) {
                    minDistToBoundary = dist;
                }
            }
            
            if (!isInside) overallMatch = false;
            
            comparisonTable.push({
                index: pointIndex,
                xml: `${xmlPoint.x.toFixed(2)}, ${xmlPoint.y.toFixed(2)}`,
                egrn: isInside ? 'Внутри/на границе' : `Вне (${minDistToBoundary.toFixed(2)} м)`,
                matchType: isInside ? 'strict' : 'none',  // <-- добавлено для корректной отрисовки маркеров
                delta: isInside ? '≤0.02' : minDistToBoundary.toFixed(3)
            });
        });
    });

    return { 
        status: overallMatch ? 'match' : 'mismatch', 
        comparisonTable, 
        isConstruction: true 
    };
}

     // ===== ОБНОВЛЕННОЕ СРАВНЕНИЕ (С УЧЕТОМ НАПРАВЛЕНИЯ И ПОИСКОМ ПОТЕРЯННЫХ ТОЧЕК) =====
        function compareParcelCoordinates(xmlContours, egrnContours) {
            const comparisonTable = [];
            let strictMatchCount = 0;
            let looseMatchCount = 0;
            let mismatchCount = 0;
            const tolerance = 0.02; // Допуск 2 см

            // 1. Создаем плоский список всех точек ЕГРН для поиска "потеряшек"
            const flatEgrnPoints = [];
            egrnContours.forEach((contour, cIndex) => {
                contour.forEach((point, pIndex) => {
                    flatEgrnPoints.push({
                        x: point.x,
                        y: point.y,
                        contourId: cIndex + 1,
                        pointId: pIndex + 1
                    });
                });
            });

            let globalPointIndex = 0;

            // 2. Проходим по всем контурам XML
            for (let i = 0; i < xmlContours.length; i++) {
                const xmlContour = xmlContours[i];
                let egrnContourStrict = egrnContours[i] || [];

                // --- ЛОГИКА АВТОМАТИЧЕСКОГО РАЗВОРОТА (REVERSE) ---
                if (egrnContourStrict.length > 0 && xmlContour.length === egrnContourStrict.length) {
                    // 1. Считаем совпадения для прямого порядка
                    let normalMatches = 0;
                    for (let k = 0; k < xmlContour.length; k++) {
                        const dx = Math.abs(xmlContour[k].x - egrnContourStrict[k].x);
                        const dy = Math.abs(xmlContour[k].y - egrnContourStrict[k].y);
                        if (Math.sqrt(dx * dx + dy * dy) <= tolerance) normalMatches++;
                    }

                    // 2. Считаем совпадения для обратного порядка
                    // Вариант А: Простой реверс массива
                    const reversedArr = [...egrnContourStrict].reverse();
                    let reverseMatches = 0;
                    for (let k = 0; k < xmlContour.length; k++) {
                        const dx = Math.abs(xmlContour[k].x - reversedArr[k].x);
                        const dy = Math.abs(xmlContour[k].y - reversedArr[k].y);
                        if (Math.sqrt(dx * dx + dy * dy) <= tolerance) reverseMatches++;
                    }

                    // Вариант Б: Реверс для замкнутого контура (первая точка остается на месте, остальные разворачиваются)
                    // Это нужно, если в XML и ЕГРН начало контура совпадает, но направление разное
                    let reverseClosedMatches = 0;
                    let reversedClosedArr = [];
                    if (egrnContourStrict.length > 2) {
                        reversedClosedArr = [
                            egrnContourStrict[0], 
                            ...egrnContourStrict.slice(1, -1).reverse(), 
                            egrnContourStrict[egrnContourStrict.length - 1]
                        ];
                        // Если контур не замкнут геометрически (первая != последняя), этот метод может исказить данные,
                        // но мы просто считаем совпадения, так что это безопасно для выбора лучшего варианта.
                        for (let k = 0; k < xmlContour.length; k++) {
                            if (!reversedClosedArr[k]) break;
                            const dx = Math.abs(xmlContour[k].x - reversedClosedArr[k].x);
                            const dy = Math.abs(xmlContour[k].y - reversedClosedArr[k].y);
                            if (Math.sqrt(dx * dx + dy * dy) <= tolerance) reverseClosedMatches++;
                        }
                    }

                    // Выбираем лучший вариант
                    // Если реверс дает больше совпадений, чем прямой порядок, используем его
                    if (reverseMatches > normalMatches && reverseMatches >= reverseClosedMatches) {
                        egrnContourStrict = reversedArr;
                    } else if (reverseClosedMatches > normalMatches && reverseClosedMatches > reverseMatches) {
                        egrnContourStrict = reversedClosedArr;
                    }
                    // Иначе оставляем прямой порядок
                }
                // --- КОНЕЦ ЛОГИКИ РАЗВОРОТА ---

                for (let j = 0; j < xmlContour.length; j++) {
                    globalPointIndex++;
                    const xmlP = xmlContour[j];
                    
                    // А. Строгая проверка (тот же контур, та же точка)
                    let isStrictMatch = false;
                    let strictDelta = null;
                    
                    if (egrnContourStrict[j]) {
                        const dx = Math.abs(xmlP.x - egrnContourStrict[j].x);
                        const dy = Math.abs(xmlP.y - egrnContourStrict[j].y);
                        const delta = Math.sqrt(dx * dx + dy * dy);
                        if (delta <= tolerance) {
                            isStrictMatch = true;
                            strictDelta = delta;
                        }
                    }

                    // Б. Если строгого совпадения нет (даже после разворота), ищем "свободное"
                    let looseDelta = null;
                    let foundLocation = '';

                    if (isStrictMatch) {
                        strictMatchCount++;
                        comparisonTable.push({
                            index: globalPointIndex,
                            xml: `${xmlP.x.toFixed(2)}, ${xmlP.y.toFixed(2)}`,
                            egrn: `${egrnContourStrict[j].x.toFixed(2)}, ${egrnContourStrict[j].y.toFixed(2)}`,
                            matchType: 'strict', 
                            delta: strictDelta.toFixed(3)
                        });
                    } else {
                        // Поиск в плоском списке
                        const foundPoint = flatEgrnPoints.find(ep => {
                            const dx = Math.abs(xmlP.x - ep.x);
                            const dy = Math.abs(xmlP.y - ep.y);
                            const delta = Math.sqrt(dx * dx + dy * dy);
                            if (delta <= tolerance) {
                                looseDelta = delta;
                                return true;
                            }
                            return false;
                        });

                        if (foundPoint) {
                            looseMatchCount++;
                            foundLocation = `(Контур ${foundPoint.contourId}, т.${foundPoint.pointId})`;
                            
                            comparisonTable.push({
                                index: globalPointIndex,
                                xml: `${xmlP.x.toFixed(2)}, ${xmlP.y.toFixed(2)}`,
                                egrn: `${foundPoint.x.toFixed(2)}, ${foundPoint.y.toFixed(2)} <br><span style="font-size:0.85em;color:#d97706">${foundLocation}</span>`,
                                matchType: 'loose',
                                delta: looseDelta.toFixed(3)
                            });
                        } else {
                            mismatchCount++;
                            comparisonTable.push({
                                index: globalPointIndex,
                                xml: `${xmlP.x.toFixed(2)}, ${xmlP.y.toFixed(2)}`,
                                egrn: '—',
                                matchType: 'none',
                                delta: '—'
                            });
                        }
                    }
                }
            }

            // Определение общего статуса
            let overallStatus = 'mismatch';
            if (mismatchCount === 0 && looseMatchCount === 0) {
                overallStatus = 'match';
            } else if (mismatchCount === 0 && looseMatchCount > 0) {
                overallStatus = 'warning'; 
            }

            if (flatEgrnPoints.length > globalPointIndex) {
                 if (overallStatus === 'match') overallStatus = 'warning';
            }

            return { 
                status: overallStatus, 
                comparisonTable, 
                isConstruction: false,
                stats: { strict: strictMatchCount, loose: looseMatchCount, miss: mismatchCount }
            };
        }
        
        
function displayComparisonResultUI(result) {
    const btn = document.getElementById('comparisonToggleBtn');
    if (!result || !result.comparisonTable) {
        comparisonSectionDiv.style.display = 'none';
        return;
    }

    btn.className = 'comparison-toggle-btn';
    btn.style.background = '';  
    if (result.status === 'match') {
        btn.classList.add('success');
        btn.innerHTML = `<i class="fas fa-check-circle"></i> Координаты совпадают`;
    } else if (result.status === 'warning') {
        btn.style.background = 'linear-gradient(135deg, #f59e0b 0%, #d97706 100%)'; 
        btn.innerHTML = `<i class="fas fa-exclamation-circle"></i> Порядок контуров отличается`;
    } else {
        btn.classList.add('failure');
        btn.innerHTML = `<i class="fas fa-exclamation-triangle"></i> Координаты не совпадают`;
    }

            if (btn._clickHandler) btn.removeEventListener('click', btn._clickHandler);
            btn._clickHandler = () => {
                openComparisonModal(result);
            };
            btn.addEventListener('click', btn._clickHandler);

            comparisonSectionDiv.style.display = 'block';
        }

function openComparisonModal(result) {
            // Обновляем бейдж статуса
            if (result.status === 'match') {
                modalStatusBadge.className = 'modal-header-status match';
                modalStatusBadge.innerHTML = '<i class="fas fa-check-circle"></i><span>Совпадают</span>';
            } else if (result.status === 'warning') {
                modalStatusBadge.className = 'modal-header-status warning';
                modalStatusBadge.innerHTML = '<i class="fas fa-random"></i><span>Порядок отличается</span>';
            } else {
                modalStatusBadge.className = 'modal-header-status mismatch';
                modalStatusBadge.innerHTML = '<i class="fas fa-times-circle"></i><span>Расхождение</span>';
            }

            constructionInfoBlock.style.display = result.isConstruction ? 'flex' : 'none';
            
            // Если есть "свободные" совпадения, показываем инфо-блок
            if (result.stats && result.stats.loose > 0) {
                // Можно добавить доп. уведомление внутри модалки, если нужно
                // Например: constructionInfoBlock.innerHTML = "..." и показать его
            }

            if (result.comparisonTable[0]?.message) {
                comparisonTableBody.innerHTML = `<tr><td colspan="4" class="mismatch-row" style="text-align:center;font-weight:600;">${result.comparisonTable[0].message}</td></tr>`;
            } else {
                let tableHTML = '';
                result.comparisonTable.forEach(row => {
                    let rowClass = '';
                    if (row.matchType === 'strict') rowClass = 'match-row';
                    else if (row.matchType === 'loose') rowClass = 'warning-row';
                    else rowClass = 'mismatch-row';

                    tableHTML += `<tr class="${rowClass}">
                        <td>${row.index}</td>
                        <td>${row.xml}</td>
                        <td>${row.egrn}</td>
                        <td>${row.delta || '—'}</td>
                    </tr>`;
                });
                comparisonTableBody.innerHTML = tableHTML;
            }

            comparisonModal.classList.add('active');
            
            requestAnimationFrame(() => {
                drawComparisonCanvas(result);
            });
        }

        // ===== ИСПРАВЛЕНИЕ 3: Четкая отрисовка с учетом devicePixelRatio =====
        function drawComparisonCanvas(result) {
            const canvas = comparisonCanvas;
            const ctx = canvas.getContext('2d');
            
            // Получаем реальный размер контейнера
            const containerWidth = canvas.parentElement.clientWidth - 32;
            const displayWidth = Math.max(containerWidth, 400);
            const displayHeight = displayWidth * 0.6;
            
            // Учитываем devicePixelRatio для четкости на HiDPI экранах
            const dpr = window.devicePixelRatio || 1;
            
            // Устанавливаем внутренний размер canvas с учетом dpr
            canvas.width = displayWidth * dpr;
            canvas.height = displayHeight * dpr;
            
            // Устанавливаем CSS размер (отображаемый размер)
            canvas.style.width = displayWidth + 'px';
            canvas.style.height = displayHeight + 'px';
            
            // Масштабируем контекст
            ctx.scale(dpr, dpr);
            
            ctx.clearRect(0, 0, displayWidth, displayHeight);

            // Собираем все точки для расчета масштаба
            const allPoints = [];
            if (currentParcelContoursXML) {
                currentParcelContoursXML.flat().forEach(p => allPoints.push(p));
            }
            if (convertedEgrnContours) {
                convertedEgrnContours.flat().forEach(p => allPoints.push(p));
            }

            if (allPoints.length === 0) return;

            // Используем displayWidth/displayHeight для расчетов (не canvas.width/height)
            const transforms = calculateCanvasTransformsForComparison(allPoints, displayWidth, displayHeight);
            const { minGeoX, maxGeoX, minGeoY, maxGeoY, scale, offsetX_canvas, offsetY_canvas } = transforms;

            const toCanvas = (point) => ({
                x: offsetX_canvas + (point.y - minGeoY) * scale,
                y: offsetY_canvas + (maxGeoX - point.x) * scale
            });

            // Рисуем контур ЕГРН (зеленый)
            if (convertedEgrnContours) {
                ctx.strokeStyle = '#22c55e';
                ctx.lineWidth = 2;
                ctx.fillStyle = result.isConstruction ? 'rgba(34, 197, 94, 0.15)' : 'rgba(34, 197, 94, 0.05)';
                
                convertedEgrnContours.forEach(contour => {
                    if (contour.length < 2) return;
                    ctx.beginPath();
                    const canvasPoints = contour.map(toCanvas);
                    canvasPoints.forEach((cp, i) => i === 0 ? ctx.moveTo(cp.x, cp.y) : ctx.lineTo(cp.x, cp.y));
                    const isClosed = contour.length > 2 && 
                        Math.abs(contour[0].x - contour[contour.length - 1].x) < 1e-6 && 
                        Math.abs(contour[0].y - contour[contour.length - 1].y) < 1e-6;
                    if (isClosed) {
                        ctx.closePath();
                        ctx.fill();
                    }
                    ctx.stroke();
                });
            }

            // Рисуем контур XML (синий)
            if (currentParcelContoursXML) {
                ctx.strokeStyle = '#2563eb';
                ctx.lineWidth = 2;
                ctx.fillStyle = 'rgba(37, 99, 235, 0.05)';
                
                currentParcelContoursXML.forEach(contour => {
                    if (contour.length < 2) return;
                    ctx.beginPath();
                    const canvasPoints = contour.map(toCanvas);
                    canvasPoints.forEach((cp, i) => i === 0 ? ctx.moveTo(cp.x, cp.y) : ctx.lineTo(cp.x, cp.y));
                    const isClosed = contour.length > 2 && 
                        Math.abs(contour[0].x - contour[contour.length - 1].x) < 1e-6 && 
                        Math.abs(contour[0].y - contour[contour.length - 1].y) < 1e-6;
                    if (isClosed && !result.isConstruction) {
                        ctx.closePath();
                        ctx.fill();
                    }
                    ctx.stroke();
                });
            }

            // Рисуем маркеры точек
                    if (result.comparisonTable && !result.comparisonTable[0]?.message) {
                const markerRadius = 5;
                let pointIndex = 0;

                currentParcelContoursXML?.forEach(contour => {
                    contour.forEach(point => {
                        const cp = toCanvas(point);
                        const tableRow = result.comparisonTable[pointIndex];
                        
                        let fillColor, strokeColor;

                        if (tableRow?.matchType === 'strict') {
                            fillColor = '#22c55e'; // Green
                            strokeColor = '#166534';
                        } else if (tableRow?.matchType === 'loose') {
                            fillColor = '#f59e0b'; // Orange (Warning)
                            strokeColor = '#b45309';
                        } else {
                            fillColor = '#ef4444'; // Red
                            strokeColor = '#991b1b';
                        }
                        
                        ctx.beginPath();
                        ctx.arc(cp.x, cp.y, markerRadius, 0, Math.PI * 2);
                        ctx.fillStyle = fillColor;
                        ctx.fill();
                        ctx.strokeStyle = strokeColor;
                        ctx.lineWidth = 1;
                        ctx.stroke();
                        
                        pointIndex++;
                    });
                });
            }
        }

        // Отдельная функция расчета трансформаций для comparison canvas
        function calculateCanvasTransformsForComparison(points, canvasWidth, canvasHeight) {
            let minGeoX = Infinity, maxGeoX = -Infinity, minGeoY = Infinity, maxGeoY = -Infinity;
            points.forEach(p => {
                minGeoX = Math.min(minGeoX, p.x); maxGeoX = Math.max(maxGeoX, p.x);
                minGeoY = Math.min(minGeoY, p.y); maxGeoY = Math.max(maxGeoY, p.y);
            });
            const dataGeoWidth = (maxGeoY - minGeoY) || 1;
            const dataGeoHeight = (maxGeoX - minGeoX) || 1;
            const jsInternalPadding = 30, scaleMultiplier = 0.85;
            const effectiveCanvasWidth = canvasWidth - 2 * jsInternalPadding;
            const effectiveCanvasHeight = canvasHeight - 2 * jsInternalPadding;
            const scale = Math.min(effectiveCanvasWidth / dataGeoWidth, effectiveCanvasHeight / dataGeoHeight) * scaleMultiplier;
            const offsetX_canvas = jsInternalPadding + (effectiveCanvasWidth - dataGeoWidth * scale) / 2;
            const offsetY_canvas = jsInternalPadding + (effectiveCanvasHeight - dataGeoHeight * scale) / 2;
            return { minGeoX, maxGeoX, minGeoY, maxGeoY, scale, offsetX_canvas, offsetY_canvas };
        }

        function getCoordinatesForDefaultTxtExport(contours) {
            return contours?.map(c => c.map(p => `${p.x.toFixed(2)}\t${p.y.toFixed(2)}`).join('\n')).join('\n\n').trim() || [];
        }

        function generateMIF(contours) {
            let mifContent = `Version 300\nCharset "WindowsCyrillic"\nDelimiter ","\nCoordSys NonEarth Units "m"\nColumns 1\n  ID Char(254)\nData\n`;
            const validContours = contours.filter(c => c.length > 0);
            if (validContours.length === 0) return "";
            mifContent += `Region ${validContours.length}\n`;
            validContours.forEach(c => { mifContent += `${c.length}\n` + c.map(p => `${p.y.toFixed(2)} ${p.x.toFixed(2)}`).join('\n') + '\n'; });
            return mifContent;
        }

        function generateDXF(contours) {
            let dxf = `0\nSECTION\n2\nENTITIES\n`;
            contours.filter(c => c.length > 0).forEach(c => {
                const isClosed = c.length > 2 && Math.abs(c[0].x - c[c.length - 1].x) < 1e-3 && Math.abs(c[0].y - c[c.length - 1].y) < 1e-3;
                dxf += `0\nLWPOLYLINE\n8\n0\n66\n1\n70\n${isClosed ? 1 : 0}\n90\n${c.length}\n` + c.map(p => `10\n${p.y.toFixed(2)}\n20\n${p.x.toFixed(2)}`).join('\n') + '\n';
            });
            dxf += `0\nENDSEC\n0\nEOF\n`;
            return dxf;
        }

        function downloadFile(content, filename, contentType) {
            const blob = new Blob([content], { type: contentType });
            const a = document.createElement('a');
            a.href = URL.createObjectURL(blob);
            a.download = filename;
            document.body.appendChild(a); a.click(); document.body.removeChild(a);
            URL.revokeObjectURL(a.href);
        }

        exportMifBtn.addEventListener('click', () => currentParcelContoursXML && downloadFile(generateMIF(currentParcelContoursXML), `${currentParcelDataXML?.cadNumber?.replace(/:/g, '_') || 'parcel'}.mif`, 'application/vnd.mif'));
        exportDxfBtn.addEventListener('click', () => currentParcelContoursXML && downloadFile(generateDXF(currentParcelContoursXML), `${currentParcelDataXML?.cadNumber?.replace(/:/g, '_') || 'parcel'}.dxf`, 'application/dxf'));
        exportTxtBtn.addEventListener('click', () => {
            if (!currentParcelContoursXML?.some(c => c.length > 0)) return;
            const startNumStr = prompt("Введите номер для первой точки (оставьте пустым для формата N[tab]E):", "");
            if (startNumStr === null) return;
            const cadNum = currentParcelDataXML?.cadNumber?.replace(/:/g, '_') || 'parcel';
            let content, filename;
            if (startNumStr.trim() === "") {
                content = getCoordinatesForDefaultTxtExport(currentParcelContoursXML);
                filename = `${cadNum}_coords_N_E.txt`;
            } else {
                const startNum = parseInt(startNumStr, 10);
                if (!isNaN(startNum)) {
                    let pointNum = startNum;
                    content = currentParcelContoursXML.map(c => c.map(p => `${pointNum++},${p.x.toFixed(2)},${p.y.toFixed(2)}`).join('\n')).join('\n\n');
                    filename = `${cadNum}_coords_Num_N_E.txt`;
                } else {
                    alert("Номер введен некорректно. Экспорт в формате N[tab]E.");
                    content = getCoordinatesForDefaultTxtExport(currentParcelContoursXML);
                    filename = `${cadNum}_coords_N_E.txt`;
                }
            }
            downloadFile(content, filename, 'text/plain;charset=utf-8');
        });

        async function checkClipboardAndAutoSearch() {
            if (!navigator.clipboard?.readText) return;
            try {
                const text = (await navigator.clipboard.readText()).trim();
                if (!text || /[a-zA-Zа-яА-Я]/.test(text) || text.length > 30) return;
                const tempInput = { value: text };
                formatCadastralNumber(tempInput);
                if (isValidCadastralNumber(tempInput.value) && cadastralInput && !loadParcelBtn.disabled) {
                    cadastralInput.value = tempInput.value;
                    loadParcelBtn.click();
                }
            } catch (err) { }
        }

        window.addEventListener('DOMContentLoaded', () => {
            document.querySelectorAll('h2[id]').forEach(h => h._initialTextContent = h.textContent);
            checkClipboardAndAutoSearch();
        });
        
        // Перерисовка при изменении размера окна
        window.addEventListener('resize', () => {
            if (comparisonModal.classList.contains('active') && lastComparisonResult) {
                drawComparisonCanvas(lastComparisonResult);
            }
        });
    </script>
</body>
</html>