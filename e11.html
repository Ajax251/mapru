<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>Печать сведений</title>
    <script src="webfonts/jszip.min.js"></script>
    <link rel="icon" href="img/vyp.png" type="image/png">
    <script src="webfonts/proj4.js"></script>
    <!-- Добавляем Turf.js для расчета площадей пересечения -->
    <script src="https://cdn.jsdelivr.net/npm/@turf/turf@6/turf.min.js"></script>
    <script src="sk.js"></script>
    <script src="msk.js"></script>
    <style id="print-orientation-style"></style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
 <style>
    :root {
        --page-width: 297mm;
        --main-font-times: "Times New Roman", Times, serif;
        --main-font-ui: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
        --font-size-normal: 10pt;
        --font-size-small: 8pt;
        --primary-blue: #4285f4;
        --primary-blue-hover: #3367d6;
        --sky-blue: #29b6f6;
        --sky-blue-hover: #0288d1;
        --success-green: #34a853;
        --success-green-hover: #2d8f47;
        --warning-orange: #fbbc05;
        --warning-orange-hover: #f9ab00;
        --secondary-gray: #9aa0a6;
        --secondary-gray-hover: #80868b;
        --indigo: #6366f1;
        --indigo-hover: #4f46e5;
        --purple: #8b5cf6;
        --purple-hover: #7c3aed;
        --teal: #14b8a6;
        --teal-hover: #0d9488;
    }

    * { margin: 0; padding: 0; box-sizing: border-box; }

    body {
        font-family: var(--main-font-ui);
        margin: 0;
        background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 50%, #f1f3f4 100%);
        color: #202124;
        min-height: 100vh;
    }

    #app-container {
        display: flex;
        flex-direction: column;
        min-height: 100vh;
    }

    #start-view {
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        flex-grow: 1;
        padding: 20px;
    }

    #results-view {
        display: none;
        width: 100%;
        max-width: var(--page-width);
        margin: 0 auto;
        padding: 20px;
        box-sizing: border-box;
    }

    .glass-panel {
        background: rgba(255, 255, 255, 0.95);
        border-radius: 20px;
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.12);
        backdrop-filter: blur(10px);
        -webkit-backdrop-filter: blur(10px);
        border: 1px solid rgba(255, 255, 255, 0.8);
        position: relative;
        overflow: hidden;
    }

    .glass-panel::before {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        height: 1px;
        background: linear-gradient(90deg, transparent, rgba(66, 133, 244, 0.3), transparent);
    }

    .control-panel {
        padding: 50px 60px;
        text-align: center;
        max-width: 800px;
        width: 100%;
    }

    .control-panel h3 {
        margin-top: 0;
        margin-bottom: 15px;
        font-size: 32px;
        color: #202124;
        font-weight: 600;
        text-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
    }

    .control-panel p {
        margin-bottom: 35px;
        color: #5f6368;
        font-size: 18px;
        font-weight: 400;
    }

    .input-group {
        display: flex;
        flex-direction: column;
        gap: 20px;
    }

    #cadastralInput {
        padding: 18px 25px;
        font-size: 20px;
        border: 2px solid #dadce0;
        border-radius: 12px;
        text-align: center;
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        background: #fff;
        color: #202124;
        font-weight: 400;
    }

    #cadastralInput::placeholder {
        color: #9aa0a6;
        font-weight: 400;
    }

    #cadastralInput:focus {
        outline: none;
        border-color: var(--primary-blue);
        background: #fff;
        box-shadow: 0 0 0 4px rgba(66, 133, 244, 0.15);
        transform: translateY(-2px);
    }

    .button-row {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 20px;
    }

    .control-panel .button {
        padding: 18px 25px;
        border-radius: 12px;
        border: none;
        color: white;
        cursor: pointer;
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        text-align: center;
        font-size: 16px;
        font-weight: 600;
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 10px;
        position: relative;
        overflow: hidden;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
    }

    .control-panel .button:nth-child(1) {
        background: linear-gradient(135deg, var(--primary-blue) 0%, #5a9fd4 100%);
    }

    .control-panel .button:nth-child(2) {
        background: linear-gradient(135deg, var(--sky-blue) 0%, #81d4fa 100%);
    }

    #xmlFileInputLabel {
        background: linear-gradient(135deg, var(--indigo) 0%, #818cf8 100%);
        grid-column: 1 / -1;
    }

    .control-panel .button::before {
        content: '';
        position: absolute;
        top: 0;
        left: -100%;
        width: 100%;
        height: 100%;
        background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
        transition: left 0.5s;
    }

    .control-panel .button:hover::before {
        left: 100%;
    }

    .control-panel .button:hover {
        transform: translateY(-3px) scale(1.02);
        box-shadow: 0 6px 20px rgba(0, 0, 0, 0.2);
    }

    .control-panel .button:nth-child(1):hover {
        background: linear-gradient(135deg, var(--primary-blue-hover) 0%, #4a8bc2 100%);
    }

    .control-panel .button:nth-child(2):hover {
        background: linear-gradient(135deg, var(--sky-blue-hover) 0%, #29b6f6 100%);
    }

   #xmlFileInputLabel:hover {
        background: linear-gradient(135deg, var(--indigo-hover) 0%, #6366f1 100%);
    }

    .control-panel input[type="file"] {
        display: none;
    }

    #action-buttons {
        display: flex;
        justify-content: center;
        gap: 15px;
        margin-bottom: 25px;
        flex-wrap: wrap;
    }

    #action-buttons button {
        padding: 12px 24px;
        border-radius: 10px;
        border: none;
        color: white;
        cursor: pointer;
        font-size: 16px;
        font-weight: 500;
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        display: inline-flex;
        align-items: center;
        justify-content: center;
        gap: 8px;
        position: relative;
        overflow: hidden;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
    }

    #action-buttons button:nth-child(1) {
        background: linear-gradient(135deg, var(--purple) 0%, #a855f7 100%);
    }

    #action-buttons button:nth-child(1):hover {
        background: linear-gradient(135deg, var(--purple-hover) 0%, #9333ea 100%);
    }
    #action-buttons button:nth-child(2) {
        background: linear-gradient(135deg, var(--primary-blue) 0%, #5a9fd4 100%);
    }

    #action-buttons button:nth-child(3) {
        background: linear-gradient(135deg, var(--success-green) 0%, #4caf50 100%);
    }

    #action-buttons button:nth-child(4) {
        background: linear-gradient(135deg, var(--warning-orange) 0%, #ffca28 100%);
    }

    #action-buttons button:nth-child(4):hover {
        background: linear-gradient(135deg, var(--warning-orange-hover) 0%, #f9a825 100%);
    }

    /* Кнопка Расширенный отчет */
    #extendedReportBtn {
        background: linear-gradient(135deg, var(--teal) 0%, #2dd4bf 100%) !important;
    }
    #extendedReportBtn:hover {
        background: linear-gradient(135deg, var(--teal-hover) 0%, #14b8a6 100%) !important;
    }

    #action-buttons button::before {
        content: '';
        position: absolute;
        top: 0;
        left: -100%;
        width: 100%;
        height: 100%;
        background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
        transition: left 0.5s;
    }

    #action-buttons button:hover::before {
        left: 100%;
    }

    #action-buttons button:hover {
        transform: translateY(-3px) scale(1.05);
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
    }


    #action-buttons button:nth-child(2):hover {
        background: linear-gradient(135deg, var(--primary-blue-hover) 0%, #4a8bc2 100%);
    }

    #action-buttons button:nth-child(3):hover {
        background: linear-gradient(135deg, var(--success-green-hover) 0%, #45a049 100%);
    }

    /* === СТИЛИ ДЛЯ ПЕЧАТНОГО ДОКУМЕНТА (Вариант 1 - Классический официальный) === */
    .page {
        font-family: "Times New Roman", Times, serif;
        font-size: 11pt;
        line-height: 1.4;
        color: #1a1a1a;
        background: white;
        border-radius: 8px;
        box-shadow: 0 4px 16px rgba(0, 0, 0, 0.1);
        margin-top: 25px;
        padding: 15mm 20mm;
        box-sizing: border-box;
        position: relative;
        border: 1px solid #e8eaed;
    }

    .page .doc-header {
        text-align: center;
        border-bottom: 2px solid #1a365d;
        padding-bottom: 15px;
        margin-bottom: 20px;
    }

    .page .doc-header h1 {
        font-size: 15pt;
        font-weight: bold;
        color: #1a365d;
        margin: 0 0 6px 0;
    }

    .page .doc-header .doc-meta {
        font-size: 10pt;
        color: #4a5568;
    }

    .page .section-title {
        background: #f7fafc;
        border-left: 4px solid #1a365d;
        padding: 8px 12px;
        font-weight: bold;
        font-size: 11pt;
        margin: 20px 0 12px 0;
        color: #1a365d;
    }

    .page .object-type-block {
        text-align: center;
        margin: 15px 0;
    }

    .page .object-type {
        font-size: 13pt;
        font-weight: bold;
        color: #1a365d;
        border-bottom: 1px solid #1a365d;
        display: inline-block;
        padding-bottom: 2px;
    }

    .page .object-type-hint {
        font-size: 9pt;
        color: #718096;
        font-style: italic;
        margin-top: 4px;
    }

    .page table {
        width: 100%;
        border-collapse: collapse;
        margin: 12px 0;
    }

    .page table th,
    .page table td {
        border: 1px solid #cbd5e0;
        padding: 8px 10px;
        text-align: left;
        vertical-align: top;
        word-break: break-word;
    }

    .page table th {
        background: #edf2f7;
        font-weight: bold;
        width: 30%; /* Левая колонка - 30% */
        color: #2d3748;
    }

    .page table td {
        background: #fff;
    }

    .page .main-info-table td:first-child {
        background: #f7fafc;
        font-weight: 600;
        color: #2d3748;
        width: 30%; /* Левая колонка - 30% */
    }

    .page .info-block {
        border: 1px solid #e2e8f0;
        border-radius: 4px;
        padding: 12px;
        margin: 12px 0;
        background: #fafafa;
    }

    .page .info-block-title {
        font-weight: bold;
        color: #1a365d;
        margin-bottom: 8px;
        padding-bottom: 6px;
        border-bottom: 1px dashed #cbd5e0;
    }

    /* Разделитель для секции прав внутри таблицы */
    .page .rights-section-header td {
        background: #edf2f7 !important;
        font-weight: bold;
        color: #1a365d;
        border-top: 2px solid #1a365d;
        padding: 10px;
    }

    .page .rights-row td:first-child {
        background: #fafcff;
        padding-left: 20px;
    }

  
/* Координатная таблица */
      .page .coordinates-table {
        font-size: 9pt;
        table-layout: fixed; /* Жесткая фиксация ширины */
        width: 100%;
        border-collapse: collapse;
        margin-top: 10px;
    }

    .page .coordinates-table th,
    .page .coordinates-table td {
        border: 1px solid #595959 !important; /* Более четкие границы */
        padding: 5px;
        vertical-align: middle;
        word-wrap: break-word; /* Перенос слов */
        white-space: normal;
    }

    .page .coordinates-table th {
        background-color: #f2f2f2 !important;
        color: #000 !important;
        text-align: center;
        font-weight: bold;
    }

   
    /* План контейнер */
    .page .plan-container {
        border: 2px solid #1a365d;
        margin-top: 15px;
        padding: 15px;
        box-sizing: border-box;
        min-height: 400px;
        display: flex;
        align-items: center;
        justify-content: center;
        background-color: #fafafa;
        border-radius: 4px;
    }

    .page .plan-container canvas {
        max-width: 100%;
        max-height: 100%;
        border-radius: 4px;
    }

    /* Заголовки для страницы координат */
    .page .coord-header {
        text-align: center;
        margin-bottom: 15px;
    }

    .page .coord-header h3 {
        font-size: 14pt;
        font-weight: bold;
        color: #1a365d;
        margin: 0 0 10px 0;
    }

    .page .coord-info-table {
        margin-bottom: 15px;
    }

    .page .coord-info-table td {
        padding: 6px 10px;
    }

    .page .coord-info-table td:first-child {
        font-weight: 600;
        width: 200px;
    }
    
  
     /* Настройка ширины колонок для ЗОУИТ */
    .page .zouit-table th:nth-child(1) { width: 25%; } /* Учетный номер */
    .page .zouit-table th:nth-child(2) { width: 15%; text-align: center; } /* Площадь */
    .page .zouit-table th:nth-child(3) { width: 60%; } /* Описание */
    .page .zouit-table td:nth-child(2) { text-align: center; }

    /* Настройка для простых таблиц (2 колонки) */
    .page .simple-table th:nth-child(1) { width: 35%; }
    .page .simple-table th:nth-child(2) { width: 65%; }


    /* === КОНЕЦ НОВЫХ СТИЛЕЙ === */

    .modal-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.4);
        backdrop-filter: blur(4px);
        -webkit-backdrop-filter: blur(4px);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 1000;
        transition: opacity 0.3s ease;
    }

    .modal-dialog {
        background: rgba(255, 255, 255, 0.98);
        backdrop-filter: blur(10px);
        padding: 0;
        width: 90%;
        max-width: 700px;
        max-height: 85vh;
        display: flex;
        flex-direction: column;
        border-radius: 16px;
        box-shadow: 0 12px 36px rgba(0, 0, 0, 0.15);
        overflow: hidden;
        border: 1px solid #e8eaed;
    }

    .modal-dialog h3 {
        margin: 0;
        padding: 25px 30px;
        color: #202124;
        font-size: 1.4em;
        font-weight: 600;
        background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
        border-bottom: 1px solid #dadce0;
    }

    #object-filter-input {
        display: block;
        width: calc(100% - 60px);
        margin: 20px 30px 10px 30px;
        padding: 15px 20px;
        font-size: 16px;
        border: 2px solid #dadce0;
        border-radius: 10px;
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        text-align: center;
        background: #fff;
    }

    #object-filter-input:focus {
        outline: none;
        border-color: var(--primary-blue);
        background: #fff;
        box-shadow: 0 0 0 4px rgba(66, 133, 244, 0.15);
        transform: translateY(-1px);
    }

    .modal-list {
        list-style: none;
        padding: 0 20px 20px 20px;
        margin: 0;
        overflow-y: auto;
    }

    .modal-list::-webkit-scrollbar {
        width: 8px;
    }

    .modal-list::-webkit-scrollbar-track {
        background: #f1f3f4;
        border-radius: 4px;
    }

    .modal-list::-webkit-scrollbar-thumb {
        background: var(--primary-blue);
        border-radius: 4px;
    }

    .modal-list::-webkit-scrollbar-thumb:hover {
        background: var(--primary-blue-hover);
    }

    .modal-list li {
        padding: 16px 20px;
        border-bottom: none;
        border-radius: 8px;
        margin-top: 8px;
        cursor: pointer;
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        display: flex;
        justify-content: space-between;
        align-items: center;
        font-size: 16px;
        background: #fff;
        border: 1px solid #e8eaed;
    }

    .modal-list li span:first-child {
        flex-grow: 1;
        text-align: center;
        margin-right: 15px;
        font-weight: 500;
        color: #202124;
    }

    .modal-list li:hover {
        background: #f8f9fa;
        transform: translateY(-1px);
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        border-color: var(--primary-blue);
    }

    .modal-list .obj-type {
        color: var(--primary-blue);
        font-size: 0.85em;
        font-weight: 600;
        background: rgba(66, 133, 244, 0.1);
        padding: 6px 12px;
        border-radius: 6px;
        min-width: 90px;
        text-align: center;
        border: 1px solid rgba(66, 133, 244, 0.2);
    }

   #loader {
    text-align: center;
    padding: 30px;
    font-size: 1.3em;
    display: none;
    color: #5f6368;
    background: rgba(255, 255, 255, 0.9);
    border-radius: 12px;
    backdrop-filter: blur(10px);
    box-shadow: 0 4px 16px rgba(0, 0, 0, 0.1);
    flex-direction: column;
    align-items: center;
    justify-content: center;
    gap: 20px;
}


.spinner {
    width: 60px;
    height: 60px;
    border: 6px solid rgba(66, 133, 244, 0.2);
    border-top-color: var(--primary-blue);
    border-radius: 50%;
    animation: spin 1s linear infinite;
}

#loader p {
    margin: 0;
    font-weight: 500;
}

@keyframes spin {
    to { transform: rotate(360deg); }
}

    .error {
        color: #d93025;
        padding: 15px;
        background: linear-gradient(135deg, #fce8e6 0%, #f9dedc 100%);
        border: 2px solid #f9dedc;
        border-radius: 8px;
        margin-top: 15px;
        font-weight: 500;
        box-shadow: 0 2px 8px rgba(217, 48, 37, 0.15);
    }

.merge-control {
    position: absolute;
    bottom: 10px;
    right: 20mm;
    z-index: 10;
    display: flex;
    gap: 8px;
}

.merge-control button {
    color: white;
    border: none;
    padding: 8px 15px;
    border-radius: 6px;
    cursor: pointer;
    font-size: 10pt;
    font-family: var(--main-font-ui);
    font-weight: 500;
    opacity: 0;
    transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
    display: inline-flex;
    align-items: center;
    gap: 8px;
}

/* Кнопка ориентации (1-я) */
.merge-control button:nth-child(1) {
    background: linear-gradient(135deg, var(--success-green) 0%, #4caf50 100%);
}
.merge-control button:nth-child(1):hover {
    background: linear-gradient(135deg, var(--success-green-hover) 0%, #45a049 100%);
}

/* Кнопка объединения (2-я) */
.merge-control button:nth-child(2) {
    background: linear-gradient(135deg, var(--purple) 0%, #a855f7 100%);
}
.merge-control button:nth-child(2):hover {
    background: linear-gradient(135deg, var(--purple-hover) 0%, #9333ea 100%);
}

/* Кнопка PDF (3-я - НОВАЯ) */
.merge-control button:nth-child(3) {
    background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%); /* Красный цвет */
}
.merge-control button:nth-child(3):hover {
    background: linear-gradient(135deg, #b91c1c 0%, #991b1b 100%);
    transform: translateY(-2px) scale(1.05);
}

.page:hover .merge-control button {
    opacity: 1;
}

.merge-control button:hover {
    transform: translateY(-2px) scale(1.05);
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
}

.page.portrait {
    width: 210mm;
    max-width: 100%;
    margin-left: auto;
    margin-right: auto;
}

    .page.no-break {
        margin-bottom: 2px;
        border-bottom-left-radius: 0;
        border-bottom-right-radius: 0;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
    }

    .page.no-break + .page {
        margin-top: 0;
        border-top-left-radius: 0;
        border-top-right-radius: 0;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
    }

 @media print {
        /* ВАЖНО: Мы убрали отсюда "size: A4", чтобы работал скрипт переключения ориентации */
        @page {
            margin: 10mm; /* Стандартные поля */
        }

        body * { visibility: hidden; }
        
        #report-output, #report-output * { 
            visibility: visible; 
        }

        #report-output { 
            position: absolute; 
            left: 0; 
            top: 0; 
            width: 95%; 
            margin: 0; 
            padding: 0; 
        }

        .page { 
            /* Возвращаем нормальный размер шрифта */
            font-size: 11pt !important;
            line-height: 1.4 !important;
            
            box-shadow: none; 
            border: none;
            border-radius: 0; 
            margin: 0 !important; 
            padding: 0 !important; 
            width: 100% !important;
            max-width: 100% !important;
            
            /* Разрешаем разрыв страницы, если контент длинный */
            page-break-after: always;
            height: auto !important; 
            min-height: auto !important;
            display: block !important;
        }

        /* Заголовки */
        .page .doc-header h1 {
            font-size: 16pt !important;
            margin-bottom: 10px !important;
        }
        
        .page .object-type {
            font-size: 14pt !important;
        }

        /* Таблицы и ячейки */
        table {
            width: 100% !important;
            table-layout: fixed; /* Фиксируем ширину колонок */
            border-collapse: collapse;
        }

        .page table th,
        .page table td {
            padding: 6px 8px !important; /* Комфортные отступы */
            /* Разрешаем перенос слов */
            word-wrap: break-word !important;
            white-space: normal !important;
            overflow-wrap: break-word !important;
        }

        /* Разрешаем разрыв строк таблицы на новую страницу */
        tr {
            page-break-inside: avoid;
        }

        /* Скрываем интерфейс */
        #start-view, 
        #results-view #action-buttons,
        .merge-control,
        button { 
            display: none !important; 
        }

        .page.no-break { 
            page-break-after: avoid !important; 
            margin-bottom: 0; 
        }
        
        .page.no-break + .page { 
            margin-top: 0; 
        }
    }

    @media (max-width: 768px) {
        body {
            font-size: 14px;
        }

        .control-panel {
            padding: 25px 15px;
            border-radius: 0;
            border: none;
            box-shadow: none;
            background: transparent;
        }

        .control-panel h3 {
            font-size: 24px;
        }

        .control-panel p {
            font-size: 16px;
            margin-bottom: 25px;
        }

        .button-row {
            grid-template-columns: 1fr;
        }

        #results-view {
            padding: 10px 5px;
        }

        #action-buttons {
            gap: 8px;
            justify-content: center;
        }

        #action-buttons button {
            padding: 10px 14px;
            font-size: 14px;
        }

        .page {
            padding: 15px;
            margin-top: 15px;
            border-radius: 12px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        .main-info-table tr {
            border-bottom: 1px solid #e0e0e0;
        }
        .main-info-table td {
            display: block;
            width: 100%;
            border: none;
        }
        .main-info-table td:first-child {
            width: 100%;
            background-color: transparent;
            font-weight: bold;
            padding-bottom: 2px;
        }
        .main-info-table td:last-child {
            padding-top: 0;
            padding-left: 8px;
        }

        .plan-container {
            min-height: 250px;
            padding: 8px;
        }

        th, td {
            padding: 6px;
        }

        .header-line, .section-title {
            font-size: 1.1em;
        }

        .modal-dialog {
            width: 95%;
            max-height: 85vh;
        }
        .modal-dialog h3 {
            font-size: 1.2em;
            padding: 20px 15px;
        }
        #object-filter-input {
            width: calc(100% - 30px);
            margin: 15px 15px 10px 15px;
            padding: 12px;
        }
        .modal-list li {
            flex-direction: column;
            align-items: flex-start;
            gap: 8px;
            padding: 12px 15px;
        }
        .modal-list .obj-type {
            align-self: flex-start;
        }
    }
    
    /* --- Стили для нового селектора МСК --- */
.selector-modal {
    background: rgba(255, 255, 255, 0.9) !important;
    backdrop-filter: blur(12px) !important;
    -webkit-backdrop-filter: blur(12px) !important;
    border: 1px solid rgba(255, 255, 255, 0.7) !important;
}

.selector-modal h3 {
    text-align: center;
    font-weight: 500;
}

#msk-filter-input {
    display: block;
    width: calc(100% - 60px);
    margin: 20px 30px 15px 30px;
    padding: 16px 22px;
    font-size: 16px;
    border: 2px solid #dadce0;
    border-radius: 12px;
    transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    text-align: center;
    background: #fff;
}

#msk-filter-input:focus {
    outline: none;
    border-color: var(--primary-blue);
    background: #fff;
    box-shadow: 0 0 0 4px rgba(66, 133, 244, 0.15);
    transform: translateY(-1px);
}

.selector-modal .modal-list li {
    flex-direction: column;
    align-items: flex-start;
    gap: 4px;
    padding: 14px 20px;
    background-color: rgba(255, 255, 255, 0.8);
    border: 1px solid #e8eaed;
}

.selector-modal .modal-list li .item-title {
    font-weight: 500;
    color: #202124;
    font-size: 16px;
}

.selector-modal .modal-list li .item-subtitle {
    font-size: 13px;
    color: var(--secondary-gray);
    background-color: #f1f3f4;
    padding: 3px 8px;
    border-radius: 6px;
}

.selector-modal .modal-list li:hover {
    background: #f8f9fa;
    transform: translateY(-2px);
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
    border-color: var(--primary-blue);
}

/* Стили для диалога расширенного отчета */
.checkbox-list {
    list-style: none;
    padding: 20px 30px;
    margin: 0;
    overflow-y: auto;
}

.checkbox-list li {
    padding: 10px 0;
    display: flex;
    align-items: center;
    font-size: 16px;
}

.checkbox-list input[type="checkbox"] {
    width: 20px;
    height: 20px;
    margin-right: 15px;
    cursor: pointer;
}

.checkbox-list label {
    cursor: pointer;
    flex-grow: 1;
}

#generateReportBtn {
    margin: 20px 30px;
    padding: 12px;
    background: linear-gradient(135deg, var(--primary-blue) 0%, #5a9fd4 100%);
    color: white;
    border: none;
    border-radius: 8px;
    font-size: 16px;
    cursor: pointer;
    transition: all 0.3s;
}

#generateReportBtn:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 12px rgba(0,0,0,0.2);
}
</style>
</head>
<body>
    <div id="app-container">
        <div id="start-view">
            <div class="control-panel glass-panel">
                <h3>Печать сведений по объекту</h3>
                <p>Введите кадастровый номер или загрузите файл XML</p>
                <div class="input-group">
                    <input type="text" id="cadastralInput" placeholder="XX:XX:XXXXXXX:XX">
                    <div class="button-row">
    <button class="button" onclick="fetchFromNspd()">
        <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/>
            <polyline points="14 2 14 8 20 8"/>
            <line x1="16" y1="13" x2="8" y2="13"/>
            <line x1="16" y1="17" x2="8" y2="17"/>
            <polyline points="10 9 9 9 8 9"/>
        </svg>
        Актуальные сведения
    </button>
    <button class="button" onclick="fetchFromKptArchive()">
        <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <path d="M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z"/>
            <polyline points="3.27 6.96 12 12.01 20.73 6.96"/>
            <line x1="12" y1="22.08" x2="12" y2="12"/>
        </svg>
        Сведения из XML
    </button>
</div>
<label for="xmlFileInput" id="xmlFileInputLabel" class="button">
    <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
        <polyline points="17 8 12 3 7 8"/>
        <line x1="12" y1="3" x2="12" y2="15"/>
    </svg>
    Открыть XML
</label>
                    <input type="file" id="xmlFileInput" accept=".xml,.zip" onchange="handleFileSelect(event)">
                </div>
            </div>
        </div>
        <div id="results-view">
            <div id="action-buttons">
                 <button onclick="showStartView()">
                    <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M19 12H5M12 19l-7-7 7-7"/></svg>
                    <span>Назад</span>
                </button>
                <button id="selectObjectBtn" onclick="reShowObjectSelectionDialog()" style="display: none;">
                     <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 3h7v7H3zM14 3h7v7h-7zM14 14h7v7h-7zM3 14h7v7H3z"/></svg>
                    <span>Выбрать объект</span>
                </button>
                <button onclick="window.print()">
                    <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="6 9 6 2 18 2 18 9"></polyline><path d="M6 18H4a2 2 0 0 1-2-2v-5a2 2 0 0 1 2-2h16a2 2 0 0 1 2 2v5a2 2 0 0 1-2 2h-2"></path><rect x="6" y="14" width="12" height="8"></rect></svg>
                    <span>Печать</span>
                </button>
                  <button id="convertToMskBtn" style="display: none;">
        <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="14.5 10.5 12 8 9.5 10.5"></polyline><polyline points="9.5 13.5 12 16 14.5 13.5"></polyline><path d="M20.49 9A9 9 0 0 0 5.64 5.64L1 10m22 4l-4.64 4.36A9 9 0 0 1 3.51 15"></path></svg>
        <span>Координаты в МСК</span>
    </button>
                <button id="extendedReportBtn" onclick="showExtendedReportDialog()" style="display: none;">
                    <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/>
                        <polyline points="14 2 14 8 20 8"/>
                        <line x1="12" y1="18" x2="12" y2="12"/>
                        <line x1="9" y1="15" x2="15" y2="15"/>
                    </svg>
                    <span>Расширенный отчет</span>
                </button>
            </div>
           <div id="loader">
    <div class="spinner"></div>
    <p id="loader-text">Загрузка данных...</p>
</div>
            <div id="report-output"></div>
        </div>
    </div>
  <script src="cb.js"></script> 
    <script>
    let loadedKptData = { xmlString: null, fileName: null, objectList: [], title: null };
    let currentObjectGeometry = null; // Глобальная переменная для хранения геометрии текущего объекта в EPSG:3857
    const sixDigitsRegions = ['02', '03', '04', '05', '08', '15', '16', '18', '19', '21', '22', '25', '26', '28', '30', '33', '34', '37', '38', '39', '40', '43', '44', '45', '46', '54', '55', '73', '75', '76', '91', '92'];


    const colorPalettes = [
    ['#667eea', '#764ba2'],
    ['#f093fb', '#f5576c'],
    ['#4facfe', '#00f2fe'],
    ['#43e97b', '#38f9d7'],
    ['#fa709a', '#fee140'],
    ['#a8edea', '#fed6e3'],
    ['#ff9a9e', '#fecfef'],
    ['#a18cd1', '#fbc2eb'],
    ['#fad0c4', '#ffd1ff'],
    ['#ff8a80', '#ffb74d'],
    ['#81c784', '#aed581'],
    ['#64b5f6', '#42a5f5']
];



let originalNspdData = null; // Для возможности возврата к исходным данным
let isAutoMskEnabled = localStorage.getItem('app_auto_msk') === 'true';
let savedOrientation = localStorage.getItem('app_orientation') || 'portrait';
let savedMergedIndices = JSON.parse(localStorage.getItem('app_merged_indices') || '[]');

function saveMergeState() {
    const merged = [];
    document.querySelectorAll('.page').forEach((page, index) => {
        if (page.classList.contains('no-break')) {
            merged.push(index);
        }
    });
    savedMergedIndices = merged;
    localStorage.setItem('app_merged_indices', JSON.stringify(merged));
}

function restoreMergeState() {
    const pages = document.querySelectorAll('.page');
    savedMergedIndices.forEach(index => {
        if (pages[index]) {
            const page = pages[index];
            const btn = page.querySelector('.merge-control button:last-child');
            if (btn) {
                page.classList.add('no-break');
                // Обновляем иконку кнопки
                btn.innerHTML = `
            <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3"/>
            </svg>`;
            }
        }
    });
}

function showStartView() {
    document.getElementById('start-view').style.display = 'flex';
    document.getElementById('results-view').style.display = 'none';
    document.getElementById('report-output').innerHTML = '';
   loadedKptData = { xmlString: null, fileName: null, objectList: [], title: null };
    document.getElementById('selectObjectBtn').style.display = 'none';
    document.getElementById('extendedReportBtn').style.display = 'none';
    currentObjectGeometry = null;
}

function showResultsView() {
    document.getElementById('start-view').style.display = 'none';
    document.getElementById('results-view').style.display = 'block';
}

    function showLoader(show) { document.getElementById('loader').style.display = show ? 'flex' : 'none'; }

    function displayError(error, isFatal = false) {
        const output = document.getElementById('report-output');
        output.innerHTML = `<div class="error"><strong>Ошибка:</strong> ${error.message}</div>`;
        if(!isFatal) showResultsView();
    }

async function handleFileSelect(event) {
    const file = event.target.files[0]; if (!file) return;
    resetAndShowLoader();
    try {
        let xmlString, fileName = file.name;
        if (file.name.toLowerCase().endsWith('.zip')) {
            const zip = await JSZip.loadAsync(await file.arrayBuffer());
            const xmlFile = Object.values(zip.files).find(f => f.name.toLowerCase().endsWith('.xml'));
            if (!xmlFile) throw new Error("XML-файл не найден в архиве.");
            xmlString = await xmlFile.async("string");
            fileName = xmlFile.name;
        } else { xmlString = await file.text(); }
        const parser = new DOMParser();
        const xmlDoc = parser.parseFromString(xmlString, "text/xml");
   const reportTitle = createTitleFromXml(xmlDoc, fileName);

        const records = xmlDoc.querySelectorAll('land_record, build_record, construction_record');
        if (records.length > 1) {
            showLoader(false);
            extractAndShowObjectList(xmlString, records, fileName, reportTitle);
            document.getElementById('selectObjectBtn').style.display = 'inline-flex';
        } else {
            const { data, isKptFile } = parseXml(xmlString);
            displayResults(data, reportTitle, isKptFile);
            showResultsView();
        }
    } catch (error) { displayError(error, true); }
    finally { if (document.querySelectorAll('.modal-overlay').length === 0) showLoader(false); event.target.value = null; }
}


    function updateLoaderText(text) {
    const loaderTextElement = document.getElementById('loader-text');
    if (loaderTextElement) {
        loaderTextElement.textContent = text;
    }
}


async function fetchFromKptArchive() {
    const cadNum = document.getElementById('cadastralInput').value.trim();
    if (!cadNum) { alert("Введите кадастровый номер."); return; }
       const cadParts = cadNum.split(':');
    if (cadParts.length >= 3 && parseInt(cadParts[2], 10) === 0) {
        alert("Загрузка данных по нулевому кварталу из архива не поддерживается, так как это может привести к зависанию браузера из-за большого объема данных");
        return;
    }
    resetAndShowLoader();
    try {
        updateLoaderText('Идет поиск файлов КПТ...');
        const quarterNum = cadNum.split(':').slice(0, 3).join(':');
        const searchPrefix = quarterNum.replace(/:/g, '_');

        let listResponse;
        try {
            listResponse = await fetch(`https://mapruapp.ru/storage/kpt?search=${searchPrefix}`);
        } catch (error) {
            if (error.message === "Failed to fetch") {
                throw new Error("нет ответа");
            }
            throw error;
        }

        if (!listResponse.ok) throw new Error(`Ошибка получения списка файлов для квартала ${quarterNum}.`);
        const fileList = await listResponse.json();
        if (!fileList || fileList.length === 0) throw new Error(`Архивы КПТ для квартала ${quarterNum} не найдены.`);

        updateLoaderText('Найден КПТ. Загружаем...');
        const latestFile = fileList.map(file => ({ name: file.name, date: new Date(file.name.match(/(\d{4}-\d{2}-\d{2})/)?.[1] || 0) })).sort((a, b) => b.date - a.date)[0];
        if (!latestFile) throw new Error("Не удалось определить последний файл КПТ.");

        let zipResponse;
        try {
            zipResponse = await fetch(`https://mapruapp.ru/storage/kpt/${latestFile.name}`);
        } catch (error) {
            if (error.message === "Failed to fetch") {
                throw new Error("Ошибка запроса");
            }
            throw error;
        }

        if (!zipResponse.ok) throw new Error(`Не удалось загрузить архив ${latestFile.name}.`);


        updateLoaderText('Распаковываем архив и ищем XML...');
        const zip = await JSZip.loadAsync(await zipResponse.blob());
        const xmlFile = Object.values(zip.files).find(f => f.name.toLowerCase().endsWith('.xml'));
        if (!xmlFile) throw new Error("XML-файл не найден в архиве КПТ.");

        updateLoaderText('Извлечение данных. Почти готово...');
        const xmlString = await xmlFile.async("string");
        const parser = new DOMParser();
        const xmlDoc = parser.parseFromString(xmlString, "text/xml");
        const reportTitle = createTitleFromXml(xmlDoc, latestFile.name);

        const isSpecificObject = cadParts.length > 3 && cadParts[3] !== '';

        if (isSpecificObject) {
            updateLoaderText('Поиск объекта в архиве...');
            const { data, isKptFile } = parseXml(xmlString, cadNum);
            displayResults(data, reportTitle, isKptFile);
            showResultsView();
            document.getElementById('selectObjectBtn').style.display = 'none';
        } else {
            const records = xmlDoc.querySelectorAll('land_record, build_record, construction_record');
            if (records.length > 0) {
                showResultsView();
                showLoader(false);
                extractAndShowObjectList(xmlString, records, latestFile.name, reportTitle);
                document.getElementById('selectObjectBtn').style.display = 'inline-flex';
            } else {
                throw new Error(`В найденном архиве КПТ (${latestFile.name}) не найдено объектов для отображения.`);
            }
        }

    } catch (error) {
        displayError(error);
    }
    finally {
        if (document.querySelectorAll('.modal-overlay').length === 0) {
            showLoader(false);
        }
        updateLoaderText('Поиск данных...');
    }
}

function createTitleFromXml(xmlDoc, fallbackFileName) {
    const regNum = getValue(xmlDoc, 'registration_number');
    const regDateRaw = getValue(xmlDoc, 'date_receipt_request_reg_authority_rights') || getValue(xmlDoc, 'date_formation');
    const regDate = formatDate(regDateRaw);

    if (regNum && regDate) {
        return `${regNum} от ${regDate}`;
    } else {
        return `Данные из файла: ${fallbackFileName}`;
    }
}

async function fetchFromNspd() {
    const cadNum = document.getElementById('cadastralInput').value.trim();
    if (!cadNum) { alert("Введите кадастровый номер."); return; }

    resetAndShowLoader();
    try {
        // Сбрасываем сохраненные объединения при загрузке НОВОГО объекта
        localStorage.removeItem('app_merged_indices'); savedMergedIndices = [];

        updateLoaderText('Поиск объекта ...');
        const data = await getNspdData(cadNum);
        
        // Сохраняем оригинал для возможности отката
        originalNspdData = JSON.parse(JSON.stringify(data));

        updateLoaderText('Получаем ответ. Обрабатываем данные...');
        const formattedDate = new Date().toLocaleDateString('ru-RU');
        
        displayResults(data, `Дата: ${formattedDate} (EPSG:3857)`);
        showResultsView();
    } catch (error) {
        displayError(error);
    }
    finally {
        showLoader(false);
        updateLoaderText('Загрузка данных...');
    }
}

function resetAndShowLoader() {
    document.getElementById('report-output').innerHTML = '';
    showResultsView();
    showLoader(true);
}

function reShowObjectSelectionDialog() {
            if (loadedKptData && loadedKptData.objectList.length > 0) {
        const { xmlString, fileName, objectList, title } = loadedKptData;
        const overlay = document.createElement('div');
            overlay.className = 'modal-overlay';
            const dialog = document.createElement('div');
            dialog.className = 'modal-dialog';

            dialog.innerHTML = `
                <h3>Выберите объект из файла "${fileName}" (${objectList.length} шт.)</h3>
                <input type="text" id="object-filter-input" onkeyup="filterObjectList(this)" placeholder="Фильтр по кадастровому номеру...">
            `;

            const list = document.createElement('ul');
            list.className = 'modal-list';
            objectList.forEach(obj => {
                const listItem = document.createElement('li');
                listItem.innerHTML = `<span>${obj.cadNum}</span><span class="obj-type">${obj.type}</span>`;
                listItem.onclick = () => {
                    document.body.removeChild(overlay); resetAndShowLoader();
                    setTimeout(() => {
                        try {
                            const { data, isKptFile } = parseXml(xmlString, obj.cadNum);
                             displayResults(data, title, isKptFile);
                            showResultsView();
                        } catch (e) { displayError(e); }
                        finally { showLoader(false); }
                    }, 10);
                };
                list.appendChild(listItem);
            });
            dialog.appendChild(list);
            overlay.appendChild(dialog);
            document.body.appendChild(overlay);
            overlay.onclick = (e) => { if (e.target === overlay) document.body.removeChild(overlay); };

            document.getElementById('object-filter-input').focus();
        } else {
            alert("Нет данных о загруженном файле для выбора объекта.");
        }
    }

 function filterObjectList(input) {
        const filterText = input.value.trim();
        const list = document.querySelector('.modal-list');
        const items = list.getElementsByTagName('li');

        const isDigitsOnly = /^\d+$/.test(filterText);

        for (let i = 0; i < items.length; i++) {
            const item = items[i];
            const itemText = item.querySelector('span:first-child').textContent || item.querySelector('span:first-child').innerText;

            let isMatch = false;

            if (filterText === '') {
                isMatch = true;
            }
            else if (isDigitsOnly) {
                isMatch = itemText.endsWith(':' + filterText);
            }
            else {
                isMatch = itemText.toLowerCase().includes(filterText.toLowerCase());
            }

            if (isMatch) {
                item.style.display = "flex";
            } else {
                item.style.display = "none";
            }
        }
    }


function extractAndShowObjectList(xmlString, records, fileName, title) {
    const objectList = [];
    const typeMap = { 'land_record': 'ЗУ', 'build_record': 'Здание', 'construction_record': 'Сооружение' };
    records.forEach(record => {
        const cadNum = getValue(record, 'object > common_data > cad_number');
        const type = typeMap[record.tagName] || 'Объект';
        if (cadNum) objectList.push({ cadNum, type });
    });
    loadedKptData = { xmlString, fileName, objectList, title };
    reShowObjectSelectionDialog();
}


  function createDataObject() { return { common: {}, params: {}, rights: [], restrictions: [], coordinates: [], coordinatesSystem: '', source: '', links: {} }; }
    function getValue(node, selector, d = '') { return (node.querySelector(selector)?.textContent || d).trim(); }
    function formatDate(d) { return d ? new Date(d).toLocaleDateString('ru-RU') : ''; }
    function formatDateTime(d) { return d ? new Date(d).toLocaleString('ru-RU') : ''; }
    function getShare(node) { if (!node) return ''; const share = node.querySelector('share'); return share ? `${getValue(share, 'numerator')}/${getValue(share, 'denominator')}` : getValue(node, 'share_description', ''); }
    function generateTableRow(key, value) { return value ? `<tr><td>${key}</td><td>${value}</td></tr>` : ''; }

async function getNspdData(cadNum) {
    try {
        const response = await fetch(`https://nspd.gov.ru/api/geoportal/v2/search/geoportal?thematicSearchId=1&query=${encodeURIComponent(cadNum)}`);
        if (!response.ok) throw new Error("Ошибка запроса");
        const json = await response.json();
        if (!json.data || !json.data.features.length === 0) throw new Error("Объект не найден");
        // Сохраняем геометрию перед парсингом для использования в расширенном отчете
        const feature = json.data.features[0];
        if (feature.geometry) {
            currentObjectGeometry = feature.geometry; // Сохраняем в глобальную переменную
        }
        return await parseNspdJson(feature);
    } catch (error) {
        if (error.message === "Failed to fetch") {
            throw new Error("Ошибка запроса");
        }
        throw error;
    }
}

function parseXml(xmlString, targetCadNum = null) {
    const parser = new DOMParser();
    const xmlDoc = parser.parseFromString(xmlString, "text/xml");
    if (xmlDoc.querySelector('parsererror')) {
        throw new Error('Ошибка парсинга XML-файла.');
    }

    const isKptFile = xmlDoc.querySelector('extract_cadastral_plan_territory') !== null;

    let mainRecordNode;
    const allRecords = xmlDoc.querySelectorAll('land_record, build_record, construction_record');

    if (targetCadNum) {
        mainRecordNode = Array.from(allRecords).find(r => getValue(r, 'object > common_data > cad_number') === targetCadNum);
    } else {
        mainRecordNode = allRecords[0];
    }

    if (!mainRecordNode) {
        throw new Error(`Объект ${targetCadNum || ''} не найден в XML.`);
    }

    const data = createDataObject();
    const objectTypeRaw = getValue(mainRecordNode, 'object > common_data > type > value');
    data.common.organ = getValue(xmlDoc, 'organ_registr_rights');
    data.common.docDate = formatDate(getValue(xmlDoc, 'date_formation'));
    data.common.docNum = getValue(xmlDoc, 'registration_number');
    data.common.cadNum = getValue(mainRecordNode, 'object > common_data > cad_number');
    data.common.assignDate = formatDate(getValue(mainRecordNode, 'record_info > registration_date'));
    data.common.objType = {
        'land_record': 'Земельный участок',
        'build_record': 'Здание',
        'construction_record': 'Сооружение'
    }[mainRecordNode.tagName] || objectTypeRaw;
    data.common.location = getValue(mainRecordNode, 'address_location > address > readable_address');
    data.common.cost = getValue(mainRecordNode, 'cost > value');
    data.common.status = getValue(xmlDoc, 'status');

    if (mainRecordNode.tagName === 'land_record') {
        data.params['Площадь'] = `${getValue(mainRecordNode, 'area > value')} ± ${getValue(mainRecordNode, 'area > inaccuracy')} кв. м.`;
        data.params['Категория земель'] = getValue(mainRecordNode, 'params > category > type > value');
        data.params['Разрешенное использование'] = getValue(mainRecordNode, 'params > permitted_use > permitted_use_established > by_document');
    } else {
        data.params['Назначение'] = getValue(mainRecordNode, 'params > purpose > value') || getValue(mainRecordNode, 'params > purpose');
        data.params['Наименование'] = getValue(mainRecordNode, 'params > name');
        if (mainRecordNode.tagName === 'build_record') {
            data.params['Площадь'] = `${getValue(mainRecordNode, 'params > area')} кв. м.`;
        }
        if (mainRecordNode.tagName === 'construction_record') {
            const extension = getValue(mainRecordNode, 'params > base_parameter > extension') || getValue(mainRecordNode, 'params > base_parameters > base_parameter > extension');
            if (extension) {
                data.params['Протяженность'] = `${extension} м.`;
            }
        }
    }

    const recordCadNum = data.common.cadNum;

    xmlDoc.querySelectorAll(`right_record`).forEach(rec => {
        const objectCadNumInRight = getValue(rec, 'object_cad_number');
        if (!isKptFile || objectCadNumInRight === recordCadNum || !objectCadNumInRight) {
            const holderNode = rec.querySelector('right_holders > right_holder');
            let holderName = [getValue(holderNode, 'individual surname'), getValue(holderNode, 'individual name'), getValue(holderNode, 'individual patronymic')].filter(Boolean).join(' ').trim() || getValue(holderNode, 'legal_entity name') || getValue(holderNode, 'public_formation municipality name') || 'не определено';
            data.rights.push({
                holder: holderName,
                type: getValue(rec, 'right_data > right_type > value'),
                number: getValue(rec, 'right_data > right_number'),
                date: formatDateTime(getValue(rec, 'record_info > registration_date')),
                share: getShare(rec.querySelector('right_data'))
            });
        }
    });
    
xmlDoc.querySelectorAll(`restrict_record`).forEach(rec => {
        const objectCadNumInRestriction = getValue(rec, 'object_cad_number');
        if (!isKptFile || objectCadNumInRestriction === recordCadNum || !objectCadNumInRestriction) {
            const docNode = rec.querySelector('underlying_documents > underlying_document');
            let basis = '';
            if (docNode) {
                const docName = getValue(docNode, 'document_name');
                const docNum = getValue(docNode, 'document_number');
                const docDate = formatDate(getValue(docNode, 'document_date'));
                
                let parts = [docName];
                if (docNum) parts.push(`№${docNum}`);
                if (docDate) parts.push(`от ${docDate}`);
                basis = parts.join(' ');
            }

            const periodInfoNode = rec.querySelector('period > period_info');
            let period = '';
            if(periodInfoNode) {
                period = getValue(periodInfoNode, 'deal_validity_time');
            }

            data.restrictions.push({
                type: getValue(rec, 'restrictions_encumbrances_data > restriction_encumbrance_type > value'),
                number: getValue(rec, 'restrictions_encumbrances_data > restriction_encumbrance_number'),
                date: formatDateTime(getValue(rec, 'record_info > registration_date')),
                basis: basis,
                period: period
            });
        }
    });

    const contoursNode = mainRecordNode.querySelector(':scope > contours_location, :scope > contours');

    data.coordinatesSystem = '';

    if (contoursNode) {
        data.coordinatesSystem = getValue(contoursNode, 'entity_spatial sk_id');

        const allSpatialElements = contoursNode.querySelectorAll('spatial_element, Spatial_Element');

        allSpatialElements.forEach((spatialElement, contourIndex) => {
            const currentContourCoordinates = [];

            spatialElement.querySelectorAll('ordinate, Ordinate').forEach(ord => {
                currentContourCoordinates.push({
                    x: parseFloat(getValue(ord, 'x, X')),
                    y: parseFloat(getValue(ord, 'y, Y')),
                    num: getValue(ord, 'ord_nmb, Num_Geopoint', ''),
                    delta: getValue(ord, 'delta_geopoint, Delta_Geopoint', ''),
                    zacrep: getValue(ord, 'geopoint_zacrep, Geopoint_Zacrep', ''),
                    contour: contourIndex + 1
                });
            });

            if (currentContourCoordinates.length > 0) {
                data.coordinates.push(currentContourCoordinates);
            }
        });
    }

    // Если координаты получены из XML, то currentObjectGeometry мы сформировать не можем (нет данных в EPSG:3857)
    // Либо нужно конвертировать, если известна СК. Для простоты - сбрасываем.
    currentObjectGeometry = null; 

    data.source = 'xml';
    return { data, isKptFile };
}

// Функция форматирования чисел с пробелами (для площадей и цен)
function formatNumberWithSpaces(number) {
    if (number === null || number === undefined) return '';
    const num = parseFloat(number);
    if (isNaN(num)) return number;
    
    // Если есть дробная часть
    if (String(num).includes('.')) {
        const parts = num.toFixed(2).split('.');
        parts[0] = parts[0].replace(/\B(?=(\d{3})+(?!\d))/g, ' ');
        return parts.join('.');
    }
    // Если целое
    return String(num).replace(/\B(?=(\d{3})+(?!\d))/g, ' ');
}

async function parseNspdJson(feature) {
    const options = feature.properties.options || {};
    const properties = feature.properties || {};
    const data = createDataObject();

    // --- Общие данные ---
    data.common.cadNum = options.cad_num || options.cad_number;
    data.common.objType = properties.categoryName || (feature.properties.categoryName || '').replace(' ЕГРН', '');
    data.common.location = options.readable_address || options.address_readable_address || options.address_by_document;
    data.common.cost = options.cost_value; // Основная цена используется в шапке
    data.common.status = options.status || options.common_data_status;
    
    // Дата присвоения
    data.common.assignDate = formatDate(options.date_created || options.land_record_reg_date || options.registration_date || options.build_record_registration_date);

    // Вспомогательная функция для добавления параметров только если есть значение
    const addParam = (key, value) => {
        if (value !== null && value !== undefined && value !== '' && value !== '-' && value !== 'null') {
            data.params[key] = value;
        }
    };

    // --- Детальные характеристики ---
    
    // Адрес (если отличается от местоположения или для надежности)
    // addParam('Адрес', options.readable_address); 

    // Данные о стоимости (детали)
    addParam('Дата определения стоимости', formatDate(options.cost_determination_date));
    addParam('Дата внесения стоимости', formatDate(options.cost_registration_date || options.cost_approval_date));
    addParam('Основание определения стоимости', options.determination_couse);

    // Характеристики ЗЕМЕЛЬНОГО УЧАСТКА
    if (data.common.objType.includes("Земельные участки")) {
        addParam('Вид участка', options.subtype || options.land_record_subtype);
        
        let areaText = null;
        if (options.specified_area) areaText = `${formatNumberWithSpaces(options.specified_area)} м² (уточненная)`;
        else if (options.land_record_area_verified) areaText = `${formatNumberWithSpaces(options.land_record_area_verified)} м² (уточненная)`;
        else if (options.declared_area) areaText = `${formatNumberWithSpaces(options.declared_area)} м² (декларированная)`;
        else if (options.land_record_area_declaration) areaText = `${formatNumberWithSpaces(options.land_record_area_declaration)} м² (декларированная)`;
        else if (options.land_record_area) areaText = `${formatNumberWithSpaces(options.land_record_area)} м²`;
        addParam('Площадь', areaText);
        
        addParam('Погрешность площади', options.area_accuracy ? `+/- ${options.area_accuracy} м²` : null);
        addParam('Категория земель', options.land_record_category_type || options.category_type);
        addParam('Разрешенное использование', options.permitted_use_established_by_document || options.permitted_use);
        addParam('Использование по документу', options.utilization_by_document);
        
        // Связанные ОКС
        const oknList = await fetchLinkedObjects(feature);
        if (oknList && oknList.length > 0) {
             data.links['ОКС на земельном участке'] = oknList;
        }

    } 
    // Характеристики ЗДАНИЯ
    else if (data.common.objType.includes("Здания")) {
        const areaVal = options.area || options.build_record_area;
        addParam('Площадь', areaVal ? `${formatNumberWithSpaces(areaVal)} м²` : null);
        addParam('Наименование', options.name || options.building_name);
        addParam('Назначение', options.purpose);
        addParam('Вид объекта', options.build_record_type_value || options.object_type);
        addParam('Количество этажей', options.floors);
        addParam('Подземных этажей', options.underground_floors);
        addParam('Год постройки', options.year_built);
        addParam('Год ввода в эксплуатацию', options.year_commissioning || options.year_commisioning);
        addParam('Материал стен', options.materials || options.wall_material);
        
        const isHeritage = options.cultural_heritage_val === "true" || options.cultural_heritage_val === true ? "Да" : (typeof options.cultural_heritage_val === 'string' ? options.cultural_heritage_val : null);
        addParam('Культурное наследие', isHeritage);
        addParam('Физический износ', options.physical_wear ? `${options.physical_wear}%` : null);
        addParam('УПКС', options.cost_index);
        
        const landList = await fetchLinkedObjects(feature);
        if (landList && landList.length > 0) data.links['Расположен на ЗУ'] = landList;
        addParam('Объединенные КН', options.united_cad_numbers);

    } 
    // Характеристики ПОМЕЩЕНИЯ
    else if (data.common.objType.includes("Помещения")) {
        addParam('Площадь', options.area ? `${formatNumberWithSpaces(options.area)} м²` : null);
        addParam('Назначение', options.purpose);
        addParam('Тип помещения', options.params_type || options.type);
        addParam('Вид жилого помещения', options.type_living_quarters);
        addParam('Наименование', options.name);
        
        const floorStr = Array.isArray(options.floor) ? options.floor.join(', ') : options.floor;
        addParam('Этаж', floorStr);
        addParam('Номер на плане', options.floor_plan_number || options.plan_number);
        addParam('КН родительского здания', options.parent_cad_number);
        
        const isCommon = options.common_property === "true" || options.common_property === true ? "Да" : null;
        addParam('Общее имущество', isCommon);
        
        const landList = await fetchLinkedObjects(feature);
        if (landList && landList.length > 0) data.links['Расположен на ЗУ'] = landList;

    } 
    // Характеристики СООРУЖЕНИЯ
    else if (data.common.objType.includes("Сооружения")) {
        addParam('Площадь', options.params_area ? `${formatNumberWithSpaces(options.params_area)} м²` : null);
        addParam('Наименование', options.params_name || options.name);
        addParam('Назначение', options.params_purpose || options.purpose);
        addParam('Вид объекта', options.object_type_value);
        
        addParam('Протяженность', (options.params_extension || options.extension) ? `${options.params_extension || options.extension} м` : null);
        addParam('Объем', options.params_volume ? `${options.params_volume} м³` : null);
        addParam('Высота', options.params_height ? `${options.params_height} м` : null);
        addParam('Глубина', options.params_depth ? `${options.params_depth} м` : null);
        addParam('Глубина залегания', options.params_occurence_depth ? `${options.params_occurence_depth} м` : null);
        addParam('Площадь застройки', options.params_built_up_area ? `${options.params_built_up_area} м²` : null);

        addParam('Год постройки', options.params_year_built || options.year_built);
        addParam('Год ввода в экспл.', options.params_year_commisioning || options.year_commisioning);
        
        const landList = await fetchLinkedObjects(feature);
        if (landList && landList.length > 0) data.links['Расположен на ЗУ'] = landList;
    } 
    // Машино-места
    else if (data.common.objType.includes("Машино")) {
         addParam('Площадь', options.area ? `${formatNumberWithSpaces(options.area)} м²` : null);
         addParam('Этаж', options.floor);
         addParam('Номер на плане', options.floor_plan_number);
         addParam('КН здания/сооружения', options.parent_cad_number);
    }

    // Общие поля для всех (права, ограничения, примечания)
    
    // Формирование права
    let rightDisplay = null;
    if (options.right_type) {
        rightDisplay = options.right_type;
        if (options.ownership_type) rightDisplay += ` (${options.ownership_type})`;
    } else if (options.ownership_type) {
        rightDisplay = `Не зарегистрировано (${options.ownership_type})`;
    }
    addParam('Тип права', rightDisplay);
    addParam('Форма собственности', options.ownership_type);
    
    addParam('Ограничения и обременения', options.encumbrances || options.restrictions);
    addParam('Особые отметки', options.special_notes || options.notes);
    addParam('Кадастровый квартал', options.quarter_cad_number);
    addParam('Дата обновления данных', formatDate(properties.systemInfo?.updated));
    addParam('Дата внесения записи', formatDate(properties.systemInfo?.inserted));

    // Координаты системы
    data.coordinatesSystem = 'EPSG:3857';

    // Обработка геометрии для отрисовки
    if (feature.geometry) {
        // Если точка, добавляем в параметры
        if (feature.geometry.type === 'Point' && Array.isArray(feature.geometry.coordinates)) {
             const x = feature.geometry.coordinates[0];
             const y = feature.geometry.coordinates[1];
             addParam('Координаты (X, Y)', `${formatNumberWithSpaces(x)}; ${formatNumberWithSpaces(y)}`);
        }

        const extractCoords = (geom) => {
            if (!geom) return;
            let contourCounter = 1;
            if (geom.type === 'Polygon') {
                geom.coordinates.forEach(ring => {
                    data.coordinates.push(ring.map((c, i) => ({ x: c[0], y: c[1], num: i + 1, contour: contourCounter })));
                    contourCounter++;
                });
            } else if (geom.type === 'MultiPolygon') {
                geom.coordinates.forEach(poly => {
                    data.coordinates.push(poly[0].map((c, i) => ({ x: c[0], y: c[1], num: i + 1, contour: contourCounter })));
                    contourCounter++;
                });
            } else if (geom.type === 'LineString') {
                data.coordinates.push(geom.coordinates.map((c, i) => ({ x: c[0], y: c[1], num: i + 1, contour: 1 })));
            }
        };
        extractCoords(feature.geometry);
    }
    
    data.source = 'nspd';
    return data;
}

function displayResults(data, title, isKptFile = false) {
    const output = document.getElementById('report-output');
    const pages = [];

    // === СТРАНИЦА 1: Основные характеристики ===
    let page1Html = `
        <div class="doc-header">
            <h1>Сведения об объекте недвижимости</h1>
            <div class="doc-meta">${title}</div>
        </div>
        
        <div class="object-type-block">
            <div class="object-type">${data.common.objType || 'Объект недвижимости'}</div>
            <div class="object-type-hint">вид объекта недвижимости</div>
        </div>
        
        <table class="main-info-table">
            ${generateTableRow('Кадастровый номер', data.common.cadNum)}
            ${generateTableRow('Дата присвоения кадастрового номера', data.common.assignDate)}
            ${generateTableRow('Местоположение', data.common.location)}
            ${Object.entries(data.params).map(([key, value]) => generateTableRow(key, value)).join('')}
            ${generateTableRow('Кадастровая стоимость', data.common.cost ? `${new Intl.NumberFormat('ru-RU').format(data.common.cost)} руб.` : '')}
            ${Object.entries(data.links || {}).map(([key, value]) => generateTableRow(key, Array.isArray(value) ? value.join(', ') : value)).join('')}
            ${generateTableRow('Статус', data.common.status)}`;
    
    // Права
    if (data.rights && data.rights.length > 0) {
        page1Html += `
            <tr class="rights-section-header">
                <td colspan="2">Сведения о зарегистрированных правах</td>
            </tr>`;
        data.rights.forEach((right, i) => {
            page1Html += `
                <tr class="rights-row">
                    <td>Право ${i + 1}: ${right.type || ''}</td>
                    <td>
                        <strong>Правообладатель:</strong> ${right.holder || 'не определено'}<br>
                        ${right.number ? `<strong>Номер:</strong> ${right.number}` : ''}
                        ${right.date ? ` от ${right.date}` : ''}
                        ${right.share ? `<br><strong>Доля:</strong> ${right.share}` : ''}
                    </td>
                </tr>`;
        });
    }
    
    // Ограничения
    if (data.restrictions && data.restrictions.length > 0) {
        page1Html += `
            <tr class="rights-section-header">
                <td colspan="2">Сведения об ограничениях прав и обременениях</td>
            </tr>`;
        data.restrictions.forEach((r, i) => {
            page1Html += `
                <tr class="rights-row">
                    <td>Обременение ${i + 1}: ${r.type || ''}</td>
                    <td>
                        ${r.number ? `<strong>Номер:</strong> ${r.number}` : ''}
                        ${r.date ? ` от ${r.date}` : ''}
                        ${r.period ? `<br><strong>Срок:</strong> ${r.period}` : ''}
                        ${r.basis ? `<br><strong>Основание:</strong> ${r.basis}` : ''}
                    </td>
                </tr>`;
        });
    }
    
    page1Html += `</table>`;
    pages.push(page1Html);

    // === КООРДИНАТЫ И ПЛАН (с разбивкой на страницы) ===
    if (data.coordinates && data.coordinates.length > 0) {
        const canvasId = 'plan-canvas';

        // Исправление нумерации (1 = последняя)
        data.coordinates.forEach(contour => {
            if (contour.length > 2) {
                const first = contour[0];
                const last = contour[contour.length - 1];
                if (Math.abs(first.x - last.x) < 0.001 && Math.abs(first.y - last.y) < 0.001) {
                    last.num = first.num;
                }
            }
        });

        const flatCoords = data.coordinates.flat();
        const hasZacrep = flatCoords.some(c => c.zacrep);
        const hasDelta = flatCoords.some(c => c.delta);
        const hasMultipleContours = data.coordinates.length > 1;

        // --- НАСТРОЙКИ ПАГИНАЦИИ ---
        // Сколько строк влезает на страницу с картой
        const rowsFirstPage = 15; 
        // Сколько строк влезает на полную страницу
        const rowsNextPages = 40; 

        // 1. Формируем первую страницу с картой и началом таблицы
        const firstBatch = flatCoords.slice(0, rowsFirstPage);
        
        let planPageHtml = `
            <div class="coord-header">
                <h3>Описание местоположения объекта недвижимости</h3>
            </div>
            
            <table class="coord-info-table">
                <tr>
                    <td>Кадастровый номер:</td>
                    <td>${data.common.cadNum}</td>
                </tr>
                ${data.coordinatesSystem ? `<tr><td>Система координат:</td><td>${data.coordinatesSystem}</td></tr>` : ''}
            </table>
            
            <div class="section-title">Схема расположения</div>
            <div class="plan-container">
                <canvas id="${canvasId}"></canvas>
            </div>
            
            <div class="section-title">Сведения о характерных точках контура</div>
            ${generateCoordsTable(firstBatch, hasMultipleContours, hasDelta, hasZacrep)}`;
        
        pages.push(planPageHtml);

        // 2. Если остались точки, создаем дополнительные страницы
        if (flatCoords.length > rowsFirstPage) {
            let remaining = flatCoords.slice(rowsFirstPage);
            
            while (remaining.length > 0) {
                const batch = remaining.slice(0, rowsNextPages);
                remaining = remaining.slice(rowsNextPages);

                let nextPageHtml = `
                    <div class="coord-header">
                        <h3>Сведения о точках (продолжение)</h3>
                    </div>
                    ${generateCoordsTable(batch, hasMultipleContours, hasDelta, hasZacrep)}
                `;
                pages.push(nextPageHtml);
            }
        }
    }

    // Вспомогательная функция для генерации HTML таблицы
    function generateCoordsTable(coords, hasContour, hasDelta, hasZacrep) {
        return `
            <table class="coordinates-table">
                <thead>
                    <tr>
                        <th style="width: 10%">№ точки</th>
                        ${hasContour ? '<th style="width: 10%">Контур</th>' : ''}
                        <th>X</th>
                        <th>Y</th>
                        ${hasDelta ? '<th>Погрешность, м</th>' : ''}
                        ${hasZacrep ? '<th>Закрепление</th>' : ''}
                    </tr>
                </thead>
                <tbody>
                    ${coords.map(c => `
                        <tr>
                            <td>${c.num || ''}</td>
                            ${hasContour ? `<td>${c.contour}</td>` : ''}
                            <td>${c.x.toFixed(2)}</td>
                            <td>${c.y.toFixed(2)}</td>
                            ${hasDelta ? `<td>${c.delta || ''}</td>` : ''}
                            ${hasZacrep ? `<td>${c.zacrep || ''}</td>` : ''}
                        </tr>
                    `).join('')}
                </tbody>
            </table>`;
    }

    // === СБОРКА И ВЫВОД ===
    let finalHtml = '';
    pages.forEach((pageContent, i) => {
        finalHtml += `<div class="page ${savedOrientation === 'portrait' ? 'portrait' : ''}">`;
        finalHtml += pageContent;
        
        finalHtml += `<div class="merge-control">`;
        finalHtml += `
            <button onclick="toggleAllOrientations()" title="Сменить ориентацию страницы">
                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="23 4 23 10 17 10"></polyline><path d="M20.49 15a9 9 0 1 1-2.12-9.36L23 10"></path></svg>
            </button>`;

        if (i < pages.length - 1) {
            finalHtml += `
            <button onclick="toggleMerge(this)" title="Объединить со следующей">
                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"/>
                    <rect x="8" y="2" width="8" height="4" rx="1" ry="1"/>
                </svg>
            </button>`;
        } else {
            finalHtml += `<div style="width: 1px;"></div>`;
        }

        finalHtml += `
            <button onclick="savePageToPdf(this)" title="Сохранить как PDF (экранная версия)">
                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path>
                    <polyline points="14 2 14 8 20 8"></polyline>
                    <line x1="16" y1="13" x2="8" y2="13"></line>
                    <line x1="16" y1="17" x2="8" y2="17"></line>
                    <polyline points="10 9 9 9 8 9"></polyline>
                </svg>
                
            </button>
        </div>`;
        finalHtml += `</div>`;
    });

    output.innerHTML = finalHtml;

    // Применение стилей и логики кнопок
    const printStyleElement = document.getElementById('print-orientation-style');
    const allPages = document.querySelectorAll('#report-output .page');
    
    if (savedOrientation === 'portrait') {
        allPages.forEach(page => page.classList.add('portrait'));
        printStyleElement.innerHTML = '@media print { @page { size: portrait; } }';
    } else {
        allPages.forEach(page => page.classList.remove('portrait'));
        printStyleElement.innerHTML = '@media print { @page { size: landscape; } }';
    }

    const convertBtn = document.getElementById('convertToMskBtn');
    // Показываем кнопку расширенного отчета только если есть геометрия и это данные НСПД
    const extendedReportBtn = document.getElementById('extendedReportBtn');
    
    if (data.source === 'nspd' && currentObjectGeometry) {
        if (isAutoMskEnabled) {
            setTimeout(() => convertNspdCoordinatesToMsk(data), 50);
            // extendedReportBtn будет показан после выполнения
        } else {
            // Если авто-МСК выключен, показываем кнопку конвертации
            convertBtn.style.display = 'inline-flex';
            const newBtn = convertBtn.cloneNode(true);
            newBtn.style.background = '';
            newBtn.querySelector('span').textContent = 'Координаты в МСК';
            newBtn.onclick = () => {
                localStorage.setItem('app_auto_msk', 'true');
                isAutoMskEnabled = true;
                convertNspdCoordinatesToMsk(data);
            };
            convertBtn.parentNode.replaceChild(newBtn, convertBtn);
        }
        // Показываем кнопку расширенного отчета, так как геометрия есть
        extendedReportBtn.style.display = 'inline-flex';
    } else if (data.source === 'nspd_converted') {
        convertBtn.style.display = 'inline-flex';
        const newBtn = convertBtn.cloneNode(true);
        newBtn.style.background = 'linear-gradient(135deg, #757575 0%, #616161 100%)';
        newBtn.querySelector('span').textContent = 'Координаты в EPSG3857';
        newBtn.onclick = () => {
            localStorage.setItem('app_auto_msk', 'false');
            isAutoMskEnabled = false;
            if (originalNspdData) {
                displayResults(originalNspdData, title.replace(/\(.*\)/, '(EPSG:3857)'));
            }
        };
        convertBtn.parentNode.replaceChild(newBtn, convertBtn);
        // Показываем кнопку расширенного отчета, так как geometry была сохранена из originalData
        extendedReportBtn.style.display = 'inline-flex';
    } else {
        convertBtn.style.display = 'none';
        extendedReportBtn.style.display = 'none'; // Не показываем для XML без геометрии НСПД
    }

    if (data.coordinates && data.coordinates.length > 0) {
        drawPlan(data.coordinates, 'plan-canvas', data.source);
    }

    restoreMergeState();
}

function filterMskList(input) {
    const filterText = input.value.trim().toLowerCase();
    const list = input.parentElement.querySelector('.modal-list');
    if (!list) return;
    const items = list.getElementsByTagName('li');
    for (let i = 0; i < items.length; i++) {
        const item = items[i];
        const itemText = (item.textContent || item.innerText).toLowerCase();
        if (itemText.includes(filterText)) {
            item.style.display = "flex";
        } else {
            item.style.display = "none";
        }
    }
}

function showMskSelector(originalData) {
    // Проверяем, что переменная из sk.js загружена и является массивом
    if (typeof COORDINATE_SYSTEMS === 'undefined' || !Array.isArray(COORDINATE_SYSTEMS)) {
        alert('Ошибка: База систем координат (sk.js) не загружена или имеет неверный формат.');
        return;
    }

    const overlay = document.createElement('div');
    overlay.className = 'modal-overlay';

    const dialog = document.createElement('div');
    // Добавляем новые классы для стилизации
    dialog.className = 'modal-dialog selector-modal glass-panel';

    dialog.innerHTML = `
        <h3>Не удалось определить МСК. Выберите систему координат:</h3>
        <input type="text" id="msk-filter-input" onkeyup="filterMskList(this)" placeholder="Фильтр по названию, коду региона или EPSG...">
    `;

    const list = document.createElement('ul');
    list.className = 'modal-list';

    // Получаем все системы, кроме пункта для ручного ввода
    const systems = COORDINATE_SYSTEMS.filter(sys => sys.value !== 'custom');

    systems.forEach(system => {
        const listItem = document.createElement('li');
        // Новая, более информативная структура элемента списка
        listItem.innerHTML = `
            <div>
                <span class="item-title">${system.text}</span>
                <span class="item-subtitle">${system.value}</span>
            </div>
        `;
        listItem.onclick = () => {
            document.body.removeChild(overlay);
            performConversion(originalData, system);
        };
        list.appendChild(listItem);
    });

    dialog.appendChild(list);
    overlay.appendChild(dialog);
    document.body.appendChild(overlay);
    overlay.onclick = (e) => { if (e.target === overlay) document.body.removeChild(overlay); };
    document.getElementById('msk-filter-input').focus();
}


function performConversion(originalData, targetSystem) {
    try {
        const data = JSON.parse(JSON.stringify(originalData));
        if (!targetSystem) {
            alert('Целевая система координат не выбрана.');
            return;
        }
        if ((targetSystem.offsetX === undefined || targetSystem.offsetX === 0) && (targetSystem.offsetY === undefined || targetSystem.offsetY === 0)) {
            alert("ВНИМАНИЕ: Настройки смещения для этой МСК не настроены, координаты в выписке могут быть неверны.");
        }
        const sourceSystemDef = COORDINATE_SYSTEMS.find(s => s.value === 'EPSG:3857');
        if (!sourceSystemDef || !targetSystem.def) {
            alert('Отсутствует определение для исходной или целевой системы координат.');
            return;
        }
        proj4.defs('EPSG:3857', sourceSystemDef.def);
        proj4.defs(targetSystem.value, targetSystem.def);
        const offsetX = targetSystem.offsetX || 0;
        const offsetY = targetSystem.offsetY || 0;
        data.coordinates = data.coordinates.map(contour => {
            const convertedContour = contour.map(point => {
                const convertedPoint = proj4('EPSG:3857', targetSystem.value, [point.x, point.y]);
                const newPoint = { ...point
                };
                newPoint.x = convertedPoint[1] + offsetX;
                newPoint.y = convertedPoint[0] + offsetY;
                return newPoint;
            });
            const reversedContour = convertedContour.reverse();
            return reversedContour.map((point, index) => ({ ...point,
                num: index + 1
            }));
        });
        data.coordinatesSystem = targetSystem.text;
        data.source = 'nspd_converted';
        resetAndShowLoader();
      //  updateLoaderText('Пересчет координат и перерисовка...');
        setTimeout(() => {
            const formattedDate = new Date().toLocaleDateString('ru-RU');
            displayResults(data, `Дата: ${formattedDate} (${data.coordinatesSystem})`);
            showLoader(false);
        }, 250);
    } catch (e) {
        console.error("Ошибка при конвертации координат:", e);
        alert(`Произошла ошибка при конвертации: ${e.message}`);
        showLoader(false);
    }
}

function convertNspdCoordinatesToMsk(originalData) {
    const cadNum = originalData.common.cadNum;
    if (!cadNum || typeof MskFinder === 'undefined' || typeof proj4 === 'undefined' || typeof COORDINATE_SYSTEMS === 'undefined') {
        alert('Ошибка: Необходимые для конвертации компоненты не загружены.');
        return;
    }
    const mskCode = MskFinder.findMskCode(cadNum);
    if (!mskCode) {
        showMskSelector(originalData);
        return;
    }
    // ИСПРАВЛЕННАЯ СТРОКА: дефис заменен на пробел
    const searchString = `МСК ${mskCode}`; 
    const targetSystem = COORDINATE_SYSTEMS.find(system => system.text && system.text.includes(searchString));
    if (!targetSystem) {
        showMskSelector(originalData);
        return;
    }
    performConversion(originalData, targetSystem);
}

function toggleMerge(button) {
    const page = button.closest('.page');
    if (!page) return;

    page.classList.toggle('no-break');

    // Обновляем иконку
    if (page.classList.contains('no-break')) {
        button.innerHTML = `
            <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3"/>
            </svg>
            `;
    } else {
        button.innerHTML = `
            <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"/>
                <rect x="8" y="2" width="8" height="4" rx="1" ry="1"/>
            </svg>
            `;
    }
    
    // Сохраняем состояние в LocalStorage
    saveMergeState();
}

function toggleAllOrientations() {
    const allPages = document.querySelectorAll('#report-output .page');
    if (allPages.length === 0) return;

    const printStyleElement = document.getElementById('print-orientation-style');
    // Определяем текущую ориентацию по первой странице (так как меняем все сразу)
    // Если у первой страницы есть класс portrait, значит мы в портрете
    const isCurrentlyPortrait = allPages[0].classList.contains('portrait');
    
    const newOrientation = isCurrentlyPortrait ? 'landscape' : 'portrait';

    allPages.forEach(page => {
        // Если newOrientation portrait -> добавляем класс
        // Если newOrientation landscape -> убираем класс (так как по дефолту в CSS landscape)
        if (newOrientation === 'portrait') {
            page.classList.add('portrait');
        } else {
            page.classList.remove('portrait');
        }
    });

    if (printStyleElement) {
        printStyleElement.innerHTML = `@media print { @page { size: ${newOrientation}; } }`;
    }
    
    // Сохраняем в глобальную переменную и LocalStorage
    savedOrientation = newOrientation;
    localStorage.setItem('app_orientation', newOrientation);
}

async function fetchLinkedObjects(feature) {
    if (!feature || !feature.properties) return null;

    const geomId = feature.id;
    const categoryId = feature.properties.category;
    const categoryName = feature.properties.categoryName;

    let path = '';
    if (categoryName === "Земельные участки ЕГРН") {
        path = `/api/geoportal/v1/tab-group-data?tabClass=objectsList&categoryId=${categoryId}&geomId=${geomId}`;
    } else {
        path = `/api/geoportal/v1/tab-values-data?tabClass=landLinks&categoryId=${categoryId}&geomId=${geomId}`;
    }

    if (!geomId || !categoryId) {
        console.error("Отсутствует geomId или categoryId, невозможно запросить связанные объекты.");
        return null;
    }

    try {
        const res = await fetch(`https://nspd.gov.ru${path}`);
        if (!res.ok) return null;
        const data = await res.json();
        return (data?.object?.[0]?.value || data?.value) || null;
    } catch (e) {
        console.error("Ошибка при запросе связанных объектов:", e);
        return null;
    }
}

    function drawPlan(contours, canvasId, source) {
        const canvas = document.getElementById(canvasId); if (!canvas) return; const ctx = canvas.getContext('2d'); const container = canvas.parentElement;
        canvas.width = container.clientWidth > 0 ? container.clientWidth : 800; canvas.height = 500;
        const allCoords = contours.flat(); if(allCoords.length < 1) return;

        const allX = allCoords.map(c => c.x), allY = allCoords.map(c => c.y);
        const minX = Math.min(...allX), maxX = Math.max(...allX);
        const minY = Math.min(...allY), maxY = Math.max(...allY);

        const dataWidth = (source === 'nspd') ? maxX - minX : maxY - minY;
        const dataHeight = (source === 'nspd') ? maxY - minY : maxX - minX;
        if(dataWidth <= 0 || dataHeight <= 0) return;

        const margin = 40;
        const canvasDrawWidth = canvas.width - 2 * margin;
        const canvasDrawHeight = canvas.height - 2 * margin;

        const scale = Math.min(canvasDrawWidth / dataWidth, canvasDrawHeight / dataHeight);

        const scaledDataWidth = dataWidth * scale;
        const scaledDataHeight = dataHeight * scale;

        const horizontalPadding = canvasDrawWidth - scaledDataWidth;
        const verticalPadding = canvasDrawHeight - scaledDataHeight;

        const offsetX = horizontalPadding / 2;
        const offsetY = verticalPadding / 2;

        ctx.clearRect(0, 0, canvas.width, canvas.height);
        contours.forEach(contour => {
            if (contour.length === 0) return; ctx.beginPath();
            contour.forEach((c, i) => {
                let canvasX, canvasY;

                if (source === 'nspd') {
                    canvasX = margin + offsetX + (c.x - minX) * scale;
                    canvasY = (canvas.height - margin - offsetY) - (c.y - minY) * scale;
                }
                else {
                    canvasX = margin + offsetX + (c.y - minY) * scale;
                    canvasY = (canvas.height - margin - offsetY) - (c.x - minX) * scale;
                }

                i === 0 ? ctx.moveTo(canvasX, canvasY) : ctx.lineTo(canvasX, canvasY);
            });
            const first = contour[0], last = contour[contour.length - 1];
            if (contour.length > 2 && Math.abs(first.x - last.x) < 0.01 && Math.abs(first.y - last.y) < 0.01) {
                ctx.closePath();
                ctx.fillStyle = 'rgba(0, 123, 255, 0.1)';
                ctx.fill();
            }
            ctx.strokeStyle = '#007bff'; ctx.lineWidth = 2; ctx.stroke();
        });
    }
    
async function savePageToPdf(button) {
    const pages = document.querySelectorAll('.page');
    const allControls = document.querySelectorAll('.merge-control');
    
    // Скрываем кнопки управления
    allControls.forEach(el => el.style.display = 'none');

    showLoader(true);
    updateLoaderText('Генерация PDF...');

    try {
        const { jsPDF } = window.jspdf;
        
        // Определяем ориентацию по первой странице
        const isPortrait = pages[0].classList.contains('portrait');
        const orientation = isPortrait ? 'p' : 'l';
        
        // Создаем документ
        const doc = new jsPDF(orientation, 'mm', 'a4');
        const pdfWidth = doc.internal.pageSize.getWidth();
        const pdfHeight = doc.internal.pageSize.getHeight();

        for (let i = 0; i < pages.length; i++) {
            const page = pages[i];
            
            updateLoaderText(`Обработка страницы ${i + 1} из ${pages.length}...`);
            
            // Если это не первая страница, добавляем новый лист
            if (i > 0) {
                doc.addPage();
            }

            // Рендерим страницу в canvas с помощью html2canvas
            const canvas = await html2canvas(page, {
                scale: 2, // Увеличиваем качество
                useCORS: true,
                logging: false,
                backgroundColor: '#ffffff',
                // Важно: указываем фиксированную ширину для корректного рендера
                windowWidth: page.scrollWidth,
                windowHeight: page.scrollHeight
            });

            // Конвертируем canvas в изображение
            const imgData = canvas.toDataURL('image/jpeg', 0.95);
            
            // Вычисляем размеры для вписывания в страницу PDF
            const imgWidth = canvas.width;
            const imgHeight = canvas.height;
            
            // Вычисляем масштаб, чтобы изображение вписалось в страницу с отступами
            const margin = 5; // отступ в мм
            const maxWidth = pdfWidth - (margin * 2);
            const maxHeight = pdfHeight - (margin * 2);
            
            const ratio = Math.min(maxWidth / imgWidth, maxHeight / imgHeight);
            
            const finalWidth = imgWidth * ratio;
            const finalHeight = imgHeight * ratio;
            
            // Центрируем изображение на странице
            const x = (pdfWidth - finalWidth) / 2;
            const y = (pdfHeight - finalHeight) / 2;

            // Добавляем изображение в PDF
            doc.addImage(imgData, 'JPEG', x, y, finalWidth, finalHeight);
        }
        
        // Формируем имя файла
        const cadNum = document.querySelector('.page table td:nth-child(2)')?.textContent?.trim() || 'report';
        const safeName = cadNum.replace(/[:\s]/g, '_');
        const timestamp = new Date().toISOString().slice(0, 10);
        
        doc.save(`${safeName}_${timestamp}.pdf`);

    } catch (error) {
        console.error("Ошибка при создании PDF:", error);
        alert("Не удалось создать PDF: " + error.message);
    } finally {
        // Возвращаем кнопки управления
        allControls.forEach(el => el.style.display = 'flex');
        showLoader(false);
        updateLoaderText('Загрузка данных...');
    }
}

function formatCadastralNumber(input) {
        let value = input.value.replace(/\D/g, ''); 
        let formatted = '';
        if (value.length > 0) formatted += value.slice(0, 2); 
        if (value.length > 2) formatted += ':' + value.slice(2, 4);
        
        // Логика для 6-значных регионов
        const isSixDigits = sixDigitsRegions.includes(value.slice(0, 2)); 
        const digitsAfter = isSixDigits ? 6 : 7;
        
        if (value.length > 4) formatted += ':' + value.slice(4, 4 + digitsAfter); 
        if (value.length > 4 + digitsAfter) formatted += ':' + value.slice(4 + digitsAfter);
        
        input.value = formatted;
    }

    // --- ЛОГИКА РАСШИРЕННОГО ОТЧЕТА ---

    function showExtendedReportDialog() {
        if (!currentObjectGeometry) {
            alert('Необходимо сначала загрузить объект с геометрией.');
            return;
        }

        const overlay = document.createElement('div');
        overlay.className = 'modal-overlay';
        const dialog = document.createElement('div');
        dialog.className = 'modal-dialog selector-modal glass-panel';

        dialog.innerHTML = `
            <h3>Выберите разделы для расширенного отчета</h3>
            <ul class="checkbox-list">
                <li>
                    <input type="checkbox" id="check-zouit" checked>
                    <label for="check-zouit">Зоны с особыми условиями (ЗОУИТ)</label>
                </li>
                <li>
                    <input type="checkbox" id="check-zones" checked>
                    <label for="check-zones">Территориальные зоны</label>
                </li>
                <li>
                    <input type="checkbox" id="check-settlements" checked>
                    <label for="check-settlements">Населенные пункты</label>
                </li>
                <li>
                    <input type="checkbox" id="check-municipal" checked>
                    <label for="check-municipal">Муниципальные образования</label>
                </li>
                <li>
                    <input type="checkbox" id="check-forestry" checked>
                    <label for="check-forestry">Лесничества</label>
                </li>
            </ul>
            <div style="text-align: center;">
                <button id="generateReportBtn" onclick="generateExtendedReport(this)">Сформировать</button>
            </div>
        `;

        overlay.appendChild(dialog);
        document.body.appendChild(overlay);
        overlay.onclick = (e) => { if (e.target === overlay) document.body.removeChild(overlay); };
    }

   const delay = ms => new Promise(res => setTimeout(res, ms));

    async function generateExtendedReport(btn) {
        const overlay = btn.closest('.modal-overlay');
        // Не скрываем окно сразу, чтобы видеть прогресс, но блокируем повторные клики
        const btnOriginalText = btn.textContent;
        btn.disabled = true;
        btn.style.opacity = '0.7';
        
        showLoader(true);

        const geoJSON = currentObjectGeometry;
        const results = [];

        // Конфигурация слоев для проверки
        const layersToCheck = [
            { id: 'check-zouit', layerId: 36940, type: 'zouit', name: 'ЗОУИТ' },
            { id: 'check-zones', layerId: 36315, type: 'zone', name: 'Территориальные зоны' },
            { id: 'check-settlements', layerId: 36281, type: 'settlement', name: 'Населенные пункты' },
            { id: 'check-municipal', layerId: 36278, type: 'municipal', name: 'Муниципальные обр.' },
            { id: 'check-forestry', layerId: 36314, type: 'forestry', name: 'Лесничества' }
        ];

        try {
            // ПОСЛЕДОВАТЕЛЬНЫЙ запуск запросов с паузой
            for (const item of layersToCheck) {
                const checkbox = document.getElementById(item.id);
                if (checkbox && checkbox.checked) {
                    updateLoaderText(`Поиск: ${item.name}...`);
                    
                    // Запрос
                    const data = await searchIntersections(geoJSON, item.layerId, item.type);
                    results.push(data);

                    // Пауза 1 секунда между запросами, чтобы не блокировал сервер
                    await delay(1000); 
                }
            }

            document.body.removeChild(overlay);
            appendExtendedData(results);

        } catch (error) {
            console.error(error);
            alert('Ошибка при формировании отчета: ' + error.message);
        } finally {
            showLoader(false);
            btn.disabled = false;
            btn.textContent = btnOriginalText;
            btn.style.opacity = '1';
        }
    }

    async function searchIntersections(geometry, layerId, type) {
        try {
            // Используем fetch API с правильными заголовками
            const response = await fetch('https://nspd.gov.ru/api/geoportal/v1/intersects?typeIntersect=fullObject', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    // Добавляем заголовки, имитирующие браузер, хотя CORS может их отфильтровать
                    'Accept': 'application/json'
                },
                body: JSON.stringify({
                    "geom": {
                        "type": "FeatureCollection",
                        "features": [{
                            "type": "Feature",
                            "geometry": geometry,
                            "properties": {}
                        }]
                    },
                    "categories": [{"id": layerId}]
                })
            });

            if (!response.ok) {
                // Если ошибка 404, возможно в этом месте просто нет объектов этого слоя
                // Не выбрасываем фатальную ошибку, а возвращаем пустой результат
                console.warn(`Layer ${layerId} returned status ${response.status}`);
                return { type, features: [] };
            }

            const data = await response.json();
            return { type, features: data.features || [] };
        } catch (e) {
            console.error(`Ошибка при запросе слоя ${layerId}:`, e);
            // Возвращаем пустой массив, чтобы отчет продолжил формироваться
            return { type, features: [] };
        }
    }

    function appendExtendedData(results) {
        const output = document.getElementById('report-output');
        let htmlContent = '';

        // Преобразуем геометрию основного объекта в GeoJSON (WGS84) для Turf.js
        // В currentObjectGeometry координаты в EPSG:3857.
        // Turf работает с WGS84. Нужно конвертировать.
        let mainObjectWgs84 = null;
        try {
            const geom3857 = currentObjectGeometry;
            // Упрощенная конвертация (предполагаем Polygon или MultiPolygon)
            const convertCoords = (coords) => {
                if (typeof coords[0] === 'number') {
                    const p = proj4('EPSG:3857', 'EPSG:4326', coords);
                    return p; // proj4 возвращает [lon, lat]
                }
                return coords.map(convertCoords);
            };
            
            const coordsWgs84 = convertCoords(geom3857.coordinates);
            
            if (geom3857.type === 'Polygon') {
                mainObjectWgs84 = turf.polygon(coordsWgs84);
            } else if (geom3857.type === 'MultiPolygon') {
                mainObjectWgs84 = turf.multiPolygon(coordsWgs84);
            }
        } catch (e) {
            console.error("Ошибка конвертации геометрии для расчета площади:", e);
        }

        results.forEach(group => {
            if (group.features.length === 0) return;

            let title = '';
            let tableHeader = '';
            let rows = '';

            // Обработка ЗОУИТ
            if (group.type === 'zouit') {
                title = 'Сведения о частях земельного участка (ЗОУИТ)';
                tableHeader = `
                    <tr>
                        <th>Учетный номер части / Реестровый номер</th>
                        <th>Площадь, м²</th>
                        <th>Содержание ограничения</th>
                    </tr>`;
                
                group.features.forEach((f, index) => {
                    const props = f.properties.options || {};
                    const regNum = props.reg_numb_border || f.properties.descr || '-';
                    const content = props.content_restrict_encumbrances || props.name_by_doc || 'Ограничения не указаны';
                    
                    // Расчет площади
                    let areaText = '-';
                    if (mainObjectWgs84 && f.geometry) {
                        try {
                            const zouitCoords3857 = f.geometry.coordinates;
                            // Конвертируем координаты ЗОУИТ в WGS84
                            const convertZouitCoords = (coords) => {
                                if (typeof coords[0] === 'number') return proj4('EPSG:3857', 'EPSG:4326', coords);
                                return coords.map(convertZouitCoords);
                            };
                            const zouitWgs84Coords = convertZouitCoords(zouitCoords3857);
                            
                            let zouitPoly = null;
                            if (f.geometry.type === 'Polygon') zouitPoly = turf.polygon(zouitWgs84Coords);
                            else if (f.geometry.type === 'MultiPolygon') zouitPoly = turf.multiPolygon(zouitWgs84Coords);

                            if (zouitPoly) {
                                const intersection = turf.intersect(mainObjectWgs84, zouitPoly);
                                if (intersection) {
                                    const area = turf.area(intersection);
                                    areaText = Math.round(area).toString();
                                } else {
                                    areaText = '0 (касание)';
                                }
                            }
                        } catch (e) {
                            console.error("Ошибка расчета площади:", e);
                            areaText = 'ошибка расчета';
                        }
                    }

                    rows += `
                        <tr>
                            <td>${regNum}</td>
                            <td>${areaText}</td>
                            <td>
                                <strong>Вид:</strong> ${props.name_by_doc || ''}<br>
                                <strong>Содержание:</strong> ${content}
                            </td>
                        </tr>`;
                });
                
                htmlContent += `
                    <div class="page portrait">
                        <div class="coord-header"><h3>${title}</h3></div>
                        <table class="coordinates-table zouit-table">
                            ${tableHeader}
                            <tbody>${rows}</tbody>
                        </table>
                        ${generatePageControls()}
                    </div>`;
            } 
            // Обработка остальных слоев (простая таблица)
            else {
                switch(group.type) {
                    case 'zone': title = 'Сведения о территориальных зонах'; break;
                    case 'settlement': title = 'Сведения о расположении в границах населенных пунктов'; break;
                    case 'municipal': title = 'Сведения о расположении в границах муниципальных образований'; break;
                    case 'forestry': title = 'Сведения о лесничествах'; break;
                }

                tableHeader = `<tr><th>Наименование / Вид</th><th>Описание / Реестровый номер</th></tr>`;
                
                group.features.forEach(f => {
                    const props = f.properties.options || {};
                    const name = props.name_by_doc || f.properties.label || props.name || '-';
                    const desc = props.reg_numb_border || f.properties.descr || '-';
                    rows += `<tr><td>${name}</td><td>${desc}</td></tr>`;
                });

                htmlContent += `
                    <div class="page portrait">
                        <div class="coord-header"><h3>${title}</h3></div>
                        <table class="coordinates-table simple-table">
                            ${tableHeader}
                            <tbody>${rows}</tbody>
                        </table>
                        ${generatePageControls()}
                    </div>`;
            }
        });

        // Добавляем созданный контент в конец отчета
        output.insertAdjacentHTML('beforeend', htmlContent);
        
        // Прокручиваем к новым данным
        const lastPage = output.lastElementChild;
        if (lastPage) lastPage.scrollIntoView({ behavior: 'smooth' });
    }

    function generatePageControls() {
        return `
        <div class="merge-control">
            <button onclick="toggleAllOrientations()" title="Сменить ориентацию страницы">
                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="23 4 23 10 17 10"></polyline><path d="M20.49 15a9 9 0 1 1-2.12-9.36L23 10"></path></svg>
            </button>
            <button onclick="toggleMerge(this)" title="Объединить со следующей">
                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"/><rect x="8" y="2" width="8" height="4" rx="1" ry="1"/></svg>
            </button>
            <button onclick="savePageToPdf(this)" title="Сохранить как PDF">
                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path><polyline points="14 2 14 8 20 8"></polyline><line x1="16" y1="13" x2="8" y2="13"></line><line x1="16" y1="17" x2="8" y2="17"></line><polyline points="10 9 9 9 8 9"></polyline></svg>
            </button>
        </div>`;
    }

    // Инициализация событий при загрузке
    const cadInput = document.getElementById('cadastralInput');
    
    // 1. Событие форматирования (авто-двоеточия)
    cadInput.addEventListener('input', (e) => formatCadastralNumber(e.target));
    
    // 2. Событие нажатия Enter (запуск поиска)
    cadInput.addEventListener('keydown', function(event) {
        if (event.key === 'Enter') {
            event.preventDefault(); 
            fetchFromNspd(); 
        }
    });
    
    if (document.getElementById('print-orientation-style')) {
        document.getElementById('print-orientation-style').innerHTML = '@media print { @page { size: portrait; } }';
    }

    showStartView();
    </script>
</body>
</html>