




<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Слова</title>
    <link rel="icon" href="img/words.png" type="image/png">
    <link rel="stylesheet" href="webfonts/all.min.css">
    <script src="webfonts/jszip.min.js"></script>
    
<style>
body, html {
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    margin: 0;
    padding: 0;
    box-sizing: border-box;
    background-color: #f0f0f0;
    height: 100%;
    overflow-x: hidden;
}

.container {
    max-width: 800px;
    margin: 0 auto;
    padding: 20px;
    background-color: white;
    box-shadow: 0 0 10px rgba(0,0,0,0.1);
    border-radius: 10px;
}

.file-input-container {
    text-align: center;
    margin-bottom: 20px;
}

h1 {
    color: #2196F3;
    text-align: center;
    margin-bottom: 20px;
}

#fileInput {
    display: none;
}

.file-label, .menu-button, #startButton, #finishButton, #showAnswersButton, .modal-close-button {
    display: inline-block;
    padding: 12px 24px;
    color: white;
    border: none;
    border-radius: 5px;
    cursor: pointer;
    transition: all 0.3s ease;
    font-size: 16px;
    text-align: center;
    text-decoration: none;
    box-shadow: 0 2px 5px rgba(0,0,0,0.2);
    position: relative;
    overflow: hidden;
}

.file-label {
    background-color: #4CAF50;
}

.menu-button {
    background-color: #2196F3;
}

#startButton {
    background-color: #FF9800;
}

#finishButton {
    background-color: #E91E63;
}

#showAnswersButton {
    background-color: #9C27B0;
}

.modal-close-button {
    background-color: #00cec8;
}

.file-label:hover, .menu-button:hover, #startButton:hover, #finishButton:hover, #showAnswersButton:hover, .modal-close-button:hover {
    transform: translateY(-3px);
    box-shadow: 0 4px 8px rgba(0,0,0,0.3);
}

.file-label:active, .menu-button:active, #startButton:active, #finishButton:active, #showAnswersButton:active, .modal-close-button:active {
    transform: translateY(1px);
    box-shadow: 0 2px 4px rgba(0,0,0,0.2);
}

.file-label::after, .menu-button::after, #startButton::after, #finishButton::after, #showAnswersButton::after, .modal-close-button::after {
    content: '';
    position: absolute;
    top: 50%;
    left: 50%;
    width: 5px;
    height: 5px;
    background: rgba(255, 255, 255, 0.5);
    opacity: 0;
    border-radius: 100%;
    transform: scale(1, 1) translate(-50%);
    transform-origin: 50% 50%;
}

@keyframes ripple {
    0% {
        transform: scale(0, 0);
        opacity: 1;
    }
    20% {
        transform: scale(25, 25);
        opacity: 1;
    }
    100% {
        opacity: 0;
        transform: scale(40, 40);
    }
}

.file-label:focus:not(:active)::after,
.menu-button:focus:not(:active)::after,
#startButton:focus:not(:active)::after,
#finishButton:focus:not(:active)::after,
#showAnswersButton:focus:not(:active)::after,
.modal-close-button:focus:not(:active)::after {
    animation: ripple 1s ease-out;
}

#questionCountInput, #startQuestionInput, #endQuestionInput {
    width: 80px;
    text-align: center;
    border: none;
    padding: 10px 5px;
    font-size: 18px;
    -moz-appearance: textfield;
    outline: none;
}

#startButton, #finishButton, #showAnswersButton {
    display: block;
    width: 100%;
}

.question {
    background-color: #fff;
    padding: 20px;
    margin: 20px 0;
    border-radius: 5px;
    box-shadow: 0 2px 5px rgba(0,0,0,0.1);
}

.question-text {
    font-weight: bold;
    margin-bottom: 10px;
}

.answer {
    display: block;
    width: 100%;
    padding: 10px;
    margin: 5px 0;
    background-color: #f0f0f0;
    border: none;
    border-radius: 5px;
    cursor: pointer;
    transition: background-color 0.3s;
}

.answer:hover {
    background-color: #e0e0e0;
}

.answer.selected {
    background-color: #2196F3;
    color: white;
}

#results {
    margin-top: 20px;
}

.correct {
    color: #4CAF50;
}

.incorrect {
    color: #F44336;
}

#fileInfo {
    display: none;
    margin-top: 20px;
    align-items: center;
}

.header-buttons {
    position: absolute;
    top: 10px;
    right: 10px;
}

.icon-button {
    background: none;
    border: none;
    font-size: 24px;
    color: #2196F3;
    cursor: pointer;
    margin-left: 10px;
    transition: color 0.3s;
}

.icon-button:hover {
    color: #1e87db;
}

.modal {
    display: none;
    position: fixed;
    z-index: 1000;
    left: 0;
    top: 0;
    width: 100%;
    height: 100%;
    overflow: auto;
    background-color: rgba(0,0,0,0.4);
    align-items: center;
    justify-content: center;
}

.modal-content {
    background-color: #fefefe;
    padding: 20px;
    border: 1px solid #888;
    width: 90%;
    max-width: 600px;
    border-radius: 10px;
    box-shadow: 0 4px 8px rgba(0,0,0,0.1);
    max-height: 80vh;
   
    /* Уменьшаем нижний padding */
    padding-bottom: 40px;
    position: relative;
    
    
                 /* Устанавливаем ширину в процентах */
    max-width: 600px;           /* Максимальная ширина */
    box-sizing: border-box;
        max-height: 80vh; /* Ensures the content doesn't exceed 80% of the viewport height */
    overflow-y: hidden; /* Disables vertical scroll */
}



/* Стили для текстового поля в модальном окне */
#word-input {
    width: 95%;
    height: 100px; /* Увеличиваем высоту до 300px */
    min-height: 100px; /* Минимальная высота */
    max-height: 150px; /* Максимальная высота */
    margin: 10px auto;
    padding: 10px;
    border: 1px solid #ddd;
    border-radius: 5px;
    resize: vertical; /* Разрешаем пользователю изменять высоту */
    display: block;
    margin-bottom: 20px;
    font-size: 14px;
    line-height: 1.4;
    font-family: monospace;
    background-color: #f8f9fa;
    border: 1px solid #ced4da;
    box-shadow: inset 0 1px 2px rgba(0,0,0,.075);
     padding-right: 50px; 
}

#word-input:focus {
    border-color: #80bdff;
    outline: 0;
    box-shadow: 0 0 0 0.2rem rgba(0,123,255,.25);
    background-color: #fff;
}

.modal-content h2 {
    margin-top: 0;
    color: #2196F3;
}

.modal-content pre {
    background-color: #f5f5f5;
    padding: 10px;
    border-radius: 5px;
    white-space: pre-wrap;       /* Перенос длинных строк */
    word-wrap: break-word;       /* Перенос слов */
    overflow-x: hidden;          /* Скрываем горизонтальный скроллбар */
    max-width: 100%;             /* Ограничиваем максимальную ширину */
    margin: 10px 0;              /* Добавляем отступы сверху и снизу */
}

.modal-content {
    overflow-x: hidden;          /* Скрываем горизонтальный скроллбар */
    padding: 20px;
    width: 90%;                  /* Устанавливаем ширину в процентах */
    max-width: 600px;           /* Максимальная ширина */
    box-sizing: border-box;      /* Учитываем padding в общей ширине */
}

.test-button-container {
    display: flex;
    align-items: center;
    margin-bottom: 10px;
}

.download-button {
    background-color: #4CAF50;
    color: white;
    border: none;
    border-radius: 5px;
    padding: 5px 10px;
    margin-left: 10px;
    cursor: pointer;
    transition: background-color 0.3s;
}

.download-button:hover {
    background-color: #45a049;
}

#quizContainer {
    overflow-y: auto;
    -webkit-overflow-scrolling: touch;
}

.peek-answers-button {
    position: fixed;
    bottom: 20px;
    right: 20px;
    background-color: #ff9800;
    color: white;
    border: none;
    border-radius: 50%;
    width: 60px;
    height: 60px;
    cursor: pointer;
    transition: background-color 0.3s, transform 0.3s;
    z-index: 1001;
    display: flex;
    align-items: center;
    justify-content: center;
    box-shadow: 0 2px 5px rgba(0,0,0,0.2);
}

.peek-answers-button:hover {
    background-color: #f57c00;
    transform: scale(1.1);
}

.peek-answers-button:active {
    transform: scale(0.95);
}

.peek-answers-button i {
    font-size: 30px;
}

.switch-container {
    display: flex;
    align-items: center;
    justify-content: center;
    margin-top: 20px;
     margin-bottom: 20px;
}

.switch {
    position: relative;
    display: inline-block;
    width: 60px;
    height: 34px;
    margin-right: 10px;
}

.switch input {
    opacity: 0;
    width: 0;
    height: 0;
}

.slider {
    position: absolute;
    cursor: pointer;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background-color: #ccc;
    transition: .4s;
}

.slider:before {
    position: absolute;
    content: "";
    height: 26px;
    width: 26px;
    left: 4px;
    bottom: 4px;
    background-color: white;
    transition: .4s;
}

input:checked + .slider {
    background-color: #2196F3;
}

input:checked + .slider:before {
    transform: translateX(26px);
}

.slider.round {
    border-radius: 34px;
}

.slider.round:before {
    border-radius: 50%;
}

.range-inputs {
    display: none;
    margin-top: 10px;
}

.range-inputs input {
    width: 60px;
    margin-right: 10px;
}

.spin-input-container, .range-inputs {
    display: flex;
    justify-content: center;
    margin-bottom: 20px;
}

.spin-input {
    display: flex;
    align-items: center;
    overflow: hidden;
    margin: 0 10px;
    border: 1px solid #2196F3;
    border-radius: 5px;
}

.spin-button {
    background-color: #2196F3;
    color: white;
    border: none;
    padding: 10px 15px;
    cursor: pointer;
    transition: background-color 0.3s;
    font-size: 18px;
}

.spin-button:hover {
    background-color: #1e87db;
}

.spin-down {
    border-radius: 5px 0 0 5px;
}

.spin-up {
    border-radius: 0 5px 5px 0;
}

.range-separator {
    font-size: 24px;
    margin: 0 10px;
    align-self: center;
}

@keyframes fadeIn {
    from { opacity: 0; }
    to { opacity: 1; }
}

@keyframes slideIn {
    from { transform: translateY(-20px); opacity: 0; }
    to { transform: translateY(0); opacity: 1; }
}

@keyframes scaleIn {
    from { transform: scale(0.9); opacity: 0; }
    to { transform: scale(1); opacity: 1; }
}

@keyframes rotateIn {
    from { transform: rotate(-5deg) scale(0.9); opacity: 0; }
    to { transform: rotate(0) scale(1); opacity: 1; }
}

.fade-in {
    animation: fadeIn 0.5s ease-out;
}

.slide-in {
    animation: slideIn 0.5s ease-out;
}

.scale-in {
    animation: scaleIn 0.3s ease-out;
}

.rotate-in {
    animation: rotateIn 0.5s ease-out;
}

/* Styles for mobile devices */
@media (max-width: 768px) {
    body, html {
        height: auto;
        min-height: 100%;
        overflow-x: hidden;
    }

    .container {
        min-height: auto;
        max-height: 100vh;
        overflow-y: auto;
        padding-bottom: 20px;
    }

    #quizContainer {
        max-height: calc(100vh - 200px);
        overflow-y: auto;
    }

    .question {
        margin: 10px 0;
    }

    .answer {
        padding: 15px 10px;
        margin: 5px 0;
    }

    #startButton, #finishButton, #showAnswersButton {
        padding: 15px;
        font-size: 16px;
    }

    body {
        position: relative;
    }

    #results {
        margin-bottom: 20px;
    }
}

.show-answers .answer.selected:not(.correct-answer) {
    background-color: #ed2100;
    color: white;
}

.show-answers .answer.correct-answer {
    background-color: #4CAF50;
    color: white;
}

.show-answers .answer.selected.correct-answer {
    background-color: #45a049;
}

#questionCountInput::-webkit-inner-spin-button,
#questionCountInput::-webkit-outer-spin-button,
#startQuestionInput::-webkit-inner-spin-button,
#startQuestionInput::-webkit-outer-spin-button,
#endQuestionInput::-webkit-inner-spin-button,
#endQuestionInput::-webkit-outer-spin-button {
    -webkit-appearance: none;
    margin: 0;
}

@keyframes shootWord {
    0% {
        opacity: 0;
        transform: translate3d(0, 0, -1000px) scale(0.1);
        filter: blur(20px);
    }
    60% {
        opacity: 1;
        transform: translate3d(0, 0, -10px) scale(1.1);
        filter: blur(0);
    }
    80% {
        transform: translate3d(0, 0, 0) scale(0.95);
    }
    100% {
        transform: translate3d(0, 0, 0) scale(1);
    }
}


@keyframes shatterEffect {
    0%, 100% {
        clip-path: polygon(0% 0%, 100% 0%, 100% 100%, 0% 100%);
    }
    25% {
        clip-path: polygon(0% 0%, 100% 0%, 75% 100%, 0% 100%);
    }
    50% {
        clip-path: polygon(0% 0%, 100% 0%, 100% 100%, 25% 100%);
    }
    75% {
        clip-path: polygon(25% 0%, 100% 0%, 100% 100%, 0% 100%);
    }
}

h1 {
    color: #2196F3;
    text-align: center;
    margin-bottom: 20px;
    font-size: 48px;
    perspective: 1000px;
    animation: shootWord 1s ease-out forwards, shatterEffect 0.2s 0.9s;
    position: relative;
    display: inline-block;
}

h1 i {
    margin-right: 10px;
    display: inline-block;
    animation: rotateIcon 1s ease-out forwards;
}

@keyframes rotateIcon {
    0% {
        transform: rotate(-720deg);
    }
    100% {
        transform: rotate(0deg);
    }
}

h1::after {
    content: '';
    position: absolute;
    top: -10px;
    left: -10px;
    right: -10px;
    bottom: -10px;
    background: radial-gradient(circle at center, rgba(255,255,255,0.8) 0%, rgba(255,255,255,0) 70%);
    opacity: 0;
    animation: flashEffect 0.5s 0.9s;
}

@keyframes flashEffect {
    0%, 100% {
        opacity: 0;
    }
    50% {
        opacity: 1;
    }
}


#learning-panel {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
}

/* Затемняющий слой */
.overlay {
    display: none; /* Изначально скрыт */
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.8); /* Полупрозрачный черный фон */
    z-index: 999; /* Устанавливаем высокий z-index */
}

/* Панель обучения */
#learning-panel {
    z-index: 1000; /* Поверх overlay */
    position: relative;
   background-color: white;
    padding: 20px;
    border-radius: 10px;
    box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);
     color: #305cde;
      transition: background-color 0.3s, color 0.3s; /* Плавный переход */
}


/* Стили для панели обучения, когда overlay активен */
#learning-panel.overlay-active {
    background-color: transparent;
    color: white;
}


#word-to-learn {
    font-size: 3em;
    margin-bottom: 20px;
    text-align: center;
    text-shadow: 2px 2px 5px rgba(0, 0, 0, 0.5); /* Пример тени */
}


/* Обновленные стили для контейнера вариантов */


#progress {
    text-align: center;
    margin-top: 20px;
    font-size: 1.2em;
    color: #64B5F6; /* светло-голубой цвет */
    padding: 10px;
    border-radius: 8px;
    font-weight: 500; /* чуть жирнее шрифт */
    text-shadow: 1px 1px 2px rgba(0,0,0,0.05); /* легкая тень */
   
}
.options-count-container {
    margin-bottom: 30px; /* Уменьшаем отступ снизу */
}

.options-count-container label {
    margin-right: 10px;
}

#optionsCountInput {
    width: 50px;
    text-align: center;
}




/* Стили для кнопок в шапке */
#helpButton, #urlButton, #selectFromTextBtn {
    background: none;
    border: none;
    padding: 0;
    margin-left: 10px;
    cursor: pointer;
    opacity: 0.7;
    transition: opacity 0.3s;
}

#helpButton:hover, #urlButton:hover, #selectFromTextBtn:hover {
    opacity: 1;
}

#helpButton img, #urlButton img, #selectFromTextBtn i {
    width: 24px;
    height: 24px;
}

/* Стили для модального окна */
.modal {
    display: none;
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.5);
    z-index: 1000;
}


.modal-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 15px 20px;
    border-bottom: 1px solid #eee;
}

.modal-header h3 {
    margin: 0;
    color: #333;
}

.text-inputs-container {
    display: flex;
    flex: 1;
    gap: 20px;
    padding: 20px;
}

.input-column {
    flex: 1;
    display: flex;
    flex-direction: column;
    gap: 10px;
}

.text-input {
    flex: 1;
    padding: 15px;
    border: 1px solid #ddd;
    border-radius: 8px;
    font-size: 14px;
    resize: none;
    background-color: #f8f9fa;
}

.text-input:focus {
    outline: none;
    border-color: #4CAF50;
    box-shadow: 0 0 0 2px rgba(76, 175, 80, 0.2);
}

.custom-select {
    padding: 8px;
    border: 1px solid #ddd;
    border-radius: 6px;
    background-color: white;
    font-size: 14px;
}

.buttons-container {
    padding: 20px;
    display: flex;
    justify-content: center;
    gap: 15px;
}

.green-button {
    background-color: #4CAF50;
    color: white;
    border: none;
    padding: 10px 20px;
    border-radius: 6px;
    cursor: pointer;
    font-size: 14px;
    transition: background-color 0.3s;
}

.green-button:hover {
    background-color: #45a049;
}

/* Стили для скроллбара */
.custom-scrollbar::-webkit-scrollbar {
    width: 8px;
}

.custom-scrollbar::-webkit-scrollbar-track {
    background: #f1f1f1;
    border-radius: 4px;
}

.custom-scrollbar::-webkit-scrollbar-thumb {
    background: #888;
    border-radius: 4px;
}

.custom-scrollbar::-webkit-scrollbar-thumb:hover {
    background: #666;
}

#textinput1, #textinput2 {
    font-family: monospace;
    line-height: 1.5;
    white-space: pre;
    overflow-y: scroll;
    overflow-x: hidden;
      height: 200px; /* Увеличиваем высоту в 1.5 раза */
    min-height: 200px;
    max-height: 300px;
  
}

#textinput1::placeholder, #textinput2::placeholder {
    white-space: pre-wrap;
    word-wrap: break-word;
}

/* Для разных браузеров */
#textinput1::-webkit-input-placeholder, #textinput2::-webkit-input-placeholder {
    white-space: pre-wrap;
    word-wrap: break-word;
}

#textinput1::-moz-placeholder, #textinput2::-moz-placeholder {
    white-space: pre-wrap;
    word-wrap: break-word;
}

#textinput1:-ms-input-placeholder, #textinput2:-ms-input-placeholder {
    white-space: pre-wrap;
    word-wrap: break-word;
}




/* Обновляем базовые стили для модального окна */
#textSelectionModal .modal-content {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: 90%;
    max-width: 1000px;
    height: auto; /* Изменено с фиксированной высоты */
    max-height: 90vh; /* Максимальная высота 90% от высоты viewport */
    display: flex;
    flex-direction: column;
    padding: 15px;
    overflow: hidden;
}

/* Стили для мобильных устройств */
@media (max-width: 768px) {
    #textSelectionModal .modal-content {
        width: 95%; /* Увеличиваем ширину на мобильных */
        height: 90vh; /* Фиксированная высота на мобильных */
        top: 5vh; /* Отступ сверху */
        transform: translateX(-50%); /* Убираем вертикальное центрирование */
        padding: 10px;
    }

    .text-inputs-container {
        flex-direction: column; /* Столбцы вместо строк на мобильных */
        height: calc(100% - 100px); /* Учитываем высоту кнопок и заголовка */
        overflow: hidden;
    }

    .input-column {
        height: 45%; /* Уменьшаем высоту каждой колонки */
        margin-bottom: 10px;
    }

    #textinput1, #textinput2 {
        height: calc(100% - 40px); /* Учитываем высоту селекта языка */
        min-height: auto;
    }

    .buttons-container {
        padding: 10px;
        gap: 10px;
    }

    .modal-header {
        padding: 10px;
    }

    /* Уменьшаем размер шрифта для мобильных устройств */
    .modal-header h3 {
        font-size: 16px;
    }

    /* Настраиваем размер кнопок */
    .green-button {
        padding: 8px 15px;
        font-size: 14px;
    }

    /* Улучшаем отображение селектов языка */
    .custom-select {
        height: 35px;
        margin-top: 5px;
    }
}

/* Дополнительные стили для очень маленьких экранов */
@media (max-width: 480px) {
    #textSelectionModal .modal-content {
        width: 98%;
    }

    .buttons-container {
        flex-direction: column; /* Кнопки друг под другом */
        align-items: stretch;
    }

    .green-button {
        width: 100%;
        margin: 5px 0;
    }
}

/* Добавляем поддержку ландшафтной ориентации */
@media (max-height: 600px) and (orientation: landscape) {
    #textSelectionModal .modal-content {
        height: 95vh;
        top: 2.5vh;
    }

    .text-inputs-container {
        flex-direction: row; /* Возвращаем расположение в строку */
        gap: 10px;
    }

    .input-column {
        height: 100%;
    }
}






.input-column {
    position: relative;
}



.congratulations {
    text-align: center;
    font-size: 24px;
    color: #305cde;
    text-shadow: 2px 2px 4px rgba(0,0,0,0.1);
    animation: congratsAppear 0.5s ease-out;
}

.congratulations-title {
    font-size: 32px;
    font-weight: bold;
    margin-bottom: 15px;
    background: linear-gradient(45deg, #2cff05, #2cff05);
    -webkit-background-clip: text;
    background-clip: text;

    text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.2);
}

.congratulations-text {
    font-size: 20px;
    color: #ffa500;
    text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.3);
}

@keyframes congratsAppear {
    0% { opacity: 0; transform: translateY(-20px); }
    100% { opacity: 1; transform: translateY(0); }
}

#saveToFileBtn {
    background-color: #4CAF50;
}

#saveToFileBtn:disabled {
    background-color: #cccccc;
    cursor: not-allowed;
    opacity: 0.7;
}

#saveToFileBtn i {
    margin-right: 5px;
}

/* Добавьте эти стили в существующий CSS */

/* Обновленные стили для контейнера вариантов */
#translation-options {
    display: grid;
    grid-template-rows: repeat(2, 1fr); /* Изменено с 7 на 3 строки */
    gap: 10px;
    height: 200px; /* Уменьшена высота для 3 строк */
    position: relative;
    width: 100%;
    padding: 10px;
    margin: 20px 0;
}

.translation-option {
    position: absolute;
    transform: translate(-50%, -50%);
    font-size: 1.2em;
    padding: 10px 20px;
    border: none;
    border-radius: 5px;
    cursor: pointer;
    transition: transform 0.3s ease, box-shadow 0.3s ease;
    white-space: nowrap;
    z-index: 1;
}

.translation-option:hover {
    transform: translate(-50%, -50%) scale(1.1);
    box-shadow: 0 5px 15px rgba(0,0,0,0.3);
    z-index: 2;
}

@keyframes correctAnswer {
    0% { 
        transform: translate(-50%, -50%) scale(1);
        background-color: #89f336;
    }
    50% { 
        transform: translate(-50%, -50%) scale(1.3);
        background-color: #89f336;
    }
    100% { 
        transform: translate(-50%, -50%) scale(1);
        background-color: #89f336;
    }
}

@keyframes wrongAnswer {
    0% { 
        transform: translate(-50%, -50%) scale(1);
        background-color: #F44336;
    }
    50% { 
        transform: translate(-50%, -50%) scale(1.1);
        background-color: #F44336;
    }
    100% { 
        transform: translate(-50%, -50%) scale(1);
        background-color: #F44336;
    }
}

.translation-option.correct-animation {
    animation: correctAnswer 0.8s ease;
}

.translation-option.wrong-animation {
    animation: wrongAnswer 0.8s ease;
   
}
/* Добавим эффект вспышки */
@keyframes flash {
    0% {
        box-shadow: 0 0 0 0 rgba(255, 255, 255, 0.7);
    }
    70% {
        box-shadow: 0 0 0 50px rgba(255, 255, 255, 0);
    }
    100% {
        box-shadow: 0 0 0 0 rgba(255, 255, 255, 0);
    }
}

.flash-effect {
    animation: flash 0.7s ease-out;
}

/* Изменим стили для кнопок в списке файлов */
#fileList .menu-button {
    background-color: #2196F3;
    margin: 8px auto; /* центрирование */
    width: 90%; /* уменьшаем ширину */
    max-width: 400px; /* максимальная ширина */
    padding: 12px 20px;
    transition: all 0.3s ease;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 10px;
    border-radius: 8px;
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}

#fileList .menu-button:hover {
    background-color: #1976D2;
    transform: translateY(-2px);
    box-shadow: 0 4px 8px rgba(0,0,0,0.2);
}

/* Стили для модального окна с файлами */
#urlModal .modal-content {
    width: 90%;
    max-width: 500px; /* ограничиваем максимальную ширину */
    padding: 25px;
    overflow: visible; /* убираем скроллбар */
}

#fileList {
    margin: 15px 0;
    padding: 0;
    overflow: visible;
}

.swap-button {
    position: absolute;
    right: 10px;
    top: 10px;
    background-color: #2196F3;
    color: white;
    border: none;
    border-radius: 50%;
    width: 36px;
    height: 36px;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.3s ease;
    box-shadow: 0 2px 5px rgba(0,0,0,0.2);
}

.swap-button:hover {
    background-color: #1976D2;
    transform: scale(1.1);
}

.swap-button:active {
    transform: scale(0.95);
}

.swap-button i {
    font-size: 16px;
}


.learning-panel-expanded {
    width: 90%;
    height: 90%;
    margin: auto;
    transition: all 0.3s ease;
}


.repeat-button, .swap-repeat-button {
    padding: 10px 20px;
    font-size: 16px;
    border: none;
    border-radius: 5px;
    cursor: pointer;
    color: white;
    margin-top: 20px;
    transition: background-color 0.3s;
}

.repeat-button {
    background-color: #9d00ff; /* Зеленый цвет для кнопки "Повторить" */
    position: absolute;
    bottom: 10px;
    left: 10px;
}

.swap-repeat-button {
    background-color: #FF9800; /* Оранжевый цвет для кнопки "Поменять" */
    position: absolute;
    bottom: 10px;
    right: 10px;
}

.repeat-button:hover {
    background-color: #45a049;
}

.swap-repeat-button:hover {
    background-color: #f57c00;
}

.congratulations-buttons {
    display: none;
    opacity: 0;
    transition: opacity 0.5s ease-in-out;
}

.congratulations-buttons.show {
    display: block;
    opacity: 1;
}

/* Добавляем стили для статистики */
.statistics {
    text-align: center;
    margin-top: 20px;
    font-size: 18px;
    color: #333;
}

.statistics div {
    margin: 10px 0;
}

.statistics .label {
     
}

.statistics .value {
    font-weight: bold;
   
}




.translator-select {
    padding: 10px;
    border: 1px solid #ddd;
    border-radius: 6px;
    background-color: white;
    font-size: 14px;
    margin-right: 10px;
    color: #333;
    cursor: pointer;
    transition: all 0.3s ease;
    min-width: 200px;
}

.translator-select:hover {
    border-color: #4CAF50;
}

.translator-select:focus {
    outline: none;
    border-color: #4CAF50;
    box-shadow: 0 0 0 2px rgba(76, 175, 80, 0.2);
}

/* Стилизация стрелки выпадающего списка */
.translator-select {
    appearance: none;
    -webkit-appearance: none;
    -moz-appearance: none;
    background-image: url("data:image/svg+xml;charset=UTF-8,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3e%3cpolyline points='6 9 12 15 18 9'%3e%3c/polyline%3e%3c/svg%3e");
    background-repeat: no-repeat;
    background-position: right 10px center;
    background-size: 1em;
    padding-right: 30px;
}


.learned-words-container {
    position: fixed;
    bottom: 20px;
    left: 20px;
    z-index: 1001;
    display: flex;
    align-items: center;
}

.learned-words-button {
    position: relative;
    background-color: #4CAF50;
    color: white;
    border: none;
    border-radius: 50%;
    width: 60px;
    height: 60px;
    cursor: pointer;
    transition: background-color 0.3s, transform 0.3s;
    z-index: 1001;
    display: flex;
    align-items: center;
    justify-content: center;
    box-shadow: 0 2px 5px rgba(0,0,0,0.2);
}

.learned-words-button:hover {
    background-color: #45a049;
    transform: scale(1.1);
}

.learned-words-button:active {
    transform: scale(0.95);
}

.learned-words-button.disabled {
    background-color: #ccc;
}

.learned-words-button i {
    font-size: 30px;
}

.learned-words-count {
    position: absolute;
    background-color: #ff5722;
    color: white;
    border-radius: 50%;
    padding: 2px 8px;
    font-size: 12px;
    font-weight: bold;
    min-width: 20px;
    height: 20px;
    display: flex;
    align-items: center;
    justify-content: center;
    box-shadow: 0 2px 5px rgba(0,0,0,0.2);
    animation: scaleIn 0.3s ease-out;
}

.total-count {
    bottom: -10px;
    left: -20px;
    background-color: #ff5722; 
}

.current-file-count {
    bottom: -10px;
    right: -20px;
    background-color: #2196F3; 
}

.learned-words-count.hidden {
    display: none;
}

@keyframes scaleIn {
    0% { transform: scale(0); }
    70% { transform: scale(1.2); }
    100% { transform: scale(1); }
}

.learned-words-button:hover .learned-words-count {
    animation: none;
}

.learned-words-menu {
    display: none;
    position: fixed;
    bottom: 90px;
    left: 20px;
    background-color: white;
    border-radius: 8px;
    box-shadow: 0 2px 10px rgba(0,0,0,0.2);
    z-index: 1002;
    min-width: 250px;
}

.menu-item {
    display: block;
    width: 100%;
    padding: 12px 20px;
    border: none;
    background: none;
    text-align: left;
    cursor: pointer;
    white-space: nowrap;
    transition: background-color 0.3s;
}

.menu-item:hover {
    background-color: #f5f5f5;
}

.menu-item i {
    margin-right: 10px;
}

.add-to-learned-button {
    background-color: #4CAF50;
    color: white;
    border: none;
    border-radius: 5px;
    padding: 10px 20px;
    cursor: pointer;
    margin: 0 10px;
    transition: background-color 0.3s;
}

.add-to-learned-button:hover {
    background-color: #2e6f40;
}

.add-to-learned-button:disabled {
    background-color: #cccccc;
    cursor: default;
}

.red-button {
    background-color: #ff2c2c; /* Красный цвет */
    color: white;
    border: none;
    border-radius: 5px;
    padding: 10px 15px;
    cursor: pointer;
    transition: background-color 0.3s;
}

.red-button:hover {
    background-color: #d32f2f; /* Темно-красный при наведении */
}

/* Добавьте эти стили в существующий <style> блок */
.accordion-category {
    margin-bottom: 10px;
    background: white;
    border-radius: 8px;
    overflow: hidden;
}

.category-header {
    display: flex;
    justify-content: center;
    align-items: center;
    background: #2196F3;
    color: white;
    padding: 15px;
    cursor: pointer;
    transition: background-color 0.3s;
}


.category-header:hover {
    background: #1976D2;
}

.category-content {
    max-height: 0;
    overflow: hidden;
    transition: max-height 0.3s ease-out;
}

.category-content.active {
    max-height: 500px; /* Достаточно большое значение для содержимого */
}

.category-header i {
    margin-left: 10px; 
    transition: transform 0.3s;
}

.category-header.active i {
    transform: rotate(180deg);
}

#urlModal .modal-content {
    max-height: 80vh;
    overflow-y: auto;
    padding: 20px;
}

.file-list-container {
    max-height: calc(80vh - 120px);
    overflow-y: auto;
}

.accordion-category .menu-button {
    margin: 8px;
    width: calc(100% - 16px);
}

</style>
</head>
<body>
<div class="container">
    <div class="header-buttons fade-in">
        <button id="helpButton" class="icon-button"><i class="fas fa-question-circle"></i></button>
        <button id="urlButton" class="icon-button"><i class="fas fa-link"></i></button>
        <button id="selectFromTextBtn" class="icon-button" title="Выбрать слова из текста">
    <i class="fas fa-book-open"></i>
</button>
    </div>

    <div style="text-align: center;">
        <h1><i class="fas fa-language"></i>Слова</h1>
    </div>
    
    <div class="file-input-container fade-in">
        <input type="file" id="fileInput" accept=".txt,.csv,.zip">
        <label for="fileInput" class="file-label">
            <i class="fas fa-file-upload"></i> Открыть
        </label>
    </div>

    <div id="fileInfo" class="slide-in" style="display: none;">
        <div class="spin-input-container">
            <div class="spin-input">
                <button class="spin-button spin-down"><i class="fas fa-chevron-left"></i></button>
                <input type="number" id="questionCountInput" title="Введите количество слов">
                <button class="spin-button spin-up"><i class="fas fa-chevron-right"></i></button>
            </div>
        </div>
        <div class="range-inputs" style="display: none;">
            <div class="spin-input">
                <button class="spin-button spin-down" id="startQuestionDown"><i class="fas fa-chevron-left"></i></button>
                <input type="number" id="startQuestionInput" min="1" value="1" title="Введите начальный номер слова">
                <button class="spin-button spin-up" id="startQuestionUp"><i class="fas fa-chevron-right"></i></button>
            </div>
            <span class="range-separator">-</span>
            <div class="spin-input">
                <button class="spin-button spin-down" id="endQuestionDown"><i class="fas fa-chevron-left"></i></button>
                <input type="number" id="endQuestionInput" min="1" value="1" title="Введите конечный номер слова">
                <button class="spin-button spin-up" id="endQuestionUp"><i class="fas fa-chevron-right"></i></button>
            </div>
        </div>
        <button id="startButton" class="scale-in"><i class="fas fa-play"></i> Начать обучение </button>
    </div>

    <div id="learning-panel" style="display: none;">
        <div id="word-to-learn"></div>
        <div id="translation-options"></div>
    </div>

    <div id="progress"></div>

    <div id="helpModal" class="modal" style="display: none;">
        <div class="modal-content scale-in">
            <h2>Помощь</h2>
            <p>Для изучения слов используется текстовый файл, в названии которого язык должен быть указан перед символом нижнего подчеркивания '_' (например: English_1000.txt), со следующими строками:</p>
            <pre>
Слово1;Перевод1
Слово2;Перевод2
Слово3;Перевод3
            </pre>
            <div style="position: relative;">
                <textarea id="word-input" placeholder="Введите слова и переводы в формате:&#10;Слово1;Перевод1&#10;Слово2;Перевод2"></textarea>
                <button id="swapButton" class="swap-button" title="Поменять местами слова и переводы">
                    <i class="fas fa-exchange-alt"></i>
                </button>
            </div>
            <div class="switch-container">
                <label class="switch">
                    <input type="checkbox" id="randomSelectionSwitch" checked>
                    <span class="slider round"></span>
                </label>
                <span>Случайный выбор слов</span>
            </div>
 <div class="options-count-container">
    <label for="optionsCountInput">Количество вариантов ответа:</label>
    <input type="number" id="optionsCountInput" min="2" max="10" value="5">
    <button id="clearDataButton" class="red-button" style="margin-left: 50px;">Удалить данные</button>
</div>
        </div>
    </div>

<div id="urlModal" class="modal">
    <div class="modal-content scale-in">
        <h2>Выберите набор слов</h2>
        <div class="file-list-container">
            <div id="fileList"></div>
        </div>
        <button id="closeUrlButton" class="modal-close-button">Закрыть</button>
    </div>
</div>

    <button id="peekAnswersButton" class="peek-answers-button" style="display: none;" title="Подсмотреть ответы"><i class="fas fa-eye"></i></button>
<div class="learned-words-container">
    <button id="learnedWordsButton" class="learned-words-button" title="Изученные слова">
        <i class="fas fa-graduation-cap"></i>
    </button>
    <!-- Общий счетчик всех изученных слов -->
    <span id="totalLearnedWordsCount" class="learned-words-count total-count" title="Всего изучено слов"></span>
    <!-- Счетчик изученных слов из текущего файла -->
    <span id="currentFileLearnedCount" class="learned-words-count current-file-count" title="Изучено слов из текущего файла"></span>
</div>
</div>

<div id="textSelectionModal" class="modal">
    <div class="modal-content">
        <div class="modal-header">
            <h3>Выбор слов из текста</h3>
        </div>
        <div class="text-inputs-container">
            <div class="input-column">
                <textarea id="textinput1" class="text-input custom-scrollbar" placeholder="1) Введите текст и нажмите Перевести"></textarea>
                <select id="fromLang" class="custom-select">
                    <option value="en" selected>Английский</option>
                    <option value="es">Испанский</option>
                    <option value="de">Немецкий</option>
                    <option value="ru">Русский</option>
                    <option value="tt">Татарский</option>
                    <option value="tr">Турецкий</option>
                    <option value="fr">Французский</option>
                </select>
            </div>
            <div class="input-column">
                <textarea id="textinput2" class="text-input custom-scrollbar" placeholder="2) Вставьте слова с переводом из Google Переводчик или OnlineDocTranslator"></textarea>
                <select id="toLang" class="custom-select">
                    <option value="en">Английский</option>
                    <option value="es">Испанский</option>
                    <option value="de">Немецкий</option>
                    <option value="ru" selected>Русский</option>
                    <option value="tt">Татарский</option>
                    <option value="tr">Турецкий</option>
                    <option value="fr">Французский</option>
                </select>
            </div>
        </div>
        <div class="buttons-container">
                <select id="translatorSelect" class="translator-select">
        <option value="google">Google Переводчик</option>
        <option value="onlinedoc">OnlineDocTranslator</option>
    </select>
    <button id="translateBtn" class="green-button">Перевести</button>
            <button id="startLearningBtn" class="green-button">Начать обучение</button>
            <button id="saveToFileBtn" class="green-button" disabled>
                <i class="fas fa-download"></i> Сохранить в файл
            </button>
        </div>
    </div>
</div>

<div id="learnedWordsMenu" class="learned-words-menu">
    <button class="menu-item" id="downloadLearnedWords">
        <i class="fas fa-download"></i> Сохранить
    </button>
  
    <button class="menu-item" id="replaceLearnedWords">
        <i class="fas fa-exchange-alt"></i> Заменить
    </button>
  <button class="menu-item" id="deleteLearnedWords">
        <i class="fas fa-trash"></i> Удалить
    </button>
</div>


<div id="overlay" class="overlay"></div>

<script>
// Ждем полной загрузки DOM перед выполнением скрипта
document.addEventListener('DOMContentLoaded', function() {
    // Глобальные переменные состояния
 
let words = [];
let totalWords = 0;
let learnedWords = 0;
let currentWord = null;
let incorrectAnswers = 0;
let startTime = null;
let currentLanguage = 'common';

let isLearnedWordsEnabled = localStorage.getItem('learnedWordsEnabled') !== 'false';
const learnedWordsButton = document.getElementById('learnedWordsButton');
const learnedWordsMenu = document.getElementById('learnedWordsMenu');

    // Получаем все необходимые элементы DOM
    const fileInput = document.getElementById('fileInput');
    const wordInput = document.getElementById('word-input');
    const startButton = document.getElementById('startButton');
    const learningPanel = document.getElementById('learning-panel');
    const wordToLearn = document.getElementById('word-to-learn');
    const translationOptions = document.getElementById('translation-options');
    const progressDisplay = document.getElementById('progress');
    const helpButton = document.getElementById('helpButton');
    const urlButton = document.getElementById('urlButton');
    const helpModal = document.getElementById('helpModal');
    const urlModal = document.getElementById('urlModal');
    const closeUrlButton = document.getElementById('closeUrlButton');
    const randomSelectionSwitch = document.getElementById('randomSelectionSwitch');
    const questionCountInput = document.getElementById('questionCountInput');
    const startQuestionInput = document.getElementById('startQuestionInput');
    const endQuestionInput = document.getElementById('endQuestionInput');
    const peekAnswersButton = document.getElementById('peekAnswersButton');
    const optionsCountInput = document.getElementById('optionsCountInput');
    const textInput1 = document.getElementById('textinput1');
    const textInput2 = document.getElementById('textinput2');
    const translateBtn = document.getElementById('translateBtn');
    const startLearningBtn = document.getElementById('startLearningBtn');
    const saveToFileBtn = document.getElementById('saveToFileBtn');
    const selectFromTextBtn = document.getElementById('selectFromTextBtn');
    const modal = document.getElementById('textSelectionModal');

    const fileOptions = [
{ name: "English - 700", url: "https://vsemap.ru/english_700.zip" },
        { name: "English - 2800", url: "https://vsemap.ru/english_2800.zip" },
{ name: "English - 5000", url: "english_5000.zip" },
    { name: "English - 6500", url: "english_6500.zip" },
         { name: "Español - 500", url: "español_500.zip" },
         { name: "Español - 5000", url: "español_5000.zip" },
 { name: "Español - 20000", url: "español_20000.zip" },
 { name: "Татар - 4400", url: "татар_4400.zip" },
 { name: "Татар - 12500", url: "татар_12500.zip" },
 { name: "Türkçe - 5000", url: "türkçe_5000.zip" }
       
    ];
    
      function checkLearnedWordsState() {
      /*  console.log('Checking learned words state:');
        console.log('Current Language:', currentLanguage);
        console.log('Storage Key:', getStorageKey(currentLanguage)); */
        
        const learnedWords = getLearnedWords(currentLanguage);
    /*    console.log('Learned Words Count:', learnedWords.length);
        console.log('Learned Words:', learnedWords);
        console.log('LocalStorage State:', localStorage.getItem(getStorageKey(currentLanguage))); */
    }
    
    
     try {
        isLearnedWordsEnabled = localStorage.getItem('learnedWordsEnabled') !== 'false';
        
        // Функция обновления состояния кнопки (должна быть объявлена ранее)
        function updateLearnedWordsButtonState() {
            if (isLearnedWordsEnabled) {
                learnedWordsButton.classList.remove('disabled');
            } else {
                learnedWordsButton.classList.add('disabled');
            }
        }

        updateLearnedWordsButtonState();
        updateTotalLearnedWordsCounter();
        updateCurrentFileLearnedCounter(0);
    } catch (e) {
        console.error('Error initializing learned words:', e);
        // Очищаем ключ для текущего языка, а не общий 'learnedWords'
        localStorage.removeItem(getStorageKey(currentLanguage));
        isLearnedWordsEnabled = true;
    }

    // Вызываем проверку состояния при загрузке
    checkLearnedWordsState();
    
    
  
    
   
    updateLearnedWordsButtonState();

    // Добавляем основные слушатели событий
    fileInput.addEventListener('change', handleFileUpload);
    fileInput.addEventListener('click', function(event) {
        this.value = '';
    });
    startButton.addEventListener('click', startLearning);
    helpButton.addEventListener('click', () => helpModal.style.display = 'flex');
    urlButton.addEventListener('click', () => urlModal.style.display = 'flex');
    closeUrlButton.addEventListener('click', () => urlModal.style.display = 'none');
    randomSelectionSwitch.addEventListener('change', toggleSelectionMode);
    peekAnswersButton.addEventListener('click', togglePeekAnswers);

    // Слушатели для текстовых полей
    textInput1.addEventListener('scroll', () => syncScroll(textInput1, textInput2));
    textInput2.addEventListener('scroll', () => syncScroll(textInput2, textInput1));
    textInput1.addEventListener('input', checkInputs);
    textInput2.addEventListener('input', checkInputs);


    // Слушатели для кнопок в модальном окне
    translateBtn.addEventListener('click', () => {
        const inputText = textInput1.value;
        const uniqueWordsList = findUniqueWordsNoNumbers(inputText, false);
        textInput1.value = addLineNumbers(uniqueWordsList);
        setTimeout(translateText, 1000);
    });
    startLearningBtn.addEventListener('click', handleStartLearning);
    saveToFileBtn.addEventListener('click', saveToFile);
    selectFromTextBtn.addEventListener('click', () => {
        modal.style.display = 'block';
    });
    
    
    
    // Функция для обновления внешнего вида кнопки
function updateLearnedWordsButtonState() {
    if (isLearnedWordsEnabled) {
        learnedWordsButton.classList.remove('disabled');
    } else {
        learnedWordsButton.classList.add('disabled');
    }
}



// Функция для обновления счетчика изученных слов из текущего файла
// Функция для обновления счетчика изученных слов
function updateLearnedWordsCounter(count = null) {
    // Обновляем оба счетчика
    updateTotalLearnedWordsCounter();
    
    if (count !== null) {
        updateCurrentFileLearnedCounter(count);
    }
}

function updateTotalLearnedWordsCounter() {
    const counter = document.getElementById('totalLearnedWordsCount');
    
    if (!counter || !isLearnedWordsEnabled) {
        return;
    }

    const learnedWords = getLearnedWords(currentLanguage);
    const count = learnedWords.length;

    if (count > 0) {
        counter.textContent = count;
        counter.classList.remove('hidden');
    } else {
        counter.classList.add('hidden');
    }
}


function updateCurrentFileLearnedCounter(count) {
    const counter = document.getElementById('currentFileLearnedCount');
    
    if (!counter || !isLearnedWordsEnabled || count === 0) {
        if (counter) {
            counter.classList.add('hidden');
        }
        return;
    }

    counter.textContent = count;
    counter.classList.remove('hidden');
}


// Инициализация при загрузке


function displayFileList() {
    const fileList = document.getElementById('fileList');
    fileList.innerHTML = '';

    // Группируем файлы по языкам
    const groupedFiles = {};
    
    fileOptions.forEach(file => {
        // Извлекаем язык из имени файла (до первого дефиса)
        const language = file.name.split('-')[0].trim();
        
        if (!groupedFiles[language]) {
            groupedFiles[language] = [];
        }
        groupedFiles[language].push(file);
    });

    // Создаем аккордеон для каждой группы
    Object.entries(groupedFiles).forEach(([language, files], index) => {
        const categoryDiv = document.createElement('div');
        categoryDiv.className = 'accordion-category';

        const header = document.createElement('div');
        header.className = 'category-header';
        header.innerHTML = `
            ${language} <i class="fas fa-chevron-down"></i>
        `;

        const content = document.createElement('div');
        content.className = 'category-content';
    

        files.forEach(file => {
            const fileButton = document.createElement('button');
            fileButton.className = 'menu-button slide-in';
            fileButton.innerHTML = `<i class="fas fa-file-download"></i> ${file.name}`;
            fileButton.addEventListener('click', () => loadFileFromUrl(file.url));
            content.appendChild(fileButton);
        });

        header.addEventListener('click', () => {
            // Закрываем все другие категории
            document.querySelectorAll('.category-content.active').forEach(el => {
                if (el !== content) {
                    el.classList.remove('active');
                    el.previousElementSibling.classList.remove('active');
                }
            });
            
            // Переключаем текущую категорию
            content.classList.toggle('active');
            header.classList.toggle('active');
        });

        categoryDiv.appendChild(header);
        categoryDiv.appendChild(content);
        fileList.appendChild(categoryDiv);
    });
}

function loadFileFromUrl(url) {
    // Извлекаем имя файла из URL
    const fileName = url.split('/').pop();

    fetch(url)
        .then(response => {
            if (!response.ok) {
                throw new Error('Network response was not ok');
            }
            const contentType = response.headers.get('content-type');
            if (contentType && contentType.includes('application/zip')) {
                return response.blob();
            }
            return response.text();
        })
        .then(content => {
            if (content instanceof Blob) {
                // Обработка zip-файла
                JSZip.loadAsync(content)
                    .then(zip => {
                        const textFile = Object.values(zip.files).find(f =>
                            f.name.endsWith('.txt') || f.name.endsWith('.csv'));
                        if (textFile) {
                            // Читаем как массив байтов, чтобы потом правильно декодировать
                            return textFile.async('uint8array').then(u8array => {
                                try {
                                    // Пробуем декодировать как UTF-8. 'fatal: true' вызовет ошибку на некорректных последовательностях.
                                    return new TextDecoder('utf-8', { fatal: true }).decode(u8array);
                                } catch (e) {
                                    // Если декодирование UTF-8 не удалось, предполагаем, что это windows-1251.
                                    console.log('UTF-8 decoding failed for ' + textFile.name + ', falling back to windows-1251.');
                                    return new TextDecoder('windows-1251').decode(u8array);
                                }
                            });
                        } else {
                            throw new Error('No text file found in the ZIP archive');
                        }
                    })
                    .then(text => {
                        // Устанавливаем язык из имени файла
                        try {
                            currentLanguage = getLanguageFromFileName(fileName);
                            updateLearnedWordsButtonTitle();
                            updateTotalLearnedWordsCounter();
                        } catch (e) {
                            console.error('Error setting language:', e);
                        }

                        wordInput.value = text;
                        urlModal.style.display = 'none';
                        updateFileInfo(fileName); // Используем оригинальное имя файла
                        document.getElementById('fileInfo').style.display = 'block';
                        resetLearningState();
                    });
            } else {
                // Обработка текстового файла (без изменений)
                try {
                    currentLanguage = getLanguageFromFileName(fileName);
                    updateLearnedWordsButtonTitle();
                    updateTotalLearnedWordsCounter();
                } catch (e) {
                    console.error('Error setting language:', e);
                }

                wordInput.value = content;
                urlModal.style.display = 'none';
                updateFileInfo(fileName); // Используем оригинальное имя файла
                document.getElementById('fileInfo').style.display = 'block';
                resetLearningState();
            }
        })
        .catch(error => {
            console.error('Error loading file:', error);
            alert('Ошибка при загрузке файла. Пожалуйста, попробуйте позже.');
        });
}

    urlButton.addEventListener('click', () => {
        urlModal.style.display = 'flex';
        displayFileList();
    });

    // Функции обработки файлов и управления состоянием
function resetLearningState() {
    words = [];
    originalWords = [];
    selectedWords = [];
    totalWords = 0;
    learnedWords = 0;
    currentWord = null;
    incorrectAnswers = 0;
    startTime = null;
    wordToLearn.textContent = '';
    translationOptions.innerHTML = '';
    learningPanel.style.display = 'none';
    peekAnswersButton.style.display = 'none';
    progressDisplay.textContent = '';
}

function getLanguageFromFileName(fileName) {
    const match = fileName.match(/^([^_]+)_/);
    if (!match) {
        throw new Error('Язык должен быть указан в имени файла до знака нижнего подчеркивания, например: Испанский_100 слов.txt');
    }
    return standardizeLanguageName(match[1]);
}



function handleFileUpload(event) {
    resetLearningState();
    const file = event.target.files[0];
    if (file) {
        try {
            currentLanguage = getLanguageFromFileName(file.name);
            updateLearnedWordsButtonTitle();
            updateTotalLearnedWordsCounter();
            
            if (file.name.endsWith('.zip')) {
                handleZipFile(file);
            } else {
                handleTextFile(file);
            }
        } catch (error) {
            alert(error.message);
            fileInput.value = ''; // Очищаем input файла
            return;
        }
    }
}

function handleTextFile(file) {
    const reader = new FileReader();
    reader.onload = event => {
        let content = event.target.result;
        if (isLearnedWordsEnabled) {
            const learnedWords = new Set(getLearnedWords());
            content = content.split('\n')
                .filter(line => {
                    const trimmedLine = line.trim();
                    return trimmedLine && !learnedWords.has(trimmedLine);
                })
                .join('\n');
        }
        wordInput.value = content;
        updateFileInfo(file.name);
    };
    reader.readAsText(file);
}

function handleZipFile(file) {
    JSZip.loadAsync(file)
        .then(zip => {
            const textFile = Object.values(zip.files).find(f =>
                f.name.endsWith('.txt') || f.name.endsWith('.csv'));
            if (textFile) {
                // Читаем как массив байтов и декодируем с проверкой
                return textFile.async('uint8array').then(u8array => {
                    try {
                        // Пробуем декодировать как UTF-8. 'fatal: true' вызовет ошибку.
                        return new TextDecoder('utf-8', { fatal: true }).decode(u8array);
                    } catch (e) {
                        // Если не удалось, пробуем windows-1251.
                        console.log('UTF-8 decoding for local file failed, falling back to windows-1251.');
                        return new TextDecoder('windows-1251').decode(u8array);
                    }
                });
            } else {
                throw new Error('No text file found in the ZIP archive');
            }
        })
        .then(content => {
            wordInput.value = content;
            updateFileInfo(file.name);
        })
        .catch(error => {
            console.error('Error processing ZIP file:', error);
            alert('Текстовый файл, содержащий список слов, не найден');
        });
}
// Функция для обновления счетчика изученных слов
function updateLearnedWordsCounter(count = null) {
    const counter = document.getElementById('learnedWordsCount');
    
    if (!isLearnedWordsEnabled) {
        counter.classList.add('hidden');
        return;
    }

    if (count === null) {
        // Если count не передан, подсчитываем количество изученных слов
        const learnedWords = getLearnedWords();
        count = learnedWords.length;
    }

    if (count > 0) {
        counter.textContent = count;
        counter.classList.remove('hidden');
    } else {
        counter.classList.add('hidden');
    }
}

// Обновим функцию updateFileInfo
function updateFileInfo(fileName) {
    document.querySelector('.file-label').innerHTML =
        `<i class="fas fa-file-upload"></i> ${fileName}`;
    document.getElementById('fileInfo').style.display = 'block';
    
    // Получаем актуальное количество слов
    const allWords = wordInput.value.split('\n')
        .filter(line => line.trim() && line.includes(';'));
    
    let wordCount = allWords.length;

    // Если включено отслеживание изученных слов, вычитаем их количество
    if (isLearnedWordsEnabled) {
        const learnedWordsSet = new Set(getLearnedWords());
        const availableWords = allWords.filter(line => !learnedWordsSet.has(line.trim()));
        const learnedCount = allWords.length - availableWords.length;
        wordCount = availableWords.length;
        
        // Обновляем только счетчик текущего файла
        updateCurrentFileLearnedCounter(learnedCount);
    } else {
        // Скрываем счетчик текущего файла
        updateCurrentFileLearnedCounter(0);
    }

    questionCountInput.value = wordCount;
    questionCountInput.max = wordCount;
    startQuestionInput.max = wordCount;
    endQuestionInput.max = wordCount;
    endQuestionInput.value = wordCount;

    if (wordCount === 0) {
        alert('Все слова из этого списка уже изучены!');
    }
}

    // Функции для обработки текстовых полей
    function checkInputs() {
        const text1 = textInput1.value.trim();
        const text2 = textInput2.value.trim();
        if (saveToFileBtn) {
            saveToFileBtn.disabled = !(text1 && text2);
        }
    }

function handleTextInputChange(input) {
    const text = input.value;
    const cursorPosition = input.selectionStart;
    const scrollTop = input.scrollTop;

    // Разбиваем текст на строки
    let lines = text.split('\n');

    // Удаляем существующие номера строк, но сохраняем структуру
    lines = lines.map(line => line.replace(/^\d+\.\s*/, ''));

    // Добавляем новые номера строк
    const numberedLines = lines.map((line, index) =>
        `${index + 1}. ${line}`
    );

    // Обновляем значение в текстовом поле
    input.value = numberedLines.join('\n');

    // Вычисляем новую позицию курсора
    let newPosition = 0;
    let charCount = 0;

    for (let i = 0; i < lines.length; i++) {
        charCount += lines[i].length + 1; // +1 для символа новой строки
        if (charCount >= cursorPosition) {
            newPosition = charCount - lines[i].length - 1 + cursorPosition - (charCount - lines[i].length - 1);
            break;
        }
    }

    // Восстанавливаем позицию курсора и прокрутки
    setTimeout(() => {
        input.selectionStart = newPosition;
        input.selectionEnd = newPosition;
        input.scrollTop = scrollTop;
    }, 0);
}



function setupTextInputHandlers(input) {
    let timeout;
    let lastValue = input.value;

    input.addEventListener('input', (e) => {
        clearTimeout(timeout);

        // Проверяем, действительно ли изменилось содержимое
        if (input.value !== lastValue) {
            timeout = setTimeout(() => {
                handleTextInputChange(input);
                lastValue = input.value;
            }, 300);
        }
    });

    input.addEventListener('keydown', (e) => {
        // Обработка Del и Backspace для пустых строк
        if ((e.key === 'Backspace' || e.key === 'Delete') && input.selectionStart === input.selectionEnd) {
            const lines = input.value.split('\n');
            const currentLineIndex = getCurrentLineIndex(input);

            // Проверяем, состоит ли текущая строка только из номера
            if (lines[currentLineIndex].trim().match(/^\d+\.$/)) {
                e.preventDefault(); // Предотвращаем стандартное поведение

                // Удаляем текущую строку
                lines.splice(currentLineIndex, 1);

                // Обновляем текст с перенумерацией
                input.value = lines.map((line, index) =>
                    `${index + 1}. ${line.replace(/^\d+\.\s*/, '')}`
                ).join('\n');

                // Устанавливаем курсор в начало предыдущей строки или в начало документа
                const newPosition = currentLineIndex > 0
                    ? getLineStartPosition(input, currentLineIndex - 1)
                    : 0;

                input.selectionStart = newPosition;
                input.selectionEnd = newPosition;
            }
        }
    });
}



// Получает индекс текущей строки
function getCurrentLineIndex(input) {
    const cursorPosition = input.selectionStart;
    const lines = input.value.split('\n');
    let charCount = 0;
    
    for (let i = 0; i < lines.length; i++) {
        charCount += lines[i].length + 1; // +1 для символа новой строки
        if (charCount > cursorPosition) {
            return i;
        }
    }
    
    return lines.length - 1;
}

// Получает позицию начала указанной строки
function getLineStartPosition(input, lineIndex) {
    const lines = input.value.split('\n');
    let position = 0;
    
    for (let i = 0; i < lineIndex; i++) {
        position += lines[i].length + 1; // +1 для символа новой строки
    }
    
    return position;
}


// Применяем обработчики к обоим полям ввода
setupTextInputHandlers(textInput1);
setupTextInputHandlers(textInput2);

    function handleBackspace(e) {
        if (e.key === 'Backspace' && this.value.trim().match(/^\d+\.\s*$/)) {
            this.value = '';
            e.preventDefault();
        }
    }

    let originalWords = []; // Переменная для хранения изначального списка слов

    function initializeOriginalWords() {
        if (originalWords.length === 0) {
            originalWords = [...words]; // Сохраняем оригинальный список слов для повторений
        }
    }

   // Обновленная функция startLearning
function startLearning() {
    // Проверяем наличие слов в текущем файле
    if (!wordInput.value) {
        alert('Пожалуйста, загрузите файл со словами.');
        return;
    }

    // Инициализируем оригинальный список слов из текущего значения wordInput
    originalWords = wordInput.value.split('\n')
        .map(line => {
            if (!line || !line.includes(';')) return null;
            const [word, translation] = line.split(';');
            return word && translation ? 
                { word: word.trim(), translation: translation.trim() } : null;
        })
        .filter(pair => pair !== null);

    // Проверка на минимальное количество слов
    if (!originalWords || originalWords.length < 5) {
        alert('Пожалуйста, введите как минимум 5 слов с переводами.');
        return;
    }

    // Устанавливаем `words` на основе `originalWords`
    words = [...originalWords];

    // Если включено отслеживание изученных слов, удаляем их из списка
    if (isLearnedWordsEnabled) {
        const learnedWordsSet = new Set(getLearnedWords());
        words = words.filter(pair => {
            const wordPair = `${pair.word};${pair.translation}`;
            return !learnedWordsSet.has(wordPair);
        });

        if (words.length === 0) {
            alert('Все слова из этого списка уже изучены!');
            return;
        }
    }

    // Случайный выбор или диапазон слов
    if (randomSelectionSwitch.checked) {
        const count = Math.min(parseInt(questionCountInput.value), words.length);
        words = getRandomWords(words, count);
    } else {
        const start = Math.min(parseInt(startQuestionInput.value) - 1, words.length - 1);
        const end = Math.min(parseInt(endQuestionInput.value), words.length);
        words = words.slice(start, end);
    }

    // Сохраняем выбранный список слов
    selectedWords = [...words];

    // Проверяем, есть ли слова для изучения
    if (words.length === 0) {
        alert('Нет слов для изучения. Пожалуйста, проверьте настройки или загрузите новый список слов.');
        return;
    }

    // Показать затемняющий слой и панель обучения
    document.getElementById('overlay').style.display = 'block';
    totalWords = words.length;
    learnedWords = 0;
    incorrectAnswers = 0;
    startTime = new Date();
    document.getElementById('fileInfo').style.display = 'none';
    learningPanel.style.display = 'block';
    peekAnswersButton.style.display = 'block';

    // Запуск обучения
    showNextWord();
    updateProgress();
}




// Обновленная функция restartLearning
function restartLearning() {
    // Восстанавливаем выбранный список слов
    words = [...selectedWords];
    learnedWords = 0;
    incorrectAnswers = 0;
    startTime = new Date();
    showNextWord();
    updateProgress();
}


    function endLearning() {
        // Скрыть затемняющий слой после завершения обучения
        document.getElementById('overlay').style.display = 'none';
        learningPanel.style.display = 'none';
    }

    function getRandomWords(array, count) {
        const shuffled = array.sort(() => 0.5 - Math.random());
        return shuffled.slice(0, count);
    }

    function showNextWord() {
        if (words.length === 0) {
            showCongratulations(); // Вызов функции показа поздравительного сообщения
            translationOptions.innerHTML = '';
            peekAnswersButton.style.display = 'none';
            return;
        }
        currentWord = words[Math.floor(Math.random() * words.length)];
        wordToLearn.textContent = currentWord.word;

        const options = getRandomOptions(currentWord.translation);
        translationOptions.innerHTML = '';

        // Создаем сетку позиций для предотвращения наложения
        const positions = generateNonOverlappingPositions(options.length);

        options.forEach((option, index) => {
            const button = document.createElement('button');
            button.textContent = option;
            button.classList.add('translation-option');
            button.style.backgroundColor = getRandomColor();

            // Используем предварительно рассчитанные позиции
            const position = positions[index];
            button.style.top = `${position.top}%`;
            button.style.left = `${position.left}%`;

            button.addEventListener('click', () => checkAnswer(option, button));
            translationOptions.appendChild(button);
        });
    }

function showCongratulations() {
    wordToLearn.innerHTML = `
        <div class="congratulations">
            <div class="congratulations-title">Обучение завершено!</div>
        
            <div class="statistics">
                <div><span class="label">Общее количество вопросов:</span> <span class="value">${totalWords}</span></div>
                <div><span class="label">Затраченное время:</span> <span class="value">${calculateTimeSpent()}</span></div>
                <div><span class="label">Среднее время на слово:</span> <span class="value">${calculateAverageTimePerWord()}</span></div>
                <div><span class="label">Количество неверных ответов:</span> <span class="value">${incorrectAnswers}</span></div>
            </div>
            <div class="congratulations-buttons">
                <button id="repeatButton" class="repeat-button">Повторить</button>
                ${incorrectAnswers === 0 ? 
                    `<button id="addToLearnedButton" class="add-to-learned-button">
                        Добавить в изученные: ${totalWords} слов(а)
                    </button>` 
                    : ''}
                <button id="swapAndRepeatButton" class="swap-repeat-button">Перевернуть</button>
            </div>
        </div>`;

    // Показываем кнопки через 1 секунду
    setTimeout(() => {
        document.querySelector('.congratulations-buttons').classList.add('show');
    }, 1000);

    // Назначаем обработчики для кнопок
    document.getElementById('repeatButton').addEventListener('click', restartLearning);
    document.getElementById('swapAndRepeatButton').addEventListener('click', swapAndRestartLearning);
    
    // Добавляем обработчик для новой кнопки, если она существует
    const addToLearnedButton = document.getElementById('addToLearnedButton');
    if (addToLearnedButton) {
        addToLearnedButton.addEventListener('click', addCurrentWordsToLearned);
    }
}

// Новая функция для добавления текущего списка слов в изученные
function addCurrentWordsToLearned() {
    if (!isLearnedWordsEnabled) return;

    const key = getStorageKey(currentLanguage);
    let learnedWords = getLearnedWords(currentLanguage);
    let addedCount = 0;

    // Добавляем все слова из текущего сеанса
    selectedWords.forEach(({ word, translation }) => {
        const wordPair = `${word};${translation}`;
        if (!learnedWords.includes(wordPair)) {
            learnedWords.push(wordPair);
            addedCount++;
        }
    });

    // Сохраняем обновленный список
    try {
        localStorage.setItem(key, JSON.stringify(learnedWords));
        updateTotalLearnedWordsCounter();
        updateCurrentFileLearnedCounter(addedCount);
        
        // Отключаем кнопку после успешного добавления
        const addButton = document.getElementById('addToLearnedButton');
        if (addButton) {
            addButton.disabled = true;
            addButton.textContent = 'Добавлено!';
        }

        // Добавляем отладочную информацию
        console.log('Added words to learned:', addedCount);
        console.log('Current learned words:', learnedWords);
        debugLocalStorage();
    } catch (e) {
        console.error('Error saving to localStorage:', e);
        alert('Произошла ошибка при сохранении изученных слов');
    }
}


    // Функция для генерации неперекрывающихся позиций
    function generateNonOverlappingPositions(count) {
        const positions = [];
        const rows = 3; // 3 строки
        const minDistance = 20; // Минимальное расстояние между кнопками в процентах

        for (let i = 0; i < count; i++) {
            let position;
            let attempts = 0;
            const maxAttempts = 50;

            do {
                position = {
                    top: (Math.floor(i / (count / rows)) * (100 / rows)) + (Math.random() * (100 / rows)),
                    left: Math.random() * 80 + 10 // 10-90%
                };

                // Проверяем, не слишком ли близко к другим позициям
                const isTooClose = positions.some(existingPos => {
                    const horizontalDistance = Math.abs(existingPos.left - position.left);
                    const verticalDistance = Math.abs(existingPos.top - position.top);
                    return horizontalDistance < minDistance && verticalDistance < minDistance;
                });

                attempts++;
                if (attempts >= maxAttempts) {
                    // Если не можем найти подходящую позицию, используем запасной вариант
                    position.left = (i * (80 / count)) + 10;
                    break;
                }
            } while (positions.length > 0 && attempts < maxAttempts &&
                    positions.some(existingPos => {
                        const horizontalDistance = Math.abs(existingPos.left - position.left);
                        const verticalDistance = Math.abs(existingPos.top - position.top);
                        return horizontalDistance < minDistance && verticalDistance < minDistance;
                    }));

            positions.push(position);
        }

        return positions;
    }

    function getRandomOptions(correctAnswer) {
        const optionsCount = getOptionsCount();
        const options = [correctAnswer];
        const availableTranslations = words.map(w => w.translation)
            .filter(t => t !== correctAnswer);
        while (options.length < optionsCount && availableTranslations.length > 0) {
            const randomIndex = Math.floor(Math.random() * availableTranslations.length);
            options.push(availableTranslations.splice(randomIndex, 1)[0]);
        }
        return shuffleArray(options);
    }

    // Обновленная функция checkAnswer
function checkAnswer(selectedAnswer, button) {
    button.classList.remove('correct-animation', 'wrong-animation', 'flash-effect');

    if (selectedAnswer === currentWord.translation) {
        button.classList.add('correct-animation', 'flash-effect');
        
    
        setTimeout(() => {
            words = words.filter(w => w !== currentWord);
            learnedWords++;
            updateProgress();
            showNextWord();
        }, 800);
    } else {
        button.classList.add('wrong-animation');
        incorrectAnswers++;

        setTimeout(() => {
            showNextWord();
        }, 800);
    }
}

    // Вспомогательные функции
    function shuffleArray(array) {
        for (let i = array.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [array[i], array[j]] = [array[j], array[i]];
        }
        return array;
    }

    function updateProgress() {
        progressDisplay.textContent = `Изучено ${learnedWords} из ${totalWords} слов`;
    }

    function getRandomColor() {
        const hue = Math.random() * 360;
        const saturation = 60 + Math.random() * 20; // 60-80%
        const lightness = 65 + Math.random() * 15; // 65-80%
        return `hsl(${hue}, ${saturation}%, ${lightness}%)`;
    }

    function togglePeekAnswers() {
        const buttons = translationOptions.querySelectorAll('.translation-option');
        buttons.forEach(button => {
            if (button.textContent === currentWord.translation) {
                button.style.border = button.style.border ? '' : '3px solid #4CAF50';
            }
        });
    }

    function toggleSelectionMode() {
        const spinInputContainer = document.querySelector('.spin-input-container');
        const rangeInputs = document.querySelector('.range-inputs');
        if (randomSelectionSwitch.checked) {
            spinInputContainer.style.display = 'flex';
            rangeInputs.style.display = 'none';
        } else {
            spinInputContainer.style.display = 'none';
            rangeInputs.style.display = 'flex';
        }
    }

function handleStartLearning() {
    // Очищаем предыдущий список слов и сбрасываем состояние
    resetLearningState();
    originalWords = []; // Очищаем оригинальный список слов

    let text1 = textInput1.value.split('\n')
        .map(line => line.replace(/^\d+\.\s*/, '').trim())
        .filter(line => line.length > 0);
    let text2 = textInput2.value.split('\n')
        .map(line => line.replace(/^\d+\.\s*/, '').trim())
        .filter(line => line.length > 0);

    if (text1.length !== text2.length) {
        alert('Количество непустых строк в обоих полях должно совпадать!\n' +
              `Поле 1: ${text1.length} строк\n` +
              `Поле 2: ${text2.length} строк`);
        return;
    }

    let combinedText = text1.map((line, index) => `${line};${text2[index]}`).join('\n');
    wordInput.value = combinedText;
    modal.style.display = 'none';
    updateFileInfo('список_слов.txt');
    textInput1.value = '';
    textInput2.value = '';

    // Инициализируем новый список слов
    words = combinedText.split('\n').map(line => {
        const [word, translation] = line.split(';');
        return { word: word.trim(), translation: translation.trim() };
    }).filter(pair => pair.word && pair.translation);

    // Автоматически запускаем обучение
    startLearning();
}

    // Повторное обучение с измененным списком (слова и переводы поменяны местами)
    function swapAndRestartLearning() {
        // Меняем слова местами
        words = selectedWords.map(({ word, translation }) => ({ word: translation, translation: word }));
        learnedWords = 0;
        incorrectAnswers = 0;
        startTime = new Date();
        showNextWord();
        updateProgress();
    }

    function downloadWordsAsZip(content) {
        // Создаем новый ZIP
        const zip = new JSZip();

        // Добавляем текстовый файл в ZIP с максимальным уровнем сжатия
        zip.file("список_слов.txt", content, {
            compression: "DEFLATE",
            compressionOptions: {
                level: 9 // максимальный уровень сжатия (1-9)
            }
        });

        // Генерируем ZIP-файл с максимальным сжатием
        zip.generateAsync({
            type: "blob",
            compression: "DEFLATE",
            compressionOptions: {
                level: 9
            }
        })
        .then(function(blob) {
            // Создаем ссылку для скачивания
            const downloadLink = document.createElement('a');
            downloadLink.href = URL.createObjectURL(blob);
            downloadLink.download = "список_слов.zip";

            // Добавляем ссылку в документ (невидимую)
            document.body.appendChild(downloadLink);

            // Имитируем клик по ссылке
            downloadLink.click();

            // Удаляем ссылку
            document.body.removeChild(downloadLink);

            // Освобождаем URL
            URL.revokeObjectURL(downloadLink.href);
        });
    }

    function saveToFile() {
        let text1 = textInput1.value.split('\n')
            .map(line => line.replace(/^\d+\.\s*/, '').trim())
            .filter(line => line.length > 0);
        let text2 = textInput2.value.split('\n')
            .map(line => line.replace(/^\d+\.\s*/, '').trim())
            .filter(line => line.length > 0);

        if (text1.length !== text2.length) {
            alert('Количество непустых строк в обоих полях должно совпадать!\n' +
                  `Поле 1: ${text1.length} строк\n` +
                  `Поле 2: ${text2.length} строк`);
            return;
        }

        let combinedText = text1.map((line, index) => `${line};${text2[index]}`).join('\n');
        downloadWordsAsZip(combinedText);
    }

function translateText() {
    const translatorSelect = document.getElementById('translatorSelect');
    const fromLang = document.getElementById('fromLang').value;
    const toLang = document.getElementById('toLang').value;

    const cleanText = textInput1.value
        .split('\n')
        .map(line => line.replace(/^\d+\.\s*/, '').trim())
        .filter(line => line.length > 0)
        .join('\n');

    if (translatorSelect.value === 'google') {
        // Google Translate
        const url = `https://translate.google.com/?sl=${fromLang}&tl=${toLang}&text=${encodeURIComponent(cleanText)}`;
        window.open(url, '_blank');
    } else {
        // OnlineDocTranslator
        // Сначала скачиваем файл
        downloadTextFile(cleanText, 'words_to_translate.txt');
        // Затем открываем сайт
        window.open('https://www.onlinedoctranslator.com/ru/translationform', '_blank');
    }
}


// Обработка двойного клика
learnedWordsButton.addEventListener('dblclick', () => {
    isLearnedWordsEnabled = !isLearnedWordsEnabled;
    localStorage.setItem('learnedWordsEnabled', isLearnedWordsEnabled);
    updateLearnedWordsButtonState();
    updateTotalLearnedWordsCounter();
    updateCurrentFileLearnedCounter(0); // Сбрасываем счетчик текущего файла
});

// Обработка одиночного клика
learnedWordsButton.addEventListener('click', (e) => {
    e.stopPropagation();
    learnedWordsMenu.style.display = learnedWordsMenu.style.display === 'block' ? 'none' : 'block';
});

// Закрытие меню при клике вне его
document.addEventListener('click', () => {
    learnedWordsMenu.style.display = 'none';
});

// Функции для работы с изученными словами
function addToLearnedWords(word, translation) {
    if (!isLearnedWordsEnabled) return;
    
    const key = getStorageKey(currentLanguage);
    let learnedWords = getLearnedWords(currentLanguage);
    const wordPair = `${word};${translation}`;
    
    if (!learnedWords.includes(wordPair)) {
        learnedWords.push(wordPair);
        try {
            localStorage.setItem(key, JSON.stringify(learnedWords));
            updateTotalLearnedWordsCounter();
        } catch (e) {
            console.error('Error saving to localStorage:', e);
        }
    }
}


function getStorageKey(language) {
    // Стандартизируем название языка при создании ключа хранилища
    return `learnedWords_${standardizeLanguageName(language)}`;
}

function getLearnedWords(language = currentLanguage) {
    try {
        const key = getStorageKey(language);
        const stored = localStorage.getItem(key);
        return stored ? JSON.parse(stored) : [];
    } catch (e) {
        console.error(`Error reading ${language} words from localStorage:`, e);
        return [];
    }
}

function debugLocalStorage() {
    console.log('Current Language:', currentLanguage);
    console.log('Storage Key:', getStorageKey(currentLanguage));
    console.log('Learned Words:', getLearnedWords(currentLanguage));
    // Выводим все ключи в localStorage, содержащие "learnedWords"
    Object.keys(localStorage).forEach(key => {
        if (key.includes('learnedWords')) {
            console.log(`${key}:`, localStorage.getItem(key));
        }
    });
}

function saveLearnedWords(words, language) {
    const key = getStorageKey(language);
    try {
        localStorage.setItem(key, JSON.stringify(words));
    } catch (e) {
        console.error(`Error saving ${language} words to localStorage:`, e);
    }
}

function updateLearnedWordsButtonTitle() {
    const title = `Изученные слова (${currentLanguage})`;
    learnedWordsButton.setAttribute('title', title);
}

function standardizeLanguageName(language) {
    // Приводим первую букву к верхнему регистру, остальные к нижнему
    return language.charAt(0).toUpperCase() + language.slice(1).toLowerCase();
}

function downloadTextFile(content, filename) {
    const blob = new Blob([content], { type: 'text/plain;charset=utf-8' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
}


// Обработчики для пунктов меню
document.getElementById('downloadLearnedWords').addEventListener('click', () => {
    const fileName = `learned_words_${currentLanguage}`;
    let learnedWords = getLearnedWords(currentLanguage);
    
    if (learnedWords.length === 0) {
        alert('Список изученных слов пуст!');
        return;
    }

    // Сортируем слова
    learnedWords.sort((a, b) => a.localeCompare(b, 'ru'));
    
    // Создаем содержимое файла
    const content = learnedWords.join('\n');
    
    try {
        // Создаем и скачиваем ZIP-файл
        const zip = new JSZip();
        zip.file(`${fileName}.txt`, content);
        
        zip.generateAsync({
            type: "blob",
            compression: "DEFLATE",
            compressionOptions: { level: 9 }
        }).then(function(blob) {
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `${fileName}.zip`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        });
    } catch (e) {
        console.error('Error in downloadLearnedWords:', e);
        alert('Произошла ошибка при сохранении файла');
    }
});


// Обновляем обработчик для замены списка
document.getElementById('replaceLearnedWords').addEventListener('click', () => {
    const input = document.createElement('input');
    input.type = 'file';
    input.accept = '.txt';
    input.onchange = (e) => {
        const file = e.target.files[0];
        const reader = new FileReader();
        reader.onload = (event) => {
            if (confirm(`Заменить текущий список изученных слов для языка ${currentLanguage}?`)) {
                try {
                    const words = event.target.result.split('\n')
                        .filter(line => line.trim())
                        .map(line => line.trim());
                    saveLearnedWords(words, currentLanguage);
                    updateTotalLearnedWordsCounter();
                    alert('Список изученных слов успешно обновлен');
                } catch (e) {
                    console.error('Error replacing learned words:', e);
                    alert('Произошла ошибка при обновлении списка');
                }
            }
        };
        reader.readAsText(file);
    };
    input.click();
});


document.getElementById('deleteLearnedWords').addEventListener('click', () => {
    if (confirm('Вы уверены, что хотите удалить список изученных слов?')) {
        localStorage.removeItem('learnedWords');
        updateTotalLearnedWordsCounter();
        updateCurrentFileLearnedCounter(0);
    }
});


    function findUniqueWordsNoNumbers(text, caseSensitive) {
        const words = text.split(/[^a-zA-Zа-яА-ЯёЁ]+/)
            .filter(word => {
                // Фильтруем слова: длина больше 1 символа
                const cleanWord = caseSensitive ? word : word.toLowerCase();
                return cleanWord.length > 1;
            })
            .map(word => caseSensitive ? word : word.toLowerCase());

        // Создаем Set для хранения уникальных слов
        const uniqueWords = new Set(words);

        // Преобразуем Set обратно в массив и сортируем
        const sortedUniqueWords = Array.from(uniqueWords).sort((a, b) =>
            a.localeCompare(b, ['ru', 'en'], {sensitivity: caseSensitive ? 'case' : 'base'})
        );

        // Возвращаем отсортированный список слов
        return sortedUniqueWords.join('\n');
    }

    function addLineNumbers(text) {
        const lines = text.trim().split('\n')
            .filter(line => line.replace(/^\d+\.\s*/, '').trim().length > 0);
        return lines.map((line, index) => {
            const cleanLine = line.replace(/^\d+\.\s*/, '').trim();
            return cleanLine.length > 0 ? `${index + 1}. ${cleanLine}` : '';
        }).filter(Boolean).join('\n');
    }

    function syncScroll(source, target) {
        target.scrollTop = source.scrollTop;
    }

    function getOptionsCount() {
        return Math.max(2, Math.min(10, parseInt(optionsCountInput.value) || 5));
    }

    // Закрытие модальных окон при клике вне их области
    window.addEventListener('click', (event) => {
        if (event.target === helpModal) {
            helpModal.style.display = 'none';
        }
        if (event.target === urlModal) {
            urlModal.style.display = 'none';
        }
        if (event.target === modal) {
            modal.style.display = 'none';
        }
    });

    // Инициализация спиннеров
    const spinDown = document.querySelector('.spin-down');
    const spinUp = document.querySelector('.spin-up');

    spinDown.addEventListener('click', () => {
        if (questionCountInput.value > 1) {
            questionCountInput.value = parseInt(questionCountInput.value) - 1;
        }
    });

    spinUp.addEventListener('click', () => {
        if (questionCountInput.value < parseInt(questionCountInput.max)) {
            questionCountInput.value = parseInt(questionCountInput.value) + 1;
        }
    });

    // Получаем ссылку на кнопку
    const swapButton = document.getElementById('swapButton');

    // Добавляем обработчик события для кнопки
    swapButton.addEventListener('click', () => {
        const textarea = document.getElementById('word-input');
        const text = textarea.value;

        // Если текстовое поле пустое, ничего не делаем
        if (!text.trim()) return;

        // Разбиваем текст на строки и обрабатываем каждую
        const swappedLines = text.split('\n').map(line => {
            const trimmedLine = line.trim();
            if (!trimmedLine || !trimmedLine.includes(';')) return line;

            // Разбиваем строку на слово и перевод
            const [word, translation] = trimmedLine.split(';').map(part => part.trim());

            // Возвращаем строку с поменянными местами словом и переводом
            return `${translation};${word}`;
        });

        // Обновляем содержимое текстового поля
        textarea.value = swappedLines.join('\n');

        // Добавляем анимацию для кнопки
        swapButton.classList.add('rotate-animation');
        setTimeout(() => {
            swapButton.classList.remove('rotate-animation');
        }, 500);
    });

  // Получаем ссылки на элементы
const overlay = document.getElementById('overlay');


// Функция для показа затемнения и увеличения панели
function showOverlay() {
    overlay.style.display = 'block';
    learningPanel.classList.add('overlay-active');
}

// Функция для скрытия затемнения и возврата панели к нормальному размеру
function hideOverlay() {
    overlay.style.display = 'none';
    learningPanel.classList.remove('overlay-active');
}

// Показ затемнения и расширение панели при старте обучения
startButton.addEventListener('click', () => {
    showOverlay();
    startLearning();
});

// Скрытие затемнения при клике вне `learning-panel`
overlay.addEventListener('click', (event) => {
    if (event.target === overlay) {
        hideOverlay();
    }
});

// Показ затемнения при клике внутри `learning-panel`
learningPanel.addEventListener('click', (event) => {
    event.stopPropagation(); // Предотвращаем всплытие события
    showOverlay();
});


    // Добавляем стиль для анимации вращения
    const style = document.createElement('style');
    style.textContent = `
        @keyframes rotate {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }
        .rotate-animation {
            animation: rotate 0.5s ease-in-out;
        }
    `;
    document.head.appendChild(style);
    
    document.getElementById('clearDataButton').addEventListener('click', () => {
    if (confirm('Вы уверены, что хотите удалить все данные из локального хранилища?')) {
        // Перебираем все ключи в localStorage и удаляем те, которые содержат "learnedWords"
        Object.keys(localStorage).forEach(key => {
            if (key.includes('learnedWords')) {
                localStorage.removeItem(key);
            }
        });

        // Обновляем счетчики и интерфейс
        updateTotalLearnedWordsCounter();
        updateCurrentFileLearnedCounter(0);
        alert('Все данные успешно удалены.');
    }
});

    // Добавляем обработчики событий для кнопок spin-down и spin-up
    document.querySelector('#startQuestionDown').addEventListener('click', () => {
        if (startQuestionInput.value > 1) {
            startQuestionInput.value = parseInt(startQuestionInput.value) - 1;
        }
    });

    document.querySelector('#startQuestionUp').addEventListener('click', () => {
        if (startQuestionInput.value < parseInt(startQuestionInput.max)) {
            startQuestionInput.value = parseInt(startQuestionInput.value) + 1;
        }
    });

    document.querySelector('#endQuestionDown').addEventListener('click', () => {
        if (endQuestionInput.value > 1) {
            endQuestionInput.value = parseInt(endQuestionInput.value) - 1;
        }
    });

    document.querySelector('#endQuestionUp').addEventListener('click', () => {
        if (endQuestionInput.value < parseInt(endQuestionInput.max)) {
            endQuestionInput.value = parseInt(endQuestionInput.value) + 1;
        }
    });

    document.addEventListener('click', (event) => {
        if (event.target.id === 'repeatButton') {
            restartLearning();
        } else if (event.target.id === 'swapAndRepeatButton') {
            swapAndRestartLearning();
        }
    });

    // Обработка изменения количества вариантов ответов
    optionsCountInput.addEventListener('change', () => {
        const value = parseInt(optionsCountInput.value);
        if (value < 2) {
            optionsCountInput.value = 2;
        } else if (value > 10) {
            optionsCountInput.value = 10;
        }
    });

    // Функция для расчета затраченного времени
  // Функция для расчета затраченного времени
function calculateTimeSpent() {
    const endTime = new Date();
    const timeSpent = (endTime - startTime) / 1000; // в секундах
    const minutes = Math.floor(timeSpent / 60);
    const seconds = Math.floor(timeSpent % 60);
    return `${minutes} мин ${seconds} сек`;
}

// Функция для расчета среднего времени на слово
function calculateAverageTimePerWord() {
    const totalTimeSpent = (new Date() - startTime) / 1000; // в секундах
    const averageTime = totalTimeSpent / totalWords;
    const minutes = Math.floor(averageTime / 60);
    const seconds = Math.floor(averageTime % 60);
    return `${minutes} мин ${seconds} сек`;
}

});



</script>

</body>
</html>
