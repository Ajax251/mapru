<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>Редактор изображений</title>
    <link rel="icon" href="img/picture.png" type="image/png">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="webfonts/all.min.css">
    <script src="webfonts/heic2any.min.js"></script>
    <script src="webfonts/jszip.min.js"></script> 
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        :root {
            --primary-bg: #f7f9fc;
            --sidebar-bg: rgba(255, 255, 255, 0.9);
            --button-bg: #e3f2fd;
            --button-hover-bg: #e3f2fd;
            --accent-color: #2196F3;
            --accent-dark: #1976D2;
            --text-primary: #37474F;
            --text-secondary: #6c757d;
            --border-color: #e0e0e0;
            --shadow-color: rgba(0, 0, 0, 0.08);
            --shadow-strong-color: rgba(33, 150, 243, 0.2);
            --sidebar-width: 80px;
        }
        body {
            font-family: 'Inter', 'Segoe UI', Tahoma, sans-serif;
            background: var(--primary-bg);
            color: var(--text-primary);
            height: 100vh;
            overflow: hidden;
            display: flex;
        }
        ::-webkit-scrollbar { width: 14px; height: 14px; }
        ::-webkit-scrollbar-track { background: #e8e8e8; border-radius: 7px; }
        ::-webkit-scrollbar-thumb { background: #b0bec5; border-radius: 7px; border: 3px solid #e8e8e8; }
        ::-webkit-scrollbar-thumb:hover { background: #90a4ae; }
        ::-webkit-scrollbar-corner { background: #e8e8e8; }

    .sidebar {
            width: var(--sidebar-width);
            background: var(--sidebar-bg);
            backdrop-filter: blur(10px);
            box-shadow: 1px 0 15px var(--shadow-color);
            padding: 15px 5px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 12px;
        
            z-index: 200; 
            border-right: 1px solid var(--border-color);
            overflow-y: auto;
        }
        .sidebar-btn {
            width: 55px; height: 55px; border-radius: 16px; border: none;
            background: var(--button-bg); color: var(--accent-color); cursor: pointer;
            display: flex; align-items: center; justify-content: center;
            position: relative; box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05); flex-shrink: 0;
            transition: all 0.2s ease;
        }
        .sidebar-btn:disabled {
            cursor: not-allowed;
            opacity: 0.5;
            background-color: #e9ecef;
        }
        .sidebar-btn.active { background-color: var(--accent-color); color: white; }
        .sidebar-btn.active i { color: white; }
        .sidebar-btn:hover:not(.active):not(:disabled) {
            box-shadow: 0 4px 10px var(--shadow-strong-color);
            background-color: var(--button-hover-bg);
            transform: translateY(-2px);
        }
        .sidebar-btn i { font-size: 1.6em; }
        .sidebar-btn:hover:not(.active):not(:disabled) i { color: var(--accent-dark); }
        .sidebar-separator { width: 80%; height: 1px; background-color: var(--border-color); margin: 8px 0; }
        .sidebar-control-group {
            display: flex; flex-direction: column; align-items: center;
            gap: 6px; margin-bottom: 5px; width: 100%;
        }
        .sidebar-control-group label { font-size: 0.75em; color: var(--text-secondary); font-weight: 500; }
        .sidebar-control-group input, .sidebar-control-group select {
            width: 60px; padding: 5px; border: 1px solid var(--border-color);
            border-radius: 8px; text-align: center; font-size: 0.8em;
            background: #fff; -moz-appearance: textfield;
        }
        .sidebar-control-group input[type="color"] { width: 45px; height: 30px; padding: 2px; border-radius: 8px; cursor: pointer; }
        .sidebar-control-group input::-webkit-outer-spin-button, .sidebar-control-group input::-webkit-inner-spin-button { -webkit-appearance: none; margin: 0; }

      .main-content { 
            flex: 1; 
            display: flex; 
            flex-direction: column; 
            position: relative; 
            overflow: hidden; 
            z-index: 1;
        }
        
        .drop-zone {
            position: fixed; top: 15px; left: calc(var(--sidebar-width) + 15px); right: 15px; bottom: 15px;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            background: rgba(255, 255, 255, 0.8); backdrop-filter: blur(5px); z-index: 1000;
            border: 2px dashed var(--accent-color); border-radius: 20px;
            transition: all 0.3s ease;
        }
        .drop-zone.dragover { background: rgba(33, 150, 243, 0.1); border-color: var(--accent-dark); }
        .drop-zone-content { text-align: center; color: var(--accent-color); }
        .drop-zone-icon { width: 100px; height: 100px; margin-bottom: 20px; opacity: 0.8; }
        .drop-zone-text { font-size: 1.2em; color: var(--text-secondary); font-weight: 500; }

.image-container {
            flex: 1;
            position: relative;
            overflow: auto;
         
            z-index: 0;
            isolation: isolate; 


    background-color: #fdfbf7;
    background-image: radial-gradient(#e8e4dc 1px, transparent 1px);
    background-size: 15px 15px;
}


        .canvas-wrapper {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            min-width: 100%;
            min-height: 100%;
            padding: 40px;
        }
        
        #imageWrapper {
            position: relative;
            box-shadow: 0 10px 40px rgba(0,0,0,0.2);
            line-height: 0;
            cursor: default;
            flex-shrink: 0;
            transform-origin: center center;
            background: white;
        }
        
        #imagePreview {
            display: none;
            opacity: 0;
            vertical-align: top;
            background: white;
        }
        #annotationCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 998;
        }
        .selection {
            position: absolute;
            border: 2px dashed var(--accent-color);
            background: rgba(33, 150, 243, 0.1);
            pointer-events: none;
            z-index: 999;
            display: none;
            box-shadow: 0 0 0 9999px rgba(0, 0, 0, 0.3);
        }

        .status-bar, .zoom-info, .selection-info, .history-info {
            position: fixed; background: rgba(255, 255, 255, 0.95); backdrop-filter: blur(10px);
            color: var(--text-primary); padding: 8px 16px; border-radius: 30px; font-size: 14px;
            box-shadow: 0 4px 15px var(--shadow-color); z-index: 100;
        }
        .status-bar { bottom: 20px; left: 50%; transform: translateX(-50%); }
        .zoom-info { 
            top: 20px; right: 20px; cursor: pointer; user-select: none;
            display: flex; align-items: center; gap: 8px;
        }
        .zoom-info:hover { background: rgba(255, 255, 255, 1); }
        .zoom-btn {
            width: 24px; height: 24px; border: none; background: var(--button-bg);
            border-radius: 50%; cursor: pointer; display: flex; align-items: center;
            justify-content: center; font-size: 14px; color: var(--accent-color);
            transition: all 0.2s ease;
        }
        .zoom-btn:hover { background: var(--accent-color); color: white; }
        .selection-info { top: 20px; left: calc(var(--sidebar-width) + 20px); display: none; }
        .history-info { 
            bottom: 20px; right: 20px; 
            font-size: 12px; 
            color: var(--text-secondary);
            padding: 6px 12px;
        }

        .context-menu {
            position: fixed; background: white; border-radius: 12px; padding: 8px;
            box-shadow: 0 8px 25px rgba(0,0,0,0.15); display: none; z-index: 1001;
            min-width: 200px; border: 1px solid var(--border-color);
        }
        .context-menu-item {
            padding: 10px 12px; color: var(--text-primary); cursor: pointer;
            display: flex; align-items: center; gap: 10px; border-radius: 8px;
            transition: all 0.15s ease;
        }
        .context-menu-item:hover { background: var(--button-bg); color: var(--accent-dark); }
        .context-menu-item i { font-size: 1.1em; width: 20px; text-align: center; color: var(--text-secondary); }
        .context-menu-item:hover i { color: var(--accent-dark); }
        .context-menu-separator { height: 1px; background: var(--border-color); margin: 5px 0; }
        
        #fileInput, #jsonInput { display: none; }
        
     .modal-backdrop {
    position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5);
    z-index: 2000; display: none; align-items: center; justify-content: center;
}
        
       .modal-content {
    background: white; padding: 25px; border-radius: 16px; box-shadow: 0 15px 50px rgba(0,0,0,0.3);
    width: 90%; max-width: 480px;
}
        .modal-content h3 { margin-bottom: 20px; font-weight: 700; color: var(--text-primary); font-size: 1.3em; }
        
        .modal-text-input-row {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
        }
        .modal-text-input-row input[type="text"] {
            flex: 1;
            padding: 12px 15px;
            border-radius: 10px;
            border: 2px solid var(--border-color);
            font-size: 1em;
            transition: all 0.2s ease;
        }
        .modal-text-input-row input[type="text"]:focus {
            border-color: var(--accent-color);
            box-shadow: 0 0 0 4px rgba(33, 150, 243, 0.15);
            outline: none;
        }
        .modal-text-input-row input[type="color"] {
            width: 50px;
            height: 46px;
            padding: 3px;
            border: 2px solid var(--border-color);
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        .modal-text-input-row input[type="color"]:hover {
            border-color: var(--accent-color);
        }
        
        .modal-style-buttons {
            display: flex;
            gap: 8px;
            margin-bottom: 15px;
        }
        .modal-style-btn {
            width: 42px;
            height: 42px;
            border: 2px solid var(--border-color);
            background: #fff;
            border-radius: 10px;
            cursor: pointer;
            font-size: 1em; 
            color: var(--text-secondary);
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        }
        .modal-style-btn:hover {
            background-color: var(--button-bg);
            color: var(--accent-dark);
            border-color: var(--accent-color);
        }
        .modal-style-btn.active {
            background-color: var(--accent-color);
            color: white;
            border-color: var(--accent-dark);
        }
        
        .modal-buttons { display: flex; justify-content: flex-end; gap: 10px; margin-top: 20px; }
        .modal-btn {
            padding: 12px 24px; border: none; border-radius: 10px; font-size: 1em;
            cursor: pointer; font-weight: 600; transition: all 0.2s ease;
        }
        #modalOkBtn { background: var(--accent-color); color: white; }
        #modalOkBtn:hover { background: var(--accent-dark); transform: translateY(-1px); }
        #modalCancelBtn { background: #e9ecef; color: var(--text-primary); }
        #modalCancelBtn:hover { background: #dee2e6; }
        
        .modal-options-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px 20px;
            margin-bottom: 10px;
            font-size: 0.9em;
        }
        .modal-option-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        .modal-checkbox-label {
            display: flex;
            align-items: center;
            cursor: pointer;
            gap: 8px;
            font-weight: 500;
        }
        .modal-checkbox-label input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--accent-color);
        }
        .modal-radio-group {
            display: flex;
            flex-direction: column;
            gap: 10px;
            padding-left: 25px;
        }
        .modal-radio-group input[type="radio"] {
            accent-color: var(--accent-color);
        }
        .blur-control-group {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .blur-control-group input[type="range"] { 
            flex: 1; 
            accent-color: var(--accent-color);
        }
        .blur-control-group input[type="number"] { 
            width: 60px; 
            text-align: center;
            padding: 5px;
            border: 1px solid var(--border-color);
                                    border-radius: 6px;
        }
        
        .notification-toast {
    position: fixed;
    top: 80px;
    left: 50%;
    transform: translateX(-50%) translateY(-20px);
    background: #4CAF50;
    color: white;
    padding: 12px 24px;
    border-radius: 8px;
    font-size: 14px;
    font-weight: 500;
    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.2);
    z-index: 3000;
    opacity: 0;
    transition: all 0.3s ease;
    pointer-events: none;
}

.notification-toast.show {
    opacity: 1;
    transform: translateX(-50%) translateY(0);
}

.modal-template-row {
    display: flex;
    gap: 8px;
    margin-bottom: 15px;
    align-items: center;
}
.modal-template-row select {
    flex: 1;
    padding: 10px 12px;
    border-radius: 10px;
    border: 2px solid var(--border-color);
    font-size: 0.95em;
    background: #fff;
    transition: all 0.2s ease;
}
.modal-template-row select:focus {
    border-color: var(--accent-color);
    box-shadow: 0 0 0 4px rgba(33, 150, 243, 0.15);
    outline: none;
}
.modal-template-btn {
    width: 42px;
    height: 42px;
    border: 2px solid var(--border-color);
    background: #fff;
    border-radius: 10px;
    cursor: pointer;
    font-size: 0.95em;
    color: var(--text-secondary);
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.2s ease;
    flex-shrink: 0;
}
.modal-template-btn:hover {
    border-color: var(--accent-color);
    color: var(--accent-dark);
    background-color: var(--button-bg);
}
.modal-template-btn.delete:hover {
    border-color: #f44336;
    color: #f44336;
    background-color: #ffebee;
}

    </style>
</head>
<body>
    <div class="sidebar">
        <button class="sidebar-btn" onclick="document.getElementById('fileInput').click()" title="Открыть (O)"><i class="fas fa-folder-open"></i></button>
        <button class="sidebar-btn" onclick="zoomIn()" title="Увеличить (+)"><i class="fas fa-search-plus"></i></button>
        <button class="sidebar-btn" onclick="zoomOut()" title="Уменьшить (-)"><i class="fas fa-search-minus"></i></button>
        <button class="sidebar-btn" onclick="resetZoom()" title="Сбросить масштаб (0)"><i class="fas fa-compress-arrows-alt"></i></button>
        <button class="sidebar-btn" onclick="undoLastAction()" id="undoBtn" title="Отменить (Ctrl+Z)"><i class="fas fa-undo"></i></button>
        <button class="sidebar-btn" onclick="redoLastAction()" id="redoBtn" title="Повторить (Ctrl+Y)"><i class="fas fa-redo"></i></button>
        <button class="sidebar-btn" onclick="toggleFullscreen()" title="Полный экран (F)"><i class="fas fa-expand"></i></button>
        <div class="sidebar-separator"></div>
        <button id="arrowModeBtn" class="sidebar-btn" onclick="setActiveMode('arrow')" title="Стрелка (A)"><i class="fas fa-long-arrow-alt-up"></i></button>
        <button id="lineModeBtn" class="sidebar-btn" onclick="setActiveMode('line')" title="Линия (L)"><i class="fas fa-pencil-alt"></i></button>
        <button id="placemarkModeBtn" class="sidebar-btn" onclick="setActiveMode('placemark')" title="Метка (M)"><i class="fas fa-map-marker-alt"></i></button>
        <button id="textModeBtn" class="sidebar-btn" onclick="setActiveMode('text')" title="Текст (T)"><i class="fas fa-font"></i></button>
        <button id="eraserModeBtn" class="sidebar-btn" onclick="setActiveMode('eraser')" title="Ластик (E)"><i class="fas fa-eraser"></i></button>
        <button id="traceModeBtn" class="sidebar-btn" onclick="setActiveMode('trace')" title="Обвести (V)"><i class="fas fa-signature"></i></button>
        <div class="sidebar-separator"></div>
        <div class="sidebar-control-group">
            <label for="annotationColorPicker">Цвет</label>
            <input type="color" id="annotationColorPicker" value="#FF0000" title="Цвет аннотации">
        </div>
        <div class="sidebar-control-group">
            <label for="fontFamilySelect">Шрифт</label>
            <select id="fontFamilySelect">
                <option value="Inter">Inter</option>
                <option value="Arial">Arial</option>
                <option value="Verdana">Verdana</option>
                <option value="Times New Roman" selected>Times New Roman</option>
            </select>
            <label for="fontSizeInput">Размер</label>
            <input type="number" id="fontSizeInput" value="30" min="8" max="300" title="Размер шрифта">
            <label for="arrowThicknessInput">Толщина</label>
            <input type="number" id="arrowThicknessInput" value="2" min="1" max="50" title="Толщина линии">
            <label for="textRotationInput">Поворот</label>
            <input type="number" id="textRotationInput" value="0" min="0" max="360" title="Поворот текста (°)">
            <label for="eraserSizeInput">Ластик</label>
            <input type="number" id="eraserSizeInput" value="20" min="5" max="100" title="Размер ластика">
        </div>
        <div class="sidebar-separator"></div>
        <button class="sidebar-btn" onclick="flattenAndReloadImage()" title="Объединить слои"><i class="fas fa-layer-group"></i></button>
        <button class="sidebar-btn" onclick="saveAsPNG()" title="Сохранить как PNG"><i class="fas fa-save"></i></button>
        <button class="sidebar-btn" onclick="saveAsJPG()" title="Сохранить как JPG"><i class="fas fa-file-image"></i></button>
        <div class="sidebar-separator"></div>
        <button class="sidebar-btn" onclick="exportAnnotationsAsJSON()" id="exportAnnotationsBtn" title="Экспорт аннотаций"><i class="fas fa-file-export"></i></button>
        <button class="sidebar-btn" onclick="importAnnotationsFromJSON()" id="importAnnotationsBtn" title="Импорт аннотаций"><i class="fas fa-file-import"></i></button>
    </div>

    <div class="main-content">
        <div class="drop-zone" id="dropZone">
            <div class="drop-zone-content">
                <svg class="drop-zone-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                    <rect x="3" y="3" width="18" height="18" rx="2" ry="2"/>
                    <circle cx="8.5" cy="8.5" r="1.5"/>
                    <polyline points="21,15 16,10 5,21"/>
                </svg>
                <div class="drop-zone-text">Перетащите изображение или вставьте (Ctrl+V)</div>
            </div>
        </div>

        <div class="image-container" id="imageContainer">
            <div class="canvas-wrapper" id="canvasWrapper">
                <div id="imageWrapper">
                    <img id="imagePreview" alt="Предпросмотр">
                    <canvas id="annotationCanvas"></canvas>
                    <div class="selection" id="selection"></div>
                </div>
            </div>
        </div>
        
        <div class="selection-info" id="selectionInfo"></div>
        <div class="status-bar" id="statusBar">Готов к работе. Ctrl+V для вставки из буфера.</div>
        <div class="zoom-info" id="zoomInfo">
            <button class="zoom-btn" onclick="zoomOut()" title="Уменьшить">−</button>
            <span id="zoomText">100%</span>
            <button class="zoom-btn" onclick="zoomIn()" title="Увеличить">+</button>
        </div>
        <div class="history-info" id="historyInfo">История: 0/0</div>
    </div>

    <div class="context-menu" id="selectionContextMenu">
        <div class="context-menu-item" onclick="copySelection()"><i class="fas fa-copy"></i>Копировать</div>
        <div class="context-menu-item" onclick="cutSelectionAsObject()"><i class="fas fa-cut"></i>Вырезать</div>
        <div class="context-menu-item" onclick="cropSelection()"><i class="fas fa-crop"></i>Обрезать</div>
        <div class="context-menu-item" onclick="pasteIntoSelection()"><i class="fas fa-paste"></i>Вставить</div>
        <div class="context-menu-separator"></div>
        <div class="context-menu-item" onclick="clearSelection()"><i class="fas fa-eraser"></i>Очистить</div>
        <div class="context-menu-item" onclick="clearAroundSelection()"><i class="fas fa-border-style"></i>Удалить вокруг</div>
        <div class="context-menu-separator"></div>
        <div class="context-menu-item" onclick="blurSelection()"><i class="fas fa-eye-slash"></i>Размыть</div>
        <div class="context-menu-item" onclick="pixelateSelection()"><i class="fas fa-th"></i>Пикселизировать</div>
    </div>
    
    <div class="context-menu" id="textContextMenu">
        <div class="context-menu-item" onclick="editText()"><i class="fas fa-pencil-alt"></i>Редактировать</div>
        <div class="context-menu-item" onclick="duplicateText()"><i class="fas fa-clone"></i>Дублировать</div>
        <div class="context-menu-item" onclick="deleteSelectedText()"><i class="fas fa-trash-alt"></i>Удалить</div>
    </div>
    
 <div class="context-menu" id="imageContextMenu">
        <div class="context-menu-item" onclick="pasteAsObject()"><i class="fas fa-paste"></i>Вставить изображение</div>
        <div class="context-menu-item" onclick="setActiveMode('trace')"><i class="fas fa-signature"></i>Обвести область</div>
        <div class="context-menu-separator"></div>
        <div class="context-menu-item" onclick="flattenAndReloadImage()"><i class="fas fa-layer-group"></i>Объединить слои</div>
    </div>
    
    <div class="context-menu" id="tracedObjectContextMenu">
        <div class="context-menu-item" onclick="copyTracedObject()"><i class="fas fa-copy"></i>Копировать</div>
        <div class="context-menu-item" onclick="cutTracedObject()"><i class="fas fa-cut"></i>Вырезать</div>
        <div class="context-menu-item" onclick="deleteTracedObject()"><i class="fas fa-trash-alt"></i>Удалить</div>
    </div>
    
    <div class="context-menu" id="pastedImageContextMenu">
        <div class="context-menu-item" onclick="duplicatePastedImage()"><i class="fas fa-clone"></i>Дублировать</div>
        <div class="context-menu-item" onclick="deletePastedImage()"><i class="fas fa-trash-alt"></i>Удалить</div>
    </div>

    <input type="file" id="fileInput" accept="image/*,.heic,.heif">
    <input type="file" id="jsonInput" accept=".image,application/json">

    <div class="modal-backdrop" id="textModal">
        <div class="modal-content">
            <h3>Ввод текста</h3>
            <div class="modal-text-input-row">
                <input type="text" id="textInput" placeholder="Введите текст...">
                <input type="color" id="textColorPicker" value="#FF0000" title="Цвет текста">
            </div>
            
            
            <div class="modal-text-input-row" style="align-items: center;">
    <label style="font-weight: 500; white-space: nowrap; font-size: 0.9em;">Размер:</label>
    <input type="number" id="modalFontSizeInput" value="30" min="8" max="300" style="width: 70px; padding: 10px 12px; border-radius: 10px; border: 2px solid var(--border-color); font-size: 1em; text-align: center;">
    <label style="font-weight: 500; white-space: nowrap; font-size: 0.9em; margin-left: 10px;">Шрифт:</label>
    <select id="modalFontFamilySelect" style="flex: 1; padding: 10px 12px; border-radius: 10px; border: 2px solid var(--border-color); font-size: 0.95em; background: #fff;">
        <option value="Inter">Inter</option>
        <option value="Arial">Arial</option>
        <option value="Verdana">Verdana</option>
        <option value="Times New Roman" selected>Times New Roman</option>
    </select>
</div>

<div class="modal-template-row">
    <select id="templateSelect">
        <option value="">— Шаблон —</option>
    </select>
    <button class="modal-template-btn save" id="saveTemplateBtn" title="Сохранить шаблон"><i class="fas fa-plus"></i></button>
    <button class="modal-template-btn delete" id="deleteTemplateBtn" title="Удалить шаблон"><i class="fas fa-trash-alt"></i></button>
</div>
            
            <div class="modal-style-buttons">
                <button id="textBoldBtn" class="modal-style-btn" title="Жирный"><i class="fas fa-bold"></i></button>
                <button id="textItalicBtn" class="modal-style-btn" title="Курсив"><i class="fas fa-italic"></i></button>
                <button id="textUnderlineBtn" class="modal-style-btn" title="Подчеркнутый"><i class="fas fa-underline"></i></button>
                <button id="textStrikethroughBtn" class="modal-style-btn" title="Зачеркнутый"><i class="fas fa-strikethrough"></i></button>
            </div>
            <div class="modal-options-grid">
                <div class="modal-option-group">
                    <label class="modal-checkbox-label">
                        <input type="checkbox" id="textStrokeCheckbox">
                        <span>Обводка</span>
                    </label>
                    <div id="strokeOptionsContainer" class="modal-radio-group" style="display: none;">
                        <label><input type="radio" name="strokeColor" value="#000000" checked> Черная</label>
                        <label><input type="radio" name="strokeColor" value="#FFFFFF"> Белая</label>
                    </div>
                </div>
                <div class="modal-option-group">
                    <label class="modal-checkbox-label">
                        <input type="checkbox" id="textShadowCheckbox">
                        <span>Тень</span>
                    </label>
                    <div id="shadowOptionsContainer" class="modal-radio-group" style="display: none;">
                        <label><input type="radio" name="shadowColor" value="rgba(0,0,0,0.5)" checked> Черная</label>
                        <label><input type="radio" name="shadowColor" value="rgba(255,255,255,0.7)"> Белая</label>
                    </div>
                </div>
                <div class="modal-option-group" style="grid-column: 1 / -1;">
                    <label class="modal-checkbox-label">
                        <input type="checkbox" id="textBackgroundCheckbox">
                        <span>Фон</span>
                    </label>
                    <div id="backgroundOptionsContainer" class="modal-radio-group" style="display: none;">
                        <label style="display: flex; align-items: center; gap: 8px;">
                            <input type="radio" name="backgroundType" value="color" checked> 
                            <span>Сплошной</span>
                            <input type="color" id="textBackgroundColorPicker" value="#FFFFFF" style="margin-left: auto; width: 40px; height: 28px; border-radius: 6px;">
                        </label>
                        <label class="modal-checkbox-label">
                            <input type="radio" name="backgroundType" value="blur">
                            <span>Размытие</span>
                        </label>
                        <div class="blur-control-group" style="padding-left: 25px;">
                            <input type="range" id="textBlurAmountSlider" min="0" max="100" value="25">
                            <input type="number" id="textBlurAmountInput" min="0" max="100" value="25">
                            <span>%</span>
                        </div>
                    </div>
                </div>
            </div>
            <div class="modal-buttons">
                <button class="modal-btn" id="modalCancelBtn">Отмена</button>
                <button class="modal-btn" id="modalOkBtn">OK</button>
            </div>
        </div>
    </div>
    
<script>
    // DOM Elements
    const dropZone = document.getElementById('dropZone');
    const fileInput = document.getElementById('fileInput');
    const jsonInput = document.getElementById('jsonInput');
    const imagePreview = document.getElementById('imagePreview');
    const imageContainer = document.getElementById('imageContainer');
    const canvasWrapper = document.getElementById('canvasWrapper');
    const imageWrapper = document.getElementById('imageWrapper');
    const selection = document.getElementById('selection');
    const statusBar = document.getElementById('statusBar');
    const zoomText = document.getElementById('zoomText');
    const historyInfo = document.getElementById('historyInfo');
    const annotationCanvas = document.getElementById('annotationCanvas');
    const annotationCtx = annotationCanvas.getContext('2d');
    const selectionInfo = document.getElementById('selectionInfo');
    const selectionContextMenu = document.getElementById('selectionContextMenu');
    const textContextMenu = document.getElementById('textContextMenu');
    const imageContextMenu = document.getElementById('imageContextMenu');
    const tracedObjectContextMenu = document.getElementById('tracedObjectContextMenu');
    const pastedImageContextMenu = document.getElementById('pastedImageContextMenu');
    const textModal = document.getElementById('textModal');
    const textInput = document.getElementById('textInput');
    const textColorPicker = document.getElementById('textColorPicker');
    const textShadowCheckbox = document.getElementById('textShadowCheckbox');
    const shadowOptionsContainer = document.getElementById('shadowOptionsContainer');
    const textStrokeCheckbox = document.getElementById('textStrokeCheckbox');
    const strokeOptionsContainer = document.getElementById('strokeOptionsContainer');
    const textBackgroundCheckbox = document.getElementById('textBackgroundCheckbox');
    const backgroundOptionsContainer = document.getElementById('backgroundOptionsContainer');
    const textBackgroundColorPicker = document.getElementById('textBackgroundColorPicker');
    const textBlurAmountSlider = document.getElementById('textBlurAmountSlider');
    const textBlurAmountInput = document.getElementById('textBlurAmountInput');
    const textBoldBtn = document.getElementById('textBoldBtn');
    const textItalicBtn = document.getElementById('textItalicBtn');
    const textUnderlineBtn = document.getElementById('textUnderlineBtn');
    const textStrikethroughBtn = document.getElementById('textStrikethroughBtn');
    const modalFontSizeInput = document.getElementById('modalFontSizeInput');
const modalFontFamilySelect = document.getElementById('modalFontFamilySelect');
const templateSelect = document.getElementById('templateSelect');
const saveTemplateBtn = document.getElementById('saveTemplateBtn');
const deleteTemplateBtn = document.getElementById('deleteTemplateBtn');

    const buttons = {
        arrow: document.getElementById('arrowModeBtn'),
        line: document.getElementById('lineModeBtn'),
        placemark: document.getElementById('placemarkModeBtn'),
        text: document.getElementById('textModeBtn'),
        eraser: document.getElementById('eraserModeBtn'),
        trace: document.getElementById('traceModeBtn'),
        undo: document.getElementById('undoBtn'),
        redo: document.getElementById('redoBtn'),
        exportAnnotations: document.getElementById('exportAnnotationsBtn'),
        importAnnotations: document.getElementById('importAnnotationsBtn'),
    };

    const controls = {
        color: document.getElementById('annotationColorPicker'),
        thickness: document.getElementById('arrowThicknessInput'),
        fontSize: document.getElementById('fontSizeInput'),
        fontFamily: document.getElementById('fontFamilySelect'),
        rotation: document.getElementById('textRotationInput'),
        eraserSize: document.getElementById('eraserSizeInput')
    };

    // State variables
    let currentZoom = 1;
    let originalFile = null;
    let isSelecting = false, selectionStartX, selectionStartY, selectedArea = null;
    let activeMode = null;
    let blurCache = {}; 
    let contextMenuPos = {};
    
    // Annotation data
    let baseImageDataUrl = null; // Хранит текущее базовое изображение для истории
    let arrows = [], lines = [], placemarks = [], texts = [], eraserStrokes = [];
    let pastedImages = [];
    let tracedObjects = [];
    let cutObjects = [];
    let loadedPastedImages = {};

    // Drawing states
    let isDrawingArrow = false, currentArrowStart = {};
    let isDrawingLine = false, currentLineStart = {};
    let isErasing = false, currentEraserPath = [];
    let isTracing = false, currentTracePath = [];

    // Pan states
    let isPanning = false;
    let isDraggingPan = false;
    let panStartX, panStartY, panStartScrollX, panStartScrollY;

    // History
    let historyStack = [];
    let redoStack = [];
    const MAX_HISTORY = 50;
    
    // Selection states
    let selectedTextId = null;
    let isDraggingText = false;
    let isRotatingText = false;
    let textDragOffset = {};
    let textModalCallback = null;
    
    let selectedPastedImageId = null;
    let isDraggingPastedImage = false;
    let isResizingPastedImage = false;
    let pastedImageDragOffset = {};
    let resizeStartPos = {};
    let resizeStartDimensions = {};
    let resizeHandle = null;

    let selectedTracedObjectId = null;
    let isDraggingTracedObject = false;
    let isRotatingTracedObject = false;
    let tracedObjectDragOffset = {};
    
    let selectedCutObjectId = null;
    let isDraggingCutObject = false;
    let cutObjectDragOffset = {};

    // Placemark image
    const placemarkImage = new Image();
    placemarkImage.crossOrigin = "Anonymous";
    placemarkImage.onload = () => { if (imagePreview.src) redrawAnnotations(); };
    placemarkImage.src = "data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='%23F44336'%3E%3Cpath d='M12 2C8.13 2 5 5.13 5 9c0 5.25 7 13 7 13s7-7.75 7-13c0-3.87-3.13-7-7-7zm0 9.5c-1.38 0-2.5-1.12-2.5-2.5s1.12-2.5 2.5-2.5 2.5 1.12 2.5 2.5-1.12 2.5-2.5 2.5z'/%3E%3C/svg%3E";

    // ==================== SETTINGS ====================
    function saveSettings() {
        const settings = {
            color: controls.color.value,
            fontFamily: controls.fontFamily.value,
            fontSize: controls.fontSize.value,
            thickness: controls.thickness.value,
            rotation: controls.rotation.value,
            eraserSize: controls.eraserSize.value,
            textColor: textColorPicker.value,
            shadowEnabled: textShadowCheckbox.checked,
            shadowColor: document.querySelector('input[name="shadowColor"]:checked')?.value,
            strokeEnabled: textStrokeCheckbox.checked,
            strokeColor: document.querySelector('input[name="strokeColor"]:checked')?.value,
            backgroundEnabled: textBackgroundCheckbox.checked,
            backgroundType: document.querySelector('input[name="backgroundType"]:checked')?.value,
            backgroundColor: textBackgroundColorPicker.value,
            blurAmount: textBlurAmountSlider.value,
            isBold: textBoldBtn.classList.contains('active'),
            isItalic: textItalicBtn.classList.contains('active'),
            isUnderline: textUnderlineBtn.classList.contains('active'),
            isStrikethrough: textStrikethroughBtn.classList.contains('active')
        };
        localStorage.setItem('imageEditorSettings', JSON.stringify(settings));
    }

    function loadSettings() {
        const savedSettings = localStorage.getItem('imageEditorSettings');
        if (savedSettings) {
            try {
                const settings = JSON.parse(savedSettings);
                controls.color.value = settings.color || '#FF0000';
                controls.fontFamily.value = settings.fontFamily || 'Times New Roman';
                controls.fontSize.value = settings.fontSize || 30;
                if (modalFontSizeInput) modalFontSizeInput.value = settings.fontSize || 30;
if (modalFontFamilySelect) modalFontFamilySelect.value = settings.fontFamily || 'Times New Roman';
                controls.thickness.value = settings.thickness || 2;
                controls.rotation.value = settings.rotation || 0;
                controls.eraserSize.value = settings.eraserSize || 20;
                textColorPicker.value = settings.textColor || '#FF0000';
                textShadowCheckbox.checked = settings.shadowEnabled || false;
                const shadowRadio = document.querySelector(`input[name="shadowColor"][value="${settings.shadowColor}"]`);
                if (shadowRadio) shadowRadio.checked = true;
                shadowOptionsContainer.style.display = textShadowCheckbox.checked ? 'flex' : 'none';
                textStrokeCheckbox.checked = settings.strokeEnabled || false;
                const strokeRadio = document.querySelector(`input[name="strokeColor"][value="${settings.strokeColor}"]`);
                if (strokeRadio) strokeRadio.checked = true;
                strokeOptionsContainer.style.display = textStrokeCheckbox.checked ? 'flex' : 'none';
                textBackgroundCheckbox.checked = settings.backgroundEnabled || false;
                const bgTypeRadio = document.querySelector(`input[name="backgroundType"][value="${settings.backgroundType}"]`);
                if (bgTypeRadio) bgTypeRadio.checked = true;
                textBackgroundColorPicker.value = settings.backgroundColor || '#FFFFFF';
                textBlurAmountSlider.value = settings.blurAmount || 25;
                textBlurAmountInput.value = settings.blurAmount || 25;
                backgroundOptionsContainer.style.display = textBackgroundCheckbox.checked ? 'flex' : 'none';
                textBoldBtn.classList.toggle('active', !!settings.isBold);
                textItalicBtn.classList.toggle('active', !!settings.isItalic);
                textUnderlineBtn.classList.toggle('active', !!settings.isUnderline);
                textStrikethroughBtn.classList.toggle('active', !!settings.isStrikethrough);
            } catch (e) {
                console.error("Error loading settings", e);
                localStorage.removeItem('imageEditorSettings');
            }
        }
    }
    
    
    // ==================== TEMPLATES ====================
function getModalState() {
    return {
        text: textInput.value,
        color: textColorPicker.value,
        fontSize: parseInt(modalFontSizeInput.value),
        fontFamily: modalFontFamilySelect.value,
        isBold: textBoldBtn.classList.contains('active'),
        isItalic: textItalicBtn.classList.contains('active'),
        isUnderline: textUnderlineBtn.classList.contains('active'),
        isStrikethrough: textStrikethroughBtn.classList.contains('active'),
        strokeEnabled: textStrokeCheckbox.checked,
        strokeColor: document.querySelector('input[name="strokeColor"]:checked')?.value,
        shadowEnabled: textShadowCheckbox.checked,
        shadowColor: document.querySelector('input[name="shadowColor"]:checked')?.value,
        backgroundEnabled: textBackgroundCheckbox.checked,
        backgroundType: document.querySelector('input[name="backgroundType"]:checked')?.value,
        backgroundColor: textBackgroundColorPicker.value,
        blurAmount: parseInt(textBlurAmountSlider.value)
    };
}

function applyModalState(state) {
    textInput.value = state.text || '';
    textColorPicker.value = state.color || '#FF0000';
    modalFontSizeInput.value = state.fontSize || 30;
    modalFontFamilySelect.value = state.fontFamily || 'Times New Roman';
    textBoldBtn.classList.toggle('active', !!state.isBold);
    textItalicBtn.classList.toggle('active', !!state.isItalic);
    textUnderlineBtn.classList.toggle('active', !!state.isUnderline);
    textStrikethroughBtn.classList.toggle('active', !!state.isStrikethrough);
    textStrokeCheckbox.checked = !!state.strokeEnabled;
    strokeOptionsContainer.style.display = state.strokeEnabled ? 'flex' : 'none';
    if (state.strokeColor) {
        const radio = document.querySelector(`input[name="strokeColor"][value="${state.strokeColor}"]`);
        if (radio) radio.checked = true;
    }
    textShadowCheckbox.checked = !!state.shadowEnabled;
    shadowOptionsContainer.style.display = state.shadowEnabled ? 'flex' : 'none';
    if (state.shadowColor) {
        const radio = document.querySelector(`input[name="shadowColor"][value="${state.shadowColor}"]`);
        if (radio) radio.checked = true;
    }
    textBackgroundCheckbox.checked = !!state.backgroundEnabled;
    backgroundOptionsContainer.style.display = state.backgroundEnabled ? 'flex' : 'none';
    if (state.backgroundType) {
        const radio = document.querySelector(`input[name="backgroundType"][value="${state.backgroundType}"]`);
        if (radio) radio.checked = true;
    }
    textBackgroundColorPicker.value = state.backgroundColor || '#FFFFFF';
    textBlurAmountSlider.value = state.blurAmount || 25;
    textBlurAmountInput.value = state.blurAmount || 25;
}

function loadTemplates() {
    const templates = JSON.parse(localStorage.getItem('imageEditorTemplates') || '[]');
    templateSelect.innerHTML = '<option value="">— Шаблон —</option>';
    templates.forEach((tmpl, index) => {
        const option = document.createElement('option');
        option.value = index;
        const preview = tmpl.text ? `"${tmpl.text.substring(0, 20)}${tmpl.text.length > 20 ? '...' : ''}"` : 'Без текста';
        option.textContent = `${tmpl.name || preview} (${tmpl.fontSize}px, ${tmpl.fontFamily})`;
        templateSelect.appendChild(option);
    });
}

function saveTemplate() {
    const state = getModalState();
    const name = prompt('Название шаблона:', state.text ? state.text.substring(0, 30) : 'Мой шаблон');
    if (name === null) return;
    
    const templates = JSON.parse(localStorage.getItem('imageEditorTemplates') || '[]');
    templates.push({ ...state, name: name || 'Без названия' });
    localStorage.setItem('imageEditorTemplates', JSON.stringify(templates));
    loadTemplates();
    templateSelect.value = templates.length - 1;
    showNotification('✓ Шаблон сохранён');
}

function deleteTemplate() {
    const index = templateSelect.value;
    if (index === '') {
        showNotification('Выберите шаблон для удаления');
        return;
    }
    const templates = JSON.parse(localStorage.getItem('imageEditorTemplates') || '[]');
    const tmpl = templates[index];
    if (!confirm(`Удалить шаблон "${tmpl.name}"?`)) return;
    templates.splice(index, 1);
    localStorage.setItem('imageEditorTemplates', JSON.stringify(templates));
    loadTemplates();
    showNotification('✓ Шаблон удалён');
}

function applyTemplate() {
    const index = templateSelect.value;
    if (index === '') return;
    const templates = JSON.parse(localStorage.getItem('imageEditorTemplates') || '[]');
    if (templates[index]) {
        applyModalState(templates[index]);
    }
}

// Event listeners для шаблонов
saveTemplateBtn.addEventListener('click', saveTemplate);
deleteTemplateBtn.addEventListener('click', deleteTemplate);
templateSelect.addEventListener('change', applyTemplate);


    // ==================== HISTORY (UNDO/REDO) ====================
    function createHistoryState() {
        return {
            // Сохраняем базовое изображение
            baseImageDataUrl: baseImageDataUrl,
            // Сохраняем все аннотации
            arrows: JSON.parse(JSON.stringify(arrows)),
            lines: JSON.parse(JSON.stringify(lines)),
            placemarks: JSON.parse(JSON.stringify(placemarks)),
            texts: JSON.parse(JSON.stringify(texts)),
            eraserStrokes: JSON.parse(JSON.stringify(eraserStrokes)),
            pastedImages: JSON.parse(JSON.stringify(pastedImages)),
            tracedObjects: tracedObjects.map(o => ({ ...o, image: null })),
            cutObjects: cutObjects.map(o => ({ ...o, image: null }))
        };
    }

    function saveStateToHistory() {
        const state = createHistoryState();
        historyStack.push(state);
        
        // Ограничиваем размер истории
        if (historyStack.length > MAX_HISTORY) {
            historyStack.shift();
        }
        
        // Очищаем redo при новом действии
        redoStack = [];
        updateUndoRedoButtons();
        updateHistoryInfo();
    }

    function applyState(state) {
        // Восстанавливаем базовое изображение если изменилось
        if (state.baseImageDataUrl !== baseImageDataUrl) {
            baseImageDataUrl = state.baseImageDataUrl;
            if (baseImageDataUrl) {
                imagePreview.src = baseImageDataUrl;
            }
        }
        
        // Восстанавливаем аннотации
        arrows = state.arrows || [];
        lines = state.lines || [];
        placemarks = state.placemarks || [];
        texts = state.texts || [];
        eraserStrokes = state.eraserStrokes || [];
        pastedImages = state.pastedImages || [];
        tracedObjects = state.tracedObjects || [];
        cutObjects = state.cutObjects || [];
        
        // Перезагружаем изображения объектов
        loadPastedImagesFromState();
        loadTracedObjectsFromState();
        loadCutObjectsFromState();
        
        // Сбрасываем выделение
        selectedTextId = null;
        selectedPastedImageId = null;
        selectedTracedObjectId = null;
        selectedCutObjectId = null;
        
        redrawAnnotations();
    }

    function undoLastAction() {
        if (historyStack.length <= 1) {
            statusBar.textContent = 'Нечего отменять';
            return;
        }
        
        const currentState = historyStack.pop();
        redoStack.push(currentState);
        
        const prevState = historyStack[historyStack.length - 1];
        applyState(prevState);
        
        updateUndoRedoButtons();
        updateHistoryInfo();
        statusBar.textContent = 'Действие отменено';
    }

    function redoLastAction() {
        if (redoStack.length === 0) {
            statusBar.textContent = 'Нечего повторять';
            return;
        }
        
        const nextState = redoStack.pop();
        historyStack.push(nextState);
        applyState(nextState);
        
        updateUndoRedoButtons();
        updateHistoryInfo();
        statusBar.textContent = 'Действие восстановлено';
    }

    function updateUndoRedoButtons() {
        buttons.undo.disabled = historyStack.length <= 1;
        buttons.redo.disabled = redoStack.length === 0;
    }

    function updateHistoryInfo() {
        const current = historyStack.length;
        const total = historyStack.length + redoStack.length;
        historyInfo.textContent = `История: ${current}/${total}`;
    }

    // ==================== MOUSE POSITION ====================
    function getMousePos(e) {
        const wrapperRect = imageWrapper.getBoundingClientRect();
        const scaleX = annotationCanvas.width / wrapperRect.width;
        const scaleY = annotationCanvas.height / wrapperRect.height;
        const x = (e.clientX - wrapperRect.left) * scaleX;
        const y = (e.clientY - wrapperRect.top) * scaleY;
        if (x >= 0 && x <= annotationCanvas.width && y >= 0 && y <= annotationCanvas.height) {
            return { x, y };
        }
        return null;
    }

    // ==================== MOUSE EVENTS ====================
    imageContainer.addEventListener('mousedown', e => {
        if (e.button !== 0 || !imagePreview.src) return;
        
        if (isPanning) {
            e.preventDefault();
            isDraggingPan = true;
            panStartX = e.clientX;
            panStartY = e.clientY;
            panStartScrollX = imageContainer.scrollLeft;
            panStartScrollY = imageContainer.scrollTop;
            imageContainer.style.cursor = 'grabbing';
            return;
        }
        
        const pos = getMousePos(e);
        if (!pos) return;

        // Check cut objects
        const cutObjectInteraction = checkCutObjectInteraction(pos);
        if (cutObjectInteraction.isOver) {
            e.preventDefault();
            setActiveMode(null);
            selectedTextId = null;
            selectedPastedImageId = null;
            selectedTracedObjectId = null;
            selectedCutObjectId = cutObjectInteraction.id;
            isDraggingCutObject = true;
            cutObjectDragOffset = {
                x: pos.x - cutObjectInteraction.obj.x,
                y: pos.y - cutObjectInteraction.obj.y
            };
            redrawAnnotations();
            return;
        }
        selectedCutObjectId = null;

        // Check traced objects
        const tracedObjectInteraction = checkTracedObjectInteraction(pos);
        if (tracedObjectInteraction.isOver) {
            e.preventDefault();
            setActiveMode(null);
            selectedTextId = null;
            selectedPastedImageId = null;
            if (selectedTracedObjectId !== tracedObjectInteraction.id) {
                selectedTracedObjectId = tracedObjectInteraction.id;
            }
            isRotatingTracedObject = tracedObjectInteraction.onRotateHandle;
            isDraggingTracedObject = !isRotatingTracedObject;
            tracedObjectDragOffset = {
                x: pos.x - (tracedObjectInteraction.obj.x + tracedObjectInteraction.obj.width / 2),
                y: pos.y - (tracedObjectInteraction.obj.y + tracedObjectInteraction.obj.height / 2)
            };
            redrawAnnotations();
            return;
        }
        selectedTracedObjectId = null;

        // Check pasted images
        const pastedImageInteraction = checkPastedImageInteraction(pos);
        if (pastedImageInteraction.isOver) {
            e.preventDefault();
            setActiveMode(null);
            selectedTextId = null;
            if (selectedPastedImageId !== pastedImageInteraction.id) {
                selectedPastedImageId = pastedImageInteraction.id;
            }
            if (pastedImageInteraction.onHandle) {
                isResizingPastedImage = true;
                resizeHandle = pastedImageInteraction.onHandle;
                resizeStartPos = pos;
                const img = pastedImageInteraction.obj;
                resizeStartDimensions = {
                    width: img.width,
                    height: img.height,
                    x: img.x,
                    y: img.y,
                    aspectRatio: img.width / img.height
                };
            } else {
                isDraggingPastedImage = true;
                pastedImageDragOffset = { x: pos.x - pastedImageInteraction.obj.x, y: pos.y - pastedImageInteraction.obj.y };
            }
            redrawAnnotations();
            return;
        }
        selectedPastedImageId = null;

        // Check texts
        const textInteraction = checkTextInteraction(pos);
        if (textInteraction.isOver) {
            e.preventDefault();
            setActiveMode(null);
            if (selectedTextId !== textInteraction.id) {
                selectedTextId = textInteraction.id;
                updateControlsForSelectedText();
            }
            isRotatingText = textInteraction.onRotateHandle;
            isDraggingText = !isRotatingText;
            textDragOffset = { x: pos.x - textInteraction.obj.x, y: pos.y - textInteraction.obj.y };
            redrawAnnotations();
            return;
        }
        if (selectedTextId) {
            selectedTextId = null;
            redrawAnnotations();
        }
        
        if (activeMode) {
            e.preventDefault();
            switch (activeMode) {
                case 'arrow': isDrawingArrow = true; currentArrowStart = pos; break;
                case 'line': isDrawingLine = true; currentLineStart = pos; break;
                case 'eraser': isErasing = true; currentEraserPath = [pos]; break;
                case 'trace': isTracing = true; currentTracePath = [pos]; break;
                case 'placemark':
                    placemarks.push({ x: pos.x, y: pos.y, size: 35 });
                    saveStateToHistory();
                    redrawAnnotations();
                    break;
                case 'text':
                    showTextModal(null, newStyles => {
                        if (newStyles.text) {
                            texts.push({
                                id: Date.now(),
                                x: pos.x,
                                y: pos.y,
                                ...getCurrentTextStyles(),
                                ...newStyles
                            });
                            saveStateToHistory();
                            redrawAnnotations();
                        }
                    });
                    break;
            }
        } else {
            e.preventDefault();
            isSelecting = true;
            selectionStartX = pos.x;
            selectionStartY = pos.y;
            Object.assign(selection.style, {
                display: 'block',
                left: `${(pos.x / annotationCanvas.width) * 100}%`,
                top: `${(pos.y / annotationCanvas.height) * 100}%`,
                width: '0%',
                height: '0%'
            });
        }
    });

    window.addEventListener('mousemove', e => {
        if (!imagePreview.src) return;
        
        if (isDraggingPan) {
            e.preventDefault();
            const dx = e.clientX - panStartX;
            const dy = e.clientY - panStartY;
            imageContainer.scrollLeft = panStartScrollX - dx;
            imageContainer.scrollTop = panStartScrollY - dy;
            return;
        }
        
        const pos = getMousePos(e);
        
        if (isDraggingCutObject) {
            e.preventDefault();
            const obj = cutObjects.find(c => c.id === selectedCutObjectId);
            if (obj && pos) {
                obj.x = pos.x - cutObjectDragOffset.x;
                obj.y = pos.y - cutObjectDragOffset.y;
                redrawAnnotations();
            }
            return;
        }
        
        if (isDraggingTracedObject || isRotatingTracedObject) {
            e.preventDefault();
            const obj = tracedObjects.find(t => t.id === selectedTracedObjectId);
            if (!obj) return;
            const effectivePos = pos || { x: obj.x + obj.width / 2 + tracedObjectDragOffset.x, y: obj.y + obj.height / 2 + tracedObjectDragOffset.y };
            if (isDraggingTracedObject) {
                obj.x = effectivePos.x - tracedObjectDragOffset.x - obj.width / 2;
                obj.y = effectivePos.y - tracedObjectDragOffset.y - obj.height / 2;
            } else {
                const centerX = obj.x + obj.width / 2;
                const centerY = obj.y + obj.height / 2;
                const angleRad = Math.atan2(effectivePos.y - centerY, effectivePos.x - centerX);
                let angleDeg = (angleRad * 180 / Math.PI) + 90;
                if (angleDeg < 0) angleDeg += 360;
                obj.rotation = Math.round(angleDeg);
            }
            redrawAnnotations();
            return;
        }

        if (isDraggingPastedImage) {
            e.preventDefault();
            const img = pastedImages.find(p => p.id === selectedPastedImageId);
            if (img && pos) {
                img.x = pos.x - pastedImageDragOffset.x;
                img.y = pos.y - pastedImageDragOffset.y;
                redrawAnnotations();
            }
            return;
        }
        
        if (isResizingPastedImage) {
            e.preventDefault();
            const img = pastedImages.find(p => p.id === selectedPastedImageId);
            if (img && pos) {
                const dx = pos.x - resizeStartPos.x;
                const dy = pos.y - resizeStartPos.y;
                const isCorner = ['topLeft', 'topRight', 'bottomLeft', 'bottomRight'].includes(resizeHandle);
                
                if (isCorner) {
                    // Пропорциональное изменение для углов
                    let newWidth, newHeight;
                    if (resizeHandle === 'bottomRight') {
                        newWidth = Math.max(20, resizeStartDimensions.width + dx);
                        newHeight = newWidth / resizeStartDimensions.aspectRatio;
                    } else if (resizeHandle === 'bottomLeft') {
                        newWidth = Math.max(20, resizeStartDimensions.width - dx);
                        newHeight = newWidth / resizeStartDimensions.aspectRatio;
                        img.x = resizeStartDimensions.x + resizeStartDimensions.width - newWidth;
                    } else if (resizeHandle === 'topRight') {
                        newWidth = Math.max(20, resizeStartDimensions.width + dx);
                        newHeight = newWidth / resizeStartDimensions.aspectRatio;
                        img.y = resizeStartDimensions.y + resizeStartDimensions.height - newHeight;
                    } else if (resizeHandle === 'topLeft') {
                        newWidth = Math.max(20, resizeStartDimensions.width - dx);
                        newHeight = newWidth / resizeStartDimensions.aspectRatio;
                        img.x = resizeStartDimensions.x + resizeStartDimensions.width - newWidth;
                        img.y = resizeStartDimensions.y + resizeStartDimensions.height - newHeight;
                    }
                    img.width = newWidth;
                    img.height = newHeight;
                } else {
                    // Свободное изменение для сторон
                    if (resizeHandle === 'right') img.width = Math.max(20, resizeStartDimensions.width + dx);
                    if (resizeHandle === 'left') {
                        img.width = Math.max(20, resizeStartDimensions.width - dx);
                        img.x = resizeStartDimensions.x + dx;
                    }
                    if (resizeHandle === 'bottom') img.height = Math.max(20, resizeStartDimensions.height + dy);
                    if (resizeHandle === 'top') {
                        img.height = Math.max(20, resizeStartDimensions.height - dy);
                        img.y = resizeStartDimensions.y + dy;
                    }
                }
                redrawAnnotations();
            }
            return;
        }

        if (isDraggingText || isRotatingText) {
            e.preventDefault();
            const text = texts.find(t => t.id === selectedTextId);
            if (!text) return;
            const effectivePos = pos || { x: text.x + textDragOffset.x, y: text.y + textDragOffset.y };
            if (isDraggingText) {
                text.x = effectivePos.x - textDragOffset.x;
                text.y = effectivePos.y - textDragOffset.y;
            } else {
                const angleRad = Math.atan2(effectivePos.y - text.y, effectivePos.x - text.x);
                let angleDeg = (angleRad * 180 / Math.PI) + 90;
                if (angleDeg < 0) angleDeg += 360;
                text.rotation = Math.round(angleDeg);
                controls.rotation.value = text.rotation;
            }
            redrawAnnotations();
            return;
        }
        
        // Update cursor
        let cursor = 'default';
        if (pos) {
            const cutObjInt = checkCutObjectInteraction(pos);
            const tracedObjInt = checkTracedObjectInteraction(pos);
            const pastedImgInt = checkPastedImageInteraction(pos);
            const textInt = checkTextInteraction(pos);
            
            if (cutObjInt.isOver) cursor = 'move';
            else if (tracedObjInt.isOver) cursor = tracedObjInt.onRotateHandle ? 'alias' : 'move';
            else if (pastedImgInt.isOver) cursor = pastedImgInt.cursor;
            else if (textInt.isOver) cursor = textInt.onRotateHandle ? 'alias' : 'move';
            else if (activeMode) cursor = activeMode === 'text' ? 'text' : 'crosshair';
        }
        imageWrapper.style.cursor = isPanning ? 'grab' : cursor;

        if (!pos) return;
        
        if (isErasing) {
            e.preventDefault();
            currentEraserPath.push(pos);
            redrawAnnotations();
            return;
        }
        if (isTracing) {
            e.preventDefault();
            currentTracePath.push(pos);
            redrawAnnotations();
            return;
        }
        if (isDrawingArrow) drawAllAnnotations({ type: 'arrow', start: currentArrowStart, end: pos });
        else if (isDrawingLine) drawAllAnnotations({ type: 'line', start: currentLineStart, end: pos });
        else if (isSelecting) {
            const currentXPercent = (pos.x / annotationCanvas.width) * 100;
            const startXPercent = (selectionStartX / annotationCanvas.width) * 100;
            const currentYPercent = (pos.y / annotationCanvas.height) * 100;
            const startYPercent = (selectionStartY / annotationCanvas.height) * 100;
            Object.assign(selection.style, {
                left: `${Math.min(currentXPercent, startXPercent)}%`,
                top: `${Math.min(currentYPercent, startYPercent)}%`,
                width: `${Math.abs(currentXPercent - startXPercent)}%`,
                height: `${Math.abs(currentYPercent - startYPercent)}%`
            });
            selectionInfo.style.display = 'block';
            selectionInfo.textContent = `Выделение: ${Math.round(Math.abs(pos.x - selectionStartX))}×${Math.round(Math.abs(pos.y - selectionStartY))} px`;
        }
    });

    window.addEventListener('mouseup', async e => {
        if (!imagePreview.src) return;
        
        if (isDraggingPan) {
            isDraggingPan = false;
            imageContainer.style.cursor = 'grab';
            return;
        }
        
        if (isDraggingCutObject) {
            isDraggingCutObject = false;
            saveStateToHistory();
            return;
        }
        
        if (isDraggingText || isRotatingText) {
            isDraggingText = isRotatingText = false;
            saveStateToHistory();
            return;
        }
        if (isDraggingPastedImage || isResizingPastedImage) {
            isDraggingPastedImage = isResizingPastedImage = false;
            saveStateToHistory();
            return;
        }
        if (isDraggingTracedObject || isRotatingTracedObject) {
            isDraggingTracedObject = isRotatingTracedObject = false;
            saveStateToHistory();
            return;
        }

        let actionTaken = false;
        const pos = getMousePos(e);
        
        if (isTracing) {
            isTracing = false;
            if (currentTracePath.length > 10 && Math.hypot(currentTracePath[currentTracePath.length - 1].x - currentTracePath[0].x, currentTracePath[currentTracePath.length - 1].y - currentTracePath[0].y) < 30) {
                await createTracedObject(currentTracePath);
                actionTaken = true;
            }
            currentTracePath = [];
            setActiveMode(null);
        } else if (isDrawingArrow) {
            isDrawingArrow = false;
            if (pos && Math.hypot(pos.x - currentArrowStart.x, pos.y - currentArrowStart.y) > 10) {
                arrows.push({
                    start: currentArrowStart,
                    end: pos,
                    color: controls.color.value,
                    thickness: parseInt(controls.thickness.value)
                });
                actionTaken = true;
            }
        } else if (isDrawingLine) {
            isDrawingLine = false;
            if (pos && Math.hypot(pos.x - currentLineStart.x, pos.y - currentLineStart.y) > 5) {
                lines.push({
                    start: currentLineStart,
                    end: pos,
                    color: controls.color.value,
                    thickness: parseInt(controls.thickness.value)
                });
                actionTaken = true;
            }
        } else if (isErasing) {
            isErasing = false;
            if (currentEraserPath.length > 1) {
                eraserStrokes.push({ path: [...currentEraserPath], size: parseInt(controls.eraserSize.value) });
                actionTaken = true;
            }
            currentEraserPath = [];
        } else if (isSelecting) {
            isSelecting = false;
            const endPos = pos || { x: parseFloat(selection.style.left) * annotationCanvas.width / 100, y: parseFloat(selection.style.top) * annotationCanvas.height / 100 };
            const w = Math.abs(endPos.x - selectionStartX);
            const h = Math.abs(endPos.y - selectionStartY);
            selectedArea = (w < 5 || h < 5) ? null : {
                x: Math.min(endPos.x, selectionStartX),
                y: Math.min(endPos.y, selectionStartY),
                width: w,
                height: h
            };
            if (!selectedArea) {
                selection.style.display = 'none';
                selectionInfo.style.display = 'none';
            }
        }
        
        if (actionTaken) saveStateToHistory();
        redrawAnnotations();
    });

    // ==================== IMAGE LOADING ====================
function flattenAndReloadImage() {
        hideAllContextMenus();

        if (!imagePreview.src) return;
        selectedTextId = null;
        selectedPastedImageId = null;
        selectedTracedObjectId = null;
        selectedCutObjectId = null;
        redrawAnnotations();

        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        canvas.width = annotationCanvas.width;
        canvas.height = annotationCanvas.height;
        ctx.drawImage(annotationCanvas, 0, 0);

        const newDataUrl = canvas.toDataURL('image/png');
        baseImageDataUrl = newDataUrl;
        
        // Ждем загрузки перед перерисовкой
        imagePreview.onload = () => {
            saveStateToHistory();
            redrawAnnotations();
            statusBar.textContent = 'Слои объединены';
            showNotification('✓ Слои объединены');
            imagePreview.onload = null; 
        };
        
        imagePreview.src = newDataUrl;
        
      
        arrows = []; lines = []; placemarks = []; texts = [];
        eraserStrokes = []; pastedImages = []; tracedObjects = []; cutObjects = [];
        loadedPastedImages = {};
    }

    async function loadImage(file, isReset = false) {
        if (file.name.toLowerCase().endsWith('.heic') || file.name.toLowerCase().endsWith('.heif')) {
            statusBar.textContent = 'Конвертация HEIC...';
            try {
                const result = await heic2any({ blob: file, toType: "image/jpeg", quality: 0.9 });
                const blob = Array.isArray(result) ? result[0] : result;
                file = new File([blob], file.name.replace(/\.(heic|heif)$/i, ".jpg"), { type: "image/jpeg" });
            } catch (e) {
                console.error("HEIC conversion error:", e);
                statusBar.textContent = 'Ошибка: Не удалось открыть HEIC файл.';
                return;
            }
        }

        const reader = new FileReader();
        reader.onload = (e) => {
            const img = new Image();
            img.onload = () => {
                if (!isReset) {
                    originalFile = file;
                }
                
                baseImageDataUrl = e.target.result;
                imagePreview.src = baseImageDataUrl;
                imagePreview.style.display = 'block';
                
                const { naturalWidth, naturalHeight } = img;
                annotationCanvas.width = naturalWidth;
                annotationCanvas.height = naturalHeight;
                
                // Calculate initial zoom to fit
                const containerRect = imageContainer.getBoundingClientRect();
                const padding = 80;
                const fitRatio = Math.min(
                    (containerRect.width - padding) / naturalWidth,
                    (containerRect.height - padding) / naturalHeight,
                    1
                );
                currentZoom = fitRatio;
                
                updateImageSize();
                resetAnnotationsAndState();
                dropZone.style.display = 'none';
                statusBar.textContent = `Загружено: ${file.name || 'изображение'} (${naturalWidth}×${naturalHeight})`;
                buttons.exportAnnotations.disabled = false;
                buttons.importAnnotations.disabled = false;
                
                setTimeout(() => centerImage(), 50);
            };
            img.src = e.target.result;
        };
        reader.readAsDataURL(file);
    }

    function updateImageSize() {
        if (!imagePreview.src || !imagePreview.naturalWidth) return;
        const w = imagePreview.naturalWidth * currentZoom;
        const h = imagePreview.naturalHeight * currentZoom;
        imageWrapper.style.width = `${w}px`;
        imageWrapper.style.height = `${h}px`;
        zoomText.textContent = `${Math.round(currentZoom * 100)}%`;
    }

    function centerImage() {
        const containerRect = imageContainer.getBoundingClientRect();
        const wrapperRect = canvasWrapper.getBoundingClientRect();
        imageContainer.scrollLeft = (wrapperRect.width - containerRect.width) / 2;
        imageContainer.scrollTop = (wrapperRect.height - containerRect.height) / 2;
    }

    // ==================== DRAWING ====================
    function prepareBlurCache() {
        blurCache = {};
        if (!imagePreview.src || imagePreview.naturalWidth === 0) return;
        const neededBlurLevels = [...new Set(texts.filter(t => t.backgroundEnabled && t.backgroundType === 'blur' && t.blurAmount > 0).map(t => t.blurAmount))];
        neededBlurLevels.forEach(level => {
            const blurInPixels = (level / 100) * 20;
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = annotationCanvas.width;
            tempCanvas.height = annotationCanvas.height;
            const tempCtx = tempCanvas.getContext('2d');
            tempCtx.filter = `blur(${blurInPixels}px)`;
            tempCtx.drawImage(imagePreview, 0, 0);
            blurCache[level] = tempCanvas;
        });
    }

    function redrawAnnotations(tempObject = null) {
        prepareBlurCache();
        drawAllAnnotations(tempObject);
    }
    
    function drawAllAnnotations(tempObject = null) {
        annotationCtx.clearRect(0, 0, annotationCanvas.width, annotationCanvas.height);
        
        // Draw base image
        if (imagePreview.src && imagePreview.complete && imagePreview.naturalWidth > 0) {
            annotationCtx.drawImage(imagePreview, 0, 0, annotationCanvas.width, annotationCanvas.height);
        }

        // Draw annotations
        arrows.forEach(a => drawArrow(annotationCtx, a.start.x, a.start.y, a.end.x, a.end.y, a.color, a.thickness));
        lines.forEach(l => drawLine(annotationCtx, l.start.x, l.start.y, l.end.x, l.end.y, l.color, l.thickness));
        
        placemarks.forEach(p => {
            if (placemarkImage.complete && placemarkImage.naturalWidth > 0) {
                try {
                    const ratio = placemarkImage.naturalHeight / placemarkImage.naturalWidth || 1.4;
                    annotationCtx.drawImage(placemarkImage, p.x - p.size / 2, p.y - p.size, p.size, p.size * ratio);
                } catch (e) {}
            }
        });

        pastedImages.forEach(p => drawPastedImage(annotationCtx, p));
        tracedObjects.forEach(t => drawTracedObject(annotationCtx, t));
        cutObjects.forEach(c => drawCutObject(annotationCtx, c));
        texts.forEach(t => drawText(annotationCtx, t));
        
        // Eraser strokes
        eraserStrokes.forEach(stroke => drawEraserStroke(annotationCtx, stroke));
        
        if (isErasing && currentEraserPath.length > 1) {
            drawEraserStroke(annotationCtx, { path: currentEraserPath, size: parseInt(controls.eraserSize.value) });
        }
        
        if (isTracing && currentTracePath.length > 1) {
            drawTracePath(annotationCtx, currentTracePath);
        }
        
        // Selection handles
        annotationCtx.globalCompositeOperation = 'source-over';

        if (selectedCutObjectId) {
            const obj = cutObjects.find(c => c.id === selectedCutObjectId);
            if (obj) drawCutObjectSelectionHandles(annotationCtx, obj);
        }
        if (selectedTracedObjectId) {
            const obj = tracedObjects.find(t => t.id === selectedTracedObjectId);
            if (obj) drawTracedObjectSelectionHandles(annotationCtx, obj);
        }
        if (selectedPastedImageId) {
            const img = pastedImages.find(p => p.id === selectedPastedImageId);
            if (img) drawPastedImageSelectionHandles(annotationCtx, img);
        }
        if (selectedTextId) {
            const text = texts.find(t => t.id === selectedTextId);
            if (text) drawTextSelectionHandles(annotationCtx, text);
        }
        
        // Temp drawing
        if (tempObject) {
            const color = controls.color.value;
            const thickness = parseInt(controls.thickness.value);
            if (tempObject.type === 'arrow') drawArrow(annotationCtx, tempObject.start.x, tempObject.start.y, tempObject.end.x, tempObject.end.y, color, thickness);
            else if (tempObject.type === 'line') drawLine(annotationCtx, tempObject.start.x, tempObject.start.y, tempObject.end.x, tempObject.end.y, color, thickness);
        }
    }
    
    function saveWithAnnotations(format, quality) {
        if (!imagePreview.src) return;
        selectedTextId = null;
        selectedPastedImageId = null;
        selectedTracedObjectId = null;
        selectedCutObjectId = null;
        redrawAnnotations();
        
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        canvas.width = annotationCanvas.width;
        canvas.height = annotationCanvas.height;
        
        if (format === 'image/jpeg') {
            ctx.fillStyle = '#FFFFFF';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
        }
        
        ctx.drawImage(annotationCanvas, 0, 0);
        
        const ext = format === 'image/jpeg' ? 'jpg' : 'png';
        const fileName = `${(originalFile?.name || 'image').replace(/\.[^/.]+$/, '')}_edited.${ext}`;
        const link = document.createElement('a');
        link.download = fileName;
        link.href = canvas.toDataURL(format, quality);
        link.click();
        statusBar.textContent = `Сохранено: ${fileName}`;
    }

    function drawArrow(ctx, fromX, fromY, toX, toY, color, thickness) {
        const headLength = Math.min(30, Math.max(8, thickness * 2.5));
        const angle = Math.atan2(toY - fromY, toX - fromX);
        ctx.strokeStyle = color;
        ctx.fillStyle = color;
        ctx.lineWidth = thickness;
        ctx.lineCap = 'round';
        ctx.beginPath();
        ctx.moveTo(fromX, fromY);
        ctx.lineTo(toX, toY);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(toX, toY);
        ctx.lineTo(toX - headLength * Math.cos(angle - Math.PI / 6), toY - headLength * Math.sin(angle - Math.PI / 6));
        ctx.lineTo(toX - headLength * Math.cos(angle + Math.PI / 6), toY - headLength * Math.sin(angle + Math.PI / 6));
        ctx.closePath();
        ctx.fill();
    }

    function drawLine(ctx, fromX, fromY, toX, toY, color, thickness) {
        ctx.save();
        ctx.strokeStyle = color;
        ctx.lineWidth = thickness;
        ctx.lineCap = 'round';
        ctx.beginPath();
        ctx.moveTo(fromX, fromY);
        ctx.lineTo(toX, toY);
        ctx.stroke();
        ctx.restore();
    }
   
    function drawText(ctx, t) {
        ctx.save();
        let fontStyle = '';
        if (t.isBold) fontStyle += 'bold ';
        if (t.isItalic) fontStyle += 'italic ';
        ctx.font = `${fontStyle}${t.size}px ${t.family}`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        
        if (t.backgroundEnabled) {
            const metrics = ctx.measureText(t.text);
            const padding = t.size * 0.3;
            const rectWidth = metrics.width + padding * 2;
            const rectHeight = t.size + padding;
            const rectX = -rectWidth / 2;
            const rectY = -rectHeight / 2;
            ctx.save();
            ctx.translate(t.x, t.y);
            ctx.rotate(t.rotation * Math.PI / 180);
            if (t.backgroundType === 'blur' && t.blurAmount > 0 && blurCache[t.blurAmount]) {
                const blurredImage = blurCache[t.blurAmount];
                ctx.beginPath();
                ctx.rect(rectX, rectY, rectWidth, rectHeight);
                ctx.clip();
                ctx.rotate(-t.rotation * Math.PI / 180);
                ctx.translate(-t.x, -t.y);
                ctx.drawImage(blurredImage, 0, 0);
            } else if (t.backgroundType === 'color') {
                ctx.fillStyle = t.backgroundColor;
                ctx.fillRect(rectX, rectY, rectWidth, rectHeight);
            }
            ctx.restore();
        }
        
        ctx.translate(t.x, t.y);
        ctx.rotate(t.rotation * Math.PI / 180);
        
        if (t.strokeEnabled) {
            ctx.strokeStyle = t.strokeColor;
            ctx.lineWidth = Math.max(1, t.size / 15);
            ctx.strokeText(t.text, 0, 0);
        }
        if (t.shadowEnabled) {
            ctx.shadowColor = t.shadowColor;
            ctx.shadowBlur = 5;
            ctx.shadowOffsetX = 2;
            ctx.shadowOffsetY = 2;
        }
        ctx.fillStyle = t.color;
        ctx.fillText(t.text, 0, 0);
        
        if (t.isUnderline || t.isStrikethrough) {
            const metrics = ctx.measureText(t.text);
            const textWidth = metrics.width;
            const lineThickness = Math.max(1, Math.floor(t.size / 15));
            ctx.fillStyle = t.color;
            if (t.isUnderline) {
                ctx.fillRect(-textWidth / 2, t.size * 0.4, textWidth, lineThickness);
            }
            if (t.isStrikethrough) {
                ctx.fillRect(-textWidth / 2, -lineThickness / 2, textWidth, lineThickness);
            }
        }
        ctx.restore();
    }
   
    function drawTextSelectionHandles(ctx, t) {
        ctx.font = `${t.size}px ${t.family}`;
        const metrics = ctx.measureText(t.text);
        const w = metrics.width + 20, h = t.size + 10, handleRadius = 8, handleOffset = 20;
        const accentColor = '#2196F3';
        ctx.save();
        ctx.translate(t.x, t.y);
        ctx.rotate(t.rotation * Math.PI / 180);
        ctx.strokeStyle = accentColor;
        ctx.lineWidth = 2;
        ctx.setLineDash([6, 3]);
        ctx.strokeRect(-w / 2, -h / 2, w, h);
        ctx.beginPath();
        ctx.arc(0, -h / 2 - handleOffset, handleRadius, 0, 2 * Math.PI);
        ctx.fillStyle = accentColor;
        ctx.fill();
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 2;
        ctx.setLineDash([]);
        ctx.stroke();
        ctx.restore();
    }

    function drawEraserStroke(ctx, stroke) {
        if (!stroke || stroke.path.length < 2) return;
        ctx.save();
        ctx.strokeStyle = '#FFFFFF';
        ctx.lineWidth = stroke.size;
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';
        ctx.globalCompositeOperation = 'destination-out';
        ctx.beginPath();
        ctx.moveTo(stroke.path[0].x, stroke.path[0].y);
        for (let i = 1; i < stroke.path.length; i++) {
            ctx.lineTo(stroke.path[i].x, stroke.path[i].y);
        }
        ctx.stroke();
        ctx.restore();
    }

    // ==================== MODE & STATE ====================
    function setActiveMode(mode) {
           hideAllContextMenus();
        activeMode = (activeMode === mode) ? null : mode;
        selectedTextId = null;
        selectedPastedImageId = null;
        selectedTracedObjectId = null;
        selectedCutObjectId = null;
        Object.values(buttons).forEach(b => { if (b && typeof b.classList !== 'undefined') b.classList.remove('active'); });
        if (activeMode && buttons[activeMode]) buttons[activeMode].classList.add('active');
        redrawAnnotations();
    }

    function resetAnnotationsAndState() {
        arrows = []; lines = []; placemarks = []; texts = []; eraserStrokes = [];
        pastedImages = []; tracedObjects = []; cutObjects = [];
        activeMode = null; isSelecting = false; selectedArea = null;
        isDrawingArrow = false; isDrawingLine = false;
        selectedTextId = null; selectedPastedImageId = null; selectedTracedObjectId = null; selectedCutObjectId = null;
        isErasing = false; currentEraserPath = [];
        isTracing = false; currentTracePath = [];
        selection.style.display = 'none';
        selectionInfo.style.display = 'none';
        blurCache = {};
        loadedPastedImages = {};
        Object.values(buttons).forEach(b => { if (b && typeof b.classList !== 'undefined') b.classList.remove('active'); });
        buttons.exportAnnotations.disabled = !imagePreview.src;
        buttons.importAnnotations.disabled = !imagePreview.src;
        historyStack = [];
        redoStack = [];
        saveStateToHistory();
        updateHistoryInfo();
        redrawAnnotations();
    }

    function revertToOriginal() {
        if (historyStack.length > 1) {
            // Возврат к первому состоянию в истории
            const firstState = historyStack[0];
            historyStack = [firstState];
            redoStack = [];
            applyState(firstState);
            updateUndoRedoButtons();
            updateHistoryInfo();
            statusBar.textContent = 'Возврат к исходному состоянию';
        } else if (!imagePreview.src) {
            dropZone.style.display = 'flex';
            statusBar.textContent = 'Готов к работе. Ctrl+V для вставки.';
        }
    }

    // ==================== CUT OBJECTS ====================
function cutSelectionAsObject() {
        hideAllContextMenus();
        if (!selectedArea) return;
        
        const selArea = { ...selectedArea };
        selection.style.display = 'none';
        selectionInfo.style.display = 'none';
        selectedArea = null;
        
        const canvas = document.createElement('canvas');
        canvas.width = selArea.width;
        canvas.height = selArea.height;
        const ctx = canvas.getContext('2d');
        ctx.drawImage(imagePreview, selArea.x, selArea.y, selArea.width, selArea.height, 0, 0, selArea.width, selArea.height);
        
        const newId = Date.now();
        const cutObj = {
            id: newId,
            imageDataUrl: canvas.toDataURL(),
            x: selArea.x,
            y: selArea.y,
            width: selArea.width,
            height: selArea.height,
            originalArea: { ...selArea }
        };
        
        const img = new Image();
        img.onload = () => {
            cutObj.image = img;
            cutObjects.push(cutObj);
            
            // Очищаем область на базовом изображении
            const mainCanvas = document.createElement('canvas');
            mainCanvas.width = imagePreview.naturalWidth;
            mainCanvas.height = imagePreview.naturalHeight;
            const mainCtx = mainCanvas.getContext('2d');
            mainCtx.drawImage(imagePreview, 0, 0);
            mainCtx.fillStyle = '#FFFFFF';
            mainCtx.fillRect(selArea.x, selArea.y, selArea.width, selArea.height);
            
            baseImageDataUrl = mainCanvas.toDataURL();
            selectedCutObjectId = newId;

            // Ждем загрузки фона перед перерисовкой
            imagePreview.onload = () => {
                saveStateToHistory();
                redrawAnnotations();
                statusBar.textContent = 'Фрагмент вырезан. Переместите его.';
                showNotification('✓ Фрагмент вырезан');
                imagePreview.onload = null;
            };
            imagePreview.src = baseImageDataUrl;
        };
        img.src = cutObj.imageDataUrl;
    }

    function drawCutObject(ctx, obj) {
        if (!obj.image || !obj.image.complete || obj.image.naturalWidth === 0) return;
        ctx.drawImage(obj.image, obj.x, obj.y, obj.width, obj.height);
    }

    function drawCutObjectSelectionHandles(ctx, obj) {
        const accentColor = '#FF9800';
        ctx.save();
        ctx.strokeStyle = accentColor;
        ctx.lineWidth = 2;
        ctx.setLineDash([6, 3]);
        ctx.strokeRect(obj.x, obj.y, obj.width, obj.height);
        ctx.restore();
    }

    function checkCutObjectInteraction(pos) {
        const result = { isOver: false, id: null, obj: null };
        for (let i = cutObjects.length - 1; i >= 0; i--) {
            const c = cutObjects[i];
            if (pos.x >= c.x && pos.x <= c.x + c.width && pos.y >= c.y && pos.y <= c.y + c.height) {
                result.isOver = true;
                result.id = c.id;
                result.obj = c;
                return result;
            }
        }
        return result;
    }

    function loadCutObjectsFromState() {
        cutObjects.forEach(obj => {
            if (!obj.image && obj.imageDataUrl) {
                const img = new Image();
                img.onload = () => { obj.image = img; redrawAnnotations(); };
                img.src = obj.imageDataUrl;
            }
        });
    }

    // ==================== SELECTION OPERATIONS ====================
function clearSelection() {
        hideAllContextMenus();
        if (!selectedArea) return;
        
        const canvas = document.createElement('canvas');
        canvas.width = imagePreview.naturalWidth;
        canvas.height = imagePreview.naturalHeight;
        const ctx = canvas.getContext('2d');
        ctx.drawImage(imagePreview, 0, 0);
        ctx.fillStyle = '#FFFFFF';
        ctx.fillRect(selectedArea.x, selectedArea.y, selectedArea.width, selectedArea.height);
        
        baseImageDataUrl = canvas.toDataURL();
        
        selection.style.display = 'none';
        selectionInfo.style.display = 'none';
        selectedArea = null;

        // Ждем загрузки
        imagePreview.onload = () => {
            saveStateToHistory();
            redrawAnnotations();
            statusBar.textContent = 'Область очищена';
            imagePreview.onload = null;
        };
        imagePreview.src = baseImageDataUrl;
    }

function clearAroundSelection() {
        hideAllContextMenus();
        if (!selectedArea) return;
        
        const canvas = document.createElement('canvas');
        canvas.width = imagePreview.naturalWidth;
        canvas.height = imagePreview.naturalHeight;
        const ctx = canvas.getContext('2d');
        
        ctx.fillStyle = '#FFFFFF';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        ctx.drawImage(
            imagePreview,
            selectedArea.x, selectedArea.y, selectedArea.width, selectedArea.height,
            selectedArea.x, selectedArea.y, selectedArea.width, selectedArea.height
        );
        
        baseImageDataUrl = canvas.toDataURL();
        
        selection.style.display = 'none';
        selectionInfo.style.display = 'none';
        selectedArea = null;

        imagePreview.onload = () => {
            saveStateToHistory();
            redrawAnnotations();
            statusBar.textContent = 'Всё вокруг выделения удалено';
            imagePreview.onload = null;
        };
        imagePreview.src = baseImageDataUrl;
    }

function blurSelection() {
        hideAllContextMenus();
        if (!selectedArea) return;
        
        const canvas = document.createElement('canvas');
        canvas.width = imagePreview.naturalWidth;
        canvas.height = imagePreview.naturalHeight;
        const ctx = canvas.getContext('2d');
        ctx.drawImage(imagePreview, 0, 0);
        
        const blurCanvas = document.createElement('canvas');
        blurCanvas.width = selectedArea.width;
        blurCanvas.height = selectedArea.height;
        const blurCtx = blurCanvas.getContext('2d');
        blurCtx.filter = 'blur(10px)';
        blurCtx.drawImage(imagePreview, selectedArea.x, selectedArea.y, selectedArea.width, selectedArea.height, 0, 0, selectedArea.width, selectedArea.height);
        
        ctx.drawImage(blurCanvas, selectedArea.x, selectedArea.y);
        
        baseImageDataUrl = canvas.toDataURL();
        
        selection.style.display = 'none';
        selectionInfo.style.display = 'none';
        selectedArea = null;

        imagePreview.onload = () => {
            saveStateToHistory();
            redrawAnnotations();
            statusBar.textContent = 'Область размыта';
            showNotification('✓ Область размыта');
            imagePreview.onload = null;
        };
        imagePreview.src = baseImageDataUrl;
    }

function pixelateSelection() {
        hideAllContextMenus();
        if (!selectedArea) return;
        
        const canvas = document.createElement('canvas');
        canvas.width = imagePreview.naturalWidth;
        canvas.height = imagePreview.naturalHeight;
        const ctx = canvas.getContext('2d');
        ctx.drawImage(imagePreview, 0, 0);
        
        const pixelSize = 10;
        const tempCanvas = document.createElement('canvas');
        tempCanvas.width = Math.ceil(selectedArea.width / pixelSize);
        tempCanvas.height = Math.ceil(selectedArea.height / pixelSize);
        const tempCtx = tempCanvas.getContext('2d');
        tempCtx.drawImage(imagePreview, selectedArea.x, selectedArea.y, selectedArea.width, selectedArea.height, 0, 0, tempCanvas.width, tempCanvas.height);
        
        ctx.imageSmoothingEnabled = false;
        ctx.drawImage(tempCanvas, 0, 0, tempCanvas.width, tempCanvas.height, selectedArea.x, selectedArea.y, selectedArea.width, selectedArea.height);
        ctx.imageSmoothingEnabled = true;
        
        baseImageDataUrl = canvas.toDataURL();
        
        selection.style.display = 'none';
        selectionInfo.style.display = 'none';
        selectedArea = null;

        imagePreview.onload = () => {
            saveStateToHistory();
            redrawAnnotations();
            statusBar.textContent = 'Область пикселизирована';
            showNotification('✓ Область пикселизирована');
            imagePreview.onload = null;
        };
        imagePreview.src = baseImageDataUrl;
    }
    
function copySelection() {
    hideAllContextMenus();
    if (!selectedArea) return;
    const canvas = document.createElement('canvas');
    canvas.width = selectedArea.width;
    canvas.height = selectedArea.height;
    canvas.getContext('2d').drawImage(imagePreview, selectedArea.x, selectedArea.y, selectedArea.width, selectedArea.height, 0, 0, selectedArea.width, selectedArea.height);
    canvas.toBlob(blob => {
        navigator.clipboard.write([new ClipboardItem({ "image/png": blob })]).then(() => {
            statusBar.textContent = 'Выделение скопировано';
            showNotification('✓ Скопировано в буфер обмена');
        }).catch(err => {
            showNotification('✗ Ошибка копирования');
        });
    });
}

    function cropSelection() {
        hideAllContextMenus();
    if (!selectedArea) return;
        if (!selectedArea) return;
        const canvas = document.createElement('canvas');
        canvas.width = selectedArea.width;
        canvas.height = selectedArea.height;
        canvas.getContext('2d').drawImage(imagePreview, selectedArea.x, selectedArea.y, selectedArea.width, selectedArea.height, 0, 0, selectedArea.width, selectedArea.height);
        canvas.toBlob((blob) => {
            loadImage(new File([blob], `cropped_${originalFile?.name || 'image.png'}`, { type: 'image/png' }));
        }, 'image/png');
    }

    // ==================== TRACED OBJECTS ====================
    function drawTracePath(ctx, path) {
        if (path.length < 2) return;
        ctx.save();
        ctx.strokeStyle = '#2196F3';
        ctx.lineWidth = 2;
        ctx.setLineDash([6, 3]);
        ctx.beginPath();
        ctx.moveTo(path[0].x, path[0].y);
        for (let i = 1; i < path.length; i++) {
            ctx.lineTo(path[i].x, path[i].y);
        }
        if (path.length > 10 && Math.hypot(path[path.length - 1].x - path[0].x, path[path.length - 1].y - path[0].y) < 30) {
            ctx.lineTo(path[0].x, path[0].y);
            ctx.fillStyle = 'rgba(33, 150, 243, 0.2)';
            ctx.fill();
        }
        ctx.stroke();
        ctx.restore();
    }

    async function createTracedObject(path) {
        const bounds = getPathBounds(path);
        if (bounds.width < 5 || bounds.height < 5) return;
        
        const maskCanvas = document.createElement('canvas');
        maskCanvas.width = bounds.width;
        maskCanvas.height = bounds.height;
        const maskCtx = maskCanvas.getContext('2d');
        maskCtx.fillStyle = 'black';
        maskCtx.beginPath();
        maskCtx.moveTo(path[0].x - bounds.minX, path[0].y - bounds.minY);
        for (let i = 1; i < path.length; i++) {
            maskCtx.lineTo(path[i].x - bounds.minX, path[i].y - bounds.minY);
        }
        maskCtx.closePath();
        maskCtx.fill();
        
        const objCanvas = document.createElement('canvas');
        objCanvas.width = bounds.width;
        objCanvas.height = bounds.height;
        const objCtx = objCanvas.getContext('2d');
        objCtx.drawImage(maskCanvas, 0, 0);
        objCtx.globalCompositeOperation = 'source-in';
        objCtx.drawImage(imagePreview, bounds.minX, bounds.minY, bounds.width, bounds.height, 0, 0, bounds.width, bounds.height);
        
        const newId = Date.now();
        const newObject = {
            id: newId,
            imageDataUrl: objCanvas.toDataURL(),
            x: bounds.minX,
            y: bounds.minY,
            width: bounds.width,
            height: bounds.height,
            rotation: 0,
            path: path.map(p => ({ x: p.x - bounds.minX, y: p.y - bounds.minY })),
        };
        
        const img = new Image();
        await new Promise(resolve => { img.onload = resolve; img.src = newObject.imageDataUrl; });
        newObject.image = img;
        tracedObjects.push(newObject);
        statusBar.textContent = 'Область обведена';
    }

    function drawTracedObject(ctx, obj) {
        if (!obj.image || !obj.image.complete || obj.image.naturalWidth === 0) return;
        ctx.save();
        ctx.translate(obj.x + obj.width / 2, obj.y + obj.height / 2);
        ctx.rotate(obj.rotation * Math.PI / 180);
        ctx.drawImage(obj.image, -obj.width / 2, -obj.height / 2, obj.width, obj.height);
        ctx.restore();
    }

    function drawTracedObjectSelectionHandles(ctx, obj) {
        const handleRadius = 8, handleOffset = 20;
        const accentColor = '#4CAF50';
        ctx.save();
        ctx.translate(obj.x + obj.width / 2, obj.y + obj.height / 2);
        ctx.rotate(obj.rotation * Math.PI / 180);
        ctx.strokeStyle = accentColor;
        ctx.lineWidth = 2;
        ctx.setLineDash([6, 3]);
        ctx.strokeRect(-obj.width / 2, -obj.height / 2, obj.width, obj.height);
        ctx.beginPath();
        ctx.arc(0, -obj.height / 2 - handleOffset, handleRadius, 0, 2 * Math.PI);
        ctx.fillStyle = accentColor;
        ctx.fill();
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 2;
        ctx.setLineDash([]);
        ctx.stroke();
        ctx.restore();
    }

    function checkTracedObjectInteraction(pos) {
        const result = { isOver: false, onRotateHandle: false, id: null, obj: null };
        const handleRadius = 10, handleOffset = 20;
        for (let i = tracedObjects.length - 1; i >= 0; i--) {
            const t = tracedObjects[i];
            const centerX = t.x + t.width / 2;
            const centerY = t.y + t.height / 2;
            const angle = -t.rotation * Math.PI / 180;
            const dx = pos.x - centerX;
            const dy = pos.y - centerY;
            const rotatedX = dx * Math.cos(angle) - dy * Math.sin(angle);
            const rotatedY = dx * Math.sin(angle) + dy * Math.cos(angle);
            const handleDist = Math.hypot(rotatedX, rotatedY - (-t.height / 2 - handleOffset));
            if (handleDist <= handleRadius) {
                result.isOver = true;
                result.onRotateHandle = true;
                result.id = t.id;
                result.obj = t;
                return result;
            }
            if (Math.abs(rotatedX) < t.width / 2 && Math.abs(rotatedY) < t.height / 2) {
                result.isOver = true;
                result.onRotateHandle = false;
                result.id = t.id;
                result.obj = t;
                return result;
            }
        }
        return result;
    }

    function getPathBounds(path) {
        let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
        path.forEach(p => {
            minX = Math.min(minX, p.x);
            minY = Math.min(minY, p.y);
            maxX = Math.max(maxX, p.x);
            maxY = Math.max(maxY, p.y);
        });
        return { minX, minY, maxX, maxY, width: maxX - minX, height: maxY - minY };
    }

    function loadTracedObjectsFromState() {
        tracedObjects.forEach(obj => {
            if (!obj.image && obj.imageDataUrl) {
                const img = new Image();
                img.onload = () => { obj.image = img; redrawAnnotations(); };
                img.src = obj.imageDataUrl;
            }
        });
    }

    function copyTracedObject() {
        const original = tracedObjects.find(t => t.id === selectedTracedObjectId);
        if (!original) return;
        
        const canvas = document.createElement('canvas');
        canvas.width = original.width;
        canvas.height = original.height;
        const ctx = canvas.getContext('2d');
        if (original.image && original.image.complete) {
            ctx.drawImage(original.image, 0, 0);
            canvas.toBlob(blob => {
                if (navigator.clipboard && navigator.clipboard.write) {
                    navigator.clipboard.write([new ClipboardItem({ "image/png": blob })]);
                }
            }, 'image/png');
        }
        
        const newId = Date.now();
        const newObject = JSON.parse(JSON.stringify(original));
        newObject.id = newId;
        newObject.x += 20;
        newObject.y += 20;
        newObject.image = original.image;
        tracedObjects.push(newObject);
        saveStateToHistory();
        redrawAnnotations();
        statusBar.textContent = 'Объект скопирован';
    }
    
    function cutTracedObject() { copyTracedObject(); deleteTracedObject(); }
    
    function deleteTracedObject() {
        if (selectedTracedObjectId) {
            tracedObjects = tracedObjects.filter(t => t.id !== selectedTracedObjectId);
            selectedTracedObjectId = null;
            saveStateToHistory();
            redrawAnnotations();
        }
    }

    // ==================== PASTED IMAGES ====================
    function drawPastedImage(ctx, pasted) {
        if (loadedPastedImages[pasted.id] && loadedPastedImages[pasted.id].complete) {
            ctx.drawImage(loadedPastedImages[pasted.id], pasted.x, pasted.y, pasted.width, pasted.height);
        }
    }

    function drawPastedImageSelectionHandles(ctx, pasted) {
        const handleSize = 10;
        const halfHandle = handleSize / 2;
        const accentColor = '#9C27B0';
        ctx.save();
        ctx.strokeStyle = accentColor;
        ctx.lineWidth = 2;
        ctx.setLineDash([6, 3]);
        ctx.strokeRect(pasted.x, pasted.y, pasted.width, pasted.height);
        ctx.setLineDash([]);
        
        // Угловые ручки (пропорциональное изменение)
        ctx.fillStyle = accentColor;
        ctx.fillRect(pasted.x - halfHandle, pasted.y - halfHandle, handleSize, handleSize);
        ctx.fillRect(pasted.x + pasted.width - halfHandle, pasted.y - halfHandle, handleSize, handleSize);
        ctx.fillRect(pasted.x - halfHandle, pasted.y + pasted.height - halfHandle, handleSize, handleSize);
        ctx.fillRect(pasted.x + pasted.width - halfHandle, pasted.y + pasted.height - halfHandle, handleSize, handleSize);
        
        // Боковые ручки (свободное изменение)
        ctx.fillStyle = '#E1BEE7';
        ctx.fillRect(pasted.x + pasted.width / 2 - halfHandle, pasted.y - halfHandle, handleSize, handleSize);
        ctx.fillRect(pasted.x + pasted.width / 2 - halfHandle, pasted.y + pasted.height - halfHandle, handleSize, handleSize);
        ctx.fillRect(pasted.x - halfHandle, pasted.y + pasted.height / 2 - halfHandle, handleSize, handleSize);
        ctx.fillRect(pasted.x + pasted.width - halfHandle, pasted.y + pasted.height / 2 - halfHandle, handleSize, handleSize);
        ctx.restore();
    }

    function checkPastedImageInteraction(pos) {
        const result = { isOver: false, onHandle: null, id: null, obj: null, cursor: 'default' };
        const handleSize = 12;
        for (let i = pastedImages.length - 1; i >= 0; i--) {
            const p = pastedImages[i];
            const handles = {
                topLeft: { x: p.x, y: p.y, cursor: 'nwse-resize' },
                topRight: { x: p.x + p.width, y: p.y, cursor: 'nesw-resize' },
                bottomLeft: { x: p.x, y: p.y + p.height, cursor: 'nesw-resize' },
                bottomRight: { x: p.x + p.width, y: p.y + p.height, cursor: 'nwse-resize' },
                top: { x: p.x + p.width / 2, y: p.y, cursor: 'ns-resize' },
                bottom: { x: p.x + p.width / 2, y: p.y + p.height, cursor: 'ns-resize' },
                left: { x: p.x, y: p.y + p.height / 2, cursor: 'ew-resize' },
                right: { x: p.x + p.width, y: p.y + p.height / 2, cursor: 'ew-resize' },
            };
            for (const handleName in handles) {
                const handle = handles[handleName];
                if (Math.hypot(pos.x - handle.x, pos.y - handle.y) < handleSize) {
                    result.isOver = true;
                    result.onHandle = handleName;
                    result.id = p.id;
                    result.obj = p;
                    result.cursor = handle.cursor;
                    return result;
                }
            }
            if (pos.x >= p.x && pos.x <= p.x + p.width && pos.y >= p.y && pos.y <= p.y + p.height) {
                result.isOver = true;
                result.onHandle = null;
                result.id = p.id;
                result.obj = p;
                result.cursor = 'move';
                return result;
            }
        }
        return result;
    }

    function loadPastedImagesFromState() {
        loadedPastedImages = {};
        pastedImages.forEach(p => {
            const img = new Image();
            img.onload = () => { loadedPastedImages[p.id] = img; redrawAnnotations(); };
            img.src = p.src;
        });
    }

    function duplicatePastedImage() {
        const original = pastedImages.find(p => p.id === selectedPastedImageId);
        if (!original) return;
        const newId = Date.now();
        const newImg = { ...original, id: newId, x: original.x + 20, y: original.y + 20 };
        pastedImages.push(newImg);
        loadedPastedImages[newId] = loadedPastedImages[original.id];
        selectedPastedImageId = newId;
        saveStateToHistory();
        redrawAnnotations();
    }

    function deletePastedImage() {
        if (selectedPastedImageId) {
            pastedImages = pastedImages.filter(p => p.id !== selectedPastedImageId);
            delete loadedPastedImages[selectedPastedImageId];
            selectedPastedImageId = null;
            saveStateToHistory();
            redrawAnnotations();
        }
    }

    // ==================== TEXT FUNCTIONS ====================
    function editText() {
        const text = texts.find(t => t.id === selectedTextId);
        if (text) {
            showTextModal(text, newStyles => {
                if (newStyles.text) {
                    Object.assign(text, newStyles);
                    saveStateToHistory();
                } else {
                    deleteSelectedText();
                }
                redrawAnnotations();
            });
        }
    }

    function duplicateText() {
        const original = texts.find(t => t.id === selectedTextId);
        if (!original) return;
        const newText = { ...original, id: Date.now(), x: original.x + 20, y: original.y + 20 };
        texts.push(newText);
        selectedTextId = newText.id;
        saveStateToHistory();
        redrawAnnotations();
    }

    function deleteSelectedText() {
        if (selectedTextId) {
            texts = texts.filter(t => t.id !== selectedTextId);
            selectedTextId = null;
            saveStateToHistory();
            redrawAnnotations();
        }
    }

    function checkTextInteraction(pos) {
        const result = { isOver: false, onRotateHandle: false, id: null, obj: null };
        for (let i = texts.length - 1; i >= 0; i--) {
            const t = texts[i];
            annotationCtx.font = `${t.size}px ${t.family}`;
            const metrics = annotationCtx.measureText(t.text);
            const w = metrics.width + 20, h = t.size + 10, handleRadius = 10, handleOffset = 20;
            const angle = -t.rotation * Math.PI / 180;
            const dx = pos.x - t.x, dy = pos.y - t.y;
            const rotatedX = dx * Math.cos(angle) - dy * Math.sin(angle);
            const rotatedY = dx * Math.sin(angle) + dy * Math.cos(angle);
            const handleDist = Math.hypot(rotatedX, rotatedY - (-h / 2 - handleOffset));
            if (handleDist <= handleRadius) {
                result.isOver = true;
                result.onRotateHandle = true;
                result.id = t.id;
                result.obj = t;
                break;
            }
            if (Math.abs(rotatedX) < w / 2 && Math.abs(rotatedY) < h / 2) {
                result.isOver = true;
                result.onRotateHandle = false;
                result.id = t.id;
                result.obj = t;
                break;
            }
        }
        return result;
    }
    
    function hideAllContextMenus() {
    selectionContextMenu.style.display = 'none';
    textContextMenu.style.display = 'none';
    imageContextMenu.style.display = 'none';
    tracedObjectContextMenu.style.display = 'none';
    pastedImageContextMenu.style.display = 'none';
}

function getCurrentTextStyles() {
    return {
        color: textColorPicker.value,
        size: parseInt(modalFontSizeInput.value),
        family: modalFontFamilySelect.value,
        rotation: parseInt(controls.rotation.value)
    };
}

    function updateControlsForSelectedText() {
        const text = texts.find(t => t.id === selectedTextId);
        if (!text) return;
        textColorPicker.value = text.color;
        controls.fontSize.value = text.size;
        controls.fontFamily.value = text.family;
        controls.rotation.value = text.rotation;
    }

    function showTextModal(textObject, callback) {
       textModal.style.display = 'flex';
loadTemplates();
templateSelect.value = '';
textInput.focus();
        if (textObject) {
            textInput.value = textObject.text || '';
            textColorPicker.value = textObject.color || '#FF0000';
            textShadowCheckbox.checked = textObject.shadowEnabled || false;
            if (textObject.shadowColor) {
                const radio = document.querySelector(`input[name="shadowColor"][value="${textObject.shadowColor}"]`);
                if (radio) radio.checked = true;
            }
            textStrokeCheckbox.checked = textObject.strokeEnabled || false;
            if (textObject.strokeColor) {
                const radio = document.querySelector(`input[name="strokeColor"][value="${textObject.strokeColor}"]`);
                if (radio) radio.checked = true;
            }
            textBackgroundCheckbox.checked = textObject.backgroundEnabled || false;
            if (textObject.backgroundType) {
                const radio = document.querySelector(`input[name="backgroundType"][value="${textObject.backgroundType}"]`);
                if (radio) radio.checked = true;
            }
            textBackgroundColorPicker.value = textObject.backgroundColor || '#FFFFFF';
            textBlurAmountSlider.value = textObject.blurAmount || 25;
            textBlurAmountInput.value = textObject.blurAmount || 25;
            textBoldBtn.classList.toggle('active', !!textObject.isBold);
            textItalicBtn.classList.toggle('active', !!textObject.isItalic);
            textUnderlineBtn.classList.toggle('active', !!textObject.isUnderline);
            textStrikethroughBtn.classList.toggle('active', !!textObject.isStrikethrough);
            modalFontSizeInput.value = textObject.size || 30;
modalFontFamilySelect.value = textObject.family || 'Times New Roman';

        } else {
        textInput.value = '';
textColorPicker.value = controls.color.value;
modalFontSizeInput.value = controls.fontSize.value;
modalFontFamilySelect.value = controls.fontFamily.value;
loadSettings();
        }
        shadowOptionsContainer.style.display = textShadowCheckbox.checked ? 'flex' : 'none';
        strokeOptionsContainer.style.display = textStrokeCheckbox.checked ? 'flex' : 'none';
        backgroundOptionsContainer.style.display = textBackgroundCheckbox.checked ? 'flex' : 'none';
        textInput.select();
        textModalCallback = callback;
    }
    
    document.getElementById('modalOkBtn').onclick = () => {
        if (textModalCallback) {
            const newStyles = {
                text: textInput.value,
                color: textColorPicker.value,
                shadowEnabled: textShadowCheckbox.checked,
                shadowColor: document.querySelector('input[name="shadowColor"]:checked')?.value,
                strokeEnabled: textStrokeCheckbox.checked,
                strokeColor: document.querySelector('input[name="strokeColor"]:checked')?.value,
                backgroundEnabled: textBackgroundCheckbox.checked,
                backgroundType: document.querySelector('input[name="backgroundType"]:checked')?.value,
                backgroundColor: textBackgroundColorPicker.value,
                blurAmount: parseInt(textBlurAmountSlider.value),
                isBold: textBoldBtn.classList.contains('active'),
                isItalic: textItalicBtn.classList.contains('active'),
                isUnderline: textUnderlineBtn.classList.contains('active'),
                size: parseInt(modalFontSizeInput.value),
family: modalFontFamilySelect.value,
                isStrikethrough: textStrikethroughBtn.classList.contains('active')
                
            };
            textModalCallback(newStyles);
        }
        saveSettings();
        controls.fontSize.value = modalFontSizeInput.value;
controls.fontFamily.value = modalFontFamilySelect.value;
        textModal.style.display = 'none';
    };

    document.getElementById('modalCancelBtn').onclick = () => textModal.style.display = 'none';

    // ==================== ZOOM ====================
    const toggleFullscreen = () => {
        if (!document.fullscreenElement) document.documentElement.requestFullscreen();
        else document.exitFullscreen();
    };
    
    const saveAsJPG = () => saveWithAnnotations('image/jpeg', 0.92);
    const saveAsPNG = () => saveWithAnnotations('image/png');

    function zoomIn() {
        if (!imagePreview.src) return;
        currentZoom = Math.min(currentZoom * 1.25, 10);
        updateImageSize();
    }

    function zoomOut() {
        if (!imagePreview.src) return;
        currentZoom = Math.max(currentZoom / 1.25, 0.1);
        updateImageSize();
    }

    function resetZoom() {
        if (!imagePreview.src) return;
        const containerRect = imageContainer.getBoundingClientRect();
        const padding = 80;
        currentZoom = Math.min(
            (containerRect.width - padding) / imagePreview.naturalWidth,
            (containerRect.height - padding) / imagePreview.naturalHeight,
            1
        );
        updateImageSize();
        centerImage();
    }

    imageContainer.addEventListener('wheel', (e) => {
        if (!imagePreview.src) return;
        e.preventDefault();
        if (e.deltaY < 0) zoomIn();
        else zoomOut();
    }, { passive: false });

    // ==================== CLIPBOARD ====================
    async function getClipboardImage(callback) {
        try {
            const permission = await navigator.permissions.query({ name: 'clipboard-read' });
            if (permission.state === 'denied') {
                statusBar.textContent = 'Доступ к буферу запрещен';
                return;
            }
            const items = await navigator.clipboard.read();
            for (const item of items) {
                const imageType = item.types.find(type => type.startsWith('image/'));
                if (imageType) {
                    const blob = await item.getType(imageType);
                    const reader = new FileReader();
                    reader.onload = (e) => callback(e.target.result);
                    reader.readAsDataURL(blob);
                    return;
                }
            }
            statusBar.textContent = 'Изображение в буфере не найдено';
        } catch (err) {
            console.error('Clipboard error:', err);
            statusBar.textContent = 'Не удалось прочитать буфер';
        }
    }


// ==================== ДОБАВИТЬ НОВУЮ ФУНКЦИЮ ДЛЯ УВЕДОМЛЕНИЙ ====================

function showNotification(message, duration = 2000) {
    // Удаляем предыдущее уведомление если есть
    const existingNotification = document.querySelector('.notification-toast');
    if (existingNotification) {
        existingNotification.remove();
    }
    
    const notification = document.createElement('div');
    notification.className = 'notification-toast';
    notification.textContent = message;
    document.body.appendChild(notification);
    
    // Анимация появления
    setTimeout(() => notification.classList.add('show'), 10);
    
    // Автоматическое скрытие
    setTimeout(() => {
        notification.classList.remove('show');
        setTimeout(() => notification.remove(), 300);
    }, duration);
}

// ==================== ДОБАВИТЬ CSS СТИЛИ (в секцию <style>) ====================


function pasteIntoSelection() {
        hideAllContextMenus();
        if (!selectedArea) return;
        getClipboardImage(imageDataUrl => {
            const pastedImg = new Image();
            pastedImg.onload = () => {
                const canvas = document.createElement('canvas');
                canvas.width = imagePreview.naturalWidth;
                canvas.height = imagePreview.naturalHeight;
                const ctx = canvas.getContext('2d');
                ctx.drawImage(imagePreview, 0, 0);
                ctx.drawImage(pastedImg, selectedArea.x, selectedArea.y, selectedArea.width, selectedArea.height);
                
                baseImageDataUrl = canvas.toDataURL();
                
                selection.style.display = 'none';
                selectionInfo.style.display = 'none';
                selectedArea = null;

                imagePreview.onload = () => {
                    saveStateToHistory();
                    redrawAnnotations();
                    statusBar.textContent = 'Изображение вставлено в область';
                    showNotification('✓ Изображение вставлено');
                    imagePreview.onload = null;
                };
                imagePreview.src = baseImageDataUrl;
            };
            pastedImg.src = imageDataUrl;
        });
    }

    function pasteAsObject() {
        if (!imagePreview.src) return;
        getClipboardImage(imageDataUrl => {
            const pastedImg = new Image();
            pastedImg.onload = () => {
                const newId = Date.now();
                const newPastedImage = {
                    id: newId,
                    src: imageDataUrl,
                    x: contextMenuPos.x - pastedImg.naturalWidth / 2,
                    y: contextMenuPos.y - pastedImg.naturalHeight / 2,
                    width: pastedImg.naturalWidth,
                    height: pastedImg.naturalHeight,
                };
                pastedImages.push(newPastedImage);
                loadedPastedImages[newId] = pastedImg;
                selectedPastedImageId = newId;
                saveStateToHistory();
                redrawAnnotations();
                statusBar.textContent = 'Изображение вставлено как объект';
            };
            pastedImg.src = imageDataUrl;
        });
    }

    // ==================== EXPORT/IMPORT ====================
    async function exportAnnotationsAsJSON() {
        if (!imagePreview.src) return;
        const annotationData = {
            image: { width: imagePreview.naturalWidth, height: imagePreview.naturalHeight },
            arrows, placemarks, texts, eraserStrokes, pastedImages,
            tracedObjects: tracedObjects.map(o => ({ ...o, image: null })),
            cutObjects: cutObjects.map(o => ({ ...o, image: null }))
        };
        try {
            const jsonString = JSON.stringify(annotationData, null, 2);
            const zip = new JSZip();
            zip.file("annotations.json", jsonString);
            const blob = await zip.generateAsync({ type: "blob", compression: "DEFLATE", compressionOptions: { level: 9 } });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;
            link.download = `${(originalFile?.name || 'image').replace(/\.[^/.]+$/, '')}_annotations.image`;
            link.click();
            URL.revokeObjectURL(url);
            statusBar.textContent = 'Аннотации экспортированы';
        } catch (e) {
            console.error("Export error:", e);
            statusBar.textContent = 'Ошибка экспорта';
        }
    }

   
   
   
      function importAnnotationsFromJSON() {
        if (!imagePreview.src) return;
        jsonInput.click();
    }

    jsonInput.addEventListener('change', async (e) => {
        const file = e.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.readAsArrayBuffer(file);
        reader.onload = async (event) => {
            try {
                const arrayBuffer = event.target.result;
                let jsonContent;
                try {
                    const zip = await JSZip.loadAsync(arrayBuffer);
                    let jsonFile = zip.file("annotations.json");
                    if (!jsonFile) {
                        const files = Object.keys(zip.files);
                        const anyJson = files.find(name => name.endsWith('.json'));
                        if (anyJson) jsonFile = zip.file(anyJson);
                    }
                    if (jsonFile) {
                        jsonContent = await jsonFile.async("string");
                    } else {
                        throw new Error("JSON not found in archive");
                    }
                } catch (zipError) {
                    const decoder = new TextDecoder("utf-8");
                    jsonContent = decoder.decode(arrayBuffer);
                    if (!jsonContent.trim().startsWith('{')) {
                        throw new Error("Invalid format");
                    }
                }
                const data = JSON.parse(jsonContent);
                if (data.image && (data.image.width !== imagePreview.naturalWidth || data.image.height !== imagePreview.naturalHeight)) {
                    if (!confirm('Размеры изображения не совпадают. Продолжить?')) return;
                }
                arrows = data.arrows || [];
                lines = data.lines || [];
                placemarks = data.placemarks || [];
                texts = data.texts || [];
                eraserStrokes = data.eraserStrokes || [];
                pastedImages = data.pastedImages || [];
                tracedObjects = data.tracedObjects || [];
                cutObjects = data.cutObjects || [];
                loadPastedImagesFromState();
                loadTracedObjectsFromState();
                loadCutObjectsFromState();
                saveStateToHistory();
                redrawAnnotations();
                statusBar.textContent = `Аннотации загружены: ${file.name}`;
            } catch (err) {
                alert('Не удалось прочитать файл');
                console.error("Import error:", err);
            } finally {
                e.target.value = null;
            }
        };
    });

    // ==================== EVENT LISTENERS ====================
    dropZone.addEventListener('dragover', (e) => { e.preventDefault(); dropZone.classList.add('dragover'); });
    dropZone.addEventListener('dragleave', () => dropZone.classList.remove('dragover'));
    dropZone.addEventListener('drop', (e) => {
        e.preventDefault();
        dropZone.classList.remove('dragover');
        const file = e.dataTransfer.files[0];
        if (file && (file.type.startsWith('image/') || file.name.toLowerCase().match(/\.(heic|heif)$/))) {
            loadImage(file);
        }
    });

    fileInput.addEventListener('change', (e) => { if (e.target.files[0]) loadImage(e.target.files[0]); });

    // ==================== PASTE EVENT (ИСПРАВЛЕННЫЙ) ====================
    document.addEventListener('paste', (event) => {
        // БЛОКИРУЕМ вставку изображения если открыто модальное окно текста
        if (textModal.style.display === 'flex') {
            // Проверяем, есть ли изображение в буфере
            const items = (event.clipboardData || event.originalEvent.clipboardData).items;
            for (const item of items) {
                if (item.type.startsWith("image/")) {
                    // Есть изображение - блокируем вставку полностью
                    // Не делаем event.preventDefault() чтобы текст мог вставиться
                    // Просто выходим, не обрабатывая изображение
                    return;
                }
            }
            // Если нет изображения, позволяем вставить текст в поле ввода
            return;
        }

        const items = (event.clipboardData || event.originalEvent.clipboardData).items;
        for (const item of items) {
            if (item.type.startsWith("image/")) {
                const blob = item.getAsFile();
                if (blob) {
                    event.preventDefault();
                    
                    if (imagePreview.src) {
                        // Вставляем как объект если изображение уже загружено
                        const reader = new FileReader();
                        reader.onload = (e) => {
                            const pastedImg = new Image();
                            pastedImg.onload = () => {
                                const newId = Date.now();
                                const centerX = annotationCanvas.width / 2;
                                const centerY = annotationCanvas.height / 2;
                                const newPastedImage = {
                                    id: newId,
                                    src: e.target.result,
                                    x: centerX - pastedImg.naturalWidth / 2,
                                    y: centerY - pastedImg.naturalHeight / 2,
                                    width: pastedImg.naturalWidth,
                                    height: pastedImg.naturalHeight,
                                };
                                pastedImages.push(newPastedImage);
                                loadedPastedImages[newId] = pastedImg;
                                selectedPastedImageId = newId;
                                saveStateToHistory();
                                redrawAnnotations();
                                statusBar.textContent = 'Изображение вставлено как объект';
                            };
                            pastedImg.src = e.target.result;
                        };
                        reader.readAsDataURL(blob);
                    } else {
                        // Загружаем как основное изображение
                        loadImage(new File([blob], "pasted_image.png", { type: blob.type }));
                    }
                    return;
                }
            }
        }
    });

    // ==================== CONTEXT MENUS ====================
    imageContainer.addEventListener('contextmenu', e => {
        e.preventDefault();
        const pos = getMousePos(e);
        if (!pos) return;
        contextMenuPos = pos;
        
        const cutObjInt = checkCutObjectInteraction(pos);
        const tracedObjInt = checkTracedObjectInteraction(pos);
        const pastedImgInt = checkPastedImageInteraction(pos);
        const textInt = checkTextInteraction(pos);
        
        if (cutObjInt.isOver) {
            selectedCutObjectId = cutObjInt.id;
            redrawAnnotations();
        } else if (tracedObjInt.isOver) {
            if (selectedTracedObjectId !== tracedObjInt.id) {
                selectedTracedObjectId = tracedObjInt.id;
                redrawAnnotations();
            }
            showContextMenu(tracedObjectContextMenu, e);
        } else if (pastedImgInt.isOver) {
            if (selectedPastedImageId !== pastedImgInt.id) {
                selectedPastedImageId = pastedImgInt.id;
                redrawAnnotations();
            }
            showContextMenu(pastedImageContextMenu, e);
        } else if (textInt.isOver) {
            if (selectedTextId !== textInt.id) {
                selectedTextId = textInt.id;
                updateControlsForSelectedText();
                redrawAnnotations();
            }
            showContextMenu(textContextMenu, e);
        } else if (selectedArea) {
            showContextMenu(selectionContextMenu, e);
        } else {
            showContextMenu(imageContextMenu, e);
        }
    });

    document.addEventListener('click', (e) => {
        if (!e.target.closest('.context-menu')) {
            selectionContextMenu.style.display = 'none';
            textContextMenu.style.display = 'none';
            imageContextMenu.style.display = 'none';
            tracedObjectContextMenu.style.display = 'none';
            pastedImageContextMenu.style.display = 'none';
        }
    });

    function showContextMenu(menu, e) {
        selectionContextMenu.style.display = 'none';
        textContextMenu.style.display = 'none';
        imageContextMenu.style.display = 'none';
        tracedObjectContextMenu.style.display = 'none';
        pastedImageContextMenu.style.display = 'none';
        
        let x = e.pageX + 5;
        let y = e.pageY + 5;
        
        menu.style.display = 'block';
        const menuRect = menu.getBoundingClientRect();
        if (x + menuRect.width > window.innerWidth) x = window.innerWidth - menuRect.width - 10;
        if (y + menuRect.height > window.innerHeight) y = window.innerHeight - menuRect.height - 10;
        
        menu.style.left = `${x}px`;
        menu.style.top = `${y}px`;
    }

    // ==================== KEYBOARD EVENTS ====================
    document.addEventListener('keydown', (e) => {
        // Модальное окно текста
        if (textModal.style.display === 'flex') {
            if (e.key === 'Enter') document.getElementById('modalOkBtn').click();
            if (e.key === 'Escape') document.getElementById('modalCancelBtn').click();
            return;
        }
        
        // Панорамирование пробелом
        if (e.code === 'Space' && !isPanning && !isDraggingPan) {
            e.preventDefault();
            isPanning = true;
            imageContainer.style.cursor = 'grab';
        }
        
        // Ctrl комбинации
        if (e.ctrlKey || e.metaKey) {
            if (e.key.toLowerCase() === 'z') {
                e.preventDefault();
                undoLastAction();
                return;
            }
            if (e.key.toLowerCase() === 'y') {
                e.preventDefault();
                redoLastAction();
                return;
            }
            if (e.key.toLowerCase() === 'c' && selectedArea) {
                e.preventDefault();
                copySelection();
                return;
            }
            if (e.key.toLowerCase() === 's') {
                e.preventDefault();
                saveAsPNG();
                return;
            }
            return;
        }
        
        // Escape
        if (e.key === 'Escape') {
            if (isDrawingArrow || isDrawingLine || isErasing || isTracing) {
                isDrawingArrow = isDrawingLine = isErasing = isTracing = false;
                currentEraserPath = [];
                currentTracePath = [];
                redrawAnnotations();
            } else if (activeMode) {
                setActiveMode(null);
            } else if (selectedTextId || selectedPastedImageId || selectedTracedObjectId || selectedCutObjectId) {
                selectedTextId = null;
                selectedPastedImageId = null;
                selectedTracedObjectId = null;
                selectedCutObjectId = null;
                redrawAnnotations();
            } else if (selectedArea) {
                selectedArea = null;
                selection.style.display = 'none';
                selectionInfo.style.display = 'none';
            } else {
                revertToOriginal();
            }
            return;
        }
        
        // Delete/Backspace
        if (e.key === 'Delete' || e.key === 'Backspace') {
            if (selectedTextId) { deleteSelectedText(); return; }
            if (selectedPastedImageId) { deletePastedImage(); return; }
            if (selectedTracedObjectId) { deleteTracedObject(); return; }
            if (selectedCutObjectId) {
                cutObjects = cutObjects.filter(c => c.id !== selectedCutObjectId);
                selectedCutObjectId = null;
                saveStateToHistory();
                redrawAnnotations();
                return;
            }
        }
        
        // Не обрабатываем горячие клавиши в полях ввода
        if (/INPUT|SELECT|TEXTAREA/.test(document.activeElement.tagName)) return;
        
        // Горячие клавиши инструментов
        switch (e.key.toLowerCase()) {
            case 'o': fileInput.click(); break;
            case 'f': toggleFullscreen(); break;
            case '0': resetZoom(); break;
            case '+': case '=': zoomIn(); break;
            case '-': zoomOut(); break;
            case 'a': setActiveMode('arrow'); break;
            case 'l': setActiveMode('line'); break;
            case 'm': setActiveMode('placemark'); break;
            case 't': setActiveMode('text'); break;
            case 'e': setActiveMode('eraser'); break;
            case 'v': setActiveMode('trace'); break;
        }
    });

    document.addEventListener('keyup', (e) => {
        if (e.code === 'Space') {
            e.preventDefault();
            isPanning = false;
            if (!isDraggingPan) {
                imageContainer.style.cursor = 'default';
            }
        }
    });

    // ==================== CONTROL INPUTS ====================
    Object.values(controls).forEach(control => {
        control.addEventListener('input', () => {
            if (selectedTextId) {
                const text = texts.find(t => t.id === selectedTextId);
                if (text) {
                    text.size = parseInt(controls.fontSize.value);
                    text.family = controls.fontFamily.value;
                    text.rotation = parseInt(controls.rotation.value);
                    saveStateToHistory();
                }
                redrawAnnotations();
            }
            saveSettings();
        });
    });

    // ==================== MODAL CHECKBOXES ====================
    textShadowCheckbox.addEventListener('change', () => {
        shadowOptionsContainer.style.display = textShadowCheckbox.checked ? 'flex' : 'none';
        saveSettings();
    });
    document.querySelectorAll('input[name="shadowColor"]').forEach(radio => radio.addEventListener('change', saveSettings));
    
    textStrokeCheckbox.addEventListener('change', () => {
        strokeOptionsContainer.style.display = textStrokeCheckbox.checked ? 'flex' : 'none';
        saveSettings();
    });
    document.querySelectorAll('input[name="strokeColor"]').forEach(radio => radio.addEventListener('change', saveSettings));
    
    textBackgroundCheckbox.addEventListener('change', () => {
        backgroundOptionsContainer.style.display = textBackgroundCheckbox.checked ? 'flex' : 'none';
        saveSettings();
    });
    document.querySelectorAll('input[name="backgroundType"]').forEach(radio => radio.addEventListener('change', saveSettings));
    
    textBackgroundColorPicker.addEventListener('input', saveSettings);
    
    textBlurAmountSlider.addEventListener('input', (e) => {
        textBlurAmountInput.value = e.target.value;
        saveSettings();
    });
    textBlurAmountInput.addEventListener('input', (e) => {
        textBlurAmountSlider.value = e.target.value;
        saveSettings();
    });

    // ==================== STYLE BUTTONS ====================
    textBoldBtn.addEventListener('click', () => textBoldBtn.classList.toggle('active'));
    textItalicBtn.addEventListener('click', () => textItalicBtn.classList.toggle('active'));
    textUnderlineBtn.addEventListener('click', () => textUnderlineBtn.classList.toggle('active'));
    textStrikethroughBtn.addEventListener('click', () => textStrikethroughBtn.classList.toggle('active'));

    // ==================== COLOR SYNC ====================
    controls.color.addEventListener('input', () => {
        textColorPicker.value = controls.color.value;
        saveSettings();
    });
    textColorPicker.addEventListener('input', () => {
        controls.color.value = textColorPicker.value;
        saveSettings();
    });

    // ==================== WINDOW RESIZE ====================
    window.addEventListener('resize', () => {
        if (imagePreview.src) {
            updateImageSize();
        }
    });

    // ==================== PREVENT DEFAULT DRAG ====================
    document.body.addEventListener('dragover', (e) => e.preventDefault());
    document.body.addEventListener('drop', (e) => e.preventDefault());

    // ==================== INITIALIZATION ====================
    window.addEventListener('load', async () => {
        loadSettings();
        resetAnnotationsAndState();
        updateUndoRedoButtons();
        updateHistoryInfo();

        // Попытка вставить из буфера при загрузке
        if (!navigator.clipboard || !navigator.permissions) return;
        try {
            const permission = await navigator.permissions.query({ name: 'clipboard-read' });
            if (permission.state === 'granted' || permission.state === 'prompt') {
                const items = await navigator.clipboard.read();
                for (const item of items) {
                    const imageType = item.types.find(type => type.startsWith('image/'));
                    if (imageType) {
                        const blob = await item.getType(imageType);
                        loadImage(new File([blob], "pasted_on_load.png", { type: blob.type }));
                        break;
                    }
                }
            }
        } catch (err) {
            console.log('Clipboard read on load failed:', err.name);
        }
    });

</script>
</body>
</html>