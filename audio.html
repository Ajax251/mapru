<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="theme-color" content="#4e7df9">
    <meta name="apple-mobile-web-app-title" content="Аудиоплеер">
    <title>Аудиоплеер</title>
    <link rel="stylesheet" href="webfonts/all.min.css">
        <link rel="icon" id="favicon" href="https://i.ibb.co/xKFzSX6c/musical-notes.png" type="image/png">
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>

    <style>
        /* CSS styles remain the same - no changes needed here */
        :root {
            --primary-color: #4e7df9;
            --primary-light: rgba(78, 125, 249, 0.1);
            --primary-medium: rgba(78, 125, 249, 0.3);
            --primary-dark: #3d63c9;
            --text-color: #333;
            --text-secondary: #888;
            --background-color: #f8f9fa;
            --card-background: #ffffff;
            --progress-bg: #e7e7e7;
            --control-hover: rgba(78, 125, 249, 0.1);
            --track-number-bg: #f1f3f4;
            --playlist-hover: rgba(78, 125, 249, 0.05);
            --playlist-active: rgba(78, 125, 249, 0.1);
            --playlist-border: #eee;
            --scrollbar-track: #f1f3f4;
            --scrollbar-thumb: #c1c9d2;
            --scrollbar-thumb-hover: #a8b2bf;
            --shadow-color: rgba(0, 0, 0, 0.1);
            --shadow-color-hover: rgba(0, 0, 0, 0.15);
            --tooltip-bg: rgba(0, 0, 0, 0.7);
            --modal-overlay: rgba(0, 0, 0, 0.5);
            --button-text: #fff;
            --input-border: #ddd;
            --input-focus: #4e7df9;
        }

        [data-theme="dark"] {
            --primary-color: #5d8aff;
            --primary-light: rgba(93, 138, 255, 0.15);
            --primary-medium: rgba(93, 138, 255, 0.3);
            --primary-dark: #4d74d9;
            --text-color: #e4e6eb;
            --text-secondary: #b0b3b8;
            --background-color: #18191a;
            --card-background: #242526;
            --progress-bg: #3a3b3c;
            --control-hover: rgba(93, 138, 255, 0.15);
            --track-number-bg: #3a3b3c;
            --playlist-hover: rgba(93, 138, 255, 0.1);
            --playlist-active: rgba(93, 138, 255, 0.2);
            --playlist-border: #3a3b3c;
            --scrollbar-track: #3a3b3c;
            --scrollbar-thumb: #5a5b5c;
            --scrollbar-thumb-hover: #6a6b6c;
            --shadow-color: rgba(0, 0, 0, 0.3);
            --shadow-color-hover: rgba(0, 0, 0, 0.4);
            --tooltip-bg: rgba(0, 0, 0, 0.85);
            --modal-overlay: rgba(0, 0, 0, 0.7);
            --button-text: #fff;
            --input-border: #444;
            --input-focus: #5d8aff;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen-Sans, Ubuntu, Cantarell, 'Helvetica Neue', sans-serif;
            -webkit-tap-highlight-color: transparent;
        }

        html, body {
            height: 100%;
            overscroll-behavior: none;
            --vh: 1vh;
        }

        body {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: calc(var(--vh, 1vh) * 100);
            background-color: var(--background-color);
            color: var(--text-color);
            transition: background-color 0.3s, color 0.3s;
            padding: 15px;
        }

        .player-container {
            width: 100%;
            max-width: 500px;
            background: var(--card-background);
            border-radius: 16px;
            box-shadow: 0 10px 30px var(--shadow-color);
            padding: 25px;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .player-container:hover {
            transform: translateY(-5px);
            box-shadow: 0 15px 35px var(--shadow-color-hover);
        }

         .theme-toggle-area {
            position: absolute;
            top: 0;
            right: 0;
            width: 60px;
            height: 60px;
            z-index: 4;
        }

        .theme-toggle {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            background: none;
            border: none;
            color: var(--text-color);
            font-size: 20px;
            cursor: pointer;
            transition: all 0.3s;
            z-index: 5;
            opacity: 0;
            pointer-events: none;
        }

         .theme-toggle-area:hover .theme-toggle,
        .theme-toggle:not(.hidden) {
             opacity: 1;
            pointer-events: auto;
        }

        .theme-toggle.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .theme-toggle:hover {
            background: var(--control-hover);
            color: var(--primary-color);
        }

         .theme-toggle .fa-sun {
            color: #4e7df9;
            opacity: 0.9;
        }
        .theme-toggle .fa-moon {
             color: #5d8aff;
        }

        .song-info {
            text-align: center;
            margin-bottom: 20px;
        }

        .song-title {
            font-size: 22px;
            color: var(--text-color);
            margin-bottom: 5px;
            font-weight: 600;
        }

        .artist {
            font-size: 16px;
            color: var(--text-secondary);
        }

        .album-cover {
            width: 200px;
            height: 200px;
            margin: 0 auto 20px;
            border-radius: 10px;
            overflow: hidden;
            box-shadow: 0 5px 15px var(--shadow-color);
            background-color: var(--track-number-bg);
            display: flex;
            justify-content: center;
            align-items: center;
            transition: all 0.3s ease;
            user-select: none;
            touch-action: pan-y;
            cursor: pointer;
        }

        .album-cover img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .progress-container {
            height: 6px;
            background: var(--progress-bg);
            border-radius: 3px;
            margin: 20px 0;
            cursor: pointer;
            position: relative;
            overflow: hidden;
        }

        .progress-container:hover::before {
            content: '';
            position: absolute;
            top: -2px;
            left: 0;
            right: 0;
            bottom: -2px;
            background: var(--primary-light);
            border-radius: 5px;
        }

        .progress {
            height: 100%;
            background: var(--primary-color);
            border-radius: 3px;
            width: 0%;
            transition: width 0.1s linear;
            position: relative;
        }

        .progress::after {
            content: '';
            position: absolute;
            right: 0;
            top: 50%;
            transform: translateY(-50%);
            width: 0;
            height: 0;
            border-radius: 50%;
            background: var(--card-background);
            box-shadow: 0 0 5px var(--shadow-color);
            transition: all 0.2s ease;
            opacity: 0;
        }

        .progress-container:hover .progress::after {
            width: 12px;
            height: 12px;
            opacity: 1;
        }

        .time-info {
            display: flex;
            justify-content: space-between;
            font-size: 14px;
            color: var(--text-secondary);
            margin-bottom: 25px;
        }

        .controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
        }

        .controls button {
            background: none;
            border: none;
            cursor: pointer;
            outline: none;
            color: var(--text-color);
            transition: all 0.3s;
            position: relative;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 18px;
            margin: 5px;
            z-index: 10;
            touch-action: manipulation;
        }

        .controls button::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: var(--control-hover);
            border-radius: 50%;
            transform: scale(0);
            transition: transform 0.3s;
        }

        .controls button:hover::before {
            transform: scale(1);
        }

        .controls button:active {
            transform: scale(0.95);
        }

        .controls button:hover {
            color: var(--primary-color);
        }

        .play-pause {
            background: var(--primary-color) !important;
            color: #fff !important;
            width: 60px !important;
            height: 60px !important;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            box-shadow: 0 5px 15px var(--primary-medium);
            font-size: 24px !important;
            transition: all 0.3s !important;
            position: relative;
            overflow: hidden;
        }

        .play-pause::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: radial-gradient(circle, transparent 25%, rgba(255, 255, 255, 0.2) 26%, transparent 27%);
            background-size: 5px 5px;
            opacity: 0;
            transition: opacity 0.3s;
        }

        .play-pause:hover {
            transform: scale(1.05) !important;
            box-shadow: 0 8px 20px var(--primary-medium) !important;
        }

        .play-pause:hover::after {
            opacity: 0.5;
        }

        .play-pause:active {
            transform: scale(0.98) !important;
        }

        .play-pause i {
            position: relative;
            left: 2px;
            z-index: 2;
        }

        .prev-btn, .next-btn {
            font-size: 22px;
        }

        .playlist-btn, .shuffle-btn, .fullscreen-btn {
            font-size: 18px;
        }

        .shuffle-btn.active {
            color: var(--primary-color);
        }

        .volume-control {
            position: relative;
            display: flex;
            align-items: center;
        }

        .volume-slider-container {
            width: 0;
            overflow: hidden;
            transition: width 0.3s ease;
            height: 40px;
            display: flex;
            align-items: center;
            margin-left: 5px;
        }

        .volume-control:hover .volume-slider-container,
        .volume-slider-container.active {
            width: 80px;
        }

        .volume-slider {
            width: 80px;
            -webkit-appearance: none;
            background: var(--progress-bg);
            height: 4px;
            border-radius: 2px;
            outline: none;
        }

        .volume-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 12px;
            height: 12px;
            background: var(--primary-color);
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .volume-slider::-moz-range-thumb {
            width: 12px;
            height: 12px;
            background: var(--primary-color);
            border: none;
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .volume-slider::-webkit-slider-thumb:hover,
        .volume-slider::-moz-range-thumb:hover {
            transform: scale(1.2);
        }

        .notification {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%) translateY(-100px);
            background: var(--primary-color);
            color: white;
            padding: 12px 20px;
            border-radius: 8px;
            box-shadow: 0 4px 12px var(--shadow-color);
            transition: transform 0.3s ease;
            z-index: 1050;
            text-align: center;
            max-width: 90%;
        }

        .notification.show {
            transform: translateX(-50%) translateY(0);
        }

        .player-icon {
            font-size: 80px;
            color: var(--primary-color);
        }

        .tooltip {
            position: absolute;
            bottom: -35px;
            left: 50%;
            transform: translateX(-50%);
            background: var(--tooltip-bg);
            color: white;
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 12px;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s;
            white-space: nowrap;
            pointer-events: none;
        }

        .controls button:hover .tooltip {
            opacity: 1;
            visibility: visible;
            bottom: -30px;
        }

        @keyframes pulse {
            0% { transform: scale(1); box-shadow: 0 5px 15px var(--primary-medium); }
            50% { transform: scale(1.03); box-shadow: 0 8px 20px var(--primary-medium); }
            100% { transform: scale(1); box-shadow: 0 5px 15px var(--primary-medium); }
        }

        .playing {
            animation: pulse 2s infinite;
        }

        .playlist::-webkit-scrollbar,
        .modal-body::-webkit-scrollbar {
            width: 6px;
        }

        .playlist::-webkit-scrollbar-track,
        .modal-body::-webkit-scrollbar-track {
            background: var(--scrollbar-track);
            border-radius: 3px;
        }

        .playlist::-webkit-scrollbar-thumb,
        .modal-body::-webkit-scrollbar-thumb {
            background: var(--scrollbar-thumb);
            border-radius: 3px;
        }

        .playlist::-webkit-scrollbar-thumb:hover,
        .modal-body::-webkit-scrollbar-thumb:hover {
            background: var(--scrollbar-thumb-hover);
        }

        .touch-active {
            transform: scale(0.95);
            opacity: 0.8;
            transition: transform 0.1s, opacity 0.1s;
        }

        .modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: var(--modal-overlay);
            z-index: 1000;
            align-items: center;
            justify-content: center;
            padding: 15px;
        }

        .modal-overlay.show {
            display: flex;
        }

        .modal {
            background: var(--card-background);
            border-radius: 12px;
            box-shadow: 0 10px 30px var(--shadow-color);
            padding: 20px;
            width: 100%;
            max-width: 500px;
            position: relative;
            animation: modalFadeIn 0.3s forwards;
            display: flex;
            flex-direction: column;
        }

        @keyframes modalFadeIn {
            from { opacity: 0; transform: translateY(-20px); }
            to { opacity: 1; transform: translateY(0); }
        }

       .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 1px solid var(--playlist-border);
            flex-shrink: 0;
        }

        .modal-title {
            font-size: 22px;
            font-weight: 600;
            color: var(--primary-color);
        }

        .modal-close {
            width: 32px;
            height: 32px;
            background: none;
            border: none;
            font-size: 24px;
            cursor: pointer;
            color: var(--text-secondary);
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            transition: all 0.3s;
        }

        .modal-close:hover {
            background: var(--primary-light);
            color: var(--primary-color);
        }
        .modal-body {
            margin-bottom: 20px;
            max-height: 60vh;
            overflow-y: auto;
            flex-grow: 1; /* Allow body to expand */
        }

        .form-group {
            margin-bottom: 15px;
        }

        .form-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: 500;
            color: var(--text-color);
        }

        .form-control {
            width: 100%;
            padding: 10px 15px;
            border: 1px solid var(--input-border);
            border-radius: 6px;
            background: var(--card-background);
            color: var(--text-color);
            transition: border-color 0.3s, box-shadow 0.3s;
            font-size: 14px;
            resize: vertical;
        }

        .form-control:focus {
            outline: none;
            border-color: var(--input-focus);
            box-shadow: 0 0 0 3px var(--primary-light);
        }

        .form-text {
            font-size: 12px;
            color: var(--text-secondary);
            margin-top: 5px;
        }

        .modal-footer {
            display: flex;
            justify-content: flex-end;
            border-top: 1px solid var(--playlist-border);
            padding-top: 15px;
            flex-shrink: 0;
        }

        .btn {
            padding: 8px 16px;
            border-radius: 6px;
            border: none;
            cursor: pointer;
            font-weight: 500;
            transition: all 0.3s;
        }

        .btn-primary {
            background: var(--primary-color);
            color: var(--button-text);
        }

        .btn-primary:hover {
            background: var(--primary-dark);
        }

        .btn-secondary {
            background: var(--progress-bg);
            color: var(--text-color);
            margin-right: 10px;
        }

        .btn-secondary:hover {
            background: var(--scrollbar-thumb);
        }

        .playlist-modal {
            max-width: 600px;
            max-height: 80vh;
            width: 100%;
        }

        .playlist-modal .modal-body {
            flex: 1;
            overflow-y: auto;
            position: relative;
        }

       .playlist-controls {
            display: flex;
            justify-content: space-around;
            gap: 15px;
            padding: 15px;
            background: var(--primary-light);
            border-radius: 8px;
            margin-bottom: 15px;
            flex-wrap: wrap;
            flex-shrink: 0;
        }

        .playlist-control-btn {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            border: none;
            background: var(--card-background);
            color: var(--primary-color);
            cursor: pointer;
            font-size: 18px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s;
            box-shadow: 0 2px 5px var(--shadow-color);
            flex-shrink: 0;
        }

        .playlist-control-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px var(--shadow-color);
        }

        .playlist-item {
            padding: 12px 18px;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
            margin-bottom: 8px;
            position: relative;
            overflow: hidden;
            display: flex;
            align-items: center;
            background: var(--card-background);
            box-shadow: 0 1px 3px var(--shadow-color);
        }
        .playlist-item:hover {
            color: var(--primary-color);
            background: var(--playlist-hover);
        }

        .playlist-item.active {
            color: var(--primary-color);
            font-weight: 500;
            background: var(--playlist-active);
            padding-left: 20px;
        }

        .playlist-item.active::before {
            content: '';
            position: absolute;
            left: 0;
            top: 0;
            height: 100%;
            width: 4px;
            background: var(--primary-color);
            border-radius: 0 2px 2px 0;
        }

        .track-number {
            min-width: 24px;
            height: 24px;
            background: var(--track-number-bg);
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 12px;
            color: var(--text-color);
            margin-right: 12px;
            transition: all 0.2s;
        }

        .playlist-item:hover .track-number,
        .playlist-item.active .track-number {
            background: var(--primary-color);
            color: white;
        }

        .track-info {
            flex: 1;
            overflow: hidden;
        }

        .track-title {
            font-weight: 500;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            color: var(--text-color);
        }

        .track-artist {
            font-size: 12px;
            color: var(--text-secondary);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .playlist-item.active .track-title {
            color: var(--primary-color);
        }

        .track-delete {
            width: 32px;
            height: 32px;
            padding: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            background: none;
            border: none;
            color: var(--text-secondary);
            cursor: pointer;
            border-radius: 50%;
            opacity: 0;
            transform: scale(0.8);
            transition: all 0.2s ease;
            margin-left: 10px;
            flex-shrink: 0;
        }

        .playlist-item:hover .track-delete {
            opacity: 0.8;
            transform: scale(1);
        }

        .track-delete:hover {
            background: var(--playlist-hover);
            color: #ff5252;
            opacity: 1;
        }

        .default-cover {
            width: 100%;
            height: 100%;
            object-fit: cover;
            border-radius: 10px;
        }

        .equalizer {
            width: 200px;
            height: 200px;
            margin: 0 auto 20px;
            border-radius: 10px;
            overflow: hidden;
            box-shadow: 0 5px 15px var(--shadow-color);
            background-color: var(--primary-light);
            display: none;
            align-items: flex-end;
            justify-content: space-around;
            padding: 20px 10px 10px;
            transition: all 0.3s ease;
        }

        .equalizer.active {
            display: flex;
        }

        .equalizer .bar {
            width: 8px;
            background: var(--primary-color);
            border-radius: 4px 4px 0 0;
            animation: equalize 1.2s ease-in-out infinite;
        }

        .equalizer .bar:nth-child(1) { animation-delay: -1.2s; height: 30%; }
        .equalizer .bar:nth-child(2) { animation-delay: -0.9s; height: 60%; }
        .equalizer .bar:nth-child(3) { animation-delay: -0.6s; height: 40%; }
        .equalizer .bar:nth-child(4) { animation-delay: -0.3s; height: 80%; }
        .equalizer .bar:nth-child(5) { animation-delay: -1.0s; height: 50%; }
        .equalizer .bar:nth-child(6) { animation-delay: -0.7s; height: 70%; }
        .equalizer .bar:nth-child(7) { animation-delay: -0.4s; height: 35%; }
        .equalizer .bar:nth-child(8) { animation-delay: -0.1s; height: 55%; }

        @keyframes equalize {
            0% { height: 30%; } 50% { height: 70%; } 100% { height: 30%; }
        }

        .loading-indicator {
            display: none;
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            z-index: 1050;
            align-items: center; justify-content: center; flex-direction: column;
            color: white;
        }
         .loading-indicator.local {
            position: absolute; background: rgba(0, 0, 0, 0.3);
        }

        .loading-indicator.show { display: flex; }

        .loading-spinner {
            width: 50px; height: 50px;
            border: 5px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%; border-top-color: var(--primary-color);
            animation: spin 1s ease-in-out infinite;
            margin-bottom: 15px;
        }

        @keyframes spin { to { transform: rotate(360deg); } }

        .loading-text { font-size: 16px; }

        .welcome-tips {
            position: fixed; bottom: 20px; left: 50%;
            transform: translateX(-50%); background: var(--primary-color); color: white;
            padding: 12px 20px; border-radius: 8px; box-shadow: 0 4px 12px var(--shadow-color);
            max-width: 90%; text-align: center; z-index: 100;
            opacity: 0; visibility: hidden; transition: opacity 0.5s, visibility 0.5s;
        }
        .welcome-tips.show { opacity: 1; visibility: visible; }
        .welcome-tips .close-btn {
            position: absolute; top: 5px; right: 5px;
            background: none; border: none; color: white;
            padding: 5px; cursor: pointer; font-size: 12px;
        }

        .empty-playlist { text-align: center; padding: 20px; color: var(--text-secondary); font-style: italic; }

        .playlist-type-indicator {
            display: inline-block; padding: 3px 8px; border-radius: 12px;
            font-size: 11px; margin-left: 5px; background: var(--primary-light);
            color: var(--primary-color); vertical-align: middle;
        }

        /* Styles for Supabase File Selector Modal */
        #supabaseFileList { display: flex; flex-direction: column; gap: 5px; }
        .supabase-file-item {
            display: flex; align-items: center; padding: 6px 10px;
            border-radius: 4px; transition: background-color 0.2s;
            cursor: pointer;
        }
        .supabase-file-item:hover { background-color: var(--playlist-hover); }
        .supabase-file-item input[type="checkbox"] { margin-right: 10px; cursor: pointer; }
        .supabase-file-item label {
            font-size: 13px; /* Smaller font */
            color: var(--text-color);
            white-space: nowrap; overflow: hidden; text-overflow: ellipsis;
            flex-grow: 1; cursor: pointer;
        }

        /* Media queries remain the same */
        @media (max-width: 520px) {
            .player-container { padding: 15px; border-radius: 12px; }
            .album-cover, .equalizer { width: 150px; height: 150px; }
            .song-info { margin-bottom: 15px; }
            .song-title { font-size: 18px; }
            .artist { font-size: 14px; }
            .play-pause { width: 50px !important; height: 50px !important; font-size: 20px !important; }
            .controls button { width: 35px; height: 35px; margin: 3px; font-size: 16px; }
            .tooltip { display: none; }
            .playlist-controls { padding: 10px; gap: 10px; justify-content: center; }
            .playlist-control-btn { width: 45px; height: 45px; font-size: 16px; }
            .modal-body { max-height: 55vh; }
        }
        @media (max-width: 380px) {
            .album-cover, .equalizer { width: 120px; height: 120px; }
            .player-container { padding: 12px; }
            .song-title { font-size: 16px; }
            .controls button { width: 30px; height: 30px; font-size: 14px; margin: 2px; }
            .play-pause { width: 40px !important; height: 40px !important; font-size: 18px !important; }
            .track-title { font-size: 14px; }
            .track-artist { font-size: 11px; }
            .track-number { min-width: 20px; height: 20px; margin-right: 6px; font-size: 11px; }
             .time-info { font-size: 12px; margin-bottom: 10px; }
            .equalizer .bar { width: 6px; }
             .playlist-control-btn { width: 40px; height: 40px; font-size: 14px; }
             .modal-title { font-size: 18px; }
             .modal-close { width: 28px; height: 28px; font-size: 20px; }
             .supabase-file-item label { font-size: 12px; }
        }
        @media (max-height: 500px) and (orientation: landscape) {
            body { padding: 10px; align-items: flex-start; }
            .player-container { display: grid; grid-template-columns: 120px 1fr; grid-template-rows: auto auto auto; grid-gap: 10px; align-items: center; padding: 10px; max-width: 95vw; max-height: 95vh; overflow: hidden; }
            .album-cover, .equalizer { width: 100px; height: 100px; margin: 0; grid-row: 1 / 3; grid-column: 1 / 2; }
             .theme-toggle-area { grid-row: 1 / 2; grid-column: 2 / 3; justify-self: end; align-self: start; height: 40px; width: 40px; top: 5px; right: 5px; }
             .theme-toggle { top: 5px; right: 5px; width: 30px; height: 30px; font-size: 16px; }
            .song-info { grid-row: 1 / 2; grid-column: 2 / 3; text-align: left; margin-bottom: 0; align-self: center; }
            .song-title { font-size: 16px; margin-bottom: 2px; }
            .artist { font-size: 12px; }
            .progress-container { grid-row: 2 / 3; grid-column: 2 / 3; margin: 5px 0; }
            .time-info { grid-row: 3 / 4; grid-column: 1 / 2; justify-content: center; margin-bottom: 0; font-size: 12px; }
            .controls { grid-row: 3 / 4; grid-column: 2 / 3; margin-top: 0; flex-wrap: nowrap; justify-content: flex-start; overflow-x: auto; padding-bottom: 5px; }
            .controls button { margin: 0 4px; width: 30px; height: 30px; font-size: 14px; flex-shrink: 0; }
            .play-pause { width: 40px !important; height: 40px !important; font-size: 18px !important; }
            .playlist-modal, #supabaseSelectModal { max-height: 90vh; }
             .modal-body { max-height: 70vh; }
        }
        @media (min-width: 768px) {
            .player-container { max-width: 600px; padding: 35px; }
            .song-info { margin-bottom: 30px; }
            .album-cover, .equalizer { width: 250px; height: 250px; margin-bottom: 30px; }
            .equalizer .bar { width: 12px; }
            .song-title { font-size: 28px; }
            .artist { font-size: 18px; }
            .progress-container { margin: 30px 0; }
            .time-info { font-size: 16px; margin-bottom: 35px; }
            .controls { justify-content: space-around; }
            .controls button { width: 50px; height: 50px; margin: 8px; font-size: 22px; }
            .play-pause { width: 70px !important; height: 70px !important; font-size: 28px !important; }
            .playlist-modal, #supabaseSelectModal { max-width: 700px; max-height: 75vh; }
             .modal-body { max-height: 60vh; }
            .playlist-item { padding: 12px 20px; }
            .track-number { min-width: 28px; height: 28px; margin-right: 15px; font-size: 14px; }
            .track-title { font-size: 16px; }
            .track-artist { font-size: 13px; }
             .playlist-controls { gap: 20px; justify-content: center; }
             .playlist-control-btn { width: 55px; height: 55px; font-size: 20px; }
             .supabase-file-item label { font-size: 14px; }
        }
    </style>
</head>
<body>
    <!-- HTML structure remains the same -->
    <div class="loading-indicator" id="loadingIndicator">
        <div class="loading-spinner"></div>
        <div class="loading-text">Загрузка...</div>
    </div>

    <div class="player-container">
         <div class="theme-toggle-area">
            <button class="theme-toggle" id="themeToggle">
                <i class="fas fa-moon"></i>
            </button>
         </div>

        <div class="song-info">
            <div class="album-cover" id="album-cover">
                <i class="fas fa-headphones-alt player-icon"></i>
            </div>
            <div class="equalizer" id="equalizer">
                <div class="bar"></div> <div class="bar"></div> <div class="bar"></div> <div class="bar"></div>
                <div class="bar"></div> <div class="bar"></div> <div class="bar"></div> <div class="bar"></div>
            </div>
            <h2 class="song-title">Добавьте аудиофайлы</h2>
            <p class="artist">Плейлист пуст</p>
        </div>

        <div class="progress-container" id="progress-container">
            <div class="progress" id="progress"></div>
        </div>

        <div class="time-info">
            <span id="current-time">0:00</span>
            <span id="duration">0:00</span>
        </div>

        <div class="controls">
            <div class="volume-control">
                <button class="volume-btn">
                    <i class="fas fa-volume-up"></i>
                    <span class="tooltip">Громкость</span>
                </button>
                <div class="volume-slider-container">
                    <input type="range" class="volume-slider" min="0" max="1" step="0.01" value="1">
                </div>
            </div>
            <button class="shuffle-btn" id="shuffle-btn">
                <i class="fas fa-random"></i>
                <span class="tooltip">Случайный порядок</span>
            </button>
            <button class="prev-btn">
                <i class="fas fa-step-backward"></i>
                <span class="tooltip">Предыдущий</span>
            </button>
            <button class="play-pause" id="play-pause">
                <i class="fas fa-play"></i>
            </button>
            <button class="next-btn">
                <i class="fas fa-step-forward"></i>
                <span class="tooltip">Следующий</span>
            </button>
             <button class="fullscreen-btn" id="fullscreen-btn">
                 <i class="fas fa-expand"></i>
                 <span class="tooltip">Полный экран</span>
             </button>
            <button class="playlist-btn" id="playlist-btn">
                <i class="fas fa-list"></i>
                <span class="tooltip">Плейлист</span>
            </button>
        </div>
    </div>

    <div class="notification" id="notification">
        Файлы добавлены в плейлист
    </div>

    <div class="welcome-tips" id="welcomeTips">
        Нажмите <i class="fas fa-list"></i> (плейлист) или <i class="fas fa-headphones-alt"></i> (обложку) дважды, чтобы добавить треки. Нажмите F9 в плейлисте для загрузки из облака.
        <button class="close-btn" id="closeTips"><i class="fas fa-times"></i></button>
    </div>

    <div class="modal-overlay" id="playlistModal">
        <div class="modal playlist-modal">
            <div class="modal-header">
                <h3 class="modal-title">Плейлист</h3>
                <button class="modal-close" id="closePlaylistModal">×</button>
            </div>

            <div class="playlist-controls">
                <label for="fileInput" class="playlist-control-btn" title="Загрузить файлы">
                    <i class="fas fa-upload"></i>
                    <input type="file" id="fileInput" accept="audio/*" multiple style="display:none">
                </label>
                <button class="playlist-control-btn" id="urlBtnInPlaylist" title="Добавить URL">
                    <i class="fas fa-link"></i>
                </button>
                <button class="playlist-control-btn" id="savePlaylistBtn" title="Сохранить плейлист (JSON)">
                    <i class="fas fa-save"></i>
                </button>
                <button class="playlist-control-btn" id="loadPlaylistBtn" title="Загрузить плейлист (JSON)">
                    <i class="fas fa-file-import"></i>
                </button>
                 <button class="playlist-control-btn" id="loadSupabaseBtn" title="Выбрать из облака (F9)">
                    <i class="fas fa-cloud-download-alt"></i>
                </button>
            </div>

            <div class="modal-body" id="playlistModalBody">
                 <div class="loading-indicator local" id="playlistLoadingIndicator">
                     <div class="loading-spinner"></div>
                 </div>
                <div class="playlist" id="playlist">
                     <!-- Playlist items will be rendered here -->
                </div>
            </div>
        </div>
    </div>

    <div class="modal-overlay" id="urlModal">
        <div class="modal">
            <div class="modal-header">
                <h3 class="modal-title">Добавить аудио по URL</h3>
                <button class="modal-close" id="closeUrlModal">×</button>
            </div>
            <div class="modal-body">
                <div class="form-group">
                    <textarea id="bulkUrls" class="form-control" rows="8" placeholder="https://example.com/audio1.mp3
https://example.com/audio2.mp3"></textarea>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn btn-secondary" id="cancelUrl">Отмена</button>
                <button class="btn btn-primary" id="addUrl">Добавить</button>
            </div>
        </div>
    </div>

        <div class="modal-overlay" id="supabaseSelectModal">
         <div class="modal">
             <div class="modal-header">
                 <h3 class="modal-title">Выбор файлов</h3>
                 <button class="modal-close" id="closeSupabaseSelectModal">×</button>
             </div>
             <div class="modal-body" id="supabaseSelectModalBody">
                  <div class="loading-indicator local" id="supabaseLoadingIndicator">
                     <div class="loading-spinner"></div>
                     <div class="loading-text">Загрузка списка...</div>
                 </div>

                 <!-- NEW: Select All Button -->
                 <div style="margin-bottom: 10px; text-align: right;">
                     <button class="btn btn-secondary btn-sm" id="selectAllSupabaseBtn" style="padding: 4px 10px; font-size: 12px;">Выбрать все</button>
                 </div>
                 <!-- End Select All Button -->

                 <div id="supabaseFileList">
                      <!-- Supabase file list items will be rendered here -->
                 </div>
             </div>
             <div class="modal-footer">
                 <button class="btn btn-secondary" id="cancelSupabaseSelect">Отмена</button>
                 <button class="btn btn-primary" id="addSelectedSupabase">Добавить выбранные</button>
             </div>
         </div>
     </div>


    <script>
    document.addEventListener('DOMContentLoaded', () => {
        // Element References
        const playPauseBtn = document.getElementById('play-pause');
        const playPauseIcon = playPauseBtn.querySelector('i');
        const audio = new Audio();
        const progressContainer = document.getElementById('progress-container');
        const progress = document.getElementById('progress');
        const currentTimeEl = document.getElementById('current-time');
        const durationEl = document.getElementById('duration');
        const playlistBtn = document.getElementById('playlist-btn');
        const playlist = document.getElementById('playlist');
        const fileInput = document.querySelector('label[for="fileInput"] input[type="file"]');
        const songTitle = document.querySelector('.song-title');
        const artist = document.querySelector('.artist');
        const notification = document.getElementById('notification');
        const albumCover = document.getElementById('album-cover');
        const equalizer = document.getElementById('equalizer');
        const shuffleBtn = document.getElementById('shuffle-btn');
        const themeToggle = document.getElementById('themeToggle');
        const themeIcon = themeToggle.querySelector('i');
        const playerContainer = document.querySelector('.player-container');
        const welcomeTips = document.getElementById('welcomeTips');
        const closeTips = document.getElementById('closeTips');
        const loadingIndicator = document.getElementById('loadingIndicator');
        const playlistLoadingIndicator = document.getElementById('playlistLoadingIndicator');
        const volumeBtn = document.querySelector('.volume-btn');
        const volumeSliderContainer = document.querySelector('.volume-slider-container');
        const volumeSlider = document.querySelector('.volume-slider');
        const playlistModal = document.getElementById('playlistModal');
        const closePlaylistModal = document.getElementById('closePlaylistModal');
        const urlBtnInPlaylist = document.getElementById('urlBtnInPlaylist');
        const savePlaylistBtn = document.getElementById('savePlaylistBtn');
        const loadPlaylistBtn = document.getElementById('loadPlaylistBtn');
        const loadSupabaseBtn = document.getElementById('loadSupabaseBtn');
        const urlModal = document.getElementById('urlModal');
        const closeUrlModal = document.getElementById('closeUrlModal');
        const cancelUrl = document.getElementById('cancelUrl');
        const addUrl = document.getElementById('addUrl');
        const bulkUrls = document.getElementById('bulkUrls');
        const fullscreenBtn = document.getElementById('fullscreen-btn');
        const supabaseSelectModal = document.getElementById('supabaseSelectModal');
        const closeSupabaseSelectModal = document.getElementById('closeSupabaseSelectModal');
        const supabaseFileList = document.getElementById('supabaseFileList');
        const supabaseLoadingIndicator = document.getElementById('supabaseLoadingIndicator');
        const addSelectedSupabase = document.getElementById('addSelectedSupabase');
        const cancelSupabaseSelect = document.getElementById('cancelSupabaseSelect');
        const faviconLink = document.getElementById('favicon'); // Reference for Favicon

        // Supabase Config
        const SUPABASE_URL = 'https://yabhafljpgxexeehnufk.supabase.co';
        const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InlhYmhhZmxqcGd4ZXhlZWhudWZrIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDU1MTg1MjEsImV4cCI6MjA2MTA5NDUyMX0.f5ESSDiU28ErCNGpkN9Sx3svV-Ll08UZOhb5kF-_BTo';
        const { createClient } = supabase;
        const supabaseClient = createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
        
            const selectAllSupabaseBtn = document.getElementById('selectAllSupabaseBtn'); 

        // State Variables
        let isResetting = false;
        let isPlaying = false;
        let songs = [];
        let currentSongIndex = 0;
        let isShuffleMode = false;
        let playHistory = [];
        let shuffleQueue = [];
        let touchstartX = 0;
        let touchendX = 0;
        let touchstartY = 0;
        let touchendY = 0;
        let isMuted = false;
        let previousVolume = 1;
        let wakeLock = null;
        let lastClickTime = 0;
        let themeHideTimeout = null;
        audio._skipErrorCount = 0; // Custom property for error tracking

        // Favicon Blinking Variables
        let originalFaviconUrl = faviconLink ? faviconLink.href : ''; // Store original URL
        const transparentFaviconUrl = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mNkYAAAAAYAAjCB0C8AAAAASUVORK5CYII='; // 1x1 transparent pixel
        let blinkingIntervalId = null;
        let isFaviconBlinking = false;
        let faviconStateIsOriginal = true;


        // --- Initialization ---
        initTheme();
        showWelcomeTipsIfFirstVisit();
        initVolume();
        setupBackgroundPlayback();
        setupSwipeHandling();
        setupFullscreen();
        loadSettings();
        loadSavedPlaylist(); // Loads playlist from localStorage (including Supabase)
        fixHeight();
        setupThemeToggleVisibility();


        // --- Core Functions ---

        function setupThemeToggleVisibility() {
            const themeToggleArea = document.querySelector('.theme-toggle-area');
            const showToggle = () => {
                 clearTimeout(themeHideTimeout);
                 themeToggle.classList.remove('hidden');
                 themeHideTimeout = setTimeout(() => {
                     if (!themeToggleArea.matches(':hover')) {
                         themeToggle.classList.add('hidden');
                     }
                 }, 3000);
            };
             showToggle();
             themeToggleArea.addEventListener('mouseenter', showToggle);
             themeToggleArea.addEventListener('mouseleave', () => {
                 clearTimeout(themeHideTimeout);
                 themeHideTimeout = setTimeout(() => { themeToggle.classList.add('hidden'); }, 500);
             });
             themeToggle.addEventListener('mouseenter', () => clearTimeout(themeHideTimeout));
             themeToggle.addEventListener('mouseleave', () => {
                  clearTimeout(themeHideTimeout);
                  themeHideTimeout = setTimeout(() => { themeToggle.classList.add('hidden'); }, 500);
             });
        }

        function setupBackgroundPlayback() {
             if ('mediaSession' in navigator) {
                navigator.mediaSession.setActionHandler('play', () => playPause());
                navigator.mediaSession.setActionHandler('pause', () => playPause());
                navigator.mediaSession.setActionHandler('previoustrack', () => prevSong());
                navigator.mediaSession.setActionHandler('nexttrack', () => nextSong());
            }
            document.addEventListener('visibilitychange', handleVisibilityChange);
        }

        function handleVisibilityChange() {
             if (document.visibilityState === 'visible' && isPlaying) { requestWakeLock(); }
            else if (document.visibilityState !== 'visible' && wakeLock) { wakeLock.release().then(() => wakeLock = null); }
        }

        async function requestWakeLock() {
             if ('wakeLock' in navigator && !wakeLock) {
                try {
                    wakeLock = await navigator.wakeLock.request('screen');
                    wakeLock.addEventListener('release', () => wakeLock = null);
                    // console.log('Screen Wake Lock active.');
                } catch (err) { /* console.error(`${err.name}, ${err.message}`); */ }
            }
        }

        function initTheme() {
            const savedTheme = localStorage.getItem('theme');
            const prefersDarkScheme = window.matchMedia('(prefers-color-scheme: dark)').matches;
            const currentTheme = savedTheme || (prefersDarkScheme ? 'dark' : 'light');
            document.documentElement.setAttribute('data-theme', currentTheme); updateThemeIcon(currentTheme);
            window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', e => {
                if (!localStorage.getItem('theme')) { // Only follow system if no explicit choice saved
                    const newTheme = e.matches ? 'dark' : 'light';
                    document.documentElement.setAttribute('data-theme', newTheme); updateThemeIcon(newTheme);
                }
            });
        }

        function updateThemeIcon(theme) {
             themeIcon.className = `fas ${theme === 'dark' ? 'fa-moon' : 'fa-sun'}`;
        }

        function showWelcomeTipsIfFirstVisit() {
            const hasVisitedBefore = localStorage.getItem('hasVisitedBefore');
            if (!hasVisitedBefore) { setTimeout(() => welcomeTips.classList.add('show'), 2000); localStorage.setItem('hasVisitedBefore', 'true'); }
            closeTips.addEventListener('click', () => welcomeTips.classList.remove('show'));
        }

        function setupSwipeHandling() {
             albumCover.addEventListener('touchstart', e => { touchstartX = e.changedTouches[0].screenX; touchstartY = e.changedTouches[0].screenY; }, { passive: true });
            albumCover.addEventListener('touchend', e => { touchendX = e.changedTouches[0].screenX; touchendY = e.changedTouches[0].screenY; handleSwipe(); }, { passive: true });
        }

        function handleSwipe() {
            const xDiff = touchendX - touchstartX; const yDiff = touchendY - touchstartY;
            // Horizontal swipe with significant movement
            if (Math.abs(xDiff) > Math.abs(yDiff) && Math.abs(xDiff) > 50) {
                if (xDiff > 0) prevSong(); else nextSong();
            }
        }

        function setupFullscreen() {
            if (document.documentElement.requestFullscreen) {
                fullscreenBtn.style.display = 'flex'; // Show button if API exists
                fullscreenBtn.addEventListener('click', toggleFullScreen);
                document.addEventListener('fullscreenchange', updateFullscreenIcon);
            } else {
                fullscreenBtn.style.display = 'none'; // Hide button if API doesn't exist
            }
        }

         function toggleFullScreen() {
            if (!document.fullscreenElement) { document.documentElement.requestFullscreen().catch(err => {}); }
            else if (document.exitFullscreen) { document.exitFullscreen(); }
        }

         function updateFullscreenIcon() {
             const icon = fullscreenBtn.querySelector('i'); const tooltip = fullscreenBtn.querySelector('.tooltip');
             if (document.fullscreenElement) { icon.classList.replace('fa-expand','fa-compress'); tooltip.textContent = 'Выйти'; }
             else { icon.classList.replace('fa-compress','fa-expand'); tooltip.textContent = 'Полный экран'; }
         }

        function loadSettings() {
             isShuffleMode = localStorage.getItem('shuffleMode') === 'true';
             shuffleBtn.classList.toggle('active', isShuffleMode);
        }

        function saveSettings() {
             localStorage.setItem('shuffleMode', isShuffleMode);
        }

        function loadSavedPlaylist() {
            try {
                const savedPlaylist = localStorage.getItem('playlist');
                if (savedPlaylist) {
                    const parsedPlaylist = JSON.parse(savedPlaylist);
                    if (parsedPlaylist && Array.isArray(parsedPlaylist.songs)) {
                        // Filter for valid savable types
                        songs = parsedPlaylist.songs.filter(song => song && song.url && (song.type === 'url' || song.type === 'supabase'));
                        if (songs.length > 0) {
                            renderPlaylist(); // Render first
                            currentSongIndex = parseInt(localStorage.getItem('currentSongIndex') || '0');
                            if(currentSongIndex >= songs.length || currentSongIndex < 0) currentSongIndex = 0;
                            loadSong(songs[currentSongIndex]); // Load song data *after* state is set
                             // Defer position setting slightly
                            setTimeout(() => {
                               const savedPosition = loadTrackPosition(songs[currentSongIndex]?.url);
                               if (savedPosition && !isNaN(savedPosition) && isFinite(audio.duration) && savedPosition < audio.duration && audio.seekable.length > 0) {
                                   try { audio.currentTime = savedPosition; } catch (e) { console.warn("Error setting saved position:", e); }
                               }
                               // Update progress UI after potentially setting time
                               updateProgressDirect(audio.currentTime, audio.duration)
                            }, 100);
                            showNotification('Плейлист загружен из памяти');
                            updateActivePlaylistItem();
                        } else { resetPlayer(); } // Filtered list is empty
                    } else { resetPlayer(); } // Invalid format
                } else { resetPlayer(); } // No saved playlist
            } catch (e) {
                console.error("Error loading saved playlist:", e);
                localStorage.removeItem('playlist'); localStorage.removeItem('currentSongIndex');
                resetPlayer(); // Error during parsing
            }
        }

        function savePlaylist() {
            try {
                 // Only save URL and Supabase types
                 const savableSongs = songs.filter(song => song && (song.type === 'url' || song.type === 'supabase'));
                 // Avoid saving if only local files are present (these can't be restored)
                 if (savableSongs.length === 0 && songs.some(s => s.type === 'file')) {
                     // console.log("Skipping save: Only local files present.");
                     return;
                 }
                 const playlistToSave = { songs: savableSongs };
                 localStorage.setItem('playlist', JSON.stringify(playlistToSave));
                 // Only save index if there are savable songs
                 if (savableSongs.length > 0) {
                     localStorage.setItem('currentSongIndex', currentSongIndex.toString());
                 } else {
                     localStorage.removeItem('currentSongIndex'); // Clean up index if playlist is empty
                 }
            } catch (e) {
                showNotification('Ошибка сохранения плейлиста в LocalStorage');
                console.error("Error saving playlist:", e);
            }
        }

        function initVolume() {
             const savedVolumeString = localStorage.getItem('volume'); let volumeToSet = 1.0;
             if (savedVolumeString !== null) { let parsedVolume = parseFloat(savedVolumeString); if (!isNaN(parsedVolume)) { volumeToSet = Math.min(1, Math.max(0, parsedVolume)); } }
             audio.volume = volumeToSet; volumeSlider.value = volumeToSet; updateVolumeIcon(volumeToSet); setupVolumeControls();
         }

        function updateVolumeIcon(volume) {
            const volumeIcon = volumeBtn.querySelector('i');
            if (volume <= 0 || isMuted) volumeIcon.className = 'fas fa-volume-mute';
            else if (volume < 0.5) volumeIcon.className = 'fas fa-volume-down';
            else volumeIcon.className = 'fas fa-volume-up';
        }

        function setupVolumeControls() {
             volumeBtn.addEventListener('click', () => {
                 if (isMuted) { audio.volume = (previousVolume > 0) ? previousVolume : 1.0; isMuted = false; }
                 else { previousVolume = audio.volume; audio.volume = 0; isMuted = true; }
                 volumeSlider.value = audio.volume; updateVolumeIcon(audio.volume); localStorage.setItem('volume', audio.volume.toString());
                 // Toggle slider visibility on mobile when clicking the icon
                 if (window.innerWidth <= 520) volumeSliderContainer.classList.toggle('active');
             });
             volumeSlider.addEventListener('input', () => {
                 const volume = parseFloat(volumeSlider.value); audio.volume = volume; isMuted = (volume === 0);
                 if (!isMuted) previousVolume = volume; updateVolumeIcon(volume); localStorage.setItem('volume', volume.toString());
             });
             // Hide mobile slider if clicking outside
             document.addEventListener('click', (e) => {
                 if (window.innerWidth <= 520 && !volumeBtn.contains(e.target) && !volumeSliderContainer.contains(e.target) && volumeSliderContainer.classList.contains('active')) {
                     volumeSliderContainer.classList.remove('active');
                 }
             });
         }

        function resetPlayer() {
            // console.log("Resetting player state");
            if (isResetting) return; isResetting = true;

            stopFaviconBlink(); // Stop blinking if resetting

            pauseSong(); // Call pauseSong to handle UI/state correctly before clearing src
            audio.src = '';
            if (window._nextSongTimeout) { clearTimeout(window._nextSongTimeout); window._nextSongTimeout = null; }
            audio._skipErrorCount = 0;
            songs = [];
            currentSongIndex = 0;
            // isPlaying = false; // pauseSong sets this
            songTitle.textContent = 'Добавьте аудиофайлы'; artist.textContent = 'Плейлист пуст';
            albumCover.innerHTML = '<i class="fas fa-headphones-alt player-icon"></i>';
            // equalizer.classList.remove('active'); // pauseSong handles this
            // albumCover.style.display = 'flex'; // pauseSong handles this
            updateProgressDirect(0, 0);
            renderPlaylist(); // Render the empty state
            savePlaylist(); // Save the empty state
            localStorage.removeItem('currentSongIndex');
            // Keep trackPositions for potential future use
            document.title = 'Аудиоплеер';
            if ('mediaSession' in navigator) { try { navigator.mediaSession.metadata = null; navigator.mediaSession.playbackState = "none"; } catch(e) {} }
            setTimeout(() => { isResetting = false; }, 100); // Short delay
        }

        function loadSong(song) {
             // console.log(`Loading song: ${song?.title} at index ${currentSongIndex}`);
             if (isResetting) return;
             if (!song || !song.url) {
                 showNotification('Ошибка: Невозможно загрузить трек (нет URL)');
                 console.error("Attempted to load invalid song:", song);
                 if (songs.length > 1) {
                     const badIndex = songs.findIndex(s => !s || !s.url);
                     if (badIndex !== -1) { console.warn(`Removing invalid song entry at index ${badIndex}`); removeFromPlaylist(badIndex); }
                     else { console.warn("Could not find invalid song, trying next..."); setTimeout(nextSong, 100); }
                 } else { resetPlayer(); }
                 return;
             }
             loadingIndicator.classList.add('show');
             const songName = song.title || 'Неизвестный трек'; songTitle.textContent = songName; artist.textContent = song.artist || 'Неизвестный'; document.title = songName + ' - Аудиоплеер';
             albumCover.innerHTML = song.cover ? `<img src="${song.cover}" alt="Album Cover" class="default-cover" onerror="this.src='https://i.ibb.co/NWnWNpJ/tg.jpg';">` : '<img src="https://i.ibb.co/NWnWNpJ/tg.jpg" alt="Default Album Cover" class="default-cover">';
             updateActivePlaylistItem(); // Update highlight immediately

             if ('mediaSession' in navigator) {
                 try {
                     navigator.mediaSession.metadata = new MediaMetadata({ title: song.title || 'Неизвестный трек', artist: song.artist || 'Неизвестный', artwork: song.cover ? [{ src: song.cover, sizes: '512x512', type: 'image/jpeg' }] : [{ src: 'https://i.ibb.co/NWnWNpJ/tg.jpg', sizes: '512x512', type: 'image/jpeg' }] });
                     navigator.mediaSession.playbackState = isPlaying ? "playing" : "paused";
                 } catch(e) { console.warn("Error setting media session metadata:", e); }
             }

             audio.pause(); // Pause explicitly before changing src or time
             const savedPosition = loadTrackPosition(song.url);
             currentTimeEl.textContent = formatTime(savedPosition);
             durationEl.textContent = formatTime(0);
             progress.style.width = '0%';

             let needsSrcChange = audio.currentSrc !== song.url;

             if (needsSrcChange) {
                 // console.log("Changing audio src to:", song.url);
                 audio.src = song.url;
                 audio.load(); // Explicitly load
             } else {
                 // console.log("Audio src is the same, seeking only.");
                 if (audio.readyState >= 1) { // HAVE_METADATA or higher
                     try {
                        const targetTime = savedPosition || 0;
                        if (isFinite(audio.duration) && targetTime < audio.duration && Math.abs(audio.currentTime - targetTime) > 0.5) { audio.currentTime = targetTime; }
                        updateProgressDirect(audio.currentTime, audio.duration);
                     } catch (e) { console.warn("Error seeking on same src:", e); audio.currentTime = 0; }
                 }
                 if (isPlaying && audio.paused) { playSong(); } // Start if needed
                 loadingIndicator.classList.remove('show'); // Hide loader if not changing src
             }

             audio.onloadedmetadata = () => {
                  if (isResetting || audio.src !== song.url) return; // Stale event check
                  durationEl.textContent = formatTime(audio.duration);
                  let targetTime = 0;
                  const currentSavedPos = loadTrackPosition(song.url); // Re-load position
                  if (currentSavedPos && !isNaN(currentSavedPos) && currentSavedPos < audio.duration) { targetTime = currentSavedPos; }
                  // console.log(`Setting initial time to: ${targetTime}`);
                  requestAnimationFrame(() => { // Defer setting time slightly
                     try {
                         let canSeek = false;
                         for (let i = 0; i < audio.seekable.length; i++) { if (targetTime >= audio.seekable.start(i) && targetTime <= audio.seekable.end(i)) { canSeek = true; break; } }
                         if (canSeek) { audio.currentTime = targetTime; }
                         else if (audio.seekable.length > 0) { audio.currentTime = audio.seekable.start(0); console.warn(`Target time ${targetTime} not seekable, setting to ${audio.seekable.start(0)}`); }
                         else { audio.currentTime = 0; console.warn("No seekable ranges, setting time to 0"); }
                         updateProgressDirect(audio.currentTime, audio.duration);
                     } catch (err) { console.error("Error setting currentTime in onloadedmetadata:", err); audio.currentTime = 0; updateProgressDirect(0, audio.duration); }
                  });
             };

             audio.oncanplay = () => {
                 if (isResetting || audio.src !== song.url) return; // Stale event check
                 audio._skipErrorCount = 0;
                 loadingIndicator.classList.remove('show');
                 if (isPlaying && audio.paused) { playSong(); }
                 if (!isNaN(audio.duration)) { durationEl.textContent = formatTime(audio.duration); }
             };

             audio.onerror = (e) => {
                 if (isResetting) return;
                 const currentSrcOnError = audio.currentSrc; const errCode = audio.error?.code; const errMsg = audio.error?.message || 'Unknown error';
                 const songUrlOnError = song?.url || 'N/A'; const songType = song?.type || 'unknown';

                 if (!currentSrcOnError && !songUrlOnError) { return; } // Ignore errors on empty src
                 if (currentSrcOnError !== songUrlOnError && currentSrcOnError) { console.warn(`Ignoring stale error for ${currentSrcOnError} (current song is ${songUrlOnError})`); return; }

                 let detailedMsg = `Ошибка: ${songName} (${errMsg})`; let consoleWarnMsg = `Audio error for ${songUrlOnError}`;
                 if (songType === 'supabase') { detailedMsg += ` [Облако]`; consoleWarnMsg += ` [Supabase]`; }
                 else if (songType === 'file') { detailedMsg += ` [Файл]`; consoleWarnMsg += ` [File]`; }
                 else { detailedMsg += ` [URL]`; consoleWarnMsg += ` [URL]`; }

                 console.error("Audio Error Details:", { songTitle: songName, songUrl: songUrlOnError, currentSrc: currentSrcOnError, songType: songType, errorCode: errCode, errorMessage: errMsg, errorEvent: e });
                 showNotification(detailedMsg, 4000);
                 loadingIndicator.classList.remove('show');
                 stopFaviconBlink(); // Stop blinking on error

                 if (errCode === MediaError.MEDIA_ERR_SRC_NOT_SUPPORTED || errCode === MediaError.MEDIA_ERR_DECODE || errCode === MediaError.MEDIA_ERR_NETWORK || errCode === MediaError.MEDIA_ERR_ABORTED) {
                     console.warn(`${consoleWarnMsg}. Skipping track.`);
                     if (songs.length > 1) {
                         if (!audio.hasOwnProperty('_skipErrorCount')) audio._skipErrorCount = 0; audio._skipErrorCount++;
                         if (audio._skipErrorCount >= songs.length && !isResetting) { showNotification("Не удалось воспроизвести ни один трек.", 5000); resetPlayer(); }
                         else if (!isResetting) {
                             if (window._nextSongTimeout) clearTimeout(window._nextSongTimeout);
                             window._nextSongTimeout = setTimeout(() => { if (audio.currentSrc === songUrlOnError || !audio.currentSrc) { nextSong(); } else { /* console.log("Skipping 'nextSong' call because src changed after error.") */} }, 500);
                         }
                     } else if (!isResetting) { resetPlayer(); showNotification('Не удалось воспроизвести трек.'); }
                 } else { if (audio._skipErrorCount > 0) audio._skipErrorCount = 0; }
             };
         }


        function saveTrackPosition(trackUrl, position) {
             if (!trackUrl || typeof position !== 'number' || isNaN(position) || position <= 0) return; // Don't save 0
             // console.log(`Saving position ${position} for ${trackUrl}`);
             try {
                 let trackPositions = JSON.parse(localStorage.getItem('trackPositions') || '{}');
                 const keys = Object.keys(trackPositions);
                 if (keys.length > 100) { /* console.log("Pruning oldest track position"); */ delete trackPositions[keys[0]]; }
                 const trackKey = trackUrl; // Use URL as key
                 trackPositions[trackKey] = Math.floor(position);
                 localStorage.setItem('trackPositions', JSON.stringify(trackPositions));
             } catch (e) { console.error("Error saving track position:", e); }
         }

        function loadTrackPosition(trackUrl) {
             if (!trackUrl) return 0;
             try {
                 const trackPositions = JSON.parse(localStorage.getItem('trackPositions') || '{}');
                 const trackKey = trackUrl;
                 const position = trackPositions[trackKey] || 0;
                 // console.log(`Loaded position ${position} for ${trackUrl}`);
                 return position;
             } catch (e) { console.error("Error loading track position:", e); return 0; }
         }

        function playSong() {
            if (isResetting || songs.length === 0 || !songs[currentSongIndex]) { if(!isResetting) showNotification('Плейлист пуст/трек не выбран'); return; }
            if (audio.readyState < 1) { loadingIndicator.classList.add('show'); if (!audio.currentSrc) { loadSong(songs[currentSongIndex]); } return; }

            // console.log(`Playing: ${songs[currentSongIndex].title}`);
            playPauseIcon.classList.replace('fa-play', 'fa-pause');
            albumCover.style.display = 'none';
            equalizer.classList.add('active');

            audio.play().then(() => {
                // console.log("Playback started successfully.");
                isPlaying = true; // Set state AFTER successful play starts
                requestWakeLock();
                loadingIndicator.classList.remove('show');
                if ('mediaSession' in navigator) { try { navigator.mediaSession.playbackState = "playing"; } catch(e){} }
                startFaviconBlink(); // Start blinking
            }).catch(error => {
                console.error(`Error starting playback: ${error.message}`, error);
                // Don't call pauseSong() directly here, as it might double-stop blinking
                // Revert UI elements manually
                playPauseIcon.classList.replace('fa-pause', 'fa-play');
                equalizer.classList.remove('active');
                albumCover.style.display = 'flex';
                isPlaying = false; // Ensure state is correct
                stopFaviconBlink(); // Stop blinking on error
                showNotification(`Ошибка воспроизведения: ${error.message}`);
                loadingIndicator.classList.remove('show');
                if (error.name === 'NotAllowedError') { showNotification("Воспр. заблокировано браузером. Нажмите Play.", 5000); }
                else if (error.name === 'NotSupportedError') { showNotification("Формат файла не поддерживается.", 4000); nextSong(); }
            });
        }

        function pauseSong() {
            // console.log("Pausing song");
            playPauseIcon.classList.replace('fa-pause', 'fa-play');
            equalizer.classList.remove('active');
            albumCover.style.display = 'flex';
            audio.pause(); // Pause audio first
            isPlaying = false; // Update state *after* pausing
            stopFaviconBlink(); // Stop blinking
            if ('mediaSession' in navigator) { try { navigator.mediaSession.playbackState = "paused"; } catch(e){} }
            if (songs[currentSongIndex] && audio.currentTime > 0 && !audio.ended) { saveTrackPosition(songs[currentSongIndex].url, audio.currentTime); } // Save position if paused mid-track
            if (wakeLock) { wakeLock.release().then(() => wakeLock = null); }
        }

        function playPause() {
             if (songs.length === 0) { showNotification('Плейлист пуст.'); return; }
             if (isPlaying) { pauseSong(); } else { playSong(); }
        }

        // --- Favicon Blinking Functions ---
        function startFaviconBlink() {
            if (isFaviconBlinking || !faviconLink || !originalFaviconUrl) return;
            isFaviconBlinking = true;
            faviconStateIsOriginal = true; // Start with original
            if (blinkingIntervalId) { clearInterval(blinkingIntervalId); }
            blinkingIntervalId = setInterval(() => {
                if (faviconLink) {
                    faviconLink.href = faviconStateIsOriginal ? transparentFaviconUrl : originalFaviconUrl;
                    faviconStateIsOriginal = !faviconStateIsOriginal; // Toggle state
                }
            }, 750); // Blink speed
            // console.log("Favicon blink started", blinkingIntervalId);
        }

        function stopFaviconBlink() {
            if (!isFaviconBlinking || !faviconLink) return;
            if (blinkingIntervalId) { clearInterval(blinkingIntervalId); blinkingIntervalId = null; }
            if (originalFaviconUrl) faviconLink.href = originalFaviconUrl; // Restore original
            isFaviconBlinking = false;
            faviconStateIsOriginal = true;
            // console.log("Favicon blink stopped");
        }

        // --- Playlist Navigation and Shuffle ---
        function shuffleButtonHandler() {
            isShuffleMode = !isShuffleMode;
            shuffleBtn.classList.toggle('active', isShuffleMode);
            if (isShuffleMode) { createShuffleQueue(); showNotification('Случайный порядок вкл.'); }
            else { shuffleQueue = []; showNotification('Обычный порядок'); }
            saveSettings();
        }

        function createShuffleQueue() {
            shuffleQueue = songs.map((_, i) => i).filter(i => i !== currentSongIndex); // Exclude current
            for (let i = shuffleQueue.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [shuffleQueue[i], shuffleQueue[j]] = [shuffleQueue[j], shuffleQueue[i]];
            }
            // console.log("Shuffle queue created:", shuffleQueue);
        }

        function getNextSongIndex() {
            if (songs.length <= 1) return 0;
            if (isShuffleMode) {
                if (shuffleQueue.length === 0) createShuffleQueue(); // Regenerate if empty
                return shuffleQueue.length > 0 ? shuffleQueue.pop() : (currentSongIndex + 1) % songs.length; // Fallback if still empty
            }
            return (currentSongIndex + 1) % songs.length; // Normal order
        }

        function getPrevSongIndex() {
            if (songs.length <= 1) return 0;
            // Restart current song if played for more than 3 seconds
            if (audio.currentTime > 3 && !isResetting) return currentSongIndex;
            // Use history if shuffling and history available
            if (isShuffleMode && playHistory.length > 0) {
                return playHistory.pop(); // Get the last played index from history
            }
            // Normal order or shuffle fallback
            return (currentSongIndex - 1 + songs.length) % songs.length;
        }

        function nextSong() {
            // console.log("nextSong called");
            if (isResetting || songs.length === 0) return;
            // Save position of the song *before* changing index (resetting it)
            if (songs[currentSongIndex]) { saveTrackPosition(songs[currentSongIndex].url, 0); }
            // Add current index to history *before* getting the next one
            if (isShuffleMode) playHistory.push(currentSongIndex);
            currentSongIndex = getNextSongIndex();
            // console.log(`Next index: ${currentSongIndex}`);
            loadSong(songs[currentSongIndex]);
            // loadSong will handle play if isPlaying is true
        }

        function prevSong() {
             // console.log("prevSong called");
             if (isResetting || songs.length === 0) return;
             // If playing for more than 3 secs, restart current song
             if (audio.currentTime > 3 && !isResetting) {
                  // console.log("Restarting current song");
                  audio.currentTime = 0;
                  if (isPlaying) playSong(); // Ensure it plays if it was playing
                  return;
             }
             // Save position of the song *before* changing index (resetting it)
             if (songs[currentSongIndex]) { saveTrackPosition(songs[currentSongIndex].url, 0); }

             const newIndex = getPrevSongIndex();
             // Don't add to history here, getPrevSongIndex handles shuffle history pop
             currentSongIndex = newIndex;
             // console.log(`Previous index: ${currentSongIndex}`);
             loadSong(songs[currentSongIndex]);
             // loadSong will handle play if isPlaying is true
         }

        // --- Playlist Rendering and Manipulation ---

        function showNotification(message, duration = 2000) {
            notification.textContent = message;
            notification.classList.add('show');
            setTimeout(() => notification.classList.remove('show'), duration);
        }

        function updateActivePlaylistItem() {
             if (isResetting) return;
             // console.log(`Updating active item highlight, current index: ${currentSongIndex}`);
             const items = playlist.querySelectorAll('.playlist-item');
             let activeItemFound = null;
             items.forEach((item) => {
                const itemIndex = parseInt(item.dataset.index, 10);
                const isActive = itemIndex === currentSongIndex;
                item.classList.toggle('active', isActive);
                if (isActive) activeItemFound = item;
             });
             // Scroll into view only if modal is visible and item found
             if (activeItemFound && playlistModal.classList.contains('show')) {
                requestAnimationFrame(() => {
                     activeItemFound.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                 });
             }
        }

        function renderPlaylist() {
            // console.log(`Rendering playlist, ${songs.length} items`);
             if (isResetting) return;
             playlist.innerHTML = ''; // Clear previous items

             if (songs.length === 0) {
                 playlist.innerHTML = '<div class="empty-playlist">Плейлист пуст. Загрузите файлы или нажмите F9 для загрузки из Облака.</div>';
                 return; // Stop if empty
             }

             const fragment = document.createDocumentFragment();
             songs.forEach((song, index) => {
                 if (!song || !song.title) { console.warn(`Skipping rendering invalid song at index ${index}:`, song); return; }

                 const playlistItem = document.createElement('div');
                 playlistItem.classList.add('playlist-item');
                 playlistItem.dataset.index = index; // Store original index

                 // Capture details for potential debugging
                 const renderTimeIndex = index; const renderTimeTitle = song.title;

                 let typeText = 'URL';
                 if (song.type === 'file') typeText = 'Файл';
                 else if (song.type === 'supabase') typeText = 'Облако';
                 const typeIndicator = `<span class="playlist-type-indicator">${typeText}</span>`;

                 playlistItem.innerHTML = `
                     <div class="track-number">${index + 1}</div>
                     <div class="track-info"> <div class="track-title">${song.title} ${typeIndicator}</div> <div class="track-artist">${song.artist || 'Неизвестный'}</div> </div>
                     <button class="track-delete" title="Удалить"><i class="fas fa-times"></i></button>`;

                 playlistItem.addEventListener('click', (e) => {
                     if (e.target.closest('.track-delete')) return;
                     if (songs.length === 0) { console.warn("Playlist item clicked, but songs array is empty."); renderPlaylist(); return; }
                     const clickedIndex = parseInt(playlistItem.dataset.index, 10);
                     if (isNaN(clickedIndex) || clickedIndex < 0 || clickedIndex >= songs.length) { console.error("Invalid index on playlist item click:", clickedIndex, "Current songs length:", songs.length); renderPlaylist(); return; }
                     if (currentSongIndex !== clickedIndex) {
                         if (songs[currentSongIndex] && !isResetting) { saveTrackPosition(songs[currentSongIndex].url, audio.currentTime); }
                         if (isShuffleMode) playHistory.push(currentSongIndex);
                         currentSongIndex = clickedIndex;
                         loadSong(songs[currentSongIndex]);
                         playSong();
                     } else { playPause(); }
                 });

                 const deleteButton = playlistItem.querySelector('.track-delete');
                 deleteButton.addEventListener('click', (e) => {
                     e.stopPropagation();
                     if (songs.length === 0) { console.warn(`Delete button clicked (intended index: ${renderTimeIndex}, title: "${renderTimeTitle}"), but songs array is currently EMPTY. Aborting delete. Re-rendering.`); renderPlaylist(); return; }
                     const indexToRemove = parseInt(playlistItem.dataset.index, 10);
                     console.log(`Delete clicked. RenderTimeIndex: ${renderTimeIndex}, Title: "${renderTimeTitle}". Parsed indexToRemove: ${indexToRemove}. Current songs.length: ${songs.length}`);
                     if (!isNaN(indexToRemove) && indexToRemove >= 0 && indexToRemove < songs.length) { removeFromPlaylist(indexToRemove); }
                     else { console.error(`Invalid index condition failed. indexToRemove: ${indexToRemove}, songs.length: ${songs.length}. Element dataset:`, playlistItem.dataset); showNotification("Ошибка удаления, обновление списка...", 1500); renderPlaylist(); }
                 });

                 fragment.appendChild(playlistItem);
             });

             playlist.appendChild(fragment);
             updateActivePlaylistItem(); // Highlight the correct item after rendering
         }

        function removeFromPlaylist(indexToRemove) {
            // console.log(`removeFromPlaylist called for index: ${indexToRemove}`);
            if (indexToRemove < 0 || indexToRemove >= songs.length) { console.error("Invalid index passed to removeFromPlaylist:", indexToRemove); return; }

            const removedSong = songs[indexToRemove];
            const wasPlaying = isPlaying && indexToRemove === currentSongIndex;
            const deletingCurrent = indexToRemove === currentSongIndex;
            let playlistWasReset = false;

            if (removedSong.type === 'file' && removedSong.url?.startsWith('blob:')) { try { URL.revokeObjectURL(removedSong.url); } catch (e) { console.warn("Error revoking object URL:", e); } }
            songs.splice(indexToRemove, 1);
            // console.log(`Song removed. New playlist length: ${songs.length}`);

            if (songs.length === 0) {
                 console.log("Playlist is now empty, calling resetPlayer.");
                 resetPlayer(); playlistWasReset = true;
            } else {
                if (deletingCurrent) {
                     if (currentSongIndex >= songs.length) { currentSongIndex = 0; } // Adjust index if last was deleted
                     // console.log(`Deleted current song. New index: ${currentSongIndex}. Loading song.`);
                     loadSong(songs[currentSongIndex]);
                     if (wasPlaying) { playSong(); } else { pauseSong(); } // Maintain play state
                 } else if (indexToRemove < currentSongIndex) {
                     currentSongIndex--; // Adjust index if item before current was deleted
                     // console.log(`Deleted item before current. New index: ${currentSongIndex}.`);
                 }
                 // Else: Deleted item after current, no index change needed
            }

            if (!playlistWasReset) {
                // console.log("Playlist not reset, calling renderPlaylist, createShuffleQueue, savePlaylist.");
                renderPlaylist(); // Update UI *after* adjustments
                if (isShuffleMode) { createShuffleQueue(); }
                savePlaylist(); // Persist changes
            } else {
                // console.log("Playlist was reset, skipping final steps in removeFromPlaylist.");
            }
            showNotification('Трек удален');
        }


        function addBulkUrls(text) {
            if (!text) return 0; const lines = text.split(/\r?\n/).map(line => line.trim()).filter(line => line && line.startsWith('http')); if (lines.length === 0) return 0; let addedCount = 0; const existingUrls = new Set(songs.map(s => s.url));
            const playlistWasEmpty = songs.length === 0;
            lines.forEach(url => { if (!existingUrls.has(url)) { const fileName = decodeURIComponent(url.split('/').pop().split('?')[0] || ''); const fileTitle = fileName.replace(/\.[^.]+$/, '') || 'URL ' + (songs.length + addedCount + 1); songs.push({ title: fileTitle, artist: 'Неизвестный', url: url, cover: null, type: 'url' }); addedCount++; existingUrls.add(url); } });
            if (addedCount > 0) { renderPlaylist(); if (playlistWasEmpty && !isPlaying) { currentSongIndex = 0; loadSong(songs[0]); } if (isShuffleMode) createShuffleQueue(); savePlaylist(); } return addedCount;
        }

           async function showSupabaseFileSelector() {
             supabaseLoadingIndicator.classList.add('show');
             supabaseFileList.innerHTML = ''; // Clear previous list
             supabaseSelectModal.classList.add('show');
             try {
                 const { data, error } = await supabaseClient.storage.from('mp3').list('', { limit: 1000, offset: 0, sortBy: { column: 'name', order: 'asc' }, });
                 if (error) throw error;
                 if (!data || data.length === 0) {
                     supabaseFileList.innerHTML = '<div class="empty-playlist">В облаке нет файлов.</div>';
                     selectAllSupabaseBtn.style.display = 'none'; // Hide select all if no files
                     return;
                 } else {
                    selectAllSupabaseBtn.style.display = 'inline-block'; // Show select all if files exist
                 }

                 const fragment = document.createDocumentFragment();
                 data.filter(file => file.name.toLowerCase().match(/\.(mp3|wav|ogg|m4a)$/i)) // Filter for audio
                     .forEach((file, id) => {
                         const itemDiv = document.createElement('div');
                         itemDiv.className = 'supabase-file-item';
                         const checkboxId = `supabase-cb-${id}`;
                         const title = file.name.replace(/\.[^.]+$/i, ''); // Extract title

                         itemDiv.innerHTML = `
                             <input type="checkbox" id="${checkboxId}" data-filename="${file.name}" style="flex-shrink: 0;">
                             <label for="${checkboxId}" title="${file.name}">${title}</label> <!-- Keep label for accessibility -->
                         `;

                         // --- MODIFIED: Click listener on the entire row (itemDiv) ---
                         itemDiv.addEventListener('click', (e) => {
                             // Don't interfere if the click was directly on the checkbox or label itself
                             if (e.target.tagName !== 'INPUT' && e.target.tagName !== 'LABEL') {
                                 const cb = itemDiv.querySelector('input[type="checkbox"]');
                                 if (cb) {
                                     cb.checked = !cb.checked;
                                 }
                             }
                              // If click was on the label, the default behavior already toggles the checkbox via 'for' attribute
                         });
                         // --- End Modification ---

                         fragment.appendChild(itemDiv);
                     });
                 supabaseFileList.appendChild(fragment);

             } catch (error) {
                 supabaseFileList.innerHTML = `<div class="empty-playlist">Ошибка загрузки: ${error.message}</div>`;
                 selectAllSupabaseBtn.style.display = 'none'; // Hide on error
             } finally {
                 supabaseLoadingIndicator.classList.remove('show');
             }
         }


  selectAllSupabaseBtn.addEventListener('click', () => {
            const checkboxes = supabaseFileList.querySelectorAll('input[type="checkbox"]');
            if (checkboxes.length > 0) {
                // Determine if we should select all or deselect all based on current state
                // If *any* checkbox is currently unchecked, the action is to select all.
                // If *all* checkboxes are already checked, the action is to deselect all.
                const allChecked = Array.from(checkboxes).every(cb => cb.checked);

                checkboxes.forEach(cb => {
                    cb.checked = !allChecked; // If all were checked, uncheck them. Otherwise, check them.
                });

                // Update button text (optional)
                selectAllSupabaseBtn.textContent = allChecked ? 'Выбрать все' : 'Снять выбор';
            }
        });
        // --- End Select All Listener ---

        // Listener for adding selected Supabase files (remains the same)
         addSelectedSupabase.addEventListener('click', () => {
            const selectedCheckboxes = supabaseFileList.querySelectorAll('input[type="checkbox"]:checked');
            if (selectedCheckboxes.length === 0) { showNotification("Файлы не выбраны"); return; }
            let addedCount = 0; const playlistWasEmpty = songs.length === 0; const existingUrls = new Set(songs.map(s => s.url));
            selectedCheckboxes.forEach(cb => {
                const fileName = cb.dataset.filename; if (!fileName) return;
                const { data: urlData } = supabaseClient.storage.from('mp3').getPublicUrl(fileName); const publicURL = urlData.publicUrl;
                if (publicURL && !existingUrls.has(publicURL)) {
                     const title = fileName.replace(/\.[^.]+$/i, '');
                     songs.push({ title: title, artist: 'Облачное хранилище', url: publicURL, cover: null, type: 'supabase' });
                     addedCount++; existingUrls.add(publicURL);
                }
            });
            supabaseSelectModal.classList.remove('show');
            if (addedCount > 0) {
                renderPlaylist(); savePlaylist();
                if (playlistWasEmpty && songs.length > 0) { currentSongIndex = 0; loadSong(songs[0]); }
                if (isShuffleMode) createShuffleQueue();
                showNotification(`Добавлено ${addedCount} треков из облака`);
            } else { showNotification("Выбранные треки уже есть в плейлисте"); }
         });


         addSelectedSupabase.addEventListener('click', () => {
            const selectedCheckboxes = supabaseFileList.querySelectorAll('input[type="checkbox"]:checked');
            if (selectedCheckboxes.length === 0) { showNotification("Файлы не выбраны"); return; }
            let addedCount = 0; const playlistWasEmpty = songs.length === 0; const existingUrls = new Set(songs.map(s => s.url));
            selectedCheckboxes.forEach(cb => {
                const fileName = cb.dataset.filename; if (!fileName) return;
                const { data: urlData } = supabaseClient.storage.from('mp3').getPublicUrl(fileName); const publicURL = urlData.publicUrl;
                if (publicURL && !existingUrls.has(publicURL)) {
                     const title = fileName.replace(/\.[^.]+$/i, '');
                     songs.push({ title: title, artist: 'Облачное хранилище', url: publicURL, cover: null, type: 'supabase' }); // Correct type
                     addedCount++; existingUrls.add(publicURL);
                }
            });
            supabaseSelectModal.classList.remove('show');
            if (addedCount > 0) {
                renderPlaylist(); savePlaylist();
                if (playlistWasEmpty && songs.length > 0) { currentSongIndex = 0; loadSong(songs[0]); }
                if (isShuffleMode) createShuffleQueue();
                showNotification(`Добавлено ${addedCount} треков из облака`);
            } else { showNotification("Выбранные треки уже есть в плейлисте"); }
         });


        // --- File Input and Metadata Extraction ---
        fileInput.addEventListener('change', async function(e) {
            const files = this.files; if (files.length === 0) return; loadingIndicator.classList.add('show'); showNotification(`Добавление ${files.length} файлов...`);
            if (!window.jsmediatags) { try { const script = document.createElement('script'); script.src = 'https://cdnjs.cloudflare.com/ajax/libs/jsmediatags/3.9.5/jsmediatags.min.js'; await new Promise((resolve, reject) => { script.onload = resolve; script.onerror = reject; document.head.appendChild(script); }); } catch (err) { console.warn("Could not load jsmediatags.", err); } }
            const newSongs = []; const processFile = async (file) => { try { return await extractMetadata(file); } catch (error) { console.warn(`Error extracting metadata for ${file.name}:`, error); return { title: file.name.replace(/\.[^.]+$/, ''), artist: 'Неизвестный', url: URL.createObjectURL(file), cover: null, file: file, type: 'file' }; } };
            const playlistWasEmpty = songs.length === 0;
            for (let i = 0; i < files.length; i++) { const song = await processFile(files[i]); newSongs.push(song); }
            songs = [...songs, ...newSongs]; renderPlaylist();
            if (playlistWasEmpty && songs.length > 0 && !isPlaying) { currentSongIndex = 0; loadSong(songs[0]); }
            if (isShuffleMode) createShuffleQueue();
            savePlaylist(); // Save if any URL/Supabase tracks existed
            showNotification(`${newSongs.length} файлов добавлено. Локальные файлы не сохраняются между сессиями.`);
            loadingIndicator.classList.remove('show'); this.value = ''; // Reset file input
        });

        function extractMetadata(file) {
             return new Promise((resolve) => { const song = { title: file.name.replace(/\.[^.]+$/, ''), artist: 'Неизвестный', url: URL.createObjectURL(file), cover: null, file: file, type: 'file' }; if (window.jsmediatags && file.type.startsWith('audio/')) { jsmediatags.read(file, { onSuccess: function(tag) { try { const tags = tag.tags; if (tags.title) song.title = tags.title; if (tags.artist) song.artist = tags.artist; if (tags.picture) { const { data, format } = tags.picture; let b64 = ""; for (let i = 0; i < data.length; i++) { b64 += String.fromCharCode(data[i]); } song.cover = `data:${format};base64,${btoa(b64)}`; } resolve(song); } catch (e) { console.warn("Error processing jsmediatags data:", e); resolve(song); } }, onError: function(error) { resolve(song); } }); } else { resolve(song); } });
         }

        // --- UI Formatting ---
        function formatTime(seconds) { if (isNaN(seconds) || seconds === Infinity || seconds < 0) return '0:00'; const minutes = Math.floor(seconds / 60); const secs = Math.floor(seconds % 60); return `${minutes}:${secs < 10 ? '0' : ''}${secs}`; }
        function updateProgress(e) { const { duration, currentTime } = e.srcElement; updateProgressDirect(currentTime, duration); }
        function updateProgressDirect(currentTime, duration) {
             if (!isNaN(duration) && duration > 0) { const progressPercent = (currentTime / duration) * 100; progress.style.width = `${progressPercent}%`; currentTimeEl.textContent = formatTime(currentTime); durationEl.textContent = formatTime(duration); }
             else { progress.style.width = '0%'; currentTimeEl.textContent = formatTime(currentTime || 0); durationEl.textContent = '--:--'; }
         }
        function setProgress(e) { if (!audio.duration || isNaN(audio.duration) || audio.duration <= 0) return; const width = progressContainer.clientWidth; const clickX = e.offsetX; const newTime = (clickX / width) * audio.duration; if (isFinite(newTime)) { audio.currentTime = newTime; updateProgressDirect(audio.currentTime, audio.duration); } }
        function fixHeight() { document.documentElement.style.setProperty('--vh', `${window.innerHeight * 0.01}px`); }


        // --- Event Listeners ---

        // Modal Controls
        playlistBtn.addEventListener('click', () => { playlistModal.classList.add('show'); renderPlaylist(); }); // Re-render on open
        closePlaylistModal.addEventListener('click', () => playlistModal.classList.remove('show'));
        urlBtnInPlaylist.addEventListener('click', (e) => { e.stopPropagation(); urlModal.classList.add('show'); bulkUrls.value = ''; bulkUrls.focus(); });
        closeUrlModal.addEventListener('click', () => urlModal.classList.remove('show'));
        cancelUrl.addEventListener('click', () => urlModal.classList.remove('show'));
        addUrl.addEventListener('click', () => { const text = bulkUrls.value.trim(); if (text) { const count = addBulkUrls(text); if (count > 0) { urlModal.classList.remove('show'); showNotification(`Добавлено ${count} URL`); } else { showNotification('Нет новых URL для добавления'); } } else { showNotification('Введите URL'); } });
        cancelSupabaseSelect.addEventListener('click', () => supabaseSelectModal.classList.remove('show'));
        closeSupabaseSelectModal.addEventListener('click', () => supabaseSelectModal.classList.remove('show'));

        // Playlist Action Buttons
        savePlaylistBtn.addEventListener('click', function(e) {
            e.stopPropagation(); const data = songs.filter(s => s.type === 'url' || s.type === 'supabase'); if (data.length === 0) { showNotification('Нет URL/облачных треков для сохранения'); return; }
            try { const json = JSON.stringify({ name: "Плейлист", songs: data }, null, 2); const blob = new Blob([json], { type: 'application/json' }); const url = URL.createObjectURL(blob); const a = document.createElement('a'); a.href = url; const now = new Date(); const timestamp = `${now.getFullYear()}${String(now.getMonth() + 1).padStart(2, '0')}${String(now.getDate()).padStart(2, '0')}_${String(now.getHours()).padStart(2, '0')}${String(now.getMinutes()).padStart(2, '0')}`; a.download = `audioplayer_playlist_${timestamp}.json`; document.body.appendChild(a); a.click(); setTimeout(() => { document.body.removeChild(a); window.URL.revokeObjectURL(url); }, 100); showNotification('Файл плейлиста сохранен'); } catch (e) { showNotification('Ошибка сохранения файла'); console.error("Error saving playlist file:", e); }
        });
        loadPlaylistBtn.addEventListener('click', function(e) {
            e.stopPropagation(); const input = document.createElement('input'); input.type = 'file'; input.accept = '.json,application/json'; input.style.display = 'none'; document.body.appendChild(input);
            input.addEventListener('change', function() {
                if (this.files.length === 0) { document.body.removeChild(input); return; } const file = this.files[0]; const reader = new FileReader();
                reader.onload = function(e_reader) {
                    try { const data = JSON.parse(e_reader.target.result);
                        if (data && data.songs && Array.isArray(data.songs)) {
                             const loaded = data.songs.filter(s => s && s.url && s.title && (s.type === 'url' || s.type === 'supabase')).map(s => ({ title: String(s.title).trim(), artist: String(s.artist || 'Неизвестный').trim(), url: String(s.url).trim(), cover: s.cover ? String(s.cover).trim() : null, type: s.type }));
                            if (loaded.length > 0) { songs = loaded; renderPlaylist(); currentSongIndex = 0; loadSong(songs[0]); pauseSong(); savePlaylist(); showNotification(`Плейлист "${data.name || file.name}" загружен (${loaded.length} треков)`); if (playlistModal.classList.contains('show')) { setTimeout(updateActivePlaylistItem, 100); } }
                            else { showNotification('Файл не содержит подходящих треков'); }
                        } else { showNotification('Некорректный формат файла плейлиста'); }
                    } catch (error) { showNotification('Ошибка чтения или парсинга файла'); console.error("Error loading playlist file:", error); }
                    finally { document.body.removeChild(input); }
                }; reader.onerror = () => { showNotification('Ошибка чтения файла'); document.body.removeChild(input); }; reader.readAsText(file);
            }); input.click();
        });
        loadSupabaseBtn.addEventListener('click', function(e) { e.stopPropagation(); showSupabaseFileSelector(); });

        // Keyboard Shortcuts
        document.addEventListener('keydown', function(e) {
             if (e.key === 'F9') { e.preventDefault(); showSupabaseFileSelector(); return; }
             if (e.target.closest('textarea, input:not([type="range"])') || e.ctrlKey || e.altKey || e.metaKey) return;
             let prevent = false;
             switch (e.key) {
                case ' ': case 'MediaPlayPause': playPause(); prevent = true; break;
                case 'ArrowLeft': case 'MediaPreviousTrack': prevSong(); prevent = true; break;
                case 'ArrowRight': case 'MediaNextTrack': nextSong(); prevent = true; break;
                 case 'ArrowUp': volumeSlider.value = Math.min(1, parseFloat(volumeSlider.value) + 0.05); volumeSlider.dispatchEvent(new Event('input')); prevent = true; break;
                 case 'ArrowDown': volumeSlider.value = Math.max(0, parseFloat(volumeSlider.value) - 0.05); volumeSlider.dispatchEvent(new Event('input')); prevent = true; break;
                 case 'm': case 'M': volumeBtn.click(); prevent = true; break;
                 case 's': case 'S': shuffleButtonHandler(); prevent = true; break;
                 case 'l': case 'L': playlistModal.classList.toggle('show'); if(playlistModal.classList.contains('show')) renderPlaylist(); prevent = true; break;
                 case 'f': case 'F': toggleFullScreen(); prevent = true; break;
                case 'Escape': if (supabaseSelectModal.classList.contains('show')) supabaseSelectModal.classList.remove('show'); else if (urlModal.classList.contains('show')) urlModal.classList.remove('show'); else if (playlistModal.classList.contains('show')) playlistModal.classList.remove('show'); else if (document.fullscreenElement) document.exitFullscreen(); prevent = true; break;
            }
             if (prevent) e.preventDefault();
        });

        // Core Player Controls & Audio Events
        themeToggle.addEventListener('click', () => { const currentTheme = document.documentElement.getAttribute('data-theme'); const targetTheme = currentTheme === 'dark' ? 'light' : 'dark'; document.documentElement.setAttribute('data-theme', targetTheme); localStorage.setItem('theme', targetTheme); updateThemeIcon(targetTheme); document.body.style.transition = 'background-color 0.3s, color 0.3s'; setTimeout(() => document.body.style.transition = '', 300); setupThemeToggleVisibility(); });
        playPauseBtn.addEventListener('click', playPause);
        document.querySelector('.prev-btn').addEventListener('click', prevSong);
        document.querySelector('.next-btn').addEventListener('click', nextSong);
        shuffleBtn.addEventListener('click', shuffleButtonHandler);
        progressContainer.addEventListener('click', setProgress);

        audio.addEventListener('timeupdate', updateProgress);
        audio.addEventListener('ended', () => { stopFaviconBlink(); nextSong(); });
        audio.addEventListener('pause', () => { if (!isPlaying) { stopFaviconBlink(); } if (songs[currentSongIndex] && audio.currentTime > 0 && !isResetting && !audio.ended) { saveTrackPosition(songs[currentSongIndex].url, audio.currentTime); } });
        audio.addEventListener('play', () => { /* Play event fires early, use 'playing' */ });
        audio.addEventListener('playing', () => { if (isPlaying) { startFaviconBlink(); } if(!isResetting) loadingIndicator.classList.remove('show'); });
        audio.addEventListener('waiting', () => { if(!isResetting && isPlaying) loadingIndicator.classList.add('show'); });
        audio.addEventListener('canplay', () => { if(!isResetting) loadingIndicator.classList.remove('show'); });
        audio.addEventListener('error', (e) => { stopFaviconBlink(); if(isResetting) return; loadingIndicator.classList.remove('show'); /* Error logic in loadSong */ });


        // Touch / UI Enhancements
        document.querySelectorAll('.controls button, .playlist-control-btn').forEach(button => { button.addEventListener('touchstart', function() { this.classList.add('touch-active'); }, { passive: true }); button.addEventListener('touchend', function() { this.classList.remove('touch-active'); }); button.addEventListener('touchcancel', function() { this.classList.remove('touch-active'); }); });
        if (/iPad|iPhone|iPod/.test(navigator.userAgent)) { document.body.style.webkitTouchCallout = 'none'; let lt = 0; document.addEventListener('touchend', function(e) { const n=Date.now(); if(n-lt<=300) e.preventDefault(); lt=n; }, false); document.addEventListener('touchmove', function(e) { if(e.scale !== 1) e.preventDefault(); }, { passive: false }); }
        document.addEventListener('dragstart', e => { if (e.target.tagName === 'IMG') e.preventDefault(); });
        window.addEventListener('orientationchange', () => { fixHeight(); setTimeout(renderPlaylist, 300); });
        albumCover.addEventListener('contextmenu', e => e.preventDefault());
        equalizer.addEventListener('contextmenu', e => e.preventDefault());
        albumCover.addEventListener('click', function(e) { const t=Date.now(); if (t-lastClickTime<300) { playlistModal.classList.add('show'); renderPlaylist(); e.preventDefault(); lastClickTime=0; } else { /* No action on single cover click */ lastClickTime=t; } });
        equalizer.addEventListener('click', function(e) { const t=Date.now(); if (t-lastClickTime<300) { playlistModal.classList.add('show'); renderPlaylist(); e.preventDefault(); lastClickTime=0; } else { playPause(); lastClickTime=t; } });

        // Audio element attributes
        audio.setAttribute('playsinline', ''); audio.setAttribute('webkit-playsinline', ''); audio.setAttribute('preload', 'metadata');

        // Window / Global events
        window.addEventListener('resize', fixHeight);
        window.addEventListener('beforeunload', () => { stopFaviconBlink(); if (songs[currentSongIndex] && audio.currentTime > 0 && !isResetting) { saveTrackPosition(songs[currentSongIndex].url, audio.currentTime); } savePlaylist(); });
        // window.addEventListener('error', function(e) { console.error("Global window error:", e.message, e); showNotification('Произошла общая ошибка страницы.'); return false; });
        // window.addEventListener('unhandledrejection', function(e) { console.error("Unhandled Promise Rejection:", e.reason); showNotification('Произошла внутренняя ошибка.'); });
        window.addEventListener('offline', () => showNotification('Отсутствует подключение к сети'));
        window.addEventListener('online', () => showNotification('Подключение к сети восстановлено'));

        // Click outside modals to close
        document.addEventListener('click', function(e) {
            if (playlistModal.classList.contains('show') && !e.target.closest('.modal') && !e.target.closest('#playlist-btn')) { playlistModal.classList.remove('show'); }
            if (urlModal.classList.contains('show') && !e.target.closest('.modal') && !e.target.closest('#urlBtnInPlaylist')) { urlModal.classList.remove('show'); }
            if (supabaseSelectModal.classList.contains('show') && !e.target.closest('.modal') && !e.target.closest('#loadSupabaseBtn')) { supabaseSelectModal.classList.remove('show'); }
        });
        // Prevent modal closing when clicking controls inside it
        document.querySelectorAll('.playlist-control-btn, label[for="fileInput"], .modal-footer button, #supabaseFileList').forEach(el => { el.addEventListener('click', e => e.stopPropagation()); });


    }); // --- End DOMContentLoaded ---
    </script>
</body>
</html>
                 
                 
                 
                 
                 
                 
                 
                 