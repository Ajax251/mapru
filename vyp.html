<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>Печать выписки</title>
    <script src="webfonts/jszip.min.js"></script>
    <link rel="icon" href="img/vyp.png" type="image/png">
    <script src="webfonts/proj4.js"></script>
    <script src="sk.js"></script>
    <script src="msk.js"></script>
 <style>
    :root {
        --page-width: 297mm;
        --main-font-times: "Times New Roman", Times, serif;
        --main-font-ui: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
        --font-size-normal: 10pt;
        --font-size-small: 8pt;
        --primary-blue: #4285f4;
        --primary-blue-hover: #3367d6;
        --sky-blue: #29b6f6; 
        --sky-blue-hover: #0288d1;
        --success-green: #34a853;
        --success-green-hover: #2d8f47;
        --warning-orange: #fbbc05;
        --warning-orange-hover: #f9ab00;
        --secondary-gray: #9aa0a6;
        --secondary-gray-hover: #80868b;
         --indigo: #6366f1;
        --indigo-hover: #4f46e5;
        --purple: #8b5cf6;
        --purple-hover: #7c3aed;
    }

    * { margin: 0; padding: 0; box-sizing: border-box; }
    
    body {
        font-family: var(--main-font-ui);
        margin: 0;
        background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 50%, #f1f3f4 100%);
        color: #202124;
        min-height: 100vh;
    }

    #app-container {
        display: flex;
        flex-direction: column;
        min-height: 100vh;
    }

    #start-view {
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        flex-grow: 1;
        padding: 20px;
    }

    #results-view {
        display: none;
        width: 100%;
        max-width: var(--page-width);
        margin: 0 auto;
        padding: 20px;
        box-sizing: border-box;
    }

    .glass-panel {
        background: rgba(255, 255, 255, 0.95);
        border-radius: 20px;
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.12);
        backdrop-filter: blur(10px);
        -webkit-backdrop-filter: blur(10px);
        border: 1px solid rgba(255, 255, 255, 0.8);
        position: relative;
        overflow: hidden;
    }

    .glass-panel::before {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        height: 1px;
        background: linear-gradient(90deg, transparent, rgba(66, 133, 244, 0.3), transparent);
    }

    .control-panel {
        padding: 50px 60px;
        text-align: center;
        max-width: 800px;
        width: 100%;
    }
    
    .control-panel h3 { 
        margin-top: 0; 
        margin-bottom: 15px; 
        font-size: 32px; 
        color: #202124;
        font-weight: 600;
        text-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
    }
    
    .control-panel p { 
        margin-bottom: 35px; 
        color: #5f6368;
        font-size: 18px;
        font-weight: 400;
    }
    
    .input-group { 
        display: flex; 
        flex-direction: column; 
        gap: 20px; 
    }

    #cadastralInput {
        padding: 18px 25px; 
        font-size: 20px; 
        border: 2px solid #dadce0;
        border-radius: 12px; 
        text-align: center; 
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        background: #fff;
        color: #202124;
        font-weight: 400;
    }
    
    #cadastralInput::placeholder {
        color: #9aa0a6;
        font-weight: 400;
    }
    
    #cadastralInput:focus {
        outline: none; 
        border-color: var(--primary-blue);
        background: #fff;
        box-shadow: 0 0 0 4px rgba(66, 133, 244, 0.15);
        transform: translateY(-2px);
    }
    
    .button-row { 
        display: grid; 
        grid-template-columns: 1fr 1fr; 
        gap: 20px; 
    }

    .control-panel .button {
        padding: 18px 25px; 
        border-radius: 12px; 
        border: none; 
        color: white;
        cursor: pointer; 
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1); 
        text-align: center;
        font-size: 16px; 
        font-weight: 600; 
        display: flex; 
        align-items: center; 
        justify-content: center; 
        gap: 10px;
        position: relative;
        overflow: hidden;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
    }

    .control-panel .button:nth-child(1) {
        background: linear-gradient(135deg, var(--primary-blue) 0%, #5a9fd4 100%);
    }

    .control-panel .button:nth-child(2) {
        background: linear-gradient(135deg, var(--sky-blue) 0%, #81d4fa 100%);
    }

    #xmlFileInputLabel {
        background: linear-gradient(135deg, var(--indigo) 0%, #818cf8 100%);
        grid-column: 1 / -1;
    }
    
    .control-panel .button::before {
        content: '';
        position: absolute;
        top: 0;
        left: -100%;
        width: 100%;
        height: 100%;
        background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
        transition: left 0.5s;
    }
    
    .control-panel .button:hover::before {
        left: 100%;
    }
    
    .control-panel .button:hover {
        transform: translateY(-3px) scale(1.02);
        box-shadow: 0 6px 20px rgba(0, 0, 0, 0.2);
    }

    .control-panel .button:nth-child(1):hover {
        background: linear-gradient(135deg, var(--primary-blue-hover) 0%, #4a8bc2 100%);
    }

    .control-panel .button:nth-child(2):hover {
        background: linear-gradient(135deg, var(--sky-blue-hover) 0%, #29b6f6 100%);
    }

   #xmlFileInputLabel:hover {
        background: linear-gradient(135deg, var(--indigo-hover) 0%, #6366f1 100%);
    }
    
    .control-panel input[type="file"] { 
        display: none; 
    }
    
    #action-buttons {
        display: flex; 
        justify-content: center; 
        gap: 15px;
        margin-bottom: 25px; 
        flex-wrap: wrap;
    }

    #action-buttons button {
        padding: 12px 24px; 
        border-radius: 10px; 
        border: none; 
        color: white;
        cursor: pointer; 
        font-size: 16px;
        font-weight: 500;
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1); 
        display: inline-flex; 
        align-items: center;
        justify-content: center; 
        gap: 8px; 
        position: relative;
        overflow: hidden;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
    }

    #action-buttons button:nth-child(1) {
        background: linear-gradient(135deg, var(--purple) 0%, #a855f7 100%);
    }

    #action-buttons button:nth-child(1):hover {
        background: linear-gradient(135deg, var(--purple-hover) 0%, #9333ea 100%);
    }
    #action-buttons button:nth-child(2) {
        background: linear-gradient(135deg, var(--primary-blue) 0%, #5a9fd4 100%);
    }

    #action-buttons button:nth-child(3) {
        background: linear-gradient(135deg, var(--success-green) 0%, #4caf50 100%);
    }
    
    #action-buttons button:nth-child(4) {
    background: linear-gradient(135deg, var(--warning-orange) 0%, #ffca28 100%);
}

#action-buttons button:nth-child(4):hover {
    background: linear-gradient(135deg, var(--warning-orange-hover) 0%, #f9a825 100%);
}

    #action-buttons button::before {
        content: '';
        position: absolute;
        top: 0;
        left: -100%;
        width: 100%;
        height: 100%;
        background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
        transition: left 0.5s;
    }
    
    #action-buttons button:hover::before {
        left: 100%;
    }
    
    #action-buttons button:hover {
        transform: translateY(-3px) scale(1.05);
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
    }


    #action-buttons button:nth-child(2):hover {
        background: linear-gradient(135deg, var(--primary-blue-hover) 0%, #4a8bc2 100%);
    }

    #action-buttons button:nth-child(3):hover {
        background: linear-gradient(135deg, var(--success-green-hover) 0%, #45a049 100%);
    }
    
    .page {
        font-family: var(--main-font-times); 
        font-size: var(--font-size-normal);
        background: white; 
        border-radius: 8px; 
        box-shadow: 0 4px 16px rgba(0, 0, 0, 0.1);
        margin-top: 25px; 
        padding: 20mm; 
        box-sizing: border-box;
        position: relative;
        border: 1px solid #e8eaed;
    }
    
    table { 
        width: 100%; 
        border-collapse: collapse; 
        margin-top: 8px; 
        margin-bottom: 12px; 
    }
    
    th, td { 
        border: 1px solid #333; 
        padding: 6px 8px; 
        text-align: left; 
        vertical-align: top; 
        word-break: break-word; 
    }
    
    th {
        background-color: #f8f9fa;
        font-weight: 600;
    }
    
    .main-info-table td:first-child { 
        width: 40%; 
        font-weight: bold; 
        background-color: #f8f9fa;
    }
    
    .plan-container { 
        border: 2px solid #333; 
        margin-top: 15px; 
        padding: 15px; 
        box-sizing: border-box; 
        min-height: 500px; 
        display: flex; 
        align-items: center; 
        justify-content: center;
        background-color: #fafafa;
        border-radius: 4px;
    }
    
    canvas { 
        max-width: 100%; 
        max-height: 100%; 
        border-radius: 4px;
    }
    
    .coordinates-table th, .coordinates-table td { 
        text-align: center; 
    }
    
    .header-line { 
        display: flex; 
        justify-content: space-between; 
        align-items: flex-start; 
        margin-bottom: 12px; 
    }
    
    .main-header { 
        text-align: center; 
        margin-bottom: 20px; 
    }
    
    .main-header .title-underline { 
        font-size: var(--font-size-small); 
        border-bottom: 1px solid black; 
        display: inline-block; 
        margin: 5px 0; 
        padding: 0 20px; 
    }
    
    .section-title { 
        text-align: center; 
        font-weight: bold; 
        margin: 15px 0 5px 0; 
        padding: 0; 
    }
    
    .section-subtitle { 
        text-align: center; 
        font-size: var(--font-size-small); 
        margin: 0 0 12px 0; 
        padding: 0; 
    }
    
    .info-block { 
        border: 1px solid #dadce0; 
        padding: 12px; 
        margin-top: 18px; 
        border-radius: 6px; 
        background-color: #fafafa;
    }

    .modal-overlay {
        position: fixed; 
        top: 0; 
        left: 0; 
        width: 100%; 
        height: 100%;
        background-color: rgba(0, 0, 0, 0.4);
        backdrop-filter: blur(4px);
        -webkit-backdrop-filter: blur(4px); 
        display: flex;
        justify-content: center; 
        align-items: center; 
        z-index: 1000;
        transition: opacity 0.3s ease;
    }
    
    .modal-dialog {
        background: rgba(255, 255, 255, 0.98);
        backdrop-filter: blur(10px);
        padding: 0;
        width: 90%; 
        max-width: 700px; 
        max-height: 85vh;
        display: flex; 
        flex-direction: column;
        border-radius: 16px;
        box-shadow: 0 12px 36px rgba(0, 0, 0, 0.15);
        overflow: hidden;
        border: 1px solid #e8eaed;
    }
    
    .modal-dialog h3 {
        margin: 0;
        padding: 25px 30px;
        color: #202124;
        font-size: 1.4em;
        font-weight: 600;
        background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
        border-bottom: 1px solid #dadce0;
    }
    
    #object-filter-input {
        display: block;
        width: calc(100% - 60px);
        margin: 20px 30px 10px 30px;
        padding: 15px 20px;
        font-size: 16px;
        border: 2px solid #dadce0;
        border-radius: 10px;
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        text-align: center;
        background: #fff;
    }
    
    #object-filter-input:focus {
        outline: none;
        border-color: var(--primary-blue);
        background: #fff;
        box-shadow: 0 0 0 4px rgba(66, 133, 244, 0.15);
        transform: translateY(-1px);
    }
    
    .modal-list {
        list-style: none; 
        padding: 0 20px 20px 20px;
        margin: 0; 
        overflow-y: auto;
    }
    
    .modal-list::-webkit-scrollbar { 
        width: 8px; 
    }
    
    .modal-list::-webkit-scrollbar-track { 
        background: #f1f3f4; 
        border-radius: 4px;
    }
    
    .modal-list::-webkit-scrollbar-thumb { 
        background: var(--primary-blue); 
        border-radius: 4px; 
    }
    
    .modal-list::-webkit-scrollbar-thumb:hover { 
        background: var(--primary-blue-hover); 
    }
    
    .modal-list li {
        padding: 16px 20px;
        border-bottom: none;
        border-radius: 8px;
        margin-top: 8px;
        cursor: pointer; 
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        display: flex; 
        justify-content: space-between; 
        align-items: center;
        font-size: 16px;
        background: #fff;
        border: 1px solid #e8eaed;
    }

    .modal-list li span:first-child {
        flex-grow: 1;
        text-align: center;
        margin-right: 15px;
        font-weight: 500;
        color: #202124;
    }

    .modal-list li:hover {
        background: #f8f9fa;
        transform: translateY(-1px);
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        border-color: var(--primary-blue);
    }
    
    .modal-list .obj-type {
        color: var(--primary-blue);
        font-size: 0.85em;
        font-weight: 600;
        background: rgba(66, 133, 244, 0.1);
        padding: 6px 12px; 
        border-radius: 6px;
        min-width: 90px;
        text-align: center;
        border: 1px solid rgba(66, 133, 244, 0.2);
    }

   #loader { 
    text-align: center; 
    padding: 30px; 
    font-size: 1.3em; 
    display: none;
    color: #5f6368;
    background: rgba(255, 255, 255, 0.9);
    border-radius: 12px;
    backdrop-filter: blur(10px);
    box-shadow: 0 4px 16px rgba(0, 0, 0, 0.1);
    flex-direction: column;
    align-items: center;
    justify-content: center;
    gap: 20px;
}


.spinner {
    width: 60px;
    height: 60px;
    border: 6px solid rgba(66, 133, 244, 0.2);
    border-top-color: var(--primary-blue);
    border-radius: 50%;
    animation: spin 1s linear infinite;
}

#loader p {
    margin: 0;
    font-weight: 500;
}

@keyframes spin {
    to { transform: rotate(360deg); }
}
    
    .error { 
        color: #d93025; 
        padding: 15px; 
        background: linear-gradient(135deg, #fce8e6 0%, #f9dedc 100%); 
        border: 2px solid #f9dedc; 
        border-radius: 8px; 
        margin-top: 15px;
        font-weight: 500;
        box-shadow: 0 2px 8px rgba(217, 48, 37, 0.15);
    }
    
.merge-control { 
    position: absolute; 
    bottom: 10px; 
    right: 20mm; 
    z-index: 10; 
}

.merge-control button { 
    color: white; 
    border: none; 
    padding: 8px 15px; 
    border-radius: 6px; 
    cursor: pointer; 
    font-size: 10pt; 
    font-family: var(--main-font-ui);
    font-weight: 500;
    opacity: 0; 
    transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    background: linear-gradient(135deg, var(--purple) 0%, #a855f7 100%);
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
    display: inline-flex;
    align-items: center;
    gap: 8px;
}
    
.page:hover .merge-control button { 
    opacity: 1; 
}

.merge-control button:hover { 
    background: linear-gradient(135deg, var(--purple-hover) 0%, #9333ea 100%);
    transform: translateY(-2px) scale(1.05);
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
}
    .page.no-break { 
        margin-bottom: 2px; 
        border-bottom-left-radius: 0; 
        border-bottom-right-radius: 0; 
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08); 
    }
    
    .page.no-break + .page { 
        margin-top: 0; 
        border-top-left-radius: 0; 
        border-top-right-radius: 0; 
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08); 
    }

    @media print {
          @page {
        size: landscape;
    }
        body * { visibility: hidden; }
        #report-output, #report-output * { visibility: visible; }
        #report-output { position: absolute; left: 0; top: 0; width: 100%; margin: 0; padding: 0; }
        .page { box-shadow: none; border-radius: 0; margin: 0; padding: 15mm; page-break-after: always; }
        #start-view, #results-view #action-buttons { display: none !important; }
        .merge-control { display: none !important; }
        .page.no-break { page-break-after: avoid !important; margin-bottom: 0; border-radius: 0; box-shadow: none; }
        .page.no-break + .page { margin-top: 0; border-radius: 0; box-shadow: none; }
    }
    
    @media (max-width: 768px) {
        body {
            font-size: 14px;
        }

        .control-panel {
            padding: 25px 15px;
            border-radius: 0;
            border: none;
            box-shadow: none;
            background: transparent;
        }

        .control-panel h3 {
            font-size: 24px;
        }

        .control-panel p {
            font-size: 16px;
            margin-bottom: 25px;
        }

        .button-row {
            grid-template-columns: 1fr;
        }

        #results-view {
            padding: 10px 5px;
        }
        
        #action-buttons {
            gap: 8px;
            justify-content: center;
        }
        
        #action-buttons button {
            padding: 10px 14px;
            font-size: 14px;
        }

        .page {
            padding: 15px;
            margin-top: 15px;
            border-radius: 12px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        .main-info-table tr {
            border-bottom: 1px solid #e0e0e0;
        }
        .main-info-table td {
            display: block;
            width: 100%;
            border: none;
        }
        .main-info-table td:first-child {
            width: 100%;
            background-color: transparent;
            font-weight: bold;
            padding-bottom: 2px;
        }
        .main-info-table td:last-child {
            padding-top: 0;
            padding-left: 8px;
        }

        .plan-container {
            min-height: 250px;
            padding: 8px;
        }
        
        th, td {
            padding: 6px;
        }
        
        .header-line, .section-title {
            font-size: 1.1em;
        }

        .modal-dialog {
            width: 95%;
            max-height: 85vh;
        }
        .modal-dialog h3 {
            font-size: 1.2em;
            padding: 20px 15px;
        }
        #object-filter-input {
            width: calc(100% - 30px);
            margin: 15px 15px 10px 15px;
            padding: 12px;
        }
        .modal-list li {
            flex-direction: column;
            align-items: flex-start;
            gap: 8px;
            padding: 12px 15px;
        }
        .modal-list .obj-type {
            align-self: flex-start;
        }
    }
</style>
</head>
<body>
    <div id="app-container">
        <div id="start-view">
            <div class="control-panel glass-panel">
                <h3>Печать выписки ЕГРН</h3>
                <p>Введите кадастровый номер или загрузите файл XML</p>
                <div class="input-group">
                    <input type="text" id="cadastralInput" placeholder="XX:XX:XXXXXXX:XX">
                    <div class="button-row">
    <button class="button" onclick="fetchFromNspd()">
        <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/>
            <polyline points="14 2 14 8 20 8"/>
            <line x1="16" y1="13" x2="8" y2="13"/>
            <line x1="16" y1="17" x2="8" y2="17"/>
            <polyline points="10 9 9 9 8 9"/>
        </svg>
        Сведения из ЕГРН
    </button>
    <button class="button" onclick="fetchFromKptArchive()">
        <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <path d="M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z"/>
            <polyline points="3.27 6.96 12 12.01 20.73 6.96"/>
            <line x1="12" y1="22.08" x2="12" y2="12"/>
        </svg>
        Сведения из архива КПТ
    </button>
</div>
<label for="xmlFileInput" id="xmlFileInputLabel" class="button">
    <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
        <polyline points="17 8 12 3 7 8"/>
        <line x1="12" y1="3" x2="12" y2="15"/>
    </svg>
    Открыть XML
</label>
                    <input type="file" id="xmlFileInput" accept=".xml,.zip" onchange="handleFileSelect(event)">
                </div>
            </div>
        </div>
        <div id="results-view">
            <div id="action-buttons">
                 <button onclick="showStartView()">
                    <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M19 12H5M12 19l-7-7 7-7"/></svg>
                    <span>Назад</span>
                </button>
                <button id="selectObjectBtn" onclick="reShowObjectSelectionDialog()" style="display: none;">
                     <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 3h7v7H3zM14 3h7v7h-7zM14 14h7v7h-7zM3 14h7v7H3z"/></svg>
                    <span>Выбрать объект</span>
                </button>
                <button onclick="window.print()">
                    <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="6 9 6 2 18 2 18 9"></polyline><path d="M6 18H4a2 2 0 0 1-2-2v-5a2 2 0 0 1 2-2h16a2 2 0 0 1 2 2v5a2 2 0 0 1-2 2h-2"></path><rect x="6" y="14" width="12" height="8"></rect></svg>
                    <span>Печать</span>
                </button>
                  <button id="convertToMskBtn" style="display: none;">
        <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="14.5 10.5 12 8 9.5 10.5"></polyline><polyline points="9.5 13.5 12 16 14.5 13.5"></polyline><path d="M20.49 9A9 9 0 0 0 5.64 5.64L1 10m22 4l-4.64 4.36A9 9 0 0 1 3.51 15"></path></svg>
        <span>Координаты в МСК</span>
    </button>
            </div>
           <div id="loader">
    <div class="spinner"></div>
    <p id="loader-text">Загрузка данных...</p>
</div>
            <div id="report-output"></div>
        </div>
    </div>
    <script>
    let loadedKptData = { xmlString: null, fileName: null, objectList: [], title: null };
    const sixDigitsRegions = ['02', '03', '04', '05', '08', '15', '16', '18', '19', '21', '22', '25', '26', '28', '30', '33', '34', '37', '38', '39', '40', '43', '44', '45', '46', '54', '55', '73', '75', '76', '91', '92'];
    
    
    const colorPalettes = [
    ['#667eea', '#764ba2'],
    ['#f093fb', '#f5576c'],
    ['#4facfe', '#00f2fe'],
    ['#43e97b', '#38f9d7'],
    ['#fa709a', '#fee140'],
    ['#a8edea', '#fed6e3'],
    ['#ff9a9e', '#fecfef'],
    ['#a18cd1', '#fbc2eb'],
    ['#fad0c4', '#ffd1ff'],
    ['#ff8a80', '#ffb74d'],
    ['#81c784', '#aed581'],
    ['#64b5f6', '#42a5f5']
];



function showStartView() {
    document.getElementById('start-view').style.display = 'flex';
    document.getElementById('results-view').style.display = 'none';
    document.getElementById('report-output').innerHTML = '';
   loadedKptData = { xmlString: null, fileName: null, objectList: [], title: null };
    document.getElementById('selectObjectBtn').style.display = 'none';
}

function showResultsView() {
    document.getElementById('start-view').style.display = 'none';
    document.getElementById('results-view').style.display = 'block';
}

    function showLoader(show) { document.getElementById('loader').style.display = show ? 'block' : 'none'; }
    
    function displayError(error, isFatal = false) {
        const output = document.getElementById('report-output');
        output.innerHTML = `<div class="error"><strong>Ошибка:</strong> ${error.message}</div>`;
        if(!isFatal) showResultsView();
    }
    
async function handleFileSelect(event) {
    const file = event.target.files[0]; if (!file) return;
    resetAndShowLoader();
    try {
        let xmlString, fileName = file.name;
        if (file.name.toLowerCase().endsWith('.zip')) {
            const zip = await JSZip.loadAsync(await file.arrayBuffer());
            const xmlFile = Object.values(zip.files).find(f => f.name.toLowerCase().endsWith('.xml'));
            if (!xmlFile) throw new Error("XML-файл не найден в архиве.");
            xmlString = await xmlFile.async("string");
            fileName = xmlFile.name;
        } else { xmlString = await file.text(); }
        const parser = new DOMParser();
        const xmlDoc = parser.parseFromString(xmlString, "text/xml");
   const reportTitle = createTitleFromXml(xmlDoc, fileName);

        const records = xmlDoc.querySelectorAll('land_record, build_record, construction_record');
        if (records.length > 1) {
            showLoader(false);
            extractAndShowObjectList(xmlString, records, fileName, reportTitle);
            document.getElementById('selectObjectBtn').style.display = 'inline-flex';
        } else {
            const { data, isKptFile } = parseXml(xmlString);
            displayResults(data, reportTitle, isKptFile);
            showResultsView();
        }
    } catch (error) { displayError(error, true); }
    finally { if (document.querySelectorAll('.modal-overlay').length === 0) showLoader(false); event.target.value = null; }
}
    
    
    function updateLoaderText(text) {
    const loaderTextElement = document.getElementById('loader-text');
    if (loaderTextElement) {
        loaderTextElement.textContent = text;
    }
}


async function fetchFromKptArchive() {
    const cadNum = document.getElementById('cadastralInput').value.trim();
    if (!cadNum) { alert("Введите кадастровый номер."); return; }
       const cadParts = cadNum.split(':');
    if (cadParts.length >= 3 && parseInt(cadParts[2], 10) === 0) {
        alert("Загрузка данных по нулевому кварталу из архива не поддерживается, так как это может привести к зависанию браузера из-за большого объема данных");
        return;
    }
    resetAndShowLoader();
    try {
        updateLoaderText('Идет поиск файлов КПТ...');
        const quarterNum = cadNum.split(':').slice(0, 3).join(':');
        const searchPrefix = quarterNum.replace(/:/g, '_');

        let listResponse;
        try {
            listResponse = await fetch(`https://mapruapp.ru/storage/kpt?search=${searchPrefix}`);
        } catch (error) {
            if (error.message === "Failed to fetch") {
                throw new Error("нет ответа");
            }
            throw error;
        }

        if (!listResponse.ok) throw new Error(`Ошибка получения списка файлов для квартала ${quarterNum}.`);
        const fileList = await listResponse.json();
        if (!fileList || fileList.length === 0) throw new Error(`Архивы КПТ для квартала ${quarterNum} не найдены.`);

        updateLoaderText('Найден КПТ. Загружаем...');
        const latestFile = fileList.map(file => ({ name: file.name, date: new Date(file.name.match(/(\d{4}-\d{2}-\d{2})/)?.[1] || 0) })).sort((a, b) => b.date - a.date)[0];
        if (!latestFile) throw new Error("Не удалось определить последний файл КПТ.");

        let zipResponse;
        try {
            zipResponse = await fetch(`https://mapruapp.ru/storage/kpt/${latestFile.name}`);
        } catch (error) {
            if (error.message === "Failed to fetch") {
                throw new Error("Ошибка запроса");
            }
            throw error;
        }

        if (!zipResponse.ok) throw new Error(`Не удалось загрузить архив ${latestFile.name}.`);


        updateLoaderText('Распаковываем архив и ищем XML...');
        const zip = await JSZip.loadAsync(await zipResponse.blob());
        const xmlFile = Object.values(zip.files).find(f => f.name.toLowerCase().endsWith('.xml'));
        if (!xmlFile) throw new Error("XML-файл не найден в архиве КПТ.");

        updateLoaderText('Извлечение данных. Почти готово...');
        const xmlString = await xmlFile.async("string");
        const parser = new DOMParser();
        const xmlDoc = parser.parseFromString(xmlString, "text/xml");
        const reportTitle = createTitleFromXml(xmlDoc, latestFile.name);

        const isSpecificObject = cadParts.length > 3 && cadParts[3] !== '';

        if (isSpecificObject) {
            updateLoaderText('Поиск объекта в архиве...');
            const { data, isKptFile } = parseXml(xmlString, cadNum);
            displayResults(data, reportTitle, isKptFile);
            showResultsView();
            document.getElementById('selectObjectBtn').style.display = 'none';
        } else {
            const records = xmlDoc.querySelectorAll('land_record, build_record, construction_record');
            if (records.length > 0) {
                showResultsView();
                showLoader(false);
                extractAndShowObjectList(xmlString, records, latestFile.name, reportTitle);
                document.getElementById('selectObjectBtn').style.display = 'inline-flex';
            } else {
                throw new Error(`В найденном архиве КПТ (${latestFile.name}) не найдено объектов для отображения.`);
            }
        }

    } catch (error) {
        displayError(error);
    }
    finally {
        if (document.querySelectorAll('.modal-overlay').length === 0) {
            showLoader(false);
        }
        updateLoaderText('Поиск данных...');
    }
}
    
function createTitleFromXml(xmlDoc, fallbackFileName) {
    const regNum = getValue(xmlDoc, 'registration_number');
    const regDateRaw = getValue(xmlDoc, 'date_receipt_request_reg_authority_rights') || getValue(xmlDoc, 'date_formation');
    const regDate = formatDate(regDateRaw);

    if (regNum && regDate) {
        return `${regNum} от ${regDate}`;
    } else {
        return `Данные из файла: ${fallbackFileName}`;
    }
}
    
async function fetchFromNspd() {
    const cadNum = document.getElementById('cadastralInput').value.trim();
    if (!cadNum) { alert("Введите кадастровый номер."); return; }

    resetAndShowLoader();
    try {
        updateLoaderText('Поиск объекта ...');
        const data = await getNspdData(cadNum);

        updateLoaderText('Получаем ответ. Обрабатываем данные...');
        const formattedDate = new Date().toLocaleDateString('ru-RU');
        displayResults(data, `Сведения из ЕГРН от ${formattedDate} (EPSG:3857)`);
        showResultsView();
    } catch (error) {
        displayError(error);
    }
    finally {
        showLoader(false);
        updateLoaderText('Загрузка данных...');
    }
}

function resetAndShowLoader() {
    document.getElementById('report-output').innerHTML = '';
    showResultsView();
    showLoader(true);
}

function reShowObjectSelectionDialog() {
            if (loadedKptData && loadedKptData.objectList.length > 0) {
        const { xmlString, fileName, objectList, title } = loadedKptData;
        const overlay = document.createElement('div');
            overlay.className = 'modal-overlay';
            const dialog = document.createElement('div');
            dialog.className = 'modal-dialog'; 
            
            dialog.innerHTML = `
                <h3>Выберите объект из файла "${fileName}" (${objectList.length} шт.)</h3>
                <input type="text" id="object-filter-input" onkeyup="filterObjectList(this)" placeholder="Фильтр по кадастровому номеру...">
            `;
            
            const list = document.createElement('ul');
            list.className = 'modal-list';
            objectList.forEach(obj => {
                const listItem = document.createElement('li');
                listItem.innerHTML = `<span>${obj.cadNum}</span><span class="obj-type">${obj.type}</span>`;
                listItem.onclick = () => {
                    document.body.removeChild(overlay); resetAndShowLoader();
                    setTimeout(() => {
                        try {
                            const { data, isKptFile } = parseXml(xmlString, obj.cadNum);
                             displayResults(data, title, isKptFile);
                            showResultsView();
                        } catch (e) { displayError(e); } 
                        finally { showLoader(false); }
                    }, 10);
                };
                list.appendChild(listItem);
            });
            dialog.appendChild(list); 
            overlay.appendChild(dialog); 
            document.body.appendChild(overlay);
            overlay.onclick = (e) => { if (e.target === overlay) document.body.removeChild(overlay); };
            
            document.getElementById('object-filter-input').focus();
        } else {
            alert("Нет данных о загруженном файле для выбора объекта.");
        }
    }

 function filterObjectList(input) {
        const filterText = input.value.trim();
        const list = document.querySelector('.modal-list');
        const items = list.getElementsByTagName('li');

        const isDigitsOnly = /^\d+$/.test(filterText);

        for (let i = 0; i < items.length; i++) {
            const item = items[i];
            const itemText = item.querySelector('span:first-child').textContent || item.querySelector('span:first-child').innerText;
            
            let isMatch = false;

            if (filterText === '') {
                isMatch = true;
            } 
            else if (isDigitsOnly) {
                isMatch = itemText.endsWith(':' + filterText);
            } 
            else {
                isMatch = itemText.toLowerCase().includes(filterText.toLowerCase());
            }

            if (isMatch) {
                item.style.display = "flex";
            } else {
                item.style.display = "none";
            }
        }
    }
    
    
function extractAndShowObjectList(xmlString, records, fileName, title) {
    const objectList = [];
    const typeMap = { 'land_record': 'ЗУ', 'build_record': 'Здание', 'construction_record': 'Сооружение' };
    records.forEach(record => {
        const cadNum = getValue(record, 'object > common_data > cad_number');
        const type = typeMap[record.tagName] || 'Объект';
        if (cadNum) objectList.push({ cadNum, type });
    });
    loadedKptData = { xmlString, fileName, objectList, title };
    reShowObjectSelectionDialog();
}

    
  function createDataObject() { return { common: {}, params: {}, rights: [], restrictions: [], coordinates: [], coordinatesSystem: '', source: '', links: {} }; }
    function getValue(node, selector, d = '') { return (node.querySelector(selector)?.textContent || d).trim(); }
    function formatDate(d) { return d ? new Date(d).toLocaleDateString('ru-RU') : ''; }
    function formatDateTime(d) { return d ? new Date(d).toLocaleString('ru-RU') : ''; }
    function getShare(node) { if (!node) return ''; const share = node.querySelector('share'); return share ? `${getValue(share, 'numerator')}/${getValue(share, 'denominator')}` : getValue(node, 'share_description', ''); }
    function generateTableRow(key, value) { return value ? `<tr><td>${key}</td><td>${value}</td></tr>` : ''; }

async function getNspdData(cadNum) {
    try {
        const response = await fetch(`https://nspd.gov.ru/api/geoportal/v2/search/geoportal?thematicSearchId=1&query=${encodeURIComponent(cadNum)}`);
        if (!response.ok) throw new Error("Ошибка запроса");
        const json = await response.json();
        if (!json.data || !json.data.features.length === 0) throw new Error("Объект не найден в ЕГРН");
        return await parseNspdJson(json.data.features[0]);
    } catch (error) {
        if (error.message === "Failed to fetch") {
            throw new Error("Ошибка запроса");
        }
        throw error;
    }
}
    
function parseXml(xmlString, targetCadNum = null) {
    const parser = new DOMParser();
    const xmlDoc = parser.parseFromString(xmlString, "text/xml");
    if (xmlDoc.querySelector('parsererror')) {
        throw new Error('Ошибка парсинга XML-файла.');
    }

    const isKptFile = xmlDoc.querySelector('extract_cadastral_plan_territory') !== null;

    let mainRecordNode;
    const allRecords = xmlDoc.querySelectorAll('land_record, build_record, construction_record');

    if (targetCadNum) {
        mainRecordNode = Array.from(allRecords).find(r => getValue(r, 'object > common_data > cad_number') === targetCadNum);
    } else {
        mainRecordNode = allRecords[0];
    }

    if (!mainRecordNode) {
        throw new Error(`Объект ${targetCadNum || ''} не найден в XML.`);
    }

    const data = createDataObject();
    const objectTypeRaw = getValue(mainRecordNode, 'object > common_data > type > value');
    data.common.organ = getValue(xmlDoc, 'organ_registr_rights');
    data.common.docDate = formatDate(getValue(xmlDoc, 'date_formation'));
    data.common.docNum = getValue(xmlDoc, 'registration_number');
    data.common.cadNum = getValue(mainRecordNode, 'object > common_data > cad_number');
    data.common.assignDate = formatDate(getValue(mainRecordNode, 'record_info > registration_date'));
    data.common.objType = {
        'land_record': 'Земельный участок',
        'build_record': 'Здание',
        'construction_record': 'Сооружение'
    }[mainRecordNode.tagName] || objectTypeRaw;
    data.common.location = getValue(mainRecordNode, 'address_location > address > readable_address');
    data.common.cost = getValue(mainRecordNode, 'cost > value');
    data.common.status = getValue(xmlDoc, 'status');

    if (mainRecordNode.tagName === 'land_record') {
        data.params['Площадь'] = `${getValue(mainRecordNode, 'area > value')} ± ${getValue(mainRecordNode, 'area > inaccuracy')} кв. м.`;
        data.params['Категория земель'] = getValue(mainRecordNode, 'params > category > type > value');
        data.params['Разрешенное использование'] = getValue(mainRecordNode, 'params > permitted_use > permitted_use_established > by_document');
    } else {
        data.params['Назначение'] = getValue(mainRecordNode, 'params > purpose > value') || getValue(mainRecordNode, 'params > purpose');
        data.params['Наименование'] = getValue(mainRecordNode, 'params > name');
        if (mainRecordNode.tagName === 'build_record') {
            data.params['Площадь'] = `${getValue(mainRecordNode, 'params > area')} кв. м.`;
        }
        if (mainRecordNode.tagName === 'construction_record') {
            const extension = getValue(mainRecordNode, 'params > base_parameter > extension') || getValue(mainRecordNode, 'params > base_parameters > base_parameter > extension');
            if (extension) {
                data.params['Протяженность'] = `${extension} м.`;
            }
        }
    }

    const recordCadNum = data.common.cadNum;

    xmlDoc.querySelectorAll(`right_record`).forEach(rec => {
        const objectCadNumInRight = getValue(rec, 'object_cad_number');
        if (!isKptFile || objectCadNumInRight === recordCadNum || !objectCadNumInRight) {
            const holderNode = rec.querySelector('right_holders > right_holder');
            let holderName = [getValue(holderNode, 'individual surname'), getValue(holderNode, 'individual name'), getValue(holderNode, 'individual patronymic')].filter(Boolean).join(' ').trim() || getValue(holderNode, 'legal_entity name') || getValue(holderNode, 'public_formation municipality name') || 'не определено';
            data.rights.push({
                holder: holderName,
                type: getValue(rec, 'right_data > right_type > value'),
                number: getValue(rec, 'right_data > right_number'),
                date: formatDateTime(getValue(rec, 'record_info > registration_date')),
                share: getShare(rec.querySelector('right_data'))
            });
        }
    });

    xmlDoc.querySelectorAll(`restrict_record`).forEach(rec => {
        const objectCadNumInRestriction = getValue(rec, 'object_cad_number');
        if (!isKptFile || objectCadNumInRestriction === recordCadNum || !objectCadNumInRestriction) {
            const docNode = rec.querySelector('underlying_documents > underlying_document');
            data.restrictions.push({
                type: getValue(rec, 'restrictions_encumbrances_data > restriction_encumbrance_type > value'),
                number: getValue(rec, 'restrictions_encumbrances_data > restriction_encumbrance_number'),
                date: formatDateTime(getValue(rec, 'record_info > registration_date')),
                basis: docNode ? `${getValue(docNode, 'document_name')} №${getValue(docNode, 'document_number')} от ${formatDate(docNode, 'document_date')}` : ''
            });
        }
    });

    // --- НАЧАЛО ИСПРАВЛЕННОГО БЛОКА ОБРАБОТКИ КООРДИНАТ ---
    const contoursNode = mainRecordNode.querySelector(':scope > contours_location, :scope > contours');

    data.coordinatesSystem = '';

    if (contoursNode) {
        data.coordinatesSystem = getValue(contoursNode, 'entity_spatial sk_id');

        // В КПТ каждый <spatial_element> представляет собой отдельный контур.
        // Ищем все такие элементы внутри найденного контейнера геометрии.
        const allSpatialElements = contoursNode.querySelectorAll('spatial_element, Spatial_Element');

        allSpatialElements.forEach((spatialElement, contourIndex) => {
            const currentContourCoordinates = [];
            
            spatialElement.querySelectorAll('ordinate, Ordinate').forEach(ord => {
                currentContourCoordinates.push({
                    x: parseFloat(getValue(ord, 'x, X')),
                    y: parseFloat(getValue(ord, 'y, Y')),
                    // Номер точки берем из XML (ord_nmb), он уникален внутри spatial_element
                    num: getValue(ord, 'ord_nmb, Num_Geopoint', ''),
                    delta: getValue(ord, 'delta_geopoint, Delta_Geopoint', ''),
                    zacrep: getValue(ord, 'geopoint_zacrep, Geopoint_Zacrep', ''),
                    // Номер контура - это порядковый номер <spatial_element>
                    contour: contourIndex + 1 
                });
            });

            if (currentContourCoordinates.length > 0) {
                data.coordinates.push(currentContourCoordinates);
            }
        });
    }
    // --- КОНЕЦ ИСПРАВЛЕННОГО БЛОКА ---

    data.source = 'xml';
    return { data, isKptFile };
}

async function parseNspdJson(feature) {
    const options = feature.properties.options || {}; 
    const data = createDataObject();
    data.common.cadNum = options.cad_num || options.cad_number; 
    data.common.objType = feature.properties.categoryName;
    data.common.location = options.readable_address || options.address_readable_address; 
    data.common.cost = options.cost_value;
    data.common.status = options.status; 
    data.common.assignDate = formatDate(options.land_record_reg_date || options.registration_date || options.build_record_registration_date);
    
    if (data.common.objType === "Земельные участки ЕГРН") {
        let areaText = ''; 
        if (options.specified_area) areaText = `${options.specified_area} м² (уточненная)`; 
        else if (options.declared_area) areaText = `${options.declared_area} м² (декларированная)`;
        data.params['Площадь'] = areaText; 
        data.params['Категория земель'] = options.land_record_category_type; 
        data.params['Разрешенное использование'] = options.permitted_use_established_by_document;
        data.links['ОКС на земельном участке'] = await fetchLinkedObjects(feature);
    } else {
        data.params['Назначение'] = options.purpose || options.params_purpose; 
        data.params['Наименование'] = options.name || options.building_name || options.params_name;
        if (options.area) data.params['Площадь'] = `${options.area} м²`; 
        if (options.params_extension) data.params['Протяженность'] = `${options.params_extension} м`;
        data.links['Расположен на ЗУ'] = await fetchLinkedObjects(feature);
    }
    
    data.coordinatesSystem = 'EPSG:3857';
    
    if (feature.geometry) {
        const extractCoords = (geom) => {
            if (!geom) return; 
            let contourCounter = 1; 
            if (geom.type === 'Polygon') { 
                geom.coordinates.forEach(ring => { 
                    data.coordinates.push(ring.map((c, i) => ({ x: c[0], y: c[1], num: i + 1, contour: contourCounter }))); 
                    contourCounter++; 
                }); 
            } else if (geom.type === 'MultiPolygon') { 
                geom.coordinates.forEach(poly => { 
                    data.coordinates.push(poly[0].map((c, i) => ({ x: c[0], y: c[1], num: i + 1, contour: contourCounter }))); 
                    contourCounter++; 
                }); 
            } else if (geom.type === 'LineString') { 
                data.coordinates.push(geom.coordinates.map((c, i) => ({ x: c[0], y: c[1], num: i + 1, contour: 1 }))); 
            }
        }; 
        extractCoords(feature.geometry);
    }
    data.source = 'nspd'; 
    return data;
}
    
function displayResults(data, title, isKptFile = false) {
    const output = document.getElementById('report-output');
    const pages = []; 

    const statementTitle = isKptFile 
        ? 'КПТ из Единого государственного реестра недвижимости' 
        : 'Выписка из Единого государственного реестра недвижимости об объекте недвижимости';

    const page1Html = `
        <div class="main-header">
            <div>${data.common.organ || 'Филиал ППК "Роскадастр"'}</div>
            <div class="title-underline">полное наименование органа регистрации прав</div>
            <h3>${statementTitle}</h3>
            <h4>${title}</h4>
        </div>
        <div class="header-line"><span><b>Раздел 1. Сведения о характеристиках объекта недвижимости</b></span></div>
        <div class="section-title">${data.common.objType}</div>
        <div class="section-subtitle">вид объекта недвижимости</div>
        <table class="main-info-table">
            ${generateTableRow('Кадастровый номер', data.common.cadNum)}
            ${generateTableRow('Дата присвоения кадастрового номера', data.common.assignDate)}
            ${generateTableRow('Местоположение', data.common.location)}
            ${Object.entries(data.params).map(([key, value]) => generateTableRow(key, value)).join('')}
            ${generateTableRow('Кадастровая стоимость', data.common.cost ? `${new Intl.NumberFormat('ru-RU').format(data.common.cost)} руб.` : '')}
            ${Object.entries(data.links || {}).map(([key, value]) => generateTableRow(key, Array.isArray(value) ? value.join(', ') : value)).join('')}
            ${generateTableRow('Статус записи', data.common.status)}
        </table>`;
    pages.push(page1Html);

        if (data.rights && data.rights.length > 0) {
            let page2Html = `
                <div class="header-line"><span><b>Раздел 2. Сведения о зарегистрированных правах</b></span></div>
                <table><tr><td>Кадастровый номер:</td><td>${data.common.cadNum}</td></tr></table>`;
            data.rights.forEach((right, i) => {
                page2Html += `<div class="info-block"><p><b>Право ${i + 1}</b></p>
                <table class="main-info-table">
                    ${generateTableRow('Правообладатель', right.holder)}
                    ${generateTableRow('Вид, номер и дата гос. регистрации права', `${right.type}, ${right.number} от ${right.date}`)}
                    ${generateTableRow('Доля в праве', right.share)}
                </table></div>`;
            });
            pages.push(page2Html);
        }

        if (data.restrictions && data.restrictions.length > 0) {
            let page3Html = `
                <div class="header-line"><span><b>Раздел 2.1. Сведения об ограничениях прав и обременениях</b></span></div>
                <table><tr><td>Кадастровый номер:</td><td>${data.common.cadNum}</td></tr></table>`;
            data.restrictions.forEach((r, i) => {
                page3Html += `<div class="info-block"><p><b>Обременение ${i + 1}</b></p>
                <table class="main-info-table">
                    ${generateTableRow('Вид', r.type)}
                    ${generateTableRow('Дата и номер гос. регистрации', `${r.date}, ${r.number}`)}
                    ${generateTableRow('Основание', r.basis)}
                </table></div>`;
            });
            pages.push(page3Html);
        }

        if (data.coordinates && data.coordinates.length > 0) {
            const canvasId = 'plan-canvas';
            const hasZacrep = data.coordinates.flat().some(c => c.zacrep);
            const hasMultipleContours = data.coordinates.length > 1;
            const pagePlanHtml = `
                <div class="main-header"><h3>Описание местоположения объекта недвижимости</h3></div>
                <table>
                    <tr><td>Кадастровый номер:</td><td>${data.common.cadNum}</td></tr>
                    ${generateTableRow('Система координат', data.coordinatesSystem)}
                </table>
                <div class="section-title">Схема расположения</div>
                <div class="plan-container"><canvas id="${canvasId}"></canvas></div>
                <div class="section-title">Сведения о характерных точках контура</div>
                <table class="coordinates-table">
                    <thead><tr>
                        <th>Номер точки</th>
                        ${hasMultipleContours ? '<th>Контур</th>' : ''}
                        <th>X</th><th>Y</th><th>Погрешность, м</th>
                        ${hasZacrep ? '<th>Закрепление</th>': ''}
                    </tr></thead>
                    <tbody>
                    ${data.coordinates.flat().map(c => `<tr>
                        <td>${c.num || ''}</td>
                        ${hasMultipleContours ? `<td>${c.contour}</td>` : ''}
                        <td>${c.x.toFixed(2)}</td><td>${c.y.toFixed(2)}</td>
                        <td>${c.delta || ''}</td>
                        ${hasZacrep ? `<td>${c.zacrep || ''}</td>` : ''}
                    </tr>`).join('')}
                    </tbody>
                </table>`;
            pages.push(pagePlanHtml);
        }

          let finalHtml = '';
        pages.forEach((pageContent, i) => {
            finalHtml += `<div class="page">`;
            finalHtml += pageContent;
              if (i < pages.length - 1) {
          finalHtml += `
            <div class="merge-control">
                <button onclick="toggleMerge(this)">
                    <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"/>
                        <rect x="8" y="2" width="8" height="4" rx="1" ry="1"/>
                    </svg>
                    <span></span>
                </button>
            </div>`;
            }
            finalHtml += `</div>`;
        });

        output.innerHTML = finalHtml;
        
        const convertBtn = document.getElementById('convertToMskBtn');
        if (data.source === 'nspd') {
            convertBtn.style.display = 'inline-flex';
            const newBtn = convertBtn.cloneNode(true);
            convertBtn.parentNode.replaceChild(newBtn, convertBtn);
            newBtn.addEventListener('click', () => convertNspdCoordinatesToMsk(data));
        } else {
            convertBtn.style.display = 'none';
        }

        if (data.coordinates && data.coordinates.length > 0) {
            drawPlan(data.coordinates, 'plan-canvas', data.source);
        }
    }
    
function convertNspdCoordinatesToMsk(originalData) {
    try {
        const data = JSON.parse(JSON.stringify(originalData));
        const cadNum = data.common.cadNum;

        if (!cadNum || typeof MskFinder === 'undefined' || typeof proj4 === 'undefined' || typeof COORDINATE_SYSTEMS === 'undefined') {
            alert('Ошибка: Необходимые для конвертации компоненты не загружены.');
            return;
        }

        const mskCode = MskFinder.findMskCode(cadNum);
        if (!mskCode) {
            alert(`Не удалось автоматически определить код МСК для кадастрового номера ${cadNum}.`);
            return;
        }

        const searchString = `МСК ${mskCode}`;
        const targetSystem = COORDINATE_SYSTEMS.find(system => system.text && system.text.includes(searchString));

        if (!targetSystem) {
            alert(`В базе не найдено определение для системы координат "${searchString}".`);
            return;
        }

        if ((targetSystem.offsetX === undefined || targetSystem.offsetX === 0) && (targetSystem.offsetY === undefined || targetSystem.offsetY === 0)) {
            alert("ВНИМАНИЕ: Настройки смещения для этой МСК не настроены, координаты в выписке могут быть неверны.");
        }

        const sourceSystemDef = COORDINATE_SYSTEMS.find(s => s.value === 'EPSG:3857');
        if (!sourceSystemDef || !targetSystem.def) {
             alert('Отсутствует определение для исходной или целевой системы координат.');
             return;
        }

        proj4.defs('EPSG:3857', sourceSystemDef.def);
        proj4.defs(targetSystem.value, targetSystem.def);

        const offsetX = targetSystem.offsetX || 0;
        const offsetY = targetSystem.offsetY || 0;

        data.coordinates = data.coordinates.map(contour => {
            const convertedContour = contour.map(point => {
                const convertedPoint = proj4('EPSG:3857', targetSystem.value, [point.x, point.y]);
                const newPoint = { ...point };
                newPoint.x = convertedPoint[1] + offsetX;
                newPoint.y = convertedPoint[0] + offsetY;
                return newPoint;
            });
            
            const reversedContour = convertedContour.reverse();
            
            const renumberedContour = reversedContour.map((point, index) => {
                point.num = index + 1;
                return point;
            });

            return renumberedContour;
        });

        data.coordinatesSystem = targetSystem.text;
        data.source = 'nspd_converted';
        
        resetAndShowLoader();
        updateLoaderText('Пересчет координат и перерисовка...');
        
        setTimeout(() => {
         
            const formattedDate = new Date().toLocaleDateString('ru-RU');
         
            displayResults(data, `Сведения из ЕГРН от ${formattedDate} (${data.coordinatesSystem})`);
           
            showLoader(false);
        }, 250);

    } catch(e) {
        console.error("Ошибка при конвертации координат:", e);
        alert(`Произошла ошибка при конвертации: ${e.message}`);
        showLoader(false);
    }
}

function toggleMerge(button) {
    const page = button.closest('.page');
    if (!page) return;

    page.classList.toggle('no-break');

    if (page.classList.contains('no-break')) {
        button.innerHTML = `
            <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3"/>
            </svg>
            `;
    } else {
        button.innerHTML = `
            <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"/>
                <rect x="8" y="2" width="8" height="4" rx="1" ry="1"/>
            </svg>
            `;
    }
}
    
    
    async function fetchLinkedObjects(feature) {
    if (!feature || !feature.properties) return null;
    
    const geomId = feature.id;
    const categoryId = feature.properties.category;
    const categoryName = feature.properties.categoryName;

    let path = '';
    if (categoryName === "Земельные участки ЕГРН") {
        path = `/api/geoportal/v1/tab-group-data?tabClass=objectsList&categoryId=${categoryId}&geomId=${geomId}`;
    } else {
        path = `/api/geoportal/v1/tab-values-data?tabClass=landLinks&categoryId=${categoryId}&geomId=${geomId}`;
    }

    if (!geomId || !categoryId) {
        console.error("Отсутствует geomId или categoryId, невозможно запросить связанные объекты.");
        return null;
    }

    try {
        const res = await fetch(`https://nspd.gov.ru${path}`);
        if (!res.ok) return null;
        const data = await res.json();
        return (data?.object?.[0]?.value || data?.value) || null;
    } catch (e) {
        console.error("Ошибка при запросе связанных объектов:", e);
        return null;
    }
}
    
    function drawPlan(contours, canvasId, source) {
        const canvas = document.getElementById(canvasId); if (!canvas) return; const ctx = canvas.getContext('2d'); const container = canvas.parentElement;
        canvas.width = container.clientWidth > 0 ? container.clientWidth : 800; canvas.height = 500;
        const allCoords = contours.flat(); if(allCoords.length < 1) return;
        
        const allX = allCoords.map(c => c.x), allY = allCoords.map(c => c.y);
        const minX = Math.min(...allX), maxX = Math.max(...allX);
        const minY = Math.min(...allY), maxY = Math.max(...allY);
        
        const dataWidth = (source === 'nspd') ? maxX - minX : maxY - minY;
        const dataHeight = (source === 'nspd') ? maxY - minY : maxX - minX;
        if(dataWidth <= 0 || dataHeight <= 0) return;
        
        const margin = 40;
        const canvasDrawWidth = canvas.width - 2 * margin;
        const canvasDrawHeight = canvas.height - 2 * margin;
        
        const scale = Math.min(canvasDrawWidth / dataWidth, canvasDrawHeight / dataHeight);
        
        const scaledDataWidth = dataWidth * scale;
        const scaledDataHeight = dataHeight * scale;
        
        const horizontalPadding = canvasDrawWidth - scaledDataWidth;
        const verticalPadding = canvasDrawHeight - scaledDataHeight;
        
        const offsetX = horizontalPadding / 2;
        const offsetY = verticalPadding / 2;
        
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        contours.forEach(contour => {
            if (contour.length === 0) return; ctx.beginPath();
            contour.forEach((c, i) => {
                let canvasX, canvasY;
                
                if (source === 'nspd') { 
                    canvasX = margin + offsetX + (c.x - minX) * scale;
                    canvasY = (canvas.height - margin - offsetY) - (c.y - minY) * scale; 
                }
                else { 
                    canvasX = margin + offsetX + (c.y - minY) * scale; 
                    canvasY = (canvas.height - margin - offsetY) - (c.x - minX) * scale;
                }
                
                i === 0 ? ctx.moveTo(canvasX, canvasY) : ctx.lineTo(canvasX, canvasY);
            });
            const first = contour[0], last = contour[contour.length - 1];
            if (contour.length > 2 && Math.abs(first.x - last.x) < 0.01 && Math.abs(first.y - last.y) < 0.01) { 
                ctx.closePath(); 
                ctx.fillStyle = 'rgba(0, 123, 255, 0.1)'; 
                ctx.fill(); 
            }
            ctx.strokeStyle = '#007bff'; ctx.lineWidth = 2; ctx.stroke();
        });
    }
    
    function formatCadastralNumber(input) {
        let value = input.value.replace(/\D/g, ''); let formatted = '';
        if (value.length > 0) formatted += value.slice(0, 2); if (value.length > 2) formatted += ':' + value.slice(2, 4);
        const isSixDigits = sixDigitsRegions.includes(value.slice(0, 2)); const digitsAfter = isSixDigits ? 6 : 7;
        if (value.length > 4) formatted += ':' + value.slice(4, 4 + digitsAfter); if (value.length > 4 + digitsAfter) formatted += ':' + value.slice(4 + digitsAfter);
        input.value = formatted;
    }
    
    document.getElementById('cadastralInput').addEventListener('input', (e) => formatCadastralNumber(e.target));
    showStartView();
    </script>
</body>
</html>