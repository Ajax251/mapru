<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Слова Мини</title>
    <link rel="icon" href="img/wordsm.png" type="image/png">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        :root {
            --primary: #6366f1;
            --primary-dark: #4f46e5;
            --primary-light: #818cf8;
            --success: #10b981;
            --success-dark: #059669;
            --error: #ef4444;
            --error-dark: #dc2626;
            --warning: #f59e0b;
            --bg: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            --card: #ffffff;
            --text: #1f2937;
            --text-light: #6b7280;
            --shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
            --shadow-lg: 0 25px 50px -12px rgba(0, 0, 0, 0.25);
        }
        
        * { 
            box-sizing: border-box; 
            -webkit-tap-highlight-color: transparent; 
        }
        
        body, html { 
            margin: 0; 
            padding: 0; 
            height: 100dvh; 
            font-family: 'Inter', 'Segoe UI', system-ui, -apple-system, sans-serif; 
            background: var(--bg);
            color: var(--text); 
            overflow: hidden; 
            display: flex; 
            flex-direction: column; 
        }

        /* --- Animated Background (Subtle Pulse) --- */
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: 
                radial-gradient(circle at 50% 50%, rgba(255, 255, 255, 0.1), transparent 70%);
            animation: globalPulse 8s ease-in-out infinite;
            pointer-events: none;
        }

        @keyframes globalPulse {
            0%, 100% { opacity: 0.5; transform: scale(1); }
            50% { opacity: 0.8; transform: scale(1.1); }
        }

        /* --- Buttons --- */
        .btn {
            border: none;
            border-radius: 16px;
            padding: 16px 24px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            color: white;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
            position: relative;
            overflow: hidden;
        }

        /* Button Flash Hover */
        .btn::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(255, 255, 255, 0.4);
            opacity: 0;
            transition: opacity 0.2s;
        }

        .btn:hover::after {
            opacity: 1;
            animation: btnFlash 0.4s ease-out;
        }

        @keyframes btnFlash {
            0% { opacity: 1; transform: scale(1); }
            100% { opacity: 0; transform: scale(1.5); }
        }

        .btn:active { 
            transform: scale(0.98); 
        }

        .btn-primary { background: linear-gradient(135deg, var(--primary) 0%, var(--primary-dark) 100%); }
        .btn-success { background: linear-gradient(135deg, var(--success) 0%, var(--success-dark) 100%); }
        .btn-warning { background: linear-gradient(135deg, #fbbf24 0%, var(--warning) 100%); color: #78350f; }
        .btn-secondary { background: linear-gradient(135deg, #8b5cf6 0%, #7c3aed 100%); }

        /* --- Screens Transition (Fade Only) --- */
        .screen { 
            display: flex; 
            flex-direction: column; 
            height: 100%; 
            padding: 20px; 
            position: absolute; 
            width: 100%; 
            top: 0; 
            left: 0; 
            transition: opacity 0.5s ease; /* No movement */
            opacity: 0; 
            pointer-events: none; 
            z-index: 0;
        }

        .screen.active { 
            opacity: 1; 
            pointer-events: auto; 
            z-index: 1;
        }

        /* --- Generic Flash Animation Entry --- */
        @keyframes flashAppear {
            0% { 
                opacity: 0; 
                filter: brightness(3) blur(5px);
                transform: scale(0.95);
            }
            40% {
                opacity: 1;
                filter: brightness(1.5) blur(0px);
            }
            100% { 
                opacity: 1; 
                filter: brightness(1);
                transform: scale(1);
            }
        }

        /* --- Input Screen --- */
        .input-wrapper { 
            flex: 1; 
            display: flex; 
            flex-direction: column; 
            background: var(--card); 
            border-radius: 24px; 
            box-shadow: var(--shadow-lg);
            overflow: hidden; 
            margin-bottom: 20px; 
            position: relative;
            backdrop-filter: blur(10px);
            animation: flashAppear 0.8s ease-out; /* Changed from slideUp */
        }

        textarea { 
            flex: 1; 
            width: 100%; 
            border: none; 
            padding: 24px; 
            font-size: 16px; 
            resize: none; 
            outline: none; 
            font-family: inherit;
            background: transparent;
            line-height: 1.6;
        }

        .controls-row, .full-width-btn { 
            animation: flashAppear 0.8s ease-out backwards;
        }
        .controls-row { animation-delay: 0.1s; display: grid; grid-template-columns: 1fr 1fr; gap: 12px; margin-top: 12px; }
        .full-width-btn { animation-delay: 0.2s; width: 100%; margin-top: 12px; }

        /* --- Game Screen --- */
        .game-header { 
            display: flex; 
            justify-content: space-between; 
            align-items: center; 
            background: rgba(255, 255, 255, 0.95); 
            padding: 16px 20px; 
            border-radius: 20px; 
            box-shadow: var(--shadow);
            backdrop-filter: blur(10px);
            margin-bottom: 20px;
            animation: flashAppear 0.6s ease-out; /* Changed from slideDown */
        }

        .progress-bar { 
            flex: 1; 
            height: 10px; 
            background: rgba(0, 0, 0, 0.1); 
            border-radius: 10px; 
            margin: 0 20px; 
            overflow: hidden;
            position: relative;
        }

        .progress-fill { 
            height: 100%; 
            background: linear-gradient(90deg, var(--primary) 0%, var(--primary-light) 100%);
            width: 0%; 
            transition: width 0.5s cubic-bezier(0.4, 0, 0.2, 1);
            border-radius: 10px;
            box-shadow: 0 0 15px var(--primary); /* Glow added */
        }

        .icon-btn { 
            background: none; 
            border: none; 
            font-size: 22px; 
            color: #555; 
            cursor: pointer; 
            padding: 8px;
            border-radius: 12px;
            transition: all 0.3s;
        }
        .icon-btn:hover { background: rgba(0, 0, 0, 0.05); color: var(--primary); text-shadow: 0 0 10px var(--primary-light); }

        .word-area { 
            flex: 1; 
            display: flex; 
            flex-direction: column; 
            align-items: center; 
            justify-content: center; 
            min-height: 20vh;
            margin: 20px 0;
        }

        #target-word { 
            font-size: 48px; 
            font-weight: 800; 
            text-align: center; 
            margin-bottom: 12px;
            color: white;
            text-shadow: 0 0 20px rgba(255, 255, 255, 0.5);
            /* New Flash Animation */
            animation: wordFlash 0.5s ease-out;
        }

        @keyframes wordFlash {
            0% { 
                opacity: 0; 
                transform: scale(0.8);
                filter: blur(10px) brightness(3);
                letter-spacing: 10px;
            }
            100% { 
                opacity: 1; 
                transform: scale(1);
                filter: blur(0) brightness(1);
                letter-spacing: normal;
            }
        }

        .word-counter { 
            font-size: 15px; 
            color: rgba(255, 255, 255, 0.9); 
            margin-top: 8px;
            background: rgba(255, 255, 255, 0.2);
            padding: 8px 20px;
            border-radius: 20px;
            backdrop-filter: blur(10px);
            font-weight: 600;
            animation: flashAppear 0.5s ease-out 0.2s backwards;
        }

        .options-area { 
            flex: 1.5; 
            padding: 10px; 
            overflow-y: auto;
        }

        .options-grid { 
            display: grid; 
            grid-template-columns: 1fr 1fr; 
            gap: 16px; 
            height: 100%; 
            align-content: center;
        }

        .option-btn { 
            background: white; 
            border: 3px solid transparent;
            border-radius: 20px; 
            padding: 20px; 
            font-size: 18px; 
            color: #444; 
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1);
            min-height: 100px; 
            font-weight: 600; 
            cursor: pointer; 
            display: flex; 
            align-items: center; 
            justify-content: center; 
            text-align: center; 
            word-break: break-word;
            position: relative;
            overflow: hidden;
            /* New Entry: Flash instead of Slide */
            animation: cardEntryFlash 0.6s ease-out backwards;
            transition: transform 0.2s, box-shadow 0.2s, border-color 0.2s;
        }

        @keyframes cardEntryFlash {
            0% { opacity: 0; transform: scale(0.9); filter: brightness(2); }
            100% { opacity: 1; transform: scale(1); filter: brightness(1); }
        }

        .option-btn:nth-child(1) { animation-delay: 0.05s; }
        .option-btn:nth-child(2) { animation-delay: 0.1s; }
        .option-btn:nth-child(3) { animation-delay: 0.15s; }
        .option-btn:nth-child(4) { animation-delay: 0.2s; }

        .option-btn:hover {
            transform: scale(1.03);
            box-shadow: 0 0 25px rgba(255, 255, 255, 0.6);
            border-color: rgba(99, 102, 241, 0.3);
        }

        /* --- FLASH ANIMATIONS for Answers (Replaced Movements) --- */
        
        .correct-anim { 
            /* Green Flash Burst */
            animation: flashGreen 0.6s cubic-bezier(0.22, 1, 0.36, 1) forwards !important;
            color: white !important; 
            border-color: var(--success) !important;
            z-index: 10;
        }

        @keyframes flashGreen {
            0% { 
                background: white;
                box-shadow: 0 0 50px 20px rgba(255, 255, 255, 1);
                transform: scale(1.05);
                filter: brightness(2);
            }
            30% {
                background: var(--success);
                box-shadow: 0 0 40px 10px var(--success);
                transform: scale(1.05);
                filter: brightness(1.2);
            }
            100% { 
                background: linear-gradient(135deg, var(--success) 0%, var(--success-dark) 100%);
                box-shadow: 0 0 20px rgba(16, 185, 129, 0.6);
                transform: scale(1);
                filter: brightness(1);
            }
        }

        .wrong-anim { 
            /* Red Flash Burst (No shaking) */
            animation: flashRed 0.6s cubic-bezier(0.22, 1, 0.36, 1) forwards !important;
            color: white !important; 
            border-color: var(--error) !important;
            z-index: 10;
        }

        @keyframes flashRed {
            0% { 
                background: white;
                box-shadow: 0 0 50px 20px rgba(255, 255, 255, 1);
                transform: scale(0.95); /* Slight shrink instead of shake */
                filter: brightness(2);
            }
            30% {
                background: var(--error);
                box-shadow: 0 0 40px 10px var(--error);
                filter: brightness(1.2);
            }
            100% { 
                background: linear-gradient(135deg, var(--error) 0%, var(--error-dark) 100%);
                box-shadow: 0 0 20px rgba(239, 68, 68, 0.6);
                transform: scale(1);
                filter: brightness(1);
            }
        }

        /* --- Result Screen --- */
        .result-content { 
            flex: 1; 
            display: flex; 
            flex-direction: column; 
            align-items: center; 
            justify-content: center; 
            text-align: center;
            color: white;
        }

        .score-circle { 
            width: 180px; 
            height: 180px; 
            border-radius: 50%; 
            background: linear-gradient(135deg, var(--primary) 0%, var(--primary-dark) 100%);
            color: white; 
            display: flex; 
            flex-direction: column; 
            justify-content: center; 
            margin-bottom: 30px; 
            position: relative;
            border: 4px solid rgba(255, 255, 255, 0.5);
            /* New Reveal: Implode/Flash */
            animation: circleFlash 0.8s cubic-bezier(0.19, 1, 0.22, 1);
            box-shadow: 0 0 50px var(--primary);
        }

        @keyframes circleFlash {
            0% { 
                transform: scale(0);
                opacity: 0;
                box-shadow: 0 0 100px 50px rgba(255, 255, 255, 1);
            }
            50% {
                transform: scale(1.1);
                opacity: 1;
                box-shadow: 0 0 60px 20px var(--primary-light);
            }
            100% { 
                transform: scale(1); 
                box-shadow: 0 0 50px var(--primary);
            }
        }

        .score-val { 
            font-size: 56px; 
            font-weight: 900;
            text-shadow: 0 0 20px rgba(255, 255, 255, 0.5);
            animation: flashAppear 1s ease-out 0.3s backwards;
        }

        .result-content p {
            font-size: 18px;
            margin: 12px 0;
            background: rgba(255, 255, 255, 0.2);
            padding: 12px 28px;
            border-radius: 20px;
            backdrop-filter: blur(10px);
            animation: flashAppear 0.6s ease-out backwards;
        }

        .result-content p:nth-of-type(1) { animation-delay: 0.5s; }
        .result-content p:nth-of-type(2) { animation-delay: 0.6s; }

        /* --- Loader --- */
        #loader { 
            position: fixed; 
            top: 0; 
            left: 0; 
            width: 100%; 
            height: 100%; 
            background: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(15px);
            z-index: 100; 
            display: none; 
            flex-direction: column; 
            align-items: center; 
            justify-content: center;
            transition: opacity 0.3s;
        }

        .spinner { 
            width: 60px; 
            height: 60px; 
            background: white;
            border-radius: 50%; 
            animation: pulseGlow 1.5s infinite;
            margin-bottom: 20px;
            box-shadow: 0 0 30px var(--primary);
        }

        @keyframes pulseGlow {
            0% { transform: scale(0.8); box-shadow: 0 0 0 0 rgba(99, 102, 241, 0.7); }
            70% { transform: scale(1); box-shadow: 0 0 0 20px rgba(99, 102, 241, 0); }
            100% { transform: scale(0.8); box-shadow: 0 0 0 0 rgba(99, 102, 241, 0); }
        }

        #loader h3 {
            color: var(--primary);
            font-size: 24px;
            margin: 10px 0;
            text-shadow: 0 0 10px rgba(99, 102, 241, 0.3);
        }

        .hidden-file { display: none; }

        /* --- Scrollbar --- */
        ::-webkit-scrollbar { width: 8px; }
        ::-webkit-scrollbar-track { background: rgba(0, 0, 0, 0.05); border-radius: 10px; }
        ::-webkit-scrollbar-thumb { background: var(--primary-light); border-radius: 10px; }

        /* --- Responsive --- */
        @media (max-width: 480px) {
            #target-word { font-size: 36px; }
            .option-btn { font-size: 16px; min-height: 85px; padding: 16px; }
            .score-circle { width: 150px; height: 150px; }
            .score-val { font-size: 48px; }
        }
    </style>
</head>
<body>
    <!-- SCREEN 1: INPUT -->
    <div id="screen-input" class="screen active">
        <div class="input-wrapper">
            <textarea id="sourceText" placeholder="Вставьте текст сюда...&#10;&#10;Программа разобьет его на отдельные слова и создаст словарь для тренировки"></textarea>
        </div>
        
        <button class="btn btn-primary full-width-btn" onclick="startProcessing()">
            <i class="fas fa-magic"></i>
            <span>Обработать и начать</span>
        </button>
        <div class="controls-row">
            <button class="btn btn-secondary" onclick="document.getElementById('fileInput').click()">
                <i class="fas fa-file-upload"></i>
                <span>Импорт</span>
            </button>
            <button class="btn btn-warning" onclick="clearText()">
                <i class="fas fa-arrows-rotate"></i>
                <span>Сбросить</span>
            </button>
        </div>
        <input type="file" id="fileInput" class="hidden-file" accept=".words,.json" onchange="importWords(this)">
    </div>

    <!-- SCREEN 2: GAME -->
    <div id="screen-game" class="screen">
        <div class="game-header">
            <span style="font-weight: bold; color: var(--primary);">Счет: <span id="score">0</span></span>
            <div class="progress-bar"><div class="progress-fill" id="progress"></div></div>
            <button class="icon-btn" onclick="exportWords()" title="Сохранить словарь"><i class="fas fa-download"></i></button>
            <button class="icon-btn" onclick="goToInput()" style="margin-left: 10px;"><i class="fas fa-times"></i></button>
        </div>
        <div class="word-area">
            <div id="target-word">Word</div>
            <div class="word-counter">Слово <span id="current-word-idx">1</span> из <span id="total-word-count">10</span></div>
        </div>
        <div class="options-area">
            <div class="options-grid" id="options-container"></div>
        </div>
    </div>

    <!-- SCREEN 3: RESULT -->
    <div id="screen-result" class="screen">
        <div class="result-content">
            <div class="score-circle">
                <span class="score-val" id="final-percent">0%</span>
                <span style="font-size: 16px; font-weight: 600;">Точность</span>
            </div>
            <p>Всего слов: <strong id="res-total">0</strong></p>
            <p>Ошибок: <strong id="res-errors" style="color: var(--error)">0</strong></p>
        </div>
        <button class="btn btn-primary full-width-btn" onclick="goToInput()">
            <i class="fas fa-home"></i>
            <span>На главную</span>
        </button>
        <button class="btn btn-success full-width-btn" onclick="restartGame()">
            <i class="fas fa-redo"></i>
            <span>Пройти заново</span>
        </button>
        <button class="btn btn-secondary full-width-btn" onclick="exportWords()">
            <i class="fas fa-download"></i>
            <span>Сохранить словарь (.words)</span>
        </button>
    </div>

    <!-- LOADER -->
    <div id="loader">
        <div class="spinner"></div>
        <h3 id="loader-text">Анализ текста...</h3>
        <p id="loader-sub" style="color:#888; font-size:13px; text-align:center; padding:0 20px;"></p>
    </div>

    <script>
        // --- CONFIG ---
        const VERCEL_PROXY = "https://ver-olive-delta.vercel.app";
        const MAPRUAPP_PROXY = "https://mapruapp.ru";
        const PROXY_MODE = 1;
        const MODEL = "gemini-2.5-flash-lite";
        
        // --- STATE ---
        let state = {
            words: [],
            gameOrder: [],
            idx: 0,
            score: 0,
            mistakes: 0,
            locked: false
        };

        // --- LOGIC: TEXT PROCESSING ---
        async function startProcessing() {
            const text = document.getElementById('sourceText').value;
            if (text.trim().length < 5) {
                alert("Введите текст для обработки.");
                return;
            }
            setLoading(true, "Разбиение на слова...");
            
            const rawWords = text.match(/[a-zA-Z\u00C0-\u00FF]+|[а-яА-ЯёЁ]+/g) || [];
            
            const uniqueSet = new Set();
            rawWords.forEach(w => {
                if (w.length > 2) uniqueSet.add(w.toLowerCase());
            });
            
            let wordsList = Array.from(uniqueSet);
            if (wordsList.length === 0) {
                setLoading(false);
                alert("Не найдено подходящих слов.");
                return;
            }
            
            if (wordsList.length > 200) {
                if (!confirm(`Найдено ${wordsList.length} уникальных слов. Обработать только первые 200?`)) {
                    setLoading(false);
                    return;
                }
                wordsList = wordsList.slice(0, 200);
            }
            
            setLoading(true, `Перевод ${wordsList.length} слов через ИИ...`);
            
            const prompt = `
                I have a list of single words. Translate each one to Russian.
                Context: General vocabulary.
                Return strictly a JSON array of objects with keys: "original" (the word from my list) and "translation" (Russian translation).
                Return ONLY the JSON. No markdown.
                
                List of words:
                ${JSON.stringify(wordsList)}
            `;
            
            try {
                let jsonStr = await callAI(prompt);
                jsonStr = jsonStr.replace(/```json/g, '').replace(/```/g, '').trim();
                
                const translatedData = JSON.parse(jsonStr);
                if (!Array.isArray(translatedData)) throw new Error("Invalid AI response");
                
                state.words = translatedData.filter(item => 
                    item.original && item.translation && 
                    !item.original.includes(' ')
                );
                startGame();
            } catch (e) {
                console.error(e);
                alert("Ошибка ИИ: " + e.message);
            } finally {
                setLoading(false);
            }
        }

        async function callAI(prompt) {
            let url, body;
            if (PROXY_MODE === 1) {
                url = `${MAPRUAPP_PROXY}/ai/api/v1/chat/completions`;
                body = {
                    model: MODEL,
                    messages: [{ role: "user", content: prompt }],
                    max_tokens: 8000,
                    response_format: { type: "json_object" }
                };
            } else {
                url = `${VERCEL_PROXY}/v1beta/models/${MODEL}:generateContent`;
                body = {
                    contents: [{ parts: [{ text: prompt }] }],
                    generationConfig: { responseMimeType: "application/json" }
                };
            }
            
            const res = await fetch(url, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(body)
            });
            
            if (!res.ok) throw new Error("API Error " + res.status);
            const data = await res.json();
            
            return PROXY_MODE === 1 
                ? data.choices[0].message.content 
                : data.candidates[0].content.parts[0].text;
        }

        // --- GAMEPLAY ---
        function startGame() {
            if (state.words.length < 4) {
                alert("Слишком мало слов для игры (минимум 4).");
                return;
            }
            state.gameOrder = [...state.words].sort(() => Math.random() - 0.5);
            state.idx = 0;
            state.score = 0;
            state.mistakes = 0;
            showScreen('screen-game');
            nextWord();
        }

        function restartGame() {
            startGame();
        }

        function nextWord() {
            if (state.idx >= state.gameOrder.length) {
                endGame();
                return;
            }
            state.locked = false;
            const current = state.gameOrder[state.idx];
            
            // Re-trigger animation by removing and adding the element content
            const targetEl = document.getElementById('target-word');
            targetEl.style.animation = 'none';
            targetEl.offsetHeight; /* trigger reflow */
            targetEl.style.animation = 'wordFlash 0.5s ease-out';
            targetEl.textContent = current.original;

            document.getElementById('current-word-idx').textContent = state.idx + 1;
            document.getElementById('total-word-count').textContent = state.gameOrder.length;
            document.getElementById('score').textContent = state.score;
            
            const pct = (state.idx / state.gameOrder.length) * 100;
            document.getElementById('progress').style.width = `${pct}%`;
            renderOptions(current);
        }

        function renderOptions(correct) {
            const container = document.getElementById('options-container');
            container.innerHTML = '';
            
            let pool = state.words.filter(w => w.original !== correct.original);
            let distractors = pool.sort(() => Math.random() - 0.5).slice(0, 3);
            let options = [correct, ...distractors].sort(() => Math.random() - 0.5);
            
            options.forEach((opt, index) => {
                const btn = document.createElement('button');
                btn.className = 'option-btn';
                btn.textContent = opt.translation;
                // Add staggered animation delay
                btn.style.animationDelay = (index * 0.05) + 's';
                btn.onclick = () => handleAnswer(opt, correct, btn);
                container.appendChild(btn);
            });
        }

        function handleAnswer(selected, correct, btn) {
            if (state.locked) return;
            state.locked = true;
            const isCorrect = selected.original === correct.original;
            
            if (isCorrect) {
                btn.classList.add('correct-anim');
                state.score++;
            } else {
                btn.classList.add('wrong-anim');
                state.mistakes++;
                
                // Highlight correct one softly
                Array.from(document.querySelectorAll('.option-btn')).forEach(b => {
                    if (b.textContent === correct.translation) {
                        b.style.transition = "all 0.5s";
                        b.style.border = "3px solid var(--success)";
                        b.style.boxShadow = "0 0 20px var(--success)";
                    }
                });
            }
            
            setTimeout(() => {
                state.idx++;
                nextWord();
            }, 1000);
        }

        function endGame() {
            showScreen('screen-result');
            const total = state.gameOrder.length;
            const accuracy = Math.round((state.score / total) * 100);
            
            document.getElementById('final-percent').textContent = `${accuracy}%`;
            document.getElementById('res-total').textContent = total;
            document.getElementById('res-errors').textContent = state.mistakes;
        }

        // --- IMPORT / EXPORT ---
        function exportWords() {
            if (!state.words || state.words.length === 0) {
                alert("Словарь пуст.");
                return;
            }
            const dataStr = JSON.stringify(state.words, null, 2);
            const blob = new Blob([dataStr], { type: "application/json" });
            const url = URL.createObjectURL(blob);
            
            const a = document.createElement('a');
            a.href = url;
            a.download = `dictionary_${new Date().getTime()}.words`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
        }

        function importWords(input) {
            const file = input.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const json = JSON.parse(e.target.result);
                    if (Array.isArray(json) && json.length > 0 && json[0].original) {
                        state.words = json;
                        alert(`Загружено ${json.length} слов.`);
                        startGame();
                    } else {
                        throw new Error("Неверный формат файла");
                    }
                } catch (err) {
                    alert("Ошибка чтения файла: " + err.message);
                }
            };
            reader.readAsText(file);
            input.value = '';
        }

        // --- NAVIGATION & UI ---
        function showScreen(id) {
            document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
            document.getElementById(id).classList.add('active');
        }

        function goToInput() {
            showScreen('screen-input');
        }

        function clearText() {
            document.getElementById('sourceText').value = '';
        }

        function setLoading(active, text = "") {
            document.getElementById('loader').style.display = active ? 'flex' : 'none';
            document.getElementById('loader-sub').textContent = text;
        }
    </script>
</body>
</html>