<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>График котировок и симулятор торговли</title>
    <!-- Ensure LightweightCharts library is loaded -->
  <script src="/webfonts/lightweight-charts.standalone.production.js"></script>
    <!-- Ensure PapaParse library is loaded -->
    <script src="/webfonts/papaparse.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;700&display=swap');

        body {
            font-family: 'Roboto', sans-serif;
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            height: 100vh;
            transition: background-color 0.3s, color 0.3s;
            overflow: hidden; /* Prevent body scrollbars */
        }
        body.dark-theme {
            background-color: #1e222d;
            color: #fff;
        }
        body.light-theme {
            background-color: #ffffff;
            color: #000;
        }
        #controls {
            padding: 15px 20px; /* Reduced padding */
            display: flex;
            flex-wrap: wrap; /* Allow wrapping on smaller screens */
            justify-content: space-between;
            align-items: center;
            background-color: rgba(0, 0, 0, 0.1);
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            flex-shrink: 0; /* Prevent controls from shrinking */
        }
        #chart-container {
            flex-grow: 1;
            position: relative;
            min-height: 200px; /* Ensure minimum height */
        }
        h1 {
            margin: 0 10px 0 0; /* Adjusted margin */
            font-size: 20px; /* Slightly smaller */
            font-weight: 700;
            transition: all 0.3s ease;
            white-space: nowrap; /* Prevent title wrapping */
        }
        h1:hover {
            transform: scale(1.05);
        }
        #file-input {
            display: none;
        }
        .btn {
            display: inline-block;
            padding: 8px 16px; /* Slightly smaller buttons */
            background-color: #2962ff;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s ease;
            margin: 5px;
            font-size: 13px; /* Slightly smaller font */
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        .btn:disabled {
            background-color: #aaa;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        .btn:hover:not(:disabled) {
            background-color: #1e4bd8;
            transform: translateY(-2px);
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        select {
            margin: 5px;
            padding: 8px; /* Consistent padding */
            border: none;
            border-radius: 5px;
            background-color: #f0f0f0;
            color: #333; /* Ensure text visibility */
            font-size: 13px; /* Consistent font size */
            transition: all 0.3s ease;
            cursor: pointer;
        }
        select:hover {
            background-color: #e0e0e0;
        }
        #tooltip {
            position: absolute;
            display: none;
            background-color: rgba(30, 34, 45, 0.9); /* Darker tooltip */
            color: white;
            padding: 10px;
            border-radius: 5px;
            font-size: 12px; /* Smaller tooltip font */
            pointer-events: none;
            z-index: 1000;
            transition: opacity 0.1s ease; /* Smoother transition */
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.2);
            white-space: nowrap; /* Prevent wrapping */
        }
        #trading-panel {
            padding: 15px 20px; /* Reduced padding */
            background-color: rgba(0, 0, 0, 0.1);
            box-shadow: 0 -2px 10px rgba(0, 0, 0, 0.1);
            flex-shrink: 0; /* Prevent shrinking */
        }
        #trading-panel > div:first-child { /* Style the button/balance row */
            display: flex;
            flex-wrap: wrap;
            align-items: center;
        }
        #balance {
            margin-left: auto; /* Push balance to the right */
            font-weight: 500;
            font-size: 14px;
            padding: 0 10px;
        }
        #orders-list {
            margin-top: 10px;
            max-height: 150px; /* Adjusted height */
            overflow-y: auto;
            font-size: 13px;
        }
        .order-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 6px 5px; /* Adjusted padding */
            border-bottom: 1px solid #555; /* Darker border for dark theme */
        }
        body.light-theme .order-item {
            border-bottom: 1px solid #ccc;
        }
        .order-item:last-child {
            border-bottom: none;
        }
        .order-profit {
            cursor: pointer;
            padding: 3px 6px; /* Adjusted padding */
            border-radius: 3px;
            margin-left: 10px;
            font-weight: 500;
        }
        .order-profit.positive {
            background-color: rgba(38, 166, 154, 0.3); /* Greenish */
            color: #26a69a;
        }
        .order-profit.negative {
            background-color: rgba(239, 83, 80, 0.3); /* Reddish */
            color: #ef5350;
        }
        body.light-theme .order-profit.positive {
            background-color: #e0f2f1;
            color: #00796b;
        }
        body.light-theme .order-profit.negative {
            background-color: #ffebee;
            color: #c62828;
        }

        /* Basic responsive adjustments */
        @media (max-width: 768px) {
            #controls {
                flex-direction: column;
                align-items: flex-start;
            }
            h1 {
                 margin-bottom: 10px;
            }
            #trading-panel > div:first-child {
                 flex-direction: column;
                 align-items: flex-start;
            }
            #balance {
                margin-left: 0;
                margin-top: 10px;
            }
            .btn, select {
                width: calc(50% - 10px); /* Adjust button/select width */
            }
        }
         @media (max-width: 480px) {
             .btn, select {
                width: 100%; /* Full width on very small screens */
                margin-left: 0;
                margin-right: 0;
             }
         }

    </style>
</head>
<body class="dark-theme">
    <div id="controls">
        <h1 id="chart-title">График котировок</h1>
        <div>
            <label for="file-input" class="btn">Загрузить CSV</label>
            <input type="file" id="file-input" accept=".csv">
            <select id="chart-type">
                <option value="candlestick">Свечи</option>
                <option value="bar">Бары</option>
                <option value="line">Линия</option>
            </select>
            <select id="theme">
                <option value="dark">Темная тема</option>
                <option value="light">Светлая тема</option>
            </select>
        </div>
    </div>
    <div id="chart-container">
        <div id="tooltip"></div>
    </div>
    <div id="trading-panel">
        <div>
            <button id="start-trading" class="btn" disabled>Начать торговлю</button>
            <button id="next-candle" class="btn" disabled>Далее</button>
            <button id="buy" class="btn" disabled>BUY</button>
            <button id="sell" class="btn" disabled>SELL</button>
            <span id="balance">Баланс: $10000.00</span>
        </div>
        <div id="orders-list"></div>
    </div>

    <script>
        const fileInput = document.getElementById('file-input');
        const chartContainer = document.getElementById('chart-container');
        const chartTypeSelect = document.getElementById('chart-type');
        const themeSelect = document.getElementById('theme');
        const tooltip = document.getElementById('tooltip');
        const chartTitle = document.getElementById('chart-title');
        const startTradingBtn = document.getElementById('start-trading');
        const nextCandleBtn = document.getElementById('next-candle');
        const buyBtn = document.getElementById('buy');
        const sellBtn = document.getElementById('sell');
        const balanceDisplay = document.getElementById('balance');
        const ordersList = document.getElementById('orders-list');

        let chart = null; // Initialize chart as null
        let series = null; // Initialize series as null
        let originalData = [];
        let currentDataIndex = 0;
        let currentVisibleData = []; // Data currently shown on chart
        let balance = 10000;
        let orders = []; // { type: 'BUY'/'SELL', price: number, volume: number, openTime: number, profit?: number, currentPrice?: number, line?: IPriceLine }
        let isTrading = false;
        let orderLines = []; // Keep track of price lines for orders

        // --- Initialization ---
        document.addEventListener('DOMContentLoaded', () => {
            // Check if libraries are loaded (basic check)
            if (typeof LightweightCharts === 'undefined') {
                console.error("LightweightCharts library not found!");
                alert("Ошибка: Библиотека LightweightCharts не загружена.");
            }
            if (typeof Papa === 'undefined') {
                console.error("PapaParse library not found!");
                alert("Ошибка: Библиотека PapaParse не загружена.");
            }
            updateBalanceDisplay(); // Show initial balance
        });

        // --- Event Listeners ---
        fileInput.addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (file) {
                chartTitle.textContent = file.name;
                resetSimulation(); // Reset if a new file is loaded
                loadCSV(file);
            }
        });

        chartTypeSelect.addEventListener('change', function() {
            if (chart && currentVisibleData.length > 0) {
                updateChartType(this.value);
            }
        });

        themeSelect.addEventListener('change', function() {
            updateTheme(this.value);
        });

        startTradingBtn.addEventListener('click', startTrading);
        nextCandleBtn.addEventListener('click', showNextCandle);
        buyBtn.addEventListener('click', () => placeOrder('BUY'));
        sellBtn.addEventListener('click', () => placeOrder('SELL'));

        // --- CSV Parsing ---
        function parseDate(dateString, timeString) {
            // Format: YYYY.MM.DD, HH:MM
            const dateParts = dateString.split('.');
            const timeParts = timeString.split(':');
            if (dateParts.length !== 3 || timeParts.length !== 2) {
                throw new Error(`Invalid date/time format: ${dateString} ${timeString}`);
            }
            const year = parseInt(dateParts[0]);
            const month = parseInt(dateParts[1]) - 1; // JS months are 0-indexed
            const day = parseInt(dateParts[2]);
            const hours = parseInt(timeParts[0]);
            const minutes = parseInt(timeParts[1]);

            // Basic validation
            if (isNaN(year) || isNaN(month) || isNaN(day) || isNaN(hours) || isNaN(minutes)) {
                 throw new Error(`Invalid date/time values: ${dateString} ${timeString}`);
            }

            // Use UTC to avoid timezone issues with timestamps if needed,
            // or keep local time if that's intended. Let's use local for simplicity here.
            const date = new Date(year, month, day, hours, minutes);
            // Return UNIX timestamp (seconds)
            return date.getTime() / 1000;
        }

        function loadCSV(file) {
            console.log("Loading CSV...");
            Papa.parse(file, {
                skipEmptyLines: true,
                complete: function(results) {
                    console.log("CSV Parsing complete. Rows:", results.data.length);
                    const chartData = [];
                    let parseErrors = 0;

                    results.data.forEach((row, index) => {
                        // Expecting: Date, Time, Open, High, Low, Close, Volume
                        if (row.length < 7) {
                            console.warn(`Skipping row ${index + 1}: Not enough columns (${row.length})`);
                            parseErrors++;
                            return; // Skip row if not enough columns
                        }
                        try {
                            const time = parseDate(row[0].trim(), row[1].trim());
                            const open = parseFloat(row[2]);
                            const high = parseFloat(row[3]);
                            const low = parseFloat(row[4]);
                            const close = parseFloat(row[5]);
                            const volume = parseFloat(row[6]); // Optional, but good to have

                            // Validate parsed numbers
                            if (isNaN(time) || isNaN(open) || isNaN(high) || isNaN(low) || isNaN(close) || isNaN(volume)) {
                                console.warn(`Skipping row ${index + 1}: Invalid numeric data`, row);
                                parseErrors++;
                                return; // Skip row if data is invalid
                            }

                            // Ensure high >= low, high >= open, high >= close, low <= open, low <= close
                            const candleHigh = Math.max(open, close, high);
                            const candleLow = Math.min(open, close, low);

                            chartData.push({
                                time: time,
                                open: open,
                                high: candleHigh, // Use corrected high
                                low: candleLow,   // Use corrected low
                                close: close,
                                // volume: volume // Volume often plotted separately, can be added later
                            });
                        } catch (error) {
                            console.warn(`Skipping row ${index + 1}: ${error.message}`, row);
                            parseErrors++;
                        }
                    });

                    if (parseErrors > 0) {
                         alert(`Завершено с ${parseErrors} ошибками при чтении строк CSV. Проверьте консоль (F12) для деталей.`);
                    }

                    if (chartData.length === 0) {
                        alert("Не найдено корректных данных в CSV файле.");
                        resetSimulation();
                        return;
                    }

                    // Sort data by time just in case it's not ordered
                    originalData = chartData.sort((a, b) => a.time - b.time);
                    console.log("Processed chart data points:", originalData.length);

                    // Initial display - show all data before trading starts
                    currentVisibleData = [...originalData];
                    createChart(currentVisibleData);
                    startTradingBtn.disabled = false; // Enable trading start

                },
                error: function(error) {
                    console.error("Error parsing CSV:", error);
                    alert("Ошибка чтения CSV файла: " + error.message);
                    resetSimulation();
                }
            });
        }

        // --- Charting ---
        // --- Charting ---
        function createChart(data) {
            // 1. Verify Library Existence and Core Function
            if (typeof LightweightCharts === 'undefined') {
                console.error("FATAL: LightweightCharts library object not found.");
                alert("Критическая ошибка: Библиотека LightweightCharts не загружена.");
                return;
            }
            if (typeof LightweightCharts.createChart !== 'function') {
                 console.error("FATAL: LightweightCharts.createChart is NOT a function!", LightweightCharts);
                 alert("Критическая ошибка: Функция LightweightCharts.createChart не найдена.");
                 return;
            }
            console.log("LightweightCharts library object seems OK. createChart function exists.");

            // 2. Cleanup previous chart instance (if any)
            if (chart) {
                try {
                    console.log("Removing previous chart instance...");
                    chart.remove();
                } catch (removeError) {
                    console.error("Error removing previous chart (might be ok if already removed):", removeError);
                } finally {
                     chart = null; // Ensure it's nullified
                     series = null;
                     orderLines = []; // Clear associated price lines
                }
            }

            // 3. Check Container Dimensions
            if (chartContainer.clientWidth <= 0 || chartContainer.clientHeight <= 0) {
                 console.error("Chart container has zero dimensions. Retrying shortly...");
                 // Keep the retry logic for layout issues
                 setTimeout(() => createChart(data), 150);
                 return;
            }
            console.log(`Attempting chart creation. Container: ${chartContainer.clientWidth}x${chartContainer.clientHeight}`);

            // 4. Create Chart with Minimal Options & Perform IMMEDIATE Checks
            try {
                console.log("Calling LightweightCharts.createChart with bare minimum options...");
                chart = LightweightCharts.createChart(chartContainer, {
                    width: chartContainer.clientWidth,
                    height: chartContainer.clientHeight,
                    // NO OTHER OPTIONS FOR THIS TEST
                });

                console.log("LightweightCharts.createChart call finished.");

                // === IMMEDIATE POST-CREATION CHECKS ===
                if (!chart || typeof chart !== 'object') {
                     // This should not happen if createChart didn't throw, but check anyway
                     throw new Error("createChart returned invalid value (not an object or null/undefined).");
                }
                console.log("Chart object received:", chart); // Log the object itself

                // Check essential non-series methods first
                const coreMethods = ['applyOptions', 'remove', 'timeScale', 'subscribeClick', 'unsubscribeClick'];
                let coreMethodsOk = true;
                console.log("--- Checking CORE chart methods ---");
                coreMethods.forEach(m => {
                    if (typeof chart[m] !== 'function') {
                        console.error(`  ❌ Core method ${m} is MISSING or not a function!`);
                        coreMethodsOk = false;
                    } else {
                         console.log(`  ✅ Core method ${m} found.`);
                    }
                });

                if (!coreMethodsOk) {
                    throw new Error("Chart object is missing fundamental methods. Initialization failed.");
                }
                console.log("--- Core methods seem OK. ---");

                 // Now check the series methods specifically
                const seriesMethods = ['addAreaSeries', 'addBarSeries', 'addCandlestickSeries', 'addHistogramSeries', 'addLineSeries'];
                let seriesMethodsOk = true;
                 console.log("--- Checking SERIES chart methods ---");
                seriesMethods.forEach(m => {
                     if (typeof chart[m] !== 'function') {
                         console.error(`  ❌ Series method ${m} is MISSING or not a function!`);
                         seriesMethodsOk = false;
                     } else {
                          console.log(`  ✅ Series method ${m} found.`);
                     }
                });

                 if (!seriesMethodsOk) {
                     // Log this clearly but don't necessarily throw an error yet, let updateChartType handle it
                     console.error("!!! CRITICAL: One or more SERIES methods are missing from the chart object. This indicates a likely library file problem (e.g., not the standalone version?).");
                     // Optionally alert the user here if this is unexpected
                     // alert("Warning: Chart library might be incomplete. Some chart types may not work.");
                 } else {
                      console.log("--- All checked series methods seem OK. ---");
                 }
                 // === END OF IMMEDIATE CHECKS ===


                // 5. Apply Full Options (now that basic object is confirmed)
                console.log("Applying user-defined options (theme, grid, etc.)...");
                 const currentTheme = themeSelect.value;
                 chart.applyOptions({
                     layout: {
                         background: { type: 'solid', color: currentTheme === 'dark' ? '#1e222d' : '#ffffff' },
                         textColor: currentTheme === 'dark' ? '#d1d4dc' : '#333333',
                     },
                     grid: {
                         vertLines: { color: currentTheme === 'dark' ? '#2b2b43' : '#e0e0e0' },
                         horzLines: { color: currentTheme === 'dark' ? '#2b2b43' : '#e0e0e0' },
                     },
                     crosshair: {
                         mode: LightweightCharts.CrosshairMode.Normal,
                     },
                     rightPriceScale: {
                         borderColor: currentTheme === 'dark' ? '#2b2b43' : '#cccccc',
                     },
                     timeScale: {
                         borderColor: currentTheme === 'dark' ? '#2b2b43' : '#cccccc',
                         timeVisible: true,
                         secondsVisible: false,
                     },
                     priceScale: {
                         autoScale: true,
                     },
                 });
                 console.log("Full options applied.");

                // 6. Proceed to Add Series and Listeners
                console.log("Calling updateChartType...");
                updateChartType(chartTypeSelect.value); // This function now contains its own checks

                // Check if series was successfully created in updateChartType
                if (series || chartTypeSelect.value === 'line') { // Allow line chart even if initial data might be empty
                    console.log("Series present or type is line, setting up listeners and fitting content...");
                    setupChartEventListeners(); // Also contains its own checks
                     if (chart && chart.timeScale) { // Check chart/timescale still valid
                         try { chart.timeScale().fitContent(); } catch (e) { console.error("Error fitting content:", e); }
                     }
                } else {
                    console.warn("Skipping listeners/fitContent as series object is null after updateChartType.");
                }
                console.log("createChart function finished successfully.");

            } catch (error) {
                // Catch errors from createChart, checks, applyOptions, or subsequent calls
                console.error("Error during chart creation or setup process:", error);
                alert("Произошла ошибка при инициализации графика: " + error.message);
                // Ensure cleanup even on error
                if (chart && typeof chart.remove === 'function') {
                    try { chart.remove(); } catch (e) {/* ignore */}
                }
                chart = null;
                series = null;
                resetSimulation(); // Reset state
            }
        }

        // --- Update Chart Type ---
        function updateChartType(type) {
            // Check chart object validity *and* the existence of a core method like 'applyOptions'
            // If createChart failed subtly, chart might be an object but not a *chart* object.
            if (!chart || typeof chart.applyOptions !== 'function') {
                console.error(`Cannot update chart type to ${type}: Chart object is invalid or not fully initialized.`, chart);
                // Do not proceed if the chart object isn't valid.
                return;
            }

            // Attempt to remove previous series if it exists
            if (series) {
                try {
                    chart.removeSeries(series);
                    series = null; // Ensure series is null after removal
                } catch (error) {
                    console.error("Error removing previous series (might be ignorable):", error);
                    series = null; // Still set to null
                }
            }
            // Clear any visual order lines before adding new series
             clearOrderLines();


            console.log(`Updating chart type to: ${type}. Chart object seems valid.`);

            try {
                let seriesData = currentVisibleData; // Use the data currently meant to be visible
                const commonPriceFormat = { type: 'price', precision: 5, minMove: 0.00001 }; // Use precision from your UI data

                // Explicitly check for the specific add function *before* calling it
                switch (type) {
                    case 'candlestick':
                        if (typeof chart.addCandlestickSeries !== 'function') {
                            throw new Error("Internal Error: chart.addCandlestickSeries is not a function");
                        }
                        series = chart.addCandlestickSeries({
                            upColor: '#26a69a', downColor: '#ef5350',
                            borderVisible: false,
                            wickUpColor: '#26a69a', wickDownColor: '#ef5350',
                            priceFormat: commonPriceFormat,
                        });
                        break;
                    case 'bar':
                         if (typeof chart.addBarSeries !== 'function') {
                            throw new Error("Internal Error: chart.addBarSeries is not a function");
                         }
                        series = chart.addBarSeries({
                            upColor: '#26a69a', downColor: '#ef5350',
                            priceFormat: commonPriceFormat,
                        });
                        break;
                    case 'line':
                         if (typeof chart.addLineSeries !== 'function') {
                            throw new Error("Internal Error: chart.addLineSeries is not a function");
                         }
                        series = chart.addLineSeries({
                            color: '#2962ff', lineWidth: 2,
                            priceFormat: commonPriceFormat,
                        });
                        // Line chart uses 'value' instead of OHLC
                        seriesData = currentVisibleData.map(item => ({ time: item.time, value: item.close }));
                        break;
                    default:
                        console.error("Unknown chart type selected:", type);
                        return; // Exit if type is unknown
                }

                // Check if series was created successfully before setting data
                if (series) {
                    console.log("Setting data for", type, "series:", seriesData.length, "points");
                    series.setData(seriesData);
                    console.log("Series added and data set successfully.");
                    // Re-draw order lines on the new series if any exist
                    redrawOrderLines();
                } else {
                     // This case should ideally be caught by the exceptions above, but added for safety
                     console.error("Series object was not created for type:", type);
                }

            } catch (error) {
                // Catch errors specifically from adding series or setting data
                console.error(`Error during updateChartType for ${type}:`, error);
                 alert(`Ошибка при обновлении типа графика (${type}): ${error.message}`);
                 // Ensure series is null if any part of the update fails
                 if (series && chart && typeof chart.removeSeries === 'function') {
                     try { chart.removeSeries(series); } catch (e) { /* ignore */ }
                 }
                 series = null;
            }
        }

        function updateChartType(type) {
            if (!chart) {
                console.warn("Cannot update chart type: Chart not initialized.");
                return;
            }
            if (series) {
                try {
                    chart.removeSeries(series);
                    series = null;
                } catch (error) {
                    console.error("Error removing previous series:", error);
                }
            }
            // Clear old order lines visually before adding new series/lines
             clearOrderLines();


            console.log("Updating chart type to:", type);

            try {
                let seriesData = currentVisibleData; // Use the data currently meant to be visible

                switch (type) {
                    case 'candlestick':
                        series = chart.addCandlestickSeries({
                            upColor: '#26a69a', downColor: '#ef5350',
                            borderVisible: false,
                            wickUpColor: '#26a69a', wickDownColor: '#ef5350',
                            priceFormat: { type: 'price', precision: 5, minMove: 0.00001 }, // Example precision
                        });
                        break;
                    case 'bar':
                        series = chart.addBarSeries({
                            upColor: '#26a69a', downColor: '#ef5350',
                            priceFormat: { type: 'price', precision: 5, minMove: 0.00001 },
                        });
                        break;
                    case 'line':
                        series = chart.addLineSeries({
                            color: '#2962ff', lineWidth: 2,
                            priceFormat: { type: 'price', precision: 5, minMove: 0.00001 },
                        });
                        // Line chart uses 'value' instead of OHLC
                        seriesData = currentVisibleData.map(item => ({ time: item.time, value: item.close }));
                        break;
                    default:
                        console.error("Unknown chart type:", type);
                        return;
                }

                if (series) {
                    console.log("Setting data to series:", seriesData.length, "points");
                    series.setData(seriesData);
                    console.log("Series added successfully.");
                    // Re-draw order lines on the new series
                    redrawOrderLines();

                } else {
                     console.error("Failed to create series of type:", type);
                }

            } catch (error) {
                console.error(`Error adding ${type} series:`, error);
                 alert(`Ошибка при смене типа графика на ${type}: ${error.message}`);
                 // Attempt to restore a default? Or leave chart empty?
                 series = null; // Ensure series is null if adding failed
            }
        }

        function updateTheme(theme) {
            document.body.classList.remove('dark-theme', 'light-theme');
            document.body.classList.add(theme + '-theme');

            if (!chart) return; // No chart to update

            try {
                chart.applyOptions({
                    layout: {
                        background: { type: 'solid', color: theme === 'dark' ? '#1e222d' : '#ffffff' },
                        textColor: theme === 'dark' ? '#d1d4dc' : '#333333',
                    },
                    grid: {
                        vertLines: { color: theme === 'dark' ? '#2b2b43' : '#e0e0e0' },
                        horzLines: { color: theme === 'dark' ? '#2b2b43' : '#e0e0e0' },
                    },
                     rightPriceScale: {
                        borderColor: theme === 'dark' ? '#2b2b43' : '#cccccc',
                    },
                    timeScale: {
                        borderColor: theme === 'dark' ? '#2b2b43' : '#cccccc',
                    },
                });
                 console.log("Chart theme updated to:", theme);
            } catch (error) {
                 console.error("Error applying theme options:", error);
            }
        }

  function setupChartEventListeners() {
             // Add check here as well, in case it's somehow called independently or chart becomes invalid
             if (!chart || typeof chart.subscribeCrosshairMove !== 'function') {
                console.warn("setupChartEventListeners called but chart is invalid or missing methods.");
                return;
            }
             console.log("Setting up chart event listeners."); // Confirm setup call

            // --- Crosshair Move Handler ---
            // Using the robust version from previous answer
             chart.subscribeCrosshairMove((param) => {
                // Check if the essential parts of the parameter are valid
                if (!param || param.point === undefined || !param.time || !series || !param.seriesPrices) {
                     if (tooltip.style.display !== 'none') { // Hide tooltip only if it's currently visible
                         tooltip.style.display = 'none';
                     }
                     return;
                }
                // Additional check for valid screen coordinates
                if (param.point.x < 0 || param.point.x > chartContainer.clientWidth || param.point.y < 0 || param.point.y > chartContainer.clientHeight) {
                     if (tooltip.style.display !== 'none') {
                         tooltip.style.display = 'none';
                     }
                     return;
                }

                // Find the data point using time (more reliable than logical index)
                // Use currentVisibleData as it reflects what's actually on the chart during simulation
                 const dataPoint = currentVisibleData.find(d => d.time === param.time);

                if (dataPoint) {
                    const dateTime = new Date(dataPoint.time * 1000);
                    const dateString = dateTime.toLocaleDateString('ru-RU');
                    const timeString = dateTime.toLocaleTimeString('ru-RU');
                    const formattedDateTime = `${dateString} ${timeString}`;

                    let tooltipHtml = `Время: ${formattedDateTime}<br>`;
                    const currentSeriesType = chartTypeSelect.value; // Get current type

                    // Format tooltip based on series type
                    if (currentSeriesType === 'line') {
                        // Line chart uses 'value' which corresponds to 'close' in original data
                        tooltipHtml += `Цена: ${dataPoint.close.toFixed(5)}`;
                    } else { // Candlestick or Bar
                        tooltipHtml += `
                            Open: ${dataPoint.open.toFixed(5)}<br>
                            High: ${dataPoint.high.toFixed(5)}<br>
                            Low: ${dataPoint.low.toFixed(5)}<br>
                            Close: ${dataPoint.close.toFixed(5)}
                        `;
                        // Optionally add volume if parsed:
                        // if (typeof dataPoint.volume !== 'undefined') {
                        //     tooltipHtml += `<br>Volume: ${dataPoint.volume.toFixed(0)}`; // Adjust formatting as needed
                        // }
                    }

                    tooltip.innerHTML = tooltipHtml;

                    // --- Tooltip Positioning (robust version) ---
                    tooltip.style.display = 'block'; // Show it first to calculate size
                    const chartRect = chartContainer.getBoundingClientRect();
                    const tooltipRect = tooltip.getBoundingClientRect(); // Get size *after* setting display and content

                    // Calculate initial position with offset
                    let left = param.point.x + chartRect.left + 15;
                    let top = param.point.y + chartRect.top + 15;

                    // Adjust if going off right edge
                    if (left + tooltipRect.width > window.innerWidth) {
                        left = param.point.x + chartRect.left - tooltipRect.width - 15;
                    }
                    // Adjust if going off bottom edge
                    if (top + tooltipRect.height > window.innerHeight) {
                         top = param.point.y + chartRect.top - tooltipRect.height - 15;
                    }
                     // Prevent going off top/left edges
                    if (top < 0) top = 5;
                    if (left < 0) left = 5;

                    tooltip.style.left = left + 'px';
                    tooltip.style.top = top + 'px';

                } else {
                    // Hide tooltip if no corresponding data point found for the time
                     if (tooltip.style.display !== 'none') {
                         tooltip.style.display = 'none';
                     }
                }
            }); // End of subscribeCrosshairMove

            // --- Resize Handling ---
            // Using ResizeObserver for container changes
             const resizeObserver = new ResizeObserver(entries => {
                 // Ensure chart exists and we have valid entries
                 if (entries.length > 0 && chart && typeof chart.applyOptions === 'function') {
                    const { width, height } = entries[0].contentRect;
                    // Apply options only if width and height are positive
                    if (width > 0 && height > 0) {
                        chart.applyOptions({ width, height });
                        // console.log(`Chart resized via ResizeObserver to ${width}x${height}`);
                    }
                 }
            });
            // Start observing the chart container
            resizeObserver.observe(chartContainer);

            // Also handle window resize for overall layout adjustments (optional but good practice)
             window.addEventListener('resize', () => {
                if (chart && typeof chart.applyOptions === 'function' && chartContainer.clientWidth > 0 && chartContainer.clientHeight > 0) {
                    // Use current clientWidth/clientHeight which reflect changes after window resize
                    chart.applyOptions({
                        width: chartContainer.clientWidth,
                        height: chartContainer.clientHeight,
                    });
                    // console.log(`Chart resized via window resize to ${chartContainer.clientWidth}x${chartContainer.clientHeight}`);
                }
             });
             console.log("Chart event listeners successfully set up.");

        } // End 

        // --- Trading Simulation ---
        function resetSimulation() {
             console.log("Resetting simulation state.");
             isTrading = false;
             currentDataIndex = 0;
             balance = 10000;
             orders = [];
             originalData = [];
             currentVisibleData = [];
             if (chart) {
                 chart.remove();
                 chart = null;
                 series = null;
             }
             clearOrderLines();
             updateBalanceDisplay();
             updateOrdersList();
             startTradingBtn.disabled = true;
             nextCandleBtn.disabled = true;
             buyBtn.disabled = true;
             sellBtn.disabled = true;
             chartTitle.textContent = "График котировок";
        }

        function startTrading() {
            if (originalData.length < 2) { // Need at least 2 points to step forward
                alert("Недостаточно данных для начала торговли.");
                return;
            }
            console.log("Starting trading simulation.");
            isTrading = true;
            currentDataIndex = 0; // Start at the very first candle
            balance = 10000;
            orders = [];
            clearOrderLines();
            updateBalanceDisplay();
            updateOrdersList();

            // Show only the first candle initially
            currentVisibleData = [originalData[0]];
             if (chart && series) {
                 // Need to handle line chart data format
                 const seriesType = chartTypeSelect.value;
                 series.setData(seriesType === 'line' ? currentVisibleData.map(d => ({ time: d.time, value: d.close })) : currentVisibleData);
                 chart.timeScale().scrollToPosition(0, true); // Scroll to the start
                 // chart.timeScale().fitContent(); // Might show too much space initially
                 console.log("Showing initial candle.");
             } else {
                 console.error("Cannot start trading - chart or series not ready.");
                 // Try recreating the chart with just the first point
                 createChart(currentVisibleData);
                 if(!chart || !series) { // If creation still failed
                    alert("Не удалось инициализировать график для торговли.");
                    resetSimulation();
                    return;
                 }
             }


            startTradingBtn.disabled = true;
            nextCandleBtn.disabled = false;
            buyBtn.disabled = false;
            sellBtn.disabled = false;
            fileInput.disabled = true; // Disable file loading during trading
            document.querySelector('label[for="file-input"]').style.opacity = '0.5';
            document.querySelector('label[for="file-input"]').style.pointerEvents = 'none';

        }

        function showNextCandle() {
            console.log("--- showNextCandle Start ---"); // Log start

            if (!isTrading) {
                console.warn("showNextCandle called but not trading.");
                return;
            }
             if (currentDataIndex >= originalData.length - 1) {
                console.log("End of data reached.");
                if (!nextCandleBtn.disabled) { // Alert only once
                    alert('Достигнут конец данных.');
                    nextCandleBtn.disabled = true;
                }
                return;
            }


            currentDataIndex++;
            console.log(`Incremented currentDataIndex to: ${currentDataIndex}`);
            const nextCandle = originalData[currentDataIndex];
            if (!nextCandle) {
                 console.error(`Error: No data found at originalData index ${currentDataIndex}`);
                 return; // Stop if data is missing unexpectedly
            }
            currentVisibleData.push(nextCandle); // Add the new candle to visible data

            if (!chart || !series) {
                 console.error("Cannot show next candle: Chart or series object is invalid.");
                 return;
            }
             if (typeof series.update !== 'function') {
                  console.error("Cannot show next candle: series.update is not a function.");
                  return;
             }
             if (!chart.timeScale || typeof chart.timeScale !== 'function') {
                  console.error("Cannot show next candle: chart.timeScale is not available.");
                  return;
             }


            try {
                // Update the series data
                console.log(`Updating series with data for index ${currentDataIndex}`);
                const seriesType = chartTypeSelect.value;
                const updateData = seriesType === 'line' ? { time: nextCandle.time, value: nextCandle.close } : nextCandle;
                series.update(updateData);
                console.log("Series update called.");

                // --- Automatic Scrolling Logic ---
                const timeScale = chart.timeScale();
                if (!timeScale || typeof timeScale.getVisibleLogicalRange !== 'function' || typeof timeScale.scrollToPosition !== 'function') {
                     console.error("TimeScale object or required methods missing.");
                     return; // Cannot proceed with scrolling
                }

                // Give the chart a tiny moment to process the update before scrolling
                setTimeout(() => {
                    console.log("--- Inside Scrolling Timeout ---");
                    const logicalRange = timeScale.getVisibleLogicalRange();
                    console.log("Visible Logical Range:", logicalRange); // Log the range object

                    if (logicalRange !== null && typeof logicalRange.from === 'number' && typeof logicalRange.to === 'number') {
                        const barsVisible = logicalRange.to - logicalRange.from;
                         // Center calculation: Target index for the *center* is currentDataIndex
                         // Target index for the *left edge* is roughly currentDataIndex - half_visible_bars
                        const targetCenterIndex = currentDataIndex;
                        // Calculate desired left edge index to put targetCenterIndex in the middle
                        const desiredLeftPosition = Math.round(targetCenterIndex - (barsVisible / 2));
                        // Ensure left edge is not before the first bar
                        const finalLeftPosition = Math.max(0, desiredLeftPosition);

                        console.log(`Bars Visible: ${barsVisible.toFixed(1)}`);
                        console.log(`Target Center Index: ${targetCenterIndex}`);
                        console.log(`Calculated Left Position: ${desiredLeftPosition}`);
                        console.log(`Final Left Position (>=0): ${finalLeftPosition}`);

                        // Perform the scroll
                        console.log(`Calling timeScale.scrollToPosition(${finalLeftPosition}, false)...`);
                        timeScale.scrollToPosition(finalLeftPosition, false); // false = no animation
                        console.log("scrollToPosition call finished.");

                    } else {
                         console.warn("Could not get valid logical range after update. Skipping scroll.");
                         // As a fallback, maybe try scrolling to the end?
                         // console.log("Fallback: Trying scrollToRealTime...");
                         // timeScale.scrollToRealTime();
                    }
                    console.log("--- Exiting Scrolling Timeout ---");
                }, 50); // Delay of 50ms - adjust if needed


            } catch(error) {
                 console.error("Error during series update or scrolling logic:", error);
                 // Handle potential errors gracefully
            }

            // Update P/L and display regardless of scrolling success
            try {
                updateOpenOrdersProfit(nextCandle.close);
                updateBalanceDisplay();
                updateOrdersList();
            } catch (updateError) {
                console.error("Error updating orders/balance display:", updateError);
            }
             console.log("--- showNextCandle End ---");

        } // End of showNextCandle
        
        
        function placeOrder(type) {
            if (!isTrading || currentVisibleData.length === 0) return;

            const currentCandle = currentVisibleData[currentVisibleData.length - 1];
            const currentPrice = currentCandle.close;
            const currentTime = currentCandle.time;

            const order = {
                type: type,
                price: currentPrice,
                volume: 1, // Fixed volume for simplicity
                openTime: currentTime,
                profit: 0, // Initial profit is zero
                currentPrice: currentPrice,
                line: null // Placeholder for the price line object
            };
            orders.push(order);
            console.log(`${type} order placed at ${currentPrice.toFixed(5)} (Time: ${new Date(currentTime * 1000).toLocaleString()})`);

            // Add a visual line on the chart for the order
            if (chart && series) {
                 order.line = series.createPriceLine({
                    price: order.price,
                    color: type === 'BUY' ? '#26a69a' : '#ef5350',
                    lineWidth: 1,
                    lineStyle: LightweightCharts.LineStyle.Dashed,
                    axisLabelVisible: true,
                    title: `${type} @ ${order.price.toFixed(4)}`,
                 });
                 orderLines.push(order.line); // Keep track
            }

            updateOrdersList();
            // No balance change on opening an order (margin/leverage not simulated)
        }

        function updateOpenOrdersProfit(currentPrice) {
            let totalUnrealizedProfit = 0;
            orders.forEach(order => {
                order.currentPrice = currentPrice;
                const priceDiff = order.type === 'BUY' ? (currentPrice - order.price) : (order.price - currentPrice);
                order.profit = priceDiff * order.volume; // Profit calculation
                totalUnrealizedProfit += order.profit;
            });
            return totalUnrealizedProfit;
        }

        function updateBalanceDisplay() {
            // Balance reflects initial capital + realized P/L
            // Equity reflects current balance + unrealized P/L
            let currentProfit = 0;
            if(isTrading && currentVisibleData.length > 0){
                const currentPrice = currentVisibleData[currentVisibleData.length - 1].close;
                currentProfit = updateOpenOrdersProfit(currentPrice);
            }
            const equity = balance + currentProfit;
            balanceDisplay.textContent = `Баланс: $${balance.toFixed(2)} (Equity: $${equity.toFixed(2)})`;
        }

        function updateOrdersList() {
            ordersList.innerHTML = ''; // Clear previous list
            if (orders.length === 0) {
                 ordersList.innerHTML = 'Нет открытых ордеров';
                 return;
            }

            orders.forEach((order, index) => {
                const orderElement = document.createElement('div');
                orderElement.classList.add('order-item');
                const openDate = new Date(order.openTime * 1000).toLocaleTimeString('ru-RU');

                const profitClass = order.profit > 0 ? 'positive' : (order.profit < 0 ? 'negative' : '');
                const profitSign = order.profit > 0 ? '+' : '';

                orderElement.innerHTML = `
                    <span>${order.type} ${order.volume} @ ${order.price.toFixed(5)} (${openDate})</span>
                    <span class="order-profit ${profitClass}" data-index="${index}" title="Нажмите для закрытия">
                        P/L: ${profitSign}${order.profit.toFixed(2)}
                    </span>
                `;

                // Add click listener directly
                const profitSpan = orderElement.querySelector('.order-profit');
                 if (profitSpan) {
                    profitSpan.addEventListener('click', closeOrder);
                 }

                ordersList.appendChild(orderElement);
            });
        }

        function closeOrder(event) {
            if (!isTrading) return;

            const orderIndex = parseInt(event.target.getAttribute('data-index'));
            if (isNaN(orderIndex) || orderIndex < 0 || orderIndex >= orders.length) {
                 console.error("Invalid order index for closing:", event.target.getAttribute('data-index'));
                 return;
            }

            const order = orders[orderIndex];
            const currentPrice = currentVisibleData[currentVisibleData.length - 1].close; // Close at current price

            // Recalculate final profit one last time
            const priceDiff = order.type === 'BUY' ? (currentPrice - order.price) : (order.price - currentPrice);
            const finalProfit = priceDiff * order.volume;

            console.log(`Closing order ${order.type} opened at ${order.price.toFixed(5)}. Close price: ${currentPrice.toFixed(5)}. Profit: ${finalProfit.toFixed(2)}`);

            // Realize profit/loss by adding it to the balance
            balance += finalProfit;

            // Remove the order's visual line from the chart
            if (chart && series && order.line) {
                try {
                    series.removePriceLine(order.line);
                    // Remove from our tracking array too
                    const lineIndex = orderLines.indexOf(order.line);
                    if(lineIndex > -1) orderLines.splice(lineIndex, 1);
                } catch (error) {
                    console.warn("Could not remove price line for closed order:", error);
                }
            }

            // Remove order from the array
            orders.splice(orderIndex, 1);

            // Update display
            updateBalanceDisplay();
            updateOrdersList(); // Re-render the list without the closed order
        }

         function clearOrderLines() {
            if (chart && series && orderLines.length > 0) {
                 console.log("Clearing old order price lines:", orderLines.length);
                 orderLines.forEach(line => {
                    try {
                        series.removePriceLine(line);
                    } catch(e) { /* ignore if already removed */ }
                 });
            }
             orderLines = []; // Reset the tracking array
         }

         function redrawOrderLines() {
            if (!chart || !series || orders.length === 0) return;
             console.log("Redrawing order lines for", orders.length, "orders");
             clearOrderLines(); // Remove any existing ones first

             orders.forEach(order => {
                  try {
                     order.line = series.createPriceLine({
                        price: order.price,
                        color: order.type === 'BUY' ? '#26a69a' : '#ef5350',
                        lineWidth: 1,
                        lineStyle: LightweightCharts.LineStyle.Dashed,
                        axisLabelVisible: true,
                        title: `${order.type} @ ${order.price.toFixed(4)}`,
                     });
                     orderLines.push(order.line); // Track the new line object
                  } catch(error) {
                      console.error("Error redrawing price line for order:", order, error);
                  }
             });
         }

    </script>
</body>
</html>