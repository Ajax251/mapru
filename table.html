<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Таблица</title>
    <link rel="icon" href="https://i.ibb.co/B28zDrny/excel.png" type="image/png">
    <script src="/webfonts/xlsx.full.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            height: 100%;
            width: 100%;
            overflow: hidden;
            background-color: #f5f5f5;
            user-select: none;
        }

        .container {
            display: flex;
            flex-direction: column;
            height: 100vh;
            width: 100vw;
        }

        .toolbar {
            display: none;
        }

        button {
            display: none; /* General rule, specific buttons will override this */
        }

        #file-input {
            display: none;
        }

        .table-container {
            flex: 1;
            overflow: auto;
            background-color: white;
            position: relative;
            border: 1px solid #e0e0e0;
            border-radius: 5px;
            margin: 10px;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            font-size: 14px;
        }

        th, td {
            padding: 10px;
            text-align: left;
            border: 1px solid #e0e0e0;
            min-width: 120px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            position: relative;
        }

        th {
            background-color: #4a90e2;
            color: white;
            font-weight: 600;
            position: sticky;
            top: 0;
            z-index: 10;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        tbody tr:nth-child(even) {
            background-color: #f8f9fa;
        }

        tbody tr:hover {
            background-color: #eef4ff;
        }

        .status-bar {
            background-color: #f0f0f0;
            padding: 8px 15px;
            font-size: 13px;
            color: #666;
            border-top: 1px solid #ddd;
            margin: 0 10px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .status-bar select {
            padding: 4px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 13px;
            background-color: white;
            cursor: pointer;
        }

        input, select {
            padding: 6px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
        }

        .dialog-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            z-index: 900;
        }

        .dialog {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            z-index: 1000;
            min-width: 400px;
            max-width: 90%;
            max-height: 90vh;
            overflow-y: auto;
        }

        .dialog-title {
            margin-bottom: 15px;
            font-size: 20px;
            color: #333;
            font-weight: 600;
        }

        .dialog p {
            margin-bottom: 15px;
            color: #555;
        }

        .dialog div {
            margin-bottom: 12px;
        }

        .dialog label {
            margin-left: 8px;
            color: #333;
        }

        .dialog input[type="radio"] {
            margin-right: 8px;
        }

        .dialog input[type="text"] {
            margin-left: 8px;
            padding: 6px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
        }

        .dialog-buttons {
            display: flex;
            justify-content: flex-end;
            gap: 10px;
            margin-top: 20px;
            padding-top: 15px;
            border-top: 1px solid #ddd;
        }

        .dialog-buttons button {
            display: block !important; /* Ensure dialog buttons are visible */
            padding: 8px 16px;
            border: none;
            border-radius: 4px;
            background-color: #007bff;
            color: white;
            cursor: pointer;
            font-size: 14px;
            transition: background-color 0.3s ease;
        }

        .dialog-buttons button:hover {
            background-color: #0056b3;
        }

        .dialog-buttons button#separator-cancel,
        .dialog-buttons button#update-separator-cancel,
        .dialog-buttons button#rename-column-cancel,
        .dialog-buttons button#save-cancel,
        .dialog-buttons button#move-column-cancel,
        .dialog-buttons button#move-row-cancel,
        .dialog-buttons button#replace-empty-cancel {
            background-color: #dc3545;
        }

        .dialog-buttons button#separator-cancel:hover,
        .dialog-buttons button#update-separator-cancel:hover,
        .dialog-buttons button#rename-column-cancel:hover,
        .dialog-buttons button#save-cancel:hover,
        .dialog-buttons button#move-column-cancel:hover,
        .dialog-buttons button#move-row-cancel:hover,
        .dialog-buttons button#replace-empty-cancel:hover {
            background-color: #c82333;
        }

        .context-menu {
            display: none;
            position: absolute;
            background-color: white;
            border: 1px solid #ddd;
            border-radius: 4px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
            z-index: 1000;
            padding: 5px 0;
        }

        .context-menu-item {
            padding: 8px 15px;
            cursor: pointer;
            white-space: nowrap;
        }

        .context-menu-item:hover {
            background-color: #f0f0f0;
        }

        .context-menu-separator {
            height: 1px;
            background-color: #ddd;
            margin: 5px 0;
        }

        .empty-state {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100%;
            color: #888;
            cursor: pointer;
        }

        .icon-large {
            font-size: 48px;
            margin-bottom: 15px;
            color: #aaa;
        }

        .empty-state #format-button-empty-state {
            display: inline-block; /* Make this button visible */
            padding: 10px 20px;
            margin-top: 20px;
            font-size: 16px;
            color: white;
            background-color: #007bff;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s ease;
        }

        .empty-state #format-button-empty-state:hover {
            background-color: #0056b3;
        }

        .column-resize-handle {
            display: none;
        }

        .column-resizing {
            cursor: default;
            user-select: auto;
        }

        #rename-column-dialog input[type="text"] {
            width: 100%;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
            margin-top: 10px;
        }

        #preview {
            background-color: #f9f9f9;
            border: 1px solid #ddd;
            padding: 10px;
            margin-top: 15px;
            max-height: 150px;
            overflow-y: auto;
            font-family: 'Courier New', Courier, monospace;
            font-size: 12px;
            color: #333;
            white-space: pre-wrap;
        }

        /* The switch - the box around the slider */
        .switch {
          position: relative;
          display: inline-block;
          width: 30px; /* Smaller width */
          height: 17px; /* Smaller height */
          margin: 0 5px;
        }

        /* Hide default HTML checkbox */
        .switch input {
          opacity: 0;
          width: 0;
          height: 0;
        }

        /* The slider */
        .slider {
          position: absolute;
          cursor: pointer;
          top: 0;
          left: 0;
          right: 0;
          bottom: 0;
          background-color: #ccc;
          -webkit-transition: .4s;
          transition: .4s;
        }

        .slider:before {
          position: absolute;
          content: "";
          height: 13px; /* Smaller circle */
          width: 13px; /* Smaller circle */
          left: 2px; /* Adjust position */
          bottom: 2px; /* Adjust position */
          background-color: white;
          -webkit-transition: .4s;
          transition: .4s;
        }

        input:checked + .slider {
          background-color: #2196F3;
        }

        input:focus + .slider {
          box-shadow: 0 0 1px #2196F3;
        }

        input:checked + .slider:before {
          -webkit-transform: translateX(13px); /* Adjust translation */
          -ms-transform: translateX(13px); /* Adjust translation */
          transform: translateX(13px); /* Adjust translation */
        }

        /* Rounded sliders */
        .slider.round {
          border-radius: 17px; /* Match height */
        }

        .slider.round:before {
          border-radius: 50%;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="toolbar">
            <input type="file" id="file-input" accept=".csv,.txt,.xlsx">
            <button id="open-file-btn">Открыть файл</button>
            <button id="save-file-btn" disabled>Сохранить</button>
            <button id="save-as-file-btn" disabled>Сохранить как</button>
        </div>

        <div class="table-container" id="table-container">
            <div class="empty-state" id="empty-state">
                <div class="icon-large">
                    <img src="https://i.ibb.co/B28zDrny/excel.png" alt="Excel Icon" style="width: 48px; height: 48px;">
                </div>
                <p>Открыть файл</p>
                <button id="format-button-empty-state">Форматировать</button>
            </div>
            <table id="data-table" style="display: none;">
                <thead>
                    <tr id="header-row"></tr>
                </thead>
                <tbody id="table-body"></tbody>
            </table>
        </div>

        <div class="status-bar" id="status-bar">
            <select id="sheet-selector" style="display: none;"></select>
            <span id="status-message">Готов</span>
            <div style="flex-grow: 1;"></div> <!-- Spacer to push filter to the right -->
            <input type="text" id="filter-input" placeholder="Фильтр..." style="padding: 4px; font-size: 13px; border: 1px solid #ccc; border-radius: 4px; width: 150px;">
            <div style="display: flex; align-items: center; gap: 5px; font-size: 13px;">
                <span>ячейка</span>
                <label class="switch">
                    <input type="checkbox" id="filter-mode-toggle">
                    <span class="slider round"></span>
                </label>
                <span>строка</span>
            </div>
        </div>
    </div>

    <div class="dialog-overlay" id="dialog-overlay"></div>
  <div class="dialog" id="separator-dialog">
    <h3 class="dialog-title">Выбор разделителя</h3>
    <p>Выберите разделитель для файла:</p>
    <div>
        <input type="radio" name="separator" id="comma" value=",">
        <label for="comma">Запятая (,)</label>
    </div>
    <div>
        <input type="radio" name="separator" id="semicolon" value=";" checked>
        <label for="semicolon">Точка с запятой (;)</label>
    </div>
    <div>
        <input type="radio" name="separator" id="tab" value="\t">
        <label for="tab">Табуляция</label>
    </div>
    <div>
        <input type="radio" name="separator" id="space" value=" ">
        <label for="space">Пробел</label>
    </div>
    <div>
        <input type="radio" name="separator" id="custom" value="custom">
        <label for="custom">Другой:</label>
        <input type="text" id="custom-separator" placeholder="Укажите символ" size="1" maxlength="1">
    </div>
    <div style="margin-top: 15px;">
        <input type="checkbox" id="first-row-header" checked>
        <label for="first-row-header">Заголовок в первой строке</label>
    </div>
    <div style="margin-top: 15px;">
        <label for="encoding-select">Кодировка:</label>
        <select id="encoding-select">
            <option value="utf-8" selected>UTF-8</option>
            <option value="windows-1251">ANSI (Windows-1251)</option>
        </select>
    </div>
    <div id="preview"></div>
    <div class="dialog-buttons">
        <button id="separator-cancel">Отмена</button>
        <button id="separator-confirm">Применить</button>
    </div>
</div>

    <div class="dialog" id="rename-column-dialog">
        <h3 class="dialog-title">Переименовать столбец</h3>
        <p>Введите новое имя для столбца:</p>
        <div>
            <input type="text" id="new-column-name" placeholder="Новое имя столбца" style="width: 100%;">
        </div>
        <div class="dialog-buttons">
            <button id="rename-column-cancel">Отмена</button>
            <button id="rename-column-confirm">Применить</button>
        </div>
    </div>

    <div class="dialog" id="save-dialog">
        <h3 class="dialog-title">Сохранить файл</h3>
        <div>
            <label for="save-format">Формат файла:</label>
            <select id="save-format">
                <option value="csv">CSV</option>
                <option value="txt">TXT</option>
                <option value="xlsx">Excel (XLSX)</option>
            </select>
        </div>
        <div id="separator-container" style="margin-top: 10px;">
            <label for="save-separator">Разделитель:</label>
            <select id="save-separator">
                <option value=";">Точка с запятой (;)</option>
                <option value=",">Запятая (,)</option>
                <option value="\t">Табуляция</option>
                <option value=" ">Пробел</option>
                <option value="custom">Другой</option>
            </select>
            <input type="text" id="save-custom-separator" placeholder="Символ" size="1" maxlength="1" style="display: none;">
        </div>
        <div class="dialog-buttons">
            <button id="save-cancel">Отмена</button>
            <button id="save-confirm">Сохранить</button>
        </div>
    </div>

    <div class="context-menu" id="context-menu"></div>

    <div class="dialog" id="update-separator-dialog">
        <h3 class="dialog-title">Обновить разделитель</h3>
        <p>Выберите новый разделитель для текущих данных:</p>
        <div>
            <input type="radio" name="new-separator" id="new-comma" value=",">
            <label for="new-comma">Запятая (,)</label>
        </div>
        <div>
            <input type="radio" name="new-separator" id="new-semicolon" value=";" checked>
            <label for="new-semicolon">Точка с запятой (;)</label>
        </div>
        <div>
            <input type="radio" name="new-separator" id="new-tab" value="\t">
            <label for="new-tab">Табуляция</label>
        </div>
        <div>
            <input type="radio" name="new-separator" id="new-space" value=" ">
            <label for="new-space">Пробел</label>
        </div>
        <div>
            <input type="radio" name="new-separator" id="new-custom" value="custom">
            <label for="new-custom">Другой:</label>
            <input type="text" id="new-custom-separator" placeholder="Укажите символ" size="1" maxlength="1">
        </div>
        <div class="dialog-buttons">
            <button id="update-separator-cancel">Отмена</button>
            <button id="update-separator-confirm">Применить</button>
        </div>
    </div>

    <div class="dialog" id="move-column-dialog">
        <h3 class="dialog-title">Переместить столбец</h3>
        <p>Выберите, ПЕРЕД каким столбцом переместить столбец:</p>
        <div style="margin-top: 10px;">
            <select id="column-to-select" style="width: 100%;">
            </select>
        </div>
        <div class="dialog-buttons">
            <button id="move-column-cancel">Отмена</button>
            <button id="move-column-confirm">Переместить</button>
        </div>
    </div>

    <div class="dialog" id="move-row-dialog">
        <h3 class="dialog-title">Переместить строку</h3>
        <p>Выберите, ПЕРЕД какой строкой переместить строку:</p>
        <div style="margin-top: 10px;">
            <select id="row-to-select" style="width: 100%;">
            </select>
        </div>
        <div class="dialog-buttons">
            <button id="move-row-cancel">Отмена</button>
            <button id="move-row-confirm">Переместить</button>
        </div>
    </div>
    
    <div class="dialog" id="replace-empty-dialog">
    <h3 class="dialog-title">Заменить пустые строки</h3>
    <p>Введите текст для замены пустых значений в столбце:</p>
    <div>
        <input type="text" id="replace-empty-text" placeholder="Введите текст" style="width: 100%;">
    </div>
    <div class="dialog-buttons">
        <button id="replace-empty-cancel">Отмена</button>
        <button id="replace-empty-confirm">Применить</button>
    </div>
</div>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            const fileInput = document.getElementById('file-input');
            const tableContainer = document.getElementById('table-container');
            const dataTable = document.getElementById('data-table');
            const headerRow = document.getElementById('header-row');
            const tableBody = document.getElementById('table-body');
            const emptyState = document.getElementById('empty-state');
            const statusBar = document.getElementById('status-bar');
            const statusMessage = document.getElementById('status-message');
            const sheetSelector = document.getElementById('sheet-selector');
            const iconLarge = emptyState.querySelector('.icon-large');
            const dialogOverlay = document.getElementById('dialog-overlay');
            const separatorDialog = document.getElementById('separator-dialog');
            const separatorCancel = document.getElementById('separator-cancel');
            const separatorConfirm = document.getElementById('separator-confirm');
            const customSeparator = document.getElementById('custom-separator');
            const preview = document.getElementById('preview');
            const saveDialog = document.getElementById('save-dialog');
            const saveFormat = document.getElementById('save-format');
            const saveSeparator = document.getElementById('save-separator');
            const saveCustomSeparator = document.getElementById('save-custom-separator');
            const saveCancel = document.getElementById('save-cancel');
            const saveConfirm = document.getElementById('save-confirm');
            const contextMenu = document.getElementById('context-menu');
            const filterInput = document.getElementById('filter-input');
            const filterModeToggle = document.getElementById('filter-mode-toggle');
            const formatButtonEmptyState = document.getElementById('format-button-empty-state');


            let data = [];
            let headers = [];
            let currentSeparator = null;
            let currentFilename = null;
            let currentFileSize = null;
            let modified = false;
            let contextMenuTarget = null;
            let columnWidths = {};
            let workbook = null; // Для хранения Excel workbook
            let lastActionMessage = 'Готов'; // Для хранения последнего сообщения об операции

            let renameColumnDialog = document.getElementById('rename-column-dialog');
            let renameColumnCancel = document.getElementById('rename-column-cancel');
            let renameColumnConfirm = document.getElementById('rename-column-confirm');
            let newColumnNameInput = document.getElementById('new-column-name');
            let currentColumnIndex = null;
            
            
            // Функция updatePreview вынесена наружу
    function updatePreview(file, encodingSelect, previewElement) { // Renamed 'preview' to 'previewElement' to avoid conflict
        const reader = new FileReader();
        reader.onload = function(e) {
            let content;
            const encoding = encodingSelect.value;

            if (encoding === 'windows-1251') {
                const uint8Array = new Uint8Array(e.target.result);
                content = new TextDecoder('windows-1251').decode(uint8Array);
            } else {
                content = new TextDecoder('utf-8').decode(new Uint8Array(e.target.result));
            }

            const lines = content.split(/\r?\n/).filter(line => line.trim()).slice(0, 10);
            previewElement.textContent = lines.join('\n');
        };
        reader.readAsArrayBuffer(file);
    }

    function showSeparatorDialog() {
        if (!fileInput.files[0]) return;

        const file = fileInput.files[0];
        const fileName = file.name.toLowerCase();

        if (fileName.endsWith('.xlsx')) {
            processXLSXFile(file);
            return;
        }

        dialogOverlay.style.display = 'block';
        separatorDialog.style.display = 'block';
        document.getElementById('semicolon').checked = true;

        const encodingSelect = document.getElementById('encoding-select');

        // Обновляем preview при загрузке файла
        updatePreview(file, encodingSelect, preview); // 'preview' is the global const for the preview div

        // Обновляем preview при изменении кодировки
        // To avoid multiple listeners, remove old one if any or ensure it's idempotent
        // For simplicity here, we'll rely on it being added once per dialog show
        const previewUpdateHandler = () => updatePreview(file, encodingSelect, preview);
        encodingSelect.removeEventListener('change', previewUpdateHandler); // Remove previous if any
        encodingSelect.addEventListener('change', previewUpdateHandler);
    }

    function hideSeparatorDialog() {
        dialogOverlay.style.display = 'none';
        separatorDialog.style.display = 'none';
        preview.textContent = ''; // Clear preview content
        // No need to remove listener explicitly here if it's re-added in showSeparatorDialog
    }

            function showRenameColumnDialog(columnIndex) {
                currentColumnIndex = columnIndex;
                newColumnNameInput.value = headers[columnIndex];
                dialogOverlay.style.display = 'block';
                renameColumnDialog.style.display = 'block';
                newColumnNameInput.focus();
            }

            function hideRenameColumnDialog() {
                dialogOverlay.style.display = 'none';
                renameColumnDialog.style.display = 'none';
                currentColumnIndex = null;
            }

            renameColumnCancel.addEventListener('click', hideRenameColumnDialog);

            renameColumnConfirm.addEventListener('click', () => {
                if (currentColumnIndex !== null) {
                    const newName = newColumnNameInput.value.trim();
                    if (newName) {
                        headers[currentColumnIndex] = newName;
                        renderTable(false);
                        modified = true;
                        updateStatusBar(`Столбец переименован на "${newName}"`);
                    } else {
                        alert('Имя столбца не может быть пустым!');
                    }
                }
                hideRenameColumnDialog();
            });

            newColumnNameInput.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    renameColumnConfirm.click();
                }
            });

            fileInput.addEventListener('change', showSeparatorDialog);

            separatorCancel.addEventListener('click', () => {
                hideSeparatorDialog();
                resetFileInput();
            });

            separatorConfirm.addEventListener('click', () => {
                const selectedSeparator = document.querySelector('input[name="separator"]:checked').value;
                let separator;
                if (selectedSeparator === 'custom') {
                    separator = customSeparator.value || ';';
                } else if (selectedSeparator === '\\t') {
                    separator = '\t';
                } else {
                    separator = selectedSeparator;
                }
                hideSeparatorDialog();
                processFileContent(fileInput.files[0], separator);
            });

            document.getElementById('custom').addEventListener('change', () => {
                customSeparator.focus();
            });

            saveSeparator.addEventListener('change', () => {
                saveCustomSeparator.style.display = saveSeparator.value === 'custom' ? 'inline' : 'none';
                if (saveSeparator.value === 'custom') {
                    saveCustomSeparator.focus();
                }
            });

            saveFormat.addEventListener('change', () => {
                const separatorContainer = document.getElementById('separator-container');
                if (saveFormat.value === 'xlsx') {
                    separatorContainer.style.display = 'none';
                } else {
                    separatorContainer.style.display = 'block';
                }
            });

            saveCancel.addEventListener('click', hideSaveDialog);
            saveConfirm.addEventListener('click', () => {
                let separator;
                let format = saveFormat.value;

                if (format !== 'xlsx') {
                    if (saveSeparator.value === 'custom') {
                        separator = saveCustomSeparator.value || ';';
                    } else if (saveSeparator.value === '\\t') {
                        separator = '\t';
                    } else {
                        separator = saveSeparator.value;
                    }
                }

                let filename = currentFilename;
                if (!filename) {
                    filename = `table.${format}`;
                } else {
                    filename = filename.substring(0, filename.lastIndexOf('.')) + `.${format}`;
                }

                saveFile(filename, separator, format);
                hideSaveDialog();
            });

            tableContainer.addEventListener('contextmenu', handleContextMenu);
            document.addEventListener('click', hideContextMenu);

            iconLarge.addEventListener('click', () => {
                fileInput.click();
            });
             // Also make the "Открыть файл" text clickable
            emptyState.querySelector('p').addEventListener('click', () => {
                fileInput.click();
            });


            sheetSelector.addEventListener('change', () => {
                loadSheet(sheetSelector.value);
            });

            // Add event listeners for filter
            filterInput.addEventListener('input', applyFilter);
            filterModeToggle.addEventListener('change', applyFilter);

            // Event listener for the new "Форматировать" button
            if (formatButtonEmptyState) {
                formatButtonEmptyState.addEventListener('click', () => {
                    window.location.href = 'format.html';
                });
            }


            function resetFileInput() {
                fileInput.value = '';
            }

            function processXLSXFile(file) {
                const reader = new FileReader();

                reader.onload = function(e) {
                    const arrayBuffer = e.target.result;
                    workbook = XLSX.read(arrayBuffer, {type: 'array'});
                    currentFileSize = Math.round(file.size / 1024); // Размер в КБ
                    currentFilename = file.name;

                    // Заполняем селектор листов
                    sheetSelector.innerHTML = '';
                    workbook.SheetNames.forEach(sheetName => {
                        const option = document.createElement('option');
                        option.value = sheetName;
                        option.textContent = sheetName;
                        sheetSelector.appendChild(option);
                    });
                    sheetSelector.style.display = 'inline-block';

                    // Загружаем первый лист по умолчанию
                    loadSheet(workbook.SheetNames[0]);
                };

                reader.onerror = function() {
                    updateStatusBar('Ошибка чтения Excel-файла.');
                    alert('Ошибка чтения Excel-файла.');
                    resetFileInput();
                };

                reader.readAsArrayBuffer(file);
            }

            function loadSheet(sheetName) {
                const worksheet = workbook.Sheets[sheetName];
                const jsonData = XLSX.utils.sheet_to_json(worksheet, {header: 1});

                if (jsonData.length === 0) {
                    alert("Лист пуст или не содержит данных.");
                    return;
                }

                headers = jsonData[0].map(header => header ? String(header) : '');
                data = jsonData.slice(1).map(row => {
                    const filledRow = [...row];
                    while (filledRow.length < headers.length) {
                        filledRow.push('');
                    }
                    return filledRow.map(cell => cell !== undefined ? String(cell) : '');
                });

                currentSeparator = null;
                renderTable(true);
                updateStatusBar(`Открыт лист: ${sheetName}`);
            }

function processFileContent(file, separator) {
    if (!file) {
        updateStatusBar('Ошибка: Файл не выбран.');
        return;
    }
    
    const firstRowHeader = document.getElementById('first-row-header').checked;
    const encoding = document.getElementById('encoding-select').value;
    const reader = new FileReader();

    reader.onload = function(e) {
        let content;
        if (encoding === 'windows-1251') {
            const uint8Array = new Uint8Array(e.target.result);
            content = new TextDecoder('windows-1251').decode(uint8Array);
        } else {
            content = new TextDecoder('utf-8').decode(new Uint8Array(e.target.result));
        }
        
        parseCSV(content, separator);
        currentFilename = file.name;
        currentFileSize = Math.round(file.size / 1024); // Размер в КБ
        currentSeparator = separator;
        sheetSelector.style.display = 'none';
        updateStatusBar(`Открыт файл: ${file.name} (разделитель: "${separator === '\t' ? 'Табуляция' : separator === ' ' ? 'Пробел' : separator}", кодировка: ${encoding.toUpperCase()})`);
        applyFilter(); // Apply filter after loading
    };

    reader.onerror = function() {
        updateStatusBar('Ошибка чтения файла.');
        alert('Ошибка чтения файла.');
        resetFileInput();
    };

    reader.readAsArrayBuffer(file); // Читаем как ArrayBuffer для поддержки кодировок
}

        function parseCSV(content, separator) {
    const lines = content.split(/\r?\n/).filter(line => line.trim());
    const firstRowHeader = document.getElementById('first-row-header').checked;

    if (lines.length === 0) {
         headers = [];
         data = [];
         renderTable(true); // Render empty table
         updateStatusBar("Файл пуст или не содержит данных.");
         return;
    }

    data = [];
    
    if (firstRowHeader) {
        const headerLine = lines[0];
        headers = headerLine.split(separator).map(header => header.trim());
        
        for (let i = 1; i < lines.length; i++) {
            if (!lines[i].trim()) continue;
            let row = parseCSVRow(lines[i], separator);
            while (row.length < headers.length) {
                row.push('');
            }
            data.push(row);
        }
    } else {
        const firstLine = lines[0];
        const columnCount = parseCSVRow(firstLine, separator).length;
        headers = Array.from({length: columnCount}, (_, i) => `Столбец ${i + 1}`);

        for (let i = 0; i < lines.length; i++) {
            if (!lines[i].trim()) continue;
            let row = parseCSVRow(lines[i], separator);
            while (row.length < headers.length) {
                row.push('');
            }
            data.push(row);
        }
    }

    renderTable(true);
}

function parseCSVRow(line, separator) {
    const row = [];
    let inQuote = false;
    let currentValue = '';

    for (let j = 0; j < line.length; j++) {
        const char = line[j];

        if (char === '"') {
            // Handle escaped quotes ""
            if (inQuote && j + 1 < line.length && line[j+1] === '"') {
                currentValue += '"';
                j++; // Skip next quote
                continue;
            }
            inQuote = !inQuote;
        } else if (char === separator && !inQuote) {
            row.push(currentValue.trim());
            currentValue = '';
        } else {
            currentValue += char;
        }
    }
    row.push(currentValue.trim()); // Add the last value
    return row;
}


            function renderTable(doAdjustWidths = false) {
                headerRow.innerHTML = '';
                tableBody.innerHTML = '';

                if (headers.length === 0 && data.length === 0) {
                    dataTable.style.display = 'none';
                    emptyState.style.display = 'flex'; // Use flex as per its style
                    updateStatusBar('Готов. Нет данных для отображения.');
                    return;
                }


                dataTable.style.display = 'table';
                emptyState.style.display = 'none';

                headers.forEach((header, index) => {
                    const th = document.createElement('th');
                    th.textContent = header || `Столбец ${index + 1}`;
                    th.dataset.index = index;
                    th.dataset.type = 'header';
                    headerRow.appendChild(th);
                });

                data.forEach((row, rowIndex) => {
                    const tr = document.createElement('tr');
                    tr.dataset.index = rowIndex;

                    row.forEach((cell, cellIndex) => {
                        const td = document.createElement('td');
                        td.textContent = cell;
                        td.dataset.row = rowIndex;
                        td.dataset.col = cellIndex;
                        td.dataset.type = 'cell';
                        td.addEventListener('dblclick', () => editCell(td, rowIndex, cellIndex));
                        tr.appendChild(td);
                    });

                    tableBody.appendChild(tr);
                });

                if (doAdjustWidths) {
                    adjustColumnWidths();
                }

                applyFilter(); // Apply filter after rendering
            }

            function adjustColumnWidths() {
                if (headers.length === 0) return;

                headerRow.childNodes.forEach((th, colIndex) => {
                    let maxWidth = 0;

                    maxWidth = Math.max(maxWidth, th.offsetWidth);

                    tableBody.querySelectorAll(`td[data-col="${colIndex}"]`).forEach(td => {
                        maxWidth = Math.max(maxWidth, td.offsetWidth);
                    });

                    const calculatedWidth = maxWidth + 20;
                    columnWidths[colIndex] = `${calculatedWidth}px`;

                    th.style.width = `${calculatedWidth}px`;
                    tableBody.querySelectorAll(`td[data-col="${colIndex}"]`).forEach(td => {
                        td.style.width = `${calculatedWidth}px`;
                    });
                });
            }

            function editCell(cell, rowIndex, colIndex) {
                const currentValue = data[rowIndex][colIndex];
                const input = document.createElement('input');
                input.type = 'text';
                input.value = currentValue;
                input.style.width = '90%';

                cell.textContent = '';
                cell.appendChild(input);
                input.focus();

                input.addEventListener('blur', finishEdit);
                input.addEventListener('keydown', e => {
                    if (e.key === 'Enter') {
                        finishEdit();
                    } else if (e.key === 'Escape') {
                        cell.textContent = currentValue;
                        // Re-attach dblclick listener if it was removed or stopPropagation was used
                        // However, it's simpler to just restore text and not worry about listeners here
                    }
                });

                function finishEdit() {
                    const newValue = input.value;
                    cell.textContent = newValue;
                    data[rowIndex][colIndex] = newValue;
                    modified = true;
                    updateStatusBar('Данные изменены');
                    applyFilter(); // Apply filter after cell edit
                }
            }

            function handleContextMenu(e) {
                hideContextMenu();
                e.preventDefault();

                contextMenuTarget = e.target;
                contextMenu.innerHTML = '';

                if (!currentFilename && data.length === 0) { // Only show "Открыть" if no file is loaded
                    addContextMenuItem('Открыть', () => {
                        fileInput.click();
                    });
                    addContextMenuSeparator();
                }


                if (currentFilename || data.length > 0) { // Show save options if there's data
                    addContextMenuItem('Сохранить', () => {
                        if (currentFilename && currentFilename.endsWith('.xlsx')) {
                            saveFile(currentFilename, null, 'xlsx');
                        } else {
                            saveFile(currentFilename || 'table.csv', currentSeparator || ';');
                        }
                    });
                    addContextMenuItem('Сохранить как...', showSaveDialog);
                    addContextMenuSeparator();

                    if (currentSeparator !== null) { // Only show update separator if it's a text file
                        addContextMenuItem('Обновить разделитель', () => {
                            showUpdateSeparatorDialog();
                        });
                        addContextMenuSeparator();
                    }
                }


                const element = e.target;
                const elementType = element.dataset.type;

                if (elementType === 'header' && headers.length > 0) {
                    const columnIndex = parseInt(element.dataset.index);
                    addContextMenuItem('Переименовать столбец', () => {
                        showRenameColumnDialog(columnIndex);
                    });
                    addContextMenuSeparator();
                    
                    addContextMenuItem('Заменить пустые строки на...', () => {
            showReplaceEmptyDialog(columnIndex);
        });
        

                    if (headers.length > 0) {
                        addContextMenuItem('Вставить столбец слева', () => {
                            insertColumn(columnIndex);
                        });
                        addContextMenuItem('Вставить столбец справа', () => {
                            insertColumn(columnIndex + 1);
                        });
                        addContextMenuSeparator();
                    }

                    if (headers.length > 1) {
                        addContextMenuItem('Переместить столбец', () => {
                            showMoveColumnDialog(columnIndex);
                        });
                        addContextMenuSeparator();
                    }

                    if (headers.length >= 1) { // Can delete if at least one column exists
                        addContextMenuItem('Удалить столбец', () => {
                            if (confirm(`Вы уверены, что хотите удалить столбец "${headers[columnIndex]}"?`)) {
                                deleteColumn(columnIndex);
                            }
                        });
                    }
                } else if (elementType === 'cell' && data.length > 0) {
                    const rowIndex = parseInt(element.dataset.row);
                    const columnIndex = parseInt(element.dataset.col);

                    addContextMenuItem('Редактировать ячейку', () => {
                        editCell(element, rowIndex, columnIndex);
                    });
                    addContextMenuSeparator();

                    addContextMenuItem('Вставить строку выше', () => {
                        insertRow(rowIndex);
                    });
                    addContextMenuItem('Вставить строку ниже', () => {
                        insertRow(rowIndex + 1);
                    });

                    if (data.length > 1) {
                        addContextMenuSeparator();
                        addContextMenuItem('Переместить строку', () => {
                            showMoveRowDialog(rowIndex);
                        });
                    }
                    if (data.length >= 1) { // Can delete if at least one row exists
                        if (data.length > 1) addContextMenuSeparator(); // Add separator only if move option was there
                        addContextMenuItem('Удалить строку', () => {
                            if (confirm('Вы уверены, что хотите удалить эту строку?')) {
                                deleteRow(rowIndex);
                            }
                        });
                    }
                }

                if (contextMenu.children.length > 0) {
                    contextMenu.style.top = `${e.pageY}px`;
                    contextMenu.style.left = `${e.pageX}px`;
                    contextMenu.style.display = 'block';

                    const menuRect = contextMenu.getBoundingClientRect();
                    if (menuRect.right > window.innerWidth) {
                        contextMenu.style.left = `${e.pageX - menuRect.width}px`;
                    }
                    if (menuRect.bottom > window.innerHeight) {
                        contextMenu.style.top = `${e.pageY - menuRect.height}px`;
                    }
                }
            }

            function addContextMenuItem(text, handler) {
                const item = document.createElement('div');
                item.className = 'context-menu-item';
                item.textContent = text;
                item.addEventListener('click', handler);
                contextMenu.appendChild(item);
                return item;
            }

            function addContextMenuSeparator() {
                const separator = document.createElement('div');
                separator.className = 'context-menu-separator';
                contextMenu.appendChild(separator);
            }

            function hideContextMenu() {
                contextMenu.style.display = 'none';
                contextMenuTarget = null;
            }

            function showMoveColumnDialog(fromIndex) {
                hideContextMenu();

                const dialog = document.getElementById('move-column-dialog');
                 // Clear previous content and re-create, or ensure dynamic parts are updated
                const dialogContent = `
                    <h3 class="dialog-title">Переместить столбец</h3>
                    <p>Выберите, ПЕРЕД каким столбцом переместить столбец "${headers[fromIndex]}":</p>
                    <div style="margin-top: 10px;">
                        <select id="column-to-select" style="width: 100%;">
                            ${headers.map((header, idx) =>
                                `<option value="${idx}" ${idx === fromIndex ? 'disabled' : ''}>${header}</option>`
                            ).join('')}
                            <option value="${headers.length}">В конец таблицы</option>
                        </select>
                    </div>
                    <div class="dialog-buttons">
                        <button id="move-column-cancel">Отмена</button>
                        <button id="move-column-confirm">Переместить</button>
                    </div>
                `;
                dialog.innerHTML = dialogContent; // Re-populate innerHTML

                dialogOverlay.style.display = 'block';
                dialog.style.display = 'block';

                const cancelBtn = dialog.querySelector('#move-column-cancel');
                const confirmBtn = dialog.querySelector('#move-column-confirm');
                const toSelect = dialog.querySelector('#column-to-select');

                // Add event listeners (remove old ones if they persist, or ensure one-time add)
                // For simplicity, re-adding assuming dialog.innerHTML clears old listeners on its children.
                cancelBtn.onclick = () => { // Use onclick to easily override
                    dialogOverlay.style.display = 'none';
                    dialog.style.display = 'none';
                };

                confirmBtn.onclick = () => {
                    const toIndex = parseInt(toSelect.value);
                    moveColumn(fromIndex, toIndex);
                    dialogOverlay.style.display = 'none';
                    dialog.style.display = 'none';
                };
            }

            function showUpdateSeparatorDialog() {
                hideContextMenu();

                const dialog = document.getElementById('update-separator-dialog');
                dialogOverlay.style.display = 'block';
                dialog.style.display = 'block';

                const cancelBtn = dialog.querySelector('#update-separator-cancel');
                const confirmBtn = dialog.querySelector('#update-separator-confirm');
                const customSeparatorInput = dialog.querySelector('#new-custom-separator');

                cancelBtn.onclick = () => {
                    dialogOverlay.style.display = 'none';
                    dialog.style.display = 'none';
                };

                confirmBtn.onclick = () => {
                    const selectedSeparator = dialog.querySelector('input[name="new-separator"]:checked').value;
                    let newSeparator;

                    if (selectedSeparator === 'custom') {
                        newSeparator = customSeparatorInput.value || ';';
                    } else if (selectedSeparator === '\\t') {
                        newSeparator = '\t';
                    } else {
                        newSeparator = selectedSeparator;
                    }

                    updateTableWithNewSeparator(newSeparator);
                    dialogOverlay.style.display = 'none';
                    dialog.style.display = 'none';
                };

                dialog.querySelector('#new-custom').onchange = () => { // Use onchange
                    customSeparatorInput.focus();
                };
            }

            function updateTableWithNewSeparator(newSeparator) {
                // This function assumes data and headers are correctly populated
                // It effectively re-parses the current data as if it were a CSV string
                // with the old separator, then parses it with the new one.
                // A more direct way might be needed if cell values themselves contain the old separator
                // in a way that split/join would corrupt them.
                // However, for simple cases, this might simulate the "change separator" effect.

                // Let's re-think this. If data is already an array of arrays,
                // changing the separator is mostly for saving or for re-interpreting a raw string.
                // If we just want to change `currentSeparator` for future saves, that's simpler.
                // The original intent might have been to re-split rows if they were mis-parsed.
                // For now, we'll just update `currentSeparator` and re-render.
                // The `parseCSV` function would need the raw text again to truly re-parse.
                // So, this function will primarily update the `currentSeparator` for saving.
                
                // If the goal is to re-interpret the *currently displayed data* with a new separator,
                // that would imply joining all cells of a row with the *old* separator,
                // then splitting that string with the *new* separator. This can change column counts.
                // This seems complex and potentially destructive if not what the user expects.

                // Let's assume the primary goal is to change the separator for future "Save" operations
                // and to update the status bar.
                if (currentSeparator !== null) { // Only if it was a text file
                    currentSeparator = newSeparator;
                    modified = true; // The "way" it's saved has changed.
                    renderTable(false); // Re-render might not be strictly needed unless UI depends on currentSeparator
                    updateStatusBar(`Разделитель для сохранения обновлен на "${newSeparator === '\t' ? 'Табуляция' : newSeparator === ' ' ? 'Пробел' : newSeparator}"`);
                }
            }

            function showMoveRowDialog(fromIndex) {
                hideContextMenu();

                const dialog = document.getElementById('move-row-dialog');
                const dialogContent = `
                    <h3 class="dialog-title">Переместить строку</h3>
                    <p>Выберите, ПЕРЕД какой строкой переместить строку ${fromIndex + 1}:</p>
                    <div style="margin-top: 10px;">
                        <select id="row-to-select" style="width: 100%;">
                            ${data.map((_, idx) =>
                                `<option value="${idx}" ${idx === fromIndex ? 'disabled' : ''}>Строка ${idx + 1}</option>`
                            ).join('')}
                            <option value="${data.length}">В конец таблицы</option>
                        </select>
                    </div>
                    <div class="dialog-buttons">
                        <button id="move-row-cancel">Отмена</button>
                        <button id="move-row-confirm">Переместить</button>
                    </div>
                `;
                dialog.innerHTML = dialogContent;

                dialogOverlay.style.display = 'block';
                dialog.style.display = 'block';

                const cancelBtn = dialog.querySelector('#move-row-cancel');
                const confirmBtn = dialog.querySelector('#move-row-confirm');
                const toSelect = dialog.querySelector('#row-to-select');

                cancelBtn.onclick = () => {
                    dialogOverlay.style.display = 'none';
                    dialog.style.display = 'none';
                };

                confirmBtn.onclick = () => {
                    const toIndex = parseInt(toSelect.value);
                    moveRow(fromIndex, toIndex);
                    dialogOverlay.style.display = 'none';
                    dialog.style.display = 'none';
                };
            }

            function moveRow(fromIndex, toIndex) {
                if (fromIndex === toIndex || fromIndex < 0 || fromIndex >= data.length || toIndex < 0 || toIndex > data.length) {
                     // Also check if toIndex is trying to move to its own spot if toIndex is adjusted.
                    if (toIndex === fromIndex + 1 && fromIndex < toIndex) { /* moving to just after itself, effectively no move */ }
                    else if (toIndex === fromIndex && fromIndex > toIndex) { /* moving to just before itself, effectively no move */ }
                    else { return; }
                }

                const rowToMove = data.splice(fromIndex, 1)[0];

                // If moving to a position after the original, the target index effectively shifts down.
                // No adjustment needed if splice inserts before the target index.
                data.splice(toIndex > fromIndex ? toIndex -1 : toIndex, 0, rowToMove);


                modified = true;
                renderTable(false);
                updateStatusBar('Строка перемещена');
            }
            
            function showReplaceEmptyDialog(columnIndex) {
    hideContextMenu();
    
    const dialogOverlay = document.getElementById('dialog-overlay');
    const dialog = document.getElementById('replace-empty-dialog');
    const cancelBtn = document.getElementById('replace-empty-cancel');
    const confirmBtn = document.getElementById('replace-empty-confirm');
    const textInput = document.getElementById('replace-empty-text');

    textInput.value = ''; // Очищаем поле ввода
    dialogOverlay.style.display = 'block';
    dialog.style.display = 'block';
    textInput.focus();

    cancelBtn.onclick = () => { // Use onclick for simplicity in replacing handlers
        dialogOverlay.style.display = 'none';
        dialog.style.display = 'none';
    };

    confirmBtn.onclick = () => { // Use onclick
        const replacementText = textInput.value;
        replaceEmptyCells(columnIndex, replacementText);
        dialogOverlay.style.display = 'none';
        dialog.style.display = 'none';
    };

    textInput.onkeydown = (e) => { // Use onkeydown
        if (e.key === 'Enter') {
            confirmBtn.click();
        }
    };
}

function replaceEmptyCells(columnIndex, replacementText) {
    let changesMade = false;
    
    data.forEach(row => {
        if (row[columnIndex] === null || row[columnIndex] === undefined || String(row[columnIndex]).trim() === '') {
            row[columnIndex] = replacementText;
            changesMade = true;
        }
    });

    if (changesMade) {
        modified = true;
        renderTable(false);
        updateStatusBar(`Пустые значения в столбце "${headers[columnIndex]}" заменены на "${replacementText}"`);
    } else {
        updateStatusBar(`В столбце "${headers[columnIndex]}" нет пустых значений или замен`);
    }
}

            function moveColumn(fromIndex, toIndex) {
                 if (fromIndex === toIndex || fromIndex < 0 || fromIndex >= headers.length || toIndex < 0 || toIndex > headers.length) {
                     // Check if toIndex is trying to move to its own spot after adjustment
                    if (toIndex === fromIndex + 1 && fromIndex < toIndex) { /* no move */ }
                    else if (toIndex === fromIndex && fromIndex > toIndex) { /* no move */ }
                    else { return; }
                }


                const headerToMove = headers.splice(fromIndex, 1)[0];
                headers.splice(toIndex > fromIndex ? toIndex - 1 : toIndex, 0, headerToMove);


                data.forEach(row => {
                    const cellToMove = row.splice(fromIndex, 1)[0];
                    row.splice(toIndex > fromIndex ? toIndex - 1 : toIndex, 0, cellToMove);
                });

                modified = true;
                renderTable(false); 
                updateStatusBar('Столбец перемещен');
            }

            function insertColumn(index) {
                const newColumnName = `Столбец ${headers.length + 1}`; // Name before adding
                headers.splice(index, 0, newColumnName);

                data.forEach(row => {
                    row.splice(index, 0, '');
                });

                modified = true;
                renderTable(true); // Adjust widths for new column
                updateStatusBar('Добавлен новый столбец');
            }

            function deleteColumn(index) {
                if (index < 0 || index >= headers.length) return;

                headers.splice(index, 1);

                data.forEach(row => {
                    if (row.length > index) {
                        row.splice(index, 1);
                    }
                });

                modified = true;
                if (headers.length === 0) { // If all columns deleted
                    data = []; // Clear data as well
                }
                renderTable(true); // Adjust widths
                updateStatusBar('Столбец удален');
            }

            function insertRow(index) {
                const newRow = new Array(headers.length).fill('');
                data.splice(index, 0, newRow);

                modified = true;
                renderTable(false);
                updateStatusBar('Добавлена новая строка');
            }

            function deleteRow(index) {
                if (index < 0 || index >= data.length) return;

                data.splice(index, 1);

                modified = true;
                renderTable(false);
                updateStatusBar('Строка удалена');
                 if (data.length === 0 && headers.length === 0) { // If table becomes completely empty
                    dataTable.style.display = 'none';
                    emptyState.style.display = 'flex';
                }
            }

            function saveFile(filename, separator, format = 'csv') {
                if (headers.length === 0 && data.length === 0) {
                    alert("Нет данных для сохранения.");
                    return;
                }

                if (format === 'xlsx') {
                    saveAsXLSX(filename || 'table.xlsx');
                    return;
                }
                
                const effectiveFilename = filename || (format === 'csv' ? 'table.csv' : 'table.txt');
                const effectiveSeparator = separator || (currentSeparator !== null ? currentSeparator : ';');


                let contentToSave = format === 'csv' ? "data:text/csv;charset=utf-8," : "data:text/plain;charset=utf-8,";

                let headerString = headers.map(header => formatCellValue(header, effectiveSeparator)).join(effectiveSeparator);
                contentToSave += headerString + '\r\n';

                data.forEach(row => {
                    let rowString = row.map(cell => formatCellValue(cell, effectiveSeparator)).join(effectiveSeparator);
                    contentToSave += rowString + '\r\n';
                });

                let encodedUri = encodeURI(contentToSave);
                let link = document.createElement("a");
                link.setAttribute("href", encodedUri);
                link.setAttribute("download", effectiveFilename);
                document.body.appendChild(link);

                link.click();

                document.body.removeChild(link);
                currentFilename = effectiveFilename; // Update currentFilename if it was generic
                currentSeparator = effectiveSeparator; // Update currentSeparator if it was generic for this save
                updateStatusBar(`Файл сохранен: ${effectiveFilename}`);
                modified = false;
            }

            function saveAsXLSX(filename) {
                const wb = XLSX.utils.book_new();
                // Ensure headers are present even if data is empty (but headers exist)
                const tableData = (headers.length > 0) ? [headers, ...data] : [...data];
                if (tableData.length === 0) {
                     alert("Нет данных для сохранения в XLSX.");
                     return;
                }
                const ws = XLSX.utils.aoa_to_sheet(tableData);
                XLSX.utils.book_append_sheet(wb, ws, "Sheet1");
                XLSX.writeFile(wb, filename);
                currentFilename = filename;
                currentSeparator = null; // XLSX doesn't use a separator
                updateStatusBar(`Файл сохранен: ${filename}`);
                modified = false;
            }

            function formatCellValue(value, separator) {
                if (value === null || value === undefined) return '';
                let strValue = String(value);
                // Quote if it contains the separator, double quotes, or newlines
                if (strValue.includes(separator) || strValue.includes('"') || strValue.includes('\n') || strValue.includes('\r')) {
                    strValue = '"' + strValue.replace(/"/g, '""') + '"';
                }
                return strValue;
            }

            function showSaveDialog() {
                if (headers.length === 0 && data.length === 0) {
                    alert("Нет данных для сохранения.");
                    return;
                }
                hideContextMenu(); // Hide context menu if it's open
                dialogOverlay.style.display = 'block';
                saveDialog.style.display = 'block';

                // Ensure XLSX option exists
                let hasXlsxOption = Array.from(saveFormat.options).some(opt => opt.value === 'xlsx');
                if (!hasXlsxOption) {
                    const xlsxOption = document.createElement('option');
                    xlsxOption.value = 'xlsx';
                    xlsxOption.textContent = 'Excel (XLSX)';
                    saveFormat.appendChild(xlsxOption);
                }

                // Set default save format and separator based on current file or defaults
                if (currentFilename) {
                    if (currentFilename.endsWith('.csv')) saveFormat.value = 'csv';
                    else if (currentFilename.endsWith('.txt')) saveFormat.value = 'txt';
                    else if (currentFilename.endsWith('.xlsx')) saveFormat.value = 'xlsx';
                    else saveFormat.value = 'csv'; // Default for unknown extension
                } else {
                    saveFormat.value = 'csv'; // Default if no file loaded yet
                }

                if (currentSeparator === '\t') {
                    saveSeparator.value = '\\t';
                } else if (currentSeparator === ',' || currentSeparator === ';' || currentSeparator === ' ') {
                    saveSeparator.value = currentSeparator;
                } else if (currentSeparator) { // Any other custom separator
                    saveSeparator.value = 'custom';
                    saveCustomSeparator.value = currentSeparator;
                    saveCustomSeparator.style.display = 'inline';
                } else { // Default if no currentSeparator (e.g. new table or XLSX loaded)
                    saveSeparator.value = ';';
                    saveCustomSeparator.style.display = 'none';
                }
                
                // Toggle separator visibility based on selected format
                const separatorContainer = document.getElementById('separator-container');
                separatorContainer.style.display = saveFormat.value === 'xlsx' ? 'none' : 'block';
            }

            function hideSaveDialog() {
                dialogOverlay.style.display = 'none';
                saveDialog.style.display = 'none';
            }

            function applyFilter() {
                if (data.length === 0 && headers.length === 0) { // If table is truly empty
                    updateStatusBar(lastActionMessage, 0);
                    return;
                }


                const filterText = filterInput.value.trim().toLowerCase();
                const filterMode = filterModeToggle.checked ? 'row' : 'cell'; // checked = 'строка', unchecked = 'ячейка'
                const filterTerms = filterText.split(/\s+/).filter(term => term); 

                const rows = tableBody.querySelectorAll('tr');
                let visibleRowCount = 0;

                rows.forEach(rowElement => { // Renamed 'row' to 'rowElement' to avoid conflict with 'row' data array
                    const rowIndex = parseInt(rowElement.dataset.index);
                     if (rowIndex >= data.length || data[rowIndex] === undefined) { // Safety check
                        rowElement.style.display = 'none'; // Hide rows that might not exist in data anymore
                        return;
                    }
                    const rowData = data[rowIndex];
                    let isMatch = true; 

                    if (filterTerms.length > 0) {
                        if (filterMode === 'cell') {
                            isMatch = false; 
                            for (const cellValue of rowData) {
                                const cellString = String(cellValue).toLowerCase();
                                const cellContainsAllTerms = filterTerms.every(term => cellString.includes(term));
                                if (cellContainsAllTerms) {
                                    isMatch = true;
                                    break; 
                                }
                            }
                        } else { // filterMode === 'row'
                            const rowString = rowData.map(String).join(' ').toLowerCase(); 
                            isMatch = filterTerms.every(term => rowString.includes(term));
                        }
                    }

                    if (isMatch) {
                        rowElement.style.display = '';
                        visibleRowCount++;
                    } else {
                        rowElement.style.display = 'none';
                    }
                });
                updateStatusBar(lastActionMessage, visibleRowCount);
            }


            function updateStatusBar(message, visibleRowCount) {
                lastActionMessage = message; // Store the operational message
                let statusText = message;
                
                if (currentFilename) {
                    statusText += ` | Файл: ${currentFilename}`;
                    if (currentFileSize !== null) {
                        statusText += ` (${currentFileSize} КБ)`;
                    }
                }
                 statusText += ` | Строк: ${data.length}, Столбцов: ${headers.length}`;

                const totalRows = data.length;
                // Use provided visibleRowCount if available, otherwise calculate or use totalRows
                const currentVisible = (visibleRowCount !== undefined) ? visibleRowCount : totalRows;


                if (filterInput.value.trim() && totalRows > 0) { // Show filter count only if filter is active and there's data
                     statusText += ` | Показано: ${currentVisible} из ${totalRows}`;
                }
                statusMessage.textContent = statusText;
            }

            // Initial render for empty state
            renderTable();
        });
    </script>
</body>
</html>