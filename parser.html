<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link id="favicon" rel="icon" href="https://i.ibb.co/Kx9BG3kP/exchange.png" type="image/png">
    <title>КПТ XML в JSON</title>
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <script src="webfonts/jszip.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');

        :root {
            --bg-primary: #2c2f33;
            --bg-secondary: #23272a;
            --bg-input: #3b3f45;
            --bg-card: #282b30;
            --text-primary: #ffffff;
            --text-secondary: #b9bbbe;
            --text-placeholder: #72767d;
            --accent-primary: #7289da; /* Discord-like blue/purple */
            --accent-primary-hover: #677bc4;
            --accent-secondary: #43b581; /* Green */
            --accent-secondary-hover: #3aa070;
            --border-color: #40444b;
            --error-color: #f04747;
            --font-family: 'Inter', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: var(--font-family);
            background-color: var(--bg-primary);
            color: var(--text-primary);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            padding: 20px;
            font-size: 15px;
        }

        .container {
            background-color: var(--bg-card);
            padding: 30px 35px;
            border-radius: 8px;
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.3);
            width: 100%;
            max-width: 550px;
        }

        h1 {
            color: var(--text-primary);
            text-align: center;
            margin-bottom: 30px;
            font-size: 1.9em;
            font-weight: 700;
            letter-spacing: -0.5px;
        }

        .input-group {
            margin-bottom: 22px;
        }

        .input-group label {
            display: block;
            margin-bottom: 10px;
            font-weight: 500;
            color: var(--text-secondary);
            font-size: 0.9em;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .input-group input[type="text"],
        .input-group input[type="file"] {
            width: 100%;
            padding: 12px 15px;
            background-color: var(--bg-input);
            color: var(--text-primary);
            border: 1px solid var(--border-color);
            border-radius: 5px;
            font-size: 1em;
            transition: border-color 0.2s ease, box-shadow 0.2s ease;
        }

        .input-group input[type="text"]::placeholder {
            color: var(--text-placeholder);
        }

        .input-group input[type="text"]:focus,
        .input-group input[type="file"]:focus {
            outline: none;
            border-color: var(--accent-primary);
            box-shadow: 0 0 0 3px rgba(114, 137, 218, 0.25);
        }

         .input-group input[type="file"] {
            padding: 8px 12px;
            cursor: pointer;
        }
        .input-group input[type="file"]::-webkit-file-upload-button {
            visibility: hidden;
            width: 0;
            height: 0;
            padding: 0; margin:0;
        }
        .input-group input[type="file"]::before {
            content: 'Выберите файл...';
            display: inline-block;
            background: var(--accent-primary);
            color: white;
            border-radius: 3px;
            padding: 6px 12px;
            outline: none;
            white-space: nowrap;
            cursor: pointer;
            font-weight: 500;
            font-size: 0.9em;
            margin-right: 10px;
        }
         .input-group input[type="file"]:hover::before {
            background: var(--accent-primary-hover);
         }
        .input-group input[type="file"]:focus::before {
             box-shadow: 0 0 0 3px rgba(114, 137, 218, 0.3);
        }


        .or-separator {
            text-align: center;
            margin: 30px 0;
            color: var(--text-secondary);
            font-weight: 500;
            position: relative;
        }
        .or-separator::before,
        .or-separator::after {
            content: '';
            position: absolute;
            top: 50%;
            width: 40%;
            height: 1px;
            background-color: var(--border-color);
        }
        .or-separator::before { left: 0; }
        .or-separator::after { right: 0; }


        button#processButton {
            display: flex;
            justify-content: center;
            align-items: center;
            width: 100%;
            padding: 14px;
            background-color: var(--accent-primary);
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 1.1em;
            font-weight: 600;
            transition: background-color 0.2s ease;
            letter-spacing: 0.5px;
        }

        button#processButton:hover:not(:disabled) {
            background-color: var(--accent-primary-hover);
        }
        button#processButton:disabled {
            background-color: #50545c;
            cursor: not-allowed;
        }

        .progress-container {
            margin-top: 25px;
            display: none;
        }

        progress {
            width: 100%;
            height: 10px;
            border-radius: 5px;
            appearance: none;
            background-color: var(--bg-input);
            overflow: hidden;
        }
        progress::-webkit-progress-bar {
            background-color: var(--bg-input);
        }
        progress::-webkit-progress-value {
            background-color: var(--accent-secondary);
            border-radius: 0; /* Remove radius from inner bar for smooth look */
            transition: width 0.3s ease;
        }
        progress::-moz-progress-bar {
            background-color: var(--accent-secondary);
            border-radius: 0;
            transition: width 0.3s ease;
        }


        #statusMessage {
            margin-top: 12px;
            text-align: center;
            font-size: 0.95em;
            min-height: 22px;
            color: var(--text-secondary);
        }
        .status-success { color: var(--accent-secondary) !important; font-weight: 500; }
        .status-error { color: var(--error-color) !important; font-weight: 500; }


        a#downloadJsonLink {
            display: none;
            margin-top: 25px;
            padding: 14px;
            background-color: var(--accent-secondary);
            color: white;
            text-decoration: none;
            border-radius: 5px;
            text-align: center;
            font-size: 1.1em;
            font-weight: 600;
            transition: background-color 0.2s ease;
            letter-spacing: 0.5px;
        }
        a#downloadJsonLink:hover {
            background-color: var(--accent-secondary-hover);
        }

        .spinner {
            border: 3px solid rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            border-top-color: #fff;
            width: 20px;
            height: 20px;
            animation: spin 0.8s linear infinite;
            display: inline-block;
            margin-left: 12px;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

    </style>
</head>
<body>
    <div class="container">
        <h1>КПТ XML в JSON (координаты)</h1>

        <div class="input-group">
            <label for="fileInput">Из файла на компьютере</label>
            <input type="file" id="fileInput" accept=".zip">
        </div>

        <div class="or-separator">ИЛИ</div>

        <div class="input-group">
            <label for="kvartalInput">Из базы по номеру квартала</label>
            <input type="text" id="kvartalInput" placeholder="Например: 16:00:0010101">
        </div>

        <button id="processButton" onclick="handleProcessTrigger()">Обработать</button>

        <div class="progress-container" id="progressContainer">
            <progress id="progressBar" value="0" max="100"></progress>
            <div id="statusMessage"></div>
        </div>
        
        <a id="downloadJsonLink">Скачать результат</a>
    </div>

    <script>
        const SUPABASE_URL = "https://krbqraivfbowmzvucjxz.supabase.co";
        const SUPABASE_ANON_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImtyYnFyYWl2ZmJvd216dnVjanh6Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDU1MDA0MTAsImV4cCI6MjA2MTA3NjQxMH0.Aun2UJDEW_75_Di-2hIcap42gqyZAu2XY9xiZpmShPc";
        const BUCKET_NAME = "gkn";
        const LOG_LEVEL_CONSOLE = "INFO"; // Or "DEBUG" for more verbose chunking logs

        const supabaseClient = supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

        const fileInputElement = document.getElementById('fileInput');
        const kvartalInputElement = document.getElementById('kvartalInput');
        const processButtonElement = document.getElementById('processButton');
        const progressContainerElement = document.getElementById('progressContainer');
        const progressBarElement = document.getElementById('progressBar');
        const statusMessageElement = document.getElementById('statusMessage');
        const downloadLinkElement = document.getElementById('downloadJsonLink');
        const originalButtonText = processButtonElement.textContent.trim();


        function consoleLog(level, message) {
            const upperLevel = level.toUpperCase();
            if (LOG_LEVEL_CONSOLE === "DEBUG" ||
               (LOG_LEVEL_CONSOLE === "INFO" && upperLevel !== "DEBUG") ||
               upperLevel === "ERROR") {
                console.log(`[${upperLevel}] ${message}`);
            }
        }

        function updateStatusMessage(message, type = 'info') {
            statusMessageElement.textContent = message;
            statusMessageElement.className = `status-${type}`;
            consoleLog(type === 'error' ? 'ERROR' : 'INFO', `UI_STATUS: ${message}`);
        }

        function updateProgressBar(value, statusText) {
            progressBarElement.value = value;
            if (statusText) {
                updateStatusMessage(statusText, 'info');
            }
            if (progressContainerElement.style.display !== 'block') {
                 progressContainerElement.style.display = 'block';
            }
        }
        
        function setButtonLoading(isLoading) {
            if (isLoading) {
                processButtonElement.disabled = true;
                processButtonElement.innerHTML = `${originalButtonText} <span class="spinner"></span>`;
            } else {
                processButtonElement.disabled = false;
                processButtonElement.innerHTML = originalButtonText;
            }
        }

        function resetUIState() {
            setButtonLoading(false);
            updateProgressBar(0, 'Готово к работе.');
            if (fileInputElement) fileInputElement.value = '';
            if (downloadLinkElement) downloadLinkElement.style.display = 'none';
        }
        
        function* finditer(regex, text, group = 0) {
            let match;
            const globalRegex = new RegExp(regex.source, regex.flags.includes('g') ? regex.flags : regex.flags + 'g');
            while ((match = globalRegex.exec(text)) !== null) {
                yield match[group];
            }
        }

        // Original parser, used for small files or as a fallback
        function parseXmlAsTextToLightJson(xmlTextContent, xmlFilenameInZip = "unknown.xml") {
            consoleLog("DEBUG", `Начало парсинга XML (полный): ${xmlFilenameInZip}`);
            const objectsData = [];
            const processedObjectIds = new Set(); // Local to this full parse
            let cadastralQuarterNumberText = null;

            const matchQuarterBlock = /<cadastral_block>.*?<cadastral_number>([^<]+)<\/cadastral_number>.*?<\/cadastral_block>/s.exec(xmlTextContent);
            if (matchQuarterBlock) {
                const cqnFull = matchQuarterBlock[1].trim();
                if (cqnFull && cqnFull.split(':').length >= 3) {
                    cadastralQuarterNumberText = cqnFull.split(':').slice(0, 3).join(':');
                    consoleLog("INFO", `(Полный) Найден номер квартала: ${cadastralQuarterNumberText}`);
                } else {
                    consoleLog("WARNING", `(Полный) Не удалось извлечь номер квартала из '${cqnFull}'`);
                }
            } else {
                consoleLog("WARNING", "(Полный) Тег <cadastral_block> с <cadastral_number> не найден");
            }

            for (const landRecordText of finditer(/<land_record>(.*?)<\/land_record>/s, xmlTextContent, 1)) {
                const objIdMatch = /<object>.*?<common_data>.*?<cad_number>([^<]+)<\/cad_number>.*?<\/common_data>.*?<\/object>/s.exec(landRecordText);
                if (!objIdMatch) { consoleLog("WARNING", "(Полный) Пропуск land_record: cad_number не найден."); continue; }
                const objId = objIdMatch[1].trim();
                if (!objId) { consoleLog("WARNING", "(Полный) Пропуск land_record: cad_number пуст."); continue; }
                if (processedObjectIds.has(objId)) continue;
                const currentObjectContours = [];
                const contoursLocationMatch = /<contours_location>(.*?)<\/contours_location>/s.exec(landRecordText);
                if (contoursLocationMatch) {
                    const contoursMatch = /<contours>(.*?)<\/contours>/s.exec(contoursLocationMatch[1]);
                    if (contoursMatch) {
                        for (const contourTextInner of finditer(/<contour>(.*?)<\/contour>/s, contoursMatch[1], 1)) {
                            const singleContourPoints = [];
                            for (const ordinateText of finditer(/<ordinate>(.*?)<\/ordinate>/s, contourTextInner, 1)) {
                                const xMatch = /<x>([^<]+)<\/x>/.exec(ordinateText);
                                const yMatch = /<y>([^<]+)<\/y>/.exec(ordinateText);
                                if (xMatch && yMatch) {
                                    try {
                                        const point = { 'x': parseFloat(xMatch[1].trim().replace(',', '.')), 'y': parseFloat(yMatch[1].trim().replace(',', '.')) };
                                        const ordNmbMatch = /<ord_nmb>([^<]+)<\/ord_nmb>/.exec(ordinateText);
                                        if (ordNmbMatch) point['ord_nmb'] = parseInt(ordNmbMatch[1].trim());
                                        const deltaMatch = /<delta_geopoint>([^<]+)<\/delta_geopoint>/.exec(ordinateText);
                                        if (deltaMatch) point['delta'] = parseFloat(deltaMatch[1].trim().replace(',', '.'));
                                        singleContourPoints.push(point);
                                    } catch (e) { consoleLog("WARNING", `(Полный) Ошибка координат parcel '${objId}': ${e.message}`); }
                                }
                            }
                            if (singleContourPoints.length > 0) currentObjectContours.push(singleContourPoints);
                        }
                    }
                }
                if (currentObjectContours.length > 0) {
                    objectsData.push({ "id": objId, "type": "parcel", "contours": currentObjectContours });
                    processedObjectIds.add(objId);
                }
            }
            for (const buildRecordText of finditer(/<build_record>(.*?)<\/build_record>/s, xmlTextContent, 1)) {
                const objIdMatch = /<object>.*?<common_data>.*?<cad_number>([^<]+)<\/cad_number>.*?<\/common_data>.*?<\/object>/s.exec(buildRecordText);
                if (!objIdMatch) { consoleLog("WARNING", "(Полный) Пропуск build_record: cad_number не найден."); continue; }
                const objId = objIdMatch[1].trim();
                if (!objId) { consoleLog("WARNING", "(Полный) Пропуск build_record: cad_number пуст."); continue; }
                if (processedObjectIds.has(objId)) continue;
                const currentObjectContours = [];
                const contoursMatchOuter = /<contours>(.*?)<\/contours>/s.exec(buildRecordText);
                if (contoursMatchOuter) {
                    for (const contourTextInner of finditer(/<contour>(.*?)<\/contour>/s, contoursMatchOuter[1], 1)) {
                        const singleContourPoints = [];
                        for (const ordinateText of finditer(/<ordinate>(.*?)<\/ordinate>/s, contourTextInner, 1)) {
                            const xMatch = /<x>([^<]+)<\/x>/.exec(ordinateText);
                            const yMatch = /<y>([^<]+)<\/y>/.exec(ordinateText);
                            if (xMatch && yMatch) { try { singleContourPoints.push({ 'x': parseFloat(xMatch[1].trim().replace(',', '.')), 'y': parseFloat(yMatch[1].trim().replace(',', '.')) }); } catch (e) { consoleLog("WARNING", `(Полный) Ошибка координат building '${objId}': ${e.message}`); }}
                        }
                        if (singleContourPoints.length > 0) currentObjectContours.push(singleContourPoints);
                    }
                }
                if (currentObjectContours.length > 0) { objectsData.push({ "id": objId, "type": "building", "contours": currentObjectContours }); processedObjectIds.add(objId); }
            }
            for (const constructionRecordText of finditer(/<construction_record>(.*?)<\/construction_record>/s, xmlTextContent, 1)) {
                const objIdMatch = /<object>.*?<common_data>.*?<cad_number>([^<]+)<\/cad_number>.*?<\/common_data>.*?<\/object>/s.exec(constructionRecordText);
                if (!objIdMatch) { consoleLog("WARNING", "(Полный) Пропуск construction_record: cad_number не найден."); continue; }
                const objId = objIdMatch[1].trim();
                if (!objId) { consoleLog("WARNING", "(Полный) Пропуск construction_record: cad_number пуст."); continue; }
                if (processedObjectIds.has(objId)) continue;
                const currentObjectContours = [];
                const contoursTagMatch = /<contours>(.*?)<\/contours>/s.exec(constructionRecordText);
                if (contoursTagMatch) {
                    for (const singleContourTagContent of finditer(/<contour>(.*?)<\/contour>/s, contoursTagMatch[1], 1)) {
                        const entitySpatialMatch = /<entity_spatial>(.*?)<\/entity_spatial>/s.exec(singleContourTagContent); if (!entitySpatialMatch) continue;
                        const spatialsElementsMatch = /<spatials_elements>(.*?)<\/spatials_elements>/s.exec(entitySpatialMatch[1]); if (!spatialsElementsMatch) continue;
                        for (const spatialElementContent of finditer(/<spatial_element>(.*?)<\/spatial_element>/s, spatialsElementsMatch[1], 1)) {
                            const pointsForThisSpatialElement = [];
                            const ordinatesMatchInSpatial = /<ordinates>(.*?)<\/ordinates>/s.exec(spatialElementContent);
                            if (ordinatesMatchInSpatial) {
                                for (const ordinateTextInner of finditer(/<ordinate>(.*?)<\/ordinate>/s, ordinatesMatchInSpatial[1], 1)) {
                                    const xMatch = /<x>([^<]+)<\/x>/.exec(ordinateTextInner); const yMatch = /<y>([^<]+)<\/y>/.exec(ordinateTextInner);
                                    if (xMatch && yMatch) { try { const point = { 'x': parseFloat(xMatch[1].trim().replace(',', '.')), 'y': parseFloat(yMatch[1].trim().replace(',', '.')) }; const ordNmbMatch = /<ord_nmb>([^<]+)<\/ord_nmb>/.exec(ordinateTextInner); if (ordNmbMatch) point['ord_nmb'] = parseInt(ordNmbMatch[1].trim()); const numGeopointMatch = /<num_geopoint>([^<]+)<\/num_geopoint>/.exec(ordinateTextInner); if (numGeopointMatch) point['num_geopoint'] = parseInt(numGeopointMatch[1].trim()); const deltaMatch = /<delta_geopoint>([^<]+)<\/delta_geopoint>/.exec(ordinateTextInner); if (deltaMatch) point['delta'] = parseFloat(deltaMatch[1].trim().replace(',', '.')); pointsForThisSpatialElement.push(point); } catch (e) { consoleLog("WARNING", `(Полный) Ошибка координат construction '${objId}': ${e.message}`); }}
                                }
                            }
                            if (pointsForThisSpatialElement.length > 0) currentObjectContours.push(pointsForThisSpatialElement);
                        }
                    }
                }
                if (currentObjectContours.length > 0) { objectsData.push({ "id": objId, "type": "construction", "contours": currentObjectContours }); processedObjectIds.add(objId); }
            }
            consoleLog("INFO", `(Полный) Парсинг XML завершен. Извлечено объектов: ${objectsData.length}`);
            return { // Return structure consistent with what processAndPackageResult expects
                cadastral_quarter_from_xml: cadastralQuarterNumberText,
                objects: objectsData,
                // total_objects_extracted is objects.length
                // source_xml_name_in_zip is handled by caller
                // parsing_mode is handled by caller
            };
        }

        // Parser for chunks, uses a global set for processedObjectIds
        function parseXmlChunk(xmlTextContent, xmlFilenameInZip, isFirstConceptualChunk, globalProcessedObjectIdsSet) {
            const objectsDataInChunk = [];
            let cadastralQuarterNumberText = null; // Only relevant for the first chunk

            if (isFirstConceptualChunk) {
                const matchQuarterBlock = /<cadastral_block>.*?<cadastral_number>([^<]+)<\/cadastral_number>.*?<\/cadastral_block>/s.exec(xmlTextContent);
                if (matchQuarterBlock) {
                    const cqnFull = matchQuarterBlock[1].trim();
                    if (cqnFull && cqnFull.split(':').length >= 3) {
                        cadastralQuarterNumberText = cqnFull.split(':').slice(0, 3).join(':');
                        consoleLog("INFO", `(Chunk) Найден номер квартала: ${cadastralQuarterNumberText}`);
                    } else { consoleLog("WARNING", `(Chunk) Не удалось извлечь номер квартала из '${cqnFull}'`); }
                } else { consoleLog("WARNING", "(Chunk) Тег <cadastral_block> не найден в первом концептуальном чанке."); }
            }
            // Land Records
            for (const landRecordText of finditer(/<land_record>(.*?)<\/land_record>/s, xmlTextContent, 1)) {
                const objIdMatch = /<object>.*?<common_data>.*?<cad_number>([^<]+)<\/cad_number>.*?<\/common_data>.*?<\/object>/s.exec(landRecordText);
                if (!objIdMatch) { consoleLog("WARNING", "(Chunk) Пропуск land_record: cad_number не найден."); continue; }
                const objId = objIdMatch[1].trim();
                if (!objId) { consoleLog("WARNING", "(Chunk) Пропуск land_record: cad_number пуст."); continue; }
                if (globalProcessedObjectIdsSet.has(objId)) continue;
                const currentObjectContours = [];
                const contoursLocationMatch = /<contours_location>(.*?)<\/contours_location>/s.exec(landRecordText);
                if (contoursLocationMatch) {
                    const contoursMatch = /<contours>(.*?)<\/contours>/s.exec(contoursLocationMatch[1]);
                    if (contoursMatch) {
                        for (const contourTextInner of finditer(/<contour>(.*?)<\/contour>/s, contoursMatch[1], 1)) {
                            const singleContourPoints = [];
                            for (const ordinateText of finditer(/<ordinate>(.*?)<\/ordinate>/s, contourTextInner, 1)) {
                                const xMatch = /<x>([^<]+)<\/x>/.exec(ordinateText); const yMatch = /<y>([^<]+)<\/y>/.exec(ordinateText);
                                if (xMatch && yMatch) { try { const point = { 'x': parseFloat(xMatch[1].trim().replace(',', '.')), 'y': parseFloat(yMatch[1].trim().replace(',', '.')) }; const ordNmbMatch = /<ord_nmb>([^<]+)<\/ord_nmb>/.exec(ordinateText); if (ordNmbMatch) point['ord_nmb'] = parseInt(ordNmbMatch[1].trim()); const deltaMatch = /<delta_geopoint>([^<]+)<\/delta_geopoint>/.exec(ordinateText); if (deltaMatch) point['delta'] = parseFloat(deltaMatch[1].trim().replace(',', '.')); singleContourPoints.push(point); } catch (e) { consoleLog("WARNING", `(Chunk) Ошибка координат parcel '${objId}': ${e.message}`); }}
                            }
                            if (singleContourPoints.length > 0) currentObjectContours.push(singleContourPoints);
                        }
                    }
                }
                if (currentObjectContours.length > 0) { objectsDataInChunk.push({ "id": objId, "type": "parcel", "contours": currentObjectContours }); globalProcessedObjectIdsSet.add(objId); }
            }
            // Build Records
            for (const buildRecordText of finditer(/<build_record>(.*?)<\/build_record>/s, xmlTextContent, 1)) {
                const objIdMatch = /<object>.*?<common_data>.*?<cad_number>([^<]+)<\/cad_number>.*?<\/common_data>.*?<\/object>/s.exec(buildRecordText);
                if (!objIdMatch) { consoleLog("WARNING", "(Chunk) Пропуск build_record: cad_number не найден."); continue; }
                const objId = objIdMatch[1].trim();
                if (!objId) { consoleLog("WARNING", "(Chunk) Пропуск build_record: cad_number пуст."); continue; }
                if (globalProcessedObjectIdsSet.has(objId)) continue;
                const currentObjectContours = [];
                const contoursMatchOuter = /<contours>(.*?)<\/contours>/s.exec(buildRecordText);
                if (contoursMatchOuter) {
                    for (const contourTextInner of finditer(/<contour>(.*?)<\/contour>/s, contoursMatchOuter[1], 1)) {
                        const singleContourPoints = [];
                        for (const ordinateText of finditer(/<ordinate>(.*?)<\/ordinate>/s, contourTextInner, 1)) {
                            const xMatch = /<x>([^<]+)<\/x>/.exec(ordinateText); const yMatch = /<y>([^<]+)<\/y>/.exec(ordinateText);
                            if (xMatch && yMatch) { try { singleContourPoints.push({ 'x': parseFloat(xMatch[1].trim().replace(',', '.')), 'y': parseFloat(yMatch[1].trim().replace(',', '.')) }); } catch (e) { consoleLog("WARNING", `(Chunk) Ошибка координат building '${objId}': ${e.message}`); }}
                        }
                        if (singleContourPoints.length > 0) currentObjectContours.push(singleContourPoints);
                    }
                }
                if (currentObjectContours.length > 0) { objectsDataInChunk.push({ "id": objId, "type": "building", "contours": currentObjectContours }); globalProcessedObjectIdsSet.add(objId); }
            }
            // Construction Records
            for (const constructionRecordText of finditer(/<construction_record>(.*?)<\/construction_record>/s, xmlTextContent, 1)) {
                const objIdMatch = /<object>.*?<common_data>.*?<cad_number>([^<]+)<\/cad_number>.*?<\/common_data>.*?<\/object>/s.exec(constructionRecordText);
                if (!objIdMatch) { consoleLog("WARNING", "(Chunk) Пропуск construction_record: cad_number не найден."); continue; }
                const objId = objIdMatch[1].trim();
                if (!objId) { consoleLog("WARNING", "(Chunk) Пропуск construction_record: cad_number пуст."); continue; }
                if (globalProcessedObjectIdsSet.has(objId)) continue;
                const currentObjectContours = [];
                const contoursTagMatch = /<contours>(.*?)<\/contours>/s.exec(constructionRecordText);
                if (contoursTagMatch) {
                    for (const singleContourTagContent of finditer(/<contour>(.*?)<\/contour>/s, contoursTagMatch[1], 1)) {
                        const entitySpatialMatch = /<entity_spatial>(.*?)<\/entity_spatial>/s.exec(singleContourTagContent); if (!entitySpatialMatch) continue;
                        const spatialsElementsMatch = /<spatials_elements>(.*?)<\/spatials_elements>/s.exec(entitySpatialMatch[1]); if (!spatialsElementsMatch) continue;
                        for (const spatialElementContent of finditer(/<spatial_element>(.*?)<\/spatial_element>/s, spatialsElementsMatch[1], 1)) {
                            const pointsForThisSpatialElement = [];
                            const ordinatesMatchInSpatial = /<ordinates>(.*?)<\/ordinates>/s.exec(spatialElementContent);
                            if (ordinatesMatchInSpatial) {
                                for (const ordinateTextInner of finditer(/<ordinate>(.*?)<\/ordinate>/s, ordinatesMatchInSpatial[1], 1)) {
                                    const xMatch = /<x>([^<]+)<\/x>/.exec(ordinateTextInner); const yMatch = /<y>([^<]+)<\/y>/.exec(ordinateTextInner);
                                    if (xMatch && yMatch) { try { const point = { 'x': parseFloat(xMatch[1].trim().replace(',', '.')), 'y': parseFloat(yMatch[1].trim().replace(',', '.')) }; const ordNmbMatch = /<ord_nmb>([^<]+)<\/ord_nmb>/.exec(ordinateTextInner); if (ordNmbMatch) point['ord_nmb'] = parseInt(ordNmbMatch[1].trim()); const numGeopointMatch = /<num_geopoint>([^<]+)<\/num_geopoint>/.exec(ordinateTextInner); if (numGeopointMatch) point['num_geopoint'] = parseInt(numGeopointMatch[1].trim()); const deltaMatch = /<delta_geopoint>([^<]+)<\/delta_geopoint>/.exec(ordinateTextInner); if (deltaMatch) point['delta'] = parseFloat(deltaMatch[1].trim().replace(',', '.')); pointsForThisSpatialElement.push(point); } catch (e) { consoleLog("WARNING", `(Chunk) Ошибка координат construction '${objId}': ${e.message}`); }}
                                }
                            }
                            if (pointsForThisSpatialElement.length > 0) currentObjectContours.push(pointsForThisSpatialElement);
                        }
                    }
                }
                if (currentObjectContours.length > 0) { objectsDataInChunk.push({ "id": objId, "type": "construction", "contours": currentObjectContours }); globalProcessedObjectIdsSet.add(objId); }
            }
            consoleLog("DEBUG", `(Chunk) Парсинг чанка (${xmlTextContent.length} символов) завершен. Найдено объектов: ${objectsDataInChunk.length}. Всего уникальных ID: ${globalProcessedObjectIdsSet.size}`);
            return {
                cadastral_quarter_from_xml: cadastralQuarterNumberText,
                objects_found_in_chunk: objectsDataInChunk
            };
        }


        async function processAndPackageResult(zipFileBytes, originalZipFilename) {
            let xmlFileNameInZip = "неизвестный XML";
            let globalObjectsData = [];
            let globalProcessedObjectIds = new Set(); // Shared across chunks
            let globalCadastralQuarterNumberText = null;
            let parsingModeSuffix = "_full"; // Default

            try {
                updateProgressBar(20, 'Распаковка архива...');
                const jszip = new JSZip();
                const zip = await jszip.loadAsync(zipFileBytes);
                let xmlFile = null;

                for (const filename in zip.files) {
                    if (filename.toLowerCase().endsWith('.xml') && !zip.files[filename].dir) {
                        xmlFile = zip.files[filename];
                        xmlFileNameInZip = filename;
                        break;
                    }
                }

                if (!xmlFile) {
                    updateStatusMessage('XML файл не найден в исходном архиве.', 'error');
                    return null;
                }

                const uncompressedSize = (xmlFile._data && typeof xmlFile._data.uncompressedSize === 'number') ? xmlFile._data.uncompressedSize : 0;
                consoleLog("INFO", `XML file details: Name: ${xmlFileNameInZip}, Uncompressed Size: ${uncompressedSize} bytes.`);

                const CHUNK_SIZE_THRESHOLD_MB = 450; 
                const CHUNK_SIZE_THRESHOLD_BYTES = CHUNK_SIZE_THRESHOLD_MB * 1024 * 1024;
                const CHUNK_READ_SIZE_BYTES = 25 * 1024 * 1024; // How much to read from Blob at a time
                const CARRY_OVER_HEURISTIC_SIZE_BYTES = Math.floor(CHUNK_READ_SIZE_BYTES * 0.1); // e.g., 10% of CHUNK_READ_SIZE

                if (uncompressedSize < CHUNK_SIZE_THRESHOLD_BYTES || uncompressedSize === 0) { // uncompressedSize can be 0 if not available
                    updateProgressBar(30, `Чтение XML: ${xmlFileNameInZip} (целиком)...`);
                    const xmlTextContent = await xmlFile.async("string"); // This can throw on very large files
                    updateProgressBar(40, `Анализ XML: ${xmlFileNameInZip} (целиком)...`);
                    const parsedResult = parseXmlAsTextToLightJson(xmlTextContent, xmlFileNameInZip);
                    globalObjectsData = parsedResult.objects;
                    globalCadastralQuarterNumberText = parsedResult.cadastral_quarter_from_xml;
                    // For full parsing, processed IDs are internal to parseXmlAsTextToLightJson's scope.
                } else {
                    parsingModeSuffix = "_chunked";
                    consoleLog("INFO", `XML file ${xmlFileNameInZip} (${(uncompressedSize / (1024*1024)).toFixed(2)} MB) > ${CHUNK_SIZE_THRESHOLD_MB}MB. Processing in chunks.`);
                    updateStatusMessage(`Обработка большого XML (${(uncompressedSize / (1024*1024)).toFixed(2)} MB) по частям...`, 'info');
                    
                    const xmlBlob = await xmlFile.async("blob");
                    let offset = 0;
                    let isFirstConceptualChunk = true;
                    let chunkCarryOverBuffer = "";
                    let fileEncoding = "UTF-8"; // Default

                    try { // Encoding detection block
                        const initialSliceEnd = Math.min(2048, xmlBlob.size);
                        if (initialSliceEnd > 0) {
                            const initialSlice = xmlBlob.slice(0, initialSliceEnd);
                            const initialReader = new FileReader();
                            const initialText = await new Promise((resolve, reject) => {
                                initialReader.onload = (e) => resolve(e.target.result);
                                initialReader.onerror = (e) => reject(new Error("Ошибка чтения начала файла для определения кодировки."));
                                initialReader.readAsText(initialSlice); // System default, hope for BOM or UTF-8
                            });
                            const encodingMatch = initialText.match(/<\?xml.*?encoding=["'](.*?)["'].*?\?>/i);
                            if (encodingMatch && encodingMatch[1]) {
                                const detected = encodingMatch[1].toUpperCase();
                                if (detected === "WINDOWS-1251" || detected === "CP1251") fileEncoding = "WINDOWS-1251";
                                else if (detected === "UTF-8") fileEncoding = "UTF-8";
                                // else stick to default UTF-8
                                consoleLog("INFO", `Предполагаемая кодировка из XML: ${fileEncoding} (детектировано: ${detected})`);
                            } else { consoleLog("INFO", `Кодировка не найдена в XML declaration, используется по умолчанию: ${fileEncoding}`);}
                        }
                    } catch (encErr) { consoleLog("WARNING", `Ошибка определения кодировки: ${encErr.message}. Используется: ${fileEncoding}.`); }
                    
                    updateProgressBar(30, `Начало чтения по частям (кодировка: ${fileEncoding})...`);

                    while (offset < xmlBlob.size) {
                        const readStart = offset;
                        const readEnd = Math.min(offset + CHUNK_READ_SIZE_BYTES, xmlBlob.size);
                        const currentFileSlice = xmlBlob.slice(readStart, readEnd);
                        
                        const chunkReader = new FileReader();
                        const newTextFromReader = await new Promise((resolve, reject) => {
                            chunkReader.onload = (e) => resolve(e.target.result);
                            chunkReader.onerror = (e) => reject(new Error("Ошибка чтения части файла: " + chunkReader.error));
                            chunkReader.readAsText(currentFileSlice, fileEncoding);
                        });

                        let textToParseThisIteration = chunkCarryOverBuffer + newTextFromReader;
                        consoleLog("DEBUG", `Прочитано ${newTextFromReader.length} символов. Буфер перед: ${chunkCarryOverBuffer.length}. Всего для парсинга: ${textToParseThisIteration.length}`);
                        chunkCarryOverBuffer = ""; // Clear before potentially repopulating

                        if (readEnd < xmlBlob.size) { // Not the absolute last physical piece of the file
                            let splitPoint = -1;
                            const tagEndings = ["</land_record>", "</build_record>", "</construction_record>"];
                            for (const tag of tagEndings) {
                                splitPoint = Math.max(splitPoint, textToParseThisIteration.lastIndexOf(tag));
                                if (splitPoint !== -1 && textToParseThisIteration.lastIndexOf(tag) === splitPoint) { // if this tag was the maximum
                                     splitPoint += tag.length; // include the tag itself
                                }
                            }

                            if (splitPoint > 0 && splitPoint < textToParseThisIteration.length) {
                                chunkCarryOverBuffer = textToParseThisIteration.substring(splitPoint);
                                textToParseThisIteration = textToParseThisIteration.substring(0, splitPoint);
                                consoleLog("DEBUG", `Разделено по тегу. В парсинг: ${textToParseThisIteration.length}, в буфер переноса: ${chunkCarryOverBuffer.length}`);
                            } else if (textToParseThisIteration.length > CARRY_OVER_HEURISTIC_SIZE_BYTES + CHUNK_READ_SIZE_BYTES * 0.5) { 
                                // Buffer getting large without a clear split, or just one very long text without record ends.
                                // Heuristically carry over a smaller portion to prevent infinite growth if records are malformed or huge.
                                const carryStart = Math.max(0, textToParseThisIteration.length - CARRY_OVER_HEURISTIC_SIZE_BYTES);
                                chunkCarryOverBuffer = textToParseThisIteration.substring(carryStart);
                                textToParseThisIteration = textToParseThisIteration.substring(0, carryStart);
                                consoleLog("DEBUG", `Эвристическое разделение. В парсинг: ${textToParseThisIteration.length}, в буфер переноса: ${chunkCarryOverBuffer.length}`);
                            } else {
                                 // Not splitting, will process current textToParseThisIteration. Next loop newTextFromReader will be added.
                                 // This means chunkCarryOverBuffer remains empty for this path.
                                 consoleLog("DEBUG", `Нет точки разделения, или текст мал. Буфер переноса пуст. В парсинг: ${textToParseThisIteration.length}`);
                            }
                        }
                        
                        const progress = 30 + Math.floor(((readStart + textToParseThisIteration.length) / xmlBlob.size) * 30);
                        updateProgressBar(progress, `Анализ XML: ${xmlFileNameInZip} (часть, ~${Math.round(progress*100/60)}%)...`);
                        
                        const chunkResult = parseXmlChunk(textToParseThisIteration, xmlFileNameInZip, isFirstConceptualChunk, globalProcessedObjectIds);
                        if (isFirstConceptualChunk && chunkResult.cadastral_quarter_from_xml) {
                            globalCadastralQuarterNumberText = chunkResult.cadastral_quarter_from_xml;
                        }
                        globalObjectsData.push(...chunkResult.objects_found_in_chunk);
                        isFirstConceptualChunk = false;
                        offset = readEnd;
                    }

                    if (chunkCarryOverBuffer.length > 0) {
                        consoleLog("DEBUG", `Обработка финального буфера переноса: ${chunkCarryOverBuffer.length} символов.`);
                        updateProgressBar(58, `Анализ XML: ${xmlFileNameInZip} (финальный буфер)...`);
                        const finalBufferResult = parseXmlChunk(chunkCarryOverBuffer, xmlFileNameInZip, isFirstConceptualChunk, globalProcessedObjectIds);
                        if (isFirstConceptualChunk && finalBufferResult.cadastral_quarter_from_xml) globalCadastralQuarterNumberText = finalBufferResult.cadastral_quarter_from_xml; // Unlikely here
                        globalObjectsData.push(...finalBufferResult.objects_found_in_chunk);
                    }
                }
                
                updateProgressBar(60, 'Формирование JSON...');
                const finalJsonStructure = {
                    "source_xml_name_in_zip": xmlFileNameInZip,
                    "cadastral_quarter_from_xml": globalCadastralQuarterNumberText,
                    "total_objects_extracted": globalObjectsData.length,
                    "parsing_mode": "text_regex_javascript" + parsingModeSuffix,
                    "objects": globalObjectsData
                };

                updateProgressBar(80, 'Упаковка результата...');
                let baseFilenameQuarter = "unknown_quarter";
                if (finalJsonStructure.cadastral_quarter_from_xml) {
                    baseFilenameQuarter = finalJsonStructure.cadastral_quarter_from_xml.replace(/:/g, '_');
                } else {
                    const match = originalZipFilename.match(/^(\d{2}[_:]\d{2}[_:]\d{6,7})/);
                    if (match) { baseFilenameQuarter = match[1].replace(/:/g, '_');}
                    else if (kvartalInputElement.value.trim()) { baseFilenameQuarter = kvartalInputElement.value.trim().replace(/:/g, '_');}
                }
                const currentDate = new Date().toISOString().slice(0, 10);
                const outputJsonFilename = `${baseFilenameQuarter}_${currentDate}.json`;
                const outputZipFilename = `${outputJsonFilename}.zip`;

                const outputZip = new JSZip();
                outputZip.file(outputJsonFilename, JSON.stringify(finalJsonStructure, null, 2));
                const outputZipBytes = await outputZip.generateAsync({ type: "blob", compression: "DEFLATE", compressionOptions: { level: 6 } });
                
                updateProgressBar(100, 'Готово к скачиванию!');
                downloadLinkElement.href = URL.createObjectURL(outputZipBytes);
                downloadLinkElement.download = outputZipFilename;
                downloadLinkElement.textContent = `Скачать ${outputZipFilename}`;
                downloadLinkElement.style.display = 'block';
                updateStatusMessage('Обработка успешно завершена!', 'success');
                return outputZipFilename;

            } catch (e) {
                let userMessage = `Ошибка обработки: ${e.message}`;
                if (e.name === 'RangeError' && e.message && e.message.toLowerCase().includes('invalid string length')) {
                    userMessage = `Ошибка: XML-файл (${xmlFileNameInZip || 'файл'}) слишком большой для обработки в браузере как одна строка, даже при попытке частичной обработки.`;
                    consoleLog("ERROR", `Processing error (Invalid string length): XML Name: ${xmlFileNameInZip || 'N/A'}, Error: ${e.stack || e}`);
                } else {
                    consoleLog("ERROR", `Критическая ошибка (${xmlFileNameInZip || 'файл'}): ${e.stack || e}`);
                }
                updateStatusMessage(userMessage, 'error');
                return null;
            }
        }

        async function handleProcessTrigger() {
            if (downloadLinkElement) downloadLinkElement.style.display = 'none';
            setButtonLoading(true);
            progressContainerElement.style.display = 'block';
            updateProgressBar(0, 'Запуск...');

            const localFile = fileInputElement.files[0]; 
            const kvartalNum = kvartalInputElement.value.trim();

            if (localFile) {
                updateProgressBar(5, `Чтение файла: ${localFile.name}...`);
                try {
                    const fileReader = new FileReader();
                    fileReader.onload = async (event) => {
                        await processAndPackageResult(event.target.result, localFile.name);
                        setButtonLoading(false);
                    };
                    fileReader.onerror = () => {
                        updateStatusMessage('Ошибка чтения локального файла.', 'error');
                        setButtonLoading(false);
                    };
                    fileReader.readAsArrayBuffer(localFile);
                } catch (e) {
                    updateStatusMessage(`Ошибка локального файла: ${e.message}`, 'error');
                    setButtonLoading(false);
                }
            } else if (kvartalNum) {
                const parts = kvartalNum.split(':');
                if (!(parts.length === 3 && parts.every(p => /^\d+$/.test(p)) && (parts[2].length >= 6 && parts[2].length <= 7))) {
                    updateStatusMessage("Неверный формат номера квартала.", 'error');
                    setButtonLoading(false);
                    progressContainerElement.style.display = 'none'; 
                    return;
                }
                const q_prefix = parts.join('_');
                updateProgressBar(5, `Поиск в базе для ${kvartalNum}...`);
                try {
                    const { data: listData, error: listError } = await supabaseClient.storage.from(BUCKET_NAME).list("", { search: q_prefix });
                    if (listError) throw new Error(`Ошибка Supabase (список): ${listError.message}`);
                    if (!listData || listData.length === 0) throw new Error(`Файлы для '${q_prefix}' не найдены.`);
                    const matchFiles = listData.map(f => f.name).filter(name => name.startsWith(q_prefix) && name.toLowerCase().endsWith('.zip'));
                    if (matchFiles.length === 0) throw new Error(`ZIP-архивы для '${q_prefix}' не найдены.`);
                    matchFiles.sort((a, b) => b.localeCompare(a)); 
                    const latestFile = matchFiles[0];
                    updateProgressBar(10, `Скачивание: ${latestFile}...`);
                    const { data: fileBlob, error: downloadError } = await supabaseClient.storage.from(BUCKET_NAME).download(latestFile);
                    if (downloadError) throw new Error(`Ошибка Supabase (скачивание): ${downloadError.message}`);
                    if (!fileBlob) throw new Error('Скачанный файл пуст.');
                    const fileBytes = await fileBlob.arrayBuffer();
                    await processAndPackageResult(fileBytes, latestFile);
                } catch (e) {
                    updateStatusMessage(e.message, 'error');
                } finally {
                     setButtonLoading(false);
                }
            } else {
                updateStatusMessage('Выберите файл или введите номер квартала.', 'error');
                setButtonLoading(false);
                progressContainerElement.style.display = 'none';
            }
        }
        
        fileInputElement.addEventListener('change', () => {
            if (fileInputElement.files.length > 0) {
                kvartalInputElement.value = '';
                updateStatusMessage(`Выбран файл: ${fileInputElement.files[0].name}`, 'info');
            }
             if (progressContainerElement.style.display === 'block' && progressBarElement.value === 0 && !statusMessageElement.textContent.startsWith("Выбран файл")){
                updateStatusMessage('Готово к работе.', 'info'); // Clear previous processing messages
            }
            downloadLinkElement.style.display = 'none';
        });
        kvartalInputElement.addEventListener('input', () => {
            if (kvartalInputElement.value.trim() !== '') {
                fileInputElement.value = '';
                updateStatusMessage('Ввод номера квартала...', 'info');
            }
            if (progressContainerElement.style.display === 'block' && progressBarElement.value === 0 && !statusMessageElement.textContent.startsWith("Ввод номера")){
                 updateStatusMessage('Готово к работе.', 'info'); // Clear previous processing messages
            }
            downloadLinkElement.style.display = 'none';
        });

        document.addEventListener('DOMContentLoaded', () => {
            resetUIState();
            progressContainerElement.style.display = 'none';
        });
    </script>
</body>
</html>